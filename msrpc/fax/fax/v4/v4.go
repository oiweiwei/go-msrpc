package fax

import (
	"context"
	"fmt"
	"strings"
	"unicode/utf16"

	dcerpc "github.com/oiweiwei/go-msrpc/dcerpc"
	errors "github.com/oiweiwei/go-msrpc/dcerpc/errors"
	uuid "github.com/oiweiwei/go-msrpc/midl/uuid"
	fax "github.com/oiweiwei/go-msrpc/msrpc/fax"
	ndr "github.com/oiweiwei/go-msrpc/ndr"
)

var (
	_ = context.Background
	_ = fmt.Errorf
	_ = utf16.Encode
	_ = strings.TrimPrefix
	_ = ndr.ZeroString
	_ = (*uuid.UUID)(nil)
	_ = (*dcerpc.SyntaxID)(nil)
	_ = (*errors.Error)(nil)
	_ = fax.GoPackage
)

var (
	// import guard
	GoPackage = "fax"
)

var (
	// Syntax UUID
	FaxSyntaxUUID = &uuid.UUID{TimeLow: 0xea0a3165, TimeMid: 0x4834, TimeHiAndVersion: 0x11d2, ClockSeqHiAndReserved: 0xa6, ClockSeqLow: 0xf8, Node: [6]uint8{0x0, 0xc0, 0x4f, 0xa3, 0x46, 0xcc}}
	// Syntax ID
	FaxSyntaxV4_0 = &dcerpc.SyntaxID{IfUUID: FaxSyntaxUUID, IfVersionMajor: 4, IfVersionMinor: 0}
)

// fax interface.
type FaxClient interface {

	// The fax client application calls the FAX_GetServicePrinters (Opnum 0) method to obtain
	// a list of printers that are visible to the fax server.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The client's fax user account does not have the                |
	//	|                                    | FAX_ACCESS_QUERY_CONFIG access rights required for this operation.               |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NOT_ENOUGH_MEMORY 0x00000008 | Not enough storage is available to process this command. The fax server failed   |
	//	|                                    | to allocate sufficient memory to hold the array of FAX_PRINTER_INFOW structures  |
	//	|                                    | to be returned to the client.                                                    |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. The lpBuffer parameter is set to a NULL pointer      |
	//	|                                    | value.<136>                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INTERNAL_ERROR 0x0000054F    | The fax server failed to custom marshal the array of FAX_PRINTER_INFOW           |
	//	|                                    | structures to be returned to the client.                                         |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	GetServicePrinters(context.Context, *GetServicePrintersRequest, ...dcerpc.CallOption) (*GetServicePrintersResponse, error)

	// The FAX_ConnectionRefCount (Opnum 1) method is called by the client.<73>
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The Connect parameter is set to a value of 0x00000001          |
	//	|                                    | (Connect), and the client's fax user account does not have the                   |
	//	|                                    | ALL_FAX_USER_ACCESS_RIGHTS access rights required for the connect operation.     |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. This error code is returned if any of the following  |
	//	|                                    | conditions are met: § The Connect parameter is set to a value of 0x00000000      |
	//	|                                    | (Disconnect) or to a value of 0x00000002 (Release), and the Handle parameter is  |
	//	|                                    | set to a NULL value.<75> § The Connect parameter is set to a value of 0x00000001 |
	//	|                                    | (Connect), and the CanShare parameter is set to a NULL pointer value.<76> §      |
	//	|                                    | The Connect parameter is set to a value other than 0x00000000 (Disconnect),      |
	//	|                                    | 0x00000001 (Connect), or 0x00000002 (Release).                                   |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Fax clients call this method to connect or disconnect from the fax server.
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	ConnectionReferenceCount(context.Context, *ConnectionReferenceCountRequest, ...dcerpc.CallOption) (*ConnectionReferenceCountResponse, error)

	// The FAX_OpenPort (Opnum 2) method is called by the client. In response, the server
	// opens a fax port for subsequent use in other fax methods, and it returns a fax port
	// handle for use by the fax client application.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied: the client's fax user account does not have either the         |
	//	|                                    | FAX_ACCESS_QUERY_CONFIG or the FAX_ACCESS_MANAGE_CONFIG access permissions.      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_HANDLE 0x00000006    | The call was made with the Flags argument containing the PORT_OPEN_MODIFY flag   |
	//	|                                    | and the port is already opened to be modified by another call.                   |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_BAD_UNIT 0x00000014          | The system cannot find the port for the receiving device by using the line       |
	//	|                                    | identifier specified by the DeviceId argument.                                   |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The FaxPortHandle argument is NULL.<140>                                         |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	OpenPort(context.Context, *OpenPortRequest, ...dcerpc.CallOption) (*OpenPortResponse, error)

	// The FAX_ClosePort (Opnum 3) method is called by the client to close an open fax port.
	// The client passes FaxPortHandle, which it received from a call to FAX_OpenPort (section
	// 3.1.4.1.65).
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_HANDLE 0x00000006    | FaxPortHandle is not a valid open port handle returned by FAX_OpenPort. <71>     |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The RPC_FAX_PORT_HANDLE fax data type referenced by the FaxPortHandle parameter  |
	//	|                                    | is set to a NULL pointer value.<72>                                              |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol [MS-RPCE].
	ClosePort(context.Context, *ClosePortRequest, ...dcerpc.CallOption) (*ClosePortResponse, error)

	// The FAX_EnumJobs (Opnum 4) method is called by the client to enumerate all the fax
	// jobs on the specified fax server.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The client's fax user account does not have the                |
	//	|                                    | FAX_ACCESS_QUERY_JOBS access right.                                              |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NOT_ENOUGH_MEMORY 0x00000008 | The server cannot allocate sufficient memory to hold the array of FAX_JOB_ENTRY  |
	//	|                                    | (section 2.2.5) structures to be returned to the client.                         |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. The Buffer parameter is set to a NULL pointer        |
	//	|                                    | value.<87>                                                                       |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INTERNAL_ERROR 0x0000054F    | The server failed to custom marshal the array of FAX_JOB_ENTRY to be returned to |
	//	|                                    | the client.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	EnumJobs(context.Context, *EnumJobsRequest, ...dcerpc.CallOption) (*EnumJobsResponse, error)

	// The FAX_GetJob (Opnum 5) method is called by the client to retrieve information regarding
	// a specific job. The job is specified by the JobId parameter. The value for the JobId
	// parameter can be obtained using one of the following methods: FAX_EnumJobs (section
	// 3.1.4.1.21), FAX_EnumJobsEx (section 3.1.4.1.22), or FAX_EnumJobsEx2 (section 3.1.4.1.23).
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | The client's fax user account does not have access to query the job specified    |
	//	|                                    | by the JobId parameter. This error can happen in any of the following cases: §   |
	//	|                                    | The job specified by the JobId parameter is an outgoing job; the client (the fax |
	//	|                                    | user account currently logged in on the client) is not the owner of this job and |
	//	|                                    | does not have the FAX_ACCESS_QUERY_OUT_JOBS access rights. § The job specified   |
	//	|                                    | by the JobId parameter is an incoming job; incoming faxes are not public and     |
	//	|                                    | the client's fax user account does not have the FAX_ACCESS_MANAGE_RECEIVE_FOLDER |
	//	|                                    | rights.                                                                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NOT_ENOUGH_MEMORY 0x00000008 | The server cannot allocate sufficient memory to hold the FAX_JOB_ENTRY (section  |
	//	|                                    | 2.2.5) structure to be returned to the client.                                   |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. This error code is returned if any of the following  |
	//	|                                    | conditions are met: § The Buffer parameter is set to a NULL pointer value.<110>  |
	//	|                                    | § The fax job specified by the JobId parameter cannot be found (does not         |
	//	|                                    | exist) in the fax server queue. § The fax job specified by JobId cannot be       |
	//	|                                    | queried: the job type is JT_BROADCAST, JS_DELETING, or JS_COMPLETED. For more    |
	//	|                                    | information about job types, see the description of the dwJobType member of the  |
	//	|                                    | FAX_JOB_STATUS (section 2.2.36) structure.                                       |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INTERNAL_ERROR 0x0000054F    | The server failed to custom marshal the FAX_JOB_ENTRY to be returned to the      |
	//	|                                    | client.                                                                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	GetJob(context.Context, *GetJobRequest, ...dcerpc.CallOption) (*GetJobResponse, error)

	// The FAX_SetJob (Opnum 6) method is called by the client. The value for the JobId
	// parameter can be obtained using one of the following methods: FAX_EnumJobs (section
	// 3.1.4.1.21), FAX_EnumJobsEx (section 3.1.4.1.22), or FAX_EnumJobsEx2 (section 3.1.4.1.23).
	//
	// On success, the server MUST pause, resume, cancel, or restart the specified fax job
	// and MUST set the job status (section 3.1.1) to reflect the new job state.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The client's fax user account does not have the access rights  |
	//	|                                    | required to perform this operation: § For an outgoing fax job, the client's fax  |
	//	|                                    | user account is not the owner of the fax job and the client's fax user account   |
	//	|                                    | does not have the FAX_ACCESS_MANAGE_OUT_JOBS rights. § For an incoming fax job,  |
	//	|                                    | incoming faxes are not public, and the client's fax user account does not have   |
	//	|                                    | the FAX_ACCESS_MANAGE_RECEIVE_FOLDER rights.                                     |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. This error code is returned under any of the         |
	//	|                                    | following conditions: § The fax job indicated by the JobId argument cannot be    |
	//	|                                    | found by the fax server. § The specified Command argument value is JC_DELETE and |
	//	|                                    | the fax job specified by the JobId argument indicates a fax job that is already  |
	//	|                                    | in a state of being deleted or was already deleted. § The specified Command      |
	//	|                                    | argument value is JC_UNKNOWN (0). § The specified Command argument value is not  |
	//	|                                    | JC_DELETE, JC_PAUSE, or JC_RESUME/JC_RESTART. § The specified Command argument   |
	//	|                                    | value is JC_DELETE and the type of the fax job specified by the JobId parameter  |
	//	|                                    | is JT_BROADCAST See the definition of the dwJobType member of the FAX_JOB_STATUS |
	//	|                                    | structure (section 2.2.36).                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_OPERATION 0x000010DD | The specified Command argument value is JC_DELETE, and the specified JobId       |
	//	|                                    | represents a fax job with a current job status other than JS_PENDING or          |
	//	|                                    | JS_RETRYING.                                                                     |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	SetJob(context.Context, *SetJobRequest, ...dcerpc.CallOption) (*SetJobResponse, error)

	// The FAX_GetPageData (Opnum 7) method is called by the client to retrieve data in
	// the first page of an outgoing fax job. The information that is returned in the buffer
	// is an in-memory copy of the first page of the TIFF file. The value for the JobId
	// parameter can be obtained using one of the following methods: FAX_EnumJobs (section
	// 3.1.4.1.21), FAX_EnumJobsEx (section 3.1.4.1.22), or FAX_EnumJobsEx2 (section 3.1.4.1.23).
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The caller does not have the access rights required for this   |
	//	|                                    | operation: ALL_FAX_USER_ACCESS_RIGHTS (section 2.2.83).                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NOT_ENOUGH_MEMORY 0x00000008 | Not enough storage is available to process this command.                         |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_DATA 0x0000000D      | The job identified by the JobId parameter is not an outgoing fax job or is not   |
	//	|                                    | a valid fax job for which the fax server can extract the first page of the TIFF  |
	//	|                                    | file.                                                                            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. This error code is returned under any of the         |
	//	|                                    | following conditions: § One or more of the following parameters are null         |
	//	|                                    | pointers: Buffer, ImageWidth, ImageHeight.<120> § The fax server cannot find the |
	//	|                                    | fax job indicated by JobId.                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	GetPageData(context.Context, *GetPageDataRequest, ...dcerpc.CallOption) (*GetPageDataResponse, error)

	// The FAX_GetDeviceStatus (Opnum 8) method is called by the client to retrieve information
	// about a specified fax device (port).
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The client's fax user account does not have the                |
	//	|                                    | FAX_ACCESS_QUERY_CONFIG access rights required for this operation.               |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NOT_ENOUGH_MEMORY 0x00000008 | The server cannot allocate sufficient memory to hold the FAX_DEVICE_STATUS to be |
	//	|                                    | returned to the client.                                                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_DATA 0x0000000D      | The FaxPortHandle parameter is not set to a valid port handle obtained using     |
	//	|                                    | FAX_OpenPort.<106>                                                               |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. This error code is returned under any of the         |
	//	|                                    | following conditions: § The StatusBuffer parameter is set to a NULL pointer      |
	//	|                                    | value.<107> § The FaxPortHandle parameter is set to a NULL value.<108>           |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INTERNAL_ERROR 0x0000054F    | The server failed to custom marshal the FAX_DEVICE_STATUS to be returned to the  |
	//	|                                    | client.                                                                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	GetDeviceStatus(context.Context, *GetDeviceStatusRequest, ...dcerpc.CallOption) (*GetDeviceStatusResponse, error)

	// The FAX_Abort (Opnum 9) method is called by the client to abort the specified fax
	// job on the server. The value for the JobId parameter can be obtained using one of
	// the following methods: FAX_EnumJobs (section 3.1.4.1.21), FAX_EnumJobsEx (section
	// 3.1.4.1.22), or FAX_EnumJobsEx2 (section 3.1.4.1.23).
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return either one of the following error codes, one of the fax-specific errors
	// that are defined in section 2.2.52, or one of the other standard errors defined in
	// [MS-ERREF] section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. This error code is returned when any of the following          |
	//	|                                    | conditions happen: § The client's fax user account does not have                 |
	//	|                                    | FAX_ACCESS_MANAGE_RECEIVE_FOLDER permission, and the specified JobId             |
	//	|                                    | represents an incoming fax job. § The client's fax user account does not have    |
	//	|                                    | FAX_ACCESS_MANAGE_OUT_JOBS permission, and the specified JobId represents an     |
	//	|                                    | outgoing fax job of a different user.                                            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. This error code is returned under any of the         |
	//	|                                    | following conditions: § The fax job identified by the specified JobId is not     |
	//	|                                    | found. § The specified job has already been canceled or is in the process of     |
	//	|                                    | being canceled. § The type of the fax job specified by the JobId parameter is    |
	//	|                                    | JT_BROADCAST (the description of the dwJobType member of the FAX_JOB_STATUS      |
	//	|                                    | structure specified in section 2.2.36).                                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_OPERATION 0x000010DD | The operation is invalid. This error code is returned under any of the following |
	//	|                                    | conditions: § The specified JobId represents an incoming fax job (the dwJobType  |
	//	|                                    | member of the FAX_JOB_STATUS describing the job is set to 0x0002), which is      |
	//	|                                    | being routed (the dwQueueStatus member of the FAX_JOB_STATUS describing the job  |
	//	|                                    | is set to JS_ROUTING) and cannot be aborted at this stage. § The specified JobId |
	//	|                                    | represents a fax job in progress (the dwJobType member of the FAX_JOB_STATUS     |
	//	|                                    | describing the job is set to 0x0003), which the fax server failed to route       |
	//	|                                    | (the dwQueueStatus member of the FAX_JOB_STATUS describing the job is set to     |
	//	|                                    | JS_IN_PROGRESS) and cannot be aborted at this stage.                             |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol [MS-RPCE].
	Abort(context.Context, *AbortRequest, ...dcerpc.CallOption) (*AbortResponse, error)

	// The FAX_EnumPorts (Opnum 10) method is called by the client to obtain port state
	// information.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The client's fax user account does not have the access rights  |
	//	|                                    | (FAX_ACCESS_QUERY_CONFIG) required for this operation.                           |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NOT_ENOUGH_MEMORY 0x00000008 | Not enough storage is available to process this command. The fax server cannot   |
	//	|                                    | allocate sufficient memory to hold the array of _FAX_PORT_INFO to be returned to |
	//	|                                    | the client.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. This error code is returned if any of the following  |
	//	|                                    | conditions are met:<95> § The PortBuffer parameter is set to a NULL pointer      |
	//	|                                    | value. § The PortsReturned parameter is set to a NULL pointer value.             |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INTERNAL_ERROR 0x0000054F    | The fax server failed to custom marshal the array of _FAX_PORT_INFO to be        |
	//	|                                    | returned to the client.                                                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	EnumPorts(context.Context, *EnumPortsRequest, ...dcerpc.CallOption) (*EnumPortsResponse, error)

	// The FAX_GetPort (Opnum 11) method is called by the client to retrieve port status
	// information for a requested port at the server.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The client's fax user account does not have the                |
	//	|                                    | FAX_ACCESS_QUERY_CONFIG access rights required for this operation.               |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NOT_ENOUGH_MEMORY 0x00000008 | The server cannot allocate sufficient memory to hold the FAX_PORT_INFO (section  |
	//	|                                    | 2.2.7) data structure to be returned to the client.                              |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_DATA 0x0000000D      | The FaxPortHandle parameter is not set to a valid port handle obtained using     |
	//	|                                    | FAX_OpenPort.<124>                                                               |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. This error code is returned if any of the following  |
	//	|                                    | conditions are met: § The PortBuffer parameter is set to a NULL pointer          |
	//	|                                    | value.<125> § The FaxPortHandle parameter is set to NULL.<126>                   |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INTERNAL_ERROR 0x0000054F    | The server failed to custom marshal the FAX_PORT_INFO to be returned to the      |
	//	|                                    | client.                                                                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	GetPort(context.Context, *GetPortRequest, ...dcerpc.CallOption) (*GetPortResponse, error)

	// A fax client application uses the FAX_SetPort (Opnum 12) method to set fax device
	// information. The function sets extension configuration properties that are stored
	// at the device level, such as enabling or disabling sending and receiving, and the
	// auto or manual answering of calls.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	|                    RETURN                    |                                                                                  |
	//	|                  VALUE/CODE                  |                                   DESCRIPTION                                    |
	//	|                                              |                                                                                  |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005               | Access is denied. The client's fax user account does not have the                |
	//	|                                              | FAX_ACCESS_MANAGE_CONFIG fax access right.                                       |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_DATA 0x0000000D                | The handle specified by the FaxPortHandle argument is not a valid fax port       |
	//	|                                              | handle obtained by a call to FAX_OpenPort.<166>                                  |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057           | The parameter is incorrect. This error code is returned if any of the following  |
	//	|                                              | conditions are met: § The pointer specified by the PortInfo argument is NULL.    |
	//	|                                              | § The handle specified by the FaxPortHandle argument is NULL. § The requested    |
	//	|                                              | value of the Priority member of the PortInfo parameter is 0, or is greater than  |
	//	|                                              | the total number of installed fax devices. § The size of the PortInfo argument   |
	//	|                                              | specified in the SizeOfStruct field is not the correct size, in bytes, for the   |
	//	|                                              | FAX_PORT_INFO. § When FAX_ERR_DEVICE_NUM_LIMIT_EXCEEDED is to be returned, but   |
	//	|                                              | the fax client does not support this error code (the fax client API version      |
	//	|                                              | described in section 3.1.4.1.10 is FAX_API_VERSION_0).                           |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ERR_DEVICE_NUM_LIMIT_EXCEEDED 0x00001B62 | The fax server cannot complete the operation because all of the following        |
	//	|                                              | conditions are true: If the fax server has an implementation-dependent maximum   |
	//	|                                              | number of supported devices set<167> and the number of fax devices currently     |
	//	|                                              | connected to the server is equal to or exceeds this maximum number of supported  |
	//	|                                              | devices. The device is not send, receive, or manual-receive enabled.             |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol [MS-RPCE].
	SetPort(context.Context, *SetPortRequest, ...dcerpc.CallOption) (*SetPortResponse, error)

	// The FAX_EnumRoutingMethods (Opnum 13) method is called by the client to enumerate
	// all the routing methods for a specified port that are registered with the fax server
	// in the fax server's list of routing methods. The client calls Fax_OpenPort (section
	// 3.1.4.1.65) to get the value for FaxPortHandle. The function returns detailed information
	// about each of the enumerated routing methods.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_FUNCTION 0x00000001  | The fax server failed to enumerate any routing methods for the fax port          |
	//	|                                    | specified through the FaxPortHandle parameter.                                   |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The client's fax user account does not have the access rights  |
	//	|                                    | (FAX_ACCESS_QUERY_CONFIG) required for this operation.                           |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NOT_ENOUGH_MEMORY 0x00000008 | Not enough storage is available to process this command. The fax server cannot   |
	//	|                                    | allocate sufficient memory to hold the array of FAX_ROUTING_METHOD to be         |
	//	|                                    | returned to the client.                                                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_DATA 0x0000000D      | This error SHOULD be returned if the FaxPortHandle argument is not a valid       |
	//	|                                    | handle obtained using FAX_OpenPort.<99>                                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The RoutingInfoBuffer parameter is set to a NULL pointer value. <100>            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INTERNAL_ERROR 0x0000054F    | The fax server failed to custom marshal the array of FAX_ROUTING_METHOD          |
	//	|                                    | structures to be returned to the client.                                         |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	EnumRoutingMethods(context.Context, *EnumRoutingMethodsRequest, ...dcerpc.CallOption) (*EnumRoutingMethodsResponse, error)

	// The FAX_EnableRoutingMethod (Opnum 14) method is called by the client for a specified
	// fax device (port).
	//
	// The user is expected to set the proper configuration settings on the client before
	// enabling any routing method. For example, in order to enable email, the user SHOULD
	// specify the proper SMTP details, and the client SHOULD then call the FAX_SetReceiptsConfiguration
	// (section 3.1.4.1.91) method, with the bIsToUseForMSRouteThroughEmailMethod value
	// in the pReceipts parameter set to true. Also, the user can ensure that the proper
	// routing method destinations, such as EmailID, Printer, and Folder values, have been
	// specified. The client can use the FAX_SetExtensionData (section 3.1.4.1.79) method
	// to set the EmailID, Printer, and Folder once the user has entered the proper values.
	//
	// On success, the server MUST enable or disable a fax routing method for a specific
	// fax device. The server MUST validate that the client's fax user account has access
	// to enable or disable routing methods. The RoutingGUID parameter MUST be for a valid
	// routing method.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The client's fax user account does not have the                |
	//	|                                    | FAX_ACCESS_MANAGE_CONFIG access right.                                           |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_DATA 0x0000000D      | The data is invalid. The GUID specified by the RoutingGuid parameter is not a    |
	//	|                                    | routing method GUID.                                                             |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. This is returned when RoutingGuid is set to NULL.    |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	EnableRoutingMethod(context.Context, *EnableRoutingMethodRequest, ...dcerpc.CallOption) (*EnableRoutingMethodResponse, error)

	// The FAX_GetRoutingInfo (Opnum 15) method is called by the client to retrieve information
	// about a specified routing method that is identified by the passed-in GUID.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The client's fax user account does not have the                |
	//	|                                    | FAX_ACCESS_QUERY_CONFIG access rights required for this operation.               |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NOT_ENOUGH_MEMORY 0x00000008 | The server cannot allocate sufficient memory to hold the fax routing information |
	//	|                                    | data to be returned to the client.                                               |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_DATA 0x0000000D      | This error code is returned if any of the following conditions are met: § The    |
	//	|                                    | port handle specified by the FaxPortHandle parameter is not a valid fax port     |
	//	|                                    | handle obtained with FAX_OpenPort (section 3.1.4.1.65).<131> § The server cannot |
	//	|                                    | find the routing method identified by the GUID specified by the RoutingGuid      |
	//	|                                    | parameter.                                                                       |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. This error code is returned if any of the following  |
	//	|                                    | conditions are met: § The RoutingGuid parameter is set to a NULL pointer value.  |
	//	|                                    | § The RoutingInfoBuffer parameter is set to a NULL pointer value.<132> § The     |
	//	|                                    | FaxPortHandle parameter is set to a NULL value.<133>                             |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	GetRoutingInfo(context.Context, *GetRoutingInfoRequest, ...dcerpc.CallOption) (*GetRoutingInfoResponse, error)

	// The FAX_SetRoutingInfo (Opnum 16) method is called by the client to set routing information
	// for a fax routing method.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | The client's fax user account does not have the FAX_ACCESS_MANAGE_CONFIG         |
	//	|                                    | permission.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_DATA 0x0000000D      | This error code is returned if any of the following conditions are met: § The    |
	//	|                                    | FaxPortHandle parameter is not set to a valid fax port handle obtained with      |
	//	|                                    | FAX_OpenPort. § The RoutingGuid parameter is not set to a GUID representing a    |
	//	|                                    | valid routing method.                                                            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | This error code is returned if any of the following conditions are met: § The    |
	//	|                                    | RoutingGuid parameter is set to a NULL pointer value. § The RoutingInfoBuffer    |
	//	|                                    | parameter is set to a NULL pointer value. § The RoutingInfoBufferSize parameter  |
	//	|                                    | is set to a value of 0. § The FaxPortHandle parameter is set to a NULL           |
	//	|                                    | value.<172>                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	SetRoutingInfo(context.Context, *SetRoutingInfoRequest, ...dcerpc.CallOption) (*SetRoutingInfoResponse, error)

	// The FAX_EnumGlobalRoutingInfo (Opnum 17) method is called by the client to enumerate
	// global routing information.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_FUNCTION 0x00000001  | The server failed to enumerate the routing methods.                              |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The client's fax user account does not have the                |
	//	|                                    | FAX_ACCESS_QUERY_CONFIG access rights required for this operation.               |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NOT_ENOUGH_MEMORY 0x00000008 | The server cannot allocate sufficient memory to hold the array of                |
	//	|                                    | _FAX_GLOBAL_ROUTING_INFOW structures to be returned to the client.               |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The RoutingInfoBuffer parameter is set to a NULL pointer value.<86>              |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INTERNAL_ERROR 0x0000054F    | The server failed to custom marshal the array of _FAX_GLOBAL_ROUTING_INFOW       |
	//	|                                    | structures to be returned to the client.                                         |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	EnumGlobalRoutingInfo(context.Context, *EnumGlobalRoutingInfoRequest, ...dcerpc.CallOption) (*EnumGlobalRoutingInfoResponse, error)

	// The fax client application calls the FAX_SetGlobalRoutingInfo (Opnum 18) method to
	// set global routing properties such as the routing method priority.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The client's fax user account does not have the required       |
	//	|                                    | FAX_ACCESS_MANAGE_CONFIG authorization for this operation.                       |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_DATA 0x0000000D      | The fax server cannot find the routing method specified by the Guid structure    |
	//	|                                    | field of the RoutingInfo parameter.                                              |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. This error code is returned if any of the following  |
	//	|                                    | conditions are met: § The RoutingInfo parameter is set to a NULL pointer value.  |
	//	|                                    | § The SizeOfStruct structure field of RoutingInfo is not set to the correct      |
	//	|                                    | size, in bytes, for the FAX_GLOBAL_ROUTING_INFOW structure.                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol [MS-RPCE].
	SetGlobalRoutingInfo(context.Context, *SetGlobalRoutingInfoRequest, ...dcerpc.CallOption) (*SetGlobalRoutingInfoResponse, error)

	// The FAX_GetConfiguration (Opnum 19) method is called by the client to query the general
	// configuration of the fax server that is described by the _FAX_CONFIGURATIONW (section
	// 2.2.29) structure.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The client's fax user account does not have the                |
	//	|                                    | FAX_ACCESS_QUERY_CONFIG access rights required for this operation.               |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NOT_ENOUGH_MEMORY 0x00000008 | The server cannot allocate sufficient memory to hold the FAX_CONFIGURATION       |
	//	|                                    | (section 2.2.28) data structure to be returned to the client.                    |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The buffer parameter is set to a NULL pointer value.<104>                        |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INTERNAL_ERROR 0x0000054F    | The server failed to custom marshal the FAX_CONFIGURATION to be returned to the  |
	//	|                                    | client.                                                                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	GetConfiguration(context.Context, *GetConfigurationRequest, ...dcerpc.CallOption) (*GetConfigurationResponse, error)

	// The fax client application calls the FAX_SetConfiguration (Opnum 20) method to change
	// the general configuration of the fax server. The FAX_CONFIGURATIONW (section 2.2.28)
	// structure describes the general configuration of the fax server.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The client's fax user account does not have the required       |
	//	|                                    | access rights, in this case FAX_ACCESS_MANAGE_CONFIG.                            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. This error code is returned under any of the         |
	//	|                                    | following conditions: § The pointer specified with the FaxConfig argument is     |
	//	|                                    | NULL.<157> § The dwSizeOfStruct member of the FAX_CONFIGURATIONW specified by    |
	//	|                                    | the FaxConfig parameter is different from the correct size, in bytes, for the    |
	//	|                                    | FAX_CONFIGURATIONW, described in section 2.2.28. § The ArchiveOutgoingFaxes      |
	//	|                                    | member of the FAX_CONFIGURATIONW specified by FaxConfig is set to TRUE, and      |
	//	|                                    | the ArchiveDirectory member of the same data structure is set to a NULL pointer  |
	//	|                                    | value.<158>                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_REGISTRY_CORRUPT 0x000003F7  | The registry is corrupted. The structure of one of the files that contain        |
	//	|                                    | registry data is corrupted, or the system's memory image of the file is          |
	//	|                                    | corrupted, or the file could not be recovered because the alternate copy or log  |
	//	|                                    | was absent or corrupted.                                                         |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol [MS-RPCE].
	SetConfiguration(context.Context, *SetConfigurationRequest, ...dcerpc.CallOption) (*SetConfigurationResponse, error)

	// The FAX_GetLoggingCategories (Opnum 21) method is called by the client. In response,
	// the server MUST return the current logging categories for the fax server to which
	// the client has connected. A logging category determines the errors or other events
	// that the fax server records in the application event log.
	//
	// The client SHOULD free the returned buffer.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	|                RETURN                |                                                                                  |
	//	|              VALUE/CODE              |                                   DESCRIPTION                                    |
	//	|                                      |                                                                                  |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005       | Access is denied. The client's fax user account does not have the                |
	//	|                                      | FAX_ACCESS_QUERY_CONFIG access rights required for this operation.               |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NOT_ENOUGH_MEMORY 0x00000008   | The server cannot allocate sufficient memory to hold the array of                |
	//	|                                      | FAX_LOG_CATEGORY to be returned to the client.                                   |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057   | The parameter is incorrect. This error code is returned if any of the            |
	//	|                                      | following conditions are met: § The BufferSize parameter is set to a NULL        |
	//	|                                      | pointer value.<114> § The NumberCategories parameter is set to a NULL pointer    |
	//	|                                      | value.<115>                                                                      |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ARITHMETIC_OVERFLOW 0x00000216 | This error code is returned if any of the following conditions are met: § The    |
	//	|                                      | total number of logging categories multiplied by the size, in bytes, of the      |
	//	|                                      | FAX_LOG_CATEGORY Fixed_Size block results in a number that exceeds the maximum   |
	//	|                                      | value for a DWORD (0xFFFFFFFF). § The total number of logging categories         |
	//	|                                      | multiplied by the size, in bytes, of the FAX_LOG_CATEGORY Fixed_Size block       |
	//	|                                      | plus the sum of all lengths, in bytes, including NULL terminators, of all Name   |
	//	|                                      | strings from the Variable_Data blocks results in a number that exceeds the       |
	//	|                                      | maximum value for a DWORD (0xFFFFFFFF).                                          |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INTERNAL_ERROR 0x0000054F      | The server failed to custom marshal the array of FAX_LOG_CATEGORY to be returned |
	//	|                                      | to the client.                                                                   |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	GetLoggingCategories(context.Context, *GetLoggingCategoriesRequest, ...dcerpc.CallOption) (*GetLoggingCategoriesResponse, error)

	// The FAX_SetLoggingCategories (Opnum 22) method is called by the client. On success,
	// the server MUST modify the current logging categories for the fax server to which
	// the client has connected. A logging category determines the errors or other events
	// that the fax server records in the application event log.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The client's fax user account does not have the                |
	//	|                                    | FAX_ACCESS_MANAGE_CONFIG access rights required for this call.                   |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. This error code is returned under any of the         |
	//	|                                    | following conditions: § The value specified for the Buffer parameter is NULL. §  |
	//	|                                    | The value specified for the BufferSize parameter is 0. § The fax server cannot   |
	//	|                                    | parse the FAX_LOG_CATEGORY pointed at by Buffer, possibly because the buffer     |
	//	|                                    | data is corrupted. § One of the pointer fields of one of the FAX_LOG_CATEGORY    |
	//	|                                    | pointed at by Buffer point to memory locations outside of the memory block       |
	//	|                                    | specified by the Buffer and BufferSize parameters.                               |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_REGISTRY_CORRUPT 0x000003F7  | The registry is corrupted. The fax server cannot write to register the modified  |
	//	|                                    | logging categories.                                                              |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol [MS-RPCE].
	//
	// The FAX_LOG_CATEGORY array MUST be serialized. For more information, see [MSDN-FAX_LOG_CATEGORY].
	// The variable data fields, such as strings, SHOULD be filled with the offset to the
	// string from the beginning of the buffer and not the actual address.
	SetLoggingCategories(context.Context, *SetLoggingCategoriesRequest, ...dcerpc.CallOption) (*SetLoggingCategoriesResponse, error)

	// The FAX_GetSecurity (Opnum 23) method is called by the client to retrieve information
	// about the fax security descriptor from the fax server.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	|                 RETURN                  |                                                                                  |
	//	|               VALUE/CODE                |                                   DESCRIPTION                                    |
	//	|                                         |                                                                                  |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005          | Access is denied. The client's fax user account does not have a permission level |
	//	|                                         | of at least READ_CONTROL.                                                        |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NOT_ENOUGH_MEMORY 0x00000008      | Not enough storage is available to process this command.                         |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057      | The parameter is incorrect. This is returned when pSecurityDescriptor is NULL.   |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_SECURITY_DESCR 0x0000053A | The security descriptor structure is invalid.                                    |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	GetSecurity(context.Context, *GetSecurityRequest, ...dcerpc.CallOption) (*GetSecurityResponse, error)

	// The FAX_SetSecurity (Opnum 24) method is called by the client. On success, the server
	// MUST set the fax server's security descriptor.
	//
	// Protocol version FAX_API_VERSION_3 (0x00030000) fax servers SHOULD fail this call
	// by returning ERROR_NOT_SUPPORTED (0x00000032). The fax client SHOULD NOT call this
	// method if the protocol version reported by the server is FAX_API_VERSION_3 (0x00030000).
	// For more information, see FAX_ConnectFaxServer (section 3.1.4.1.10). The fax client
	// SHOULD call FAX_SetSecurityEx2 (section 3.1.4.1.95) instead.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The client's fax user account does not have the access         |
	//	|                                    | rights required for this operation. This error code is returned under any        |
	//	|                                    | of the following conditions, listed by required access right: § WRITE_OWNER,     |
	//	|                                    | when the fax server is a FAX_API_VERSION_1 server and the SecurityInformation    |
	//	|                                    | parameter contains the OWNER_SECURITY_INFORMATION value. § WRITE_DAC, when the   |
	//	|                                    | fax server is a FAX_API_VERSION_1 server and SecurityInformation contains the    |
	//	|                                    | GROUP_SECURITY_INFORMATION or DACL_SECURITY_INFORMATION values. § READ_CONTROL,  |
	//	|                                    | when the fax server is a FAX_API_VERSION_2 server and SecurityInformation        |
	//	|                                    | contains the GROUP_SECURITY_INFORMATION, DACL_SECURITY_INFORMATION,              |
	//	|                                    | or OWNER_SECURITY_INFORMATION values. § ACCESS_SYSTEM_SECURITY, when             |
	//	|                                    | SecurityInformation contains the SACL_SECURITY_INFORMATION value.                |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_DATA 0x0000000D      | The data contained in the buffer specified by the pSecurityDescriptor parameter  |
	//	|                                    | is not a valid SECURITY_DESCRIPTOR.                                              |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NOT_SUPPORTED 0x00000032     | The fax server does not support this operation. This error SHOULD be returned by |
	//	|                                    | FAX_API_VERSION_3 servers.                                                       |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. This error code is returned under any of the         |
	//	|                                    | following conditions: § pSecurityInformation is set to a NULL pointer value. §   |
	//	|                                    | The dwBufferSize parameter is set to a value of 0.                               |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_REGISTRY_CORRUPT 0x000003F7  | The registry is corrupted. The structure of one of the files containing registry |
	//	|                                    | data is corrupted, or the system's memory image of the file is corrupted, or     |
	//	|                                    | the file could not be recovered because the alternate copy or log was absent or  |
	//	|                                    | corrupted.                                                                       |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	SetSecurity(context.Context, *SetSecurityRequest, ...dcerpc.CallOption) (*SetSecurityResponse, error)

	// The FAX_AccessCheck (Opnum 25) method is called when the client needs to check whether
	// the client's fax user account has certain access permissions on the server.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The user does not have a valid fax user account on the         |
	//	|                                    | server.<65>                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. The pfAccess argument is NULL,<66> or the access     |
	//	|                                    | mask specified by the AccessMask argument contains invalid fax-specific access   |
	//	|                                    | rights.                                                                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol [MS-RPCE].
	AccessCheck(context.Context, *AccessCheckRequest, ...dcerpc.CallOption) (*AccessCheckResponse, error)

	// The FAX_CheckServerProtSeq (Opnum 26) method is called by the client to validate
	// whether a specified protocol sequence is supported by the server.<70> In response,
	// the server MUST validate the specified protocol sequence.
	//
	// Protocol version FAX_API_VERSION_2 (0x00020000) and FAX_API_VERSION_3 (0x00030000)
	// fax servers SHOULD fail this call by returning ERROR_NOT_SUPPORTED (0x00000032).
	// The fax client SHOULD NOT call this method if the protocol version reported by the
	// server is FAX_API_VERSION_2 (0x00020000) or FAX_API_VERSION_3 (0x00030000). For more
	// information, see FAX_ConnectFaxServer (section 3.1.4.1.10).
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+-----------------------------------------+-------------------------------------------------------------------------------+
	//	|                 RETURN                  |                                                                               |
	//	|               VALUE/CODE                |                                  DESCRIPTION                                  |
	//	|                                         |                                                                               |
	//	+-----------------------------------------+-------------------------------------------------------------------------------+
	//	+-----------------------------------------+-------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057      | The parameter is incorrect. The lpdwProtSeq argument specified is NULL.       |
	//	+-----------------------------------------+-------------------------------------------------------------------------------+
	//	| RPC_S_PROTSEQ_NOT_SUPPORTED 0x0000006A7 | The protocol sequence specified by the lpdwProtSeq argument is not supported. |
	//	+-----------------------------------------+-------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol [MS-RPCE].
	CheckServerProtocolSeq(context.Context, *CheckServerProtocolSeqRequest, ...dcerpc.CallOption) (*CheckServerProtocolSeqResponse, error)

	// The FAX_SendDocumentEx (Opnum 27) method is called by the client.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors (section
	// 2.2.52) or one of the standard errors ([MS-ERREF] section 2.2).
	//
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	|                    RETURN                    |                                                                                  |
	//	|                  VALUE/CODE                  |                                   DESCRIPTION                                    |
	//	|                                              |                                                                                  |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005               | Access is denied. This error is returned when any of the following conditions    |
	//	|                                              | are met: § The limit on the number of recipients for a single fax broadcast      |
	//	|                                              | was reached and FAX_ERR_RECIPIENTS_LIMIT couldn't be returned because this       |
	//	|                                              | error code is unsupported by the fax client API version (FAX_API_VERSION_0       |
	//	|                                              | or FAX_API_VERSION_1, described in section 3.1.4.1.10). § The client's fax       |
	//	|                                              | user account does not have the required access rights to submit the fax:         |
	//	|                                              | FAX_ACCESS_SUBMIT (for FAX_PRIORITY_TYPE_LOW), FAX_ACCESS_SUBMIT_NORMAL          |
	//	|                                              | (for FAX_PRIORITY_TYPE_NORMAL), or FAX_ACCESS_SUBMIT_HIGH (for                   |
	//	|                                              | FAX_PRIORITY_TYPE_HIGH), where the FAX_PRIORITY_TYPE value comes from the        |
	//	|                                              | Priority field of the specified lpJobParams structure.                           |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NOT_ENOUGH_MEMORY 0x00000008           | Not enough storage is available to process this command.                         |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_DATA 0x0000000D                | The file specified by lpcwstrFileName argument is empty (has a size of 0 bytes). |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_WRITE_PROTECT 0x00000013               | The outgoing fax queue is blocked: The queue state is FAX_OUTBOX_BLOCKED as      |
	//	|                                              | described in the FAX_SetQueue (section 3.1.4.1.90) method.                       |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NOT_SUPPORTED 0x00000032               | The fax server SHOULD return this error code when the request described by the   |
	//	|                                              | lpJobParams argument is not supported by the fax server.<152>                    |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057           | The parameter is incorrect. This error code is returned under any of the         |
	//	|                                              | following conditions: § One or more of the following arguments are NULL          |
	//	|                                              | or 0: dwNumRecipients, lpcSenderProfile, lpcRecipientList, lpJobParams,          |
	//	|                                              | lpdwlMessageId, lpdwlRecipientMessageIds,<153>lpcCoverPageInfo. § The file       |
	//	|                                              | name indicated by the lpcstwrFileName argument does not indicate a file          |
	//	|                                              | of the expected TIFF format. § The lpwstrCoverPageFileName field of the          |
	//	|                                              | lpcCoverPageInfo structure is not in the expected COV format. § The Priority     |
	//	|                                              | field of the lpJobParams structure is not one of the following values:           |
	//	|                                              | FAX_PRIORITY_TYPE_LOW, FAX_PRIORITY_TYPE_NORMAL, FAX_PRIORITY_TYPE_HIGH. § The   |
	//	|                                              | requested receipt delivery types are invalid (the dwReceiptDeliveryType field    |
	//	|                                              | of the lpJobParams structure), not DRT_EMAIL, DRT_MSGBOX, and/or DRT_NONE. §     |
	//	|                                              | The fax server tried to return FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU but the client  |
	//	|                                              | fax API version. FAX_API_VERSION_0 (described in section 3.1.4.1.10) does not    |
	//	|                                              | support this error code.                                                         |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_UNSUPPORTED_TYPE 0x0000065E            | Data of this type is not supported. The requested receipt delivery type          |
	//	|                                              | specified by the dwReceiptDeliveryType field of the lpJobParams structure is not |
	//	|                                              | supported by the fax server.                                                     |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU 0x00001B63 | The fax client module API version (described in section 3.1.4.1.10) is           |
	//	|                                              | FAX_API_VERSION_1 or above, and the fax server is running on a version of the    |
	//	|                                              | operating system that does not support the requested operation.<154>             |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ERR_RECIPIENTS_LIMIT 0x00001B65          | The limit on the number of recipients for a single fax broadcast was reached.    |
	//	|                                              | ERROR_ACCESS_DENIED is returned instead of this error code when the client       |
	//	|                                              | does not support it (client-supported fax API version is FAX_API_VERSION_0 or    |
	//	|                                              | FAX_API_VERSION_1, described in section 3.1.4.1.10).                             |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol [MS-RPCE].
	SendDocumentEx(context.Context, *SendDocumentExRequest, ...dcerpc.CallOption) (*SendDocumentExResponse, error)

	// The FAX_EnumJobsEx (Opnum 28) method is called by the client to enumerate a specified
	// set of jobs on the server's queue. The type of jobs to enumerate is described by
	// the dwJobTypes argument.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The client's fax user account does not have any of the         |
	//	|                                    | access rights defined in ALL_FAX_USER_ACCESS_RIGHTS (section 2.2.83) when        |
	//	|                                    | enumerating jobs of type JT_SEND. The client's fax user account does not have    |
	//	|                                    | the FAX_ACCESS_MANAGE_RECEIVE_FOLDER access right when enumerating jobs of type  |
	//	|                                    | JT_RECEIVE or JT_ROUTING.                                                        |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NOT_ENOUGH_MEMORY 0x00000008 | Not enough storage is available to process this command.                         |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | At least one of the following arguments has been specified as NULL: Buffer,      |
	//	|                                    | BufferSize, or lpdwJobs.<88>                                                     |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	EnumJobsEx(context.Context, *EnumJobsExRequest, ...dcerpc.CallOption) (*EnumJobsExResponse, error)

	// The FAX_GetJobEx (Opnum 29) is called by the client to retrieve information about
	// a specified job at the server. The job is identified by the job message ID. The job
	// message ID can be obtained using one of the following methods: FAX_EnumJobs (section
	// 3.1.4.1.21), FAX_EnumJobsEx (section 3.1.4.1.22), or FAX_EnumJobsEx2 (section 3.1.4.1.23).
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	|                RETURN                |                                                                                  |
	//	|              VALUE/CODE              |                                   DESCRIPTION                                    |
	//	|                                      |                                                                                  |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005       | Access is denied. The client's fax user account does not have the access rights  |
	//	|                                      | required for this operation: ALL_FAX_USER_ACCESS_RIGHTS (section 2.2.83).        |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NOT_ENOUGH_MEMORY 0x00000008   | The server cannot allocate memory for the data to be returned to the caller.     |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057   | This error code is returned under any of the following conditions:<111> § The    |
	//	|                                      | pointer submitted for the Buffer argument is NULL. § The pointer submitted for   |
	//	|                                      | the BufferSize argument is NULL.                                                 |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ERR_MESSAGE_NOT_FOUND 0x00001B61 | The fax server cannot find the fax job indicated by the dwlMessageId argument.   |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	GetJobEx(context.Context, *GetJobExRequest, ...dcerpc.CallOption) (*GetJobExResponse, error)

	// The FAX_GetCountryList (Opnum 30) method is called by the client to retrieve the
	// list of country/region information that is defined on the server. TAPI maintains
	// this list, which contains information like the country/region name or country/region
	// ID.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The client's fax user account does not have any of the         |
	//	|                                    | permissions covered by the ALL_FAX_USER_ACCESS_RIGHTS enumeration (section       |
	//	|                                    | 2.2.83).                                                                         |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NOT_ENOUGH_MEMORY 0x00000008 | Not enough storage is available to process this command. The fax server cannot   |
	//	|                                    | allocate sufficient memory to hold the FAX_TAPI_LINECOUNTRY_LISTW to be returned |
	//	|                                    | to the client.                                                                   |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. This error is returned if the Buffer parameter is    |
	//	|                                    | set to a NULL pointer value.<105>                                                |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INTERNAL_ERROR 0x0000054F    | The fax server failed to custom marshal the FAX_TAPI_LINECOUNTRY_LISTW to be     |
	//	|                                    | returned to the client.                                                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	GetCountryList(context.Context, *GetCountryListRequest, ...dcerpc.CallOption) (*GetCountryListResponse, error)

	// The FAX_GetPersonalProfileInfo (Opnum 31) method is called by the client to retrieve
	// information about the personal profile (section 3.1.1) of the sender or the receiver
	// of a fax from the specified fax message that is present in the described message
	// folder. The Folder value MUST be one of the enumerations defined by FAX_ENUM_MESSAGE_FOLDER
	// (section 2.2.2) except FAX_MESSAGE_FOLDER_INBOX. The ProfType value MUST be one of
	// the enumerations that are defined by FAX_ENUM_PERSONAL_PROF_TYPES (section 2.2.4).
	// The dwlMessageId parameter specifies a particular message and can be obtained using
	// the following methods: FAX_EnumJobs (section 3.1.4.1.21), FAX_EnumJobsEx (section
	// 3.1.4.1.22), FAX_EnumMessages (section 3.1.4.1.24), or FAX_EnumMessagesEx (section
	// 3.1.4.1.25).
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	|                RETURN                |                                                                                  |
	//	|              VALUE/CODE              |                                   DESCRIPTION                                    |
	//	|                                      |                                                                                  |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005       | Access is denied. The client's fax user account does not have any of the         |
	//	|                                      | permissions covered by ALL_FAX_USER_ACCESS_RIGHTS.                               |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_BAD_FORMAT 0x0000000B          | The message identified by dwlMessageId is an archived sent message and there was |
	//	|                                      | an error in reading the message file.                                            |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057   | The parameter is incorrect. This error code is returned when any of              |
	//	|                                      | the following conditions happen: § The pointer specified by the Buffer           |
	//	|                                      | parameter is NULL.<122> § The value of the Folder parameter specified is not     |
	//	|                                      | FAX_MESSAGE_FOLDER_QUEUE or FAX_MESSAGE_FOLDER_SENTITEMS.                        |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ERR_SRV_OUTOFMEMORY 0x00001B59   | The fax server failed to allocate memory needed for internal execution of this   |
	//	|                                      | operation.                                                                       |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ERR_MESSAGE_NOT_FOUND 0x00001B61 | This error code is returned when any of the following conditions happen: § The   |
	//	|                                      | message identified by the dwlMessageId parameter is not found. § The dwFolder    |
	//	|                                      | parameter is specified as FAX_MESSAGE_FOLDER_QUEUE, but the message identified   |
	//	|                                      | by dwlMessageId is not an outgoing queued message. § The message identified      |
	//	|                                      | by dwlMessageId is an outgoing queued message being deleted. § The message       |
	//	|                                      | identified by dwlMessageId is an outgoing queued message of a different user,    |
	//	|                                      | and this user does not have FAX_ACCESS_QUERY_OUT_JOBS permission. § The message  |
	//	|                                      | identified by dwlMessageId is an archived sent message of a different user, and  |
	//	|                                      | this user does not have FAX_ACCESS_QUERY_ARCHIVES permission.                    |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	GetPersonalProfileInfo(context.Context, *GetPersonalProfileInfoRequest, ...dcerpc.CallOption) (*GetPersonalProfileInfoResponse, error)

	// The FAX_GetQueueStates (Opnum 32) method is called by the client to retrieve the
	// state of the fax queues at the server.
	//
	// The pdwQueueStates parameter MUST NOT be NULL. On success, the server MUST return
	// the state information about the fax service.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The client's fax user account does not have any of the         |
	//	|                                    | permissions covered by ALL_FAX_USER_ACCESS_RIGHTS (section 2.2.83).              |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. The pdwQueueStates parameter is set to a NULL        |
	//	|                                    | pointer value. <128>                                                             |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	GetQueueStates(context.Context, *GetQueueStatesRequest, ...dcerpc.CallOption) (*GetQueueStatesResponse, error)

	// The fax client application calls the FAX_SetQueue (Opnum 33) method to change the
	// state of the server queue. In response, the server MUST validate whether the client's
	// fax user account has authorization to set the Queue State of the server. On success,
	// the server MUST set its Queue State as specified by the client.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The client's fax user account does not have the required       |
	//	|                                    | FAX_ACCESS_MANAGE_CONFIG authorization for this operation.                       |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_OUTOFMEMORY 0x0000000E       | The fax server cannot allocate sufficient memory for a FAX_EVENT_EX_1 (section   |
	//	|                                    | 2.2.68) structure that describes a FAX_EVENT_QUEUE_TYPE_QUEUE_STATE event to be  |
	//	|                                    | signaled to the client. For more details, see FAX_ClientEventQueueEx (section    |
	//	|                                    | 3.2.4.3).                                                                        |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. The dwQueueStates parameter is set to a              |
	//	|                                    | combination of values that does not contain any of the supported values:         |
	//	|                                    | FAX_INCOMING_BLOCKED, FAX_OUTBOX_BLOCKED, or FAX_OUTBOX_PAUSED.                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_REGISTRY_CORRUPT 0x000003F7  | The registry is corrupted. The structure of one of the files containing registry |
	//	|                                    | data is corrupted, or the system's memory image of the file is corrupted, or     |
	//	|                                    | the file could not be recovered because the alternate copy or log was absent or  |
	//	|                                    | corrupted.                                                                       |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| RPC_E_SYS_CALL_FAILED 0x80010100   | dwQueueStates includes the FAX_OUTBOX_PAUSED value and the fax server cannot     |
	//	|                                    | pause the server queue, or dwQueueStates does not include the FAX_OUTBOX_PAUSED  |
	//	|                                    | value and the fax server cannot resume the server queue.                         |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those thrown by the underlying
	// RPC protocol [MS-RPCE].
	SetQueue(context.Context, *SetQueueRequest, ...dcerpc.CallOption) (*SetQueueResponse, error)

	// The FAX_GetReceiptsConfiguration (Opnum 34) method is called by the client. On success,
	// the server MUST return the receipt configuration information of the fax server.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors ([MS-ERREF] section
	// 2.2).
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The client's fax user account does not have the                |
	//	|                                    | FAX_ACCESS_QUERY_CONFIG access rights required for this operation.               |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NOT_ENOUGH_MEMORY 0x00000008 | Not enough storage is available to process this command. The fax server cannot   |
	//	|                                    | allocate sufficient memory to hold the _FAX_RECEIPTS_CONFIGW to be returned to   |
	//	|                                    | the client.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. The Buffer parameter is set to a NULL pointer        |
	//	|                                    | value.<129>                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INTERNAL_ERROR 0x0000054F    | The fax server failed to custom marshal the _FAX_RECEIPTS_CONFIGW to be returned |
	//	|                                    | to the client.                                                                   |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol [MS-RPCE].
	GetReceiptsConfiguration(context.Context, *GetReceiptsConfigurationRequest, ...dcerpc.CallOption) (*GetReceiptsConfigurationResponse, error)

	// The FAX_SetReceiptsConfiguration (Opnum 35) method is called by the client. On success,
	// the server MUST set the receipt configuration information that is used by the fax
	// server to send delivery receipts for fax transmissions.<169>
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	|                    RETURN                    |                                                                                  |
	//	|                  VALUE/CODE                  |                                   DESCRIPTION                                    |
	//	|                                              |                                                                                  |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005               | Access is denied. The client's fax user account does not have the required       |
	//	|                                              | FAX_ACCESS_MANAGE_CONFIG authorization for this operation.                       |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NOT_SUPPORTED 0x00000032               | The dwAllowedReceipts member of the pReceipts parameter contains the DRT_MSGBOX  |
	//	|                                              | flag value (described in FAX_ENUM_DELIVERY_REPORT_TYPES), and the fax server     |
	//	|                                              | does not support this type of fax receipts.<170>                                 |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057           | The parameter is incorrect. This error code is returned if any of the            |
	//	|                                              | following conditions are met: § The dwSizeOfStruct member of pReceipts           |
	//	|                                              | is not equal to the correct size, in bytes, for the FAX_RECEIPTS_CONFIGW.        |
	//	|                                              | § The dwAllowedReceipts member of pReceipts contains one or more invalid         |
	//	|                                              | flag values (not defined for the FAX_ENUM_DELIVERY_REPORT_TYPES (section         |
	//	|                                              | 2.2.76) enumeration). § The following member values are set in the submitted     |
	//	|                                              | pReceipts: the DRT_EMAIL flag is set within the dwAllowedReceipts member,        |
	//	|                                              | the bIsToUseForMSRouteThroughEmailMethod member is set to FALSE, and the         |
	//	|                                              | lpwstrSMTPPasswordmember is set to a non-NULL pointer value. § In the submitted  |
	//	|                                              | pReceipts, the DRT_EMAIL flag is set within the dwAllowedReceipts member         |
	//	|                                              | or the bIsToUseForMSRouteThroughEmailMethod member is set to TRUE and the        |
	//	|                                              | SMTPAuthOption member is set to a value lower than FAX_SMTP_AUTH_ANONYMOUS       |
	//	|                                              | or greater than FAX_SMTP_AUTH_NTLM. § The fax server tried to return             |
	//	|                                              | FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU but the client fax API version                 |
	//	|                                              | (FAX_API_VERSION_0, described in section 3.1.4.1.10) does not support this error |
	//	|                                              | code.                                                                            |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_REGISTRY_CORRUPT 0x000003F7            | The registry is corrupted. The structure of one of the files containing registry |
	//	|                                              | data is corrupted, or the system's memory image of the file is corrupted, or     |
	//	|                                              | the file could not be recovered because the alternate copy or log was absent or  |
	//	|                                              | corrupted.                                                                       |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU 0x00001B63 | The fax client module API version (described in section 3.1.4.1.10) is           |
	//	|                                              | FAX_API_VERSION_1 or above, and the fax server is running on a version of the    |
	//	|                                              | operating system that does not support the requested operation.<171>             |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol [MS-RPCE].
	SetReceiptsConfiguration(context.Context, *SetReceiptsConfigurationRequest, ...dcerpc.CallOption) (*SetReceiptsConfigurationResponse, error)

	// The FAX_GetReceiptsOptions (Opnum 36) method is called by the client to retrieve
	// the supported receipt options on the server.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return the following error code, one of the fax-specific errors that are
	// defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	|             RETURN             |                                                                                  |
	//	|           VALUE/CODE           |                                   DESCRIPTION                                    |
	//	|                                |                                                                                  |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005 | Access is denied. The client's fax user account does not have any of the         |
	//	|                                | permissions covered by ALL_FAX_USER_ACCESS_RIGHTS (section 2.2.83).              |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol [MS-RPCE].
	GetReceiptsOptions(context.Context, *GetReceiptsOptionsRequest, ...dcerpc.CallOption) (*GetReceiptsOptionsResponse, error)

	// The fax client application calls the FAX_GetVersion (Opnum 37) method to obtain the
	// version of the fax server it is connected to.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return the following error codes, one of the fax-specific errors that are
	// defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	|             RETURN             |                                                                                  |
	//	|           VALUE/CODE           |                                   DESCRIPTION                                    |
	//	|                                |                                                                                  |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005 | Access is denied. The client's fax user account does not have the                |
	//	|                                | ALL_FAX_USER_ACCESS_RIGHTS (section 2.2.83) access rights required for this      |
	//	|                                | operation.                                                                       |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	GetVersion(context.Context, *GetVersionRequest, ...dcerpc.CallOption) (*GetVersionResponse, error)

	// The FAX_GetOutboxConfiguration (Opnum 38) method is called by the client to retrieve
	// the outbox configuration at the server.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The client's fax user account does not have the                |
	//	|                                    | FAX_ACCESS_QUERY_CONFIG access rights required for this operation.               |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NOT_ENOUGH_MEMORY 0x00000008 | Not enough storage is available to process this command. The fax server cannot   |
	//	|                                    | allocate sufficient memory to hold the FAX_OUTBOX_CONFIG to be returned to the   |
	//	|                                    | client.                                                                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. The Buffer parameter is set to a NULL pointer        |
	//	|                                    | value.<119>                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	GetOutboxConfiguration(context.Context, *GetOutboxConfigurationRequest, ...dcerpc.CallOption) (*GetOutboxConfigurationResponse, error)

	// The fax client application calls the FAX_SetOutboxConfiguration (Opnum 39) method
	// to set the current Outbox configuration such as the Discount Time.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The client's fax user account does not have the required       |
	//	|                                    | FAX_ACCESS_MANAGE_CONFIG authorization for this operation.                       |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. This error code is returned if any of the following  |
	//	|                                    | conditions occur: § The dwSizeOfStruct member of the structure pointed at by     |
	//	|                                    | the pOutboxCfg parameter is not the correct size for the FAX_OUTBOX_CONFIG.      |
	//	|                                    | § The dtDiscountStart or dtDiscountEnd members of the structure pointed to by    |
	//	|                                    | pOutboxCfg contain one or more invalid Hour (value greater than 24) or Minute    |
	//	|                                    | (value greater than 60) fields.                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_REGISTRY_CORRUPT 0x000003F7  | The registry is corrupted. The structure of one of the files containing registry |
	//	|                                    | data is corrupted, or the system's memory image of the file is corrupted, or     |
	//	|                                    | the file could not be recovered because the alternate copy or log was absent or  |
	//	|                                    | corrupted.                                                                       |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol [MS-RPCE].
	SetOutboxConfiguration(context.Context, *SetOutboxConfigurationRequest, ...dcerpc.CallOption) (*SetOutboxConfigurationResponse, error)

	// The FAX_GetPersonalCoverPagesOption (Opnum 40) method is called by the client to
	// retrieve information about the supported personal cover-page options.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return the following error code, one of the fax-specific errors that are
	// defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	|             RETURN             |                                                                                  |
	//	|           VALUE/CODE           |                                   DESCRIPTION                                    |
	//	|                                |                                                                                  |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005 | Access is denied. The client's fax user account does not have any of the         |
	//	|                                | permissions covered by ALL_FAX_USER_ACCESS_RIGHTS (section 2.2.83).<121>         |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	GetPersonalCoverPagesOption(context.Context, *GetPersonalCoverPagesOptionRequest, ...dcerpc.CallOption) (*GetPersonalCoverPagesOptionResponse, error)

	// The FAX_GetArchiveConfiguration (Opnum 41) method is called by the client to retrieve
	// the current archive configuration on the fax server. In response, the server returns
	// archive configuration information about the fax server.
	//
	// Protocol version FAX_API_VERSION_3 (0x00030000) fax servers SHOULD fail this call
	// by returning ERROR_NOT_SUPPORTED (0x00000032). The fax client SHOULD NOT call this
	// method if the protocol version reported by the server is FAX_API_VERSION_3 (0x00030000).
	// For more information, see FAX_ConnectFaxServer (section 3.1.4.1.10). The fax client
	// SHOULD call FAX_GetGeneralConfiguration (section 3.1.4.1.40) instead.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The client's fax user account does not have the access rights  |
	//	|                                    | (FAX_ACCESS_QUERY_CONFIG) required for this operation.                           |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. This error code is returned if any of the            |
	//	|                                    | following conditions are met: § The Buffer parameter is set to a NULL            |
	//	|                                    | pointer value. <102> § The value specified for the Folder parameter is not       |
	//	|                                    | FAX_MESSAGE_FOLDER_SENTITEMS or FAX_MESSAGE_FOLDER_INBOX.                        |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NOT_ENOUGH_MEMORY 0x00000008 | Not enough storage is available to process this command. The fax server cannot   |
	//	|                                    | allocate sufficient memory to hold the FAX_ARCHIVE_CONFIGW to be returned to the |
	//	|                                    | client.                                                                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NOT_SUPPORTED 0x00000032     | The fax server does not implement this method. Protocol version                  |
	//	|                                    | FAX_API_VERSION_3 (0x00030000) fax servers SHOULD fail this call by returning    |
	//	|                                    | this error code.                                                                 |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	GetArchiveConfiguration(context.Context, *GetArchiveConfigurationRequest, ...dcerpc.CallOption) (*GetArchiveConfigurationResponse, error)

	// The fax client application calls the FAX_SetArchiveConfiguration (Opnum 42) method
	// to set the archive configuration for a specific fax folder on the fax server.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors (section
	// 2.2.52), or one of the other standard errors ([MS-ERREF] section 2.2).
	//
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	|                RETURN                 |                                                                                  |
	//	|              VALUE/CODE               |                                   DESCRIPTION                                    |
	//	|                                       |                                                                                  |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005        | Access is denied. The client's fax user account does not have the required       |
	//	|                                       | FAX_ACCESS_MANAGE_CONFIG authorization for this operation.                       |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NOT_SUPPORTED 0x00000032        | The fax server does not support this operation. This error code SHOULD be        |
	//	|                                       | returned by the FAX_API_VERSION_3 servers.                                       |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057    | The parameter is incorrect. This error code is returned under any of the         |
	//	|                                       | following conditions: § The dwSizeOfStruct member of the FAX_ARCHIVE_CONFIGW     |
	//	|                                       | specified by the pArchiveCfg parameter is set to an incorrect value. § The       |
	//	|                                       | Folder parameter is set to a value other than FAX_MESSAGE_FOLDER_SENTITEMS and   |
	//	|                                       | FAX_MESSAGE_FOLDER_INBOX. § The bUseArchive member of the FAX_ARCHIVE_CONFIGW    |
	//	|                                       | specified by pArchiveCfg is set to TRUE, and any of the three following          |
	//	|                                       | conditions are also met: § The value of the dwSizeQuotaHighWatermark member      |
	//	|                                       | of the same structure is smaller than the value of the dwSizeQuotaLowWatermark   |
	//	|                                       | member. § The lpcstrFolder member of the same structure is set to NULL. § The    |
	//	|                                       | lpcstrFolder member of the same structure is set to point to an empty character  |
	//	|                                       | string.                                                                          |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_BUFFER_OVERFLOW 0x0000006F      | The file name is too long. The bUseArchive member of the FAX_ARCHIVE_CONFIGW     |
	//	|                                       | specified by pArchiveCfg is set to a value of TRUE, and the length of the file   |
	//	|                                       | name specified by the lpcstrFolder of the same structure is set to a character   |
	//	|                                       | string longer than 180 characters, excluding the length of the null terminator.  |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_REGISTRY_CORRUPT 0x000003F7     | The fax server cannot store the new archive configuration to the registry. The   |
	//	|                                       | registry could be corrupted.                                                     |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ERR_DIRECTORY_IN_USE 0x00001B5F   | The bUseArchive member of the FAX_ARCHIVE_CONFIGW specified by pArchiveCfg is    |
	//	|                                       | set to a value of TRUE, and the file specified by the lpcstrFolder member of     |
	//	|                                       | the same structure is invalid: the directory of the file is the same as the fax  |
	//	|                                       | queue directory.                                                                 |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ERR_FILE_ACCESS_DENIED 0x00001B60 | The bUseArchive member of the FAX_ARCHIVE_CONFIGW specified by pArchiveCfg       |
	//	|                                       | is set to a value of TRUE, and the file specified by the lpcstrFolder member     |
	//	|                                       | of the same structure is invalid: the fax server encountered an access denied    |
	//	|                                       | (ERROR_ACCESS_DENIED) or a sharing violation (ERROR_SHARING_VIOLATION) error     |
	//	|                                       | when attempting to access the file.                                              |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol [MS-RPCE].
	SetArchiveConfiguration(context.Context, *SetArchiveConfigurationRequest, ...dcerpc.CallOption) (*SetArchiveConfigurationResponse, error)

	// The FAX_GetActivityLoggingConfiguration (Opnum 43) method is called by the client
	// to retrieve the current activity logging configuration.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The client's fax user account does not have the access rights  |
	//	|                                    | (FAX_ACCESS_QUERY_CONFIG) required for this operation.                           |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NOT_ENOUGH_MEMORY 0x00000008 | Not enough storage is available to process this command. The fax server cannot   |
	//	|                                    | allocate sufficient memory to hold the _FAX_ACTIVITY_LOGGING_CONFIGW to be       |
	//	|                                    | returned to the client.                                                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The Buffer parameter is set to a NULL pointer value. <101>                       |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INTERNAL_ERROR 0x0000054F    | The fax server failed to custom marshal the _FAX_ACTIVITY_LOGGING_CONFIGW to be  |
	//	|                                    | returned to the client.                                                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	GetActivityLoggingConfiguration(context.Context, *GetActivityLoggingConfigurationRequest, ...dcerpc.CallOption) (*GetActivityLoggingConfigurationResponse, error)

	// The fax client application calls the FAX_SetActivityLoggingConfiguration (Opnum 44)
	// method to set options for activity logging. This includes setting whether entries
	// for incoming and outgoing faxes SHOULD be logged and the location of the log file.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	|                RETURN                 |                                                                                  |
	//	|              VALUE/CODE               |                                   DESCRIPTION                                    |
	//	|                                       |                                                                                  |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005        | Access denied. This error code is returned under any of the following            |
	//	|                                       | conditions: § The client's fax user account does not have the required           |
	//	|                                       | FAX_ACCESS_MANAGE_CONFIG authorization to manage the server configuration. §     |
	//	|                                       | The directory specified by the lpwstrDBPath member of the pActivLogCfg structure |
	//	|                                       | is not a valid fax folder (the fax server does not have rights to create files,  |
	//	|                                       | write to files, enumerate files and/or delete files), the server needs to return |
	//	|                                       | FAX_ERR_FILE_ACCESS_DENIED, and the client does not support this error code.     |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057    | This error code is returned under any of the following conditions: § The         |
	//	|                                       | dwSizeOfStruct member of the FAX_ACTIVITY_LOGGING_CONFIGW specified by the       |
	//	|                                       | pActivLogCfg parameter is set to an incorrect value. The correct size, in bytes, |
	//	|                                       | described in the FAX_ACTIVITY_LOGGING_CONFIGW structure. § The lpwstrDBPath      |
	//	|                                       | field of the structure specified by the pActivLogCfg argument contains an empty  |
	//	|                                       | string or is set to NULL. § The lpwstrDBPath member of the structure specified   |
	//	|                                       | by the pActivLogCfg argument does not indicate a complete path name.             |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_BUFFER_OVERFLOW 0x0000006F      | The file name is too long. The lpwstrDBPath field of the structure specified by  |
	//	|                                       | the pActivityLog argument contains a path name longer than 248 characters, not   |
	//	|                                       | counting the terminating null character.                                         |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_REGISTRY_CORRUPT 0x000003F7     | The fax server cannot store the new activity logging configuration in the        |
	//	|                                       | registry. This error can happen if the registry is corrupted.                    |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ERR_FILE_ACCESS_DENIED 0x00001B60 | This error code is returned under any of the following conditions: § The         |
	//	|                                       | folder specified by the lpwstrDBPath member of the pActivityLog structure        |
	//	|                                       | is not a valid fax folder where the server has rights to create, enumerate,      |
	//	|                                       | write to, and delete files. § The fax server cannot create a new (if different   |
	//	|                                       | from the respective existing file) file specified by the lpwstrDBPath            |
	//	|                                       | member of pActivLogCfg, because the server encountered an access denied          |
	//	|                                       | (ERROR_ACCESS_DENIED) or sharing violation error (ERROR_SHARING_VIOLATION) when  |
	//	|                                       | attempting to create the specified file.                                         |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol [MS-RPCE].
	SetActivityLoggingConfiguration(context.Context, *SetActivityLoggingConfigurationRequest, ...dcerpc.CallOption) (*SetActivityLoggingConfigurationResponse, error)

	// The FAX_EnumerateProviders (Opnum 45) method is called by the client to enumerate
	// all the FSPs installed on the server.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The client's fax user account does not have the                |
	//	|                                    | FAX_ACCESS_QUERY_CONFIG access rights required for this operation.               |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. This error is returned if the BufferSize and/or the  |
	//	|                                    | lpdwNumProviders parameters are set to NULL pointer values.                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INTERNAL_ERROR 0x0000054F    | The fax server failed to custom marshal the array of FAX_DEVICE_PROVIDER_INFO    |
	//	|                                    | structures to be returned to the client.                                         |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ERR_SRV_OUTOFMEMORY 0x00001B59 | The fax server failed to allocate sufficient memory for the return buffer to     |
	//	|                                    | hold the FAX_DEVICE_PROVIDER_INFO to be returned to the client.                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	EnumerateProviders(context.Context, *EnumerateProvidersRequest, ...dcerpc.CallOption) (*EnumerateProvidersResponse, error)

	// The FAX_GetPortEx (Opnum 46) method is called by the client to retrieve port status
	// information for a requested port at the server. The device ID that is passed in SHOULD
	// be obtained from FAX_EnumPorts (section 3.1.4.1.28). This method is an extended version
	// of FAX_GetPort (section 3.1.4.1.51).
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The client's fax user account does not have the                |
	//	|                                    | FAX_ACCESS_QUERY_CONFIG access rights required for this call.                    |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NOT_ENOUGH_MEMORY 0x00000008 | Not enough storage is available to process this command. The fax server cannot   |
	//	|                                    | allocate sufficient memory to hold the FAX_PORT_INFO_EXW (section 2.2.45)        |
	//	|                                    | structure to be returned to the client.                                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_BAD_UNIT 0x00000014          | The system cannot find the port for the receiving device by using the line       |
	//	|                                    | identifier specified by the dwDeviceId argument.                                 |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. The Buffer parameter is set to a NULL pointer        |
	//	|                                    | value.<127>                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INTERNAL_ERROR 0x0000054F    | The fax server failed to custom marshal the FAX_PORT_INFO_EXW to be returned to  |
	//	|                                    | the client.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	GetPortEx(context.Context, *GetPortExRequest, ...dcerpc.CallOption) (*GetPortExResponse, error)

	// A fax client application uses the FAX_SetPortEx (Opnum 47) method to set fax device
	// information. The function sets extension configuration properties that are stored
	// at the device level, such as enable or disable sending and receiving, and the auto
	// or manual answering of calls. The value for the dwDeviceId parameter can be obtained
	// using the FAX_EnumPorts (section 3.1.4.1.28) method or the FAX_EnumPortsEx (section
	// 3.1.4.1.29) method.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	|                    RETURN                    |                                                                                  |
	//	|                  VALUE/CODE                  |                                   DESCRIPTION                                    |
	//	|                                              |                                                                                  |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005               | Access is denied. The caller does not have the required FAX_ACCESS_MANAGE_CONFIG |
	//	|                                              | authorization for this operation.                                                |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_BAD_UNIT 0x00000014                    | The fax server cannot find the device specified by the dwDeviceId parameter.     |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057           | This error code is returned under any of the following conditions: § The         |
	//	|                                              | value of dwDeviceId is zero. § The size of the structure pointed at by           |
	//	|                                              | the pPortInfo parameter, or the value of the dwSizeOfStruct field of this        |
	//	|                                              | structure, do not match the correct size for the FAX_PORT_INFO_EXW. § The        |
	//	|                                              | ReceiveMode field of the structure pointed at by pPortInfo does not contain a    |
	//	|                                              | valid value of the FAX_ENUM_DEVICE_RECEIVE_MODE (section 2.2.55) enumeration.    |
	//	|                                              | § The device specified by dwDeviceId is a virtual device (the Flags field        |
	//	|                                              | of the FAX_PORT_INFO (section 2.2.7) structure is set to FPF_VIRTUAL)            |
	//	|                                              | and the ReceiveMode field of the structure pointed at by pPortInfo is            |
	//	|                                              | FAX_DEVICE_RECEIVE_MODE_MANUAL.                                                  |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_BUFFER_OVERFLOW 0x0000006F             | The length of the lpwstrDescription character string field of the data structure |
	//	|                                              | pointed at by pPortInfo exceeds 253 characters, excluding the length of the NULL |
	//	|                                              | string terminator.                                                               |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_REGISTRY_CORRUPT 0x000003F7            | The fax server cannot store the updated device information to Registry. The      |
	//	|                                              | Registry might be corrupt.                                                       |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ERR_DEVICE_NUM_LIMIT_EXCEEDED 0x00001B62 | The fax server cannot complete the operation because the number of active        |
	//	|                                              | fax devices that are allowed for this version of the operating system was        |
	//	|                                              | exceeded.<168>                                                                   |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol [MS-RPCE].
	SetPortEx(context.Context, *SetPortExRequest, ...dcerpc.CallOption) (*SetPortExResponse, error)

	// The FAX_EnumPortsEx (Opnum 48) method is called by the client to enumerate detailed
	// port state information for each device that is connected to the fax server.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The client's fax user account does not have the access rights  |
	//	|                                    | (FAX_ACCESS_QUERY_CONFIG) required for this operation.                           |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NOT_ENOUGH_MEMORY 0x00000008 | Not enough storage is available to process this command. The fax server cannot   |
	//	|                                    | allocate sufficient memory to hold the array of _FAX_PORT_INFO_EXW to be         |
	//	|                                    | returned to the client.                                                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The Buffer parameter is set to a NULL pointer value. <96>                        |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INTERNAL_ERROR 0x0000054F    | The fax server failed to custom marshal the array of _FAX_PORT_INFO_EXW to be    |
	//	|                                    | returned to the client.                                                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	EnumPortsEx(context.Context, *EnumPortsExRequest, ...dcerpc.CallOption) (*EnumPortsExResponse, error)

	// The FAX_GetExtensionData (Opnum 49) method is called by the client to retrieve the
	// private configuration data for a fax routing extension or a routing method. Such
	// private configuration data is written with a FAX_SetExtensionData (section 3.1.4.1.79)
	// call. The lpcwstrNameGUID parameter MUST be for a valid routing extension or routing
	// method for which the client requests the private data. The value for the dwDeviceId
	// parameter can be obtained from either the FAX_EnumPorts (section 3.1.4.1.28) or the
	// FAX_EnumPortsEx (section 3.1.4.1.29) methods.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_FILE_NOT_FOUND 0x00000002    | The fax server cannot find the requested data.                                   |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The client's fax user account does not have the access rights  |
	//	|                                    | (FAX_ACCESS_QUERY_CONFIG) required for this operation.                           |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. This error code is returned if any of the following  |
	//	|                                    | conditions are met: <109> § The lpcwstrNameGUID parameter is set to a NULL       |
	//	|                                    | pointer value. § The ppData parameter is set to a NULL pointer value. § The      |
	//	|                                    | lpdwDataSize parameter is set to a NULL pointer value. § The lpcwstrNameGUID     |
	//	|                                    | parameter holds an invalid curly-braced GUID string.                             |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_REGISTRY_CORRUPT 0x000003F7  | The registry is corrupted. The structure of one of the files that contain        |
	//	|                                    | registry data is corrupted, or the system's memory image of the file is          |
	//	|                                    | corrupted, or the file could not be recovered because the alternate copy or log  |
	//	|                                    | was absent or corrupted.                                                         |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	GetExtensionData(context.Context, *GetExtensionDataRequest, ...dcerpc.CallOption) (*GetExtensionDataResponse, error)

	// The fax client application calls the FAX_SetExtensionData (Opnum 50) method in order
	// to write the private data for a routing extension or routing method for one or all
	// fax devices installed on the fax server. The corresponding method that the fax client
	// calls to read this private data is FAX_GetExtensionData (section 3.1.4.1.39). The
	// value for the dwDeviceId parameter can be obtained using either the FAX_EnumPorts
	// (section 3.1.4.1.28) or FAX_EnumPortsEx (section 3.1.4.1.29) method. The lpcwstrNameGUID
	// parameter MUST be for a valid routing extension or routing method for which the client
	// requests the private data to be written.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The client's fax user account does not have the required       |
	//	|                                    | FAX_ACCESS_MANAGE_CONFIG authorization for this operation.                       |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. This error code is returned if any of the following  |
	//	|                                    | conditions are met:<161> § The lpcwstrComputerName parameter is set to a NULL    |
	//	|                                    | pointer value. § The lpcwstrNameGUID parameter is set to a NULL pointer value.   |
	//	|                                    | § The pData parameter is set to a NULL pointer value. § The dwDataSize parameter |
	//	|                                    | is set to zero. § The lpcwstrNameGUID parameter holds an invalid curly-braced    |
	//	|                                    | GUID string.                                                                     |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_REGISTRY_CORRUPT 0x000003F7  | The registry is corrupted. The structure of one of the files that contain        |
	//	|                                    | registry data is corrupted, or the system's memory image of the file is          |
	//	|                                    | corrupted, or the file could not be recovered because the alternate copy or log  |
	//	|                                    | was absent or corrupted.                                                         |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol [MS-RPCE].
	SetExtensionData(context.Context, *SetExtensionDataRequest, ...dcerpc.CallOption) (*SetExtensionDataResponse, error)

	// The FAX_AddOutboundGroup (Opnum 51) method is called by the client to add a new outbound
	// routing group.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	|                    RETURN                    |                                                                                  |
	//	|                  VALUE/CODE                  |                                   DESCRIPTION                                    |
	//	|                                              |                                                                                  |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005               | Access is denied. The client's fax user account does not have the                |
	//	|                                              | FAX_ACCESS_MANAGE_CONFIG access rights.                                          |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_DUP_NAME 0x00000034                    | The group name specified by the lpwstrGroupName parameter is "< All devices>".   |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057           | The fax server tried to return FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU, but the client |
	//	|                                              | fax API version FAX_API_VERSION_0 (described in section 3.1.4.1.10) does not     |
	//	|                                              | support this error code.                                                         |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_BUFFER_OVERFLOW 0x0000006F             | The length of the character string specified by the lpwstrGroupName parameter,   |
	//	|                                              | excluding the length of the terminating null terminator, is equal to or greater  |
	//	|                                              | than 128 characters.                                                             |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_REGISTRY_CORRUPT 0x000003F7            | The fax server cannot store the new outbound routing group configuration in the  |
	//	|                                              | registry. The registry could be corrupted.                                       |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU 0x00001B63 | The fax client module API version (described in section 3.1.4.1.10) is           |
	//	|                                              | FAX_API_VERSION_1 or above, and the fax server is running on a version of the    |
	//	|                                              | operating system that does not support the requested operation.<68>              |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those by the underlying RPC protocol
	// [MS-RPCE].
	AddOutboundGroup(context.Context, *AddOutboundGroupRequest, ...dcerpc.CallOption) (*AddOutboundGroupResponse, error)

	// The fax client application calls the FAX_SetOutboundGroup (Opnum 52) method to set
	// a new device list to an existing group. The name of the group to remove is specified
	// using the lpwstrGroupName parameter. The value for lpwstrGroupName can be obtained
	// using FAX_EnumOutboundGroups (section 3.1.4.1.26).
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	|                    RETURN                    |                                                                                  |
	//	|                  VALUE/CODE                  |                                   DESCRIPTION                                    |
	//	|                                              |                                                                                  |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005               | The client's fax user account does not have the required                         |
	//	|                                              | FAX_ACCESS_MANAGE_CONFIG authorization for this operation.                       |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057           | The parameter is incorrect. This error code is returned when any of the          |
	//	|                                              | following conditions occur: § The dwSizeOfStruct member of the pGroup parameter  |
	//	|                                              | is not equal to the correct size of the RPC_FAX_OUTBOUND_ROUTING_GROUPW. §       |
	//	|                                              | The lpwstrGroupName member of pGroup is set to a NULL pointer value. § The       |
	//	|                                              | lpdwDevices member of pGroup is set to NULL and the dwNumDevices member of       |
	//	|                                              | the same pGroup is set to a value greater than zero. § The fax server tried      |
	//	|                                              | to return FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU but the client fax API version       |
	//	|                                              | (FAX_API_VERSION_0, described in section 3.1.4.1.10) does not support this error |
	//	|                                              | code.                                                                            |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_BUFFER_OVERFLOW 0x0000006F             | The length (excluding the terminating null character) of the character           |
	//	|                                              | string pointed at by the lpwstrGroupName member of pGroup is longer than 128     |
	//	|                                              | characters.                                                                      |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_REGISTRY_CORRUPT 0x000003F7            | The registry is corrupted. The structure of one of the files containing registry |
	//	|                                              | data is corrupted, or the system's memory image of the file is corrupted, or     |
	//	|                                              | the file could not be recovered because the alternate copy or log was absent or  |
	//	|                                              | corrupted.                                                                       |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU 0x00001B63 | The fax client module API version (described in section 3.1.4.1.10) is           |
	//	|                                              | FAX_API_VERSION_1 or above, and the fax server is running on a version of the    |
	//	|                                              | operating system that does not support the requested operation.<163>             |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol [MS-RPCE].
	SetOutboundGroup(context.Context, *SetOutboundGroupRequest, ...dcerpc.CallOption) (*SetOutboundGroupResponse, error)

	// The fax client application calls the FAX_RemoveOutboundGroup (Opnum 53) method to
	// remove an existing outbound routing group from the fax server. The name of the group
	// to remove is specified using the lpwstrGroupName parameter. The value for lpwstrGroupName
	// can be obtained using FAX_EnumOutboundGroups (section 3.1.4.1.26).<149>
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	|                    RETURN                    |                                                                                  |
	//	|                  VALUE/CODE                  |                                   DESCRIPTION                                    |
	//	|                                              |                                                                                  |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005               | Access is denied. The client's fax user account does not have the                |
	//	|                                              | FAX_ACCESS_MANAGE_CONFIG access rights.                                          |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057           | The fax server tried to return FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU but the client  |
	//	|                                              | fax API version (FAX_API_VERSION_0, described in the section 3.1.4.1.10) does    |
	//	|                                              | not support this error code.                                                     |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_BUFFER_OVERFLOW 0x0000006F             | The group name specified by the lpwstrGroupName argument (excluding the length   |
	//	|                                              | of the terminating null character) is longer than 128 characters.                |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_REGISTRY_CORRUPT 0x000003F7            | The fax server cannot access the local machine's fax routing group information   |
	//	|                                              | in the registry. The registry could be corrupt.                                  |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_OPERATION 0x000010DD           | The lpwstrGroupName parameter specifies the special routing group "<All          |
	//	|                                              | Devices>".                                                                       |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ERR_GROUP_NOT_FOUND 0x000001B5A          | The group specified by the lpwstrGroupName argument cannot be found.             |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ERR_GROUP_IN_USE 0x00001B5C              | The fax server cannot remove the outbound routing group identified by            |
	//	|                                              | lpwstrGroupName. The outbound routing group is in use by one or more outbound    |
	//	|                                              | routing rules.                                                                   |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU 0x00001B63 | The fax client module API version (described in the section 3.1.4.1.10) is       |
	//	|                                              | FAX_API_VERSION_1 or above, and the fax server is running on a version of the    |
	//	|                                              | operating system that does not support the requested operation.<150>             |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol [MS-RPCE].
	RemoveOutboundGroup(context.Context, *RemoveOutboundGroupRequest, ...dcerpc.CallOption) (*RemoveOutboundGroupResponse, error)

	// The FAX_EnumOutboundGroups (Opnum 54) method is called by the client.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	|                    RETURN                    |                                                                                  |
	//	|                  VALUE/CODE                  |                                   DESCRIPTION                                    |
	//	|                                              |                                                                                  |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005               | Access is denied. The client's fax user account does not have the access rights  |
	//	|                                              | (FAX_ACCESS_QUERY_CONFIG) required for this operation.                           |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057           | This error code is returned under any of the following conditions: § The         |
	//	|                                              | pointer referenced by the ppData argument is NULL.<92> § The fax server tried    |
	//	|                                              | to return FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU, but the client fax API version      |
	//	|                                              | (FAX_API_VERSION_0, described in section 3.1.4.1.10) does not support this error |
	//	|                                              | code.                                                                            |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU 0x00001B63 | The fax client module's API version (described in section 3.1.4.1.10) is         |
	//	|                                              | FAX_API_VERSION_1 or above, and the fax server is running. on a version of the   |
	//	|                                              | operating system that does not support the requested operation.<93>              |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	EnumOutboundGroups(context.Context, *EnumOutboundGroupsRequest, ...dcerpc.CallOption) (*EnumOutboundGroupsResponse, error)

	// The FAX_SetDeviceOrderInGroup (Opnum 55) method is called by the client. The value
	// for the dwDeviceId parameter can be obtained using the FAX_EnumPorts (section 3.1.4.1.28)
	// method or the FAX_EnumPortsEx (section 3.1.4.1.29) method. The name of the group
	// to remove is specified using the lpwstrGroupName parameter. The value for lpwstrGroupName
	// can be obtained using FAX_EnumOutboundGroups (section 3.1.4.1.26).
	//
	// The order is the 1-based location of the device in the group. The value of 1 indicates
	// the device is ordered first in the group. The order of devices in the group determines
	// the order in which they are used to send outgoing faxes when the group is selected
	// by an outbound routing rule.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	|                    RETURN                    |                                                                                  |
	//	|                  VALUE/CODE                  |                                   DESCRIPTION                                    |
	//	|                                              |                                                                                  |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005               | Access is denied. The client's fax user account does not have the required       |
	//	|                                              | FAX_ACCESS_MANAGE_CONFIG authorization for this operation.                       |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_BUFFER_OVERFLOW 0x0000006F             | The group name is too long. The length of the character string specified by the  |
	//	|                                              | lpwstrGroupName parameter, excluding the length of the null terminator, exceeds  |
	//	|                                              | 128 characters.                                                                  |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057           | The parameter is incorrect. This error code is returned if any of the following  |
	//	|                                              | conditions are met: § The dwDeviceId or the dwNewOrder parameter is set to a     |
	//	|                                              | value of 0. § The fax server tried to return FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU,  |
	//	|                                              | but the client fax API version (FAX_API_VERSION_0, described in section          |
	//	|                                              | 3.1.4.1.10) does not support this error code.                                    |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_REGISTRY_CORRUPT 0x000003F7            | The registry is corrupted. The structure of one of the files containing registry |
	//	|                                              | data is corrupted, or the system's memory image of the file is corrupted, or     |
	//	|                                              | the file could not be recovered because the alternate copy or log was absent or  |
	//	|                                              | corrupted.                                                                       |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ERR_BAD_GROUP_CONFIGURATION 0x00001B5B   | The device specified by dwDeviceId does not exist in the group identified by     |
	//	|                                              | the lpwstrGroupName, or the value of dwNewOrder is greater than the number of    |
	//	|                                              | devices in the group.                                                            |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU 0x00001B63 | The fax client module API version (as described in section 3.1.4.1.10) is        |
	//	|                                              | FAX_API_VERSION_1 or above, and the fax server is running on a version of the    |
	//	|                                              | operating system that does not support the requested operation.<160>             |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol [MS-RPCE].
	SetDeviceOrderInGroup(context.Context, *SetDeviceOrderInGroupRequest, ...dcerpc.CallOption) (*SetDeviceOrderInGroupResponse, error)

	// The FAX_AddOutboundRule (Opnum 56) method is called by the client to add a new outbound
	// rule for the specified outbound group to the fax server’s rules map. The value
	// for the dwDeviceId parameter can be obtained using the FAX_EnumPorts (section 3.1.4.1.28)
	// method or the FAX_EnumPortsEx (section 3.1.4.1.29) method.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	|                    RETURN                    |                                                                                  |
	//	|                  VALUE/CODE                  |                                   DESCRIPTION                                    |
	//	|                                              |                                                                                  |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005               | Access is denied. The client's fax user account does not have authorization      |
	//	|                                              | required for this call (FAX_ACCESS_MANAGE_CONFIG).                               |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_BAD_UNIT 0x00000014                    | The system cannot find the device specified by the dwDeviceId argument.          |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_GEN_FAILURE 0x0000001F                 | The fax server encountered an exception while processing the character string    |
	//	|                                              | specified by the lpwstrGroupName argument.                                       |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057           | The parameter is incorrect. This error code is returned when any of              |
	//	|                                              | the following conditions are met: § The country code specified with the          |
	//	|                                              | dwCountryCode argument is ROUTING_RULE_COUNTRY_CODE_ANY (not a valid             |
	//	|                                              | rule dialing location). § The lpwstrGroupName argument value is NULL.            |
	//	|                                              | § The value of the dwDeviceId argument is 0. § The fax server needs to           |
	//	|                                              | return FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU, but the client fax API version         |
	//	|                                              | (FAX_API_VERSION_0, described in section 3.1.4.1.10) does not support this error |
	//	|                                              | code.                                                                            |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_BUFFER_OVERFLOW 0x0000006F             | The destination group of the rule specified by the lpwstrGroupName argument      |
	//	|                                              | is longer than the maximum supported value of 128 characters (excluding the      |
	//	|                                              | terminating null character).                                                     |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_REGISTRY_CORRUPT 0x000003F7            | The registry is corrupted. The structure of one of the files containing registry |
	//	|                                              | data is corrupted, or the system's memory image of the file is corrupted, or     |
	//	|                                              | the file could not be recovered because the alternate copy or log was absent or  |
	//	|                                              | corrupted.                                                                       |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ERR_BAD_GROUP_CONFIGURATION 0x00001B5B   | The fax server encountered an outbound routing group with a bad configuration,   |
	//	|                                              | or the group device list is empty; the status for the new rule object created    |
	//	|                                              | by the server based on the specified dialing location and device ID is           |
	//	|                                              | FAX_RULE_STATUS_ALL_GROUP_DEV_NOT_VALID or FAX_RULE_STATUS_EMPTY_GROUP.          |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU 0x00001B63 | The fax client module API version (described in section 3.1.4.1.10) is           |
	//	|                                              | FAX_API_VERSION_1 or above, and the fax server is running on a version of the    |
	//	|                                              | operating system that does not support the requested operation.<69>              |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol [MS-RPCE].
	AddOutboundRule(context.Context, *AddOutboundRuleRequest, ...dcerpc.CallOption) (*AddOutboundRuleResponse, error)

	// The FAX_RemoveOutboundRule (Opnum 57) method removes an existing outbound routing
	// rule from the rules map. The default outbound rule cannot be removed.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	|                    RETURN                    |                                                                                  |
	//	|                  VALUE/CODE                  |                                   DESCRIPTION                                    |
	//	|                                              |                                                                                  |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005               | Access is denied. The client's fax user account does not have the required       |
	//	|                                              | FAX_ACCESS_MANAGE_CONFIG access rights to perform this operation.                |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057           | The parameter is incorrect. The country code specified by the dwCountryCode      |
	//	|                                              | argument is ROUTING_RULE_COUNTRY_CODE_ANY. Also returned if the fax server       |
	//	|                                              | tried to return FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU but the client fax API version |
	//	|                                              | (FAX_API_VERSION_0, described in section 3.1.4.1.10) does not support this error |
	//	|                                              | code.                                                                            |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_REGISTRY_CORRUPT 0x000003F7            | The fax server encountered a registry error when attempting to remove the        |
	//	|                                              | specified outbound rule registration. The registry could be corrupt.             |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ERR_RULE_NOT_FOUND 0x00001B5D            | The fax server failed to locate an outbound routing rule by country/region code  |
	//	|                                              | and area code.                                                                   |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU 0x00001B63 | The fax server is running on a version of the operating system that does not     |
	//	|                                              | support the requested operation.<151>                                            |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol [MS-RPCE].
	RemoveOutboundRule(context.Context, *RemoveOutboundRuleRequest, ...dcerpc.CallOption) (*RemoveOutboundRuleResponse, error)

	// A fax client application uses the FAX_SetOutboundRule (Opnum 58) method to set the
	// information about an individual fax outbound routing rule.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	|                    RETURN                    |                                                                                  |
	//	|                  VALUE/CODE                  |                                   DESCRIPTION                                    |
	//	|                                              |                                                                                  |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005               | Access is denied. The client's fax user account does not have the required       |
	//	|                                              | FAX_ACCESS_MANAGE_CONFIG authorization for this operation.                       |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057           | The parameter is incorrect. This error code is returned if any of the following  |
	//	|                                              | conditions occur: § The lpwstrGroupName member of the Destination member of      |
	//	|                                              | the pRule parameter is set to a NULL pointer value. § The dwDeviceId member      |
	//	|                                              | of the Destination member of pRule is set to zero. § The fax server tried        |
	//	|                                              | to return FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU but the client fax API version       |
	//	|                                              | (FAX_API_VERSION_0 (described in section 3.1.4.1.10) does not support this error |
	//	|                                              | code.                                                                            |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_BUFFER_OVERFLOW 0x0000006F             | The length (excluding the terminating null character) of the character string    |
	//	|                                              | pointed at by the lpwstrGroupName member of the Destination member of pRule is   |
	//	|                                              | greater than 128 characters.                                                     |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_REGISTRY_CORRUPT 0x000003F7            | The registry is corrupted. The structure of one of the files containing registry |
	//	|                                              | data is corrupted, or the system's memory image of the file is corrupted, or     |
	//	|                                              | the file could not be recovered because the alternate copy or log was absent or  |
	//	|                                              | corrupted.                                                                       |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ERR_BAD_GROUP_CONFIGURATION 0x00001B5B   | This error code is returned if any of the following conditions occur: § The      |
	//	|                                              | fax server encountered an outbound routing group with a bad configuration,       |
	//	|                                              | or the group device list is empty. § The status for the outbound routing rule    |
	//	|                                              | object indicated by the specified dialing location (the dwCountryCode and        |
	//	|                                              | dwAreaCode members of pRule) and group name (the lpwstrGroupName member of       |
	//	|                                              | the Destination member of pRule) is FAX_GROUP_STATUS_ALL_ DEV_NOT_VALID or       |
	//	|                                              | FAX_RULE_STATUS_EMPTY_GROUP.                                                     |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU 0x00001B63 | The fax client module API version (described in section 3.1.4.1.10) is           |
	//	|                                              | FAX_API_VERSION_1 or above, and the fax server is running on a version of the    |
	//	|                                              | operating system that does not support the requested operation.<164>             |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol [MS-RPCE].
	SetOutboundRule(context.Context, *SetOutboundRuleRequest, ...dcerpc.CallOption) (*SetOutboundRuleResponse, error)

	// The FAX_EnumOutboundRules (Opnum 59) method is called by the client to enumerate
	// all the outbound routing rules that are present on the specified fax server.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	|                    RETURN                    |                                                                                  |
	//	|                  VALUE/CODE                  |                                   DESCRIPTION                                    |
	//	|                                              |                                                                                  |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005               | Access is denied. The client's fax user account does not have the access rights  |
	//	|                                              | (FAX_ACCESS_QUERY_CONFIG) required for this operation.                           |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057           | The fax server tried to return FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU but the client  |
	//	|                                              | fax API version (FAX_API_VERSION_0, described in section 3.1.4.1.10) does not    |
	//	|                                              | support this error code.                                                         |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU 0x00001B63 | The fax client module's API version (described in section 3.1.4.1.10) is         |
	//	|                                              | FAX_API_VERSION_1 or above, and the fax server is running on a version of the    |
	//	|                                              | operating system that does not support the requested operation.<94>              |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	EnumOutboundRules(context.Context, *EnumOutboundRulesRequest, ...dcerpc.CallOption) (*EnumOutboundRulesResponse, error)

	// The fax client application calls the FAX_RegisterServiceProviderEx (Opnum 60) method
	// to register a fax service provider (FSP) with the Fax Service. Registration takes
	// place after the Fax Service restarts.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The client's fax user account does not have the authorization  |
	//	|                                    | for FAX_ACCESS_MANAGE_CONFIG required for this operation.                        |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. This error code is returned if any of the following  |
	//	|                                    | conditions are met: § The lpcwstrGuid parameter contains an invalid GUID. §      |
	//	|                                    | The dwFSPIVersion parameter is set to a value other than 0x00010000. § The       |
	//	|                                    | dwCapabilities parameter is set to a value other than 0. § The file path         |
	//	|                                    | specified by the lpcwstrImageName parameter does not exist, or the fax server    |
	//	|                                    | does not have access to the file.                                                |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_BUFFER_OVERFLOW 0x0000006F   | The length of the lpcwstrFriendlyName, lpcwstrImageName or lpcwstrTspName        |
	//	|                                    | character strings exceeds MAX_FAX_STRING_LEN characters, excluding the length of |
	//	|                                    | the NULL string terminator.                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ALREADY_EXISTS 0x000000B7    | An FSP is already registered with the same GUID (specified by the lpcwstrGUID    |
	//	|                                    | parameter) or with the same telephony service provider (specified by the         |
	//	|                                    | lpcwstrTspName parameter).                                                       |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_REGISTRY_CORRUPT 0x000003F7  | The registry is corrupted. The structure of one of the files that contains       |
	//	|                                    | registry data is corrupted, or the system's memory image of the file is          |
	//	|                                    | corrupted, or the file could not be recovered because the alternate copy or log  |
	//	|                                    | was absent or corrupted.                                                         |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol [MS-RPCE].
	RegisterServiceProviderEx(context.Context, *RegisterServiceProviderExRequest, ...dcerpc.CallOption) (*RegisterServiceProviderExResponse, error)

	// The FAX_UnregisterServiceProviderEx (Opnum 61) method is called when the client needs
	// to unregister a fax service provider (FSP). In response, the server MUST validate
	// that the client's fax user account has write access. On success, the server MUST
	// remove the service provider for the fax server.<179>
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	|             RETURN             |                                                                                  |
	//	|           VALUE/CODE           |                                   DESCRIPTION                                    |
	//	|                                |                                                                                  |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005 | Access is denied. The caller does not have the required FAX_ACCESS_MANAGE_CONFIG |
	//	|                                | authorization for this operation.                                                |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol [MS-RPCE].
	UnregisterServiceProviderEx(context.Context, *UnregisterServiceProviderExRequest, ...dcerpc.CallOption) (*UnregisterServiceProviderExResponse, error)

	// The FAX_UnregisterRoutingExtension (Opnum 62) method unregisters an existing inbound
	// routing extension.<178>
	//
	// There are no corresponding routing extension registration functions exposed to the
	// FAX client. Registration is a non-RPC process that is done locally on the fax server
	// using any implementation-specific method.
	//
	// On success, the server MUST unregister the specified routing extension.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return the following error code, one of the fax-specific errors that are
	// defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	|             RETURN             |                                                                                  |
	//	|           VALUE/CODE           |                                   DESCRIPTION                                    |
	//	|                                |                                                                                  |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005 | Access is denied. The client's fax user account does not have sufficient rights  |
	//	|                                | to perform the operation (FAX_ACCESS_MANAGE_CONFIG) or the user account does not |
	//	|                                | exist.                                                                           |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	UnregisterRoutingExtension(context.Context, *UnregisterRoutingExtensionRequest, ...dcerpc.CallOption) (*UnregisterRoutingExtensionResponse, error)

	// The FAX_StartMessagesEnum (Opnum 63) method is called by the client. On success,
	// the server MUST start enumerating messages in one of the archives.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The caller does not have the required                          |
	//	|                                    | ALL_FAX_USERS_ACCESS_RIGHTS access right to execute this call.                   |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. This error code is returned under any of             |
	//	|                                    | the following conditions: § The value specified for the level argument           |
	//	|                                    | is not equal to 1. § The value specified for the Folder argument is not          |
	//	|                                    | equal to FAX_MESSAGE_FOLDER_INBOX or FAX_MESSAGE_FOLDER_SENTITEMS. § The         |
	//	|                                    | lpcwstrAccountName parameter is not NULL and passes validation checks but does   |
	//	|                                    | not correspond to an existing account name. § The account name specified by the  |
	//	|                                    | lpcwstrAccountName argument is a valid account name but it refers to a different |
	//	|                                    | user than the caller.                                                            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NO_MORE_ITEMS 0x00000103     | No data is available. There are no messages to be enumerated.                    |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	StartMessagesEnum(context.Context, *StartMessagesEnumRequest, ...dcerpc.CallOption) (*StartMessagesEnumResponse, error)

	// The FAX_EndMessagesEnum (Opnum 64) method is called by the client.
	//
	// On success, the server MUST halt the enumerating of messages in the specified archives.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_HANDLE 0x00000006    | This error code SHOULD be returned if the handle pointed to by the specified     |
	//	|                                    | lpHandle parameter is not a valid handle returned by FAX_StartMessagesEnum.<79>  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | This error SHOULD be returned if the handle pointed to by the specified lpHandle |
	//	|                                    | is NULL.<80>                                                                     |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	EndMessagesEnum(context.Context, *EndMessagesEnumRequest, ...dcerpc.CallOption) (*EndMessagesEnumResponse, error)

	// The FAX_EnumMessages (Opnum 65) method is called by the client.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NOT_ENOUGH_MEMORY 0x00000008 | The fax server failed to allocate memory for the return buffer.                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | This error code is returned if any of the following conditions are met: § One    |
	//	|                                    | or more of the pointer values specified by the following arguments are NULL:     |
	//	|                                    | lppBuffer, lpdwBufferSize, and lpdwNumMessagesRetrieved. § The hEnum parameter   |
	//	|                                    | is NULL.<89> § The maximum number of messages, specified by the dwNumMessages    |
	//	|                                    | argument, is set to zero.                                                        |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_BUFFER_OVERFLOW 0x0000006F   | The fax server encountered an integer overflow condition while processing        |
	//	|                                    | the request for the maximum number of messages specified by the dwNumMessages    |
	//	|                                    | argument.                                                                        |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NO_MORE_ITEMS 0x00000103     | No more data is available. The method reached the end of the lppBuffer message   |
	//	|                                    | buffer and there are no more messages to be enumerated.                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ERR_SRV_OUTOFMEMORY 0x00001B59 | The fax server failed to allocate memory needed for internal execution of the    |
	//	|                                    | command.                                                                         |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// The client expects that this method is incremental and uses an internal context cursor
	// to point to the next set of messages to retrieve for each call. The cursor is set
	// to point to the beginning of the messages in the archive after a successful call
	// to FAX_StartMessagesEnum. Each successful call to FAX_EnumMessages advances the cursor
	// by the number of messages retrieved. After the cursor reaches the end of the enumeration,
	// the method fails with the 0x00000103 (ERROR_NO_MORE_ITEMS) error code. The FAX_EndMessagesEnum
	// (section 3.1.4.1.16) method SHOULD then be called.
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	EnumMessages(context.Context, *EnumMessagesRequest, ...dcerpc.CallOption) (*EnumMessagesResponse, error)

	// The FAX_GetMessage (Opnum 66) method is called by the client. The archive can be
	// one of the enumerations that are defined by FAX_ENUM_MESSAGE_FOLDER (section 2.2.2)
	// except FAX_MESSAGE_FOLDER_QUEUE. The dwlMessageId parameter specifies a particular
	// message and can be obtained using the FAX_EnumMessages (section 3.1.4.1.24) method
	// or the FAX_EnumMessagesEx (section 3.1.4.1.25) method.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	|                RETURN                |                                                                                  |
	//	|              VALUE/CODE              |                                   DESCRIPTION                                    |
	//	|                                      |                                                                                  |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005       | Access is denied. The client's fax user account does not have any of the         |
	//	|                                      | permissions covered by ALL_FAX_USER_ACCESS_RIGHTS (section 2.2.83).              |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NOT_ENOUGH_MEMORY 0x00000008   | Not enough storage is available to process this command. The fax server failed   |
	//	|                                      | to allocate sufficient memory to hold the FAX_MESSAGEW to be returned to the     |
	//	|                                      | client.                                                                          |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057   | The parameter is incorrect. This error code is returned when any of the          |
	//	|                                      | following conditions are met: § The lppBuffer or lpdwBufferSize parameters       |
	//	|                                      | are set to NULL pointer values.<116> § The dwlMessageId parameter is set         |
	//	|                                      | to a value of 0, and the value of the specified Folder parameter is not          |
	//	|                                      | FAX_MESSAGE_FOLDER_INBOX or FAX_MESSAGE_FOLDER_SENTITEMS.                        |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INTERNAL_ERROR 0x0000054F      | The fax server failed to custom marshal the FAX_MESSAGEW to be returned to the   |
	//	|                                      | client.                                                                          |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ERR_MESSAGE_NOT_FOUND 0x00001B61 | The fax server cannot find the job or message by its identifier.  This           |
	//	|                                      | error code is returned when any of the following conditions are met:             |
	//	|                                      | § The message identified by dwlMessageId is not found. § The message             |
	//	|                                      | identified by dwlMessageId is an unassigned incoming fax. The incoming           |
	//	|                                      | faxes are not public (accessible to all users), and the user does not            |
	//	|                                      | have FAX_ACCESS_MANAGE_RECEIVE_FOLDER permission. § The message identified       |
	//	|                                      | by dwlMessageId is for a different user, and this user does not have             |
	//	|                                      | FAX_ACCESS_QUERY_ARCHIVES permission.                                            |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	GetMessage(context.Context, *GetMessageRequest, ...dcerpc.CallOption) (*GetMessageResponse, error)

	// The fax client application calls the FAX_RemoveMessage (Opnum 67) method to remove
	// a message from a specific Fax Archive Folder. The dwlMessageId parameter specifies
	// a particular message and can be obtained using the FAX_EnumMessages (section 3.1.4.1.24)
	// method or the FAX_EnumMessagesEx (section 3.1.4.1.25) method.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section  2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	|                RETURN                 |                                                                                  |
	//	|              VALUE/CODE               |                                   DESCRIPTION                                    |
	//	|                                       |                                                                                  |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005        | Access is denied. The caller does not have the required access rights            |
	//	|                                       | (ALL_FAX_USER_ACCESS_RIGHTS (section 2.2.83)) for this operation.                |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057    | This error code is returned under any of the following conditions: § The value   |
	//	|                                       | of the dwlMessageId parameter is 0. § The value of the Folder parameter is not   |
	//	|                                       | FAX_MESSAGE_FOLDER_INBOX or FAX_MESSAGE_FOLDER_SENT_ITEMS.                       |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ERR_FILE_ACCESS_DENIED 0x00001B60 | The fax server failed to remove the fax message. When trying to delete the fax   |
	//	|                                       | archived file (the file that represents the fax message to be removed), the fax  |
	//	|                                       | server internally encountered an access denied or sharing violation error.       |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ERR_MESSAGE_NOT_FOUND 0x00001B61  | The fax server cannot find the message to be deleted (indicated by               |
	//	|                                       | dwlMessageId). When trying to delete the fax archived file (the file that        |
	//	|                                       | represents the fax message to be removed), the fax server internally encountered |
	//	|                                       | a file not found error.                                                          |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	RemoveMessage(context.Context, *RemoveMessageRequest, ...dcerpc.CallOption) (*RemoveMessageResponse, error)

	// The client calls the FAX_StartCopyToServer (Opnum 68) method to start a copy of a
	// file to the server queue directory (section 3.1.1) for which the client's fax user
	// account has access to submit faxes. The server MUST generate a unique file name and
	// create a file with that name in the server queue directory. Then the server MUST
	// create a copy handle and return it to the client to indicate success.
	//
	// The copy handle returned by the fax server with the lpHandle output argument is valid
	// until the fax client calls FAX_EndCopy (section 3.1.4.1.15), until the fax server
	// is shut down or restarted, or until an implementation-specific condition occurs that
	// invalidates the copy handle on the fax server.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The client's fax user account does not have any of the access  |
	//	|                                    | rights required for this operation: FAX_ACCESS_SUBMIT, FAX_ACCESS_SUBMIT_NORMAL, |
	//	|                                    | or FAX_ACCESS_SUBMIT_HIGH.                                                       |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. This error code is returned under any of the         |
	//	|                                    | following conditions: § The lpcwstrFileExt parameter is set to a NULL pointer    |
	//	|                                    | value.<173> § The file extension that is specified by lpcwstrFileExt is not      |
	//	|                                    | ".cov" or ".tif".                                                                |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_BUFFER_OVERFLOW 0x0000006F   | The file name is too long. The buffer specified by the lpwstrServerFileName      |
	//	|                                    | parameter does not have sufficient space to accommodate the server file name.    |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	StartCopyToServer(context.Context, *StartCopyToServerRequest, ...dcerpc.CallOption) (*StartCopyToServerResponse, error)

	// The FAX_StartCopyMessageFromServer (Opnum 69) method is called by the fax client
	// to start a copy operation of a fax message from the Fax Archive Folder (section 3.1.1)
	// or of a fax job from the server queue directory (section 3.1.1).
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	|          RETURN/ERROR CODE           |                                                                                  |
	//	|                VALUES                |                                   DESCRIPTION                                    |
	//	|                                      |                                                                                  |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057   | The parameter is incorrect. The dwlMessageId specified is 0 and/or the           |
	//	|                                      | specified Folder enumeration value is not FAX_MESSAGE_FOLDER_QUEUE,              |
	//	|                                      | FAX_MESSAGE_FOLDER_INBOX, or FAX_MESSAGE_FOLDER_SENTITEMS.                       |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ERR_MESSAGE_NOT_FOUND 0x00001B61 | This error code is returned if any of the following conditions are met: §        |
	//	|                                      | The fax server cannot find the fax queue entry referenced by the specified       |
	//	|                                      | dwMessageId (invalid job identifier) or the user does not have sufficient        |
	//	|                                      | rights to access the fax queue. § FAX_MESSAGE_FOLDER_QUEUE was specified         |
	//	|                                      | for the Folder parameter, the specified message is not owned by the client's     |
	//	|                                      | fax user account, and the client's fax user account does not have either         |
	//	|                                      | the FAX_ACCESS_QUERY_OUT_JOBS permission or the FAX_ACCESS_MANAGE_OUT_JOBS       |
	//	|                                      | permission. § FAX_MESSAGE_FOLDER_INBOX was specified for Folder, the client's    |
	//	|                                      | fax user account does not have the FAX_ACCESS_MANAGE_RECEIVE_FOLDER permission,  |
	//	|                                      | and the bIncomingMessagesArePublic option is not specified in the server         |
	//	|                                      | configuration. § FAX_MESSAGE_FOLDER_SENTITEMS was specified for Folder,          |
	//	|                                      | the client's fax user account does not have the FAX_ACCESS_QUERY_ARCHIVES        |
	//	|                                      | permission, and the specified message is not owned by the client's fax user      |
	//	|                                      | account.                                                                         |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	StartCopyMessageFromServer(context.Context, *StartCopyMessageFromServerRequest, ...dcerpc.CallOption) (*StartCopyMessageFromServerResponse, error)

	// The FAX_WriteFile (Opnum 70) method is called by the client.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.<181>
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_HANDLE 0x00000006    | The handle value specified by the hCopy argument is not a valid copy handle      |
	//	|                                    | returned by FAX_StartCopyToServer.                                               |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_GEN_FAILURE 0x0000001F       | A device attached to the system is not functioning. The call was unable to write |
	//	|                                    | the full amount of the data that was requested to be written.                    |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The following conditions can lead to this value being returned: § The parameter  |
	//	|                                    | is incorrect. § The dwDataSize parameter is 0. § The handle value specified by   |
	//	|                                    | the hCopy argument is NULL or the buffer size specified by the dwDataSize is     |
	//	|                                    | zero.                                                                            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	WriteFile(context.Context, *WriteFileRequest, ...dcerpc.CallOption) (*WriteFileResponse, error)

	// The fax client application calls the FAX_ReadFile (Opnum 71) method to copy a file
	// from the server (in chunks).
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_HANDLE 0x00000006    | The handle specified by the hCopy argument is not a valid copy handle            |
	//	|                                    | returned by FAX_StartCopyMessageFromServer for which FAX_EndCopy has not been    |
	//	|                                    | called.<142>                                                                     |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. This error code is returned under any of the         |
	//	|                                    | following conditions: § The handle specified by the hCopy argument is NULL.<143> |
	//	|                                    | § The value specified for the dwMaxDataSize argument is zero. § The value        |
	//	|                                    | specified for the *lpdwDataSize at input (when the call is made) is different    |
	//	|                                    | than the value specified for the dwMaxDataSize argument.                         |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	ReadFile(context.Context, *ReadFileRequest, ...dcerpc.CallOption) (*ReadFileResponse, error)

	// The FAX_EndCopy (Opnum 72) method is called by the client to end a copy operation
	// process from or to the server, and to close the respective copy handle.
	//
	// On success, the server MUST terminate the specified copy operation previously begun
	// with FAX_StartCopyToServer (section 3.1.4.1.97) or FAX_StartCopyMessageFromServer
	// (section 3.1.4.1.96).
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	|             RETURN              |                                                                                  |
	//	|           VALUE/CODE            |                                   DESCRIPTION                                    |
	//	|                                 |                                                                                  |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_HANDLE 0x00000006 | This error code SHOULD be returned if the handle pointed to by the specified     |
	//	|                                 | lphCopy parameter is not a valid handle returned by FAX_StartCopyToServer or     |
	//	|                                 | FAX_StartCopyMessageFromServer.<78>                                              |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	EndCopy(context.Context, *EndCopyRequest, ...dcerpc.CallOption) (*EndCopyResponse, error)

	// The FAX_StartServerNotification (Opnum 73) method is called by the client to get
	// notification about legacy events. On success, the server MUST start to notify the
	// fax client about the occurring fax events.
	//
	// Protocol version FAX_API_VERSION_2 (0x00020000) and FAX_API_VERSION_3 (0x00030000)
	// fax servers SHOULD fail this call by returning ERROR_NOT_SUPPORTED (0x00000032).
	// The fax client SHOULD NOT call this method if the protocol version reported by the
	// server is FAX_API_VERSION_2 (0x00020000) or FAX_API_VERSION_3 (0x00030000). For more
	// information, see FAX_ConnectFaxServer (section 3.1.4.1.10).
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	|             RETURN             |                                                                                  |
	//	|           VALUE/CODE           |                                   DESCRIPTION                                    |
	//	|                                |                                                                                  |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005 | The client's fax user account does not have sufficient rights for this call,     |
	//	|                                | which is ALL_FAX_USER_ACCESS_RIGHTS, or the user account does not exist.         |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_BAD_FORMAT 0x0000000B    | The length, including the terminating null character, of the string specified    |
	//	|                                | by the lpcwstrMachineName argument is greater than 256 characters. The length,   |
	//	|                                | including the terminating null character, of the string specified by the         |
	//	|                                | lpcwstrEndPoint argument is greater than 11 characters.                          |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NOT_SUPPORTED 0x00000032 | The request is not supported.                                                    |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	//
	// A fax client calls FAX_StartServerNotification to inform the server that it needs
	// to receive the notifications of legacy fax events. The fax server SHOULD call FAX_OpenConnection
	// on the client by using the supplied endpoint, protocol sequence information, and
	// context handle information. The server then sends the notification of legacy events
	// to the client by using FAX_ClientEventQueue (section 3.2.4.2). When the client no
	// longer needs to receive notifications, it calls FAX_EndServerNotification, and the
	// server SHOULD call FAX_CloseConnection (section 3.2.4.4) to close the connection.
	//
	// Note  This method only supports TCP/IP as the transport protocol.
	StartServerNotification(context.Context, *StartServerNotificationRequest, ...dcerpc.CallOption) (*StartServerNotificationResponse, error)

	// The FAX_StartServerNotificationEx (Opnum 74) method is called by the client to get
	// notification about extended or legacy events. On success, the server MUST start to
	// notify the fax client about the occurring fax events.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section  2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. This error code is returned under any of the following         |
	//	|                                    | conditions: § The value specified for the dwEventTypes argument contains         |
	//	|                                    | the FAX_EVENT_TYPE_NEW_CALL and/or FAX_EVENT_TYPE_IN_QUEUE flags and the         |
	//	|                                    | caller cannot access unsigned faxes: incoming faxes are not public and the       |
	//	|                                    | caller does not have the FAX_ACCESS_MANAGE_RECEIVE_FOLDER rights. § The value    |
	//	|                                    | specified for the dwEventTypes argument contains the FAX_EVENT_TYPE_CONFIG,      |
	//	|                                    | FAX_EVENT_TYPE_DEVICE_STATUS and/or the FAX_EVENT_TYPE_ACTIVITY flags and the    |
	//	|                                    | caller does not have the FAX_ACCESS_QUERY_CONFIG rights.                         |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_BAD_FORMAT 0x0000000B        | This error code is returned under any of the following conditions: § The length  |
	//	|                                    | of the fax client machine name specified by the lpcwstrMachineName argument,     |
	//	|                                    | excluding the length of the terminating null character, is longer than 256       |
	//	|                                    | characters. § The length of the endpoint string specified by the lpcwstrEndPoint |
	//	|                                    | argument, excluding the length of the terminating null character, is longer than |
	//	|                                    | or equal to 11 characters.                                                       |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_OUTOFMEMORY 0x0000000E       | Not enough storage is available to complete this operation.                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | Invalid parameter. This error code is returned under any of the following        |
	//	|                                    | conditions: § Any of these arguments specify a NULL pointer value:               |
	//	|                                    | lcpwstrEndPoint, lpcwstrMachineName, lpHandle.<175> § The value specified for    |
	//	|                                    | the dwEventTypes argument is not a bitwise OR combination of the following       |
	//	|                                    | FAX_ENUM_EVENT_TYPE values: § FAX_EVENT_TYPE_IN_QUEUE § FAX_EVENT_TYPE_OUT_QUEUE |
	//	|                                    | § FAX_EVENT_TYPE_CONFIG § FAX_EVENT_TYPE_ACTIVITY § FAX_EVENT_TYPE_QUEUE_STATE   |
	//	|                                    | § FAX_EVENT_TYPE_IN_ARCHIVE § FAX_EVENT_TYPE_OUT_ARCHIVE §                       |
	//	|                                    | FAX_EVENT_TYPE_FXSSVC_ENDED § FAX_EVENT_TYPE_DEVICE_STATUS §                     |
	//	|                                    | FAX_EVENT_TYPE_NEW_CALL                                                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	//
	// A fax client calls FAX_StartServerNotificationEx to inform the server that it needs
	// to receive the notifications of extended or legacy fax events. The fax server SHOULD
	// call FAX_OpenConnection on the client by using the supplied endpoint, protocol sequence
	// information, and context handle information. The server then sends notification of
	// events to the client by using either FAX_ClientEventQueueEx (section 3.2.4.3) or
	// FAX_ClientEventQueue (section 3.2.4.2) as specified by the bEventEx parameter. When
	// the client no longer needs to receive notifications, it calls FAX_EndServerNotification;
	// the server SHOULD call FAX_CloseConnection (section 3.2.4.4) to close the connection.
	StartServerNotificationEx(context.Context, *StartServerNotificationExRequest, ...dcerpc.CallOption) (*StartServerNotificationExResponse, error)

	// The FAX_EndServerNotification (Opnum 75) method is called by the client to stop the
	// notifications from the server, which were initiated by a call to FAX_StartServerNotification
	// (section 3.1.4.1.100), FAX_StartServerNotificationEx (section 3.1.4.1.101), or FAX_StartServerNotificationEx2
	// (section 3.1.4.1.102).
	//
	// On success, the server MUST stop notifying the client of events.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_DATA 0x0000000D      | This error SHOULD be returned if the lpHandle parameter is not a valid           |
	//	|                                    | handle obtained using the FAX_StartServerNotification method, the                |
	//	|                                    | FAX_StartServerNotificationEx method, or the FAX_StartServerNotificationEx2      |
	//	|                                    | method.<81>                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | lpHandle is specified as NULL.<82>                                               |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// To stop notifications, the client SHOULD call FAX_EndServerNotification; the server
	// SHOULD call FAX_CloseConnection section 3.2.4.4) to close the connection.
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	EndServerNotification(context.Context, *EndServerNotificationRequest, ...dcerpc.CallOption) (*EndServerNotificationResponse, error)

	// The fax client application calls the FAX_GetServerActivity (Opnum 76) method to retrieve
	// the status of the fax queue activity and event log reports.
	//
	// The client MUST allocate memory for the pServerActivity argument. It MUST also set
	// the dwSizeOfStruct field to the correct size, in bytes, of the FAX_SERVER_ACTIVITY
	// structure as described in section 2.2.19.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The client's fax user account does not have the                |
	//	|                                    | FAX_ACCESS_QUERY_CONFIG access rights required for this operation.               |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. The dwSizeOfStruct member of the FAX_SERVER_ACTIVITY |
	//	|                                    | specified by the pServerActivity parameter on input is set by the client to an   |
	//	|                                    | incorrect value. For more details about the correct size to be filled in this    |
	//	|                                    | member, see the FAX_SERVER_ACTIVITY.                                             |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	GetServerActivity(context.Context, *GetServerActivityRequest, ...dcerpc.CallOption) (*GetServerActivityResponse, error)

	// The FAX_SetConfigWizardUsed (Opnum 77) method is called by the client. The server
	// MUST validate that the client's fax user account has access to manage configuration
	// information on the server. On success, the server MUST set a value in the registry
	// indicating whether or not the configuration wizard was used. <159>
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	|              RETURN               |                                                                                  |
	//	|            VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                   |                                                                                  |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005    | Access is denied. The caller does not have the required rights                   |
	//	|                                   | (FAX_ACCESS_MANAGE_CONFIG) to perform this operation.                            |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_REGISTRY_CORRUPT 0x000003F7 | The registry is corrupted. The structure of one of the files containing registry |
	//	|                                   | data is corrupted, or the system's memory image of the file is corrupted.        |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol [MS-RPCE].
	SetConfigWizardUsed(context.Context, *SetConfigWizardUsedRequest, ...dcerpc.CallOption) (*SetConfigWizardUsedResponse, error)

	// The FAX_EnumRoutingExtensions (Opnum 78) function is called by the client to enumerate
	// all the routing extensions that are registered with the specified fax server. The
	// function returns detailed information about each of the routing extensions.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The client's fax user account does not have the access rights  |
	//	|                                    | (FAX_ACCESS_QUERY_CONFIG) required for this operation.                           |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NOT_ENOUGH_MEMORY 0x00000008 | Not enough storage is available to process this command. The fax server cannot   |
	//	|                                    | allocate sufficient memory to hold the array of FAX_ROUTING_EXTENSION_INFO       |
	//	|                                    | structures to be returned to the client.                                         |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The Buffer parameter is set to a NULL pointer value. <97>                        |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INTERNAL_ERROR 0x0000054F    | The fax server failed to custom marshal the array of FAX_ROUTING_EXTENSION_INFO  |
	//	|                                    | structures to be returned to the client.                                         |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	EnumRoutingExtensions(context.Context, *EnumRoutingExtensionsRequest, ...dcerpc.CallOption) (*EnumRoutingExtensionsResponse, error)

	// The FAX_ConnectFaxServer (Opnum 80) method is called by the client to create a connection
	// to the fax server.
	//
	// Protocol version FAX_API_VERSION_0 (0x00000000) fax servers SHOULD NOT implement
	// this method.
	//
	// If the underlying RPC layer fails this call by returning RPC_S_PROCNUM_OUT_OF_RANGE
	// (0x000006D1), the fax client SHOULD consider the server protocol (and API version)
	// to be FAX_API_VERSION_0 and MAY retry this request by switching to the FaxObs Server
	// Interface (section 3.1.4.2) and calling the FaxObs_ConnectionRefCount (section 3.1.4.2.2)
	// method.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return the following error code, one of the fax-specific errors that are
	// defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	|             RETURN             |                                                                                  |
	//	|           VALUE/CODE           |                                   DESCRIPTION                                    |
	//	|                                |                                                                                  |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005 | Access is denied. The bAutoCreateAccountOnConnect field of the                   |
	//	|                                | FAX_GENERAL_CONFIG structure is set to FALSE and the calling user's              |
	//	|                                | authenticated user identity does not have a fax user account associated on       |
	//	|                                | the fax server, or the does not have any of the access rights defined in         |
	//	|                                | ALL_FAX_USER_ACCESS_RIGHTS (section 2.2.83).                                     |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol [MS-RPCE].
	ConnectFaxServer(context.Context, *ConnectFaxServerRequest, ...dcerpc.CallOption) (*ConnectFaxServerResponse, error)

	// The FAX_GetSecurityEx (Opnum 81) method is called by the clients to retrieve information
	// about the fax security descriptor from the fax server.<134>
	//
	// Protocol version FAX_API_VERSION_3 (0x00030000) fax servers SHOULD fail this call
	// by returning ERROR_NOT_SUPPORTED (0x00000032). The fax client SHOULD NOT call this
	// method if the protocol version reported by the server is FAX_API_VERSION_3 (0x00030000).
	// For more information, see FAX_ConnectFaxServer (section 3.1.4.1.10). The fax client
	// SHOULD call the FAX_GetSecurityEx2 (section 3.1.4.1.60) method instead.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	|                 RETURN                  |                                                                                  |
	//	|               VALUE/CODE                |                                   DESCRIPTION                                    |
	//	|                                         |                                                                                  |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005          | Access is denied. This error code is returned if any of the following            |
	//	|                                         | conditions occur: § The client's fax user account does not have READ_CONTROL     |
	//	|                                         | access but the requesting SecurityInformation parameter contains one             |
	//	|                                         | of these flags: GROUP_SECURITY_INFORMATION, DACL_SECURITY_INFORMATION,           |
	//	|                                         | or OWNER_SECURITY_INFORMATION. § The client's fax user account does not          |
	//	|                                         | have ACCESS_SYSTEM_SECURITY but the SecurityInformation contains the flag        |
	//	|                                         | SACL_SECURITY_INFORMATION.                                                       |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NOT_ENOUGH_MEMORY 0x00000008      | Not enough storage is available to process this command.                         |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057      | The parameter is incorrect. This is returned when the pSecurityDescriptor        |
	//	|                                         | parameter is NULL.                                                               |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_SECURITY_DESCR 0x0000053A | The security descriptor structure is invalid.                                    |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	GetSecurityEx(context.Context, *GetSecurityExRequest, ...dcerpc.CallOption) (*GetSecurityExResponse, error)

	// A fax client application calls the FAX_RefreshArchive (Opnum 82) method to notify
	// the server that the archive folder has been changed and SHOULD be refreshed.<145>
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The required access level SHOULD be FAX_ACCESS_MANAGE_CONFIG.  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. The folder parameter SHOULD either be                |
	//	|                                    | FAX_MESSAGE_FOLDER_INBOX or FAX_MESSAGE_FOLDER_SENTITEMS.<147>                   |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol [MS-RPCE].
	RefreshArchive(context.Context, *RefreshArchiveRequest, ...dcerpc.CallOption) (*RefreshArchiveResponse, error)

	// The FAX_SetRecipientsLimit (Opnum 83) method is called by the client. A fax client
	// application calls FAX_SetRecipientsLimit to set the recipient limit of a single broadcast
	// job. On success, the server MUST set the recipient limit of a single broadcast job.
	//
	// Protocol version FAX_API_VERSION_0 (0x00000000) and FAX_API_VERSION_1 (0x00010000)
	// fax servers SHOULD NOT implement this call. Protocol version FAX_API_VERSION_2 (0x00020000)
	// and FAX_API_VERSION_3 (0x00030000) fax servers SHOULD fail this call by returning
	// ERROR_NOT_SUPPORTED (0x00000032). The fax client MUST NOT call this method if the
	// protocol version reported by the server is FAX_API_VERSION_0 (0x00000000) or FAX_API_VERSION_1
	// (0x00010000). For more information,  see FAX_ConnectFaxServer (section 3.1.4.1.10).
	//
	// Return Values: This method SHOULD return 0x00000032 (ERROR_NOT_SUPPORTED).
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	SetRecipientsLimit(context.Context, *SetRecipientsLimitRequest, ...dcerpc.CallOption) (*SetRecipientsLimitResponse, error)

	// The FAX_GetRecipientsLimit (Opnum 84) method is called by the client to retrieve
	// information about the recipient limit of a single broadcast job.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return the following error code, one of the fax-specific errors that are
	// defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	|             RETURN             |                                                                                  |
	//	|           VALUE/CODE           |                                   DESCRIPTION                                    |
	//	|                                |                                                                                  |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005 | Access is denied. The client's fax user account does not have any of the         |
	//	|                                | following access rights: FAX_ACCESS_SUBMIT, FAX_ACCESS_SUBMIT_NORMAL, or         |
	//	|                                | FAX_ACCESS_SUBMIT_HIGH.                                                          |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	GetRecipientsLimit(context.Context, *GetRecipientsLimitRequest, ...dcerpc.CallOption) (*GetRecipientsLimitResponse, error)

	// The FAX_GetServerSKU (Opnum 85) method is called by the client. In response, the
	// server returns the SKU of the fax server operating system.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return the following error code, one of the fax-specific errors that are
	// defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	|             RETURN             |                                                                                  |
	//	|           VALUE/CODE           |                                   DESCRIPTION                                    |
	//	|                                |                                                                                  |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005 | Access is denied. The client's fax user account does not have any of the         |
	//	|                                | permissions covered by ALL_FAX_USER_ACCESS_RIGHTS (section 2.2.83).              |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	GetServerSKU(context.Context, *GetServerSKURequest, ...dcerpc.CallOption) (*GetServerSKUResponse, error)

	// The FAX_CheckValidFaxFolder (Opnum 86) method is called by the client to check whether
	// the specified path is accessible to the fax server.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN                |                                                                                  |
	//	|             VALUE/CODE              |                                   DESCRIPTION                                    |
	//	|                                     |                                                                                  |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_FILE_NOT_FOUND 0x00000002     | The path specified by the lpcwstrPath argument has a valid structure (the folder |
	//	|                                     | path is valid), but the file does not exist.                                     |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_PATH_NOT_FOUND 0x00000003     | The path specified by the lpcwstrPath argument has a valid structure, but the    |
	//	|                                     | folder path does not exist.                                                      |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005      | Access is denied. The client's fax user account does not have sufficient rights  |
	//	|                                     | for this operation (ALL_FAX_USER_ACCESS_RIGHTS).                                 |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057  | The lpcwstrPath argument is NULL, or the path specified by the lpcwstrPath       |
	//	|                                     | argument is incomplete.                                                          |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_BUFFER_OVERFLOW 0x0000006F    | The length of the path (including length of the terminating null character)      |
	//	|                                     | specified by the lpcwstrPath argument exceeds 180 characters.                    |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ERR_DIRECTORY_IN_USE 0x00001B5F | The path specified by the lpcwstrPath argument points to a folder currently in   |
	//	|                                     | use by the fax server, such as the server queue directory or the Fax Archive     |
	//	|                                     | Folder (section 3.1.1).                                                          |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol [MS-RPCE].
	CheckValidFaxFolder(context.Context, *CheckValidFaxFolderRequest, ...dcerpc.CallOption) (*CheckValidFaxFolderResponse, error)

	// The FAX_GetJobEx2 (Opnum 87) method is called by the client to retrieve information
	// about a specified job. The job is identified by the job message ID. The job message
	// ID can be obtained using one of the following methods: FAX_EnumJobs (section 3.1.4.1.21),
	// FAX_EnumJobsEx (section 3.1.4.1.22), or FAX_EnumJobsEx2 (section 3.1.4.1.23).
	//
	// Protocol version FAX_API_VERSION_0 (0x00000000), FAX_API_VERSION_1 (0x00010000),
	// and FAX_API_VERSION_2 (0x00020000) fax servers SHOULD NOT implement this call. The
	// fax client MUST NOT call this method if the protocol version reported by the server
	// is FAX_API_VERSION_0 (0x00000000), FAX_API_VERSION_1 (0x00010000), or FAX_API_VERSION_2
	// (0x00020000). For more information, see FAX_ConnectFaxServer (section 3.1.4.1.10).
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	|                RETURN                |                                                                                  |
	//	|              VALUE/CODE              |                                   DESCRIPTION                                    |
	//	|                                      |                                                                                  |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005       | Access is denied. This error code is returned under any of the following         |
	//	|                                      | conditions: § The client's fax user account does not have any of the permissions |
	//	|                                      | covered by ALL_FAX_USER_ACCESS_RIGHTS (section 2.2.83). § For an outgoing fax    |
	//	|                                      | job, the caller is not the owner of the fax job, and the caller does not have    |
	//	|                                      | the FAX_ACCESS_MANAGE_OUT_JOBS rights. § For an incoming fax job, the caller is  |
	//	|                                      | not the receiver of the call, incoming faxes are not public, and the client's    |
	//	|                                      | fax user account does not have the FAX_ACCESS_MANAGE_RECEIVE_FOLDER rights.      |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NOT_ENOUGH_MEMORY 0x00000008   | Not enough storage is available to process this command. The fax server failed   |
	//	|                                      | to allocate sufficient memory to hold the FAX_JOB_ENTRY_EX_1 to be returned to   |
	//	|                                      | the client.                                                                      |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057   | The parameter is incorrect. This error code is returned under any of the         |
	//	|                                      | following conditions: § The Buffer and/or BufferSize parameters are set to NULL  |
	//	|                                      | pointer values.<112> § The level parameter is set to a value other than 1.       |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INTERNAL_ERROR 0x0000054F      | The fax server failed to custom marshal the FAX_JOB_ENTRY_EX_1 to be returned to |
	//	|                                      | the client.                                                                      |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ERR_MESSAGE_NOT_FOUND 0x00001B61 | This error code is returned under any of the following conditions: § The fax     |
	//	|                                      | server cannot find the fax job identified by the value of the dwlMessageID       |
	//	|                                      | parameter. § The user is not the owner of the fax job identified by the value of |
	//	|                                      | dwlMessageID.                                                                    |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	GetJobEx2(context.Context, *GetJobEx2Request, ...dcerpc.CallOption) (*GetJobEx2Response, error)

	// The FAX_EnumJobsEx2 (Opnum 88) method is called by the client to enumerate a specified
	// set of jobs on the server's queue for a specific fax account. The type of jobs to
	// enumerate is described by the dwJobTypes argument.
	//
	// Protocol version FAX_API_VERSION_0 (0x00000000), FAX_API_VERSION_1 (0x00010000),
	// and FAX_API_VERSION_2 (0x00020000) fax servers SHOULD NOT implement this call. The
	// fax client MUST NOT call this method if the protocol version reported by the server
	// is FAX_API_VERSION_0 (0x00000000), FAX_API_VERSION_1 (0x00010000), or FAX_API_VERSION_2
	// (0x00020000). For more information, see FAX_ConnectFaxServer (section 3.1.4.1.10).
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. This error can be returned when any of the following           |
	//	|                                    | conditions are true: § The client's fax user account does not have any of the    |
	//	|                                    | access rights defined in ALL_FAX_USER_ACCESS_RIGHTS (section 2.2.83) that are    |
	//	|                                    | required in order to enumerate jobs of type JT_SEND on its own account. That     |
	//	|                                    | is, the fAllAccounts parameter is FALSE. § The client's fax user account does    |
	//	|                                    | not have the FAX_ACCESS_QUERY_OUT_JOBS access right that is required in order to |
	//	|                                    | enumerate jobs of type JT_SEND on all accounts. That is, fAllAccounts is TRUE. § |
	//	|                                    | The client's fax user account does not have the FAX_ACCESS_MANAGE_RECEIVE_FOLDER |
	//	|                                    | access right that is required in order to enumerate jobs of type JT_RECEIVE or   |
	//	|                                    | JT_ROUTING.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NOT_ENOUGH_MEMORY 0x00000008 | Not enough storage is available to process this command.                         |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. This value is returned when any of the following     |
	//	|                                    | conditions are true: § Either the lpwdJobs or the Buffer parameter is NULL.      |
	//	|                                    | § The BufferSize parameter is 0. § The level parameter is not set to 1. § The    |
	//	|                                    | lpcwstrAccountName parameter contains an improperly formatted account name or    |
	//	|                                    | points to a nonexistent or other user account.                                   |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// The account name that lpcwstrAccountName indicates MUST be in one of the following
	// formats. Any other format is invalid.
	//
	//	+----------------------------+-----------------------------------------------------------------+
	//	|                            |                                                                 |
	//	|           FORMAT           |                           DESCRIPTION                           |
	//	|                            |                                                                 |
	//	+----------------------------+-----------------------------------------------------------------+
	//	+----------------------------+-----------------------------------------------------------------+
	//	| <machine_name>\<user_name> | For a local user with machine_name as the local machine's name. |
	//	+----------------------------+-----------------------------------------------------------------+
	//	| <domain_name>\<user_name>  | For a nonlocal user.                                            |
	//	+----------------------------+-----------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	EnumJobsEx2(context.Context, *EnumJobsEx2Request, ...dcerpc.CallOption) (*EnumJobsEx2Response, error)

	// The FAX_GetMessageEx (Opnum 89) method is called by the client to retrieve a particular
	// message from one of the specified fax message archives. The dwlMessageId parameter
	// specifies a particular message and can be obtained using the FAX_EnumMessages (section
	// 3.1.4.1.24) method or the FAX_EnumMessagesEx (section 3.1.4.1.25) method. The folder
	// value MUST be one of the enumerations that are defined by FAX_ENUM_MESSAGE_FOLDER
	// (section 2.2.2), except FAX_MESSAGE_FOLDER_QUEUE. This is an extended version of
	// FAX_GetMessage (section 3.1.4.1.45), because it takes an additional level parameter
	// supporting the extended structure FAX_MESSAGE_1 (section 2.2.37).
	//
	// Protocol version FAX_API_VERSION_0 (0x00000000), FAX_API_VERSION_1  (0x00010000),
	// and  FAX_API_VERSION_2 (0x00020000) fax servers SHOULD NOT implement this call.
	// The fax client MUST NOT call this method if the protocol version reported by the
	// server is FAX_API_VERSION_0 (0x00000000), FAX_API_VERSION_1 (0x00010000), or FAX_API_VERSION_2
	// (0x00020000). For more information, see FAX_ConnectFaxServer (section 3.1.4.1.10).
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	|                RETURN                |                                                                                  |
	//	|              VALUE/CODE              |                                   DESCRIPTION                                    |
	//	|                                      |                                                                                  |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005       | Access is denied. The client's fax user account does not have any of the         |
	//	|                                      | permissions covered by ALL_FAX_USER_ACCESS_RIGHTS (section 2.2.83).              |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057   | The parameter is incorrect. This error code results under any of the following   |
	//	|                                      | conditions: § The value of the specified level parameter is not 1. § The pointer |
	//	|                                      | specified by the lppBuffer parameter is NULL.<117> § The pointer specified       |
	//	|                                      | by the lpdwBufferSize parameter is NULL.<118> § The value of the dwlMessageId    |
	//	|                                      | parameter is specified as 0. § The value of the specified Folder parameter is    |
	//	|                                      | not FAX_MESSAGE_FOLDER_INBOX or FAX_MESSAGE_FOLDER_SENTITEMS.                    |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ERR_SRV_OUTOFMEMORY 0x00001B59   | The fax server failed to allocate memory needed for internal execution of this   |
	//	|                                      | operation.                                                                       |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ERR_MESSAGE_NOT_FOUND 0x00001B61 | This error code is returned under any of the following conditions: § The         |
	//	|                                      | message identified by the dwlMessageId parameter is not found. § The message     |
	//	|                                      | identified by dwlMessageId is an unassigned incoming fax. The incoming           |
	//	|                                      | faxes are not public (accessible to all users), and the user does not            |
	//	|                                      | have FAX_ACCESS_MANAGE_RECEIVE_FOLDER permission. § The message identified       |
	//	|                                      | by dwlMessageId is for a different user, and this user does not have             |
	//	|                                      | FAX_ACCESS_QUERY_ARCHIVES permission.                                            |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	GetMessageEx(context.Context, *GetMessageExRequest, ...dcerpc.CallOption) (*GetMessageExResponse, error)

	// The FAX_StartMessagesEnumEx (Opnum 90) method is called by the client. On success,
	// the server MUST start enumerating messages in the specified archive folder.
	//
	// Protocol version FAX_API_VERSION_0 (0x00000000), FAX_API_VERSION_1 (0x00010000),
	// and FAX_API_VERSION_2 (0x00020000) fax servers SHOULD NOT implement this call. The
	// fax client MUST NOT call this method if the protocol version reported by the server
	// is FAX_API_VERSION_0 (0x00000000), FAX_API_VERSION_1 (0x00010000), or FAX_API_VERSION_2
	// (0x00020000). For more information, see FAX_ConnectFaxServer (section 3.1.4.1.10).
	//
	// A fax client application calls the FAX_StartMessagesEnumEx to start enumerating messages
	// from the archives. Each enumerated message has more information than those that are
	// returned by the FAX_StartMessagesEnum (section 3.1.4.1.98) method, namely whether
	// or not the message has a cover page, the type of receipts selected, the email address
	// for receipts, and the flags from FAX_ENUM_MSG_FLAGS (section 2.2.53) enumeration.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section  2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. This error code is returned under any of the following         |
	//	|                                    | conditions: § The caller does not have the required basic access rights to       |
	//	|                                    | execute this call (ALL_FAX_USERS_ACCESS_RIGHTS). § The client's fax user account |
	//	|                                    | does not have access to query messages for all accounts. The value specified for |
	//	|                                    | the fAllAccounts parameter is not equal to zero, and the caller does not have    |
	//	|                                    | the FAX_ACCESS_QUERY_ARCHIVES rights.                                            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. This error code is returned under any of the         |
	//	|                                    | following conditions: § The value specified for the level argument is not        |
	//	|                                    | equal to 1. § The value specified for the Folder argument is not equal to        |
	//	|                                    | FAX_MESSAGE_FOLDER_INBOX or FAX_MESSAGE_FOLDER_SENTITEMS. § The account name     |
	//	|                                    | specified for the lpcwstrAccountName argument appears valid (pointer is not      |
	//	|                                    | NULL), but the account name is not a valid fax account name. § The account name  |
	//	|                                    | specified by the lpcwstrAccountName argument is a valid account name, but it     |
	//	|                                    | refers to a different user than the caller.                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NO_MORE_ITEMS 0x00000103     | No data is available. There are no messages to be enumerated.                    |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	//
	// A fax client application calls the FAX_StartMessagesEnumEx function to start enumerating
	// messages in one of the archives. The enumerated messages have more information than
	// those that are returned by FAX_StartMessagesEnum, namely, whether it has a cover
	// page, the type of receipts selected, the email address for receipts, and the flags
	// from FAX_ENUM_MSG_FLAGS.
	//
	// The account name that lpcwstrAccountName indicates MUST be in one of the following
	// formats. Any other format is invalid.
	//
	//	+----------------------------+---------------------------------------------------------------------+
	//	|                            |                                                                     |
	//	|           FORMAT           |                             DESCRIPTION                             |
	//	|                            |                                                                     |
	//	+----------------------------+---------------------------------------------------------------------+
	//	+----------------------------+---------------------------------------------------------------------+
	//	| <machine_name>\<user_name> | For a local user that has machine_name as the local machine's name. |
	//	+----------------------------+---------------------------------------------------------------------+
	//	| <domain_name>\<user_name>  | For a nonlocal user.                                                |
	//	+----------------------------+---------------------------------------------------------------------+
	StartMessagesEnumEx(context.Context, *StartMessagesEnumExRequest, ...dcerpc.CallOption) (*StartMessagesEnumExResponse, error)

	// The FAX_EnumMessagesEx (Opnum 91) method is called by the client. This message differs
	// from the FAX_EnumMessages (section 3.1.4.1.24) in that this function takes a level
	// parameter, which differentiates the type of message information structure that the
	// function returns.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NOT_ENOUGH_MEMORY 0x00000008 | The fax server failed to allocate memory for the return buffer.                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. This error code is returned if any of                |
	//	|                                    | the following conditions are met: § One or more of the pointer values            |
	//	|                                    | specified by the following arguments are NULL: lppBuffer, lpdwBufferSize,        |
	//	|                                    | lpdwNumMessagesRetrieved, and lpdwLevel. § hEnum is NULL<90> or is an            |
	//	|                                    | invalid handle that is not returned by a call to FAX_StartMessagesEnum or        |
	//	|                                    | FAX_StartMessagesEnumEx <91>. § dwNumMessages is zero.                           |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_BUFFER_OVERFLOW 0x0000006F   | The fax server encountered an integer overflow condition while processing        |
	//	|                                    | the request for the maximum number of messages specified by the dwNumMessages    |
	//	|                                    | argument.                                                                        |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NO_MORE_ITEMS 0x00000103     | No more data is available. The method reached the end of the lppBuffer message   |
	//	|                                    | buffer and there are no more messages to be enumerated.                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ERR_SRV_OUTOFMEMORY 0x00001B59 | The fax server failed to allocate memory needed for internal execution of the    |
	//	|                                    | command.                                                                         |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// The client implementation assumes that this method is incremental and uses an internal
	// context cursor to point to the next set of messages to retrieve for each call. The
	// cursor is set to point to the beginning of the messages in the archive after a successful
	// call to FAX_StartMessagesEnum or FAX_StartMessagesEnumEx. Each successful call to
	// FAX_EnumMessagesEx advances the cursor by the number of messages retrieved. After
	// the cursor reaches the end of the enumeration, the method fails with the 0x00000103
	// (ERROR_NO_MORE_ITEMS) error code. The FAX_EndMessagesEnum (section 3.1.4.1.16) method
	// can then be called to halt the enumeration of messages.
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	EnumMessagesEx(context.Context, *EnumMessagesExRequest, ...dcerpc.CallOption) (*EnumMessagesExResponse, error)

	// The FAX_StartServerNotificationEx2 (Opnum 92) method is called by the client to get
	// notification about extended events. On success, the server MUST start to notify the
	// fax client about the occurring fax events.
	//
	// Protocol version FAX_API_VERSION_0 (0x00000000), FAX_API_VERSION_1 (0x00010000),
	// and FAX_API_VERSION_2 (0x00020000) fax servers SHOULD NOT implement this call. The
	// fax client MUST NOT call this method if the protocol version reported by the server
	// is FAX_API_VERSION_0 (0x00000000), FAX_API_VERSION_1 (0x00010000), or FAX_API_VERSION_2
	// (0x00020000). For more information, see FAX_ConnectFaxServer (section 3.1.4.1.10).
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. This error is returned when any of the following conditions    |
	//	|                                    | occur: § The dwEventTypes parameter is set to a value containing the             |
	//	|                                    | FAX_EVENT_TYPE_NEW_CALL or FAX_EVENT_TYPE_IN_QUEUE flags, the incoming faxes are |
	//	|                                    | not public (accessible to all users), and the client's fax user account does not |
	//	|                                    | have the FAX_ACCESS_MANAGE_RECEIVE_FOLDER permission. § dwEventTypes is set to   |
	//	|                                    | a value containing the FAX_EVENT_TYPE_CONFIG, FAX_EVENT_TYPE_DEVICE_STATUS, or   |
	//	|                                    | FAX_EVENT_TYPE_ACTIVITY flags and the client's fax user account does not have    |
	//	|                                    | the FAX_ACCESS_QUERY_CONFIG permission.                                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_OUTOFMEMORY 0x0000000E       | The fax server failed to allocate the memory required for the internal server's  |
	//	|                                    | execution of this operation request.                                             |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_GEN_FAILURE 0x0000001F       | The server threw internally an exception during the execution of this operation, |
	//	|                                    | and the server handled this exception.                                           |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. This error code is returned under any of the         |
	//	|                                    | following conditions: § dwEventTypes is set to a value containing the            |
	//	|                                    | FAX_EVENT_TYPE_LEGACY or FAX_EVENT_TYPE_LOCAL_ONLY flags, or to another          |
	//	|                                    | value that is not a combination made exclusively from the flags valid            |
	//	|                                    | for this operation: FAX_EVENT_TYPE_IN_QUEUE, FAX_EVENT_TYPE_OUT_QUEUE,           |
	//	|                                    | FAX_EVENT_TYPE_CONFIG, FAX_EVENT_TYPE_ACTIVITY, FAX_EVENT_TYPE_QUEUE_STATE,      |
	//	|                                    | FAX_EVENT_TYPE_IN_ARCHIVE, FAX_EVENT_TYPE_OUT_ARCHIVE,                           |
	//	|                                    | FAX_EVENT_TYPE_FXSSVC_ENDED, FAX_EVENT_TYPE_DEVICE_STATUS, or                    |
	//	|                                    | FAX_EVENT_TYPE_NEW_CALL. § The level parameter is not set to 1. § One or more    |
	//	|                                    | of the following parameters are set to NULL pointer values: lpcwstrEndpoint,     |
	//	|                                    | lpcwstrMachineName, or lpHandle.<177> § The lpcwstrAccountName parameter is set  |
	//	|                                    | to a non-null character string pointer value which does not specify a valid fax  |
	//	|                                    | account name. § lpcwstrAccountName is set to a non-null character string pointer |
	//	|                                    | value which specifies a valid fax account name for a different user than the     |
	//	|                                    | user who is currently logged on the client.                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	//
	// The account name is the one on which to listen for events and a level that specifies
	// the type of the structure that describes each event. The name lpcwstrAccountName
	// is accessed only for account-based events.
	//
	// The account name that lpcwstrAccountName indicates MUST be in one of the following
	// formats. Any other format is invalid.
	//
	//	+----------------------------+--------------------------------------------------------------------------+
	//	|                            |                                                                          |
	//	|           FORMAT           |                               DESCRIPTION                                |
	//	|                            |                                                                          |
	//	+----------------------------+--------------------------------------------------------------------------+
	//	+----------------------------+--------------------------------------------------------------------------+
	//	| <machine_name>\<user_name> | For a local user that has machine_name as the name of the local machine. |
	//	+----------------------------+--------------------------------------------------------------------------+
	//	| <domain_name>\<user_name>  | For a nonlocal user.                                                     |
	//	+----------------------------+--------------------------------------------------------------------------+
	//
	// A fax client calls FAX_StartServerNotificationEx2 (section 3.1.4.1.102) to inform
	// the server that it needs to receive notifications of extended fax events. The fax
	// server SHOULD call FAX_OpenConnection on the client by using the supplied endpoint,
	// protocol sequence information, and context handle information. The server then sends
	// notification of events to the client by using FAX_ClientEventQueueEx (section 3.2.4.3).
	// When the client no longer needs to receive notifications, it calls FAX_EndServerNotification
	// (section 3.1.4.1.17), and the server SHOULD call FAX_CloseConnection (section 3.2.4.4)
	// to close the connection.
	StartServerNotificationEx2(context.Context, *StartServerNotificationEx2Request, ...dcerpc.CallOption) (*StartServerNotificationEx2Response, error)

	// The FAX_CreateAccount (Opnum 93) method is called by the client to request a new
	// fax user account to be created based on an existing valid operating system user account.
	//
	// Protocol version FAX_API_VERSION_0 (0x00000000), FAX_API_VERSION_1 (0x00010000),
	// and FAX_API_VERSION_2 (0x00020000) fax servers SHOULD NOT implement this call. The
	// fax client MUST NOT call this method if the protocol version reported by the server
	// is FAX_API_VERSION_0 (0x00000000), FAX_API_VERSION_1 (0x00010000), or FAX_API_VERSION_2
	// (0x00020000). For more information, see FAX_ConnectFaxServer (section 3.1.4.1.10).
	//
	// Return Values: This method MUST return 0 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors that are defined
	// in [MS-ERREF] section 2.2.
	//
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	|                RETURN                 |                                                                                  |
	//	|              VALUE/CODE               |                                   DESCRIPTION                                    |
	//	|                                       |                                                                                  |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005        | Access is denied. The client's fax user account does not have the                |
	//	|                                       | FAX_ACCESS_MANAGE_CONFIG access right.                                           |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057    | The parameter is incorrect. This value is returned when any of the following     |
	//	|                                       | conditions are true: § The Buffer parameter is NULL. § The BufferSize parameter  |
	//	|                                       | is 0. § The level parameter is greater than zero. § The account name, as pointed |
	//	|                                       | to by the account information contained in Buffer, is NULL or is specified using |
	//	|                                       | an invalid format.                                                               |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ALREADY_EXISTS 0x000000B7       | The fax account already exists.                                                  |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_HANDLE_STATE 0x00000649 | The handle is in an invalid state.                                               |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//
	// The account name contained in the lpcwstrAccountName member of the FAX_ACCOUNT_INFO_0,
	// as pointed to by the Buffer parameter, MUST be in one of the following formats. Any
	// other format is invalid.
	//
	//	+----------------------------+-----------------------------------------------------------------+
	//	|                            |                                                                 |
	//	|           FORMAT           |                           DESCRIPTION                           |
	//	|                            |                                                                 |
	//	+----------------------------+-----------------------------------------------------------------+
	//	+----------------------------+-----------------------------------------------------------------+
	//	| <machine_name>\<user_name> | For a local user with machine_name as the local machine's name. |
	//	+----------------------------+-----------------------------------------------------------------+
	//	| <domain_name>\<user_name>  | For a nonlocal user.                                            |
	//	+----------------------------+-----------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol [MS-RPCE].
	CreateAccount(context.Context, *CreateAccountRequest, ...dcerpc.CallOption) (*CreateAccountResponse, error)

	// The FAX_DeleteAccount (Opnum 94) method is called by the client to delete a fax user
	// account previously created with FAX_CreateAccount (section 3.1.4.1.12).
	//
	// Protocol version FAX_API_VERSION_0 (0x00000000), FAX_API_VERSION_1 (0x00010000),
	// and FAX_API_VERSION_2 (0x00020000) fax servers SHOULD NOT implement this call. The
	// fax client MUST NOT call this method if the protocol version reported by the server
	// is FAX_API_VERSION_0 (0x00000000), FAX_API_VERSION_1 (0x00010000), or FAX_API_VERSION_2
	// (0x00020000). For more information, see FAX_ConnectFaxServer (section 3.1.4.1.10).
	//
	// On success, the server MUST delete the specified fax account. The server MUST validate
	// that the client's fax user account has access to delete fax user accounts on the
	// fax server. The client can delete any fax user accounts or the current fax user account.
	// Any subsequent operations on the deleted fax user accounts MUST be failed by the
	// server with the error code ERROR_ACCESS_DENIED. The fax server SHOULD allow deleting
	// a fax user account even if the underlying operating system's user account has been
	// deleted after this fax user account was created.
	//
	// Return Values: This method MUST return 0 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, a fax-specific error defined in
	// section 2.2.52, or one of the standard errors that are defined in [MS-ERREF] section
	// 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|            RETURN ERROR            |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The client's fax user account does not have the                |
	//	|                                    | FAX_ACCESS_MANAGE_CONFIG access right.                                           |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. The account name pointed to by the                   |
	//	|                                    | lpcwstrAccountName parameter is NULL or improperly formatted.                    |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// The account name that lpcwstrAccountName indicates MUST be in one of the following
	// formats. Any other format is invalid.
	//
	//	+----------------------------+-----------------------------------------------------------------+
	//	|                            |                                                                 |
	//	|           FORMAT           |                           DESCRIPTION                           |
	//	|                            |                                                                 |
	//	+----------------------------+-----------------------------------------------------------------+
	//	+----------------------------+-----------------------------------------------------------------+
	//	| <machine_name>\<user_name> | For a local user with machine_name as the local machine's name. |
	//	+----------------------------+-----------------------------------------------------------------+
	//	| <domain_name>\<user_name>  | For a remote (not local) user.                                  |
	//	+----------------------------+-----------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	DeleteAccount(context.Context, *DeleteAccountRequest, ...dcerpc.CallOption) (*DeleteAccountResponse, error)

	// The FAX_EnumAccounts (Opnum 95) method is called by the client to enumerate all the
	// fax accounts on the server.
	//
	// Protocol version FAX_API_VERSION_0 (0x00000000), FAX_API_VERSION_1  (0x00010000),
	// and FAX_API_VERSION_2 (0x00020000) fax servers SHOULD NOT implement this call. The
	// fax client MUST NOT call this method if the protocol version reported by the server
	// is FAX_API_VERSION_0 (0x00000000), FAX_API_VERSION_1 (0x00010000), or FAX_API_VERSION_2
	// (0x00020000). For more information, see FAX_ConnectFaxServer (section 3.1.4.1.10).
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | The client's fax user account does not have the access right                     |
	//	|                                    | FAX_ACCESS_QUERY_CONFIG to perform this operation.                               |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NOT_ENOUGH_MEMORY 0x00000008 | The fax server failed to allocate the amount of memory needed to process this    |
	//	|                                    | request.                                                                         |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. This error code is returned if any of the following  |
	//	|                                    | conditions are met: § The value specified for the level parameter is not         |
	//	|                                    | equal to zero. § The pointer specified by the Buffer parameter is NULL.<83>      |
	//	|                                    | § The value pointed to by the BufferSize parameter is zero.<84> § The pointer    |
	//	|                                    | specified by the lpdwAccounts parameter is NULL.<85>                             |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// The account name that lpcwstrAccountName indicates MUST be in one of the following
	// formats. Any other format is invalid.
	//
	//	+----------------------------+-----------------------------------------------------------------+
	//	|                            |                                                                 |
	//	|           FORMAT           |                           DESCRIPTION                           |
	//	|                            |                                                                 |
	//	+----------------------------+-----------------------------------------------------------------+
	//	+----------------------------+-----------------------------------------------------------------+
	//	| <machine_name>\<user_name> | For a local user with machine_name as the local machine's name. |
	//	+----------------------------+-----------------------------------------------------------------+
	//	| <domain_name>\<user_name>  | For a nonlocal user.                                            |
	//	+----------------------------+-----------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	EnumAccounts(context.Context, *EnumAccountsRequest, ...dcerpc.CallOption) (*EnumAccountsResponse, error)

	// The FAX_GetAccountInfo (Opnum 96) method is called by the client to retrieve information
	// about a specified fax user account. The fax user account for which information is
	// retrieved is specified by the lpcwstrAccountName parameter, which can be obtained
	// using the FAX_EnumAccounts (section 3.1.4.1.18) method.
	//
	// Protocol version FAX_API_VERSION_0 (0x00000000), FAX_API_VERSION_1 (0x00010000),
	// and FAX_API_VERSION_2 (0x00020000) fax servers SHOULD NOT implement this call. The
	// fax client MUST NOT call this method if the protocol version reported by the server
	// is FAX_API_VERSION_0 (0x00000000), FAX_API_VERSION_1 (0x00010000), or FAX_API_VERSION_2
	// (0x00020000). For more information, see FAX_ConnectFaxServer (section 3.1.4.1.10).
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_FILE_NOT_FOUND 0x00000002    | The account name specified by the lpcwstrAccountName parameter appears valid but |
	//	|                                    | does not exist.                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The user account specified by the lpwstrAccountName            |
	//	|                                    | argument is not the caller, and it does not have the fax access rights           |
	//	|                                    | FAX_ACCESS_QUERY_CONFIG.                                                         |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. The value of the level argument is greater than      |
	//	|                                    | zero. The account name specified by lpcwstrAccountName is not a valid fax        |
	//	|                                    | account name.                                                                    |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// The account name that lpcwstrAccountName indicates MUST be in one of the following
	// formats. Any other format is invalid.
	//
	//	+----------------------------+--------------------------------------------------------------------------+
	//	|                            |                                                                          |
	//	|           FORMAT           |                               DESCRIPTION                                |
	//	|                            |                                                                          |
	//	+----------------------------+--------------------------------------------------------------------------+
	//	+----------------------------+--------------------------------------------------------------------------+
	//	| <machine_name>\<user_name> | For a local user that has machine_name as the name of the local machine. |
	//	+----------------------------+--------------------------------------------------------------------------+
	//	| <domain_name>\<user_name>  | For a nonlocal user.                                                     |
	//	+----------------------------+--------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	GetAccountInfo(context.Context, *GetAccountInfoRequest, ...dcerpc.CallOption) (*GetAccountInfoResponse, error)

	// The FAX_GetGeneralConfiguration (Opnum 97) method is called by the client to request
	// information about the general configuration at the server.
	//
	// Protocol version FAX_API_VERSION_0 (0x00000000), FAX_API_VERSION_1 (0x00010000),
	// and FAX_API_VERSION_2 (0x00020000) fax servers SHOULD NOT implement this call. The
	// fax client MUST NOT call this method if the protocol version reported by the server
	// is FAX_API_VERSION_0 (0x00000000), FAX_API_VERSION_1 (0x00010000), or FAX_API_VERSION_2
	// (0x00020000). For more information, see FAX_ConnectFaxServer (section 3.1.4.1.10).
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The client's fax user account does not have the                |
	//	|                                    | FAX_ACCESS_QUERY_CONFIG access rights required for this operation.               |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NOT_ENOUGH_MEMORY 0x00000008 | Not enough storage is available to process this command. The fax server failed   |
	//	|                                    | to allocate sufficient memory to hold the FAX_GENERAL_CONFIG to be returned to   |
	//	|                                    | the client.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. The level parameter is set to a value other than 0.  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INTERNAL_ERROR 0x0000054F    | The fax server failed to custom marshal the FAX_GENERAL_CONFIG to be returned to |
	//	|                                    | the client.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	GetGeneralConfiguration(context.Context, *GetGeneralConfigurationRequest, ...dcerpc.CallOption) (*GetGeneralConfigurationResponse, error)

	// The fax client application calls the FAX_SetGeneralConfiguration (Opnum 98) method
	// to set the configuration options provided for the fax service. The FAX_GENERAL_CONFIG
	// (section 2.2.31) structure MUST be serialized. The variable data fields, such as
	// strings, MUST be filled with the offset to the string from the beginning of the buffer
	// and not the actual address. In response, the server MUST validate that the client's
	// fax user account has access to manage configuration on the server. On success, the
	// server MUST set the requested configuration options.
	//
	// Protocol version FAX_API_VERSION_0 (0x00000000), FAX_API_VERSION_1  (0x00010000),
	// and FAX_API_VERSION_2 (0x00020000) fax servers SHOULD NOT implement this call. The
	// fax client MUST NOT call this method if the protocol version reported by the server
	// is FAX_API_VERSION_0 (0x00000000), FAX_API_VERSION_1 (0x00010000), or FAX_API_VERSION_2
	// (0x00020000). For more information, see FAX_ConnectFaxServer (section 3.1.4.1.10).
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The client's fax user account does not have the required       |
	//	|                                    | FAX_ACCESS_MANAGE_CONFIG authorization for this operation.                       |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NOT_ENOUGH_MEMORY 0x00000008 | In order to process the data for custom marshaling, the server needs to make     |
	//	|                                    | a copy of the FAX_GENERAL_CONFIG provided by the client; but the server cannot   |
	//	|                                    | allocate sufficient memory to hold the copy of the FAX_GENERAL_CONFIG.           |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_DATA 0x0000000D      | The lpcwstrArchiveLocationOffset member of the Fixed_Portion of the              |
	//	|                                    | FAX_GENERAL_CONFIG referenced by the Buffer parameter is set to an invalid       |
	//	|                                    | offset value.                                                                    |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. This error code is returned if any of the following  |
	//	|                                    | conditions are met: § The level parameter is set to a value greater than 0. §    |
	//	|                                    | In the FAX_GENERAL_CONFIG referenced by Buffer, the dtDiscountStart.Hour member  |
	//	|                                    | is set to a value greater than or equal to 24, and the dtDiscountStart.Minute    |
	//	|                                    | member is set to a value greater than or equal to 60. § In the                   |
	//	|                                    | FAX_GENERAL_CONFIG referenced by Buffer, the dtDiscountEnd.Hour member is set    |
	//	|                                    | to a value greater than or equal to 24, and the dtDiscountEnd.Minute member      |
	//	|                                    | is set to a value greater than or equal to 60. § In the FAX_GENERAL_CONFIG       |
	//	|                                    | referenced by Buffer, the bUseArchive member is set to TRUE and the              |
	//	|                                    | lpcwstrArchiveLocationOffset member is set to 0. § In the FAX_GENERAL_CONFIG     |
	//	|                                    | referenced by Buffer, the dwSizeQuotaHighWaterMark member is set to a value      |
	//	|                                    | greater than the value of the dwSizeQuotaLowWaterMark member. § In the           |
	//	|                                    | FAX_GENERAL_CONFIG referenced by Buffer, the dwQueueState member contains one    |
	//	|                                    | or more of the following flag values: FAX_INCOMING_BLOCKED, FAX_OUTBOX_BLOCKED,  |
	//	|                                    | or FAX_OUTBOX_PAUSED. § The value of the BufferSize parameter is less than       |
	//	|                                    | the size required to hold the custom marshaled FAX_GENERAL_CONFIG structure      |
	//	|                                    | referenced by Buffer. This size is specified by the dwSizeOfStruct member of the |
	//	|                                    | FAX_GENERAL_CONFIG referenced by Buffer.                                         |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INTERNAL_ERROR 0x0000054F    | The server failed to parse the custom marshaled FAX_GENERAL_CONFIG.              |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol [MS-RPCE].
	SetGeneralConfiguration(context.Context, *SetGeneralConfigurationRequest, ...dcerpc.CallOption) (*SetGeneralConfigurationResponse, error)

	// The FAX_GetSecurityEx2 (Opnum 99) method is called by the client to retrieve information
	// about the fax security descriptor from the fax server.
	//
	// Protocol version FAX_API_VERSION_0 (0x00000000), FAX_API_VERSION_1 (0x00010000),
	// and FAX_API_VERSION_2 (0x00020000) fax servers SHOULD NOT implement this call. The
	// fax client MUST NOT call this method if the protocol version reported by the server
	// is FAX_API_VERSION_0 (0x00000000), FAX_API_VERSION_1 (0x00010000), or FAX_API_VERSION_2
	// (0x00020000). For more information, see FAX_ConnectFaxServer (section 3.1.4.1.10).
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	|                 RETURN                  |                                                                                  |
	//	|               VALUE/CODE                |                                   DESCRIPTION                                    |
	//	|                                         |                                                                                  |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005          | Access is denied. This error is returned when there is a mismatch between        |
	//	|                                         | the access level requested (Read control, access to set/get SACL security        |
	//	|                                         | information or both) through the bit pattern in SecurityInformation and the      |
	//	|                                         | current authorized level.                                                        |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NOT_ENOUGH_MEMORY 0x00000008      | Not enough storage is available to process this command.                         |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057      | The parameter is incorrect. This error code is returned under any of the         |
	//	|                                         | following conditions: § The pSecurityDescriptor parameter is NULL. § The value   |
	//	|                                         | of the SecurityInformation parameter does not conform to the definition of valid |
	//	|                                         | bit patterns for this parameter.                                                 |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_SECURITY_DESCR 0x0000053A | The security descriptor structure is invalid.                                    |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol [MS-RPCE].
	GetSecurityEx2(context.Context, *GetSecurityEx2Request, ...dcerpc.CallOption) (*GetSecurityEx2Response, error)

	// The FAX_SetSecurityEx2 (Opnum 100) method is called by the client. On success, the
	// server MUST set the fax server's security descriptor.
	//
	// Protocol version FAX_API_VERSION_0 (0x00000000), FAX_API_VERSION_1  (0x00010000),
	// and FAX_API_VERSION_2 (0x00020000) fax servers SHOULD NOT implement this call. The
	// fax client MUST NOT call this method if the protocol version reported by the server
	// is FAX_API_VERSION_0 (0x00000000), FAX_API_VERSION_1 (0x00010000), or FAX_API_VERSION_2
	// (0x00020000). For more information, see FAX_ConnectFaxServer (section 3.1.4.1.10).
	// The fax client SHOULD call FAX_SetSecurity (section 3.1.4.1.94) instead.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The client's fax user account does not have the access         |
	//	|                                    | rights required for this operation: § WRITE_OWNER, when the SecurityInformation  |
	//	|                                    | parameter contains the OWNER_SECURITY_INFORMATION value. § WRITE_DAC,            |
	//	|                                    | when SecurityInformation contains the GROUP_SECURITY_INFORMATION                 |
	//	|                                    | or DACL_SECURITY_INFORMATION values. § ACCESS_SYSTEM_SECURITY, when              |
	//	|                                    | SecurityInformation contains the SACL_SECURITY_INFORMATION value.                |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_DATA 0x0000000D      | The data is invalid. The data contained in the buffer specified by the           |
	//	|                                    | pSecurityDescriptor parameter is not a valid SECURITY_DESCRIPTOR.                |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_OUTOFMEMORY 0x0000000E       | The fax server cannot allocate sufficient memory for a properly constructed      |
	//	|                                    | FAX_EVENT_EX_1 (section 2.2.68) structure describing a FAX_EVENT_TYPE_CONFIG     |
	//	|                                    | event to be signaled to the client. A properly constructed structure has the     |
	//	|                                    | ConfigType member of the FAX_EVENT_EX_1 set to FAX_CONFIG_TYPE_SECURITY. For     |
	//	|                                    | more details, see FAX_ClientEventQueueEx (section 3.2.4.3).                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. This error code is returned under any                |
	//	|                                    | of the following conditions: § pSecurityDescriptor is set to a NULL              |
	//	|                                    | pointer value. § The dwBufferSize parameter is set to 0x00000000. §              |
	//	|                                    | SecurityInformation is set to a value that does not contain any of the           |
	//	|                                    | following flags: OWNER_SECURITY_INFORMATION, GROUP_SECURITY_INFORMATION,         |
	//	|                                    | DACL_SECURITY_INFORMATION, or SACL_SECURITY_INFORMATION.                         |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_REGISTRY_CORRUPT 0x000003F7  | The registry is corrupted. The structure of one of the files that contains       |
	//	|                                    | registry data is corrupted, or the system's memory image of the file is          |
	//	|                                    | corrupted, or the file could not be recovered because the alternate copy or log  |
	//	|                                    | was absent or corrupted.                                                         |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	SetSecurityEx2(context.Context, *SetSecurityEx2Request, ...dcerpc.CallOption) (*SetSecurityEx2Response, error)

	// The FAX_AccessCheckEx2 (Opnum 101) method is called by the client when the client
	// needs to check whether the client's fax user account has certain access permissions
	// on the server.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The caller does not have the required permissions for this     |
	//	|                                    | request (the caller does not have a valid fax user account).                     |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | The parameter is incorrect. This error code is returned under any of the         |
	//	|                                    | following conditions: § The pointer specified in the pfAccess parameter is NULL. |
	//	|                                    | § The fax access rights specified in the lpdwRights parameter contain invalid    |
	//	|                                    | access values.                                                                   |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol [MS-RPCE].
	AccessCheckEx2(context.Context, *AccessCheckEx2Request, ...dcerpc.CallOption) (*AccessCheckEx2Response, error)

	// The fax client application calls the FAX_ReAssignMessage (Opnum 102) method to reassign
	// the specified fax message to a set of users.<144>
	//
	// Protocol version FAX_API_VERSION_0 (0x00000000), FAX_API_VERSION_1 (0x00010000),
	// and FAX_API_VERSION_2 (0x00020000) fax servers SHOULD NOT implement this call. The
	// fax client MUST NOT call this method if the protocol version reported by the server
	// is FAX_API_VERSION_0 (0x00000000), FAX_API_VERSION_1 (0x00010000), or FAX_API_VERSION_2
	// (0x00020000). For more information, see FAX_ConnectFaxServer (section 3.1.4.1.10).
	//
	// The dwlMessageId parameter specifies a particular message and can be obtained using
	// the FAX_EnumMessages (section 3.1.4.1.24) method or the FAX_EnumMessagesEx (section
	// 3.1.4.1.25) methods.
	//
	// The client MUST specify the recipients for a reassigned message in a semicolon (;)
	// separated format. In response, the server MUST validate whether the bIncomingFaxesArePublic
	// option in the FAX_GENERAL_CONFIG (section 2.2.31) data structure is not set in the
	// server configuration. The server MUST also validate whether the message that is specified
	// by the dwlMessageId argument refers to a valid message on the server. The server
	// MUST validate that there are recipient numbers for each of the recipients that are
	// listed in pReAssignInfo structure. On success, the server MUST reassign the specified
	// fax message.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_FILE_NOT_FOUND 0x00000002    | This error code is returned under any of the following conditions: § The         |
	//	|                                    | dwlMessageId argument does not specify a valid message. § One or more recipients |
	//	|                                    | specified in the lpcwstrRecipients field of the pReAssignInfo argument do not    |
	//	|                                    | have a corresponding fax user account.                                           |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | The caller does not have the FAX_ACCESS_MANAGE_RECEIVE_FOLDER access rights.     |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | This error code is returned under any of the following conditions: § The value   |
	//	|                                    | specified for the dwlMessageId parameter is zero. § The lpcwstrRecipients member |
	//	|                                    | of the data structure specified by the pReAssignInfo parameter is set to NULL or |
	//	|                                    | to an empty string.                                                              |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_BUFFER_OVERFLOW 0x0000006F   | The number of recipients specified in the lpcwstrRecipients member of the        |
	//	|                                    | data structure pointed at by pReAssignInfo is greater than FAX_MAX_RECIPIENTS    |
	//	|                                    | (10000).                                                                         |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_OPERATION 0x000010DD | This error code is returned under any of the following conditions: § Incoming    |
	//	|                                    | faxes are public (section 2.2.31). Reassignment is not supported when incoming   |
	//	|                                    | faxes are public. § The server does not support reassignment, or the server      |
	//	|                                    | is configured with a policy that is currently set to disable fax message         |
	//	|                                    | reassignment.                                                                    |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol [MS-RPCE].
	ReassignMessage(context.Context, *ReassignMessageRequest, ...dcerpc.CallOption) (*ReassignMessageResponse, error)

	// The fax client application calls the FAX_SetMessage (Opnum 103) method to set the
	// specific message properties for the message identified by its ID.<162> The dwlMessageId
	// parameter specifies a particular message and can be obtained using the FAX_EnumMessages
	// (section 3.1.4.1.24) method or the FAX_EnumMessagesEx (section 3.1.4.1.25) method.
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	|                RETURN                |                                                                                  |
	//	|              VALUE/CODE              |                                   DESCRIPTION                                    |
	//	|                                      |                                                                                  |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005       | Access is denied. The client's fax user account does not have the                |
	//	|                                      | ALL_FAX_USER_ACCESS_RIGHTS access rights required for this operation.            |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057   | The parameter is incorrect. This error code is returned if any of the            |
	//	|                                      | following conditions are met: § The structure pointed to by the lpMessageProps   |
	//	|                                      | argument contains invalid data. § The Folder argument has an invalid value (a    |
	//	|                                      | value other than FAX_MESSAGE_FOLDER_INBOX or FAX_MESSAGE_FOLDER_SENTITEMS).      |
	//	|                                      | § The dwlMessageId parameter is zero. § In the structure pointed at              |
	//	|                                      | by the lpMessageProps argument, the dwValidityMask field contains the            |
	//	|                                      | FAX_MSG_PROP_FIELD_MSG_FLAGS, and the dwMsgFlags field does not contain the      |
	//	|                                      | FAX_MSG_ALL_FLAGS flag.                                                          |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ERR_MESSAGE_NOT_FOUND 0x00001B61 | The fax message specified by the dwlMessageId argument cannot be found by the    |
	//	|                                      | fax server in the folder specified by the Folder argument.                       |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol [MS-RPCE].
	SetMessage(context.Context, *SetMessageRequest, ...dcerpc.CallOption) (*SetMessageResponse, error)

	// The FAX_GetConfigOption (Opnum 104) is called by the client to retrieve a configuration
	// setting at the server using an RPC_REQUEST packet.
	//
	// Protocol version FAX_API_VERSION_0 (0x00000000), FAX_API_VERSION_1 (0x00010000),
	// and FAX_API_VERSION_2 (0x00020000) fax servers SHOULD NOT implement this call. The
	// fax client MUST NOT call this method if the protocol version reported by the server
	// is FAX_API_VERSION_0 (0x00000000), FAX_API_VERSION_1 (0x00010000), or FAX_API_VERSION_2
	// (0x00020000). For more information, see FAX_ConnectFaxServer (section 3.1.4.1.10).
	//
	// Return Values: This method MUST return 0x00000000 (ERROR_SUCCESS) for success; otherwise,
	// it MUST return one of the following error codes, one of the fax-specific errors that
	// are defined in section 2.2.52, or one of the other standard errors defined in [MS-ERREF]
	// section 2.2.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCESS_DENIED 0x00000005     | Access is denied. The client's fax user account does not have any of the         |
	//	|                                    | permissions covered by ALL_FAX_USER_ACCESS_RIGHTS.                               |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_INVALID_PARAMETER 0x00000057 | This error is returned when any of the following conditions are met: § The       |
	//	|                                    | lpdwValue parameter is set to a NULL pointer value.<103> § The configuration     |
	//	|                                    | option specified by the option parameter is not one of the following             |
	//	|                                    | values: FAX_CONFIG_OPTION_ALLOW_PERSONAL_CP, FAX_CONFIG_OPTION_QUEUE_STATE,      |
	//	|                                    | FAX_CONFIG_OPTION_ALLOW_RECEIPTS or FAX_CONFIG_OPTION_INCOMING_FAXES_PUBLIC.     |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Use of this method does not require FAX_ACCESS_QUERY_CONFIG access rights. A calling
	// user with any ACE on the server can use this method.
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, [MS-RPCE].
	GetConfigOption(context.Context, *GetConfigOptionRequest, ...dcerpc.CallOption) (*GetConfigOptionResponse, error)

	// AlterContext alters the client context.
	AlterContext(context.Context, ...dcerpc.Option) error

	// Conn returns the client connection (unsafe)
	Conn() dcerpc.Conn
}

type xxx_DefaultFaxClient struct {
	cc dcerpc.Conn
}

func (o *xxx_DefaultFaxClient) GetServicePrinters(ctx context.Context, in *GetServicePrintersRequest, opts ...dcerpc.CallOption) (*GetServicePrintersResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetServicePrintersResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) ConnectionReferenceCount(ctx context.Context, in *ConnectionReferenceCountRequest, opts ...dcerpc.CallOption) (*ConnectionReferenceCountResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ConnectionReferenceCountResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) OpenPort(ctx context.Context, in *OpenPortRequest, opts ...dcerpc.CallOption) (*OpenPortResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &OpenPortResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) ClosePort(ctx context.Context, in *ClosePortRequest, opts ...dcerpc.CallOption) (*ClosePortResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ClosePortResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) EnumJobs(ctx context.Context, in *EnumJobsRequest, opts ...dcerpc.CallOption) (*EnumJobsResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumJobsResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) GetJob(ctx context.Context, in *GetJobRequest, opts ...dcerpc.CallOption) (*GetJobResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetJobResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) SetJob(ctx context.Context, in *SetJobRequest, opts ...dcerpc.CallOption) (*SetJobResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetJobResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) GetPageData(ctx context.Context, in *GetPageDataRequest, opts ...dcerpc.CallOption) (*GetPageDataResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetPageDataResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) GetDeviceStatus(ctx context.Context, in *GetDeviceStatusRequest, opts ...dcerpc.CallOption) (*GetDeviceStatusResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetDeviceStatusResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) Abort(ctx context.Context, in *AbortRequest, opts ...dcerpc.CallOption) (*AbortResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AbortResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) EnumPorts(ctx context.Context, in *EnumPortsRequest, opts ...dcerpc.CallOption) (*EnumPortsResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumPortsResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) GetPort(ctx context.Context, in *GetPortRequest, opts ...dcerpc.CallOption) (*GetPortResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetPortResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) SetPort(ctx context.Context, in *SetPortRequest, opts ...dcerpc.CallOption) (*SetPortResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetPortResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) EnumRoutingMethods(ctx context.Context, in *EnumRoutingMethodsRequest, opts ...dcerpc.CallOption) (*EnumRoutingMethodsResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumRoutingMethodsResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) EnableRoutingMethod(ctx context.Context, in *EnableRoutingMethodRequest, opts ...dcerpc.CallOption) (*EnableRoutingMethodResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnableRoutingMethodResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) GetRoutingInfo(ctx context.Context, in *GetRoutingInfoRequest, opts ...dcerpc.CallOption) (*GetRoutingInfoResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetRoutingInfoResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) SetRoutingInfo(ctx context.Context, in *SetRoutingInfoRequest, opts ...dcerpc.CallOption) (*SetRoutingInfoResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetRoutingInfoResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) EnumGlobalRoutingInfo(ctx context.Context, in *EnumGlobalRoutingInfoRequest, opts ...dcerpc.CallOption) (*EnumGlobalRoutingInfoResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumGlobalRoutingInfoResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) SetGlobalRoutingInfo(ctx context.Context, in *SetGlobalRoutingInfoRequest, opts ...dcerpc.CallOption) (*SetGlobalRoutingInfoResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetGlobalRoutingInfoResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) GetConfiguration(ctx context.Context, in *GetConfigurationRequest, opts ...dcerpc.CallOption) (*GetConfigurationResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetConfigurationResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) SetConfiguration(ctx context.Context, in *SetConfigurationRequest, opts ...dcerpc.CallOption) (*SetConfigurationResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetConfigurationResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) GetLoggingCategories(ctx context.Context, in *GetLoggingCategoriesRequest, opts ...dcerpc.CallOption) (*GetLoggingCategoriesResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetLoggingCategoriesResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) SetLoggingCategories(ctx context.Context, in *SetLoggingCategoriesRequest, opts ...dcerpc.CallOption) (*SetLoggingCategoriesResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetLoggingCategoriesResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) GetSecurity(ctx context.Context, in *GetSecurityRequest, opts ...dcerpc.CallOption) (*GetSecurityResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetSecurityResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) SetSecurity(ctx context.Context, in *SetSecurityRequest, opts ...dcerpc.CallOption) (*SetSecurityResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetSecurityResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) AccessCheck(ctx context.Context, in *AccessCheckRequest, opts ...dcerpc.CallOption) (*AccessCheckResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AccessCheckResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) CheckServerProtocolSeq(ctx context.Context, in *CheckServerProtocolSeqRequest, opts ...dcerpc.CallOption) (*CheckServerProtocolSeqResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CheckServerProtocolSeqResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) SendDocumentEx(ctx context.Context, in *SendDocumentExRequest, opts ...dcerpc.CallOption) (*SendDocumentExResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SendDocumentExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) EnumJobsEx(ctx context.Context, in *EnumJobsExRequest, opts ...dcerpc.CallOption) (*EnumJobsExResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumJobsExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) GetJobEx(ctx context.Context, in *GetJobExRequest, opts ...dcerpc.CallOption) (*GetJobExResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetJobExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) GetCountryList(ctx context.Context, in *GetCountryListRequest, opts ...dcerpc.CallOption) (*GetCountryListResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetCountryListResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) GetPersonalProfileInfo(ctx context.Context, in *GetPersonalProfileInfoRequest, opts ...dcerpc.CallOption) (*GetPersonalProfileInfoResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetPersonalProfileInfoResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) GetQueueStates(ctx context.Context, in *GetQueueStatesRequest, opts ...dcerpc.CallOption) (*GetQueueStatesResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetQueueStatesResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) SetQueue(ctx context.Context, in *SetQueueRequest, opts ...dcerpc.CallOption) (*SetQueueResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetQueueResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) GetReceiptsConfiguration(ctx context.Context, in *GetReceiptsConfigurationRequest, opts ...dcerpc.CallOption) (*GetReceiptsConfigurationResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetReceiptsConfigurationResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) SetReceiptsConfiguration(ctx context.Context, in *SetReceiptsConfigurationRequest, opts ...dcerpc.CallOption) (*SetReceiptsConfigurationResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetReceiptsConfigurationResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) GetReceiptsOptions(ctx context.Context, in *GetReceiptsOptionsRequest, opts ...dcerpc.CallOption) (*GetReceiptsOptionsResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetReceiptsOptionsResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) GetVersion(ctx context.Context, in *GetVersionRequest, opts ...dcerpc.CallOption) (*GetVersionResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetVersionResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) GetOutboxConfiguration(ctx context.Context, in *GetOutboxConfigurationRequest, opts ...dcerpc.CallOption) (*GetOutboxConfigurationResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetOutboxConfigurationResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) SetOutboxConfiguration(ctx context.Context, in *SetOutboxConfigurationRequest, opts ...dcerpc.CallOption) (*SetOutboxConfigurationResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetOutboxConfigurationResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) GetPersonalCoverPagesOption(ctx context.Context, in *GetPersonalCoverPagesOptionRequest, opts ...dcerpc.CallOption) (*GetPersonalCoverPagesOptionResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetPersonalCoverPagesOptionResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) GetArchiveConfiguration(ctx context.Context, in *GetArchiveConfigurationRequest, opts ...dcerpc.CallOption) (*GetArchiveConfigurationResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetArchiveConfigurationResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) SetArchiveConfiguration(ctx context.Context, in *SetArchiveConfigurationRequest, opts ...dcerpc.CallOption) (*SetArchiveConfigurationResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetArchiveConfigurationResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) GetActivityLoggingConfiguration(ctx context.Context, in *GetActivityLoggingConfigurationRequest, opts ...dcerpc.CallOption) (*GetActivityLoggingConfigurationResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetActivityLoggingConfigurationResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) SetActivityLoggingConfiguration(ctx context.Context, in *SetActivityLoggingConfigurationRequest, opts ...dcerpc.CallOption) (*SetActivityLoggingConfigurationResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetActivityLoggingConfigurationResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) EnumerateProviders(ctx context.Context, in *EnumerateProvidersRequest, opts ...dcerpc.CallOption) (*EnumerateProvidersResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumerateProvidersResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) GetPortEx(ctx context.Context, in *GetPortExRequest, opts ...dcerpc.CallOption) (*GetPortExResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetPortExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) SetPortEx(ctx context.Context, in *SetPortExRequest, opts ...dcerpc.CallOption) (*SetPortExResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetPortExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) EnumPortsEx(ctx context.Context, in *EnumPortsExRequest, opts ...dcerpc.CallOption) (*EnumPortsExResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumPortsExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) GetExtensionData(ctx context.Context, in *GetExtensionDataRequest, opts ...dcerpc.CallOption) (*GetExtensionDataResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetExtensionDataResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) SetExtensionData(ctx context.Context, in *SetExtensionDataRequest, opts ...dcerpc.CallOption) (*SetExtensionDataResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetExtensionDataResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) AddOutboundGroup(ctx context.Context, in *AddOutboundGroupRequest, opts ...dcerpc.CallOption) (*AddOutboundGroupResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddOutboundGroupResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) SetOutboundGroup(ctx context.Context, in *SetOutboundGroupRequest, opts ...dcerpc.CallOption) (*SetOutboundGroupResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetOutboundGroupResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) RemoveOutboundGroup(ctx context.Context, in *RemoveOutboundGroupRequest, opts ...dcerpc.CallOption) (*RemoveOutboundGroupResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &RemoveOutboundGroupResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) EnumOutboundGroups(ctx context.Context, in *EnumOutboundGroupsRequest, opts ...dcerpc.CallOption) (*EnumOutboundGroupsResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumOutboundGroupsResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) SetDeviceOrderInGroup(ctx context.Context, in *SetDeviceOrderInGroupRequest, opts ...dcerpc.CallOption) (*SetDeviceOrderInGroupResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetDeviceOrderInGroupResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) AddOutboundRule(ctx context.Context, in *AddOutboundRuleRequest, opts ...dcerpc.CallOption) (*AddOutboundRuleResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddOutboundRuleResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) RemoveOutboundRule(ctx context.Context, in *RemoveOutboundRuleRequest, opts ...dcerpc.CallOption) (*RemoveOutboundRuleResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &RemoveOutboundRuleResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) SetOutboundRule(ctx context.Context, in *SetOutboundRuleRequest, opts ...dcerpc.CallOption) (*SetOutboundRuleResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetOutboundRuleResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) EnumOutboundRules(ctx context.Context, in *EnumOutboundRulesRequest, opts ...dcerpc.CallOption) (*EnumOutboundRulesResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumOutboundRulesResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) RegisterServiceProviderEx(ctx context.Context, in *RegisterServiceProviderExRequest, opts ...dcerpc.CallOption) (*RegisterServiceProviderExResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &RegisterServiceProviderExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) UnregisterServiceProviderEx(ctx context.Context, in *UnregisterServiceProviderExRequest, opts ...dcerpc.CallOption) (*UnregisterServiceProviderExResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &UnregisterServiceProviderExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) UnregisterRoutingExtension(ctx context.Context, in *UnregisterRoutingExtensionRequest, opts ...dcerpc.CallOption) (*UnregisterRoutingExtensionResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &UnregisterRoutingExtensionResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) StartMessagesEnum(ctx context.Context, in *StartMessagesEnumRequest, opts ...dcerpc.CallOption) (*StartMessagesEnumResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &StartMessagesEnumResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) EndMessagesEnum(ctx context.Context, in *EndMessagesEnumRequest, opts ...dcerpc.CallOption) (*EndMessagesEnumResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EndMessagesEnumResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) EnumMessages(ctx context.Context, in *EnumMessagesRequest, opts ...dcerpc.CallOption) (*EnumMessagesResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumMessagesResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) GetMessage(ctx context.Context, in *GetMessageRequest, opts ...dcerpc.CallOption) (*GetMessageResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetMessageResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) RemoveMessage(ctx context.Context, in *RemoveMessageRequest, opts ...dcerpc.CallOption) (*RemoveMessageResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &RemoveMessageResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) StartCopyToServer(ctx context.Context, in *StartCopyToServerRequest, opts ...dcerpc.CallOption) (*StartCopyToServerResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &StartCopyToServerResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) StartCopyMessageFromServer(ctx context.Context, in *StartCopyMessageFromServerRequest, opts ...dcerpc.CallOption) (*StartCopyMessageFromServerResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &StartCopyMessageFromServerResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) WriteFile(ctx context.Context, in *WriteFileRequest, opts ...dcerpc.CallOption) (*WriteFileResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &WriteFileResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) ReadFile(ctx context.Context, in *ReadFileRequest, opts ...dcerpc.CallOption) (*ReadFileResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ReadFileResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) EndCopy(ctx context.Context, in *EndCopyRequest, opts ...dcerpc.CallOption) (*EndCopyResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EndCopyResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) StartServerNotification(ctx context.Context, in *StartServerNotificationRequest, opts ...dcerpc.CallOption) (*StartServerNotificationResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &StartServerNotificationResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) StartServerNotificationEx(ctx context.Context, in *StartServerNotificationExRequest, opts ...dcerpc.CallOption) (*StartServerNotificationExResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &StartServerNotificationExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) EndServerNotification(ctx context.Context, in *EndServerNotificationRequest, opts ...dcerpc.CallOption) (*EndServerNotificationResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EndServerNotificationResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) GetServerActivity(ctx context.Context, in *GetServerActivityRequest, opts ...dcerpc.CallOption) (*GetServerActivityResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetServerActivityResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) SetConfigWizardUsed(ctx context.Context, in *SetConfigWizardUsedRequest, opts ...dcerpc.CallOption) (*SetConfigWizardUsedResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetConfigWizardUsedResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) EnumRoutingExtensions(ctx context.Context, in *EnumRoutingExtensionsRequest, opts ...dcerpc.CallOption) (*EnumRoutingExtensionsResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumRoutingExtensionsResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) ConnectFaxServer(ctx context.Context, in *ConnectFaxServerRequest, opts ...dcerpc.CallOption) (*ConnectFaxServerResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ConnectFaxServerResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) GetSecurityEx(ctx context.Context, in *GetSecurityExRequest, opts ...dcerpc.CallOption) (*GetSecurityExResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetSecurityExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) RefreshArchive(ctx context.Context, in *RefreshArchiveRequest, opts ...dcerpc.CallOption) (*RefreshArchiveResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &RefreshArchiveResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) SetRecipientsLimit(ctx context.Context, in *SetRecipientsLimitRequest, opts ...dcerpc.CallOption) (*SetRecipientsLimitResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetRecipientsLimitResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) GetRecipientsLimit(ctx context.Context, in *GetRecipientsLimitRequest, opts ...dcerpc.CallOption) (*GetRecipientsLimitResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetRecipientsLimitResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) GetServerSKU(ctx context.Context, in *GetServerSKURequest, opts ...dcerpc.CallOption) (*GetServerSKUResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetServerSKUResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) CheckValidFaxFolder(ctx context.Context, in *CheckValidFaxFolderRequest, opts ...dcerpc.CallOption) (*CheckValidFaxFolderResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CheckValidFaxFolderResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) GetJobEx2(ctx context.Context, in *GetJobEx2Request, opts ...dcerpc.CallOption) (*GetJobEx2Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetJobEx2Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) EnumJobsEx2(ctx context.Context, in *EnumJobsEx2Request, opts ...dcerpc.CallOption) (*EnumJobsEx2Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumJobsEx2Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) GetMessageEx(ctx context.Context, in *GetMessageExRequest, opts ...dcerpc.CallOption) (*GetMessageExResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetMessageExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) StartMessagesEnumEx(ctx context.Context, in *StartMessagesEnumExRequest, opts ...dcerpc.CallOption) (*StartMessagesEnumExResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &StartMessagesEnumExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) EnumMessagesEx(ctx context.Context, in *EnumMessagesExRequest, opts ...dcerpc.CallOption) (*EnumMessagesExResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumMessagesExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) StartServerNotificationEx2(ctx context.Context, in *StartServerNotificationEx2Request, opts ...dcerpc.CallOption) (*StartServerNotificationEx2Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &StartServerNotificationEx2Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) CreateAccount(ctx context.Context, in *CreateAccountRequest, opts ...dcerpc.CallOption) (*CreateAccountResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CreateAccountResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) DeleteAccount(ctx context.Context, in *DeleteAccountRequest, opts ...dcerpc.CallOption) (*DeleteAccountResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &DeleteAccountResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) EnumAccounts(ctx context.Context, in *EnumAccountsRequest, opts ...dcerpc.CallOption) (*EnumAccountsResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumAccountsResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) GetAccountInfo(ctx context.Context, in *GetAccountInfoRequest, opts ...dcerpc.CallOption) (*GetAccountInfoResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetAccountInfoResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) GetGeneralConfiguration(ctx context.Context, in *GetGeneralConfigurationRequest, opts ...dcerpc.CallOption) (*GetGeneralConfigurationResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetGeneralConfigurationResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) SetGeneralConfiguration(ctx context.Context, in *SetGeneralConfigurationRequest, opts ...dcerpc.CallOption) (*SetGeneralConfigurationResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetGeneralConfigurationResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) GetSecurityEx2(ctx context.Context, in *GetSecurityEx2Request, opts ...dcerpc.CallOption) (*GetSecurityEx2Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetSecurityEx2Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) SetSecurityEx2(ctx context.Context, in *SetSecurityEx2Request, opts ...dcerpc.CallOption) (*SetSecurityEx2Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetSecurityEx2Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) AccessCheckEx2(ctx context.Context, in *AccessCheckEx2Request, opts ...dcerpc.CallOption) (*AccessCheckEx2Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AccessCheckEx2Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) ReassignMessage(ctx context.Context, in *ReassignMessageRequest, opts ...dcerpc.CallOption) (*ReassignMessageResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ReassignMessageResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) SetMessage(ctx context.Context, in *SetMessageRequest, opts ...dcerpc.CallOption) (*SetMessageResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetMessageResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) GetConfigOption(ctx context.Context, in *GetConfigOptionRequest, opts ...dcerpc.CallOption) (*GetConfigOptionResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetConfigOptionResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFaxClient) AlterContext(ctx context.Context, opts ...dcerpc.Option) error {
	return o.cc.AlterContext(ctx, opts...)
}

func (o *xxx_DefaultFaxClient) Conn() dcerpc.Conn {
	return o.cc
}

func NewFaxClient(ctx context.Context, cc dcerpc.Conn, opts ...dcerpc.Option) (FaxClient, error) {
	cc, err := cc.Bind(ctx, append(opts, dcerpc.WithAbstractSyntax(FaxSyntaxV4_0))...)
	if err != nil {
		return nil, err
	}
	return &xxx_DefaultFaxClient{cc: cc}, nil
}

// xxx_GetServicePrintersOperation structure represents the FAX_GetServicePrinters operation
type xxx_GetServicePrintersOperation struct {
	Buffer           []byte `idl:"name:lpBuffer;size_is:(, lpdwBufferSize)" json:"buffer"`
	BufferSize       uint32 `idl:"name:lpdwBufferSize;pointer:ref" json:"buffer_size"`
	PrintersReturned uint32 `idl:"name:lpdwPrintersReturned;pointer:ref" json:"printers_returned"`
	Return           uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetServicePrintersOperation) OpNum() int { return 0 }

func (o *xxx_GetServicePrintersOperation) OpName() string { return "/fax/v4/FAX_GetServicePrinters" }

func (o *xxx_GetServicePrintersOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServicePrintersOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	return nil
}

func (o *xxx_GetServicePrintersOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	return nil
}

func (o *xxx_GetServicePrintersOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Buffer != nil && o.BufferSize == 0 {
		o.BufferSize = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServicePrintersOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpBuffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE}*(1))(3:{alias=BYTE}[dim:0,size_is=lpdwBufferSize](uchar))
	{
		if o.Buffer != nil || o.BufferSize > 0 {
			_ptr_lpBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.BufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Buffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Buffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Buffer, _ptr_lpBuffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpdwBufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	// lpdwPrintersReturned {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PrintersReturned); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServicePrintersOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpBuffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE,pointer=ref}*(1))(3:{alias=BYTE}[dim:0,size_is=lpdwBufferSize](uchar))
	{
		_ptr_lpBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
			}
			o.Buffer = make([]byte, sizeInfo[0])
			for i1 := range o.Buffer {
				i1 := i1
				if err := w.ReadData(&o.Buffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_lpBuffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Buffer, _s_lpBuffer, _ptr_lpBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpdwBufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	// lpdwPrintersReturned {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PrintersReturned); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetServicePrintersRequest structure represents the FAX_GetServicePrinters operation request
type GetServicePrintersRequest struct {
}

func (o *GetServicePrintersRequest) xxx_ToOp(ctx context.Context, op *xxx_GetServicePrintersOperation) *xxx_GetServicePrintersOperation {
	if op == nil {
		op = &xxx_GetServicePrintersOperation{}
	}
	if o == nil {
		return op
	}
	return op
}

func (o *GetServicePrintersRequest) xxx_FromOp(ctx context.Context, op *xxx_GetServicePrintersOperation) {
	if o == nil {
		return
	}
}
func (o *GetServicePrintersRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetServicePrintersRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetServicePrintersOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetServicePrintersResponse structure represents the FAX_GetServicePrinters operation response
type GetServicePrintersResponse struct {
	// lpBuffer: A pointer to a buffer containing an array of FAX_PRINTER_INFOW.
	Buffer []byte `idl:"name:lpBuffer;size_is:(, lpdwBufferSize)" json:"buffer"`
	// lpdwBufferSize: A pointer to a DWORD ([MS-DTYP] section 2.2.9) value containing the
	// size, in bytes, of the buffer.
	BufferSize uint32 `idl:"name:lpdwBufferSize;pointer:ref" json:"buffer_size"`
	// lpdwPrintersReturned: A pointer to a DWORD value indicating the number of the printers
	// in the buffer.
	PrintersReturned uint32 `idl:"name:lpdwPrintersReturned;pointer:ref" json:"printers_returned"`
	// Return: The FAX_GetServicePrinters return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetServicePrintersResponse) xxx_ToOp(ctx context.Context, op *xxx_GetServicePrintersOperation) *xxx_GetServicePrintersOperation {
	if op == nil {
		op = &xxx_GetServicePrintersOperation{}
	}
	if o == nil {
		return op
	}
	op.Buffer = o.Buffer
	op.BufferSize = o.BufferSize
	op.PrintersReturned = o.PrintersReturned
	op.Return = o.Return
	return op
}

func (o *GetServicePrintersResponse) xxx_FromOp(ctx context.Context, op *xxx_GetServicePrintersOperation) {
	if o == nil {
		return
	}
	o.Buffer = op.Buffer
	o.BufferSize = op.BufferSize
	o.PrintersReturned = op.PrintersReturned
	o.Return = op.Return
}
func (o *GetServicePrintersResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetServicePrintersResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetServicePrintersOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ConnectionReferenceCountOperation structure represents the FAX_ConnectionRefCount operation
type xxx_ConnectionReferenceCountOperation struct {
	Handle   *fax.Service `idl:"name:Handle" json:"handle"`
	Connect  uint32       `idl:"name:Connect" json:"connect"`
	CanShare uint32       `idl:"name:CanShare" json:"can_share"`
	Return   uint32       `idl:"name:Return" json:"return"`
}

func (o *xxx_ConnectionReferenceCountOperation) OpNum() int { return 1 }

func (o *xxx_ConnectionReferenceCountOperation) OpName() string {
	return "/fax/v4/FAX_ConnectionRefCount"
}

func (o *xxx_ConnectionReferenceCountOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ConnectionReferenceCountOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// Handle {in, out} (1:{alias=PRPC_FAX_SVC_HANDLE}*(1))(2:{context_handle, alias=RPC_FAX_SVC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.Service{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Connect {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Connect); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ConnectionReferenceCountOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// Handle {in, out} (1:{alias=PRPC_FAX_SVC_HANDLE,pointer=ref}*(1))(2:{context_handle, alias=RPC_FAX_SVC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &fax.Service{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Connect {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Connect); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ConnectionReferenceCountOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ConnectionReferenceCountOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Handle {in, out} (1:{alias=PRPC_FAX_SVC_HANDLE}*(1))(2:{context_handle, alias=RPC_FAX_SVC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.Service{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// CanShare {out} (1:{alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.CanShare); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ConnectionReferenceCountOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Handle {in, out} (1:{alias=PRPC_FAX_SVC_HANDLE,pointer=ref}*(1))(2:{context_handle, alias=RPC_FAX_SVC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &fax.Service{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// CanShare {out} (1:{alias=LPDWORD,pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.CanShare); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ConnectionReferenceCountRequest structure represents the FAX_ConnectionRefCount operation request
type ConnectionReferenceCountRequest struct {
	// Handle: The connection handle that references a connection to the fax server. If
	// Connect is set to 0x00000001 (Connect), a new handle is returned in this parameter.
	// Otherwise, this parameter MUST be set to a handle returned from a previous call to
	// this method, or to FAX_ConnectFaxServer.
	Handle *fax.Service `idl:"name:Handle" json:"handle"`
	// Connect: A DWORD ([MS-DTYP] section 2.2.9) value that specifies connection information.
	//
	//	+-----------------------+----------------------------------------------------------------------------------+
	//	|                       |                                                                                  |
	//	|         VALUE         |                                     MEANING                                      |
	//	|                       |                                                                                  |
	//	+-----------------------+----------------------------------------------------------------------------------+
	//	+-----------------------+----------------------------------------------------------------------------------+
	//	| Disconnect 0x00000000 | Close the fax server connection. The handle specified in Handle MUST have been   |
	//	|                       | returned by a previous call to FAX_ConnectFaxServer or FAX_ConnectionRefCount    |
	//	|                       | with a Connect value of 1 (Connect). After this call, the handle in Handle will  |
	//	|                       | be invalid and MUST NOT be used in any subsequent calls.                         |
	//	+-----------------------+----------------------------------------------------------------------------------+
	//	| Connect 0x00000001    | Connect to the fax server. Calling FAX_ConnectionRefCount with this value        |
	//	|                       | is equivalent to calling FAX_ConnectFaxServer with an API version of             |
	//	|                       | FAX_API_VERSION_0.                                                               |
	//	+-----------------------+----------------------------------------------------------------------------------+
	//	| Release 0x00000002    | Release a connection to the fax server. The handle specified in Handle           |
	//	|                       | MUST have been returned by a previous call to FAX_ConnectFaxServer or            |
	//	|                       | FAX_ConnectionRefCount with a Connect value of 1 (Connect). After this call,     |
	//	|                       | the handle in Handle MUST NOT be used in any subsequent calls except a call to   |
	//	|                       | FAX_ConnectionRefCount with a Connect value of 0 (Disconnect).                   |
	//	+-----------------------+----------------------------------------------------------------------------------+
	//
	// *
	//
	// The call sequence SHOULD have values for the Connect argument in the following order:
	//
	// *
	//
	// 1 (Connect): To obtain a valid Handle and connect to the fax server. (This call is
	// optional and can be replaced by a *FAX_ConnectFaxServer* call.
	//
	// *
	//
	// 2 (Release): Step "1 (Connect)" is mandatory for this call to succeed.
	//
	// *
	//
	// 0 (Disconnect): Step "1 (Connect)" is mandatory for this call to succeed.
	//
	// *
	//
	// The following sequence of calls on the same handle MUST result in an ERROR_INVALID_PARAMETER
	// error:
	//
	// *
	//
	// Consecutive calls with a Connect argument value of 2 (Release) or 0 (Disconnect)
	// without obtaining a valid Handle in between two calls (through step "1 (Connect)"
	// above).
	//
	// *
	//
	// A call with a Connect argument value of 0 (Disconnect) following a call with a Connect
	// argument value of 2 (Release).
	Connect uint32 `idl:"name:Connect" json:"connect"`
}

func (o *ConnectionReferenceCountRequest) xxx_ToOp(ctx context.Context, op *xxx_ConnectionReferenceCountOperation) *xxx_ConnectionReferenceCountOperation {
	if op == nil {
		op = &xxx_ConnectionReferenceCountOperation{}
	}
	if o == nil {
		return op
	}
	op.Handle = o.Handle
	op.Connect = o.Connect
	return op
}

func (o *ConnectionReferenceCountRequest) xxx_FromOp(ctx context.Context, op *xxx_ConnectionReferenceCountOperation) {
	if o == nil {
		return
	}
	o.Handle = op.Handle
	o.Connect = op.Connect
}
func (o *ConnectionReferenceCountRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *ConnectionReferenceCountRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ConnectionReferenceCountOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ConnectionReferenceCountResponse structure represents the FAX_ConnectionRefCount operation response
type ConnectionReferenceCountResponse struct {
	// Handle: The connection handle that references a connection to the fax server. If
	// Connect is set to 0x00000001 (Connect), a new handle is returned in this parameter.
	// Otherwise, this parameter MUST be set to a handle returned from a previous call to
	// this method, or to FAX_ConnectFaxServer.
	Handle *fax.Service `idl:"name:Handle" json:"handle"`
	// CanShare: The server MUST return a nonzero value in the DWORD referenced by this
	// parameter if the fax print queues can be shared as described in section 3.1.1, and
	// a zero value otherwise.<74>
	//
	//	+-------------------------+----------------------------------------+
	//	|        POSSIBLE         |                                        |
	//	|          VALUE          |              DESCRIPTION               |
	//	|                         |                                        |
	//	+-------------------------+----------------------------------------+
	//	+-------------------------+----------------------------------------+
	//	| 0x00000000              | The fax print queues can be shared.    |
	//	+-------------------------+----------------------------------------+
	//	| 0x00000001 — 0xFFFFFFFF | The fax print queues cannot be shared. |
	//	+-------------------------+----------------------------------------+
	CanShare uint32 `idl:"name:CanShare" json:"can_share"`
	// Return: The FAX_ConnectionRefCount return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ConnectionReferenceCountResponse) xxx_ToOp(ctx context.Context, op *xxx_ConnectionReferenceCountOperation) *xxx_ConnectionReferenceCountOperation {
	if op == nil {
		op = &xxx_ConnectionReferenceCountOperation{}
	}
	if o == nil {
		return op
	}
	op.Handle = o.Handle
	op.CanShare = o.CanShare
	op.Return = o.Return
	return op
}

func (o *ConnectionReferenceCountResponse) xxx_FromOp(ctx context.Context, op *xxx_ConnectionReferenceCountOperation) {
	if o == nil {
		return
	}
	o.Handle = op.Handle
	o.CanShare = op.CanShare
	o.Return = op.Return
}
func (o *ConnectionReferenceCountResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *ConnectionReferenceCountResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ConnectionReferenceCountOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_OpenPortOperation structure represents the FAX_OpenPort operation
type xxx_OpenPortOperation struct {
	DeviceID uint32    `idl:"name:DeviceId" json:"device_id"`
	Flags    uint32    `idl:"name:Flags" json:"flags"`
	FaxPort  *fax.Port `idl:"name:FaxPortHandle" json:"fax_port"`
	Return   uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_OpenPortOperation) OpNum() int { return 2 }

func (o *xxx_OpenPortOperation) OpName() string { return "/fax/v4/FAX_OpenPort" }

func (o *xxx_OpenPortOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenPortOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// DeviceId {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DeviceID); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenPortOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// DeviceId {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DeviceID); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenPortOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenPortOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// FaxPortHandle {out} (1:{alias=PRPC_FAX_PORT_HANDLE}*(1))(2:{context_handle, alias=RPC_FAX_PORT_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.FaxPort != nil {
			if err := o.FaxPort.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.Port{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenPortOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// FaxPortHandle {out} (1:{alias=PRPC_FAX_PORT_HANDLE,pointer=ref}*(1))(2:{context_handle, alias=RPC_FAX_PORT_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.FaxPort == nil {
			o.FaxPort = &fax.Port{}
		}
		if err := o.FaxPort.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// OpenPortRequest structure represents the FAX_OpenPort operation request
type OpenPortRequest struct {
	// DeviceId: A DWORD ([MS-DTYP] section 2.2.9) variable that is the line identifier
	// for the device (port). The client SHOULD call the FAX_EnumPorts (section 3.1.4.1.28)
	// method to retrieve a valid value for this parameter.
	DeviceID uint32 `idl:"name:DeviceId" json:"device_id"`
	// Flags: A DWORD variable that contains a set of bit flags defining the access mode
	// for the port.<137>
	//
	//	+-----------------------------+----------------------------------------------------------------------------------+
	//	|                             |                                                                                  |
	//	|         VALUE/CODE          |                                     MEANING                                      |
	//	|                             |                                                                                  |
	//	+-----------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000                  | No port access mode flags are specified.                                         |
	//	+-----------------------------+----------------------------------------------------------------------------------+
	//	| PORT_OPEN_QUERY 0x00000001  | The port access mode that is required to obtain a fax port handle. This access   |
	//	|                             | mode is also required to call the FAX_GetPort (section 3.1.4.1.51) method to     |
	//	|                             | query fax port information.<138>                                                 |
	//	+-----------------------------+----------------------------------------------------------------------------------+
	//	| PORT_OPEN_MODIFY 0x00000002 | The port access mode to change the configuration of a fax port. The fax server   |
	//	|                             | can use this port access mode to allow execution of the FAX_SetPort (section     |
	//	|                             | 3.1.4.1.88) method. This access mode also includes the allowance that is         |
	//	|                             | associated with the PORT_OPEN_QUERY access mode.<139>                            |
	//	+-----------------------------+----------------------------------------------------------------------------------+
	Flags uint32 `idl:"name:Flags" json:"flags"`
}

func (o *OpenPortRequest) xxx_ToOp(ctx context.Context, op *xxx_OpenPortOperation) *xxx_OpenPortOperation {
	if op == nil {
		op = &xxx_OpenPortOperation{}
	}
	if o == nil {
		return op
	}
	op.DeviceID = o.DeviceID
	op.Flags = o.Flags
	return op
}

func (o *OpenPortRequest) xxx_FromOp(ctx context.Context, op *xxx_OpenPortOperation) {
	if o == nil {
		return
	}
	o.DeviceID = op.DeviceID
	o.Flags = op.Flags
}
func (o *OpenPortRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *OpenPortRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenPortOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// OpenPortResponse structure represents the FAX_OpenPort operation response
type OpenPortResponse struct {
	// FaxPortHandle: A pointer to a variable that receives a fax port handle as described
	// in Fax Data Types (section 2.2.74) which is required on subsequent calls by other
	// fax client methods. This method SHOULD return a NULL handle to indicate an error.
	FaxPort *fax.Port `idl:"name:FaxPortHandle" json:"fax_port"`
	// Return: The FAX_OpenPort return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *OpenPortResponse) xxx_ToOp(ctx context.Context, op *xxx_OpenPortOperation) *xxx_OpenPortOperation {
	if op == nil {
		op = &xxx_OpenPortOperation{}
	}
	if o == nil {
		return op
	}
	op.FaxPort = o.FaxPort
	op.Return = o.Return
	return op
}

func (o *OpenPortResponse) xxx_FromOp(ctx context.Context, op *xxx_OpenPortOperation) {
	if o == nil {
		return
	}
	o.FaxPort = op.FaxPort
	o.Return = op.Return
}
func (o *OpenPortResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *OpenPortResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenPortOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ClosePortOperation structure represents the FAX_ClosePort operation
type xxx_ClosePortOperation struct {
	FaxPort *fax.Port `idl:"name:FaxPortHandle" json:"fax_port"`
	Return  uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_ClosePortOperation) OpNum() int { return 3 }

func (o *xxx_ClosePortOperation) OpName() string { return "/fax/v4/FAX_ClosePort" }

func (o *xxx_ClosePortOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ClosePortOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// FaxPortHandle {in, out} (1:{alias=PRPC_FAX_PORT_HANDLE}*(1))(2:{context_handle, alias=RPC_FAX_PORT_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.FaxPort != nil {
			if err := o.FaxPort.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.Port{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_ClosePortOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// FaxPortHandle {in, out} (1:{alias=PRPC_FAX_PORT_HANDLE,pointer=ref}*(1))(2:{context_handle, alias=RPC_FAX_PORT_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.FaxPort == nil {
			o.FaxPort = &fax.Port{}
		}
		if err := o.FaxPort.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ClosePortOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ClosePortOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// FaxPortHandle {in, out} (1:{alias=PRPC_FAX_PORT_HANDLE}*(1))(2:{context_handle, alias=RPC_FAX_PORT_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.FaxPort != nil {
			if err := o.FaxPort.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.Port{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ClosePortOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// FaxPortHandle {in, out} (1:{alias=PRPC_FAX_PORT_HANDLE,pointer=ref}*(1))(2:{context_handle, alias=RPC_FAX_PORT_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.FaxPort == nil {
			o.FaxPort = &fax.Port{}
		}
		if err := o.FaxPort.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ClosePortRequest structure represents the FAX_ClosePort operation request
type ClosePortRequest struct {
	// FaxPortHandle: A pointer to a fax port handle.
	FaxPort *fax.Port `idl:"name:FaxPortHandle" json:"fax_port"`
}

func (o *ClosePortRequest) xxx_ToOp(ctx context.Context, op *xxx_ClosePortOperation) *xxx_ClosePortOperation {
	if op == nil {
		op = &xxx_ClosePortOperation{}
	}
	if o == nil {
		return op
	}
	op.FaxPort = o.FaxPort
	return op
}

func (o *ClosePortRequest) xxx_FromOp(ctx context.Context, op *xxx_ClosePortOperation) {
	if o == nil {
		return
	}
	o.FaxPort = op.FaxPort
}
func (o *ClosePortRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *ClosePortRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ClosePortOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ClosePortResponse structure represents the FAX_ClosePort operation response
type ClosePortResponse struct {
	// FaxPortHandle: A pointer to a fax port handle.
	FaxPort *fax.Port `idl:"name:FaxPortHandle" json:"fax_port"`
	// Return: The FAX_ClosePort return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ClosePortResponse) xxx_ToOp(ctx context.Context, op *xxx_ClosePortOperation) *xxx_ClosePortOperation {
	if op == nil {
		op = &xxx_ClosePortOperation{}
	}
	if o == nil {
		return op
	}
	op.FaxPort = o.FaxPort
	op.Return = o.Return
	return op
}

func (o *ClosePortResponse) xxx_FromOp(ctx context.Context, op *xxx_ClosePortOperation) {
	if o == nil {
		return
	}
	o.FaxPort = op.FaxPort
	o.Return = op.Return
}
func (o *ClosePortResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *ClosePortResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ClosePortOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumJobsOperation structure represents the FAX_EnumJobs operation
type xxx_EnumJobsOperation struct {
	Buffer       []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	BufferSize   uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	JobsReturned uint32 `idl:"name:JobsReturned;pointer:ref" json:"jobs_returned"`
	Return       uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumJobsOperation) OpNum() int { return 4 }

func (o *xxx_EnumJobsOperation) OpName() string { return "/fax/v4/FAX_EnumJobs" }

func (o *xxx_EnumJobsOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumJobsOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	return nil
}

func (o *xxx_EnumJobsOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	return nil
}

func (o *xxx_EnumJobsOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Buffer != nil && o.BufferSize == 0 {
		o.BufferSize = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumJobsOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		if o.Buffer != nil || o.BufferSize > 0 {
			_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.BufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Buffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Buffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	// JobsReturned {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.JobsReturned); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumJobsOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE,pointer=ref}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
			}
			o.Buffer = make([]byte, sizeInfo[0])
			for i1 := range o.Buffer {
				i1 := i1
				if err := w.ReadData(&o.Buffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	// JobsReturned {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.JobsReturned); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumJobsRequest structure represents the FAX_EnumJobs operation request
type EnumJobsRequest struct {
}

func (o *EnumJobsRequest) xxx_ToOp(ctx context.Context, op *xxx_EnumJobsOperation) *xxx_EnumJobsOperation {
	if op == nil {
		op = &xxx_EnumJobsOperation{}
	}
	if o == nil {
		return op
	}
	return op
}

func (o *EnumJobsRequest) xxx_FromOp(ctx context.Context, op *xxx_EnumJobsOperation) {
	if o == nil {
		return
	}
}
func (o *EnumJobsRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumJobsRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumJobsOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumJobsResponse structure represents the FAX_EnumJobs operation response
type EnumJobsResponse struct {
	// Buffer: A pointer to the address of a buffer to receive an array of _FAX_JOB_ENTRY
	// (section 2.2.6) structures.
	Buffer []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	// BufferSize: A variable to return the size, in bytes, of the job information buffer.
	BufferSize uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	// JobsReturned: A pointer to a DWORD ([MS-DTYP] section 2.2.9) variable to receive
	// the number of _FAX_JOB_ENTRY that the method returns in the Buffer parameter.
	JobsReturned uint32 `idl:"name:JobsReturned;pointer:ref" json:"jobs_returned"`
	// Return: The FAX_EnumJobs return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumJobsResponse) xxx_ToOp(ctx context.Context, op *xxx_EnumJobsOperation) *xxx_EnumJobsOperation {
	if op == nil {
		op = &xxx_EnumJobsOperation{}
	}
	if o == nil {
		return op
	}
	op.Buffer = o.Buffer
	op.BufferSize = o.BufferSize
	op.JobsReturned = o.JobsReturned
	op.Return = o.Return
	return op
}

func (o *EnumJobsResponse) xxx_FromOp(ctx context.Context, op *xxx_EnumJobsOperation) {
	if o == nil {
		return
	}
	o.Buffer = op.Buffer
	o.BufferSize = op.BufferSize
	o.JobsReturned = op.JobsReturned
	o.Return = op.Return
}
func (o *EnumJobsResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumJobsResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumJobsOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetJobOperation structure represents the FAX_GetJob operation
type xxx_GetJobOperation struct {
	JobID      uint32 `idl:"name:JobId" json:"job_id"`
	Buffer     []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	BufferSize uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	Return     uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetJobOperation) OpNum() int { return 5 }

func (o *xxx_GetJobOperation) OpName() string { return "/fax/v4/FAX_GetJob" }

func (o *xxx_GetJobOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetJobOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// JobId {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.JobID); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetJobOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// JobId {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.JobID); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetJobOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Buffer != nil && o.BufferSize == 0 {
		o.BufferSize = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetJobOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		if o.Buffer != nil || o.BufferSize > 0 {
			_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.BufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Buffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Buffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetJobOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE,pointer=ref}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
			}
			o.Buffer = make([]byte, sizeInfo[0])
			for i1 := range o.Buffer {
				i1 := i1
				if err := w.ReadData(&o.Buffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetJobRequest structure represents the FAX_GetJob operation request
type GetJobRequest struct {
	// JobId: A unique number that identifies a queued or active fax job.
	JobID uint32 `idl:"name:JobId" json:"job_id"`
}

func (o *GetJobRequest) xxx_ToOp(ctx context.Context, op *xxx_GetJobOperation) *xxx_GetJobOperation {
	if op == nil {
		op = &xxx_GetJobOperation{}
	}
	if o == nil {
		return op
	}
	op.JobID = o.JobID
	return op
}

func (o *GetJobRequest) xxx_FromOp(ctx context.Context, op *xxx_GetJobOperation) {
	if o == nil {
		return
	}
	o.JobID = op.JobID
}
func (o *GetJobRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetJobRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetJobOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetJobResponse structure represents the FAX_GetJob operation response
type GetJobResponse struct {
	// Buffer: A pointer to the address of a buffer to receive a _FAX_JOB_ENTRY (section
	// 2.2.6) structure.
	Buffer []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	// BufferSize: A variable to return the size, in bytes, of the job information buffer.
	BufferSize uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	// Return: The FAX_GetJob return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetJobResponse) xxx_ToOp(ctx context.Context, op *xxx_GetJobOperation) *xxx_GetJobOperation {
	if op == nil {
		op = &xxx_GetJobOperation{}
	}
	if o == nil {
		return op
	}
	op.Buffer = o.Buffer
	op.BufferSize = o.BufferSize
	op.Return = o.Return
	return op
}

func (o *GetJobResponse) xxx_FromOp(ctx context.Context, op *xxx_GetJobOperation) {
	if o == nil {
		return
	}
	o.Buffer = op.Buffer
	o.BufferSize = op.BufferSize
	o.Return = op.Return
}
func (o *GetJobResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetJobResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetJobOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetJobOperation structure represents the FAX_SetJob operation
type xxx_SetJobOperation struct {
	JobID   uint32 `idl:"name:JobId" json:"job_id"`
	Command uint32 `idl:"name:Command" json:"command"`
	Return  uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_SetJobOperation) OpNum() int { return 6 }

func (o *xxx_SetJobOperation) OpName() string { return "/fax/v4/FAX_SetJob" }

func (o *xxx_SetJobOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetJobOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// JobId {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.JobID); err != nil {
			return err
		}
	}
	// Command {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Command); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetJobOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// JobId {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.JobID); err != nil {
			return err
		}
	}
	// Command {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Command); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetJobOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetJobOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetJobOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetJobRequest structure represents the FAX_SetJob operation request
type SetJobRequest struct {
	// JobId: A DWORD ([MS-DTYP] section 2.2.9) variable that uniquely identifies the fax
	// job to modify.
	JobID uint32 `idl:"name:JobId" json:"job_id"`
	// Command: A DWORD variable that indicates the job command that the fax server is requested
	// to perform.
	//
	//	+-----------------------+----------------------------------------------------------------------------------+
	//	|                       |                                                                                  |
	//	|      VALUE/CODE       |                                     MEANING                                      |
	//	|                       |                                                                                  |
	//	+-----------------------+----------------------------------------------------------------------------------+
	//	+-----------------------+----------------------------------------------------------------------------------+
	//	| JC_DELETE 0x00000001  | The fax server MUST cancel the specified fax job. This job can be in an active   |
	//	|                       | or queued state. This is equivalent with the FAX_Abort (section 3.1.4.1.2) call. |
	//	+-----------------------+----------------------------------------------------------------------------------+
	//	| JC_PAUSE 0x00000002   | The fax server MUST pause the specified fax job if the job status is JS_PENDING  |
	//	|                       | or JS_RETRYING.                                                                  |
	//	+-----------------------+----------------------------------------------------------------------------------+
	//	| JC_RESUME 0x00000003  | The fax server MUST resume the specified fax job if it is in a paused state and  |
	//	|                       | return the job status to the value it had when the job was paused: JS_PENDING or |
	//	|                       | JS_RETRYING.                                                                     |
	//	+-----------------------+----------------------------------------------------------------------------------+
	//	| JC_RESTART 0x00000003 | The fax server MUST restart the specified fax job.                               |
	//	+-----------------------+----------------------------------------------------------------------------------+
	Command uint32 `idl:"name:Command" json:"command"`
}

func (o *SetJobRequest) xxx_ToOp(ctx context.Context, op *xxx_SetJobOperation) *xxx_SetJobOperation {
	if op == nil {
		op = &xxx_SetJobOperation{}
	}
	if o == nil {
		return op
	}
	op.JobID = o.JobID
	op.Command = o.Command
	return op
}

func (o *SetJobRequest) xxx_FromOp(ctx context.Context, op *xxx_SetJobOperation) {
	if o == nil {
		return
	}
	o.JobID = op.JobID
	o.Command = op.Command
}
func (o *SetJobRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetJobRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetJobOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetJobResponse structure represents the FAX_SetJob operation response
type SetJobResponse struct {
	// Return: The FAX_SetJob return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetJobResponse) xxx_ToOp(ctx context.Context, op *xxx_SetJobOperation) *xxx_SetJobOperation {
	if op == nil {
		op = &xxx_SetJobOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetJobResponse) xxx_FromOp(ctx context.Context, op *xxx_SetJobOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetJobResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetJobResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetJobOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetPageDataOperation structure represents the FAX_GetPageData operation
type xxx_GetPageDataOperation struct {
	JobID       uint32 `idl:"name:JobId" json:"job_id"`
	Buffer      []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	BufferSize  uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	ImageWidth  uint32 `idl:"name:ImageWidth" json:"image_width"`
	ImageHeight uint32 `idl:"name:ImageHeight" json:"image_height"`
	Return      uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetPageDataOperation) OpNum() int { return 7 }

func (o *xxx_GetPageDataOperation) OpName() string { return "/fax/v4/FAX_GetPageData" }

func (o *xxx_GetPageDataOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetPageDataOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// JobId {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.JobID); err != nil {
			return err
		}
	}
	// ImageWidth {in, out} (1:{alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ImageWidth); err != nil {
			return err
		}
	}
	// ImageHeight {in, out} (1:{alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ImageHeight); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetPageDataOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// JobId {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.JobID); err != nil {
			return err
		}
	}
	// ImageWidth {in, out} (1:{alias=LPDWORD,pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ImageWidth); err != nil {
			return err
		}
	}
	// ImageHeight {in, out} (1:{alias=LPDWORD,pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ImageHeight); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetPageDataOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Buffer != nil && o.BufferSize == 0 {
		o.BufferSize = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetPageDataOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		if o.Buffer != nil || o.BufferSize > 0 {
			_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.BufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Buffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Buffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	// ImageWidth {in, out} (1:{alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ImageWidth); err != nil {
			return err
		}
	}
	// ImageHeight {in, out} (1:{alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ImageHeight); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetPageDataOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE,pointer=ref}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
			}
			o.Buffer = make([]byte, sizeInfo[0])
			for i1 := range o.Buffer {
				i1 := i1
				if err := w.ReadData(&o.Buffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	// ImageWidth {in, out} (1:{alias=LPDWORD,pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ImageWidth); err != nil {
			return err
		}
	}
	// ImageHeight {in, out} (1:{alias=LPDWORD,pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ImageHeight); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetPageDataRequest structure represents the FAX_GetPageData operation request
type GetPageDataRequest struct {
	// JobId: A unique number that identifies the fax job that is associated with the page
	// of data.
	JobID uint32 `idl:"name:JobId" json:"job_id"`
	// ImageWidth: A pointer to a DWORD variable to receive the width, in pixels, of the
	// fax image.
	ImageWidth uint32 `idl:"name:ImageWidth" json:"image_width"`
	// ImageHeight: A pointer to a DWORD variable to receive the height, in pixels, of the
	// fax image.
	ImageHeight uint32 `idl:"name:ImageHeight" json:"image_height"`
}

func (o *GetPageDataRequest) xxx_ToOp(ctx context.Context, op *xxx_GetPageDataOperation) *xxx_GetPageDataOperation {
	if op == nil {
		op = &xxx_GetPageDataOperation{}
	}
	if o == nil {
		return op
	}
	op.JobID = o.JobID
	op.ImageWidth = o.ImageWidth
	op.ImageHeight = o.ImageHeight
	return op
}

func (o *GetPageDataRequest) xxx_FromOp(ctx context.Context, op *xxx_GetPageDataOperation) {
	if o == nil {
		return
	}
	o.JobID = op.JobID
	o.ImageWidth = op.ImageWidth
	o.ImageHeight = op.ImageHeight
}
func (o *GetPageDataRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetPageDataRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetPageDataOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetPageDataResponse structure represents the FAX_GetPageData operation response
type GetPageDataResponse struct {
	// Buffer: A pointer to the address of a buffer to receive the first page of data in
	// the fax document.
	Buffer []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	// BufferSize: A pointer to a DWORD ([MS-DTYP] section 2.2.9) variable to receive the
	// size of the buffer, in bytes, pointed to by the Buffer parameter.
	BufferSize uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	// ImageWidth: A pointer to a DWORD variable to receive the width, in pixels, of the
	// fax image.
	ImageWidth uint32 `idl:"name:ImageWidth" json:"image_width"`
	// ImageHeight: A pointer to a DWORD variable to receive the height, in pixels, of the
	// fax image.
	ImageHeight uint32 `idl:"name:ImageHeight" json:"image_height"`
	// Return: The FAX_GetPageData return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetPageDataResponse) xxx_ToOp(ctx context.Context, op *xxx_GetPageDataOperation) *xxx_GetPageDataOperation {
	if op == nil {
		op = &xxx_GetPageDataOperation{}
	}
	if o == nil {
		return op
	}
	op.Buffer = o.Buffer
	op.BufferSize = o.BufferSize
	op.ImageWidth = o.ImageWidth
	op.ImageHeight = o.ImageHeight
	op.Return = o.Return
	return op
}

func (o *GetPageDataResponse) xxx_FromOp(ctx context.Context, op *xxx_GetPageDataOperation) {
	if o == nil {
		return
	}
	o.Buffer = op.Buffer
	o.BufferSize = op.BufferSize
	o.ImageWidth = op.ImageWidth
	o.ImageHeight = op.ImageHeight
	o.Return = op.Return
}
func (o *GetPageDataResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetPageDataResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetPageDataOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetDeviceStatusOperation structure represents the FAX_GetDeviceStatus operation
type xxx_GetDeviceStatusOperation struct {
	FaxPort      *fax.Port `idl:"name:FaxPortHandle" json:"fax_port"`
	StatusBuffer []byte    `idl:"name:StatusBuffer;size_is:(, BufferSize)" json:"status_buffer"`
	BufferSize   uint32    `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	Return       uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_GetDeviceStatusOperation) OpNum() int { return 8 }

func (o *xxx_GetDeviceStatusOperation) OpName() string { return "/fax/v4/FAX_GetDeviceStatus" }

func (o *xxx_GetDeviceStatusOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetDeviceStatusOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// FaxPortHandle {in} (1:{context_handle, alias=RPC_FAX_PORT_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.FaxPort != nil {
			if err := o.FaxPort.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.Port{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_GetDeviceStatusOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// FaxPortHandle {in} (1:{context_handle, alias=RPC_FAX_PORT_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.FaxPort == nil {
			o.FaxPort = &fax.Port{}
		}
		if err := o.FaxPort.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetDeviceStatusOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.StatusBuffer != nil && o.BufferSize == 0 {
		o.BufferSize = uint32(len(o.StatusBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetDeviceStatusOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// StatusBuffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		if o.StatusBuffer != nil || o.BufferSize > 0 {
			_ptr_StatusBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.BufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.StatusBuffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.StatusBuffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.StatusBuffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.StatusBuffer, _ptr_StatusBuffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetDeviceStatusOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// StatusBuffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE,pointer=ref}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		_ptr_StatusBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.StatusBuffer", sizeInfo[0])
			}
			o.StatusBuffer = make([]byte, sizeInfo[0])
			for i1 := range o.StatusBuffer {
				i1 := i1
				if err := w.ReadData(&o.StatusBuffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_StatusBuffer := func(ptr interface{}) { o.StatusBuffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.StatusBuffer, _s_StatusBuffer, _ptr_StatusBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetDeviceStatusRequest structure represents the FAX_GetDeviceStatus operation request
type GetDeviceStatusRequest struct {
	// FaxPortHandle: An RPC context handle that references a specified fax port. This context
	// handle MUST be obtained using the FAX_OpenPort (section 3.1.4.1.65) method.
	FaxPort *fax.Port `idl:"name:FaxPortHandle" json:"fax_port"`
}

func (o *GetDeviceStatusRequest) xxx_ToOp(ctx context.Context, op *xxx_GetDeviceStatusOperation) *xxx_GetDeviceStatusOperation {
	if op == nil {
		op = &xxx_GetDeviceStatusOperation{}
	}
	if o == nil {
		return op
	}
	op.FaxPort = o.FaxPort
	return op
}

func (o *GetDeviceStatusRequest) xxx_FromOp(ctx context.Context, op *xxx_GetDeviceStatusOperation) {
	if o == nil {
		return
	}
	o.FaxPort = op.FaxPort
}
func (o *GetDeviceStatusRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetDeviceStatusRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetDeviceStatusOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetDeviceStatusResponse structure represents the FAX_GetDeviceStatus operation response
type GetDeviceStatusResponse struct {
	// StatusBuffer: A pointer to the address of a buffer to receive a FAX_DEVICE_STATUS
	// structure. The structure describes the status of one fax device. The fax server MUST
	// set the SizeOfStruct member of this structure to the correct size for the Fixed_Portion
	// block of the FAX_DEVICE_STATUS, as described in section 2.2.10.
	StatusBuffer []byte `idl:"name:StatusBuffer;size_is:(, BufferSize)" json:"status_buffer"`
	// BufferSize: A variable to return the size, in bytes, of the data returned in the
	// buffer referenced by the StatusBuffer parameter.
	BufferSize uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	// Return: The FAX_GetDeviceStatus return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetDeviceStatusResponse) xxx_ToOp(ctx context.Context, op *xxx_GetDeviceStatusOperation) *xxx_GetDeviceStatusOperation {
	if op == nil {
		op = &xxx_GetDeviceStatusOperation{}
	}
	if o == nil {
		return op
	}
	op.StatusBuffer = o.StatusBuffer
	op.BufferSize = o.BufferSize
	op.Return = o.Return
	return op
}

func (o *GetDeviceStatusResponse) xxx_FromOp(ctx context.Context, op *xxx_GetDeviceStatusOperation) {
	if o == nil {
		return
	}
	o.StatusBuffer = op.StatusBuffer
	o.BufferSize = op.BufferSize
	o.Return = op.Return
}
func (o *GetDeviceStatusResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetDeviceStatusResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetDeviceStatusOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AbortOperation structure represents the FAX_Abort operation
type xxx_AbortOperation struct {
	JobID  uint32 `idl:"name:JobId" json:"job_id"`
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_AbortOperation) OpNum() int { return 9 }

func (o *xxx_AbortOperation) OpName() string { return "/fax/v4/FAX_Abort" }

func (o *xxx_AbortOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AbortOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// JobId {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.JobID); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AbortOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// JobId {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.JobID); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AbortOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AbortOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AbortOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AbortRequest structure represents the FAX_Abort operation request
type AbortRequest struct {
	// JobId: A unique number that identifies the fax job to terminate.
	JobID uint32 `idl:"name:JobId" json:"job_id"`
}

func (o *AbortRequest) xxx_ToOp(ctx context.Context, op *xxx_AbortOperation) *xxx_AbortOperation {
	if op == nil {
		op = &xxx_AbortOperation{}
	}
	if o == nil {
		return op
	}
	op.JobID = o.JobID
	return op
}

func (o *AbortRequest) xxx_FromOp(ctx context.Context, op *xxx_AbortOperation) {
	if o == nil {
		return
	}
	o.JobID = op.JobID
}
func (o *AbortRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *AbortRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AbortOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AbortResponse structure represents the FAX_Abort operation response
type AbortResponse struct {
	// Return: The FAX_Abort return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AbortResponse) xxx_ToOp(ctx context.Context, op *xxx_AbortOperation) *xxx_AbortOperation {
	if op == nil {
		op = &xxx_AbortOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *AbortResponse) xxx_FromOp(ctx context.Context, op *xxx_AbortOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *AbortResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *AbortResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AbortOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumPortsOperation structure represents the FAX_EnumPorts operation
type xxx_EnumPortsOperation struct {
	PortBuffer    []byte `idl:"name:PortBuffer;size_is:(, BufferSize)" json:"port_buffer"`
	BufferSize    uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	PortsReturned uint32 `idl:"name:PortsReturned;pointer:ref" json:"ports_returned"`
	Return        uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumPortsOperation) OpNum() int { return 10 }

func (o *xxx_EnumPortsOperation) OpName() string { return "/fax/v4/FAX_EnumPorts" }

func (o *xxx_EnumPortsOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumPortsOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	return nil
}

func (o *xxx_EnumPortsOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	return nil
}

func (o *xxx_EnumPortsOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.PortBuffer != nil && o.BufferSize == 0 {
		o.BufferSize = uint32(len(o.PortBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumPortsOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// PortBuffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		if o.PortBuffer != nil || o.BufferSize > 0 {
			_ptr_PortBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.BufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.PortBuffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.PortBuffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.PortBuffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.PortBuffer, _ptr_PortBuffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	// PortsReturned {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PortsReturned); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumPortsOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// PortBuffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE,pointer=ref}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		_ptr_PortBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.PortBuffer", sizeInfo[0])
			}
			o.PortBuffer = make([]byte, sizeInfo[0])
			for i1 := range o.PortBuffer {
				i1 := i1
				if err := w.ReadData(&o.PortBuffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_PortBuffer := func(ptr interface{}) { o.PortBuffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.PortBuffer, _s_PortBuffer, _ptr_PortBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	// PortsReturned {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PortsReturned); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumPortsRequest structure represents the FAX_EnumPorts operation request
type EnumPortsRequest struct {
}

func (o *EnumPortsRequest) xxx_ToOp(ctx context.Context, op *xxx_EnumPortsOperation) *xxx_EnumPortsOperation {
	if op == nil {
		op = &xxx_EnumPortsOperation{}
	}
	if o == nil {
		return op
	}
	return op
}

func (o *EnumPortsRequest) xxx_FromOp(ctx context.Context, op *xxx_EnumPortsOperation) {
	if o == nil {
		return
	}
}
func (o *EnumPortsRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumPortsRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumPortsOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumPortsResponse structure represents the FAX_EnumPorts operation response
type EnumPortsResponse struct {
	// PortBuffer: A pointer to the address of a buffer to receive an array of _FAX_PORT_INFO
	// (section 2.2.8) structures. Each structure describes one fax port.
	PortBuffer []byte `idl:"name:PortBuffer;size_is:(, BufferSize)" json:"port_buffer"`
	// BufferSize: A variable to return the size, in bytes, of the port buffer.
	BufferSize uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	// PortsReturned: A pointer to a DWORD ([MS-DTYP] section 2.2.9) variable to receive
	// the number of _FAX_PORT_INFO that the method returns in the PortBuffer parameter.
	PortsReturned uint32 `idl:"name:PortsReturned;pointer:ref" json:"ports_returned"`
	// Return: The FAX_EnumPorts return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumPortsResponse) xxx_ToOp(ctx context.Context, op *xxx_EnumPortsOperation) *xxx_EnumPortsOperation {
	if op == nil {
		op = &xxx_EnumPortsOperation{}
	}
	if o == nil {
		return op
	}
	op.PortBuffer = o.PortBuffer
	op.BufferSize = o.BufferSize
	op.PortsReturned = o.PortsReturned
	op.Return = o.Return
	return op
}

func (o *EnumPortsResponse) xxx_FromOp(ctx context.Context, op *xxx_EnumPortsOperation) {
	if o == nil {
		return
	}
	o.PortBuffer = op.PortBuffer
	o.BufferSize = op.BufferSize
	o.PortsReturned = op.PortsReturned
	o.Return = op.Return
}
func (o *EnumPortsResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumPortsResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumPortsOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetPortOperation structure represents the FAX_GetPort operation
type xxx_GetPortOperation struct {
	FaxPort    *fax.Port `idl:"name:FaxPortHandle" json:"fax_port"`
	PortBuffer []byte    `idl:"name:PortBuffer;size_is:(, BufferSize)" json:"port_buffer"`
	BufferSize uint32    `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	Return     uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_GetPortOperation) OpNum() int { return 11 }

func (o *xxx_GetPortOperation) OpName() string { return "/fax/v4/FAX_GetPort" }

func (o *xxx_GetPortOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetPortOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// FaxPortHandle {in} (1:{context_handle, alias=RPC_FAX_PORT_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.FaxPort != nil {
			if err := o.FaxPort.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.Port{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_GetPortOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// FaxPortHandle {in} (1:{context_handle, alias=RPC_FAX_PORT_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.FaxPort == nil {
			o.FaxPort = &fax.Port{}
		}
		if err := o.FaxPort.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetPortOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.PortBuffer != nil && o.BufferSize == 0 {
		o.BufferSize = uint32(len(o.PortBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetPortOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// PortBuffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		if o.PortBuffer != nil || o.BufferSize > 0 {
			_ptr_PortBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.BufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.PortBuffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.PortBuffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.PortBuffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.PortBuffer, _ptr_PortBuffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetPortOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// PortBuffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE,pointer=ref}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		_ptr_PortBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.PortBuffer", sizeInfo[0])
			}
			o.PortBuffer = make([]byte, sizeInfo[0])
			for i1 := range o.PortBuffer {
				i1 := i1
				if err := w.ReadData(&o.PortBuffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_PortBuffer := func(ptr interface{}) { o.PortBuffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.PortBuffer, _s_PortBuffer, _ptr_PortBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetPortRequest structure represents the FAX_GetPort operation request
type GetPortRequest struct {
	// FaxPortHandle: An RPC context handle that references a specified fax port.
	FaxPort *fax.Port `idl:"name:FaxPortHandle" json:"fax_port"`
}

func (o *GetPortRequest) xxx_ToOp(ctx context.Context, op *xxx_GetPortOperation) *xxx_GetPortOperation {
	if op == nil {
		op = &xxx_GetPortOperation{}
	}
	if o == nil {
		return op
	}
	op.FaxPort = o.FaxPort
	return op
}

func (o *GetPortRequest) xxx_FromOp(ctx context.Context, op *xxx_GetPortOperation) {
	if o == nil {
		return
	}
	o.FaxPort = op.FaxPort
}
func (o *GetPortRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetPortRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetPortOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetPortResponse structure represents the FAX_GetPort operation response
type GetPortResponse struct {
	// PortBuffer: A pointer to the address of a buffer to receive a _FAX_PORT_INFO (section
	// 2.2.8) structure. The structure describes one fax port.
	PortBuffer []byte `idl:"name:PortBuffer;size_is:(, BufferSize)" json:"port_buffer"`
	// BufferSize: A variable to return the size, in bytes, of the port buffer.
	BufferSize uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	// Return: The FAX_GetPort return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetPortResponse) xxx_ToOp(ctx context.Context, op *xxx_GetPortOperation) *xxx_GetPortOperation {
	if op == nil {
		op = &xxx_GetPortOperation{}
	}
	if o == nil {
		return op
	}
	op.PortBuffer = o.PortBuffer
	op.BufferSize = o.BufferSize
	op.Return = o.Return
	return op
}

func (o *GetPortResponse) xxx_FromOp(ctx context.Context, op *xxx_GetPortOperation) {
	if o == nil {
		return
	}
	o.PortBuffer = op.PortBuffer
	o.BufferSize = op.BufferSize
	o.Return = op.Return
}
func (o *GetPortResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetPortResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetPortOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetPortOperation structure represents the FAX_SetPort operation
type xxx_SetPortOperation struct {
	FaxPort  *fax.Port     `idl:"name:FaxPortHandle" json:"fax_port"`
	PortInfo *fax.PortInfo `idl:"name:PortInfo" json:"port_info"`
	Return   uint32        `idl:"name:Return" json:"return"`
}

func (o *xxx_SetPortOperation) OpNum() int { return 12 }

func (o *xxx_SetPortOperation) OpName() string { return "/fax/v4/FAX_SetPort" }

func (o *xxx_SetPortOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetPortOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// FaxPortHandle {in} (1:{context_handle, alias=RPC_FAX_PORT_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.FaxPort != nil {
			if err := o.FaxPort.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.Port{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// PortInfo {in} (1:{pointer=ref}*(1))(2:{alias=FAX_PORT_INFO}(struct))
	{
		if o.PortInfo != nil {
			if err := o.PortInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.PortInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetPortOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// FaxPortHandle {in} (1:{context_handle, alias=RPC_FAX_PORT_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.FaxPort == nil {
			o.FaxPort = &fax.Port{}
		}
		if err := o.FaxPort.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// PortInfo {in} (1:{pointer=ref}*(1))(2:{alias=FAX_PORT_INFO}(struct))
	{
		if o.PortInfo == nil {
			o.PortInfo = &fax.PortInfo{}
		}
		if err := o.PortInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetPortOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetPortOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetPortOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetPortRequest structure represents the FAX_SetPort operation request
type SetPortRequest struct {
	// FaxPortHandle: An RPC context handle that references a specified fax port.
	FaxPort *fax.Port `idl:"name:FaxPortHandle" json:"fax_port"`
	// PortInfo: A pointer to a FAX_PORT_INFO (section 2.2.7) structure. The structure (except
	// the State field, which has no purpose for this call and which the fax server SHOULD
	// ignore) contains data to modify the configuration of the specified fax port. The
	// client MUST set the SizeofStruct member of this structure to the correct size described
	// in section 2.2.7 before it calls the FAX_SetPort.
	PortInfo *fax.PortInfo `idl:"name:PortInfo" json:"port_info"`
}

func (o *SetPortRequest) xxx_ToOp(ctx context.Context, op *xxx_SetPortOperation) *xxx_SetPortOperation {
	if op == nil {
		op = &xxx_SetPortOperation{}
	}
	if o == nil {
		return op
	}
	op.FaxPort = o.FaxPort
	op.PortInfo = o.PortInfo
	return op
}

func (o *SetPortRequest) xxx_FromOp(ctx context.Context, op *xxx_SetPortOperation) {
	if o == nil {
		return
	}
	o.FaxPort = op.FaxPort
	o.PortInfo = op.PortInfo
}
func (o *SetPortRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetPortRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetPortOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetPortResponse structure represents the FAX_SetPort operation response
type SetPortResponse struct {
	// Return: The FAX_SetPort return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetPortResponse) xxx_ToOp(ctx context.Context, op *xxx_SetPortOperation) *xxx_SetPortOperation {
	if op == nil {
		op = &xxx_SetPortOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetPortResponse) xxx_FromOp(ctx context.Context, op *xxx_SetPortOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetPortResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetPortResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetPortOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumRoutingMethodsOperation structure represents the FAX_EnumRoutingMethods operation
type xxx_EnumRoutingMethodsOperation struct {
	FaxPort               *fax.Port `idl:"name:FaxPortHandle" json:"fax_port"`
	RoutingInfoBuffer     []byte    `idl:"name:RoutingInfoBuffer;size_is:(, RoutingInfoBufferSize)" json:"routing_info_buffer"`
	RoutingInfoBufferSize uint32    `idl:"name:RoutingInfoBufferSize;pointer:ref" json:"routing_info_buffer_size"`
	PortsReturned         uint32    `idl:"name:PortsReturned;pointer:ref" json:"ports_returned"`
	Return                uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumRoutingMethodsOperation) OpNum() int { return 13 }

func (o *xxx_EnumRoutingMethodsOperation) OpName() string { return "/fax/v4/FAX_EnumRoutingMethods" }

func (o *xxx_EnumRoutingMethodsOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumRoutingMethodsOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// FaxPortHandle {in} (1:{context_handle, alias=RPC_FAX_PORT_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.FaxPort != nil {
			if err := o.FaxPort.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.Port{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_EnumRoutingMethodsOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// FaxPortHandle {in} (1:{context_handle, alias=RPC_FAX_PORT_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.FaxPort == nil {
			o.FaxPort = &fax.Port{}
		}
		if err := o.FaxPort.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumRoutingMethodsOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.RoutingInfoBuffer != nil && o.RoutingInfoBufferSize == 0 {
		o.RoutingInfoBufferSize = uint32(len(o.RoutingInfoBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumRoutingMethodsOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// RoutingInfoBuffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE}*(1))(3:{alias=BYTE}[dim:0,size_is=RoutingInfoBufferSize](uchar))
	{
		if o.RoutingInfoBuffer != nil || o.RoutingInfoBufferSize > 0 {
			_ptr_RoutingInfoBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.RoutingInfoBufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.RoutingInfoBuffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.RoutingInfoBuffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.RoutingInfoBuffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.RoutingInfoBuffer, _ptr_RoutingInfoBuffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// RoutingInfoBufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RoutingInfoBufferSize); err != nil {
			return err
		}
	}
	// PortsReturned {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PortsReturned); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumRoutingMethodsOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// RoutingInfoBuffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE,pointer=ref}*(1))(3:{alias=BYTE}[dim:0,size_is=RoutingInfoBufferSize](uchar))
	{
		_ptr_RoutingInfoBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.RoutingInfoBuffer", sizeInfo[0])
			}
			o.RoutingInfoBuffer = make([]byte, sizeInfo[0])
			for i1 := range o.RoutingInfoBuffer {
				i1 := i1
				if err := w.ReadData(&o.RoutingInfoBuffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_RoutingInfoBuffer := func(ptr interface{}) { o.RoutingInfoBuffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.RoutingInfoBuffer, _s_RoutingInfoBuffer, _ptr_RoutingInfoBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// RoutingInfoBufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RoutingInfoBufferSize); err != nil {
			return err
		}
	}
	// PortsReturned {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PortsReturned); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumRoutingMethodsRequest structure represents the FAX_EnumRoutingMethods operation request
type EnumRoutingMethodsRequest struct {
	// FaxPortHandle: An RPC context handle that references a specified fax port.
	FaxPort *fax.Port `idl:"name:FaxPortHandle" json:"fax_port"`
}

func (o *EnumRoutingMethodsRequest) xxx_ToOp(ctx context.Context, op *xxx_EnumRoutingMethodsOperation) *xxx_EnumRoutingMethodsOperation {
	if op == nil {
		op = &xxx_EnumRoutingMethodsOperation{}
	}
	if o == nil {
		return op
	}
	op.FaxPort = o.FaxPort
	return op
}

func (o *EnumRoutingMethodsRequest) xxx_FromOp(ctx context.Context, op *xxx_EnumRoutingMethodsOperation) {
	if o == nil {
		return
	}
	o.FaxPort = op.FaxPort
}
func (o *EnumRoutingMethodsRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumRoutingMethodsRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumRoutingMethodsOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumRoutingMethodsResponse structure represents the FAX_EnumRoutingMethods operation response
type EnumRoutingMethodsResponse struct {
	// RoutingInfoBuffer: A pointer to the address of a buffer to receive an array of FAX_ROUTING_METHOD
	// (section 2.2.9) structures. Each structure contains information about one fax routing
	// method.
	RoutingInfoBuffer []byte `idl:"name:RoutingInfoBuffer;size_is:(, RoutingInfoBufferSize)" json:"routing_info_buffer"`
	// RoutingInfoBufferSize: A variable to return the size, in bytes, of the routing method
	// buffer.
	RoutingInfoBufferSize uint32 `idl:"name:RoutingInfoBufferSize;pointer:ref" json:"routing_info_buffer_size"`
	// PortsReturned: A pointer to a DWORD ([MS-DTYP] section 2.2.9) variable to receive
	// the number of FAX_ROUTING_METHOD  that are returned by the RoutingInfoBuffer parameter.
	PortsReturned uint32 `idl:"name:PortsReturned;pointer:ref" json:"ports_returned"`
	// Return: The FAX_EnumRoutingMethods return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumRoutingMethodsResponse) xxx_ToOp(ctx context.Context, op *xxx_EnumRoutingMethodsOperation) *xxx_EnumRoutingMethodsOperation {
	if op == nil {
		op = &xxx_EnumRoutingMethodsOperation{}
	}
	if o == nil {
		return op
	}
	op.RoutingInfoBuffer = o.RoutingInfoBuffer
	op.RoutingInfoBufferSize = o.RoutingInfoBufferSize
	op.PortsReturned = o.PortsReturned
	op.Return = o.Return
	return op
}

func (o *EnumRoutingMethodsResponse) xxx_FromOp(ctx context.Context, op *xxx_EnumRoutingMethodsOperation) {
	if o == nil {
		return
	}
	o.RoutingInfoBuffer = op.RoutingInfoBuffer
	o.RoutingInfoBufferSize = op.RoutingInfoBufferSize
	o.PortsReturned = op.PortsReturned
	o.Return = op.Return
}
func (o *EnumRoutingMethodsResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumRoutingMethodsResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumRoutingMethodsOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnableRoutingMethodOperation structure represents the FAX_EnableRoutingMethod operation
type xxx_EnableRoutingMethodOperation struct {
	FaxPort     *fax.Port `idl:"name:FaxPortHandle" json:"fax_port"`
	RoutingGUID string    `idl:"name:RoutingGuid;string;pointer:unique" json:"routing_guid"`
	Enabled     bool      `idl:"name:Enabled" json:"enabled"`
	Return      uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_EnableRoutingMethodOperation) OpNum() int { return 14 }

func (o *xxx_EnableRoutingMethodOperation) OpName() string { return "/fax/v4/FAX_EnableRoutingMethod" }

func (o *xxx_EnableRoutingMethodOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnableRoutingMethodOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// FaxPortHandle {in} (1:{context_handle, alias=RPC_FAX_PORT_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.FaxPort != nil {
			if err := o.FaxPort.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.Port{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// RoutingGuid {in} (1:{string, pointer=unique, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.RoutingGUID != "" {
			_ptr_RoutingGuid := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.RoutingGUID); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.RoutingGUID, _ptr_RoutingGuid); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Enabled {in} (1:{alias=BOOL}(int32))
	{
		if !o.Enabled {
			if err := w.WriteData(int32(0)); err != nil {
				return err
			}
		} else {
			if err := w.WriteData(int32(1)); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_EnableRoutingMethodOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// FaxPortHandle {in} (1:{context_handle, alias=RPC_FAX_PORT_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.FaxPort == nil {
			o.FaxPort = &fax.Port{}
		}
		if err := o.FaxPort.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// RoutingGuid {in} (1:{string, pointer=unique, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_RoutingGuid := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.RoutingGUID); err != nil {
				return err
			}
			return nil
		})
		_s_RoutingGuid := func(ptr interface{}) { o.RoutingGUID = *ptr.(*string) }
		if err := w.ReadPointer(&o.RoutingGUID, _s_RoutingGuid, _ptr_RoutingGuid); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Enabled {in} (1:{alias=BOOL}(int32))
	{
		var _bEnabled int32
		if err := w.ReadData(&_bEnabled); err != nil {
			return err
		}
		o.Enabled = _bEnabled != 0
	}
	return nil
}

func (o *xxx_EnableRoutingMethodOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnableRoutingMethodOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnableRoutingMethodOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnableRoutingMethodRequest structure represents the FAX_EnableRoutingMethod operation request
type EnableRoutingMethodRequest struct {
	// FaxPortHandle: An RPC context handle that references a specified fax port. This parameter
	// MUST NOT be NULL.
	FaxPort *fax.Port `idl:"name:FaxPortHandle" json:"fax_port"`
	// RoutingGuid: A curly-braced GUID string that MUST specify the GUID that uniquely
	// identifies the fax routing method upon which to act. For more information about routing
	// methods, see [MSDN-FRM]. The routing methods and the associated curly-braced GUID
	// string values that can be used for this parameter are discoverable by calling FAX_EnumRoutingMethods
	// (section 3.1.4.1.31). Included in this list are the default routing methods described
	// in section 2.2.87.
	RoutingGUID string `idl:"name:RoutingGuid;string;pointer:unique" json:"routing_guid"`
	// Enabled: A Boolean variable that indicates whether the application is enabling or
	// disabling the fax routing method that is specified by the RoutingGuid. If this parameter
	// is TRUE, the application is requesting that the server enable the routing method;
	// if this parameter is FALSE, the application is requesting that the server disable
	// the routing method.
	Enabled bool `idl:"name:Enabled" json:"enabled"`
}

func (o *EnableRoutingMethodRequest) xxx_ToOp(ctx context.Context, op *xxx_EnableRoutingMethodOperation) *xxx_EnableRoutingMethodOperation {
	if op == nil {
		op = &xxx_EnableRoutingMethodOperation{}
	}
	if o == nil {
		return op
	}
	op.FaxPort = o.FaxPort
	op.RoutingGUID = o.RoutingGUID
	op.Enabled = o.Enabled
	return op
}

func (o *EnableRoutingMethodRequest) xxx_FromOp(ctx context.Context, op *xxx_EnableRoutingMethodOperation) {
	if o == nil {
		return
	}
	o.FaxPort = op.FaxPort
	o.RoutingGUID = op.RoutingGUID
	o.Enabled = op.Enabled
}
func (o *EnableRoutingMethodRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnableRoutingMethodRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnableRoutingMethodOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnableRoutingMethodResponse structure represents the FAX_EnableRoutingMethod operation response
type EnableRoutingMethodResponse struct {
	// Return: The FAX_EnableRoutingMethod return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnableRoutingMethodResponse) xxx_ToOp(ctx context.Context, op *xxx_EnableRoutingMethodOperation) *xxx_EnableRoutingMethodOperation {
	if op == nil {
		op = &xxx_EnableRoutingMethodOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *EnableRoutingMethodResponse) xxx_FromOp(ctx context.Context, op *xxx_EnableRoutingMethodOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *EnableRoutingMethodResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnableRoutingMethodResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnableRoutingMethodOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetRoutingInfoOperation structure represents the FAX_GetRoutingInfo operation
type xxx_GetRoutingInfoOperation struct {
	FaxPort               *fax.Port `idl:"name:FaxPortHandle" json:"fax_port"`
	RoutingGUID           string    `idl:"name:RoutingGuid;string;pointer:unique" json:"routing_guid"`
	RoutingInfoBuffer     []byte    `idl:"name:RoutingInfoBuffer;size_is:(, RoutingInfoBufferSize)" json:"routing_info_buffer"`
	RoutingInfoBufferSize uint32    `idl:"name:RoutingInfoBufferSize;pointer:ref" json:"routing_info_buffer_size"`
	Return                uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_GetRoutingInfoOperation) OpNum() int { return 15 }

func (o *xxx_GetRoutingInfoOperation) OpName() string { return "/fax/v4/FAX_GetRoutingInfo" }

func (o *xxx_GetRoutingInfoOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetRoutingInfoOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// FaxPortHandle {in} (1:{context_handle, alias=RPC_FAX_PORT_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.FaxPort != nil {
			if err := o.FaxPort.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.Port{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// RoutingGuid {in} (1:{string, pointer=unique, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.RoutingGUID != "" {
			_ptr_RoutingGuid := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.RoutingGUID); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.RoutingGUID, _ptr_RoutingGuid); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetRoutingInfoOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// FaxPortHandle {in} (1:{context_handle, alias=RPC_FAX_PORT_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.FaxPort == nil {
			o.FaxPort = &fax.Port{}
		}
		if err := o.FaxPort.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// RoutingGuid {in} (1:{string, pointer=unique, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_RoutingGuid := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.RoutingGUID); err != nil {
				return err
			}
			return nil
		})
		_s_RoutingGuid := func(ptr interface{}) { o.RoutingGUID = *ptr.(*string) }
		if err := w.ReadPointer(&o.RoutingGUID, _s_RoutingGuid, _ptr_RoutingGuid); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetRoutingInfoOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.RoutingInfoBuffer != nil && o.RoutingInfoBufferSize == 0 {
		o.RoutingInfoBufferSize = uint32(len(o.RoutingInfoBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetRoutingInfoOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// RoutingInfoBuffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE}*(1))(3:{alias=BYTE}[dim:0,size_is=RoutingInfoBufferSize](uchar))
	{
		if o.RoutingInfoBuffer != nil || o.RoutingInfoBufferSize > 0 {
			_ptr_RoutingInfoBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.RoutingInfoBufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.RoutingInfoBuffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.RoutingInfoBuffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.RoutingInfoBuffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.RoutingInfoBuffer, _ptr_RoutingInfoBuffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// RoutingInfoBufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RoutingInfoBufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetRoutingInfoOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// RoutingInfoBuffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE,pointer=ref}*(1))(3:{alias=BYTE}[dim:0,size_is=RoutingInfoBufferSize](uchar))
	{
		_ptr_RoutingInfoBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.RoutingInfoBuffer", sizeInfo[0])
			}
			o.RoutingInfoBuffer = make([]byte, sizeInfo[0])
			for i1 := range o.RoutingInfoBuffer {
				i1 := i1
				if err := w.ReadData(&o.RoutingInfoBuffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_RoutingInfoBuffer := func(ptr interface{}) { o.RoutingInfoBuffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.RoutingInfoBuffer, _s_RoutingInfoBuffer, _ptr_RoutingInfoBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// RoutingInfoBufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RoutingInfoBufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetRoutingInfoRequest structure represents the FAX_GetRoutingInfo operation request
type GetRoutingInfoRequest struct {
	// FaxPortHandle: An RPC context handle that references a specified fax port.
	FaxPort *fax.Port `idl:"name:FaxPortHandle" json:"fax_port"`
	// RoutingGuid: A curly braced GUID string that specifies the GUID that uniquely identifies
	// the fax routing method for which to obtain the routing information. Fax routing methods
	// are defined by a fax routing extension and the method is identified by a GUID. For
	// more information about routing methods, see [MSDN-FRM]. The routing methods and the
	// associated curly-braced GUID string values that can be used for this parameter are
	// discoverable by calling FAX_EnumRoutingMethods (section 3.1.4.1.31). Included in
	// this list are the default routing methods described in Default Routing Methods (section
	// 2.2.87).
	RoutingGUID string `idl:"name:RoutingGuid;string;pointer:unique" json:"routing_guid"`
}

func (o *GetRoutingInfoRequest) xxx_ToOp(ctx context.Context, op *xxx_GetRoutingInfoOperation) *xxx_GetRoutingInfoOperation {
	if op == nil {
		op = &xxx_GetRoutingInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.FaxPort = o.FaxPort
	op.RoutingGUID = o.RoutingGUID
	return op
}

func (o *GetRoutingInfoRequest) xxx_FromOp(ctx context.Context, op *xxx_GetRoutingInfoOperation) {
	if o == nil {
		return
	}
	o.FaxPort = op.FaxPort
	o.RoutingGUID = op.RoutingGUID
}
func (o *GetRoutingInfoRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetRoutingInfoRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetRoutingInfoOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetRoutingInfoResponse structure represents the FAX_GetRoutingInfo operation response
type GetRoutingInfoResponse struct {
	// RoutingInfoBuffer: A pointer to the address of a buffer that receives the fax routing
	// information. The buffer format and contents depend on the routing method that is
	// identified by the RoutingGuid.
	RoutingInfoBuffer []byte `idl:"name:RoutingInfoBuffer;size_is:(, RoutingInfoBufferSize)" json:"routing_info_buffer"`
	// RoutingInfoBufferSize: A pointer to a DWORD ([MS-DTYP] section 2.2.9) variable that
	// receives the size, in bytes, of the RoutingInfoBuffer buffer.
	RoutingInfoBufferSize uint32 `idl:"name:RoutingInfoBufferSize;pointer:ref" json:"routing_info_buffer_size"`
	// Return: The FAX_GetRoutingInfo return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetRoutingInfoResponse) xxx_ToOp(ctx context.Context, op *xxx_GetRoutingInfoOperation) *xxx_GetRoutingInfoOperation {
	if op == nil {
		op = &xxx_GetRoutingInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.RoutingInfoBuffer = o.RoutingInfoBuffer
	op.RoutingInfoBufferSize = o.RoutingInfoBufferSize
	op.Return = o.Return
	return op
}

func (o *GetRoutingInfoResponse) xxx_FromOp(ctx context.Context, op *xxx_GetRoutingInfoOperation) {
	if o == nil {
		return
	}
	o.RoutingInfoBuffer = op.RoutingInfoBuffer
	o.RoutingInfoBufferSize = op.RoutingInfoBufferSize
	o.Return = op.Return
}
func (o *GetRoutingInfoResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetRoutingInfoResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetRoutingInfoOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetRoutingInfoOperation structure represents the FAX_SetRoutingInfo operation
type xxx_SetRoutingInfoOperation struct {
	FaxPort               *fax.Port `idl:"name:FaxPortHandle" json:"fax_port"`
	RoutingGUID           string    `idl:"name:RoutingGuid;string;pointer:unique" json:"routing_guid"`
	RoutingInfoBuffer     []byte    `idl:"name:RoutingInfoBuffer;size_is:(RoutingInfoBufferSize);pointer:unique" json:"routing_info_buffer"`
	RoutingInfoBufferSize uint32    `idl:"name:RoutingInfoBufferSize" json:"routing_info_buffer_size"`
	Return                uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_SetRoutingInfoOperation) OpNum() int { return 16 }

func (o *xxx_SetRoutingInfoOperation) OpName() string { return "/fax/v4/FAX_SetRoutingInfo" }

func (o *xxx_SetRoutingInfoOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.RoutingInfoBuffer != nil && o.RoutingInfoBufferSize == 0 {
		o.RoutingInfoBufferSize = uint32(len(o.RoutingInfoBuffer))
	}
	if o.RoutingInfoBufferSize > uint32(1048576) {
		return fmt.Errorf("RoutingInfoBufferSize is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetRoutingInfoOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// FaxPortHandle {in} (1:{context_handle, alias=RPC_FAX_PORT_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.FaxPort != nil {
			if err := o.FaxPort.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.Port{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// RoutingGuid {in} (1:{string, pointer=unique, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.RoutingGUID != "" {
			_ptr_RoutingGuid := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.RoutingGUID); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.RoutingGUID, _ptr_RoutingGuid); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// RoutingInfoBuffer {in} (1:{pointer=unique}*(1))(2:{alias=BYTE}[dim:0,size_is=RoutingInfoBufferSize](uchar))
	{
		if o.RoutingInfoBuffer != nil || o.RoutingInfoBufferSize > 0 {
			_ptr_RoutingInfoBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.RoutingInfoBufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.RoutingInfoBuffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.RoutingInfoBuffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.RoutingInfoBuffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.RoutingInfoBuffer, _ptr_RoutingInfoBuffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// RoutingInfoBufferSize {in} (1:{range=(0,1048576), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RoutingInfoBufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetRoutingInfoOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// FaxPortHandle {in} (1:{context_handle, alias=RPC_FAX_PORT_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.FaxPort == nil {
			o.FaxPort = &fax.Port{}
		}
		if err := o.FaxPort.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// RoutingGuid {in} (1:{string, pointer=unique, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_RoutingGuid := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.RoutingGUID); err != nil {
				return err
			}
			return nil
		})
		_s_RoutingGuid := func(ptr interface{}) { o.RoutingGUID = *ptr.(*string) }
		if err := w.ReadPointer(&o.RoutingGUID, _s_RoutingGuid, _ptr_RoutingGuid); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// RoutingInfoBuffer {in} (1:{pointer=unique}*(1))(2:{alias=BYTE}[dim:0,size_is=RoutingInfoBufferSize](uchar))
	{
		_ptr_RoutingInfoBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.RoutingInfoBuffer", sizeInfo[0])
			}
			o.RoutingInfoBuffer = make([]byte, sizeInfo[0])
			for i1 := range o.RoutingInfoBuffer {
				i1 := i1
				if err := w.ReadData(&o.RoutingInfoBuffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_RoutingInfoBuffer := func(ptr interface{}) { o.RoutingInfoBuffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.RoutingInfoBuffer, _s_RoutingInfoBuffer, _ptr_RoutingInfoBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// RoutingInfoBufferSize {in} (1:{range=(0,1048576), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RoutingInfoBufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetRoutingInfoOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetRoutingInfoOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetRoutingInfoOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetRoutingInfoRequest structure represents the FAX_SetRoutingInfo operation request
type SetRoutingInfoRequest struct {
	// FaxPortHandle: An RPC context handle that references a specified fax port. This context
	// handle MUST be obtained using the FAX_OpenPort (section 3.1.4.1.65) method.
	FaxPort *fax.Port `idl:"name:FaxPortHandle" json:"fax_port"`
	// RoutingGuid: A curly-braced GUID string that uniquely identifies the fax routing
	// method to set the routing information for. Fax routing methods are defined by a fax
	// routing extension, and the method is identified by a GUID. For more information about
	// routing methods, see [MSDN-FRM].For more information about routing methods, see [MSDN-FRM].
	// The routing methods and the associated curly-braced GUID string values that can be
	// used for this parameter are discoverable by calling FAX_EnumRoutingMethods (section
	// 3.1.4.1.31). Included in this list are the Default Routing Methods described in section
	// 2.2.87.
	RoutingGUID string `idl:"name:RoutingGuid;string;pointer:unique" json:"routing_guid"`
	// RoutingInfoBuffer: A pointer to a buffer that contains the new fax routing information.
	// The format and contents of this buffer depend on the routing method identified by
	// the RoutingGuid.
	RoutingInfoBuffer []byte `idl:"name:RoutingInfoBuffer;size_is:(RoutingInfoBufferSize);pointer:unique" json:"routing_info_buffer"`
	// RoutingInfoBufferSize: The size, in bytes, of the RoutingInfoBuffer buffer. The maximum
	// size is the value FAX_MAX_RPC_BUFFER(section 2.2.82).
	RoutingInfoBufferSize uint32 `idl:"name:RoutingInfoBufferSize" json:"routing_info_buffer_size"`
}

func (o *SetRoutingInfoRequest) xxx_ToOp(ctx context.Context, op *xxx_SetRoutingInfoOperation) *xxx_SetRoutingInfoOperation {
	if op == nil {
		op = &xxx_SetRoutingInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.FaxPort = o.FaxPort
	op.RoutingGUID = o.RoutingGUID
	op.RoutingInfoBuffer = o.RoutingInfoBuffer
	op.RoutingInfoBufferSize = o.RoutingInfoBufferSize
	return op
}

func (o *SetRoutingInfoRequest) xxx_FromOp(ctx context.Context, op *xxx_SetRoutingInfoOperation) {
	if o == nil {
		return
	}
	o.FaxPort = op.FaxPort
	o.RoutingGUID = op.RoutingGUID
	o.RoutingInfoBuffer = op.RoutingInfoBuffer
	o.RoutingInfoBufferSize = op.RoutingInfoBufferSize
}
func (o *SetRoutingInfoRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetRoutingInfoRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetRoutingInfoOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetRoutingInfoResponse structure represents the FAX_SetRoutingInfo operation response
type SetRoutingInfoResponse struct {
	// Return: The FAX_SetRoutingInfo return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetRoutingInfoResponse) xxx_ToOp(ctx context.Context, op *xxx_SetRoutingInfoOperation) *xxx_SetRoutingInfoOperation {
	if op == nil {
		op = &xxx_SetRoutingInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetRoutingInfoResponse) xxx_FromOp(ctx context.Context, op *xxx_SetRoutingInfoOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetRoutingInfoResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetRoutingInfoResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetRoutingInfoOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumGlobalRoutingInfoOperation structure represents the FAX_EnumGlobalRoutingInfo operation
type xxx_EnumGlobalRoutingInfoOperation struct {
	RoutingInfoBuffer     []byte `idl:"name:RoutingInfoBuffer;size_is:(, RoutingInfoBufferSize)" json:"routing_info_buffer"`
	RoutingInfoBufferSize uint32 `idl:"name:RoutingInfoBufferSize;pointer:ref" json:"routing_info_buffer_size"`
	MethodsReturned       uint32 `idl:"name:MethodsReturned;pointer:ref" json:"methods_returned"`
	Return                uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumGlobalRoutingInfoOperation) OpNum() int { return 17 }

func (o *xxx_EnumGlobalRoutingInfoOperation) OpName() string {
	return "/fax/v4/FAX_EnumGlobalRoutingInfo"
}

func (o *xxx_EnumGlobalRoutingInfoOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumGlobalRoutingInfoOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	return nil
}

func (o *xxx_EnumGlobalRoutingInfoOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	return nil
}

func (o *xxx_EnumGlobalRoutingInfoOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.RoutingInfoBuffer != nil && o.RoutingInfoBufferSize == 0 {
		o.RoutingInfoBufferSize = uint32(len(o.RoutingInfoBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumGlobalRoutingInfoOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// RoutingInfoBuffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE}*(1))(3:{alias=BYTE}[dim:0,size_is=RoutingInfoBufferSize](uchar))
	{
		if o.RoutingInfoBuffer != nil || o.RoutingInfoBufferSize > 0 {
			_ptr_RoutingInfoBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.RoutingInfoBufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.RoutingInfoBuffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.RoutingInfoBuffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.RoutingInfoBuffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.RoutingInfoBuffer, _ptr_RoutingInfoBuffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// RoutingInfoBufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RoutingInfoBufferSize); err != nil {
			return err
		}
	}
	// MethodsReturned {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.MethodsReturned); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumGlobalRoutingInfoOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// RoutingInfoBuffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE,pointer=ref}*(1))(3:{alias=BYTE}[dim:0,size_is=RoutingInfoBufferSize](uchar))
	{
		_ptr_RoutingInfoBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.RoutingInfoBuffer", sizeInfo[0])
			}
			o.RoutingInfoBuffer = make([]byte, sizeInfo[0])
			for i1 := range o.RoutingInfoBuffer {
				i1 := i1
				if err := w.ReadData(&o.RoutingInfoBuffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_RoutingInfoBuffer := func(ptr interface{}) { o.RoutingInfoBuffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.RoutingInfoBuffer, _s_RoutingInfoBuffer, _ptr_RoutingInfoBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// RoutingInfoBufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RoutingInfoBufferSize); err != nil {
			return err
		}
	}
	// MethodsReturned {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.MethodsReturned); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumGlobalRoutingInfoRequest structure represents the FAX_EnumGlobalRoutingInfo operation request
type EnumGlobalRoutingInfoRequest struct {
}

func (o *EnumGlobalRoutingInfoRequest) xxx_ToOp(ctx context.Context, op *xxx_EnumGlobalRoutingInfoOperation) *xxx_EnumGlobalRoutingInfoOperation {
	if op == nil {
		op = &xxx_EnumGlobalRoutingInfoOperation{}
	}
	if o == nil {
		return op
	}
	return op
}

func (o *EnumGlobalRoutingInfoRequest) xxx_FromOp(ctx context.Context, op *xxx_EnumGlobalRoutingInfoOperation) {
	if o == nil {
		return
	}
}
func (o *EnumGlobalRoutingInfoRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumGlobalRoutingInfoRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumGlobalRoutingInfoOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumGlobalRoutingInfoResponse structure represents the FAX_EnumGlobalRoutingInfo operation response
type EnumGlobalRoutingInfoResponse struct {
	// RoutingInfoBuffer:  A pointer to the address of a buffer to receive an array of
	// _FAX_GLOBAL_ROUTING_INFOW (section 2.2.33) structures. Each structure contains information
	// about one fax routing method, as it pertains to the entire Fax Service.
	RoutingInfoBuffer []byte `idl:"name:RoutingInfoBuffer;size_is:(, RoutingInfoBufferSize)" json:"routing_info_buffer"`
	// RoutingInfoBufferSize: A variable to return the size, in bytes, of the routing information
	// buffer.
	RoutingInfoBufferSize uint32 `idl:"name:RoutingInfoBufferSize;pointer:ref" json:"routing_info_buffer_size"`
	// MethodsReturned: A pointer to a DWORD ([MS-DTYP] section 2.2.9) variable to receive
	// the number of _FAX_GLOBAL_ROUTING_INFOW  that the method returns in the RoutingInfoBuffer
	// parameter. This number SHOULD equal the total number of fax routing methods installed
	// on the target server.
	MethodsReturned uint32 `idl:"name:MethodsReturned;pointer:ref" json:"methods_returned"`
	// Return: The FAX_EnumGlobalRoutingInfo return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumGlobalRoutingInfoResponse) xxx_ToOp(ctx context.Context, op *xxx_EnumGlobalRoutingInfoOperation) *xxx_EnumGlobalRoutingInfoOperation {
	if op == nil {
		op = &xxx_EnumGlobalRoutingInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.RoutingInfoBuffer = o.RoutingInfoBuffer
	op.RoutingInfoBufferSize = o.RoutingInfoBufferSize
	op.MethodsReturned = o.MethodsReturned
	op.Return = o.Return
	return op
}

func (o *EnumGlobalRoutingInfoResponse) xxx_FromOp(ctx context.Context, op *xxx_EnumGlobalRoutingInfoOperation) {
	if o == nil {
		return
	}
	o.RoutingInfoBuffer = op.RoutingInfoBuffer
	o.RoutingInfoBufferSize = op.RoutingInfoBufferSize
	o.MethodsReturned = op.MethodsReturned
	o.Return = op.Return
}
func (o *EnumGlobalRoutingInfoResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumGlobalRoutingInfoResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumGlobalRoutingInfoOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetGlobalRoutingInfoOperation structure represents the FAX_SetGlobalRoutingInfo operation
type xxx_SetGlobalRoutingInfoOperation struct {
	RoutingInfo *fax.GlobalRoutingInfoW `idl:"name:RoutingInfo" json:"routing_info"`
	Return      uint32                  `idl:"name:Return" json:"return"`
}

func (o *xxx_SetGlobalRoutingInfoOperation) OpNum() int { return 18 }

func (o *xxx_SetGlobalRoutingInfoOperation) OpName() string {
	return "/fax/v4/FAX_SetGlobalRoutingInfo"
}

func (o *xxx_SetGlobalRoutingInfoOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetGlobalRoutingInfoOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// RoutingInfo {in} (1:{pointer=ref}*(1))(2:{alias=FAX_GLOBAL_ROUTING_INFOW}(struct))
	{
		if o.RoutingInfo != nil {
			if err := o.RoutingInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.GlobalRoutingInfoW{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetGlobalRoutingInfoOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// RoutingInfo {in} (1:{pointer=ref}*(1))(2:{alias=FAX_GLOBAL_ROUTING_INFOW}(struct))
	{
		if o.RoutingInfo == nil {
			o.RoutingInfo = &fax.GlobalRoutingInfoW{}
		}
		if err := o.RoutingInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetGlobalRoutingInfoOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetGlobalRoutingInfoOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetGlobalRoutingInfoOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetGlobalRoutingInfoRequest structure represents the FAX_SetGlobalRoutingInfo operation request
type SetGlobalRoutingInfoRequest struct {
	// RoutingInfo: A pointer to a buffer that contains a FAX_GLOBAL_ROUTING_INFOW (section
	// 2.2.32) structure.
	RoutingInfo *fax.GlobalRoutingInfoW `idl:"name:RoutingInfo" json:"routing_info"`
}

func (o *SetGlobalRoutingInfoRequest) xxx_ToOp(ctx context.Context, op *xxx_SetGlobalRoutingInfoOperation) *xxx_SetGlobalRoutingInfoOperation {
	if op == nil {
		op = &xxx_SetGlobalRoutingInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.RoutingInfo = o.RoutingInfo
	return op
}

func (o *SetGlobalRoutingInfoRequest) xxx_FromOp(ctx context.Context, op *xxx_SetGlobalRoutingInfoOperation) {
	if o == nil {
		return
	}
	o.RoutingInfo = op.RoutingInfo
}
func (o *SetGlobalRoutingInfoRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetGlobalRoutingInfoRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetGlobalRoutingInfoOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetGlobalRoutingInfoResponse structure represents the FAX_SetGlobalRoutingInfo operation response
type SetGlobalRoutingInfoResponse struct {
	// Return: The FAX_SetGlobalRoutingInfo return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetGlobalRoutingInfoResponse) xxx_ToOp(ctx context.Context, op *xxx_SetGlobalRoutingInfoOperation) *xxx_SetGlobalRoutingInfoOperation {
	if op == nil {
		op = &xxx_SetGlobalRoutingInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetGlobalRoutingInfoResponse) xxx_FromOp(ctx context.Context, op *xxx_SetGlobalRoutingInfoOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetGlobalRoutingInfoResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetGlobalRoutingInfoResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetGlobalRoutingInfoOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetConfigurationOperation structure represents the FAX_GetConfiguration operation
type xxx_GetConfigurationOperation struct {
	Buffer     []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	BufferSize uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	Return     uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetConfigurationOperation) OpNum() int { return 19 }

func (o *xxx_GetConfigurationOperation) OpName() string { return "/fax/v4/FAX_GetConfiguration" }

func (o *xxx_GetConfigurationOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetConfigurationOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	return nil
}

func (o *xxx_GetConfigurationOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	return nil
}

func (o *xxx_GetConfigurationOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Buffer != nil && o.BufferSize == 0 {
		o.BufferSize = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetConfigurationOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		if o.Buffer != nil || o.BufferSize > 0 {
			_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.BufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Buffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Buffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetConfigurationOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE,pointer=ref}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
			}
			o.Buffer = make([]byte, sizeInfo[0])
			for i1 := range o.Buffer {
				i1 := i1
				if err := w.ReadData(&o.Buffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetConfigurationRequest structure represents the FAX_GetConfiguration operation request
type GetConfigurationRequest struct {
}

func (o *GetConfigurationRequest) xxx_ToOp(ctx context.Context, op *xxx_GetConfigurationOperation) *xxx_GetConfigurationOperation {
	if op == nil {
		op = &xxx_GetConfigurationOperation{}
	}
	if o == nil {
		return op
	}
	return op
}

func (o *GetConfigurationRequest) xxx_FromOp(ctx context.Context, op *xxx_GetConfigurationOperation) {
	if o == nil {
		return
	}
}
func (o *GetConfigurationRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetConfigurationRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetConfigurationOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetConfigurationResponse structure represents the FAX_GetConfiguration operation response
type GetConfigurationResponse struct {
	// Buffer: A pointer to the address of a buffer to receive a _FAX_CONFIGURATIONW (section
	// 2.2.29) structure. The structure contains the current configuration settings for
	// the fax server.
	Buffer []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	// BufferSize: A variable to return the size, in bytes, of the buffer.
	BufferSize uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	// Return: The FAX_GetConfiguration return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetConfigurationResponse) xxx_ToOp(ctx context.Context, op *xxx_GetConfigurationOperation) *xxx_GetConfigurationOperation {
	if op == nil {
		op = &xxx_GetConfigurationOperation{}
	}
	if o == nil {
		return op
	}
	op.Buffer = o.Buffer
	op.BufferSize = o.BufferSize
	op.Return = o.Return
	return op
}

func (o *GetConfigurationResponse) xxx_FromOp(ctx context.Context, op *xxx_GetConfigurationOperation) {
	if o == nil {
		return
	}
	o.Buffer = op.Buffer
	o.BufferSize = op.BufferSize
	o.Return = op.Return
}
func (o *GetConfigurationResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetConfigurationResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetConfigurationOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetConfigurationOperation structure represents the FAX_SetConfiguration operation
type xxx_SetConfigurationOperation struct {
	FaxConfig *fax.ConfigW `idl:"name:FaxConfig" json:"fax_config"`
	Return    uint32       `idl:"name:Return" json:"return"`
}

func (o *xxx_SetConfigurationOperation) OpNum() int { return 20 }

func (o *xxx_SetConfigurationOperation) OpName() string { return "/fax/v4/FAX_SetConfiguration" }

func (o *xxx_SetConfigurationOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetConfigurationOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// FaxConfig {in} (1:{pointer=ref}*(1))(2:{alias=FAX_CONFIGURATIONW}(struct))
	{
		if o.FaxConfig != nil {
			if err := o.FaxConfig.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.ConfigW{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetConfigurationOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// FaxConfig {in} (1:{pointer=ref}*(1))(2:{alias=FAX_CONFIGURATIONW}(struct))
	{
		if o.FaxConfig == nil {
			o.FaxConfig = &fax.ConfigW{}
		}
		if err := o.FaxConfig.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetConfigurationOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetConfigurationOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetConfigurationOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetConfigurationRequest structure represents the FAX_SetConfiguration operation request
type SetConfigurationRequest struct {
	// FaxConfig: A pointer to a FAX_CONFIGURATIONW. The SizeOfStruct member of this structure
	// MUST be set to the correct size, in bytes, of the FAX_CONFIGURATIONW described in
	// section 2.2.28. The structure MUST be passed as a byte array buffer. The structure
	// MUST be present at the start of the buffer. The LPCWSTR fields in the structure MUST
	// store the offsets to the actual string data, which MUST be located at the end of
	// the structure. The LPCWSTR strings located at the end of the buffer MUST be in the
	// same order of occurrence in the structure.  If the Branding structure member is
	// TRUE, the fax server SHOULD generate a brand that contains transmission-related information,
	// such as the transmitting subscriber identifier, date, time, and page count. If the
	// UseDeviceTsid structure member is TRUE, the server SHOULD use the device's transmitting
	// subscriber identifier. If the ServerCp structure member is TRUE, the client SHOULD
	// use a common cover page stored on the fax server; if this member is FALSE, the client
	// SHOULD use a personal cover page template. If the PauseServerQueue structure member
	// is TRUE, the server SHOULD pause the outgoing fax queue. If the ArchiveOutgoingFaxes
	// structure member is TRUE, the server SHOULD archive transmissions in the directory
	// specified by the ArchiveDirectory member. The fax server SHOULD ignore the ArchiveDirectory
	// structure member if the ArchiveOutgoingFaxes member is FALSE. If the ArchiveOutgoingFaxes
	// member is TRUE, the fax server SHOULD<155> validate the value of the ArchiveDirectory
	// member, and if this validation succeeds, the fax server SHOULD retain the value of
	// the ArchiveDirectory member and use this value as the name of the directory where
	// the fax server will archive the future fax transmissions. The fax server SHOULD retain
	// the discount time period submitted by the client with the StartCheapTime and the
	// StopCheapTime structure members.<156>
	FaxConfig *fax.ConfigW `idl:"name:FaxConfig" json:"fax_config"`
}

func (o *SetConfigurationRequest) xxx_ToOp(ctx context.Context, op *xxx_SetConfigurationOperation) *xxx_SetConfigurationOperation {
	if op == nil {
		op = &xxx_SetConfigurationOperation{}
	}
	if o == nil {
		return op
	}
	op.FaxConfig = o.FaxConfig
	return op
}

func (o *SetConfigurationRequest) xxx_FromOp(ctx context.Context, op *xxx_SetConfigurationOperation) {
	if o == nil {
		return
	}
	o.FaxConfig = op.FaxConfig
}
func (o *SetConfigurationRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetConfigurationRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetConfigurationOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetConfigurationResponse structure represents the FAX_SetConfiguration operation response
type SetConfigurationResponse struct {
	// Return: The FAX_SetConfiguration return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetConfigurationResponse) xxx_ToOp(ctx context.Context, op *xxx_SetConfigurationOperation) *xxx_SetConfigurationOperation {
	if op == nil {
		op = &xxx_SetConfigurationOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetConfigurationResponse) xxx_FromOp(ctx context.Context, op *xxx_SetConfigurationOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetConfigurationResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetConfigurationResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetConfigurationOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetLoggingCategoriesOperation structure represents the FAX_GetLoggingCategories operation
type xxx_GetLoggingCategoriesOperation struct {
	Buffer           []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	BufferSize       uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	NumberCategories uint32 `idl:"name:NumberCategories;pointer:ref" json:"number_categories"`
	Return           uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetLoggingCategoriesOperation) OpNum() int { return 21 }

func (o *xxx_GetLoggingCategoriesOperation) OpName() string {
	return "/fax/v4/FAX_GetLoggingCategories"
}

func (o *xxx_GetLoggingCategoriesOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetLoggingCategoriesOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	return nil
}

func (o *xxx_GetLoggingCategoriesOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	return nil
}

func (o *xxx_GetLoggingCategoriesOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Buffer != nil && o.BufferSize == 0 {
		o.BufferSize = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetLoggingCategoriesOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		if o.Buffer != nil || o.BufferSize > 0 {
			_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.BufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Buffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Buffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	// NumberCategories {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.NumberCategories); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetLoggingCategoriesOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE,pointer=ref}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
			}
			o.Buffer = make([]byte, sizeInfo[0])
			for i1 := range o.Buffer {
				i1 := i1
				if err := w.ReadData(&o.Buffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	// NumberCategories {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.NumberCategories); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetLoggingCategoriesRequest structure represents the FAX_GetLoggingCategories operation request
type GetLoggingCategoriesRequest struct {
}

func (o *GetLoggingCategoriesRequest) xxx_ToOp(ctx context.Context, op *xxx_GetLoggingCategoriesOperation) *xxx_GetLoggingCategoriesOperation {
	if op == nil {
		op = &xxx_GetLoggingCategoriesOperation{}
	}
	if o == nil {
		return op
	}
	return op
}

func (o *GetLoggingCategoriesRequest) xxx_FromOp(ctx context.Context, op *xxx_GetLoggingCategoriesOperation) {
	if o == nil {
		return
	}
}
func (o *GetLoggingCategoriesRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetLoggingCategoriesRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetLoggingCategoriesOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetLoggingCategoriesResponse structure represents the FAX_GetLoggingCategories operation response
type GetLoggingCategoriesResponse struct {
	// Buffer: A pointer to the address of a buffer to receive an array of FAX_LOG_CATEGORY
	// (section 2.2.11) structures. The number of structures included in the array is set
	// by NumberCategories. Each structure describes one current logging category. The Name
	// strings are appended after the FAX_LOG_CATEGORY entries. The Name field of each FAX_LOG_CATEGORY
	// is an offset indicating the location of the associated Name string in the buffer.<113>
	Buffer []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	// BufferSize: A variable to return the size, in bytes, of the buffer.
	BufferSize uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	// NumberCategories:  A pointer to a DWORD ([MS-DTYP] section 2.2.9) variable to receive
	// the number of FAX_LOG_CATEGORY that the method returns in the Buffer parameter.
	NumberCategories uint32 `idl:"name:NumberCategories;pointer:ref" json:"number_categories"`
	// Return: The FAX_GetLoggingCategories return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetLoggingCategoriesResponse) xxx_ToOp(ctx context.Context, op *xxx_GetLoggingCategoriesOperation) *xxx_GetLoggingCategoriesOperation {
	if op == nil {
		op = &xxx_GetLoggingCategoriesOperation{}
	}
	if o == nil {
		return op
	}
	op.Buffer = o.Buffer
	op.BufferSize = o.BufferSize
	op.NumberCategories = o.NumberCategories
	op.Return = o.Return
	return op
}

func (o *GetLoggingCategoriesResponse) xxx_FromOp(ctx context.Context, op *xxx_GetLoggingCategoriesOperation) {
	if o == nil {
		return
	}
	o.Buffer = op.Buffer
	o.BufferSize = op.BufferSize
	o.NumberCategories = op.NumberCategories
	o.Return = op.Return
}
func (o *GetLoggingCategoriesResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetLoggingCategoriesResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetLoggingCategoriesOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetLoggingCategoriesOperation structure represents the FAX_SetLoggingCategories operation
type xxx_SetLoggingCategoriesOperation struct {
	Buffer           []byte `idl:"name:Buffer;size_is:(BufferSize);pointer:unique" json:"buffer"`
	BufferSize       uint32 `idl:"name:BufferSize" json:"buffer_size"`
	NumberCategories uint32 `idl:"name:NumberCategories" json:"number_categories"`
	Return           uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_SetLoggingCategoriesOperation) OpNum() int { return 22 }

func (o *xxx_SetLoggingCategoriesOperation) OpName() string {
	return "/fax/v4/FAX_SetLoggingCategories"
}

func (o *xxx_SetLoggingCategoriesOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.Buffer != nil && o.BufferSize == 0 {
		o.BufferSize = uint32(len(o.Buffer))
	}
	if o.BufferSize > uint32(1048576) {
		return fmt.Errorf("BufferSize is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetLoggingCategoriesOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// Buffer {in} (1:{pointer=unique, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		if o.Buffer != nil || o.BufferSize > 0 {
			_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.BufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Buffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Buffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {in} (1:{range=(0,1048576), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	// NumberCategories {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.NumberCategories); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetLoggingCategoriesOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// Buffer {in} (1:{pointer=unique, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
			}
			o.Buffer = make([]byte, sizeInfo[0])
			for i1 := range o.Buffer {
				i1 := i1
				if err := w.ReadData(&o.Buffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {in} (1:{range=(0,1048576), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	// NumberCategories {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.NumberCategories); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetLoggingCategoriesOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetLoggingCategoriesOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetLoggingCategoriesOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetLoggingCategoriesRequest structure represents the FAX_SetLoggingCategories operation request
type SetLoggingCategoriesRequest struct {
	// Buffer: A pointer to an array of the FAX_LOG_CATEGORY (section 2.2.11) structure.
	// Each structure contains the data to modify one logging category. The data includes
	// a friendly name of the logging category, a numeric identifier for the category, and
	// the current severity-level threshold for the category. For more information, see
	// [MSDN-FSCAR].
	Buffer []byte `idl:"name:Buffer;size_is:(BufferSize);pointer:unique" json:"buffer"`
	// BufferSize: A variable to return the size, in bytes, of the job information buffer.
	// This variable MUST be set to a value between 1 and 1,048,576. The maximum size is
	// FAX_MAX_RPC_BUFFER (section 2.2.82).
	BufferSize uint32 `idl:"name:BufferSize" json:"buffer_size"`
	// NumberCategories: A DWORD ([MS-DTYP] section 2.2.9) variable that contains the number
	// of FAX_LOG_CATEGORY items that the method passes in the Buffer parameter.
	NumberCategories uint32 `idl:"name:NumberCategories" json:"number_categories"`
}

func (o *SetLoggingCategoriesRequest) xxx_ToOp(ctx context.Context, op *xxx_SetLoggingCategoriesOperation) *xxx_SetLoggingCategoriesOperation {
	if op == nil {
		op = &xxx_SetLoggingCategoriesOperation{}
	}
	if o == nil {
		return op
	}
	op.Buffer = o.Buffer
	op.BufferSize = o.BufferSize
	op.NumberCategories = o.NumberCategories
	return op
}

func (o *SetLoggingCategoriesRequest) xxx_FromOp(ctx context.Context, op *xxx_SetLoggingCategoriesOperation) {
	if o == nil {
		return
	}
	o.Buffer = op.Buffer
	o.BufferSize = op.BufferSize
	o.NumberCategories = op.NumberCategories
}
func (o *SetLoggingCategoriesRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetLoggingCategoriesRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetLoggingCategoriesOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetLoggingCategoriesResponse structure represents the FAX_SetLoggingCategories operation response
type SetLoggingCategoriesResponse struct {
	// Return: The FAX_SetLoggingCategories return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetLoggingCategoriesResponse) xxx_ToOp(ctx context.Context, op *xxx_SetLoggingCategoriesOperation) *xxx_SetLoggingCategoriesOperation {
	if op == nil {
		op = &xxx_SetLoggingCategoriesOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetLoggingCategoriesResponse) xxx_FromOp(ctx context.Context, op *xxx_SetLoggingCategoriesOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetLoggingCategoriesResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetLoggingCategoriesResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetLoggingCategoriesOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetSecurityOperation structure represents the FAX_GetSecurity operation
type xxx_GetSecurityOperation struct {
	SecurityDescriptor []byte `idl:"name:pSecurityDescriptor;size_is:(, lpdwBufferSize)" json:"security_descriptor"`
	BufferSize         uint32 `idl:"name:lpdwBufferSize;pointer:ref" json:"buffer_size"`
	Return             uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetSecurityOperation) OpNum() int { return 23 }

func (o *xxx_GetSecurityOperation) OpName() string { return "/fax/v4/FAX_GetSecurity" }

func (o *xxx_GetSecurityOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetSecurityOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	return nil
}

func (o *xxx_GetSecurityOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	return nil
}

func (o *xxx_GetSecurityOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.SecurityDescriptor != nil && o.BufferSize == 0 {
		o.BufferSize = uint32(len(o.SecurityDescriptor))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetSecurityOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pSecurityDescriptor {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE}*(1))(3:{alias=BYTE}[dim:0,size_is=lpdwBufferSize](uchar))
	{
		if o.SecurityDescriptor != nil || o.BufferSize > 0 {
			_ptr_pSecurityDescriptor := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.BufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.SecurityDescriptor {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.SecurityDescriptor[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.SecurityDescriptor); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.SecurityDescriptor, _ptr_pSecurityDescriptor); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpdwBufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetSecurityOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pSecurityDescriptor {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE,pointer=ref}*(1))(3:{alias=BYTE}[dim:0,size_is=lpdwBufferSize](uchar))
	{
		_ptr_pSecurityDescriptor := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.SecurityDescriptor", sizeInfo[0])
			}
			o.SecurityDescriptor = make([]byte, sizeInfo[0])
			for i1 := range o.SecurityDescriptor {
				i1 := i1
				if err := w.ReadData(&o.SecurityDescriptor[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_pSecurityDescriptor := func(ptr interface{}) { o.SecurityDescriptor = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.SecurityDescriptor, _s_pSecurityDescriptor, _ptr_pSecurityDescriptor); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpdwBufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetSecurityRequest structure represents the FAX_GetSecurity operation request
type GetSecurityRequest struct {
}

func (o *GetSecurityRequest) xxx_ToOp(ctx context.Context, op *xxx_GetSecurityOperation) *xxx_GetSecurityOperation {
	if op == nil {
		op = &xxx_GetSecurityOperation{}
	}
	if o == nil {
		return op
	}
	return op
}

func (o *GetSecurityRequest) xxx_FromOp(ctx context.Context, op *xxx_GetSecurityOperation) {
	if o == nil {
		return
	}
}
func (o *GetSecurityRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetSecurityRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetSecurityOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetSecurityResponse structure represents the FAX_GetSecurity operation response
type GetSecurityResponse struct {
	// pSecurityDescriptor: A pointer to a SECURITY_DESCRIPTOR ([MS-DTYP] section 2.4.6)
	// structure.
	SecurityDescriptor []byte `idl:"name:pSecurityDescriptor;size_is:(, lpdwBufferSize)" json:"security_descriptor"`
	// lpdwBufferSize: A variable to return the size, in bytes, of the security descriptor
	// buffer.
	BufferSize uint32 `idl:"name:lpdwBufferSize;pointer:ref" json:"buffer_size"`
	// Return: The FAX_GetSecurity return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetSecurityResponse) xxx_ToOp(ctx context.Context, op *xxx_GetSecurityOperation) *xxx_GetSecurityOperation {
	if op == nil {
		op = &xxx_GetSecurityOperation{}
	}
	if o == nil {
		return op
	}
	op.SecurityDescriptor = o.SecurityDescriptor
	op.BufferSize = o.BufferSize
	op.Return = o.Return
	return op
}

func (o *GetSecurityResponse) xxx_FromOp(ctx context.Context, op *xxx_GetSecurityOperation) {
	if o == nil {
		return
	}
	o.SecurityDescriptor = op.SecurityDescriptor
	o.BufferSize = op.BufferSize
	o.Return = op.Return
}
func (o *GetSecurityResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetSecurityResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetSecurityOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetSecurityOperation structure represents the FAX_SetSecurity operation
type xxx_SetSecurityOperation struct {
	SecurityInformation uint32 `idl:"name:SecurityInformation" json:"security_information"`
	SecurityDescriptor  []byte `idl:"name:pSecurityDescriptor;size_is:(dwBufferSize);pointer:unique" json:"security_descriptor"`
	BufferSize          uint32 `idl:"name:dwBufferSize" json:"buffer_size"`
	Return              uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_SetSecurityOperation) OpNum() int { return 24 }

func (o *xxx_SetSecurityOperation) OpName() string { return "/fax/v4/FAX_SetSecurity" }

func (o *xxx_SetSecurityOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.SecurityDescriptor != nil && o.BufferSize == 0 {
		o.BufferSize = uint32(len(o.SecurityDescriptor))
	}
	if o.BufferSize > uint32(1048576) {
		return fmt.Errorf("BufferSize is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetSecurityOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// SecurityInformation {in} (1:{alias=SECURITY_INFORMATION, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.SecurityInformation); err != nil {
			return err
		}
	}
	// pSecurityDescriptor {in} (1:{pointer=unique, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=dwBufferSize](uchar))
	{
		if o.SecurityDescriptor != nil || o.BufferSize > 0 {
			_ptr_pSecurityDescriptor := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.BufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.SecurityDescriptor {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.SecurityDescriptor[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.SecurityDescriptor); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.SecurityDescriptor, _ptr_pSecurityDescriptor); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// dwBufferSize {in} (1:{range=(0,1048576), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetSecurityOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// SecurityInformation {in} (1:{alias=SECURITY_INFORMATION, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.SecurityInformation); err != nil {
			return err
		}
	}
	// pSecurityDescriptor {in} (1:{pointer=unique, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=dwBufferSize](uchar))
	{
		_ptr_pSecurityDescriptor := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.SecurityDescriptor", sizeInfo[0])
			}
			o.SecurityDescriptor = make([]byte, sizeInfo[0])
			for i1 := range o.SecurityDescriptor {
				i1 := i1
				if err := w.ReadData(&o.SecurityDescriptor[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_pSecurityDescriptor := func(ptr interface{}) { o.SecurityDescriptor = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.SecurityDescriptor, _s_pSecurityDescriptor, _ptr_pSecurityDescriptor); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// dwBufferSize {in} (1:{range=(0,1048576), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetSecurityOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetSecurityOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetSecurityOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetSecurityRequest structure represents the FAX_SetSecurity operation request
type SetSecurityRequest struct {
	// SecurityInformation: Identifies the components that are included in the security
	// descriptor. The value of this parameter is a bitwise OR combination of SECURITY_INFORMATION
	// ([MS-DTYP] section 2.4.7) constant values.
	SecurityInformation uint32 `idl:"name:SecurityInformation" json:"security_information"`
	// pSecurityDescriptor: A pointer to a SECURITY_DESCRIPTOR ([MS-DTYP] section 2.4.6)
	// structure to be set.
	SecurityDescriptor []byte `idl:"name:pSecurityDescriptor;size_is:(dwBufferSize);pointer:unique" json:"security_descriptor"`
	// dwBufferSize: A variable to indicate the size, in bytes, of the pSecurityDescriptor
	// security descriptor buffer. The maximum size is FAX_MAX_RPC_BUFFER (section 2.2.82).
	BufferSize uint32 `idl:"name:dwBufferSize" json:"buffer_size"`
}

func (o *SetSecurityRequest) xxx_ToOp(ctx context.Context, op *xxx_SetSecurityOperation) *xxx_SetSecurityOperation {
	if op == nil {
		op = &xxx_SetSecurityOperation{}
	}
	if o == nil {
		return op
	}
	op.SecurityInformation = o.SecurityInformation
	op.SecurityDescriptor = o.SecurityDescriptor
	op.BufferSize = o.BufferSize
	return op
}

func (o *SetSecurityRequest) xxx_FromOp(ctx context.Context, op *xxx_SetSecurityOperation) {
	if o == nil {
		return
	}
	o.SecurityInformation = op.SecurityInformation
	o.SecurityDescriptor = op.SecurityDescriptor
	o.BufferSize = op.BufferSize
}
func (o *SetSecurityRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetSecurityRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetSecurityOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetSecurityResponse structure represents the FAX_SetSecurity operation response
type SetSecurityResponse struct {
	// Return: The FAX_SetSecurity return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetSecurityResponse) xxx_ToOp(ctx context.Context, op *xxx_SetSecurityOperation) *xxx_SetSecurityOperation {
	if op == nil {
		op = &xxx_SetSecurityOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetSecurityResponse) xxx_FromOp(ctx context.Context, op *xxx_SetSecurityOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetSecurityResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetSecurityResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetSecurityOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AccessCheckOperation structure represents the FAX_AccessCheck operation
type xxx_AccessCheckOperation struct {
	AccessMask uint32 `idl:"name:AccessMask" json:"access_mask"`
	Access     bool   `idl:"name:pfAccess;pointer:ref" json:"access"`
	Rights     uint32 `idl:"name:lpdwRights;pointer:unique" json:"rights"`
	Return     uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_AccessCheckOperation) OpNum() int { return 25 }

func (o *xxx_AccessCheckOperation) OpName() string { return "/fax/v4/FAX_AccessCheck" }

func (o *xxx_AccessCheckOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AccessCheckOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// AccessMask {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.AccessMask); err != nil {
			return err
		}
	}
	// lpdwRights {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		// XXX pointer to primitive type, default behavior is to write non-null pointer.
		// if this behavior is not desired, use goext_default_null([cond]) attribute.
		_ptr_lpdwRights := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.Rights); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Rights, _ptr_lpdwRights); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AccessCheckOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// AccessMask {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.AccessMask); err != nil {
			return err
		}
	}
	// lpdwRights {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_lpdwRights := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.Rights); err != nil {
				return err
			}
			return nil
		})
		_s_lpdwRights := func(ptr interface{}) { o.Rights = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.Rights, _s_lpdwRights, _ptr_lpdwRights); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AccessCheckOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AccessCheckOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pfAccess {out} (1:{pointer=ref}*(1))(2:{alias=BOOL}(int32))
	{
		if !o.Access {
			if err := w.WriteData(int32(0)); err != nil {
				return err
			}
		} else {
			if err := w.WriteData(int32(1)); err != nil {
				return err
			}
		}
	}
	// lpdwRights {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		// XXX pointer to primitive type, default behavior is to write non-null pointer.
		// if this behavior is not desired, use goext_default_null([cond]) attribute.
		_ptr_lpdwRights := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.Rights); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Rights, _ptr_lpdwRights); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AccessCheckOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pfAccess {out} (1:{pointer=ref}*(1))(2:{alias=BOOL}(int32))
	{
		var _bAccess int32
		if err := w.ReadData(&_bAccess); err != nil {
			return err
		}
		o.Access = _bAccess != 0
	}
	// lpdwRights {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_lpdwRights := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.Rights); err != nil {
				return err
			}
			return nil
		})
		_s_lpdwRights := func(ptr interface{}) { o.Rights = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.Rights, _s_lpdwRights, _ptr_lpdwRights); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AccessCheckRequest structure represents the FAX_AccessCheck operation request
type AccessCheckRequest struct {
	// AccessMask: A DWORD ([MS-DTYP] section 2.2.9) variable that MUST contain a set of
	// bit flags that define the fax access permissions specified by the client to be validated
	// against the access permissions of the client's fax user account. This parameter can
	// be any bitwise OR combination of fax-specific access rights, standard access rights,
	// and fax-generic access rights. For a list of standard access rights, see [MSDN-SAR].
	//
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	|       FAX-GENERIC ACCESS       |                                                                                  |
	//	|             RIGHTS             |                                     MEANING                                      |
	//	|                                |                                                                                  |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_GENERIC_EXECUTE 0x00000001 | Identical to the FAX_ACCESS_SUBMIT access right.                                 |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_GENERIC_READ 0x000002A8    | Includes the read-only rights that are granted by the following specific         |
	//	|                                | access rights: § FAX_ACCESS_QUERY_JOBS § FAX_ACCESS_QUERY_CONFIG §               |
	//	|                                | FAX_ACCESS_QUERY_IN_ARCHIVE § FAX_ACCESS_QUERY_OUT_ARCHIVE                       |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_GENERIC_WRITE 0x00000550   | Includes the management rights that are granted by the following specific        |
	//	|                                | access rights: § FAX_ACCESS_MANAGE_JOBS § FAX_ACCESS_MANAGE_CONFIG §             |
	//	|                                | FAX_ACCESS_MANAGE_IN_ARCHIVE § FAX_ACCESS_MANAGE_OUT_ARCHIVE                     |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_GENERIC_ALL 0x000007FF     | Includes all the following specific fax permissions: § FAX_ACCESS_SUBMIT §       |
	//	|                                | FAX_ACCESS_SUBMIT_NORMAL § FAX_ACCESS_SUBMIT_HIGH § FAX_ACCESS_QUERY_JOBS §      |
	//	|                                | FAX_ACCESS_MANAGE_JOBS § FAX_ACCESS_QUERY_CONFIG § FAX_ACCESS_MANAGE_CONFIG      |
	//	|                                | § FAX_ACCESS_QUERY_IN_ARCHIVE § FAX_ACCESS_MANAGE_IN_ARCHIVE §                   |
	//	|                                | FAX_ACCESS_QUERY_OUT_ARCHIVE § FAX_ACCESS_MANAGE_OUT_ARCHIVE                     |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//
	//
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	|           FAX-SPECIFIC ACCESS            |                                                                                  |
	//	|                  RIGHTS                  |                                   DESCRIPTION                                    |
	//	|                                          |                                                                                  |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ACCESS_SUBMIT 0x00000001             | Grants permission to send a low-priority fax transmission to one or more         |
	//	|                                          | recipients.                                                                      |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ACCESS_SUBMIT_NORMAL 0x00000002      | Grants permission to send a normal-priority fax transmission to one or more      |
	//	|                                          | recipients.                                                                      |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ACCESS_SUBMIT_HIGH 0x00000004        | Grants permission to send a high-priority fax transmission to one or more        |
	//	|                                          | recipients.                                                                      |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ACCESS_QUERY_JOBS 0x00000008         | Grants permission to view all the incoming and outgoing faxes in the Incoming    |
	//	|                                          | and Outbox queues, including those that belong to other users. By default,       |
	//	|                                          | without this permission, non-administrator users can view their own outgoing     |
	//	|                                          | messages in the Outbox queue but cannot view the Incoming queue. Also,           |
	//	|                                          | non-administrator users cannot view incoming or outgoing faxes that belong to    |
	//	|                                          | other users.                                                                     |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ACCESS_MANAGE_JOBS 0x00000010        | Grants permission to manage all the incoming and outgoing faxes in the Incoming  |
	//	|                                          | and Outbox queues, including those that belong to other users. By default,       |
	//	|                                          | without this permission, non-administrator users can manage their own outgoing   |
	//	|                                          | messages in the Outgoing queue (defined in section 3.1.1) but cannot manage the  |
	//	|                                          | Incoming queue. Also, non-administrator users cannot manage incoming or outgoing |
	//	|                                          | faxes that belong to other users.                                                |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ACCESS_QUERY_CONFIG 0x00000020       | Grants permission to view the properties of the Fax Service. By default,         |
	//	|                                          | non-administrator users do not have this permission. Without this permission,    |
	//	|                                          | users cannot view any of the tree nodes, except for the cover page node in the   |
	//	|                                          | Fax Service Manager.                                                             |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ACCESS_MANAGE_CONFIG 0x00000040      | Grants permission to modify the properties of the fax service. By default,       |
	//	|                                          | non-administrator users do not have this permission.                             |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ACCESS_QUERY_IN_ARCHIVE 0x00000080   | Grants permission to view all successfully received messages in the Inbox        |
	//	|                                          | archive. By default, without this permission, non-administrator users cannot     |
	//	|                                          | view archived incoming faxes.                                                    |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ACCESS_MANAGE_IN_ARCHIVE 0x00000100  | Grants permission to manage all successfully received messages in the Inbox      |
	//	|                                          | archive. By default, without this permission, non-administrator users cannot     |
	//	|                                          | manage archived incoming faxes.                                                  |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ACCESS_QUERY_OUT_ARCHIVE 0x00000200  | Grants permission to view all successfully sent messages in the Sent Items       |
	//	|                                          | archive, including those belonging to other users. By default, without this      |
	//	|                                          | permission, non-administrator users can view archives of their own sent messages |
	//	|                                          | but cannot view archives that belong to other users.                             |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ACCESS_MANAGE_OUT_ARCHIVE 0x00000400 | Grants permission to manage all successfully sent messages in the Sent Items     |
	//	|                                          | archive, including those that belong to other users. By default, without this    |
	//	|                                          | permission, non-administrator users can manage archives of their own sent        |
	//	|                                          | messages but cannot manage archives that belong to other users.                  |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//
	//
	//	+-------------------------+----------------------------------------------------------------------------------+
	//	|     STANDARD ACCESS     |                                                                                  |
	//	|         RIGHTS          |                                   DESCRIPTIION                                   |
	//	|                         |                                                                                  |
	//	+-------------------------+----------------------------------------------------------------------------------+
	//	+-------------------------+----------------------------------------------------------------------------------+
	//	| DELETE 0x00010000       | Delete access.                                                                   |
	//	+-------------------------+----------------------------------------------------------------------------------+
	//	| READ_CONTROL 0x00020000 | Read access to the owner, group, and discretionary access control list (ACL) of  |
	//	|                         | the security descriptor.                                                         |
	//	+-------------------------+----------------------------------------------------------------------------------+
	//	| WRITE_DAC 0x00040000    | Write access to the ACL.                                                         |
	//	+-------------------------+----------------------------------------------------------------------------------+
	//	| WRITE_OWNER 0x00080000  | Write access to the owner.                                                       |
	//	+-------------------------+----------------------------------------------------------------------------------+
	//	| SYNCHRONIZE 0x00100000  | Allow use of the object for synchronization.                                     |
	//	+-------------------------+----------------------------------------------------------------------------------+
	//
	//
	//	+-----------------------------+------------------------------------------------+
	//	|    MISCELLANEOUS ACCESS     |                                                |
	//	|           RIGHTS            |                  DESCRIPTION                   |
	//	|                             |                                                |
	//	+-----------------------------+------------------------------------------------+
	//	+-----------------------------+------------------------------------------------+
	//	| MAXIMUM_ALLOWED 0x02000000  | Maximum allowed access rights for this server. |
	//	+-----------------------------+------------------------------------------------+
	AccessMask uint32 `idl:"name:AccessMask" json:"access_mask"`
	// lpdwRights: A pointer to a DWORD value to receive the fax access rights that this
	// caller is verified to have of those requested in the AccessMask parameter. This value
	// MUST be a DWORD bitwise OR combination of fax-specific access rights, standard access
	// rights, and/or fax-generic access rights limited to those specified by the client
	// in the AccessMask. In order for the client to be verified for the maxiumum allowed
	// rights, the caller MUST set the AccessMask to 0x02000000 (MAXIMUM_ALLOWED) and the
	// server SHOULD set this output value to the actual rights that this caller is verified
	// to have.
	Rights uint32 `idl:"name:lpdwRights;pointer:unique" json:"rights"`
}

func (o *AccessCheckRequest) xxx_ToOp(ctx context.Context, op *xxx_AccessCheckOperation) *xxx_AccessCheckOperation {
	if op == nil {
		op = &xxx_AccessCheckOperation{}
	}
	if o == nil {
		return op
	}
	op.AccessMask = o.AccessMask
	op.Rights = o.Rights
	return op
}

func (o *AccessCheckRequest) xxx_FromOp(ctx context.Context, op *xxx_AccessCheckOperation) {
	if o == nil {
		return
	}
	o.AccessMask = op.AccessMask
	o.Rights = op.Rights
}
func (o *AccessCheckRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *AccessCheckRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AccessCheckOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AccessCheckResponse structure represents the FAX_AccessCheck operation response
type AccessCheckResponse struct {
	// pfAccess: A pointer to a BOOL ([MS-DTYP] section 2.2.3) to receive the access check
	// return value. This value MUST be TRUE if the client's fax user account has all of
	// the fax access rights specified by the AccessMask parameter; otherwise, this value
	// MUST be FALSE. If the value submitted by the client for the AccessMask is zero, the
	// value pointed to by the pfAccess parameter SHOULD be FALSE on return.
	Access bool `idl:"name:pfAccess;pointer:ref" json:"access"`
	// lpdwRights: A pointer to a DWORD value to receive the fax access rights that this
	// caller is verified to have of those requested in the AccessMask parameter. This value
	// MUST be a DWORD bitwise OR combination of fax-specific access rights, standard access
	// rights, and/or fax-generic access rights limited to those specified by the client
	// in the AccessMask. In order for the client to be verified for the maxiumum allowed
	// rights, the caller MUST set the AccessMask to 0x02000000 (MAXIMUM_ALLOWED) and the
	// server SHOULD set this output value to the actual rights that this caller is verified
	// to have.
	Rights uint32 `idl:"name:lpdwRights;pointer:unique" json:"rights"`
	// Return: The FAX_AccessCheck return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AccessCheckResponse) xxx_ToOp(ctx context.Context, op *xxx_AccessCheckOperation) *xxx_AccessCheckOperation {
	if op == nil {
		op = &xxx_AccessCheckOperation{}
	}
	if o == nil {
		return op
	}
	op.Access = o.Access
	op.Rights = o.Rights
	op.Return = o.Return
	return op
}

func (o *AccessCheckResponse) xxx_FromOp(ctx context.Context, op *xxx_AccessCheckOperation) {
	if o == nil {
		return
	}
	o.Access = op.Access
	o.Rights = op.Rights
	o.Return = op.Return
}
func (o *AccessCheckResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *AccessCheckResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AccessCheckOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CheckServerProtocolSeqOperation structure represents the FAX_CheckServerProtSeq operation
type xxx_CheckServerProtocolSeqOperation struct {
	ProtocolSeq uint32 `idl:"name:lpdwProtSeq;pointer:unique" json:"protocol_seq"`
	Return      uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_CheckServerProtocolSeqOperation) OpNum() int { return 26 }

func (o *xxx_CheckServerProtocolSeqOperation) OpName() string {
	return "/fax/v4/FAX_CheckServerProtSeq"
}

func (o *xxx_CheckServerProtocolSeqOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CheckServerProtocolSeqOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lpdwProtSeq {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		// XXX pointer to primitive type, default behavior is to write non-null pointer.
		// if this behavior is not desired, use goext_default_null([cond]) attribute.
		_ptr_lpdwProtSeq := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.ProtocolSeq); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ProtocolSeq, _ptr_lpdwProtSeq); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CheckServerProtocolSeqOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lpdwProtSeq {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_lpdwProtSeq := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.ProtocolSeq); err != nil {
				return err
			}
			return nil
		})
		_s_lpdwProtSeq := func(ptr interface{}) { o.ProtocolSeq = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.ProtocolSeq, _s_lpdwProtSeq, _ptr_lpdwProtSeq); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CheckServerProtocolSeqOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CheckServerProtocolSeqOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpdwProtSeq {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		// XXX pointer to primitive type, default behavior is to write non-null pointer.
		// if this behavior is not desired, use goext_default_null([cond]) attribute.
		_ptr_lpdwProtSeq := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.ProtocolSeq); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ProtocolSeq, _ptr_lpdwProtSeq); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CheckServerProtocolSeqOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpdwProtSeq {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_lpdwProtSeq := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.ProtocolSeq); err != nil {
				return err
			}
			return nil
		})
		_s_lpdwProtSeq := func(ptr interface{}) { o.ProtocolSeq = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.ProtocolSeq, _s_lpdwProtSeq, _ptr_lpdwProtSeq); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CheckServerProtocolSeqRequest structure represents the FAX_CheckServerProtSeq operation request
type CheckServerProtocolSeqRequest struct {
	// lpdwProtSeq: A variable into which the requested sequence is specified. If the specified
	// protocol sequence is supported, upon return, lpdwProtSeq contains the value for this
	// validated sequence.
	//
	//	+-------------------+------------------------------------------+
	//	|                   |                                          |
	//	|    VALUE/CODE     |                 MEANING                  |
	//	|                   |                                          |
	//	+-------------------+------------------------------------------+
	//	+-------------------+------------------------------------------+
	//	| RPC_PROT_TCP_IP 1 | Check the protocol sequence for TCP/IP.  |
	//	+-------------------+------------------------------------------+
	//	| RPC_PROT_SPX 2    | Check the protocol sequence for IPX/SPX. |
	//	+-------------------+------------------------------------------+
	ProtocolSeq uint32 `idl:"name:lpdwProtSeq;pointer:unique" json:"protocol_seq"`
}

func (o *CheckServerProtocolSeqRequest) xxx_ToOp(ctx context.Context, op *xxx_CheckServerProtocolSeqOperation) *xxx_CheckServerProtocolSeqOperation {
	if op == nil {
		op = &xxx_CheckServerProtocolSeqOperation{}
	}
	if o == nil {
		return op
	}
	op.ProtocolSeq = o.ProtocolSeq
	return op
}

func (o *CheckServerProtocolSeqRequest) xxx_FromOp(ctx context.Context, op *xxx_CheckServerProtocolSeqOperation) {
	if o == nil {
		return
	}
	o.ProtocolSeq = op.ProtocolSeq
}
func (o *CheckServerProtocolSeqRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *CheckServerProtocolSeqRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CheckServerProtocolSeqOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CheckServerProtocolSeqResponse structure represents the FAX_CheckServerProtSeq operation response
type CheckServerProtocolSeqResponse struct {
	// lpdwProtSeq: A variable into which the requested sequence is specified. If the specified
	// protocol sequence is supported, upon return, lpdwProtSeq contains the value for this
	// validated sequence.
	//
	//	+-------------------+------------------------------------------+
	//	|                   |                                          |
	//	|    VALUE/CODE     |                 MEANING                  |
	//	|                   |                                          |
	//	+-------------------+------------------------------------------+
	//	+-------------------+------------------------------------------+
	//	| RPC_PROT_TCP_IP 1 | Check the protocol sequence for TCP/IP.  |
	//	+-------------------+------------------------------------------+
	//	| RPC_PROT_SPX 2    | Check the protocol sequence for IPX/SPX. |
	//	+-------------------+------------------------------------------+
	ProtocolSeq uint32 `idl:"name:lpdwProtSeq;pointer:unique" json:"protocol_seq"`
	// Return: The FAX_CheckServerProtSeq return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CheckServerProtocolSeqResponse) xxx_ToOp(ctx context.Context, op *xxx_CheckServerProtocolSeqOperation) *xxx_CheckServerProtocolSeqOperation {
	if op == nil {
		op = &xxx_CheckServerProtocolSeqOperation{}
	}
	if o == nil {
		return op
	}
	op.ProtocolSeq = o.ProtocolSeq
	op.Return = o.Return
	return op
}

func (o *CheckServerProtocolSeqResponse) xxx_FromOp(ctx context.Context, op *xxx_CheckServerProtocolSeqOperation) {
	if o == nil {
		return
	}
	o.ProtocolSeq = op.ProtocolSeq
	o.Return = op.Return
}
func (o *CheckServerProtocolSeqResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *CheckServerProtocolSeqResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CheckServerProtocolSeqOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SendDocumentExOperation structure represents the FAX_SendDocumentEx operation
type xxx_SendDocumentExOperation struct {
	FileName            string                `idl:"name:lpcwstrFileName;string;pointer:unique" json:"file_name"`
	CoverPageInfo       *fax.CoverPageInfoExW `idl:"name:lpcCoverPageInfo" json:"cover_page_info"`
	SenderProfile       []byte                `idl:"name:lpcSenderProfile" json:"sender_profile"`
	RecipientsLength    uint32                `idl:"name:dwNumRecipients" json:"recipients_length"`
	RecipientList       []byte                `idl:"name:lpcRecipientList;size_is:(, dwNumRecipients)" json:"recipient_list"`
	JobParams           *fax.JobParamExW      `idl:"name:lpJobParams" json:"job_params"`
	JobID               uint32                `idl:"name:lpdwJobId;pointer:unique" json:"job_id"`
	MessageID           uint64                `idl:"name:lpdwlMessageId" json:"message_id"`
	RecipientMessageIDs []uint64              `idl:"name:lpdwlRecipientMessageIds;size_is:(dwNumRecipients)" json:"recipient_message_ids"`
	Return              uint32                `idl:"name:Return" json:"return"`
}

func (o *xxx_SendDocumentExOperation) OpNum() int { return 27 }

func (o *xxx_SendDocumentExOperation) OpName() string { return "/fax/v4/FAX_SendDocumentEx" }

func (o *xxx_SendDocumentExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.RecipientList != nil && o.RecipientsLength == 0 {
		o.RecipientsLength = uint32(len(o.RecipientList))
	}
	if o.RecipientsLength > uint32(10000) {
		return fmt.Errorf("RecipientsLength is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SendDocumentExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lpcwstrFileName {in} (1:{string, pointer=unique, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.FileName != "" {
			_ptr_lpcwstrFileName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.FileName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.FileName, _ptr_lpcwstrFileName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpcCoverPageInfo {in} (1:{alias=LPCFAX_COVERPAGE_INFO_EXW}*(1))(2:{alias=FAX_COVERPAGE_INFO_EXW}(struct))
	{
		if o.CoverPageInfo != nil {
			if err := o.CoverPageInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.CoverPageInfoExW{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpcSenderProfile {in} (1:[dim:0])(2:{alias=LPBYTE}*(1))(3:{alias=BYTE}(uchar))
	{
		dimSize1 := uint64(len(o.SenderProfile))
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.SenderProfile {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			// XXX pointer to primitive type, default behavior is to write non-null pointer.
			// if this behavior is not desired, use goext_default_null([cond]) attribute.
			_ptr_lpcSenderProfile := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := w.WriteData(o.SenderProfile[i1]); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.SenderProfile[i1], _ptr_lpcSenderProfile); err != nil {
				return err
			}
		}
		for i1 := len(o.SenderProfile); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// dwNumRecipients {in} (1:{range=(0,10000), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RecipientsLength); err != nil {
			return err
		}
	}
	// lpcRecipientList {in} (1:{pointer=ref}*(2))(2:{alias=LPBYTE}*(1))(3:{alias=BYTE}[dim:0,size_is=dwNumRecipients](uchar))
	{
		if o.RecipientList != nil || o.RecipientsLength > 0 {
			_ptr_lpcRecipientList := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.RecipientsLength)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.RecipientList {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.RecipientList[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.RecipientList); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.RecipientList, _ptr_lpcRecipientList); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpJobParams {in} (1:{alias=LPCFAX_JOB_PARAM_EXW}*(1))(2:{alias=FAX_JOB_PARAM_EXW}(struct))
	{
		if o.JobParams != nil {
			if err := o.JobParams.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.JobParamExW{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpdwJobId {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		// XXX pointer to primitive type, default behavior is to write non-null pointer.
		// if this behavior is not desired, use goext_default_null([cond]) attribute.
		_ptr_lpdwJobId := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.JobID); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.JobID, _ptr_lpdwJobId); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SendDocumentExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lpcwstrFileName {in} (1:{string, pointer=unique, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_lpcwstrFileName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.FileName); err != nil {
				return err
			}
			return nil
		})
		_s_lpcwstrFileName := func(ptr interface{}) { o.FileName = *ptr.(*string) }
		if err := w.ReadPointer(&o.FileName, _s_lpcwstrFileName, _ptr_lpcwstrFileName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpcCoverPageInfo {in} (1:{alias=LPCFAX_COVERPAGE_INFO_EXW,pointer=ref}*(1))(2:{alias=FAX_COVERPAGE_INFO_EXW}(struct))
	{
		if o.CoverPageInfo == nil {
			o.CoverPageInfo = &fax.CoverPageInfoExW{}
		}
		if err := o.CoverPageInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpcSenderProfile {in} (1:[dim:0])(2:{alias=LPBYTE,pointer=ref}*(1))(3:{alias=BYTE}(uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.SenderProfile", sizeInfo[0])
		}
		o.SenderProfile = make([]byte, sizeInfo[0])
		for i1 := range o.SenderProfile {
			i1 := i1
			_ptr_lpcSenderProfile := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
				if err := w.ReadData(&o.SenderProfile[i1]); err != nil {
					return err
				}
				return nil
			})
			_s_lpcSenderProfile := func(ptr interface{}) { o.SenderProfile[i1] = *ptr.(*uint8) }
			if err := w.ReadPointer(&o.SenderProfile[i1], _s_lpcSenderProfile, _ptr_lpcSenderProfile); err != nil {
				return err
			}
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// dwNumRecipients {in} (1:{range=(0,10000), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RecipientsLength); err != nil {
			return err
		}
	}
	// lpcRecipientList {in} (1:{pointer=ref}*(2))(2:{alias=LPBYTE,pointer=ref}*(1))(3:{alias=BYTE}[dim:0,size_is=dwNumRecipients](uchar))
	{
		_ptr_lpcRecipientList := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.RecipientList", sizeInfo[0])
			}
			o.RecipientList = make([]byte, sizeInfo[0])
			for i1 := range o.RecipientList {
				i1 := i1
				if err := w.ReadData(&o.RecipientList[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_lpcRecipientList := func(ptr interface{}) { o.RecipientList = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.RecipientList, _s_lpcRecipientList, _ptr_lpcRecipientList); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpJobParams {in} (1:{alias=LPCFAX_JOB_PARAM_EXW,pointer=ref}*(1))(2:{alias=FAX_JOB_PARAM_EXW}(struct))
	{
		if o.JobParams == nil {
			o.JobParams = &fax.JobParamExW{}
		}
		if err := o.JobParams.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpdwJobId {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_lpdwJobId := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.JobID); err != nil {
				return err
			}
			return nil
		})
		_s_lpdwJobId := func(ptr interface{}) { o.JobID = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.JobID, _s_lpdwJobId, _ptr_lpdwJobId); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SendDocumentExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SendDocumentExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpdwJobId {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		// XXX pointer to primitive type, default behavior is to write non-null pointer.
		// if this behavior is not desired, use goext_default_null([cond]) attribute.
		_ptr_lpdwJobId := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.JobID); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.JobID, _ptr_lpdwJobId); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpdwlMessageId {out} (1:{alias=PDWORDLONG}*(1))(2:{alias=DWORDLONG, names=ULONGLONG}(uint64))
	{
		if err := w.WriteData(o.MessageID); err != nil {
			return err
		}
	}
	// lpdwlRecipientMessageIds {out} (1:{alias=PDWORDLONG}*(1))(2:{alias=DWORDLONG, names=ULONGLONG}[dim:0,size_is=dwNumRecipients](uint64))
	{
		dimSize1 := uint64(o.RecipientsLength)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.RecipientMessageIDs {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.RecipientMessageIDs[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.RecipientMessageIDs); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint64(0)); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SendDocumentExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpdwJobId {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_lpdwJobId := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.JobID); err != nil {
				return err
			}
			return nil
		})
		_s_lpdwJobId := func(ptr interface{}) { o.JobID = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.JobID, _s_lpdwJobId, _ptr_lpdwJobId); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpdwlMessageId {out} (1:{alias=PDWORDLONG,pointer=ref}*(1))(2:{alias=DWORDLONG, names=ULONGLONG}(uint64))
	{
		if err := w.ReadData(&o.MessageID); err != nil {
			return err
		}
	}
	// lpdwlRecipientMessageIds {out} (1:{alias=PDWORDLONG,pointer=ref}*(1))(2:{alias=DWORDLONG, names=ULONGLONG}[dim:0,size_is=dwNumRecipients](uint64))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.RecipientMessageIDs", sizeInfo[0])
		}
		o.RecipientMessageIDs = make([]uint64, sizeInfo[0])
		for i1 := range o.RecipientMessageIDs {
			i1 := i1
			if err := w.ReadData(&o.RecipientMessageIDs[i1]); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SendDocumentExRequest structure represents the FAX_SendDocumentEx operation request
type SendDocumentExRequest struct {
	// lpcwstrFileName: A pointer to a null-terminated character string that contains the
	// name of the file, without path information, of the body of the fax in TIFF. The body
	// file is previously copied to the server queue directory using the call sequence of
	// FAX_StartCopyToServer (section 3.1.4.1.97) to retrieve the file name from the server,
	// FAX_WriteFile (section 3.1.4.1.105) to write to the file, and FAX_EndCopy (section
	// 3.1.4.1.15) to end the write operation. If no fax body is available, this pointer
	// MUST be NULL.
	FileName string `idl:"name:lpcwstrFileName;string;pointer:unique" json:"file_name"`
	// lpcCoverPageInfo: A pointer to a FAX_COVERPAGE_INFO_EXW (section 2.2.12) structure
	// that contains the cover-page information, including the name of the cover-page file
	// obtained from the fax server with the FAX_StartCopyToServer call, if available. This
	// pointer MUST NOT be NULL. If no cover-page information is available, the lpwstrCoverPageFileName
	// member of the structure MUST be NULL. If cover-page information is specified, the
	// fax server SHOULD use the server queue directory to find the cover page. The fax
	// client can add a new personal cover page template to the server queue directory before
	// calling this method by using the call sequence of FAX_StartCopyToServer to retrieve
	// the file name from the server, FAX_WriteFile to write to the file, and FAX_EndCopy
	// to end the write operation. If this call sequence was used, the client SHOULD set
	// the bServerBased member of the structure to FALSE; otherwise the client MUST set
	// the bServerBased member to TRUE. If bServerBased is FALSE, the server SHOULD validate
	// that the cover page template specified by the lpwstrCoverPageFileName member has
	// a file extension of ".cov" and the file name string contains (except for the terminating
	// null character) only characters representing valid hexadecimal digits: "0123456789abcdefABCDEF".
	CoverPageInfo *fax.CoverPageInfoExW `idl:"name:lpcCoverPageInfo" json:"cover_page_info"`
	// lpcSenderProfile: A pointer to a buffer containing an array of FAX_PERSONAL_PROFILEW
	// (section 2.2.44) structures that contain the personal profile (section 3.1.1) of
	// the fax sender. This pointer MUST NOT be NULL.
	SenderProfile []byte `idl:"name:lpcSenderProfile" json:"sender_profile"`
	// dwNumRecipients: A DWORD ([MS-DTYP] section 2.2.9) that contains the number of recipients
	// of the fax.
	RecipientsLength uint32 `idl:"name:dwNumRecipients" json:"recipients_length"`
	// lpcRecipientList: A pointer to an array FAX_PERSONAL_PROFILEW that contains the personal
	// profiles of the recipients of the fax. The dwNumRecipients member specifies the number
	// of elements in this array.
	RecipientList []byte `idl:"name:lpcRecipientList;size_is:(, dwNumRecipients)" json:"recipient_list"`
	// lpJobParams: A pointer to a FAX_JOB_PARAM_EXW (section 2.2.14) structure that contains
	// the information necessary for the fax server to send the fax transmission.
	JobParams *fax.JobParamExW `idl:"name:lpJobParams" json:"job_params"`
	// lpdwJobId: An optional pointer to a DWORD to return the job identifier. This parameter
	// is used for backward compatibility with FaxObs_SendDocument (section 3.1.4.2.7).
	// The fax server MUST ignore this argument if the fax client submits a NULL pointer
	// value when making the call.
	JobID uint32 `idl:"name:lpdwJobId;pointer:unique" json:"job_id"`
}

func (o *SendDocumentExRequest) xxx_ToOp(ctx context.Context, op *xxx_SendDocumentExOperation) *xxx_SendDocumentExOperation {
	if op == nil {
		op = &xxx_SendDocumentExOperation{}
	}
	if o == nil {
		return op
	}
	op.FileName = o.FileName
	op.CoverPageInfo = o.CoverPageInfo
	op.SenderProfile = o.SenderProfile
	op.RecipientsLength = o.RecipientsLength
	op.RecipientList = o.RecipientList
	op.JobParams = o.JobParams
	op.JobID = o.JobID
	return op
}

func (o *SendDocumentExRequest) xxx_FromOp(ctx context.Context, op *xxx_SendDocumentExOperation) {
	if o == nil {
		return
	}
	o.FileName = op.FileName
	o.CoverPageInfo = op.CoverPageInfo
	o.SenderProfile = op.SenderProfile
	o.RecipientsLength = op.RecipientsLength
	o.RecipientList = op.RecipientList
	o.JobParams = op.JobParams
	o.JobID = op.JobID
}
func (o *SendDocumentExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SendDocumentExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SendDocumentExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SendDocumentExResponse structure represents the FAX_SendDocumentEx operation response
type SendDocumentExResponse struct {
	// XXX: dwNumRecipients is an implicit input depedency for output parameters
	RecipientsLength uint32 `idl:"name:dwNumRecipients" json:"recipients_length"`

	// lpdwJobId: An optional pointer to a DWORD to return the job identifier. This parameter
	// is used for backward compatibility with FaxObs_SendDocument (section 3.1.4.2.7).
	// The fax server MUST ignore this argument if the fax client submits a NULL pointer
	// value when making the call.
	JobID uint32 `idl:"name:lpdwJobId;pointer:unique" json:"job_id"`
	// lpdwlMessageId: A pointer to a DWORDLONG ([MS-DTYP] section 2.2.13) that returns
	// the unique message identifier that represents the fax message to be sent to all recipients.
	MessageID uint64 `idl:"name:lpdwlMessageId" json:"message_id"`
	// lpdwlRecipientMessageIds: A pointer to a DWORDLONG array in which the server returns
	// the unique message identifier for each individual recipient. The number of elements
	// in this array SHOULD be at least equal to the value specified in the dwNumRecipients
	// member. The elements in the array SHOULD be ordered in the same order as the elements
	// of the lpcRecipientList array.
	RecipientMessageIDs []uint64 `idl:"name:lpdwlRecipientMessageIds;size_is:(dwNumRecipients)" json:"recipient_message_ids"`
	// Return: The FAX_SendDocumentEx return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SendDocumentExResponse) xxx_ToOp(ctx context.Context, op *xxx_SendDocumentExOperation) *xxx_SendDocumentExOperation {
	if op == nil {
		op = &xxx_SendDocumentExOperation{}
	}
	if o == nil {
		return op
	}
	// XXX: implicit input dependencies for output parameters
	if op.RecipientsLength == uint32(0) {
		op.RecipientsLength = o.RecipientsLength
	}

	op.JobID = o.JobID
	op.MessageID = o.MessageID
	op.RecipientMessageIDs = o.RecipientMessageIDs
	op.Return = o.Return
	return op
}

func (o *SendDocumentExResponse) xxx_FromOp(ctx context.Context, op *xxx_SendDocumentExOperation) {
	if o == nil {
		return
	}
	// XXX: implicit input dependencies for output parameters
	o.RecipientsLength = op.RecipientsLength

	o.JobID = op.JobID
	o.MessageID = op.MessageID
	o.RecipientMessageIDs = op.RecipientMessageIDs
	o.Return = op.Return
}
func (o *SendDocumentExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SendDocumentExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SendDocumentExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumJobsExOperation structure represents the FAX_EnumJobsEx operation
type xxx_EnumJobsExOperation struct {
	JobTypes   uint32 `idl:"name:dwJobTypes" json:"job_types"`
	Buffer     []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	BufferSize uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	Jobs       uint32 `idl:"name:lpdwJobs;pointer:ref" json:"jobs"`
	Return     uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumJobsExOperation) OpNum() int { return 28 }

func (o *xxx_EnumJobsExOperation) OpName() string { return "/fax/v4/FAX_EnumJobsEx" }

func (o *xxx_EnumJobsExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumJobsExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// dwJobTypes {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.JobTypes); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumJobsExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// dwJobTypes {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.JobTypes); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumJobsExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Buffer != nil && o.BufferSize == 0 {
		o.BufferSize = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumJobsExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		if o.Buffer != nil || o.BufferSize > 0 {
			_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.BufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Buffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Buffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	// lpdwJobs {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Jobs); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumJobsExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE,pointer=ref}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
			}
			o.Buffer = make([]byte, sizeInfo[0])
			for i1 := range o.Buffer {
				i1 := i1
				if err := w.ReadData(&o.Buffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	// lpdwJobs {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Jobs); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumJobsExRequest structure represents the FAX_EnumJobsEx operation request
type EnumJobsExRequest struct {
	// dwJobTypes: A DWORD ([MS-DTYP] section 2.2.9) value. The dwJobTypes parameter SHOULD
	// be a bitwise combination of job types defined in section 3.1.1. Only jobs that are
	// of the requested types SHOULD be returned in the buffer. If zero is passed as a value
	// for the parameter (0 is not a valid job type), the server will return success, but
	// with a zero-byte buffer.
	JobTypes uint32 `idl:"name:dwJobTypes" json:"job_types"`
}

func (o *EnumJobsExRequest) xxx_ToOp(ctx context.Context, op *xxx_EnumJobsExOperation) *xxx_EnumJobsExOperation {
	if op == nil {
		op = &xxx_EnumJobsExOperation{}
	}
	if o == nil {
		return op
	}
	op.JobTypes = o.JobTypes
	return op
}

func (o *EnumJobsExRequest) xxx_FromOp(ctx context.Context, op *xxx_EnumJobsExOperation) {
	if o == nil {
		return
	}
	o.JobTypes = op.JobTypes
}
func (o *EnumJobsExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumJobsExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumJobsExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumJobsExResponse structure represents the FAX_EnumJobsEx operation response
type EnumJobsExResponse struct {
	// Buffer: A pointer to the address of a buffer to receive an array of FAX_JOB_ENTRY_EXW
	// (section 2.2.35) structures followed by an array of the same number of FAX_JOB_STATUS
	// (section 2.2.36) structures, followed by other data pointed at from these structures
	// (from pointer type fields). Each FAX_JOB_ENTRY_EXW and FAX_JOB_STATUS pair describes
	// one fax job. For each returned FAX_JOB_ENTRY_EXW, if the pStatus pointer is not NULL,
	// it MUST point to one of the FAX_JOB_STATUS in the buffer. If the pStatus pointer
	// is NULL, the FAX_JOB_STATUS attached to the current FAX_JOB_ENTRY_EXW is located
	// at the corresponding index position in the structure array. This data is serialized
	// on the wire. The field length MUST be clamped to 32 bits before serialization.
	//
	// For example, when three jobs are successfully enumerated, the call returns ERROR_SUCCESS
	// with a value of 3 for the *lpdwJobs output argument. The returned data is arranged
	// in memory as follows, from the start of the address specified by the Buffer parameter:
	//
	//	+-------------------+--------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	|       DATA        |                                                                          |                                                                                  |
	//	|     STRUCTURE     |                                   SIZE                                   |                                   DESCRIPTION                                    |
	//	|                   |                                                                          |                                                                                  |
	//	+-------------------+--------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	+-------------------+--------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_JOB_ENTRY_EXW | sizeof(FAX_JOB_ENTRY_EXW)                                                | The first FAX_JOB_ENTRY_EXW in the buffer, corresponding to the first            |
	//	|                   |                                                                          | FAX_JOB_STATUS in the buffer if pStatus is NULL in this FAX_JOB_ENTRY_EXW.       |
	//	+-------------------+--------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_JOB_ENTRY_EXW | sizeof(FAX_JOB_ENTRY_EXW)                                                | The second FAX_JOB_ENTRY_EXW in the buffer, corresponding to the second          |
	//	|                   |                                                                          | FAX_JOB_STATUS in the buffer if pStatus is NULL in this FAX_JOB_ENTRY_EXW.       |
	//	+-------------------+--------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_JOB_ENTRY_EXW | sizeof(FAX_JOB_ENTRY_EXW)                                                | The third FAX_JOB_ENTRY_EXW in the buffer, corresponding to the third            |
	//	|                   |                                                                          | FAX_JOB_STATUS in the buffer if pStatus is NULL in this FAX_JOB_ENTRY_EXW.       |
	//	+-------------------+--------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_JOB_STATUS    | sizeof(FAX_JOB_STATUS)                                                   | The first FAX_JOB_STATUS in the buffer, corresponding to the first               |
	//	|                   |                                                                          | FAX_JOB_ENTRY_EXW in the buffer if pStatus is NULL in this FAX_JOB_ENTRY_EXW.    |
	//	+-------------------+--------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_JOB_STATUS    | sizeof(FAX_JOB_STATUS)                                                   | The second FAX_JOB_STATUS in the buffer, corresponding to the second             |
	//	|                   |                                                                          | FAX_JOB_ENTRY_EXW in the buffer if pStatus is NULL in this FAX_JOB_ENTRY_EXW.    |
	//	+-------------------+--------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_JOB_STATUS    | sizeof(FAX_JOB_STATUS)                                                   | The third FAX_JOB_STATUS in the buffer, corresponding to the third               |
	//	|                   |                                                                          | FAX_JOB_ENTRY_EXW in the buffer if pStatus is NULL in this FAX_JOB_ENTRY_EXW.    |
	//	+-------------------+--------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| Other data        | *BufferSize – (3 * (sizeof(FAX_JOB_ENTRY_EXW) + sizeof(FAX_JOB_STATUS))) | Data pointed at by pointer fields in FAX_JOB_ENTRY_EXW and FAX_JOB_STATUS at the |
	//	|                   |                                                                          | beginning of the buffer.                                                         |
	//	+-------------------+--------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	Buffer []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	// BufferSize: A variable to return the size, in bytes, of the buffer.
	BufferSize uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	// lpdwJobs: A pointer to a DWORD ([MS-DTYP] section 2.2.9) variable to receive the
	// number of FAX_JOB_ENTRY_EXW and FAX_JOB_STATUS that the method returns in the Buffer
	// parameter.
	Jobs uint32 `idl:"name:lpdwJobs;pointer:ref" json:"jobs"`
	// Return: The FAX_EnumJobsEx return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumJobsExResponse) xxx_ToOp(ctx context.Context, op *xxx_EnumJobsExOperation) *xxx_EnumJobsExOperation {
	if op == nil {
		op = &xxx_EnumJobsExOperation{}
	}
	if o == nil {
		return op
	}
	op.Buffer = o.Buffer
	op.BufferSize = o.BufferSize
	op.Jobs = o.Jobs
	op.Return = o.Return
	return op
}

func (o *EnumJobsExResponse) xxx_FromOp(ctx context.Context, op *xxx_EnumJobsExOperation) {
	if o == nil {
		return
	}
	o.Buffer = op.Buffer
	o.BufferSize = op.BufferSize
	o.Jobs = op.Jobs
	o.Return = op.Return
}
func (o *EnumJobsExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumJobsExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumJobsExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetJobExOperation structure represents the FAX_GetJobEx operation
type xxx_GetJobExOperation struct {
	MessageID  uint64 `idl:"name:dwlMessageID" json:"message_id"`
	Buffer     []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	BufferSize uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	Return     uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetJobExOperation) OpNum() int { return 29 }

func (o *xxx_GetJobExOperation) OpName() string { return "/fax/v4/FAX_GetJobEx" }

func (o *xxx_GetJobExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetJobExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// dwlMessageID {in} (1:{alias=DWORDLONG, names=ULONGLONG}(uint64))
	{
		if err := w.WriteData(o.MessageID); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetJobExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// dwlMessageID {in} (1:{alias=DWORDLONG, names=ULONGLONG}(uint64))
	{
		if err := w.ReadData(&o.MessageID); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetJobExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Buffer != nil && o.BufferSize == 0 {
		o.BufferSize = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetJobExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		if o.Buffer != nil || o.BufferSize > 0 {
			_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.BufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Buffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Buffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetJobExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE,pointer=ref}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
			}
			o.Buffer = make([]byte, sizeInfo[0])
			for i1 := range o.Buffer {
				i1 := i1
				if err := w.ReadData(&o.Buffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetJobExRequest structure represents the FAX_GetJobEx operation request
type GetJobExRequest struct {
	// dwlMessageID: A unique number that identifies a queued or active fax job. The job
	// MUST be an inbound or outbound transmission.
	MessageID uint64 `idl:"name:dwlMessageID" json:"message_id"`
}

func (o *GetJobExRequest) xxx_ToOp(ctx context.Context, op *xxx_GetJobExOperation) *xxx_GetJobExOperation {
	if op == nil {
		op = &xxx_GetJobExOperation{}
	}
	if o == nil {
		return op
	}
	op.MessageID = o.MessageID
	return op
}

func (o *GetJobExRequest) xxx_FromOp(ctx context.Context, op *xxx_GetJobExOperation) {
	if o == nil {
		return
	}
	o.MessageID = op.MessageID
}
func (o *GetJobExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetJobExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetJobExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetJobExResponse structure represents the FAX_GetJobEx operation response
type GetJobExResponse struct {
	// Buffer: A pointer to the address of a buffer to receive one FAX_JOB_ENTRY_EXW followed
	// by one FAX_JOB_STATUS (section 2.2.36) structure, followed by other data pointed
	// at from these two structures (from pointer type fields). These two data structures
	// describe one fax job. If the pStatus pointer field of the FAX_JOB_ENTRY_EXW is not
	// NULL, it MUST point to the address of the FAX_JOB_STATUS in the buffer. If the pStatus
	// pointer is NULL, the FAX_JOB_STATUS is located in the buffer immediately after the
	// FAX_JOB_ENTRY_EXW. The field length MUST be clamped to 32 bits before serialization.
	Buffer []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	// BufferSize: A variable to return the size, in bytes, of the buffer.
	BufferSize uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	// Return: The FAX_GetJobEx return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetJobExResponse) xxx_ToOp(ctx context.Context, op *xxx_GetJobExOperation) *xxx_GetJobExOperation {
	if op == nil {
		op = &xxx_GetJobExOperation{}
	}
	if o == nil {
		return op
	}
	op.Buffer = o.Buffer
	op.BufferSize = o.BufferSize
	op.Return = o.Return
	return op
}

func (o *GetJobExResponse) xxx_FromOp(ctx context.Context, op *xxx_GetJobExOperation) {
	if o == nil {
		return
	}
	o.Buffer = op.Buffer
	o.BufferSize = op.BufferSize
	o.Return = op.Return
}
func (o *GetJobExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetJobExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetJobExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetCountryListOperation structure represents the FAX_GetCountryList operation
type xxx_GetCountryListOperation struct {
	Buffer     []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	BufferSize uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	Return     uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetCountryListOperation) OpNum() int { return 30 }

func (o *xxx_GetCountryListOperation) OpName() string { return "/fax/v4/FAX_GetCountryList" }

func (o *xxx_GetCountryListOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetCountryListOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	return nil
}

func (o *xxx_GetCountryListOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	return nil
}

func (o *xxx_GetCountryListOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Buffer != nil && o.BufferSize == 0 {
		o.BufferSize = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetCountryListOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		if o.Buffer != nil || o.BufferSize > 0 {
			_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.BufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Buffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Buffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetCountryListOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE,pointer=ref}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
			}
			o.Buffer = make([]byte, sizeInfo[0])
			for i1 := range o.Buffer {
				i1 := i1
				if err := w.ReadData(&o.Buffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetCountryListRequest structure represents the FAX_GetCountryList operation request
type GetCountryListRequest struct {
}

func (o *GetCountryListRequest) xxx_ToOp(ctx context.Context, op *xxx_GetCountryListOperation) *xxx_GetCountryListOperation {
	if op == nil {
		op = &xxx_GetCountryListOperation{}
	}
	if o == nil {
		return op
	}
	return op
}

func (o *GetCountryListRequest) xxx_FromOp(ctx context.Context, op *xxx_GetCountryListOperation) {
	if o == nil {
		return
	}
}
func (o *GetCountryListRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetCountryListRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetCountryListOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetCountryListResponse structure represents the FAX_GetCountryList operation response
type GetCountryListResponse struct {
	// Buffer: A pointer to a buffer of type FAX_TAPI_LINECOUNTRY_LISTW (section 2.2.51)
	// in which to place the country/region information.
	Buffer []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	// BufferSize: A pointer to a DWORD ([MS-DTYP] section 2.2.9) in which to return the
	// size, in bytes, of the buffer.
	BufferSize uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	// Return: The FAX_GetCountryList return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetCountryListResponse) xxx_ToOp(ctx context.Context, op *xxx_GetCountryListOperation) *xxx_GetCountryListOperation {
	if op == nil {
		op = &xxx_GetCountryListOperation{}
	}
	if o == nil {
		return op
	}
	op.Buffer = o.Buffer
	op.BufferSize = o.BufferSize
	op.Return = o.Return
	return op
}

func (o *GetCountryListResponse) xxx_FromOp(ctx context.Context, op *xxx_GetCountryListOperation) {
	if o == nil {
		return
	}
	o.Buffer = op.Buffer
	o.BufferSize = op.BufferSize
	o.Return = op.Return
}
func (o *GetCountryListResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetCountryListResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetCountryListOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetPersonalProfileInfoOperation structure represents the FAX_GetPersonalProfileInfo operation
type xxx_GetPersonalProfileInfoOperation struct {
	MessageID  uint64                   `idl:"name:dwlMessageId" json:"message_id"`
	Folder     fax.MessageFolder        `idl:"name:dwFolder" json:"folder"`
	ProfType   fax.PersonalProfileTypes `idl:"name:ProfType" json:"prof_type"`
	Buffer     []byte                   `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	BufferSize uint32                   `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	Return     uint32                   `idl:"name:Return" json:"return"`
}

func (o *xxx_GetPersonalProfileInfoOperation) OpNum() int { return 31 }

func (o *xxx_GetPersonalProfileInfoOperation) OpName() string {
	return "/fax/v4/FAX_GetPersonalProfileInfo"
}

func (o *xxx_GetPersonalProfileInfoOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetPersonalProfileInfoOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// dwlMessageId {in} (1:{alias=DWORDLONG, names=ULONGLONG}(uint64))
	{
		if err := w.WriteData(o.MessageID); err != nil {
			return err
		}
	}
	// dwFolder {in} (1:{alias=FAX_ENUM_MESSAGE_FOLDER}(enum))
	{
		if err := w.WriteEnum(uint16(o.Folder)); err != nil {
			return err
		}
	}
	// ProfType {in} (1:{alias=FAX_ENUM_PERSONAL_PROF_TYPES}(enum))
	{
		if err := w.WriteEnum(uint16(o.ProfType)); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetPersonalProfileInfoOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// dwlMessageId {in} (1:{alias=DWORDLONG, names=ULONGLONG}(uint64))
	{
		if err := w.ReadData(&o.MessageID); err != nil {
			return err
		}
	}
	// dwFolder {in} (1:{alias=FAX_ENUM_MESSAGE_FOLDER}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.Folder)); err != nil {
			return err
		}
	}
	// ProfType {in} (1:{alias=FAX_ENUM_PERSONAL_PROF_TYPES}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.ProfType)); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetPersonalProfileInfoOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Buffer != nil && o.BufferSize == 0 {
		o.BufferSize = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetPersonalProfileInfoOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		if o.Buffer != nil || o.BufferSize > 0 {
			_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.BufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Buffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Buffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetPersonalProfileInfoOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE,pointer=ref}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
			}
			o.Buffer = make([]byte, sizeInfo[0])
			for i1 := range o.Buffer {
				i1 := i1
				if err := w.ReadData(&o.Buffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetPersonalProfileInfoRequest structure represents the FAX_GetPersonalProfileInfo operation request
type GetPersonalProfileInfoRequest struct {
	// dwlMessageId: A DWORDLONG ([MS-DTYP] section 2.2.13) that contains the message identifier
	// for which the sender's FAX_PERSONAL_PROFILEW (section 2.2.44) structure is retrieved.
	MessageID uint64 `idl:"name:dwlMessageId" json:"message_id"`
	// dwFolder: A FAX_ENUM_MESSAGE_FOLDER indicating the location of the folder in which
	// to search for the message containing the personal profile information.
	Folder fax.MessageFolder `idl:"name:dwFolder" json:"folder"`
	// ProfType: A FAX_ENUM_PERSONAL_PROF_TYPES indicating whether to retrieve sender or
	// recipient personal profile information.
	ProfType fax.PersonalProfileTypes `idl:"name:ProfType" json:"prof_type"`
}

func (o *GetPersonalProfileInfoRequest) xxx_ToOp(ctx context.Context, op *xxx_GetPersonalProfileInfoOperation) *xxx_GetPersonalProfileInfoOperation {
	if op == nil {
		op = &xxx_GetPersonalProfileInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.MessageID = o.MessageID
	op.Folder = o.Folder
	op.ProfType = o.ProfType
	return op
}

func (o *GetPersonalProfileInfoRequest) xxx_FromOp(ctx context.Context, op *xxx_GetPersonalProfileInfoOperation) {
	if o == nil {
		return
	}
	o.MessageID = op.MessageID
	o.Folder = op.Folder
	o.ProfType = op.ProfType
}
func (o *GetPersonalProfileInfoRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetPersonalProfileInfoRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetPersonalProfileInfoOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetPersonalProfileInfoResponse structure represents the FAX_GetPersonalProfileInfo operation response
type GetPersonalProfileInfoResponse struct {
	// Buffer:  A pointer to a FAX_PERSONAL_PROFILEW in which to place the returned recipient
	// or sender personal profile information.
	Buffer []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	// BufferSize: A pointer to a DWORD ([MS-DTYP] section 2.2.9) variable to receive the
	// buffer size.
	BufferSize uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	// Return: The FAX_GetPersonalProfileInfo return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetPersonalProfileInfoResponse) xxx_ToOp(ctx context.Context, op *xxx_GetPersonalProfileInfoOperation) *xxx_GetPersonalProfileInfoOperation {
	if op == nil {
		op = &xxx_GetPersonalProfileInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.Buffer = o.Buffer
	op.BufferSize = o.BufferSize
	op.Return = o.Return
	return op
}

func (o *GetPersonalProfileInfoResponse) xxx_FromOp(ctx context.Context, op *xxx_GetPersonalProfileInfoOperation) {
	if o == nil {
		return
	}
	o.Buffer = op.Buffer
	o.BufferSize = op.BufferSize
	o.Return = op.Return
}
func (o *GetPersonalProfileInfoResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetPersonalProfileInfoResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetPersonalProfileInfoOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetQueueStatesOperation structure represents the FAX_GetQueueStates operation
type xxx_GetQueueStatesOperation struct {
	QueueStates uint32 `idl:"name:pdwQueueStates" json:"queue_states"`
	Return      uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetQueueStatesOperation) OpNum() int { return 32 }

func (o *xxx_GetQueueStatesOperation) OpName() string { return "/fax/v4/FAX_GetQueueStates" }

func (o *xxx_GetQueueStatesOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetQueueStatesOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	return nil
}

func (o *xxx_GetQueueStatesOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	return nil
}

func (o *xxx_GetQueueStatesOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetQueueStatesOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwQueueStates {out} (1:{alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.QueueStates); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetQueueStatesOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwQueueStates {out} (1:{alias=LPDWORD,pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.QueueStates); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetQueueStatesRequest structure represents the FAX_GetQueueStates operation request
type GetQueueStatesRequest struct {
}

func (o *GetQueueStatesRequest) xxx_ToOp(ctx context.Context, op *xxx_GetQueueStatesOperation) *xxx_GetQueueStatesOperation {
	if op == nil {
		op = &xxx_GetQueueStatesOperation{}
	}
	if o == nil {
		return op
	}
	return op
}

func (o *GetQueueStatesRequest) xxx_FromOp(ctx context.Context, op *xxx_GetQueueStatesOperation) {
	if o == nil {
		return
	}
}
func (o *GetQueueStatesRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetQueueStatesRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetQueueStatesOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetQueueStatesResponse structure represents the FAX_GetQueueStates operation response
type GetQueueStatesResponse struct {
	// pdwQueueStates: A pointer to a DWORD ([MS-DTYP] section 2.2.9) value that receives
	// state information about the fax queue. If this value is zero, both the incoming and
	// outgoing queues are unblocked. Otherwise, this value is a combination of one or more
	// of the following values.
	//
	//	+---------------------------------+--------------------------------------------------------------------------------+
	//	|                                 |                                                                                |
	//	|           VALUE/CODE            |                                    MEANING                                     |
	//	|                                 |                                                                                |
	//	+---------------------------------+--------------------------------------------------------------------------------+
	//	+---------------------------------+--------------------------------------------------------------------------------+
	//	| 0x00000000                      | Both the incoming and outgoing queues are unblocked.                           |
	//	+---------------------------------+--------------------------------------------------------------------------------+
	//	| FAX_INCOMING_BLOCKED 0x00000001 | The fax service will not receive new incoming faxes.                           |
	//	+---------------------------------+--------------------------------------------------------------------------------+
	//	| FAX_OUTBOX_BLOCKED 0x00000002   | The fax service will reject submissions of new outgoing faxes to its queue.    |
	//	+---------------------------------+--------------------------------------------------------------------------------+
	//	| FAX_OUTBOX_PAUSED 0x00000004    | The fax service will not dequeue and execute outgoing fax jobs from its queue. |
	//	+---------------------------------+--------------------------------------------------------------------------------+
	QueueStates uint32 `idl:"name:pdwQueueStates" json:"queue_states"`
	// Return: The FAX_GetQueueStates return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetQueueStatesResponse) xxx_ToOp(ctx context.Context, op *xxx_GetQueueStatesOperation) *xxx_GetQueueStatesOperation {
	if op == nil {
		op = &xxx_GetQueueStatesOperation{}
	}
	if o == nil {
		return op
	}
	op.QueueStates = o.QueueStates
	op.Return = o.Return
	return op
}

func (o *GetQueueStatesResponse) xxx_FromOp(ctx context.Context, op *xxx_GetQueueStatesOperation) {
	if o == nil {
		return
	}
	o.QueueStates = op.QueueStates
	o.Return = op.Return
}
func (o *GetQueueStatesResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetQueueStatesResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetQueueStatesOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetQueueOperation structure represents the FAX_SetQueue operation
type xxx_SetQueueOperation struct {
	QueueStates uint32 `idl:"name:dwQueueStates" json:"queue_states"`
	Return      uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_SetQueueOperation) OpNum() int { return 33 }

func (o *xxx_SetQueueOperation) OpName() string { return "/fax/v4/FAX_SetQueue" }

func (o *xxx_SetQueueOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetQueueOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// dwQueueStates {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.QueueStates); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetQueueOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// dwQueueStates {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.QueueStates); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetQueueOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetQueueOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetQueueOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetQueueRequest structure represents the FAX_SetQueue operation request
type SetQueueRequest struct {
	// dwQueueStates: A pointer to a DWORD ([MS-DTYP] section 2.2.9) value that contains
	// state information about the fax queue. If this value is zero, both the incoming and
	// outgoing queues are unblocked. Otherwise, this value is a combination of one or more
	// of the following values.
	//
	//	+---------------------------------+--------------------------------------------------------------------------------+
	//	|                                 |                                                                                |
	//	|           VALUE/CODE            |                                    MEANING                                     |
	//	|                                 |                                                                                |
	//	+---------------------------------+--------------------------------------------------------------------------------+
	//	+---------------------------------+--------------------------------------------------------------------------------+
	//	| FAX_INCOMING_BLOCKED 0x00000001 | The fax service will not receive new incoming faxes.                           |
	//	+---------------------------------+--------------------------------------------------------------------------------+
	//	| FAX_OUTBOX_BLOCKED 0x00000002   | The fax service will reject submissions of new outgoing faxes to its queue.    |
	//	+---------------------------------+--------------------------------------------------------------------------------+
	//	| FAX_OUTBOX_PAUSED 0x00000004    | The fax service will not dequeue and execute outgoing fax jobs from its queue. |
	//	+---------------------------------+--------------------------------------------------------------------------------+
	QueueStates uint32 `idl:"name:dwQueueStates" json:"queue_states"`
}

func (o *SetQueueRequest) xxx_ToOp(ctx context.Context, op *xxx_SetQueueOperation) *xxx_SetQueueOperation {
	if op == nil {
		op = &xxx_SetQueueOperation{}
	}
	if o == nil {
		return op
	}
	op.QueueStates = o.QueueStates
	return op
}

func (o *SetQueueRequest) xxx_FromOp(ctx context.Context, op *xxx_SetQueueOperation) {
	if o == nil {
		return
	}
	o.QueueStates = op.QueueStates
}
func (o *SetQueueRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetQueueRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetQueueOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetQueueResponse structure represents the FAX_SetQueue operation response
type SetQueueResponse struct {
	// Return: The FAX_SetQueue return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetQueueResponse) xxx_ToOp(ctx context.Context, op *xxx_SetQueueOperation) *xxx_SetQueueOperation {
	if op == nil {
		op = &xxx_SetQueueOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetQueueResponse) xxx_FromOp(ctx context.Context, op *xxx_SetQueueOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetQueueResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetQueueResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetQueueOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetReceiptsConfigurationOperation structure represents the FAX_GetReceiptsConfiguration operation
type xxx_GetReceiptsConfigurationOperation struct {
	Buffer     []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	BufferSize uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	Return     uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetReceiptsConfigurationOperation) OpNum() int { return 34 }

func (o *xxx_GetReceiptsConfigurationOperation) OpName() string {
	return "/fax/v4/FAX_GetReceiptsConfiguration"
}

func (o *xxx_GetReceiptsConfigurationOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetReceiptsConfigurationOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	return nil
}

func (o *xxx_GetReceiptsConfigurationOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	return nil
}

func (o *xxx_GetReceiptsConfigurationOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Buffer != nil && o.BufferSize == 0 {
		o.BufferSize = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetReceiptsConfigurationOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		if o.Buffer != nil || o.BufferSize > 0 {
			_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.BufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Buffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Buffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetReceiptsConfigurationOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE,pointer=ref}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
			}
			o.Buffer = make([]byte, sizeInfo[0])
			for i1 := range o.Buffer {
				i1 := i1
				if err := w.ReadData(&o.Buffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetReceiptsConfigurationRequest structure represents the FAX_GetReceiptsConfiguration operation request
type GetReceiptsConfigurationRequest struct {
}

func (o *GetReceiptsConfigurationRequest) xxx_ToOp(ctx context.Context, op *xxx_GetReceiptsConfigurationOperation) *xxx_GetReceiptsConfigurationOperation {
	if op == nil {
		op = &xxx_GetReceiptsConfigurationOperation{}
	}
	if o == nil {
		return op
	}
	return op
}

func (o *GetReceiptsConfigurationRequest) xxx_FromOp(ctx context.Context, op *xxx_GetReceiptsConfigurationOperation) {
	if o == nil {
		return
	}
}
func (o *GetReceiptsConfigurationRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetReceiptsConfigurationRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetReceiptsConfigurationOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetReceiptsConfigurationResponse structure represents the FAX_GetReceiptsConfiguration operation response
type GetReceiptsConfigurationResponse struct {
	// Buffer: A pointer to a _FAX_RECEIPTS_CONFIGW (section 2.2.48) structure.
	Buffer []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	// BufferSize: A pointer to a DWORD ([MS-DTYP] section 2.2.9) in which to return the
	// size, in bytes, of the buffer.
	BufferSize uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	// Return: The FAX_GetReceiptsConfiguration return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetReceiptsConfigurationResponse) xxx_ToOp(ctx context.Context, op *xxx_GetReceiptsConfigurationOperation) *xxx_GetReceiptsConfigurationOperation {
	if op == nil {
		op = &xxx_GetReceiptsConfigurationOperation{}
	}
	if o == nil {
		return op
	}
	op.Buffer = o.Buffer
	op.BufferSize = o.BufferSize
	op.Return = o.Return
	return op
}

func (o *GetReceiptsConfigurationResponse) xxx_FromOp(ctx context.Context, op *xxx_GetReceiptsConfigurationOperation) {
	if o == nil {
		return
	}
	o.Buffer = op.Buffer
	o.BufferSize = op.BufferSize
	o.Return = op.Return
}
func (o *GetReceiptsConfigurationResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetReceiptsConfigurationResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetReceiptsConfigurationOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetReceiptsConfigurationOperation structure represents the FAX_SetReceiptsConfiguration operation
type xxx_SetReceiptsConfigurationOperation struct {
	Receipts *fax.ReceiptsConfigW `idl:"name:pReceipts;pointer:ref" json:"receipts"`
	Return   uint32               `idl:"name:Return" json:"return"`
}

func (o *xxx_SetReceiptsConfigurationOperation) OpNum() int { return 35 }

func (o *xxx_SetReceiptsConfigurationOperation) OpName() string {
	return "/fax/v4/FAX_SetReceiptsConfiguration"
}

func (o *xxx_SetReceiptsConfigurationOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetReceiptsConfigurationOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// pReceipts {in} (1:{pointer=ref, alias=PFAX_RECEIPTS_CONFIGW}*(1))(2:{alias=FAX_RECEIPTS_CONFIGW}(struct))
	{
		if o.Receipts != nil {
			if err := o.Receipts.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.ReceiptsConfigW{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetReceiptsConfigurationOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// pReceipts {in} (1:{pointer=ref, alias=PFAX_RECEIPTS_CONFIGW}*(1))(2:{alias=FAX_RECEIPTS_CONFIGW}(struct))
	{
		if o.Receipts == nil {
			o.Receipts = &fax.ReceiptsConfigW{}
		}
		if err := o.Receipts.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetReceiptsConfigurationOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetReceiptsConfigurationOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetReceiptsConfigurationOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetReceiptsConfigurationRequest structure represents the FAX_SetReceiptsConfiguration operation request
type SetReceiptsConfigurationRequest struct {
	// pReceipts: A pointer to a FAX_RECEIPTS_CONFIGW (section 2.2.47) object.
	Receipts *fax.ReceiptsConfigW `idl:"name:pReceipts;pointer:ref" json:"receipts"`
}

func (o *SetReceiptsConfigurationRequest) xxx_ToOp(ctx context.Context, op *xxx_SetReceiptsConfigurationOperation) *xxx_SetReceiptsConfigurationOperation {
	if op == nil {
		op = &xxx_SetReceiptsConfigurationOperation{}
	}
	if o == nil {
		return op
	}
	op.Receipts = o.Receipts
	return op
}

func (o *SetReceiptsConfigurationRequest) xxx_FromOp(ctx context.Context, op *xxx_SetReceiptsConfigurationOperation) {
	if o == nil {
		return
	}
	o.Receipts = op.Receipts
}
func (o *SetReceiptsConfigurationRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetReceiptsConfigurationRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetReceiptsConfigurationOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetReceiptsConfigurationResponse structure represents the FAX_SetReceiptsConfiguration operation response
type SetReceiptsConfigurationResponse struct {
	// Return: The FAX_SetReceiptsConfiguration return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetReceiptsConfigurationResponse) xxx_ToOp(ctx context.Context, op *xxx_SetReceiptsConfigurationOperation) *xxx_SetReceiptsConfigurationOperation {
	if op == nil {
		op = &xxx_SetReceiptsConfigurationOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetReceiptsConfigurationResponse) xxx_FromOp(ctx context.Context, op *xxx_SetReceiptsConfigurationOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetReceiptsConfigurationResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetReceiptsConfigurationResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetReceiptsConfigurationOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetReceiptsOptionsOperation structure represents the FAX_GetReceiptsOptions operation
type xxx_GetReceiptsOptionsOperation struct {
	ReceiptsOptions uint32 `idl:"name:lpdwReceiptsOptions;pointer:ref" json:"receipts_options"`
	Return          uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetReceiptsOptionsOperation) OpNum() int { return 36 }

func (o *xxx_GetReceiptsOptionsOperation) OpName() string { return "/fax/v4/FAX_GetReceiptsOptions" }

func (o *xxx_GetReceiptsOptionsOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetReceiptsOptionsOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	return nil
}

func (o *xxx_GetReceiptsOptionsOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	return nil
}

func (o *xxx_GetReceiptsOptionsOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetReceiptsOptionsOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpdwReceiptsOptions {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ReceiptsOptions); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetReceiptsOptionsOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpdwReceiptsOptions {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ReceiptsOptions); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetReceiptsOptionsRequest structure represents the FAX_GetReceiptsOptions operation request
type GetReceiptsOptionsRequest struct {
}

func (o *GetReceiptsOptionsRequest) xxx_ToOp(ctx context.Context, op *xxx_GetReceiptsOptionsOperation) *xxx_GetReceiptsOptionsOperation {
	if op == nil {
		op = &xxx_GetReceiptsOptionsOperation{}
	}
	if o == nil {
		return op
	}
	return op
}

func (o *GetReceiptsOptionsRequest) xxx_FromOp(ctx context.Context, op *xxx_GetReceiptsOptionsOperation) {
	if o == nil {
		return
	}
}
func (o *GetReceiptsOptionsRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetReceiptsOptionsRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetReceiptsOptionsOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetReceiptsOptionsResponse structure represents the FAX_GetReceiptsOptions operation response
type GetReceiptsOptionsResponse struct {
	// lpdwReceiptsOptions: A pointer to the DWORD ([MS-DTYP] section 2.2.9) that receives
	// the options.
	//
	//	+--------------+----------------------------------------------------------------------------------+
	//	|              |                                                                                  |
	//	|  VALUE/CODE  |                                     MEANING                                      |
	//	|              |                                                                                  |
	//	+--------------+----------------------------------------------------------------------------------+
	//	+--------------+----------------------------------------------------------------------------------+
	//	| DRT_EMAIL 1  | Allow sending the receipt by email. The email address is the email address of    |
	//	|              | the sender.                                                                      |
	//	+--------------+----------------------------------------------------------------------------------+
	//	| DRT_MSGBOX 4 | Allow notification on the transmission result by sending a text message          |
	//	|              | containing a character string to the sender's computer as described in Messenger |
	//	|              | Service Remote Protocol Specification [MS-MSRP] section 3.2.4.1.<130>            |
	//	+--------------+----------------------------------------------------------------------------------+
	ReceiptsOptions uint32 `idl:"name:lpdwReceiptsOptions;pointer:ref" json:"receipts_options"`
	// Return: The FAX_GetReceiptsOptions return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetReceiptsOptionsResponse) xxx_ToOp(ctx context.Context, op *xxx_GetReceiptsOptionsOperation) *xxx_GetReceiptsOptionsOperation {
	if op == nil {
		op = &xxx_GetReceiptsOptionsOperation{}
	}
	if o == nil {
		return op
	}
	op.ReceiptsOptions = o.ReceiptsOptions
	op.Return = o.Return
	return op
}

func (o *GetReceiptsOptionsResponse) xxx_FromOp(ctx context.Context, op *xxx_GetReceiptsOptionsOperation) {
	if o == nil {
		return
	}
	o.ReceiptsOptions = op.ReceiptsOptions
	o.Return = op.Return
}
func (o *GetReceiptsOptionsResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetReceiptsOptionsResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetReceiptsOptionsOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetVersionOperation structure represents the FAX_GetVersion operation
type xxx_GetVersionOperation struct {
	Version *fax.Version `idl:"name:pVersion" json:"version"`
	Return  uint32       `idl:"name:Return" json:"return"`
}

func (o *xxx_GetVersionOperation) OpNum() int { return 37 }

func (o *xxx_GetVersionOperation) OpName() string { return "/fax/v4/FAX_GetVersion" }

func (o *xxx_GetVersionOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetVersionOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// pVersion {in, out} (1:{alias=PFAX_VERSION}*(1))(2:{alias=FAX_VERSION}(struct))
	{
		if o.Version != nil {
			if err := o.Version.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.Version{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_GetVersionOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// pVersion {in, out} (1:{alias=PFAX_VERSION,pointer=ref}*(1))(2:{alias=FAX_VERSION}(struct))
	{
		if o.Version == nil {
			o.Version = &fax.Version{}
		}
		if err := o.Version.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetVersionOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetVersionOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pVersion {in, out} (1:{alias=PFAX_VERSION}*(1))(2:{alias=FAX_VERSION}(struct))
	{
		if o.Version != nil {
			if err := o.Version.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.Version{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetVersionOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pVersion {in, out} (1:{alias=PFAX_VERSION,pointer=ref}*(1))(2:{alias=FAX_VERSION}(struct))
	{
		if o.Version == nil {
			o.Version = &fax.Version{}
		}
		if err := o.Version.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetVersionRequest structure represents the FAX_GetVersion operation request
type GetVersionRequest struct {
	// pVersion: A pointer to a FAX_VERSION (section 2.2.22) object.
	Version *fax.Version `idl:"name:pVersion" json:"version"`
}

func (o *GetVersionRequest) xxx_ToOp(ctx context.Context, op *xxx_GetVersionOperation) *xxx_GetVersionOperation {
	if op == nil {
		op = &xxx_GetVersionOperation{}
	}
	if o == nil {
		return op
	}
	op.Version = o.Version
	return op
}

func (o *GetVersionRequest) xxx_FromOp(ctx context.Context, op *xxx_GetVersionOperation) {
	if o == nil {
		return
	}
	o.Version = op.Version
}
func (o *GetVersionRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetVersionRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetVersionOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetVersionResponse structure represents the FAX_GetVersion operation response
type GetVersionResponse struct {
	// pVersion: A pointer to a FAX_VERSION (section 2.2.22) object.
	Version *fax.Version `idl:"name:pVersion" json:"version"`
	// Return: The FAX_GetVersion return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetVersionResponse) xxx_ToOp(ctx context.Context, op *xxx_GetVersionOperation) *xxx_GetVersionOperation {
	if op == nil {
		op = &xxx_GetVersionOperation{}
	}
	if o == nil {
		return op
	}
	op.Version = o.Version
	op.Return = o.Return
	return op
}

func (o *GetVersionResponse) xxx_FromOp(ctx context.Context, op *xxx_GetVersionOperation) {
	if o == nil {
		return
	}
	o.Version = op.Version
	o.Return = op.Return
}
func (o *GetVersionResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetVersionResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetVersionOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetOutboxConfigurationOperation structure represents the FAX_GetOutboxConfiguration operation
type xxx_GetOutboxConfigurationOperation struct {
	Buffer     []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	BufferSize uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	Return     uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetOutboxConfigurationOperation) OpNum() int { return 38 }

func (o *xxx_GetOutboxConfigurationOperation) OpName() string {
	return "/fax/v4/FAX_GetOutboxConfiguration"
}

func (o *xxx_GetOutboxConfigurationOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetOutboxConfigurationOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	return nil
}

func (o *xxx_GetOutboxConfigurationOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	return nil
}

func (o *xxx_GetOutboxConfigurationOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Buffer != nil && o.BufferSize == 0 {
		o.BufferSize = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetOutboxConfigurationOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		if o.Buffer != nil || o.BufferSize > 0 {
			_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.BufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Buffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Buffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetOutboxConfigurationOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE,pointer=ref}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
			}
			o.Buffer = make([]byte, sizeInfo[0])
			for i1 := range o.Buffer {
				i1 := i1
				if err := w.ReadData(&o.Buffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetOutboxConfigurationRequest structure represents the FAX_GetOutboxConfiguration operation request
type GetOutboxConfigurationRequest struct {
}

func (o *GetOutboxConfigurationRequest) xxx_ToOp(ctx context.Context, op *xxx_GetOutboxConfigurationOperation) *xxx_GetOutboxConfigurationOperation {
	if op == nil {
		op = &xxx_GetOutboxConfigurationOperation{}
	}
	if o == nil {
		return op
	}
	return op
}

func (o *GetOutboxConfigurationRequest) xxx_FromOp(ctx context.Context, op *xxx_GetOutboxConfigurationOperation) {
	if o == nil {
		return
	}
}
func (o *GetOutboxConfigurationRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetOutboxConfigurationRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetOutboxConfigurationOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetOutboxConfigurationResponse structure represents the FAX_GetOutboxConfiguration operation response
type GetOutboxConfigurationResponse struct {
	// Buffer: A pointer to a FAX_OUTBOX_CONFIG (section 2.2.16) object.
	Buffer []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	// BufferSize: A pointer to a DWORD ([MS-DTYP] section 2.2.9) in which to return the
	// size, in bytes, of the buffer.
	BufferSize uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	// Return: The FAX_GetOutboxConfiguration return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetOutboxConfigurationResponse) xxx_ToOp(ctx context.Context, op *xxx_GetOutboxConfigurationOperation) *xxx_GetOutboxConfigurationOperation {
	if op == nil {
		op = &xxx_GetOutboxConfigurationOperation{}
	}
	if o == nil {
		return op
	}
	op.Buffer = o.Buffer
	op.BufferSize = o.BufferSize
	op.Return = o.Return
	return op
}

func (o *GetOutboxConfigurationResponse) xxx_FromOp(ctx context.Context, op *xxx_GetOutboxConfigurationOperation) {
	if o == nil {
		return
	}
	o.Buffer = op.Buffer
	o.BufferSize = op.BufferSize
	o.Return = op.Return
}
func (o *GetOutboxConfigurationResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetOutboxConfigurationResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetOutboxConfigurationOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetOutboxConfigurationOperation structure represents the FAX_SetOutboxConfiguration operation
type xxx_SetOutboxConfigurationOperation struct {
	OutboxConfig *fax.OutboxConfig `idl:"name:pOutboxCfg;pointer:ref" json:"outbox_config"`
	Return       uint32            `idl:"name:Return" json:"return"`
}

func (o *xxx_SetOutboxConfigurationOperation) OpNum() int { return 39 }

func (o *xxx_SetOutboxConfigurationOperation) OpName() string {
	return "/fax/v4/FAX_SetOutboxConfiguration"
}

func (o *xxx_SetOutboxConfigurationOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOutboxConfigurationOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// pOutboxCfg {in} (1:{pointer=ref, alias=PFAX_OUTBOX_CONFIG}*(1))(2:{alias=FAX_OUTBOX_CONFIG}(struct))
	{
		if o.OutboxConfig != nil {
			if err := o.OutboxConfig.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.OutboxConfig{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_SetOutboxConfigurationOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// pOutboxCfg {in} (1:{pointer=ref, alias=PFAX_OUTBOX_CONFIG}*(1))(2:{alias=FAX_OUTBOX_CONFIG}(struct))
	{
		if o.OutboxConfig == nil {
			o.OutboxConfig = &fax.OutboxConfig{}
		}
		if err := o.OutboxConfig.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOutboxConfigurationOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOutboxConfigurationOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOutboxConfigurationOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetOutboxConfigurationRequest structure represents the FAX_SetOutboxConfiguration operation request
type SetOutboxConfigurationRequest struct {
	// pOutboxCfg: A pointer to an FAX_OUTBOX_CONFIG (section 2.2.16) object containing
	// configuration information.
	OutboxConfig *fax.OutboxConfig `idl:"name:pOutboxCfg;pointer:ref" json:"outbox_config"`
}

func (o *SetOutboxConfigurationRequest) xxx_ToOp(ctx context.Context, op *xxx_SetOutboxConfigurationOperation) *xxx_SetOutboxConfigurationOperation {
	if op == nil {
		op = &xxx_SetOutboxConfigurationOperation{}
	}
	if o == nil {
		return op
	}
	op.OutboxConfig = o.OutboxConfig
	return op
}

func (o *SetOutboxConfigurationRequest) xxx_FromOp(ctx context.Context, op *xxx_SetOutboxConfigurationOperation) {
	if o == nil {
		return
	}
	o.OutboxConfig = op.OutboxConfig
}
func (o *SetOutboxConfigurationRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetOutboxConfigurationRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetOutboxConfigurationOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetOutboxConfigurationResponse structure represents the FAX_SetOutboxConfiguration operation response
type SetOutboxConfigurationResponse struct {
	// Return: The FAX_SetOutboxConfiguration return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetOutboxConfigurationResponse) xxx_ToOp(ctx context.Context, op *xxx_SetOutboxConfigurationOperation) *xxx_SetOutboxConfigurationOperation {
	if op == nil {
		op = &xxx_SetOutboxConfigurationOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetOutboxConfigurationResponse) xxx_FromOp(ctx context.Context, op *xxx_SetOutboxConfigurationOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetOutboxConfigurationResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetOutboxConfigurationResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetOutboxConfigurationOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetPersonalCoverPagesOptionOperation structure represents the FAX_GetPersonalCoverPagesOption operation
type xxx_GetPersonalCoverPagesOptionOperation struct {
	PersonalCreatePartitionAllowed bool   `idl:"name:lpbPersonalCPAllowed;pointer:ref" json:"personal_create_partition_allowed"`
	Return                         uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetPersonalCoverPagesOptionOperation) OpNum() int { return 40 }

func (o *xxx_GetPersonalCoverPagesOptionOperation) OpName() string {
	return "/fax/v4/FAX_GetPersonalCoverPagesOption"
}

func (o *xxx_GetPersonalCoverPagesOptionOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetPersonalCoverPagesOptionOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	return nil
}

func (o *xxx_GetPersonalCoverPagesOptionOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	return nil
}

func (o *xxx_GetPersonalCoverPagesOptionOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetPersonalCoverPagesOptionOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpbPersonalCPAllowed {out} (1:{pointer=ref, alias=LPBOOL}*(1))(2:{alias=BOOL}(int32))
	{
		if !o.PersonalCreatePartitionAllowed {
			if err := w.WriteData(int32(0)); err != nil {
				return err
			}
		} else {
			if err := w.WriteData(int32(1)); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetPersonalCoverPagesOptionOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpbPersonalCPAllowed {out} (1:{pointer=ref, alias=LPBOOL}*(1))(2:{alias=BOOL}(int32))
	{
		var _bPersonalCreatePartitionAllowed int32
		if err := w.ReadData(&_bPersonalCreatePartitionAllowed); err != nil {
			return err
		}
		o.PersonalCreatePartitionAllowed = _bPersonalCreatePartitionAllowed != 0
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetPersonalCoverPagesOptionRequest structure represents the FAX_GetPersonalCoverPagesOption operation request
type GetPersonalCoverPagesOptionRequest struct {
}

func (o *GetPersonalCoverPagesOptionRequest) xxx_ToOp(ctx context.Context, op *xxx_GetPersonalCoverPagesOptionOperation) *xxx_GetPersonalCoverPagesOptionOperation {
	if op == nil {
		op = &xxx_GetPersonalCoverPagesOptionOperation{}
	}
	if o == nil {
		return op
	}
	return op
}

func (o *GetPersonalCoverPagesOptionRequest) xxx_FromOp(ctx context.Context, op *xxx_GetPersonalCoverPagesOptionOperation) {
	if o == nil {
		return
	}
}
func (o *GetPersonalCoverPagesOptionRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetPersonalCoverPagesOptionRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetPersonalCoverPagesOptionOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetPersonalCoverPagesOptionResponse structure represents the FAX_GetPersonalCoverPagesOption operation response
type GetPersonalCoverPagesOptionResponse struct {
	// lpbPersonalCPAllowed: A pointer to a BOOL that receives the personal cover-pages
	// option. If TRUE, the server allows sending personal cover pages. Otherwise, the server
	// does not allow personal cover pages.
	PersonalCreatePartitionAllowed bool `idl:"name:lpbPersonalCPAllowed;pointer:ref" json:"personal_create_partition_allowed"`
	// Return: The FAX_GetPersonalCoverPagesOption return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetPersonalCoverPagesOptionResponse) xxx_ToOp(ctx context.Context, op *xxx_GetPersonalCoverPagesOptionOperation) *xxx_GetPersonalCoverPagesOptionOperation {
	if op == nil {
		op = &xxx_GetPersonalCoverPagesOptionOperation{}
	}
	if o == nil {
		return op
	}
	op.PersonalCreatePartitionAllowed = o.PersonalCreatePartitionAllowed
	op.Return = o.Return
	return op
}

func (o *GetPersonalCoverPagesOptionResponse) xxx_FromOp(ctx context.Context, op *xxx_GetPersonalCoverPagesOptionOperation) {
	if o == nil {
		return
	}
	o.PersonalCreatePartitionAllowed = op.PersonalCreatePartitionAllowed
	o.Return = op.Return
}
func (o *GetPersonalCoverPagesOptionResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetPersonalCoverPagesOptionResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetPersonalCoverPagesOptionOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetArchiveConfigurationOperation structure represents the FAX_GetArchiveConfiguration operation
type xxx_GetArchiveConfigurationOperation struct {
	Folder     fax.MessageFolder `idl:"name:Folder" json:"folder"`
	Buffer     []byte            `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	BufferSize uint32            `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	Return     uint32            `idl:"name:Return" json:"return"`
}

func (o *xxx_GetArchiveConfigurationOperation) OpNum() int { return 41 }

func (o *xxx_GetArchiveConfigurationOperation) OpName() string {
	return "/fax/v4/FAX_GetArchiveConfiguration"
}

func (o *xxx_GetArchiveConfigurationOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetArchiveConfigurationOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// Folder {in} (1:{alias=FAX_ENUM_MESSAGE_FOLDER}(enum))
	{
		if err := w.WriteEnum(uint16(o.Folder)); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetArchiveConfigurationOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// Folder {in} (1:{alias=FAX_ENUM_MESSAGE_FOLDER}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.Folder)); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetArchiveConfigurationOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Buffer != nil && o.BufferSize == 0 {
		o.BufferSize = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetArchiveConfigurationOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		if o.Buffer != nil || o.BufferSize > 0 {
			_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.BufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Buffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Buffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetArchiveConfigurationOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE,pointer=ref}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
			}
			o.Buffer = make([]byte, sizeInfo[0])
			for i1 := range o.Buffer {
				i1 := i1
				if err := w.ReadData(&o.Buffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetArchiveConfigurationRequest structure represents the FAX_GetArchiveConfiguration operation request
type GetArchiveConfigurationRequest struct {
	// Folder: Archive location. This MUST be either FAX_MESSAGE_FOLDER_INBOX or FAX_MESSAGE_FOLDER_SENTITEMS
	// described in section 2.2.2.
	Folder fax.MessageFolder `idl:"name:Folder" json:"folder"`
}

func (o *GetArchiveConfigurationRequest) xxx_ToOp(ctx context.Context, op *xxx_GetArchiveConfigurationOperation) *xxx_GetArchiveConfigurationOperation {
	if op == nil {
		op = &xxx_GetArchiveConfigurationOperation{}
	}
	if o == nil {
		return op
	}
	op.Folder = o.Folder
	return op
}

func (o *GetArchiveConfigurationRequest) xxx_FromOp(ctx context.Context, op *xxx_GetArchiveConfigurationOperation) {
	if o == nil {
		return
	}
	o.Folder = op.Folder
}
func (o *GetArchiveConfigurationRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetArchiveConfigurationRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetArchiveConfigurationOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetArchiveConfigurationResponse structure represents the FAX_GetArchiveConfiguration operation response
type GetArchiveConfigurationResponse struct {
	// Buffer: A pointer to a FAX_ARCHIVE_CONFIGW (section 2.2.27) object. If the size of
	// the archive exceeds the dwSizeQuotaHighWatermark value and if the bSizeQuotaWarning
	// member is set to TRUE, an event log warning SHOULD be issued. If an event log warning
	// was already issued, no more events SHOULD be issued until the size of the archive
	// drops below the dwSizeQuotaLowWatermark value. If a fax message stays in the archive
	// longer than the dwAgeLimit value, it MAY be automatically deleted. If the dwAgeLimit
	// value is zero, the time limit MUST NOT be used.
	Buffer []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	// BufferSize: A pointer to a DWORD ([MS-DTYP] section 2.2.9) in which to return the
	// size, in bytes, of the buffer.
	BufferSize uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	// Return: The FAX_GetArchiveConfiguration return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetArchiveConfigurationResponse) xxx_ToOp(ctx context.Context, op *xxx_GetArchiveConfigurationOperation) *xxx_GetArchiveConfigurationOperation {
	if op == nil {
		op = &xxx_GetArchiveConfigurationOperation{}
	}
	if o == nil {
		return op
	}
	op.Buffer = o.Buffer
	op.BufferSize = o.BufferSize
	op.Return = o.Return
	return op
}

func (o *GetArchiveConfigurationResponse) xxx_FromOp(ctx context.Context, op *xxx_GetArchiveConfigurationOperation) {
	if o == nil {
		return
	}
	o.Buffer = op.Buffer
	o.BufferSize = op.BufferSize
	o.Return = op.Return
}
func (o *GetArchiveConfigurationResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetArchiveConfigurationResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetArchiveConfigurationOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetArchiveConfigurationOperation structure represents the FAX_SetArchiveConfiguration operation
type xxx_SetArchiveConfigurationOperation struct {
	Folder        fax.MessageFolder `idl:"name:Folder" json:"folder"`
	ArchiveConfig uint8             `idl:"name:pArchiveCfg;pointer:ref" json:"archive_config"`
	Return        uint32            `idl:"name:Return" json:"return"`
}

func (o *xxx_SetArchiveConfigurationOperation) OpNum() int { return 42 }

func (o *xxx_SetArchiveConfigurationOperation) OpName() string {
	return "/fax/v4/FAX_SetArchiveConfiguration"
}

func (o *xxx_SetArchiveConfigurationOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetArchiveConfigurationOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// Folder {in} (1:{alias=FAX_ENUM_MESSAGE_FOLDER}(enum))
	{
		if err := w.WriteEnum(uint16(o.Folder)); err != nil {
			return err
		}
	}
	// pArchiveCfg {in} (1:{pointer=ref, alias=LPBYTE}*(1))(2:{alias=BYTE}(uchar))
	{
		if err := w.WriteData(o.ArchiveConfig); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetArchiveConfigurationOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// Folder {in} (1:{alias=FAX_ENUM_MESSAGE_FOLDER}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.Folder)); err != nil {
			return err
		}
	}
	// pArchiveCfg {in} (1:{pointer=ref, alias=LPBYTE}*(1))(2:{alias=BYTE}(uchar))
	{
		if err := w.ReadData(&o.ArchiveConfig); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetArchiveConfigurationOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetArchiveConfigurationOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetArchiveConfigurationOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetArchiveConfigurationRequest structure represents the FAX_SetArchiveConfiguration operation request
type SetArchiveConfigurationRequest struct {
	// Folder: The archive location. The client MUST set this parameter to either FAX_MESSAGE_FOLDER_INBOX
	// or FAX_MESSAGE_FOLDER_SENTITEMS.
	Folder fax.MessageFolder `idl:"name:Folder" json:"folder"`
	// pArchiveCfg: A pointer to a buffer containing an array of FAX_ARCHIVE_CONFIGW (section
	// 2.2.27) structures. If the size of the archive exceeds the dwSizeQuotaHighWatermark
	// value and if the bSizeQuotaWarning member is set to TRUE, an event log warning SHOULD
	// be issued. If an event log warning was already issued, no more events SHOULD be issued
	// until the size of the archive drops below the dwSizeQuotaLowWatermark value. If a
	// fax message stays in the archive longer than the dwAgeLimit value, it MAY be automatically
	// deleted. If the dwAgeLimit value is zero, the time limit MUST NOT be used.
	ArchiveConfig uint8 `idl:"name:pArchiveCfg;pointer:ref" json:"archive_config"`
}

func (o *SetArchiveConfigurationRequest) xxx_ToOp(ctx context.Context, op *xxx_SetArchiveConfigurationOperation) *xxx_SetArchiveConfigurationOperation {
	if op == nil {
		op = &xxx_SetArchiveConfigurationOperation{}
	}
	if o == nil {
		return op
	}
	op.Folder = o.Folder
	op.ArchiveConfig = o.ArchiveConfig
	return op
}

func (o *SetArchiveConfigurationRequest) xxx_FromOp(ctx context.Context, op *xxx_SetArchiveConfigurationOperation) {
	if o == nil {
		return
	}
	o.Folder = op.Folder
	o.ArchiveConfig = op.ArchiveConfig
}
func (o *SetArchiveConfigurationRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetArchiveConfigurationRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetArchiveConfigurationOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetArchiveConfigurationResponse structure represents the FAX_SetArchiveConfiguration operation response
type SetArchiveConfigurationResponse struct {
	// Return: The FAX_SetArchiveConfiguration return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetArchiveConfigurationResponse) xxx_ToOp(ctx context.Context, op *xxx_SetArchiveConfigurationOperation) *xxx_SetArchiveConfigurationOperation {
	if op == nil {
		op = &xxx_SetArchiveConfigurationOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetArchiveConfigurationResponse) xxx_FromOp(ctx context.Context, op *xxx_SetArchiveConfigurationOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetArchiveConfigurationResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetArchiveConfigurationResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetArchiveConfigurationOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetActivityLoggingConfigurationOperation structure represents the FAX_GetActivityLoggingConfiguration operation
type xxx_GetActivityLoggingConfigurationOperation struct {
	Buffer     []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	BufferSize uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	Return     uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetActivityLoggingConfigurationOperation) OpNum() int { return 43 }

func (o *xxx_GetActivityLoggingConfigurationOperation) OpName() string {
	return "/fax/v4/FAX_GetActivityLoggingConfiguration"
}

func (o *xxx_GetActivityLoggingConfigurationOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetActivityLoggingConfigurationOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	return nil
}

func (o *xxx_GetActivityLoggingConfigurationOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	return nil
}

func (o *xxx_GetActivityLoggingConfigurationOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Buffer != nil && o.BufferSize == 0 {
		o.BufferSize = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetActivityLoggingConfigurationOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		if o.Buffer != nil || o.BufferSize > 0 {
			_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.BufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Buffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Buffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetActivityLoggingConfigurationOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE,pointer=ref}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
			}
			o.Buffer = make([]byte, sizeInfo[0])
			for i1 := range o.Buffer {
				i1 := i1
				if err := w.ReadData(&o.Buffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetActivityLoggingConfigurationRequest structure represents the FAX_GetActivityLoggingConfiguration operation request
type GetActivityLoggingConfigurationRequest struct {
}

func (o *GetActivityLoggingConfigurationRequest) xxx_ToOp(ctx context.Context, op *xxx_GetActivityLoggingConfigurationOperation) *xxx_GetActivityLoggingConfigurationOperation {
	if op == nil {
		op = &xxx_GetActivityLoggingConfigurationOperation{}
	}
	if o == nil {
		return op
	}
	return op
}

func (o *GetActivityLoggingConfigurationRequest) xxx_FromOp(ctx context.Context, op *xxx_GetActivityLoggingConfigurationOperation) {
	if o == nil {
		return
	}
}
func (o *GetActivityLoggingConfigurationRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetActivityLoggingConfigurationRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetActivityLoggingConfigurationOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetActivityLoggingConfigurationResponse structure represents the FAX_GetActivityLoggingConfiguration operation response
type GetActivityLoggingConfigurationResponse struct {
	// Buffer: A pointer to a _FAX_ACTIVITY_LOGGING_CONFIGW (section 2.2.26) structure.
	Buffer []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	// BufferSize: A pointer to a DWORD ([MS-DTYP] section 2.2.9) in which to return the
	// size, in bytes, of the buffer.
	BufferSize uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	// Return: The FAX_GetActivityLoggingConfiguration return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetActivityLoggingConfigurationResponse) xxx_ToOp(ctx context.Context, op *xxx_GetActivityLoggingConfigurationOperation) *xxx_GetActivityLoggingConfigurationOperation {
	if op == nil {
		op = &xxx_GetActivityLoggingConfigurationOperation{}
	}
	if o == nil {
		return op
	}
	op.Buffer = o.Buffer
	op.BufferSize = o.BufferSize
	op.Return = o.Return
	return op
}

func (o *GetActivityLoggingConfigurationResponse) xxx_FromOp(ctx context.Context, op *xxx_GetActivityLoggingConfigurationOperation) {
	if o == nil {
		return
	}
	o.Buffer = op.Buffer
	o.BufferSize = op.BufferSize
	o.Return = op.Return
}
func (o *GetActivityLoggingConfigurationResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetActivityLoggingConfigurationResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetActivityLoggingConfigurationOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetActivityLoggingConfigurationOperation structure represents the FAX_SetActivityLoggingConfiguration operation
type xxx_SetActivityLoggingConfigurationOperation struct {
	ActivityLogConfig *fax.ActivityLoggingConfigW `idl:"name:pActivLogCfg;pointer:ref" json:"activity_log_config"`
	Return            uint32                      `idl:"name:Return" json:"return"`
}

func (o *xxx_SetActivityLoggingConfigurationOperation) OpNum() int { return 44 }

func (o *xxx_SetActivityLoggingConfigurationOperation) OpName() string {
	return "/fax/v4/FAX_SetActivityLoggingConfiguration"
}

func (o *xxx_SetActivityLoggingConfigurationOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetActivityLoggingConfigurationOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// pActivLogCfg {in} (1:{pointer=ref, alias=PFAX_ACTIVITY_LOGGING_CONFIGW}*(1))(2:{alias=FAX_ACTIVITY_LOGGING_CONFIGW}(struct))
	{
		if o.ActivityLogConfig != nil {
			if err := o.ActivityLogConfig.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.ActivityLoggingConfigW{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetActivityLoggingConfigurationOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// pActivLogCfg {in} (1:{pointer=ref, alias=PFAX_ACTIVITY_LOGGING_CONFIGW}*(1))(2:{alias=FAX_ACTIVITY_LOGGING_CONFIGW}(struct))
	{
		if o.ActivityLogConfig == nil {
			o.ActivityLogConfig = &fax.ActivityLoggingConfigW{}
		}
		if err := o.ActivityLogConfig.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetActivityLoggingConfigurationOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetActivityLoggingConfigurationOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetActivityLoggingConfigurationOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetActivityLoggingConfigurationRequest structure represents the FAX_SetActivityLoggingConfiguration operation request
type SetActivityLoggingConfigurationRequest struct {
	// pActivLogCfg: A pointer to a FAX_ACTIVITY_LOGGING_CONFIGW (section 2.2.25) object.
	// The directory specified by the lpwstrDBPath field of this structure SHOULD be created
	// by the caller if it does not exist.
	ActivityLogConfig *fax.ActivityLoggingConfigW `idl:"name:pActivLogCfg;pointer:ref" json:"activity_log_config"`
}

func (o *SetActivityLoggingConfigurationRequest) xxx_ToOp(ctx context.Context, op *xxx_SetActivityLoggingConfigurationOperation) *xxx_SetActivityLoggingConfigurationOperation {
	if op == nil {
		op = &xxx_SetActivityLoggingConfigurationOperation{}
	}
	if o == nil {
		return op
	}
	op.ActivityLogConfig = o.ActivityLogConfig
	return op
}

func (o *SetActivityLoggingConfigurationRequest) xxx_FromOp(ctx context.Context, op *xxx_SetActivityLoggingConfigurationOperation) {
	if o == nil {
		return
	}
	o.ActivityLogConfig = op.ActivityLogConfig
}
func (o *SetActivityLoggingConfigurationRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetActivityLoggingConfigurationRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetActivityLoggingConfigurationOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetActivityLoggingConfigurationResponse structure represents the FAX_SetActivityLoggingConfiguration operation response
type SetActivityLoggingConfigurationResponse struct {
	// Return: The FAX_SetActivityLoggingConfiguration return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetActivityLoggingConfigurationResponse) xxx_ToOp(ctx context.Context, op *xxx_SetActivityLoggingConfigurationOperation) *xxx_SetActivityLoggingConfigurationOperation {
	if op == nil {
		op = &xxx_SetActivityLoggingConfigurationOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetActivityLoggingConfigurationResponse) xxx_FromOp(ctx context.Context, op *xxx_SetActivityLoggingConfigurationOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetActivityLoggingConfigurationResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetActivityLoggingConfigurationResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetActivityLoggingConfigurationOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumerateProvidersOperation structure represents the FAX_EnumerateProviders operation
type xxx_EnumerateProvidersOperation struct {
	Buffer          []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	BufferSize      uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	ProvidersLength uint32 `idl:"name:lpdwNumProviders;pointer:ref" json:"providers_length"`
	Return          uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumerateProvidersOperation) OpNum() int { return 45 }

func (o *xxx_EnumerateProvidersOperation) OpName() string { return "/fax/v4/FAX_EnumerateProviders" }

func (o *xxx_EnumerateProvidersOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumerateProvidersOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	return nil
}

func (o *xxx_EnumerateProvidersOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	return nil
}

func (o *xxx_EnumerateProvidersOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Buffer != nil && o.BufferSize == 0 {
		o.BufferSize = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumerateProvidersOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		if o.Buffer != nil || o.BufferSize > 0 {
			_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.BufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Buffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Buffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	// lpdwNumProviders {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ProvidersLength); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumerateProvidersOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE,pointer=ref}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
			}
			o.Buffer = make([]byte, sizeInfo[0])
			for i1 := range o.Buffer {
				i1 := i1
				if err := w.ReadData(&o.Buffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	// lpdwNumProviders {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ProvidersLength); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumerateProvidersRequest structure represents the FAX_EnumerateProviders operation request
type EnumerateProvidersRequest struct {
}

func (o *EnumerateProvidersRequest) xxx_ToOp(ctx context.Context, op *xxx_EnumerateProvidersOperation) *xxx_EnumerateProvidersOperation {
	if op == nil {
		op = &xxx_EnumerateProvidersOperation{}
	}
	if o == nil {
		return op
	}
	return op
}

func (o *EnumerateProvidersRequest) xxx_FromOp(ctx context.Context, op *xxx_EnumerateProvidersOperation) {
	if o == nil {
		return
	}
}
func (o *EnumerateProvidersRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumerateProvidersRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumerateProvidersOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumerateProvidersResponse structure represents the FAX_EnumerateProviders operation response
type EnumerateProvidersResponse struct {
	// Buffer: A pointer to the address of a buffer to receive an array of FAX_DEVICE_PROVIDER_INFO
	// (section 2.2.30) structures. Each structure contains information about one fax device
	// provider, as it pertains to the entire fax service.
	Buffer []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	// BufferSize: A pointer to a DWORD ([MS-DTYP] section 2.2.9) in which to return the
	// size, in bytes, of the buffer.
	BufferSize uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	// lpdwNumProviders: A pointer to a DWORD variable to receive the number of FAX_DEVICE_PROVIDER_INFO
	// that the method returns in Buffer. This number MUST be equal to the total number
	// of FSPs installed on the target server.
	ProvidersLength uint32 `idl:"name:lpdwNumProviders;pointer:ref" json:"providers_length"`
	// Return: The FAX_EnumerateProviders return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumerateProvidersResponse) xxx_ToOp(ctx context.Context, op *xxx_EnumerateProvidersOperation) *xxx_EnumerateProvidersOperation {
	if op == nil {
		op = &xxx_EnumerateProvidersOperation{}
	}
	if o == nil {
		return op
	}
	op.Buffer = o.Buffer
	op.BufferSize = o.BufferSize
	op.ProvidersLength = o.ProvidersLength
	op.Return = o.Return
	return op
}

func (o *EnumerateProvidersResponse) xxx_FromOp(ctx context.Context, op *xxx_EnumerateProvidersOperation) {
	if o == nil {
		return
	}
	o.Buffer = op.Buffer
	o.BufferSize = op.BufferSize
	o.ProvidersLength = op.ProvidersLength
	o.Return = op.Return
}
func (o *EnumerateProvidersResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumerateProvidersResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumerateProvidersOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetPortExOperation structure represents the FAX_GetPortEx operation
type xxx_GetPortExOperation struct {
	DeviceID   uint32 `idl:"name:dwDeviceId" json:"device_id"`
	Buffer     []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	BufferSize uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	Return     uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetPortExOperation) OpNum() int { return 46 }

func (o *xxx_GetPortExOperation) OpName() string { return "/fax/v4/FAX_GetPortEx" }

func (o *xxx_GetPortExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetPortExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// dwDeviceId {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DeviceID); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetPortExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// dwDeviceId {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DeviceID); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetPortExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Buffer != nil && o.BufferSize == 0 {
		o.BufferSize = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetPortExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		if o.Buffer != nil || o.BufferSize > 0 {
			_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.BufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Buffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Buffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetPortExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE,pointer=ref}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
			}
			o.Buffer = make([]byte, sizeInfo[0])
			for i1 := range o.Buffer {
				i1 := i1
				if err := w.ReadData(&o.Buffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetPortExRequest structure represents the FAX_GetPortEx operation request
type GetPortExRequest struct {
	// dwDeviceId: A DWORD ([MS-DTYP] section 2.2.9) that indicates a unique identifier
	// that distinguishes the device. The value of dwDeviceId MUST be greater than zero.
	DeviceID uint32 `idl:"name:dwDeviceId" json:"device_id"`
}

func (o *GetPortExRequest) xxx_ToOp(ctx context.Context, op *xxx_GetPortExOperation) *xxx_GetPortExOperation {
	if op == nil {
		op = &xxx_GetPortExOperation{}
	}
	if o == nil {
		return op
	}
	op.DeviceID = o.DeviceID
	return op
}

func (o *GetPortExRequest) xxx_FromOp(ctx context.Context, op *xxx_GetPortExOperation) {
	if o == nil {
		return
	}
	o.DeviceID = op.DeviceID
}
func (o *GetPortExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetPortExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetPortExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetPortExResponse structure represents the FAX_GetPortEx operation response
type GetPortExResponse struct {
	// Buffer: A pointer to a buffer to hold a _FAX_PORT_INFO_EXW (section 2.2.46) structure.
	Buffer []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	// BufferSize: A pointer to a DWORD in which to return the size, in bytes, of the buffer.
	BufferSize uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	// Return: The FAX_GetPortEx return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetPortExResponse) xxx_ToOp(ctx context.Context, op *xxx_GetPortExOperation) *xxx_GetPortExOperation {
	if op == nil {
		op = &xxx_GetPortExOperation{}
	}
	if o == nil {
		return op
	}
	op.Buffer = o.Buffer
	op.BufferSize = o.BufferSize
	op.Return = o.Return
	return op
}

func (o *GetPortExResponse) xxx_FromOp(ctx context.Context, op *xxx_GetPortExOperation) {
	if o == nil {
		return
	}
	o.Buffer = op.Buffer
	o.BufferSize = op.BufferSize
	o.Return = op.Return
}
func (o *GetPortExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetPortExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetPortExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetPortExOperation structure represents the FAX_SetPortEx operation
type xxx_SetPortExOperation struct {
	DeviceID uint32           `idl:"name:dwDeviceId" json:"device_id"`
	PortInfo *fax.PortInfoExW `idl:"name:pPortInfo;pointer:ref" json:"port_info"`
	Return   uint32           `idl:"name:Return" json:"return"`
}

func (o *xxx_SetPortExOperation) OpNum() int { return 47 }

func (o *xxx_SetPortExOperation) OpName() string { return "/fax/v4/FAX_SetPortEx" }

func (o *xxx_SetPortExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetPortExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// dwDeviceId {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DeviceID); err != nil {
			return err
		}
	}
	// pPortInfo {in} (1:{pointer=ref, alias=PFAX_PORT_INFO_EXW}*(1))(2:{alias=FAX_PORT_INFO_EXW}(struct))
	{
		if o.PortInfo != nil {
			if err := o.PortInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.PortInfoExW{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetPortExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// dwDeviceId {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DeviceID); err != nil {
			return err
		}
	}
	// pPortInfo {in} (1:{pointer=ref, alias=PFAX_PORT_INFO_EXW}*(1))(2:{alias=FAX_PORT_INFO_EXW}(struct))
	{
		if o.PortInfo == nil {
			o.PortInfo = &fax.PortInfoExW{}
		}
		if err := o.PortInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetPortExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetPortExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetPortExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetPortExRequest structure represents the FAX_SetPortEx operation request
type SetPortExRequest struct {
	// dwDeviceId: A unique identifier that distinguishes the device. The value of dwDeviceId
	// MUST be greater than zero.
	DeviceID uint32 `idl:"name:dwDeviceId" json:"device_id"`
	// pPortInfo: A pointer to a buffer of type FAX_PORT_INFO_EXW (section 2.2.45).
	PortInfo *fax.PortInfoExW `idl:"name:pPortInfo;pointer:ref" json:"port_info"`
}

func (o *SetPortExRequest) xxx_ToOp(ctx context.Context, op *xxx_SetPortExOperation) *xxx_SetPortExOperation {
	if op == nil {
		op = &xxx_SetPortExOperation{}
	}
	if o == nil {
		return op
	}
	op.DeviceID = o.DeviceID
	op.PortInfo = o.PortInfo
	return op
}

func (o *SetPortExRequest) xxx_FromOp(ctx context.Context, op *xxx_SetPortExOperation) {
	if o == nil {
		return
	}
	o.DeviceID = op.DeviceID
	o.PortInfo = op.PortInfo
}
func (o *SetPortExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetPortExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetPortExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetPortExResponse structure represents the FAX_SetPortEx operation response
type SetPortExResponse struct {
	// Return: The FAX_SetPortEx return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetPortExResponse) xxx_ToOp(ctx context.Context, op *xxx_SetPortExOperation) *xxx_SetPortExOperation {
	if op == nil {
		op = &xxx_SetPortExOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetPortExResponse) xxx_FromOp(ctx context.Context, op *xxx_SetPortExOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetPortExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetPortExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetPortExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumPortsExOperation structure represents the FAX_EnumPortsEx operation
type xxx_EnumPortsExOperation struct {
	Buffer      []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	BufferSize  uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	PortsLength uint32 `idl:"name:lpdwNumPorts;pointer:ref" json:"ports_length"`
	Return      uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumPortsExOperation) OpNum() int { return 48 }

func (o *xxx_EnumPortsExOperation) OpName() string { return "/fax/v4/FAX_EnumPortsEx" }

func (o *xxx_EnumPortsExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumPortsExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	return nil
}

func (o *xxx_EnumPortsExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	return nil
}

func (o *xxx_EnumPortsExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Buffer != nil && o.BufferSize == 0 {
		o.BufferSize = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumPortsExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		if o.Buffer != nil || o.BufferSize > 0 {
			_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.BufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Buffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Buffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	// lpdwNumPorts {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PortsLength); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumPortsExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE,pointer=ref}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
			}
			o.Buffer = make([]byte, sizeInfo[0])
			for i1 := range o.Buffer {
				i1 := i1
				if err := w.ReadData(&o.Buffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	// lpdwNumPorts {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PortsLength); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumPortsExRequest structure represents the FAX_EnumPortsEx operation request
type EnumPortsExRequest struct {
}

func (o *EnumPortsExRequest) xxx_ToOp(ctx context.Context, op *xxx_EnumPortsExOperation) *xxx_EnumPortsExOperation {
	if op == nil {
		op = &xxx_EnumPortsExOperation{}
	}
	if o == nil {
		return op
	}
	return op
}

func (o *EnumPortsExRequest) xxx_FromOp(ctx context.Context, op *xxx_EnumPortsExOperation) {
	if o == nil {
		return
	}
}
func (o *EnumPortsExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumPortsExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumPortsExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumPortsExResponse structure represents the FAX_EnumPortsEx operation response
type EnumPortsExResponse struct {
	// Buffer: A pointer to the address of a buffer to receive an array of _FAX_PORT_INFO_EXW
	// (section 2.2.46) structures. Each structure describes one fax port. The data includes,
	// among other items, the line identifier and the current status and capability of the
	// port.
	Buffer []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	// BufferSize: A pointer to a DWORD ([MS-DTYP] section 2.2.9) in which to return the
	// size, in bytes, of the buffer.
	BufferSize uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	// lpdwNumPorts: A pointer to a DWORD variable that receives the number of ports that
	// are returned by the method.
	PortsLength uint32 `idl:"name:lpdwNumPorts;pointer:ref" json:"ports_length"`
	// Return: The FAX_EnumPortsEx return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumPortsExResponse) xxx_ToOp(ctx context.Context, op *xxx_EnumPortsExOperation) *xxx_EnumPortsExOperation {
	if op == nil {
		op = &xxx_EnumPortsExOperation{}
	}
	if o == nil {
		return op
	}
	op.Buffer = o.Buffer
	op.BufferSize = o.BufferSize
	op.PortsLength = o.PortsLength
	op.Return = o.Return
	return op
}

func (o *EnumPortsExResponse) xxx_FromOp(ctx context.Context, op *xxx_EnumPortsExOperation) {
	if o == nil {
		return
	}
	o.Buffer = op.Buffer
	o.BufferSize = op.BufferSize
	o.PortsLength = op.PortsLength
	o.Return = op.Return
}
func (o *EnumPortsExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumPortsExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumPortsExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetExtensionDataOperation structure represents the FAX_GetExtensionData operation
type xxx_GetExtensionDataOperation struct {
	DeviceID uint32 `idl:"name:dwDeviceId" json:"device_id"`
	NameGUID string `idl:"name:lpcwstrNameGUID;string;pointer:ref" json:"name_guid"`
	Data     []byte `idl:"name:ppData;size_is:(, lpdwDataSize)" json:"data"`
	DataSize uint32 `idl:"name:lpdwDataSize;pointer:ref" json:"data_size"`
	Return   uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetExtensionDataOperation) OpNum() int { return 49 }

func (o *xxx_GetExtensionDataOperation) OpName() string { return "/fax/v4/FAX_GetExtensionData" }

func (o *xxx_GetExtensionDataOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetExtensionDataOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// dwDeviceId {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DeviceID); err != nil {
			return err
		}
	}
	// lpcwstrNameGUID {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.NameGUID); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetExtensionDataOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// dwDeviceId {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DeviceID); err != nil {
			return err
		}
	}
	// lpcwstrNameGUID {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.NameGUID); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetExtensionDataOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Data != nil && o.DataSize == 0 {
		o.DataSize = uint32(len(o.Data))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetExtensionDataOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ppData {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE}*(1))(3:{alias=BYTE}[dim:0,size_is=lpdwDataSize](uchar))
	{
		if o.Data != nil || o.DataSize > 0 {
			_ptr_ppData := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.DataSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Data {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Data[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Data); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Data, _ptr_ppData); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpdwDataSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DataSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetExtensionDataOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ppData {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE,pointer=ref}*(1))(3:{alias=BYTE}[dim:0,size_is=lpdwDataSize](uchar))
	{
		_ptr_ppData := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Data", sizeInfo[0])
			}
			o.Data = make([]byte, sizeInfo[0])
			for i1 := range o.Data {
				i1 := i1
				if err := w.ReadData(&o.Data[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_ppData := func(ptr interface{}) { o.Data = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Data, _s_ppData, _ptr_ppData); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpdwDataSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DataSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetExtensionDataRequest structure represents the FAX_GetExtensionData operation request
type GetExtensionDataRequest struct {
	// dwDeviceId: The device identifier. A value of zero indicates the caller requests
	// a named data BLOB that is not associated with any specific device. This value can
	// be used to store configurations that affect all the devices. For example, an Optical
	// Character Recognition (OCR) routing extension might export several different routing
	// methods that all rely on the same OCR parameters. This routing extension can associate
	// the OCR configuration with a non-specific device so that it would become global.
	DeviceID uint32 `idl:"name:dwDeviceId" json:"device_id"`
	// lpcwstrNameGUID: A curly-braced GUID string that identifies the data to return. The
	// GUID can identify a routing extension or a routing method.Because GUIDs are unique,
	// the server determines from the specific GUID value whether the call is requesting
	// routing extension data or routing method data.
	NameGUID string `idl:"name:lpcwstrNameGUID;string;pointer:ref" json:"name_guid"`
}

func (o *GetExtensionDataRequest) xxx_ToOp(ctx context.Context, op *xxx_GetExtensionDataOperation) *xxx_GetExtensionDataOperation {
	if op == nil {
		op = &xxx_GetExtensionDataOperation{}
	}
	if o == nil {
		return op
	}
	op.DeviceID = o.DeviceID
	op.NameGUID = o.NameGUID
	return op
}

func (o *GetExtensionDataRequest) xxx_FromOp(ctx context.Context, op *xxx_GetExtensionDataOperation) {
	if o == nil {
		return
	}
	o.DeviceID = op.DeviceID
	o.NameGUID = op.NameGUID
}
func (o *GetExtensionDataRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetExtensionDataRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetExtensionDataOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetExtensionDataResponse structure represents the FAX_GetExtensionData operation response
type GetExtensionDataResponse struct {
	// ppData: A pointer to an allocated private data buffer. This buffer contains the data
	// that is returned by the fax server. For the default routing methods described in
	// section 2.2.87, this data is a null-terminated character string containing an EmailID,
	// Printer, or Folder name. For other routing extensions or methods the format of this
	// data depends on the respective routing extension or routing method and SHOULD be
	// treated as opaque binary data by the fax server.
	Data []byte `idl:"name:ppData;size_is:(, lpdwDataSize)" json:"data"`
	// lpdwDataSize: A pointer to a DWORD ([MS-DTYP] section 2.2.9) value that returns the
	// size, in bytes, of the data that is pointed to by the ppData parameter.
	DataSize uint32 `idl:"name:lpdwDataSize;pointer:ref" json:"data_size"`
	// Return: The FAX_GetExtensionData return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetExtensionDataResponse) xxx_ToOp(ctx context.Context, op *xxx_GetExtensionDataOperation) *xxx_GetExtensionDataOperation {
	if op == nil {
		op = &xxx_GetExtensionDataOperation{}
	}
	if o == nil {
		return op
	}
	op.Data = o.Data
	op.DataSize = o.DataSize
	op.Return = o.Return
	return op
}

func (o *GetExtensionDataResponse) xxx_FromOp(ctx context.Context, op *xxx_GetExtensionDataOperation) {
	if o == nil {
		return
	}
	o.Data = op.Data
	o.DataSize = op.DataSize
	o.Return = op.Return
}
func (o *GetExtensionDataResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetExtensionDataResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetExtensionDataOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetExtensionDataOperation structure represents the FAX_SetExtensionData operation
type xxx_SetExtensionDataOperation struct {
	ComputerName string `idl:"name:lpcwstrComputerName;string" json:"computer_name"`
	DeviceID     uint32 `idl:"name:dwDeviceId" json:"device_id"`
	NameGUID     string `idl:"name:lpcwstrNameGUID;string" json:"name_guid"`
	Data         []byte `idl:"name:pData;size_is:(dwDataSize);pointer:ref" json:"data"`
	DataSize     uint32 `idl:"name:dwDataSize" json:"data_size"`
	Return       uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_SetExtensionDataOperation) OpNum() int { return 50 }

func (o *xxx_SetExtensionDataOperation) OpName() string { return "/fax/v4/FAX_SetExtensionData" }

func (o *xxx_SetExtensionDataOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.Data != nil && o.DataSize == 0 {
		o.DataSize = uint32(len(o.Data))
	}
	if o.DataSize > uint32(1048576) {
		return fmt.Errorf("DataSize is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetExtensionDataOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lpcwstrComputerName {in} (1:{string, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ComputerName); err != nil {
			return err
		}
	}
	// dwDeviceId {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DeviceID); err != nil {
			return err
		}
	}
	// lpcwstrNameGUID {in} (1:{string, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.NameGUID); err != nil {
			return err
		}
	}
	// pData {in} (1:{pointer=ref, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=dwDataSize](uchar))
	{
		dimSize1 := uint64(o.DataSize)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.Data {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.Data[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.Data); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// dwDataSize {in} (1:{range=(0,1048576), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DataSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetExtensionDataOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lpcwstrComputerName {in} (1:{string, alias=LPCWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ComputerName); err != nil {
			return err
		}
	}
	// dwDeviceId {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DeviceID); err != nil {
			return err
		}
	}
	// lpcwstrNameGUID {in} (1:{string, alias=LPCWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.NameGUID); err != nil {
			return err
		}
	}
	// pData {in} (1:{pointer=ref, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=dwDataSize](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Data", sizeInfo[0])
		}
		o.Data = make([]byte, sizeInfo[0])
		for i1 := range o.Data {
			i1 := i1
			if err := w.ReadData(&o.Data[i1]); err != nil {
				return err
			}
		}
	}
	// dwDataSize {in} (1:{range=(0,1048576), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DataSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetExtensionDataOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetExtensionDataOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetExtensionDataOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetExtensionDataRequest structure represents the FAX_SetExtensionData operation request
type SetExtensionDataRequest struct {
	// lpcwstrComputerName: A null-terminated character string that SHOULD hold the name
	// of the client computer.
	ComputerName string `idl:"name:lpcwstrComputerName;string" json:"computer_name"`
	// dwDeviceId: A DWORD ([MS-DTYP] section 2.2.9) value of the unique device identifier.
	// A value of zero indicates the caller needs to set a named data BLOB that is not associated
	// with any specific device. This value can be used to store configurations that affect
	// all the devices. For example, an Optical Character Recognition (OCR) routing extension
	// might export several different routing methods that all rely on the same OCR parameters.
	// This routing extension can associate the OCR configuration with a non-specific device
	// so that it becomes global.
	DeviceID uint32 `idl:"name:dwDeviceId" json:"device_id"`
	// lpcwstrNameGUID: A curly-braced GUID string that identifies the data to set. The
	// GUID can identify a routing extension or a routing method. Because GUIDs are unique,
	// the server determines from the specific GUID value whether the call is requesting
	// to set routing extension data or routing method data. If some data is already set
	// for the specified GUID, the fax server SHOULD replace it with the new data that is
	// pointed to by the pData parameter.
	NameGUID string `idl:"name:lpcwstrNameGUID;string" json:"name_guid"`
	// pData: A pointer to the data buffer to set. For the default routing methods described
	// in the Default Routing Methods (section 2.2.87) this data is a null-terminated character
	// string containing an EmailID, Printer, or Folder name. For other routing extensions
	// or methods the format of this data depends on the respective routing extension or
	// routing method and SHOULD be treated as opaque binary data by the fax server.
	Data []byte `idl:"name:pData;size_is:(dwDataSize);pointer:ref" json:"data"`
	// dwDataSize: A DWORD value that indicates the size, in bytes, of the pData buffer.
	// The maximum size is FAX_MAX_RPC_BUFFER (section 2.2.82).
	DataSize uint32 `idl:"name:dwDataSize" json:"data_size"`
}

func (o *SetExtensionDataRequest) xxx_ToOp(ctx context.Context, op *xxx_SetExtensionDataOperation) *xxx_SetExtensionDataOperation {
	if op == nil {
		op = &xxx_SetExtensionDataOperation{}
	}
	if o == nil {
		return op
	}
	op.ComputerName = o.ComputerName
	op.DeviceID = o.DeviceID
	op.NameGUID = o.NameGUID
	op.Data = o.Data
	op.DataSize = o.DataSize
	return op
}

func (o *SetExtensionDataRequest) xxx_FromOp(ctx context.Context, op *xxx_SetExtensionDataOperation) {
	if o == nil {
		return
	}
	o.ComputerName = op.ComputerName
	o.DeviceID = op.DeviceID
	o.NameGUID = op.NameGUID
	o.Data = op.Data
	o.DataSize = op.DataSize
}
func (o *SetExtensionDataRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetExtensionDataRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetExtensionDataOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetExtensionDataResponse structure represents the FAX_SetExtensionData operation response
type SetExtensionDataResponse struct {
	// Return: The FAX_SetExtensionData return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetExtensionDataResponse) xxx_ToOp(ctx context.Context, op *xxx_SetExtensionDataOperation) *xxx_SetExtensionDataOperation {
	if op == nil {
		op = &xxx_SetExtensionDataOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetExtensionDataResponse) xxx_FromOp(ctx context.Context, op *xxx_SetExtensionDataOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetExtensionDataResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetExtensionDataResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetExtensionDataOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddOutboundGroupOperation structure represents the FAX_AddOutboundGroup operation
type xxx_AddOutboundGroupOperation struct {
	GroupName string `idl:"name:lpwstrGroupName;string;pointer:ref" json:"group_name"`
	Return    uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_AddOutboundGroupOperation) OpNum() int { return 51 }

func (o *xxx_AddOutboundGroupOperation) OpName() string { return "/fax/v4/FAX_AddOutboundGroup" }

func (o *xxx_AddOutboundGroupOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddOutboundGroupOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lpwstrGroupName {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.GroupName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddOutboundGroupOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lpwstrGroupName {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.GroupName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddOutboundGroupOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddOutboundGroupOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddOutboundGroupOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddOutboundGroupRequest structure represents the FAX_AddOutboundGroup operation request
type AddOutboundGroupRequest struct {
	// lpwstrGroupName: A pointer to a null-terminated character string that uniquely identifies
	// a new group name. This value cannot be NULL. The group name is expected to be case-insensitive.
	GroupName string `idl:"name:lpwstrGroupName;string;pointer:ref" json:"group_name"`
}

func (o *AddOutboundGroupRequest) xxx_ToOp(ctx context.Context, op *xxx_AddOutboundGroupOperation) *xxx_AddOutboundGroupOperation {
	if op == nil {
		op = &xxx_AddOutboundGroupOperation{}
	}
	if o == nil {
		return op
	}
	op.GroupName = o.GroupName
	return op
}

func (o *AddOutboundGroupRequest) xxx_FromOp(ctx context.Context, op *xxx_AddOutboundGroupOperation) {
	if o == nil {
		return
	}
	o.GroupName = op.GroupName
}
func (o *AddOutboundGroupRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *AddOutboundGroupRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddOutboundGroupOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddOutboundGroupResponse structure represents the FAX_AddOutboundGroup operation response
type AddOutboundGroupResponse struct {
	// Return: The FAX_AddOutboundGroup return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddOutboundGroupResponse) xxx_ToOp(ctx context.Context, op *xxx_AddOutboundGroupOperation) *xxx_AddOutboundGroupOperation {
	if op == nil {
		op = &xxx_AddOutboundGroupOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *AddOutboundGroupResponse) xxx_FromOp(ctx context.Context, op *xxx_AddOutboundGroupOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *AddOutboundGroupResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *AddOutboundGroupResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddOutboundGroupOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetOutboundGroupOperation structure represents the FAX_SetOutboundGroup operation
type xxx_SetOutboundGroupOperation struct {
	Group  *fax.OutboundRoutingGroupw `idl:"name:pGroup;pointer:ref" json:"group"`
	Return uint32                     `idl:"name:Return" json:"return"`
}

func (o *xxx_SetOutboundGroupOperation) OpNum() int { return 52 }

func (o *xxx_SetOutboundGroupOperation) OpName() string { return "/fax/v4/FAX_SetOutboundGroup" }

func (o *xxx_SetOutboundGroupOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOutboundGroupOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// pGroup {in} (1:{pointer=ref, alias=PRPC_FAX_OUTBOUND_ROUTING_GROUPW}*(1))(2:{alias=RPC_FAX_OUTBOUND_ROUTING_GROUPW}(struct))
	{
		if o.Group != nil {
			if err := o.Group.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.OutboundRoutingGroupw{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOutboundGroupOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// pGroup {in} (1:{pointer=ref, alias=PRPC_FAX_OUTBOUND_ROUTING_GROUPW}*(1))(2:{alias=RPC_FAX_OUTBOUND_ROUTING_GROUPW}(struct))
	{
		if o.Group == nil {
			o.Group = &fax.OutboundRoutingGroupw{}
		}
		if err := o.Group.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOutboundGroupOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOutboundGroupOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOutboundGroupOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetOutboundGroupRequest structure represents the FAX_SetOutboundGroup operation request
type SetOutboundGroupRequest struct {
	// pGroup: A pointer to an RPC_FAX_OUTBOUND_ROUTING_GROUPW buffer to set.
	Group *fax.OutboundRoutingGroupw `idl:"name:pGroup;pointer:ref" json:"group"`
}

func (o *SetOutboundGroupRequest) xxx_ToOp(ctx context.Context, op *xxx_SetOutboundGroupOperation) *xxx_SetOutboundGroupOperation {
	if op == nil {
		op = &xxx_SetOutboundGroupOperation{}
	}
	if o == nil {
		return op
	}
	op.Group = o.Group
	return op
}

func (o *SetOutboundGroupRequest) xxx_FromOp(ctx context.Context, op *xxx_SetOutboundGroupOperation) {
	if o == nil {
		return
	}
	o.Group = op.Group
}
func (o *SetOutboundGroupRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetOutboundGroupRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetOutboundGroupOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetOutboundGroupResponse structure represents the FAX_SetOutboundGroup operation response
type SetOutboundGroupResponse struct {
	// Return: The FAX_SetOutboundGroup return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetOutboundGroupResponse) xxx_ToOp(ctx context.Context, op *xxx_SetOutboundGroupOperation) *xxx_SetOutboundGroupOperation {
	if op == nil {
		op = &xxx_SetOutboundGroupOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetOutboundGroupResponse) xxx_FromOp(ctx context.Context, op *xxx_SetOutboundGroupOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetOutboundGroupResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetOutboundGroupResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetOutboundGroupOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_RemoveOutboundGroupOperation structure represents the FAX_RemoveOutboundGroup operation
type xxx_RemoveOutboundGroupOperation struct {
	GroupName string `idl:"name:lpwstrGroupName;string;pointer:ref" json:"group_name"`
	Return    uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_RemoveOutboundGroupOperation) OpNum() int { return 53 }

func (o *xxx_RemoveOutboundGroupOperation) OpName() string { return "/fax/v4/FAX_RemoveOutboundGroup" }

func (o *xxx_RemoveOutboundGroupOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveOutboundGroupOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lpwstrGroupName {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.GroupName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveOutboundGroupOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lpwstrGroupName {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.GroupName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveOutboundGroupOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveOutboundGroupOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveOutboundGroupOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// RemoveOutboundGroupRequest structure represents the FAX_RemoveOutboundGroup operation request
type RemoveOutboundGroupRequest struct {
	// lpwstrGroupName: A pointer to a null-terminated string that uniquely identifies an
	// existing group name. The group name is expected to be case-insensitive.
	GroupName string `idl:"name:lpwstrGroupName;string;pointer:ref" json:"group_name"`
}

func (o *RemoveOutboundGroupRequest) xxx_ToOp(ctx context.Context, op *xxx_RemoveOutboundGroupOperation) *xxx_RemoveOutboundGroupOperation {
	if op == nil {
		op = &xxx_RemoveOutboundGroupOperation{}
	}
	if o == nil {
		return op
	}
	op.GroupName = o.GroupName
	return op
}

func (o *RemoveOutboundGroupRequest) xxx_FromOp(ctx context.Context, op *xxx_RemoveOutboundGroupOperation) {
	if o == nil {
		return
	}
	o.GroupName = op.GroupName
}
func (o *RemoveOutboundGroupRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *RemoveOutboundGroupRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemoveOutboundGroupOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// RemoveOutboundGroupResponse structure represents the FAX_RemoveOutboundGroup operation response
type RemoveOutboundGroupResponse struct {
	// Return: The FAX_RemoveOutboundGroup return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *RemoveOutboundGroupResponse) xxx_ToOp(ctx context.Context, op *xxx_RemoveOutboundGroupOperation) *xxx_RemoveOutboundGroupOperation {
	if op == nil {
		op = &xxx_RemoveOutboundGroupOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *RemoveOutboundGroupResponse) xxx_FromOp(ctx context.Context, op *xxx_RemoveOutboundGroupOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *RemoveOutboundGroupResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *RemoveOutboundGroupResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemoveOutboundGroupOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumOutboundGroupsOperation structure represents the FAX_EnumOutboundGroups operation
type xxx_EnumOutboundGroupsOperation struct {
	Data         []byte `idl:"name:ppData;size_is:(, lpdwDataSize)" json:"data"`
	DataSize     uint32 `idl:"name:lpdwDataSize;pointer:ref" json:"data_size"`
	GroupsLength uint32 `idl:"name:lpdwNumGroups;pointer:ref" json:"groups_length"`
	Return       uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumOutboundGroupsOperation) OpNum() int { return 54 }

func (o *xxx_EnumOutboundGroupsOperation) OpName() string { return "/fax/v4/FAX_EnumOutboundGroups" }

func (o *xxx_EnumOutboundGroupsOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumOutboundGroupsOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	return nil
}

func (o *xxx_EnumOutboundGroupsOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	return nil
}

func (o *xxx_EnumOutboundGroupsOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Data != nil && o.DataSize == 0 {
		o.DataSize = uint32(len(o.Data))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumOutboundGroupsOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ppData {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE}*(1))(3:{alias=BYTE}[dim:0,size_is=lpdwDataSize](uchar))
	{
		if o.Data != nil || o.DataSize > 0 {
			_ptr_ppData := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.DataSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Data {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Data[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Data); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Data, _ptr_ppData); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpdwDataSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DataSize); err != nil {
			return err
		}
	}
	// lpdwNumGroups {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.GroupsLength); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumOutboundGroupsOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ppData {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE,pointer=ref}*(1))(3:{alias=BYTE}[dim:0,size_is=lpdwDataSize](uchar))
	{
		_ptr_ppData := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Data", sizeInfo[0])
			}
			o.Data = make([]byte, sizeInfo[0])
			for i1 := range o.Data {
				i1 := i1
				if err := w.ReadData(&o.Data[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_ppData := func(ptr interface{}) { o.Data = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Data, _s_ppData, _ptr_ppData); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpdwDataSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DataSize); err != nil {
			return err
		}
	}
	// lpdwNumGroups {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.GroupsLength); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumOutboundGroupsRequest structure represents the FAX_EnumOutboundGroups operation request
type EnumOutboundGroupsRequest struct {
}

func (o *EnumOutboundGroupsRequest) xxx_ToOp(ctx context.Context, op *xxx_EnumOutboundGroupsOperation) *xxx_EnumOutboundGroupsOperation {
	if op == nil {
		op = &xxx_EnumOutboundGroupsOperation{}
	}
	if o == nil {
		return op
	}
	return op
}

func (o *EnumOutboundGroupsRequest) xxx_FromOp(ctx context.Context, op *xxx_EnumOutboundGroupsOperation) {
	if o == nil {
		return
	}
}
func (o *EnumOutboundGroupsRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumOutboundGroupsRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumOutboundGroupsOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumOutboundGroupsResponse structure represents the FAX_EnumOutboundGroups operation response
type EnumOutboundGroupsResponse struct {
	// ppData: The address of a pointer to a buffer containing an array of _RPC_FAX_OUTBOUND_ROUTING_GROUPW
	// (section 2.2.40) structures.
	Data []byte `idl:"name:ppData;size_is:(, lpdwDataSize)" json:"data"`
	// lpdwDataSize: The size, in bytes, of the returned ppData buffer.
	DataSize uint32 `idl:"name:lpdwDataSize;pointer:ref" json:"data_size"`
	// lpdwNumGroups: The number of groups that are returned.
	GroupsLength uint32 `idl:"name:lpdwNumGroups;pointer:ref" json:"groups_length"`
	// Return: The FAX_EnumOutboundGroups return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumOutboundGroupsResponse) xxx_ToOp(ctx context.Context, op *xxx_EnumOutboundGroupsOperation) *xxx_EnumOutboundGroupsOperation {
	if op == nil {
		op = &xxx_EnumOutboundGroupsOperation{}
	}
	if o == nil {
		return op
	}
	op.Data = o.Data
	op.DataSize = o.DataSize
	op.GroupsLength = o.GroupsLength
	op.Return = o.Return
	return op
}

func (o *EnumOutboundGroupsResponse) xxx_FromOp(ctx context.Context, op *xxx_EnumOutboundGroupsOperation) {
	if o == nil {
		return
	}
	o.Data = op.Data
	o.DataSize = op.DataSize
	o.GroupsLength = op.GroupsLength
	o.Return = op.Return
}
func (o *EnumOutboundGroupsResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumOutboundGroupsResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumOutboundGroupsOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetDeviceOrderInGroupOperation structure represents the FAX_SetDeviceOrderInGroup operation
type xxx_SetDeviceOrderInGroupOperation struct {
	GroupName string `idl:"name:lpwstrGroupName;string;pointer:ref" json:"group_name"`
	DeviceID  uint32 `idl:"name:dwDeviceId" json:"device_id"`
	NewOrder  uint32 `idl:"name:dwNewOrder" json:"new_order"`
	Return    uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_SetDeviceOrderInGroupOperation) OpNum() int { return 55 }

func (o *xxx_SetDeviceOrderInGroupOperation) OpName() string {
	return "/fax/v4/FAX_SetDeviceOrderInGroup"
}

func (o *xxx_SetDeviceOrderInGroupOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetDeviceOrderInGroupOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lpwstrGroupName {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.GroupName); err != nil {
			return err
		}
	}
	// dwDeviceId {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DeviceID); err != nil {
			return err
		}
	}
	// dwNewOrder {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.NewOrder); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetDeviceOrderInGroupOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lpwstrGroupName {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.GroupName); err != nil {
			return err
		}
	}
	// dwDeviceId {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DeviceID); err != nil {
			return err
		}
	}
	// dwNewOrder {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.NewOrder); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetDeviceOrderInGroupOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetDeviceOrderInGroupOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetDeviceOrderInGroupOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetDeviceOrderInGroupRequest structure represents the FAX_SetDeviceOrderInGroup operation request
type SetDeviceOrderInGroupRequest struct {
	// lpwstrGroupName: A pointer to a null-terminated string that uniquely identifies a
	// group. Group names SHOULD be case-insensitive.
	GroupName string `idl:"name:lpwstrGroupName;string;pointer:ref" json:"group_name"`
	// dwDeviceId: A DWORD ([MS-DTYP] section 2.2.9) value specifying the identifier of
	// the device in the group. The specified device MUST exist in the group.
	DeviceID uint32 `idl:"name:dwDeviceId" json:"device_id"`
	// dwNewOrder: A DWORD value specifying the new 1-based order of the device in the group.
	// If there are N devices in the group, this value MUST be between 1 and N (inclusive).
	// Other devices are moved up or down in the group to place the specified device in
	// the specified order.
	NewOrder uint32 `idl:"name:dwNewOrder" json:"new_order"`
}

func (o *SetDeviceOrderInGroupRequest) xxx_ToOp(ctx context.Context, op *xxx_SetDeviceOrderInGroupOperation) *xxx_SetDeviceOrderInGroupOperation {
	if op == nil {
		op = &xxx_SetDeviceOrderInGroupOperation{}
	}
	if o == nil {
		return op
	}
	op.GroupName = o.GroupName
	op.DeviceID = o.DeviceID
	op.NewOrder = o.NewOrder
	return op
}

func (o *SetDeviceOrderInGroupRequest) xxx_FromOp(ctx context.Context, op *xxx_SetDeviceOrderInGroupOperation) {
	if o == nil {
		return
	}
	o.GroupName = op.GroupName
	o.DeviceID = op.DeviceID
	o.NewOrder = op.NewOrder
}
func (o *SetDeviceOrderInGroupRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetDeviceOrderInGroupRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetDeviceOrderInGroupOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetDeviceOrderInGroupResponse structure represents the FAX_SetDeviceOrderInGroup operation response
type SetDeviceOrderInGroupResponse struct {
	// Return: The FAX_SetDeviceOrderInGroup return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetDeviceOrderInGroupResponse) xxx_ToOp(ctx context.Context, op *xxx_SetDeviceOrderInGroupOperation) *xxx_SetDeviceOrderInGroupOperation {
	if op == nil {
		op = &xxx_SetDeviceOrderInGroupOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetDeviceOrderInGroupResponse) xxx_FromOp(ctx context.Context, op *xxx_SetDeviceOrderInGroupOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetDeviceOrderInGroupResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetDeviceOrderInGroupResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetDeviceOrderInGroupOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddOutboundRuleOperation structure represents the FAX_AddOutboundRule operation
type xxx_AddOutboundRuleOperation struct {
	AreaCode    uint32 `idl:"name:dwAreaCode" json:"area_code"`
	CountryCode uint32 `idl:"name:dwCountryCode" json:"country_code"`
	DeviceID    uint32 `idl:"name:dwDeviceId" json:"device_id"`
	GroupName   string `idl:"name:lpwstrGroupName;string;pointer:unique" json:"group_name"`
	UseGroup    bool   `idl:"name:bUseGroup" json:"use_group"`
	Return      uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_AddOutboundRuleOperation) OpNum() int { return 56 }

func (o *xxx_AddOutboundRuleOperation) OpName() string { return "/fax/v4/FAX_AddOutboundRule" }

func (o *xxx_AddOutboundRuleOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddOutboundRuleOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// dwAreaCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.AreaCode); err != nil {
			return err
		}
	}
	// dwCountryCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.CountryCode); err != nil {
			return err
		}
	}
	// dwDeviceId {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DeviceID); err != nil {
			return err
		}
	}
	// lpwstrGroupName {in} (1:{string, pointer=unique, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.GroupName != "" {
			_ptr_lpwstrGroupName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.GroupName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.GroupName, _ptr_lpwstrGroupName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// bUseGroup {in} (1:{alias=BOOL}(int32))
	{
		if !o.UseGroup {
			if err := w.WriteData(int32(0)); err != nil {
				return err
			}
		} else {
			if err := w.WriteData(int32(1)); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_AddOutboundRuleOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// dwAreaCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.AreaCode); err != nil {
			return err
		}
	}
	// dwCountryCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.CountryCode); err != nil {
			return err
		}
	}
	// dwDeviceId {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DeviceID); err != nil {
			return err
		}
	}
	// lpwstrGroupName {in} (1:{string, pointer=unique, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_lpwstrGroupName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.GroupName); err != nil {
				return err
			}
			return nil
		})
		_s_lpwstrGroupName := func(ptr interface{}) { o.GroupName = *ptr.(*string) }
		if err := w.ReadPointer(&o.GroupName, _s_lpwstrGroupName, _ptr_lpwstrGroupName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// bUseGroup {in} (1:{alias=BOOL}(int32))
	{
		var _bUseGroup int32
		if err := w.ReadData(&_bUseGroup); err != nil {
			return err
		}
		o.UseGroup = _bUseGroup != 0
	}
	return nil
}

func (o *xxx_AddOutboundRuleOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddOutboundRuleOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddOutboundRuleOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddOutboundRuleRequest structure represents the FAX_AddOutboundRule operation request
type AddOutboundRuleRequest struct {
	// dwAreaCode: The area code of the rule. A value of zero indicates the special any-area
	// value ROUTING_RULE_AREA_CODE_ANY. The combination of the dwAreaCode and dwCountryCode
	// parameters is a unique key.
	AreaCode uint32 `idl:"name:dwAreaCode" json:"area_code"`
	// dwCountryCode: The country/region code of the rule. The value of this argument MUST
	// NOT be zero. A value of zero indicates the special any-country, any-region value
	// ROUTING_RULE_COUNTRY_CODE_ANY, which is not valid for this argument. The combination
	// of dwAreaCode and dwCountryCode is a unique key.
	CountryCode uint32 `idl:"name:dwCountryCode" json:"country_code"`
	// dwDeviceId: The destination device of the rule. This value is valid only if the bUseGroup
	// parameter is FALSE. The value of dwDeviceId MUST be greater than zero.
	DeviceID uint32 `idl:"name:dwDeviceId" json:"device_id"`
	// lpwstrGroupName: The destination group of the rule. This value is valid only if bUseGroup
	// is TRUE.
	GroupName string `idl:"name:lpwstrGroupName;string;pointer:unique" json:"group_name"`
	// bUseGroup: A Boolean value that specifies whether the group SHOULD be used as the
	// destination.
	UseGroup bool `idl:"name:bUseGroup" json:"use_group"`
}

func (o *AddOutboundRuleRequest) xxx_ToOp(ctx context.Context, op *xxx_AddOutboundRuleOperation) *xxx_AddOutboundRuleOperation {
	if op == nil {
		op = &xxx_AddOutboundRuleOperation{}
	}
	if o == nil {
		return op
	}
	op.AreaCode = o.AreaCode
	op.CountryCode = o.CountryCode
	op.DeviceID = o.DeviceID
	op.GroupName = o.GroupName
	op.UseGroup = o.UseGroup
	return op
}

func (o *AddOutboundRuleRequest) xxx_FromOp(ctx context.Context, op *xxx_AddOutboundRuleOperation) {
	if o == nil {
		return
	}
	o.AreaCode = op.AreaCode
	o.CountryCode = op.CountryCode
	o.DeviceID = op.DeviceID
	o.GroupName = op.GroupName
	o.UseGroup = op.UseGroup
}
func (o *AddOutboundRuleRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *AddOutboundRuleRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddOutboundRuleOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddOutboundRuleResponse structure represents the FAX_AddOutboundRule operation response
type AddOutboundRuleResponse struct {
	// Return: The FAX_AddOutboundRule return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddOutboundRuleResponse) xxx_ToOp(ctx context.Context, op *xxx_AddOutboundRuleOperation) *xxx_AddOutboundRuleOperation {
	if op == nil {
		op = &xxx_AddOutboundRuleOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *AddOutboundRuleResponse) xxx_FromOp(ctx context.Context, op *xxx_AddOutboundRuleOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *AddOutboundRuleResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *AddOutboundRuleResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddOutboundRuleOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_RemoveOutboundRuleOperation structure represents the FAX_RemoveOutboundRule operation
type xxx_RemoveOutboundRuleOperation struct {
	AreaCode    uint32 `idl:"name:dwAreaCode" json:"area_code"`
	CountryCode uint32 `idl:"name:dwCountryCode" json:"country_code"`
	Return      uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_RemoveOutboundRuleOperation) OpNum() int { return 57 }

func (o *xxx_RemoveOutboundRuleOperation) OpName() string { return "/fax/v4/FAX_RemoveOutboundRule" }

func (o *xxx_RemoveOutboundRuleOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveOutboundRuleOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// dwAreaCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.AreaCode); err != nil {
			return err
		}
	}
	// dwCountryCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.CountryCode); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveOutboundRuleOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// dwAreaCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.AreaCode); err != nil {
			return err
		}
	}
	// dwCountryCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.CountryCode); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveOutboundRuleOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveOutboundRuleOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveOutboundRuleOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// RemoveOutboundRuleRequest structure represents the FAX_RemoveOutboundRule operation request
type RemoveOutboundRuleRequest struct {
	// dwAreaCode: The area code of the rule. The combination of the dwAreaCode and dwCountryCode
	// parameters are a unique key.
	AreaCode uint32 `idl:"name:dwAreaCode" json:"area_code"`
	// dwCountryCode: The country code of the rule. The combination of dwAreaCode and dwCountryCode
	// are a unique key.
	CountryCode uint32 `idl:"name:dwCountryCode" json:"country_code"`
}

func (o *RemoveOutboundRuleRequest) xxx_ToOp(ctx context.Context, op *xxx_RemoveOutboundRuleOperation) *xxx_RemoveOutboundRuleOperation {
	if op == nil {
		op = &xxx_RemoveOutboundRuleOperation{}
	}
	if o == nil {
		return op
	}
	op.AreaCode = o.AreaCode
	op.CountryCode = o.CountryCode
	return op
}

func (o *RemoveOutboundRuleRequest) xxx_FromOp(ctx context.Context, op *xxx_RemoveOutboundRuleOperation) {
	if o == nil {
		return
	}
	o.AreaCode = op.AreaCode
	o.CountryCode = op.CountryCode
}
func (o *RemoveOutboundRuleRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *RemoveOutboundRuleRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemoveOutboundRuleOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// RemoveOutboundRuleResponse structure represents the FAX_RemoveOutboundRule operation response
type RemoveOutboundRuleResponse struct {
	// Return: The FAX_RemoveOutboundRule return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *RemoveOutboundRuleResponse) xxx_ToOp(ctx context.Context, op *xxx_RemoveOutboundRuleOperation) *xxx_RemoveOutboundRuleOperation {
	if op == nil {
		op = &xxx_RemoveOutboundRuleOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *RemoveOutboundRuleResponse) xxx_FromOp(ctx context.Context, op *xxx_RemoveOutboundRuleOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *RemoveOutboundRuleResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *RemoveOutboundRuleResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemoveOutboundRuleOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetOutboundRuleOperation structure represents the FAX_SetOutboundRule operation
type xxx_SetOutboundRuleOperation struct {
	Rule   *fax.OutboundRoutingRuleW `idl:"name:pRule;pointer:ref" json:"rule"`
	Return uint32                    `idl:"name:Return" json:"return"`
}

func (o *xxx_SetOutboundRuleOperation) OpNum() int { return 58 }

func (o *xxx_SetOutboundRuleOperation) OpName() string { return "/fax/v4/FAX_SetOutboundRule" }

func (o *xxx_SetOutboundRuleOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOutboundRuleOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// pRule {in} (1:{pointer=ref}*(1))(2:{alias=RPC_FAX_OUTBOUND_ROUTING_RULEW}(struct))
	{
		if o.Rule != nil {
			if err := o.Rule.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.OutboundRoutingRuleW{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOutboundRuleOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// pRule {in} (1:{pointer=ref}*(1))(2:{alias=RPC_FAX_OUTBOUND_ROUTING_RULEW}(struct))
	{
		if o.Rule == nil {
			o.Rule = &fax.OutboundRoutingRuleW{}
		}
		if err := o.Rule.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOutboundRuleOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOutboundRuleOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOutboundRuleOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetOutboundRuleRequest structure represents the FAX_SetOutboundRule operation request
type SetOutboundRuleRequest struct {
	// pRule: A pointer to an RPC_FAX_OUTBOUND_ROUTING_RULEW (section 2.2.41) buffer to
	// set.
	Rule *fax.OutboundRoutingRuleW `idl:"name:pRule;pointer:ref" json:"rule"`
}

func (o *SetOutboundRuleRequest) xxx_ToOp(ctx context.Context, op *xxx_SetOutboundRuleOperation) *xxx_SetOutboundRuleOperation {
	if op == nil {
		op = &xxx_SetOutboundRuleOperation{}
	}
	if o == nil {
		return op
	}
	op.Rule = o.Rule
	return op
}

func (o *SetOutboundRuleRequest) xxx_FromOp(ctx context.Context, op *xxx_SetOutboundRuleOperation) {
	if o == nil {
		return
	}
	o.Rule = op.Rule
}
func (o *SetOutboundRuleRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetOutboundRuleRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetOutboundRuleOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetOutboundRuleResponse structure represents the FAX_SetOutboundRule operation response
type SetOutboundRuleResponse struct {
	// Return: The FAX_SetOutboundRule return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetOutboundRuleResponse) xxx_ToOp(ctx context.Context, op *xxx_SetOutboundRuleOperation) *xxx_SetOutboundRuleOperation {
	if op == nil {
		op = &xxx_SetOutboundRuleOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetOutboundRuleResponse) xxx_FromOp(ctx context.Context, op *xxx_SetOutboundRuleOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetOutboundRuleResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetOutboundRuleResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetOutboundRuleOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumOutboundRulesOperation structure represents the FAX_EnumOutboundRules operation
type xxx_EnumOutboundRulesOperation struct {
	Data        []byte `idl:"name:ppData;size_is:(, lpdwDataSize)" json:"data"`
	DataSize    uint32 `idl:"name:lpdwDataSize;pointer:ref" json:"data_size"`
	RulesLength uint32 `idl:"name:lpdwNumRules;pointer:ref" json:"rules_length"`
	Return      uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumOutboundRulesOperation) OpNum() int { return 59 }

func (o *xxx_EnumOutboundRulesOperation) OpName() string { return "/fax/v4/FAX_EnumOutboundRules" }

func (o *xxx_EnumOutboundRulesOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumOutboundRulesOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	return nil
}

func (o *xxx_EnumOutboundRulesOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	return nil
}

func (o *xxx_EnumOutboundRulesOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Data != nil && o.DataSize == 0 {
		o.DataSize = uint32(len(o.Data))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumOutboundRulesOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ppData {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE}*(1))(3:{alias=BYTE}[dim:0,size_is=lpdwDataSize](uchar))
	{
		if o.Data != nil || o.DataSize > 0 {
			_ptr_ppData := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.DataSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Data {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Data[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Data); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Data, _ptr_ppData); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpdwDataSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DataSize); err != nil {
			return err
		}
	}
	// lpdwNumRules {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RulesLength); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumOutboundRulesOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ppData {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE,pointer=ref}*(1))(3:{alias=BYTE}[dim:0,size_is=lpdwDataSize](uchar))
	{
		_ptr_ppData := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Data", sizeInfo[0])
			}
			o.Data = make([]byte, sizeInfo[0])
			for i1 := range o.Data {
				i1 := i1
				if err := w.ReadData(&o.Data[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_ppData := func(ptr interface{}) { o.Data = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Data, _s_ppData, _ptr_ppData); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpdwDataSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DataSize); err != nil {
			return err
		}
	}
	// lpdwNumRules {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RulesLength); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumOutboundRulesRequest structure represents the FAX_EnumOutboundRules operation request
type EnumOutboundRulesRequest struct {
}

func (o *EnumOutboundRulesRequest) xxx_ToOp(ctx context.Context, op *xxx_EnumOutboundRulesOperation) *xxx_EnumOutboundRulesOperation {
	if op == nil {
		op = &xxx_EnumOutboundRulesOperation{}
	}
	if o == nil {
		return op
	}
	return op
}

func (o *EnumOutboundRulesRequest) xxx_FromOp(ctx context.Context, op *xxx_EnumOutboundRulesOperation) {
	if o == nil {
		return
	}
}
func (o *EnumOutboundRulesRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumOutboundRulesRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumOutboundRulesOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumOutboundRulesResponse structure represents the FAX_EnumOutboundRules operation response
type EnumOutboundRulesResponse struct {
	// ppData: A pointer to a buffer containing an array of _RPC_FAX_OUTBOUND_ROUTING_RULEW
	// (section 2.2.42) structures.
	Data []byte `idl:"name:ppData;size_is:(, lpdwDataSize)" json:"data"`
	// lpdwDataSize: A pointer to a DWORD ([MS-DTYP] section 2.2.9) in which to return the
	// size, in bytes, of the lpData buffer.
	DataSize uint32 `idl:"name:lpdwDataSize;pointer:ref" json:"data_size"`
	// lpdwNumRules: A pointer to a DWORD value indicating the number of rules retrieved.
	RulesLength uint32 `idl:"name:lpdwNumRules;pointer:ref" json:"rules_length"`
	// Return: The FAX_EnumOutboundRules return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumOutboundRulesResponse) xxx_ToOp(ctx context.Context, op *xxx_EnumOutboundRulesOperation) *xxx_EnumOutboundRulesOperation {
	if op == nil {
		op = &xxx_EnumOutboundRulesOperation{}
	}
	if o == nil {
		return op
	}
	op.Data = o.Data
	op.DataSize = o.DataSize
	op.RulesLength = o.RulesLength
	op.Return = o.Return
	return op
}

func (o *EnumOutboundRulesResponse) xxx_FromOp(ctx context.Context, op *xxx_EnumOutboundRulesOperation) {
	if o == nil {
		return
	}
	o.Data = op.Data
	o.DataSize = op.DataSize
	o.RulesLength = op.RulesLength
	o.Return = op.Return
}
func (o *EnumOutboundRulesResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumOutboundRulesResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumOutboundRulesOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_RegisterServiceProviderExOperation structure represents the FAX_RegisterServiceProviderEx operation
type xxx_RegisterServiceProviderExOperation struct {
	GUID         string `idl:"name:lpcwstrGUID;string;pointer:ref" json:"guid"`
	FriendlyName string `idl:"name:lpcwstrFriendlyName;string;pointer:ref" json:"friendly_name"`
	ImageName    string `idl:"name:lpcwstrImageName;string;pointer:ref" json:"image_name"`
	TspName      string `idl:"name:lpcwstrTspName;string;pointer:ref" json:"tsp_name"`
	FspiVersion  uint32 `idl:"name:dwFSPIVersion" json:"fspi_version"`
	Capabilities uint32 `idl:"name:dwCapabilities" json:"capabilities"`
	Return       uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_RegisterServiceProviderExOperation) OpNum() int { return 60 }

func (o *xxx_RegisterServiceProviderExOperation) OpName() string {
	return "/fax/v4/FAX_RegisterServiceProviderEx"
}

func (o *xxx_RegisterServiceProviderExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RegisterServiceProviderExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lpcwstrGUID {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.GUID); err != nil {
			return err
		}
	}
	// lpcwstrFriendlyName {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.FriendlyName); err != nil {
			return err
		}
	}
	// lpcwstrImageName {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ImageName); err != nil {
			return err
		}
	}
	// lpcwstrTspName {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.TspName); err != nil {
			return err
		}
	}
	// dwFSPIVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.FspiVersion); err != nil {
			return err
		}
	}
	// dwCapabilities {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Capabilities); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RegisterServiceProviderExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lpcwstrGUID {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.GUID); err != nil {
			return err
		}
	}
	// lpcwstrFriendlyName {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.FriendlyName); err != nil {
			return err
		}
	}
	// lpcwstrImageName {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ImageName); err != nil {
			return err
		}
	}
	// lpcwstrTspName {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.TspName); err != nil {
			return err
		}
	}
	// dwFSPIVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.FspiVersion); err != nil {
			return err
		}
	}
	// dwCapabilities {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Capabilities); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RegisterServiceProviderExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RegisterServiceProviderExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RegisterServiceProviderExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// RegisterServiceProviderExRequest structure represents the FAX_RegisterServiceProviderEx operation request
type RegisterServiceProviderExRequest struct {
	// lpcwstrGUID: A pointer to a constant null-terminated character string that contains
	// a valid string representation of the GUID of the FSP.
	GUID string `idl:"name:lpcwstrGUID;string;pointer:ref" json:"guid"`
	// lpcwstrFriendlyName: A pointer to a constant null-terminated character string to
	// associate with the FSP execution component. This is the FSP friendly name, which
	// is suitable for display. This value cannot exceed MAX_FAX_STRING_LEN (section 2.2.86)
	// characters.
	FriendlyName string `idl:"name:lpcwstrFriendlyName;string;pointer:ref" json:"friendly_name"`
	// lpcwstrImageName: A pointer to a constant null-terminated character string that specifies
	// the full path and file name for the FSP execution component.<148> This value cannot
	// exceed MAX_FAX_STRING_LEN characters.
	ImageName string `idl:"name:lpcwstrImageName;string;pointer:ref" json:"image_name"`
	// lpcwstrTspName: A pointer to a constant null-terminated character string that specifies
	// the name of the telephony service provider that is associated with the devices for
	// the FSP. This parameter SHOULD be set to NULL if the FSP does not use a telephony
	// service provider. This value cannot exceed MAX_FAX_STRING_LEN characters. This value
	// MUST be unique across all registered FSPs.
	TspName string `idl:"name:lpcwstrTspName;string;pointer:ref" json:"tsp_name"`
	// dwFSPIVersion: A DWORD ([MS-DTYP] section 2.2.9) value that specifies the API version
	// of the FSP interface. The value MUST be 0x00010000.
	FspiVersion uint32 `idl:"name:dwFSPIVersion" json:"fspi_version"`
	// dwCapabilities: A DWORD value that specifies the capabilities of the extended FSP.
	// This value MUST be 0.
	Capabilities uint32 `idl:"name:dwCapabilities" json:"capabilities"`
}

func (o *RegisterServiceProviderExRequest) xxx_ToOp(ctx context.Context, op *xxx_RegisterServiceProviderExOperation) *xxx_RegisterServiceProviderExOperation {
	if op == nil {
		op = &xxx_RegisterServiceProviderExOperation{}
	}
	if o == nil {
		return op
	}
	op.GUID = o.GUID
	op.FriendlyName = o.FriendlyName
	op.ImageName = o.ImageName
	op.TspName = o.TspName
	op.FspiVersion = o.FspiVersion
	op.Capabilities = o.Capabilities
	return op
}

func (o *RegisterServiceProviderExRequest) xxx_FromOp(ctx context.Context, op *xxx_RegisterServiceProviderExOperation) {
	if o == nil {
		return
	}
	o.GUID = op.GUID
	o.FriendlyName = op.FriendlyName
	o.ImageName = op.ImageName
	o.TspName = op.TspName
	o.FspiVersion = op.FspiVersion
	o.Capabilities = op.Capabilities
}
func (o *RegisterServiceProviderExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *RegisterServiceProviderExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RegisterServiceProviderExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// RegisterServiceProviderExResponse structure represents the FAX_RegisterServiceProviderEx operation response
type RegisterServiceProviderExResponse struct {
	// Return: The FAX_RegisterServiceProviderEx return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *RegisterServiceProviderExResponse) xxx_ToOp(ctx context.Context, op *xxx_RegisterServiceProviderExOperation) *xxx_RegisterServiceProviderExOperation {
	if op == nil {
		op = &xxx_RegisterServiceProviderExOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *RegisterServiceProviderExResponse) xxx_FromOp(ctx context.Context, op *xxx_RegisterServiceProviderExOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *RegisterServiceProviderExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *RegisterServiceProviderExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RegisterServiceProviderExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_UnregisterServiceProviderExOperation structure represents the FAX_UnregisterServiceProviderEx operation
type xxx_UnregisterServiceProviderExOperation struct {
	GUID   string `idl:"name:lpcwstrGUID;string;pointer:ref" json:"guid"`
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_UnregisterServiceProviderExOperation) OpNum() int { return 61 }

func (o *xxx_UnregisterServiceProviderExOperation) OpName() string {
	return "/fax/v4/FAX_UnregisterServiceProviderEx"
}

func (o *xxx_UnregisterServiceProviderExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UnregisterServiceProviderExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lpcwstrGUID {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.GUID); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UnregisterServiceProviderExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lpcwstrGUID {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.GUID); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UnregisterServiceProviderExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UnregisterServiceProviderExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UnregisterServiceProviderExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// UnregisterServiceProviderExRequest structure represents the FAX_UnregisterServiceProviderEx operation request
type UnregisterServiceProviderExRequest struct {
	// lpcwstrGUID: A pointer to a constant null-terminated character string that contains
	// a valid string representation of the GUID of the fax service provider (FSP). This
	// value can be obtained with the FAX_EnumerateProviders (section 3.1.4.1.19) method.
	GUID string `idl:"name:lpcwstrGUID;string;pointer:ref" json:"guid"`
}

func (o *UnregisterServiceProviderExRequest) xxx_ToOp(ctx context.Context, op *xxx_UnregisterServiceProviderExOperation) *xxx_UnregisterServiceProviderExOperation {
	if op == nil {
		op = &xxx_UnregisterServiceProviderExOperation{}
	}
	if o == nil {
		return op
	}
	op.GUID = o.GUID
	return op
}

func (o *UnregisterServiceProviderExRequest) xxx_FromOp(ctx context.Context, op *xxx_UnregisterServiceProviderExOperation) {
	if o == nil {
		return
	}
	o.GUID = op.GUID
}
func (o *UnregisterServiceProviderExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *UnregisterServiceProviderExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_UnregisterServiceProviderExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// UnregisterServiceProviderExResponse structure represents the FAX_UnregisterServiceProviderEx operation response
type UnregisterServiceProviderExResponse struct {
	// Return: The FAX_UnregisterServiceProviderEx return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *UnregisterServiceProviderExResponse) xxx_ToOp(ctx context.Context, op *xxx_UnregisterServiceProviderExOperation) *xxx_UnregisterServiceProviderExOperation {
	if op == nil {
		op = &xxx_UnregisterServiceProviderExOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *UnregisterServiceProviderExResponse) xxx_FromOp(ctx context.Context, op *xxx_UnregisterServiceProviderExOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *UnregisterServiceProviderExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *UnregisterServiceProviderExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_UnregisterServiceProviderExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_UnregisterRoutingExtensionOperation structure represents the FAX_UnregisterRoutingExtension operation
type xxx_UnregisterRoutingExtensionOperation struct {
	ExtensionName string `idl:"name:lpcwstrExtensionName;string;pointer:ref" json:"extension_name"`
	Return        uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_UnregisterRoutingExtensionOperation) OpNum() int { return 62 }

func (o *xxx_UnregisterRoutingExtensionOperation) OpName() string {
	return "/fax/v4/FAX_UnregisterRoutingExtension"
}

func (o *xxx_UnregisterRoutingExtensionOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UnregisterRoutingExtensionOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lpcwstrExtensionName {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ExtensionName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UnregisterRoutingExtensionOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lpcwstrExtensionName {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ExtensionName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UnregisterRoutingExtensionOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UnregisterRoutingExtensionOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UnregisterRoutingExtensionOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// UnregisterRoutingExtensionRequest structure represents the FAX_UnregisterRoutingExtension operation request
type UnregisterRoutingExtensionRequest struct {
	// lpcwstrExtensionName: Specifies the name of the fax routing extension returned by
	// the FAX_EnumRoutingExtensions (section 3.1.4.1.30) call as the lpcwstrExtensionName
	// field of the FAX_ROUTING_EXTENSION_INFO (section 2.2.49) structure representing the
	// respective fax routing extension.
	ExtensionName string `idl:"name:lpcwstrExtensionName;string;pointer:ref" json:"extension_name"`
}

func (o *UnregisterRoutingExtensionRequest) xxx_ToOp(ctx context.Context, op *xxx_UnregisterRoutingExtensionOperation) *xxx_UnregisterRoutingExtensionOperation {
	if op == nil {
		op = &xxx_UnregisterRoutingExtensionOperation{}
	}
	if o == nil {
		return op
	}
	op.ExtensionName = o.ExtensionName
	return op
}

func (o *UnregisterRoutingExtensionRequest) xxx_FromOp(ctx context.Context, op *xxx_UnregisterRoutingExtensionOperation) {
	if o == nil {
		return
	}
	o.ExtensionName = op.ExtensionName
}
func (o *UnregisterRoutingExtensionRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *UnregisterRoutingExtensionRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_UnregisterRoutingExtensionOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// UnregisterRoutingExtensionResponse structure represents the FAX_UnregisterRoutingExtension operation response
type UnregisterRoutingExtensionResponse struct {
	// Return: The FAX_UnregisterRoutingExtension return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *UnregisterRoutingExtensionResponse) xxx_ToOp(ctx context.Context, op *xxx_UnregisterRoutingExtensionOperation) *xxx_UnregisterRoutingExtensionOperation {
	if op == nil {
		op = &xxx_UnregisterRoutingExtensionOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *UnregisterRoutingExtensionResponse) xxx_FromOp(ctx context.Context, op *xxx_UnregisterRoutingExtensionOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *UnregisterRoutingExtensionResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *UnregisterRoutingExtensionResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_UnregisterRoutingExtensionOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_StartMessagesEnumOperation structure represents the FAX_StartMessagesEnum operation
type xxx_StartMessagesEnumOperation struct {
	Folder fax.MessageFolder `idl:"name:Folder" json:"folder"`
	Handle *fax.MessageEnum  `idl:"name:lpHandle;pointer:ref" json:"handle"`
	Return uint32            `idl:"name:Return" json:"return"`
}

func (o *xxx_StartMessagesEnumOperation) OpNum() int { return 63 }

func (o *xxx_StartMessagesEnumOperation) OpName() string { return "/fax/v4/FAX_StartMessagesEnum" }

func (o *xxx_StartMessagesEnumOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartMessagesEnumOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// Folder {in} (1:{alias=FAX_ENUM_MESSAGE_FOLDER}(enum))
	{
		if err := w.WriteEnum(uint16(o.Folder)); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartMessagesEnumOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// Folder {in} (1:{alias=FAX_ENUM_MESSAGE_FOLDER}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.Folder)); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartMessagesEnumOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartMessagesEnumOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpHandle {out} (1:{pointer=ref, alias=PRPC_FAX_MSG_ENUM_HANDLE}*(1))(2:{context_handle, alias=RPC_FAX_MSG_ENUM_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.MessageEnum{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartMessagesEnumOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpHandle {out} (1:{pointer=ref, alias=PRPC_FAX_MSG_ENUM_HANDLE}*(1))(2:{context_handle, alias=RPC_FAX_MSG_ENUM_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &fax.MessageEnum{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// StartMessagesEnumRequest structure represents the FAX_StartMessagesEnum operation request
type StartMessagesEnumRequest struct {
	// Folder: This MUST be a FAX_ENUM_MESSAGE_FOLDER (section 2.2.2) enumeration that indicates
	// the type of the archive where the message resides. The FAX_MESSAGE_FOLDER_QUEUE value
	// is invalid for this parameter.
	Folder fax.MessageFolder `idl:"name:Folder" json:"folder"`
}

func (o *StartMessagesEnumRequest) xxx_ToOp(ctx context.Context, op *xxx_StartMessagesEnumOperation) *xxx_StartMessagesEnumOperation {
	if op == nil {
		op = &xxx_StartMessagesEnumOperation{}
	}
	if o == nil {
		return op
	}
	op.Folder = o.Folder
	return op
}

func (o *StartMessagesEnumRequest) xxx_FromOp(ctx context.Context, op *xxx_StartMessagesEnumOperation) {
	if o == nil {
		return
	}
	o.Folder = op.Folder
}
func (o *StartMessagesEnumRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *StartMessagesEnumRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_StartMessagesEnumOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// StartMessagesEnumResponse structure represents the FAX_StartMessagesEnum operation response
type StartMessagesEnumResponse struct {
	// lpHandle: A pointer to an enumeration handle return value.
	Handle *fax.MessageEnum `idl:"name:lpHandle;pointer:ref" json:"handle"`
	// Return: The FAX_StartMessagesEnum return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *StartMessagesEnumResponse) xxx_ToOp(ctx context.Context, op *xxx_StartMessagesEnumOperation) *xxx_StartMessagesEnumOperation {
	if op == nil {
		op = &xxx_StartMessagesEnumOperation{}
	}
	if o == nil {
		return op
	}
	op.Handle = o.Handle
	op.Return = o.Return
	return op
}

func (o *StartMessagesEnumResponse) xxx_FromOp(ctx context.Context, op *xxx_StartMessagesEnumOperation) {
	if o == nil {
		return
	}
	o.Handle = op.Handle
	o.Return = op.Return
}
func (o *StartMessagesEnumResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *StartMessagesEnumResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_StartMessagesEnumOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EndMessagesEnumOperation structure represents the FAX_EndMessagesEnum operation
type xxx_EndMessagesEnumOperation struct {
	Handle *fax.MessageEnum `idl:"name:lpHandle;pointer:ref" json:"handle"`
	Return uint32           `idl:"name:Return" json:"return"`
}

func (o *xxx_EndMessagesEnumOperation) OpNum() int { return 64 }

func (o *xxx_EndMessagesEnumOperation) OpName() string { return "/fax/v4/FAX_EndMessagesEnum" }

func (o *xxx_EndMessagesEnumOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EndMessagesEnumOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lpHandle {in, out} (1:{pointer=ref, alias=PRPC_FAX_MSG_ENUM_HANDLE}*(1))(2:{context_handle, alias=RPC_FAX_MSG_ENUM_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.MessageEnum{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_EndMessagesEnumOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lpHandle {in, out} (1:{pointer=ref, alias=PRPC_FAX_MSG_ENUM_HANDLE}*(1))(2:{context_handle, alias=RPC_FAX_MSG_ENUM_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &fax.MessageEnum{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EndMessagesEnumOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EndMessagesEnumOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpHandle {in, out} (1:{pointer=ref, alias=PRPC_FAX_MSG_ENUM_HANDLE}*(1))(2:{context_handle, alias=RPC_FAX_MSG_ENUM_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.MessageEnum{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EndMessagesEnumOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpHandle {in, out} (1:{pointer=ref, alias=PRPC_FAX_MSG_ENUM_HANDLE}*(1))(2:{context_handle, alias=RPC_FAX_MSG_ENUM_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &fax.MessageEnum{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EndMessagesEnumRequest structure represents the FAX_EndMessagesEnum operation request
type EndMessagesEnumRequest struct {
	// lpHandle: The parameter lpHandle MUST have been returned by FAX_StartMessagesEnum
	// (section 3.1.4.1.98).
	Handle *fax.MessageEnum `idl:"name:lpHandle;pointer:ref" json:"handle"`
}

func (o *EndMessagesEnumRequest) xxx_ToOp(ctx context.Context, op *xxx_EndMessagesEnumOperation) *xxx_EndMessagesEnumOperation {
	if op == nil {
		op = &xxx_EndMessagesEnumOperation{}
	}
	if o == nil {
		return op
	}
	op.Handle = o.Handle
	return op
}

func (o *EndMessagesEnumRequest) xxx_FromOp(ctx context.Context, op *xxx_EndMessagesEnumOperation) {
	if o == nil {
		return
	}
	o.Handle = op.Handle
}
func (o *EndMessagesEnumRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EndMessagesEnumRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EndMessagesEnumOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EndMessagesEnumResponse structure represents the FAX_EndMessagesEnum operation response
type EndMessagesEnumResponse struct {
	// lpHandle: The parameter lpHandle MUST have been returned by FAX_StartMessagesEnum
	// (section 3.1.4.1.98).
	Handle *fax.MessageEnum `idl:"name:lpHandle;pointer:ref" json:"handle"`
	// Return: The FAX_EndMessagesEnum return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EndMessagesEnumResponse) xxx_ToOp(ctx context.Context, op *xxx_EndMessagesEnumOperation) *xxx_EndMessagesEnumOperation {
	if op == nil {
		op = &xxx_EndMessagesEnumOperation{}
	}
	if o == nil {
		return op
	}
	op.Handle = o.Handle
	op.Return = o.Return
	return op
}

func (o *EndMessagesEnumResponse) xxx_FromOp(ctx context.Context, op *xxx_EndMessagesEnumOperation) {
	if o == nil {
		return
	}
	o.Handle = op.Handle
	o.Return = op.Return
}
func (o *EndMessagesEnumResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EndMessagesEnumResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EndMessagesEnumOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumMessagesOperation structure represents the FAX_EnumMessages operation
type xxx_EnumMessagesOperation struct {
	Enum                    *fax.MessageEnum `idl:"name:hEnum;pointer:ref" json:"enum"`
	MessagesLength          uint32           `idl:"name:dwNumMessages" json:"messages_length"`
	Buffer                  []byte           `idl:"name:lppBuffer;size_is:(, lpdwBufferSize)" json:"buffer"`
	BufferSize              uint32           `idl:"name:lpdwBufferSize;pointer:ref" json:"buffer_size"`
	MessagesRetrievedLength uint32           `idl:"name:lpdwNumMessagesRetrieved;pointer:ref" json:"messages_retrieved_length"`
	Return                  uint32           `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumMessagesOperation) OpNum() int { return 65 }

func (o *xxx_EnumMessagesOperation) OpName() string { return "/fax/v4/FAX_EnumMessages" }

func (o *xxx_EnumMessagesOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumMessagesOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hEnum {in} (1:{context_handle, pointer=ref, alias=RPC_FAX_MSG_ENUM_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Enum != nil {
			if err := o.Enum.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.MessageEnum{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwNumMessages {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.MessagesLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumMessagesOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hEnum {in} (1:{context_handle, pointer=ref, alias=RPC_FAX_MSG_ENUM_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Enum == nil {
			o.Enum = &fax.MessageEnum{}
		}
		if err := o.Enum.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwNumMessages {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.MessagesLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumMessagesOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Buffer != nil && o.BufferSize == 0 {
		o.BufferSize = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumMessagesOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lppBuffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE}*(1))(3:{alias=BYTE}[dim:0,size_is=lpdwBufferSize](uchar))
	{
		if o.Buffer != nil || o.BufferSize > 0 {
			_ptr_lppBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.BufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Buffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Buffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Buffer, _ptr_lppBuffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpdwBufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	// lpdwNumMessagesRetrieved {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.MessagesRetrievedLength); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumMessagesOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lppBuffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE,pointer=ref}*(1))(3:{alias=BYTE}[dim:0,size_is=lpdwBufferSize](uchar))
	{
		_ptr_lppBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
			}
			o.Buffer = make([]byte, sizeInfo[0])
			for i1 := range o.Buffer {
				i1 := i1
				if err := w.ReadData(&o.Buffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_lppBuffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Buffer, _s_lppBuffer, _ptr_lppBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpdwBufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	// lpdwNumMessagesRetrieved {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.MessagesRetrievedLength); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumMessagesRequest structure represents the FAX_EnumMessages operation request
type EnumMessagesRequest struct {
	// hEnum:  The enumeration handle returned through the lpHandle output argument by
	// FAX_StartMessagesEnum.
	Enum *fax.MessageEnum `idl:"name:hEnum;pointer:ref" json:"enum"`
	// dwNumMessages: A DWORD ([MS-DTYP] section 2.2.9) value indicating the maximum number
	// of messages the caller requires to enumerate. This value MUST NOT be zero.
	MessagesLength uint32 `idl:"name:dwNumMessages" json:"messages_length"`
}

func (o *EnumMessagesRequest) xxx_ToOp(ctx context.Context, op *xxx_EnumMessagesOperation) *xxx_EnumMessagesOperation {
	if op == nil {
		op = &xxx_EnumMessagesOperation{}
	}
	if o == nil {
		return op
	}
	op.Enum = o.Enum
	op.MessagesLength = o.MessagesLength
	return op
}

func (o *EnumMessagesRequest) xxx_FromOp(ctx context.Context, op *xxx_EnumMessagesOperation) {
	if o == nil {
		return
	}
	o.Enum = op.Enum
	o.MessagesLength = op.MessagesLength
}
func (o *EnumMessagesRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumMessagesRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumMessagesOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumMessagesResponse structure represents the FAX_EnumMessages operation response
type EnumMessagesResponse struct {
	// lppBuffer: A pointer to a buffer of FAX_MESSAGEW (section 2.2.38) structures. This
	// buffer contains lpdwNumMessagesRetrieved entries.
	Buffer []byte `idl:"name:lppBuffer;size_is:(, lpdwBufferSize)" json:"buffer"`
	// lpdwBufferSize: A pointer to a DWORD in which to return the size, in bytes, of the
	// buffer.
	BufferSize uint32 `idl:"name:lpdwBufferSize;pointer:ref" json:"buffer_size"`
	// lpdwNumMessagesRetrieved: A pointer to a DWORD value indicating the actual number
	// of messages retrieved. This value SHOULD NOT exceed dwNumMessages.
	MessagesRetrievedLength uint32 `idl:"name:lpdwNumMessagesRetrieved;pointer:ref" json:"messages_retrieved_length"`
	// Return: The FAX_EnumMessages return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumMessagesResponse) xxx_ToOp(ctx context.Context, op *xxx_EnumMessagesOperation) *xxx_EnumMessagesOperation {
	if op == nil {
		op = &xxx_EnumMessagesOperation{}
	}
	if o == nil {
		return op
	}
	op.Buffer = o.Buffer
	op.BufferSize = o.BufferSize
	op.MessagesRetrievedLength = o.MessagesRetrievedLength
	op.Return = o.Return
	return op
}

func (o *EnumMessagesResponse) xxx_FromOp(ctx context.Context, op *xxx_EnumMessagesOperation) {
	if o == nil {
		return
	}
	o.Buffer = op.Buffer
	o.BufferSize = op.BufferSize
	o.MessagesRetrievedLength = op.MessagesRetrievedLength
	o.Return = op.Return
}
func (o *EnumMessagesResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumMessagesResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumMessagesOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetMessageOperation structure represents the FAX_GetMessage operation
type xxx_GetMessageOperation struct {
	MessageID  uint64            `idl:"name:dwlMessageId" json:"message_id"`
	Folder     fax.MessageFolder `idl:"name:Folder" json:"folder"`
	Buffer     []byte            `idl:"name:lppBuffer;size_is:(, lpdwBufferSize)" json:"buffer"`
	BufferSize uint32            `idl:"name:lpdwBufferSize;pointer:ref" json:"buffer_size"`
	Return     uint32            `idl:"name:Return" json:"return"`
}

func (o *xxx_GetMessageOperation) OpNum() int { return 66 }

func (o *xxx_GetMessageOperation) OpName() string { return "/fax/v4/FAX_GetMessage" }

func (o *xxx_GetMessageOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMessageOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// dwlMessageId {in} (1:{alias=DWORDLONG, names=ULONGLONG}(uint64))
	{
		if err := w.WriteData(o.MessageID); err != nil {
			return err
		}
	}
	// Folder {in} (1:{alias=FAX_ENUM_MESSAGE_FOLDER}(enum))
	{
		if err := w.WriteEnum(uint16(o.Folder)); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMessageOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// dwlMessageId {in} (1:{alias=DWORDLONG, names=ULONGLONG}(uint64))
	{
		if err := w.ReadData(&o.MessageID); err != nil {
			return err
		}
	}
	// Folder {in} (1:{alias=FAX_ENUM_MESSAGE_FOLDER}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.Folder)); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMessageOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Buffer != nil && o.BufferSize == 0 {
		o.BufferSize = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMessageOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lppBuffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE}*(1))(3:{alias=BYTE}[dim:0,size_is=lpdwBufferSize](uchar))
	{
		if o.Buffer != nil || o.BufferSize > 0 {
			_ptr_lppBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.BufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Buffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Buffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Buffer, _ptr_lppBuffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpdwBufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMessageOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lppBuffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE,pointer=ref}*(1))(3:{alias=BYTE}[dim:0,size_is=lpdwBufferSize](uchar))
	{
		_ptr_lppBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
			}
			o.Buffer = make([]byte, sizeInfo[0])
			for i1 := range o.Buffer {
				i1 := i1
				if err := w.ReadData(&o.Buffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_lppBuffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Buffer, _s_lppBuffer, _ptr_lppBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpdwBufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetMessageRequest structure represents the FAX_GetMessage operation request
type GetMessageRequest struct {
	// dwlMessageId: A DWORDLONG ([MS-DTYP] section 2.2.13) value that identifies the fax
	// message to retrieve from the archive.
	MessageID uint64 `idl:"name:dwlMessageId" json:"message_id"`
	// Folder: The type of archive where the message resides. FAX_MESSAGE_FOLDER_QUEUE is
	// an invalid value for this parameter.
	Folder fax.MessageFolder `idl:"name:Folder" json:"folder"`
}

func (o *GetMessageRequest) xxx_ToOp(ctx context.Context, op *xxx_GetMessageOperation) *xxx_GetMessageOperation {
	if op == nil {
		op = &xxx_GetMessageOperation{}
	}
	if o == nil {
		return op
	}
	op.MessageID = o.MessageID
	op.Folder = o.Folder
	return op
}

func (o *GetMessageRequest) xxx_FromOp(ctx context.Context, op *xxx_GetMessageOperation) {
	if o == nil {
		return
	}
	o.MessageID = op.MessageID
	o.Folder = op.Folder
}
func (o *GetMessageRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetMessageRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetMessageOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetMessageResponse structure represents the FAX_GetMessage operation response
type GetMessageResponse struct {
	// lppBuffer: A pointer to a buffer that receives a FAX_MESSAGEW (section 2.2.38) structure.
	// This buffer contains the retrieved message.
	Buffer []byte `idl:"name:lppBuffer;size_is:(, lpdwBufferSize)" json:"buffer"`
	// lpdwBufferSize: A pointer to a DWORD ([MS-DTYP] section 2.2.9) in which to return
	// the size, in bytes, of the buffer that is pointed to by the lppBuffer parameter.
	BufferSize uint32 `idl:"name:lpdwBufferSize;pointer:ref" json:"buffer_size"`
	// Return: The FAX_GetMessage return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetMessageResponse) xxx_ToOp(ctx context.Context, op *xxx_GetMessageOperation) *xxx_GetMessageOperation {
	if op == nil {
		op = &xxx_GetMessageOperation{}
	}
	if o == nil {
		return op
	}
	op.Buffer = o.Buffer
	op.BufferSize = o.BufferSize
	op.Return = o.Return
	return op
}

func (o *GetMessageResponse) xxx_FromOp(ctx context.Context, op *xxx_GetMessageOperation) {
	if o == nil {
		return
	}
	o.Buffer = op.Buffer
	o.BufferSize = op.BufferSize
	o.Return = op.Return
}
func (o *GetMessageResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetMessageResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetMessageOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_RemoveMessageOperation structure represents the FAX_RemoveMessage operation
type xxx_RemoveMessageOperation struct {
	MessageID uint64            `idl:"name:dwlMessageId" json:"message_id"`
	Folder    fax.MessageFolder `idl:"name:Folder" json:"folder"`
	Return    uint32            `idl:"name:Return" json:"return"`
}

func (o *xxx_RemoveMessageOperation) OpNum() int { return 67 }

func (o *xxx_RemoveMessageOperation) OpName() string { return "/fax/v4/FAX_RemoveMessage" }

func (o *xxx_RemoveMessageOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveMessageOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// dwlMessageId {in} (1:{alias=DWORDLONG, names=ULONGLONG}(uint64))
	{
		if err := w.WriteData(o.MessageID); err != nil {
			return err
		}
	}
	// Folder {in} (1:{alias=FAX_ENUM_MESSAGE_FOLDER}(enum))
	{
		if err := w.WriteEnum(uint16(o.Folder)); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveMessageOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// dwlMessageId {in} (1:{alias=DWORDLONG, names=ULONGLONG}(uint64))
	{
		if err := w.ReadData(&o.MessageID); err != nil {
			return err
		}
	}
	// Folder {in} (1:{alias=FAX_ENUM_MESSAGE_FOLDER}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.Folder)); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveMessageOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveMessageOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveMessageOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// RemoveMessageRequest structure represents the FAX_RemoveMessage operation request
type RemoveMessageRequest struct {
	// dwlMessageId: A DWORDLONG ([MS-DTYP] section 2.2.13) value identifying the fax message
	// to remove from the archive.
	MessageID uint64 `idl:"name:dwlMessageId" json:"message_id"`
	// Folder: The type of the archive where the message resides. FAX_MESSAGE_FOLDER_QUEUE
	// is an invalid value for this parameter.
	Folder fax.MessageFolder `idl:"name:Folder" json:"folder"`
}

func (o *RemoveMessageRequest) xxx_ToOp(ctx context.Context, op *xxx_RemoveMessageOperation) *xxx_RemoveMessageOperation {
	if op == nil {
		op = &xxx_RemoveMessageOperation{}
	}
	if o == nil {
		return op
	}
	op.MessageID = o.MessageID
	op.Folder = o.Folder
	return op
}

func (o *RemoveMessageRequest) xxx_FromOp(ctx context.Context, op *xxx_RemoveMessageOperation) {
	if o == nil {
		return
	}
	o.MessageID = op.MessageID
	o.Folder = op.Folder
}
func (o *RemoveMessageRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *RemoveMessageRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemoveMessageOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// RemoveMessageResponse structure represents the FAX_RemoveMessage operation response
type RemoveMessageResponse struct {
	// Return: The FAX_RemoveMessage return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *RemoveMessageResponse) xxx_ToOp(ctx context.Context, op *xxx_RemoveMessageOperation) *xxx_RemoveMessageOperation {
	if op == nil {
		op = &xxx_RemoveMessageOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *RemoveMessageResponse) xxx_FromOp(ctx context.Context, op *xxx_RemoveMessageOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *RemoveMessageResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *RemoveMessageResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemoveMessageOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_StartCopyToServerOperation structure represents the FAX_StartCopyToServer operation
type xxx_StartCopyToServerOperation struct {
	FileExt        string    `idl:"name:lpcwstrFileExt;string;pointer:ref" json:"file_ext"`
	ServerFileName string    `idl:"name:lpwstrServerFileName;string;pointer:ref" json:"server_file_name"`
	Handle         *fax.Copy `idl:"name:lpHandle;pointer:ref" json:"handle"`
	Return         uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_StartCopyToServerOperation) OpNum() int { return 68 }

func (o *xxx_StartCopyToServerOperation) OpName() string { return "/fax/v4/FAX_StartCopyToServer" }

func (o *xxx_StartCopyToServerOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartCopyToServerOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lpcwstrFileExt {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.FileExt); err != nil {
			return err
		}
	}
	// lpwstrServerFileName {in, out} (1:{string, pointer=ref, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ServerFileName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartCopyToServerOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lpcwstrFileExt {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.FileExt); err != nil {
			return err
		}
	}
	// lpwstrServerFileName {in, out} (1:{string, pointer=ref, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ServerFileName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartCopyToServerOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartCopyToServerOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpwstrServerFileName {in, out} (1:{string, pointer=ref, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ServerFileName); err != nil {
			return err
		}
	}
	// lpHandle {out} (1:{pointer=ref, alias=PRPC_FAX_COPY_HANDLE}*(1))(2:{context_handle, alias=RPC_FAX_COPY_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.Copy{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartCopyToServerOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpwstrServerFileName {in, out} (1:{string, pointer=ref, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ServerFileName); err != nil {
			return err
		}
	}
	// lpHandle {out} (1:{pointer=ref, alias=PRPC_FAX_COPY_HANDLE}*(1))(2:{context_handle, alias=RPC_FAX_COPY_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &fax.Copy{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// StartCopyToServerRequest structure represents the FAX_StartCopyToServer operation request
type StartCopyToServerRequest struct {
	// lpcwstrFileExt: A null-terminated character string containing the extension of the
	// file to create on the server. The only file name extensions that are supported by
	// the server are ".tif" and ".cov".
	FileExt string `idl:"name:lpcwstrFileExt;string;pointer:ref" json:"file_ext"`
	// lpwstrServerFileName: Pointer to the buffer that receives the null-terminated character
	// string containing the name and specified extension of the file created on the server.
	// The client MUST fill the buffer with any null-terminated character string of sufficient
	// length to accommodate the character string that will be received. The server MUST
	// overwrite this buffer with the null-terminated character string containing the name
	// of the file on the server upon return. The server SHOULD NOT write more than 255
	// characters, including the terminating null character, to the returned character string.
	ServerFileName string `idl:"name:lpwstrServerFileName;string;pointer:ref" json:"server_file_name"`
}

func (o *StartCopyToServerRequest) xxx_ToOp(ctx context.Context, op *xxx_StartCopyToServerOperation) *xxx_StartCopyToServerOperation {
	if op == nil {
		op = &xxx_StartCopyToServerOperation{}
	}
	if o == nil {
		return op
	}
	op.FileExt = o.FileExt
	op.ServerFileName = o.ServerFileName
	return op
}

func (o *StartCopyToServerRequest) xxx_FromOp(ctx context.Context, op *xxx_StartCopyToServerOperation) {
	if o == nil {
		return
	}
	o.FileExt = op.FileExt
	o.ServerFileName = op.ServerFileName
}
func (o *StartCopyToServerRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *StartCopyToServerRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_StartCopyToServerOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// StartCopyToServerResponse structure represents the FAX_StartCopyToServer operation response
type StartCopyToServerResponse struct {
	// lpwstrServerFileName: Pointer to the buffer that receives the null-terminated character
	// string containing the name and specified extension of the file created on the server.
	// The client MUST fill the buffer with any null-terminated character string of sufficient
	// length to accommodate the character string that will be received. The server MUST
	// overwrite this buffer with the null-terminated character string containing the name
	// of the file on the server upon return. The server SHOULD NOT write more than 255
	// characters, including the terminating null character, to the returned character string.
	ServerFileName string `idl:"name:lpwstrServerFileName;string;pointer:ref" json:"server_file_name"`
	// lpHandle: The copy handle identifying this copy operation.
	Handle *fax.Copy `idl:"name:lpHandle;pointer:ref" json:"handle"`
	// Return: The FAX_StartCopyToServer return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *StartCopyToServerResponse) xxx_ToOp(ctx context.Context, op *xxx_StartCopyToServerOperation) *xxx_StartCopyToServerOperation {
	if op == nil {
		op = &xxx_StartCopyToServerOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerFileName = o.ServerFileName
	op.Handle = o.Handle
	op.Return = o.Return
	return op
}

func (o *StartCopyToServerResponse) xxx_FromOp(ctx context.Context, op *xxx_StartCopyToServerOperation) {
	if o == nil {
		return
	}
	o.ServerFileName = op.ServerFileName
	o.Handle = op.Handle
	o.Return = op.Return
}
func (o *StartCopyToServerResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *StartCopyToServerResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_StartCopyToServerOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_StartCopyMessageFromServerOperation structure represents the FAX_StartCopyMessageFromServer operation
type xxx_StartCopyMessageFromServerOperation struct {
	MessageID uint64            `idl:"name:dwlMessageId" json:"message_id"`
	Folder    fax.MessageFolder `idl:"name:Folder" json:"folder"`
	Handle    *fax.Copy         `idl:"name:lpHandle;pointer:ref" json:"handle"`
	Return    uint32            `idl:"name:Return" json:"return"`
}

func (o *xxx_StartCopyMessageFromServerOperation) OpNum() int { return 69 }

func (o *xxx_StartCopyMessageFromServerOperation) OpName() string {
	return "/fax/v4/FAX_StartCopyMessageFromServer"
}

func (o *xxx_StartCopyMessageFromServerOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartCopyMessageFromServerOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// dwlMessageId {in} (1:{alias=DWORDLONG, names=ULONGLONG}(uint64))
	{
		if err := w.WriteData(o.MessageID); err != nil {
			return err
		}
	}
	// Folder {in} (1:{alias=FAX_ENUM_MESSAGE_FOLDER}(enum))
	{
		if err := w.WriteEnum(uint16(o.Folder)); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartCopyMessageFromServerOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// dwlMessageId {in} (1:{alias=DWORDLONG, names=ULONGLONG}(uint64))
	{
		if err := w.ReadData(&o.MessageID); err != nil {
			return err
		}
	}
	// Folder {in} (1:{alias=FAX_ENUM_MESSAGE_FOLDER}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.Folder)); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartCopyMessageFromServerOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartCopyMessageFromServerOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpHandle {out} (1:{pointer=ref, alias=PRPC_FAX_COPY_HANDLE}*(1))(2:{context_handle, alias=RPC_FAX_COPY_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.Copy{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartCopyMessageFromServerOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpHandle {out} (1:{pointer=ref, alias=PRPC_FAX_COPY_HANDLE}*(1))(2:{context_handle, alias=RPC_FAX_COPY_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &fax.Copy{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// StartCopyMessageFromServerRequest structure represents the FAX_StartCopyMessageFromServer operation request
type StartCopyMessageFromServerRequest struct {
	// dwlMessageId: A DWORDLONG ([MS-DTYP] section 2.2.13) value that indicates the message
	// identifier to copy to the client.
	MessageID uint64 `idl:"name:dwlMessageId" json:"message_id"`
	// Folder: This MUST be an enumeration value that indicates the folder from which to
	// copy the message. For more information, see FAX_ENUM_MESSAGE_FOLDER (section 2.2.2).
	Folder fax.MessageFolder `idl:"name:Folder" json:"folder"`
}

func (o *StartCopyMessageFromServerRequest) xxx_ToOp(ctx context.Context, op *xxx_StartCopyMessageFromServerOperation) *xxx_StartCopyMessageFromServerOperation {
	if op == nil {
		op = &xxx_StartCopyMessageFromServerOperation{}
	}
	if o == nil {
		return op
	}
	op.MessageID = o.MessageID
	op.Folder = o.Folder
	return op
}

func (o *StartCopyMessageFromServerRequest) xxx_FromOp(ctx context.Context, op *xxx_StartCopyMessageFromServerOperation) {
	if o == nil {
		return
	}
	o.MessageID = op.MessageID
	o.Folder = op.Folder
}
func (o *StartCopyMessageFromServerRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *StartCopyMessageFromServerRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_StartCopyMessageFromServerOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// StartCopyMessageFromServerResponse structure represents the FAX_StartCopyMessageFromServer operation response
type StartCopyMessageFromServerResponse struct {
	// lpHandle: The copy handle identifying this copy operation.
	Handle *fax.Copy `idl:"name:lpHandle;pointer:ref" json:"handle"`
	// Return: The FAX_StartCopyMessageFromServer return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *StartCopyMessageFromServerResponse) xxx_ToOp(ctx context.Context, op *xxx_StartCopyMessageFromServerOperation) *xxx_StartCopyMessageFromServerOperation {
	if op == nil {
		op = &xxx_StartCopyMessageFromServerOperation{}
	}
	if o == nil {
		return op
	}
	op.Handle = o.Handle
	op.Return = o.Return
	return op
}

func (o *StartCopyMessageFromServerResponse) xxx_FromOp(ctx context.Context, op *xxx_StartCopyMessageFromServerOperation) {
	if o == nil {
		return
	}
	o.Handle = op.Handle
	o.Return = op.Return
}
func (o *StartCopyMessageFromServerResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *StartCopyMessageFromServerResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_StartCopyMessageFromServerOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_WriteFileOperation structure represents the FAX_WriteFile operation
type xxx_WriteFileOperation struct {
	HCopy    *fax.Copy `idl:"name:hCopy;pointer:ref" json:"h_copy"`
	Data     []byte    `idl:"name:lpbData;size_is:(dwDataSize);pointer:ref" json:"data"`
	DataSize uint32    `idl:"name:dwDataSize" json:"data_size"`
	Return   uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_WriteFileOperation) OpNum() int { return 70 }

func (o *xxx_WriteFileOperation) OpName() string { return "/fax/v4/FAX_WriteFile" }

func (o *xxx_WriteFileOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.Data != nil && o.DataSize == 0 {
		o.DataSize = uint32(len(o.Data))
	}
	if o.DataSize > uint32(16384) {
		return fmt.Errorf("DataSize is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_WriteFileOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hCopy {in} (1:{context_handle, pointer=ref, alias=RPC_FAX_COPY_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.HCopy != nil {
			if err := o.HCopy.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.Copy{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// lpbData {in} (1:{pointer=ref, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=dwDataSize](uchar))
	{
		dimSize1 := uint64(o.DataSize)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.Data {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.Data[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.Data); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// dwDataSize {in} (1:{range=(0,16384), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DataSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_WriteFileOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hCopy {in} (1:{context_handle, pointer=ref, alias=RPC_FAX_COPY_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.HCopy == nil {
			o.HCopy = &fax.Copy{}
		}
		if err := o.HCopy.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// lpbData {in} (1:{pointer=ref, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=dwDataSize](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Data", sizeInfo[0])
		}
		o.Data = make([]byte, sizeInfo[0])
		for i1 := range o.Data {
			i1 := i1
			if err := w.ReadData(&o.Data[i1]); err != nil {
				return err
			}
		}
	}
	// dwDataSize {in} (1:{range=(0,16384), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DataSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_WriteFileOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_WriteFileOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_WriteFileOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// WriteFileRequest structure represents the FAX_WriteFile operation request
type WriteFileRequest struct {
	// hCopy: An RPC context handle that is returned by FAX_StartCopyToServer.
	HCopy *fax.Copy `idl:"name:hCopy;pointer:ref" json:"h_copy"`
	// lpbData: A pointer to the buffer from which to copy the file.
	Data []byte `idl:"name:lpbData;size_is:(dwDataSize);pointer:ref" json:"data"`
	// dwDataSize: A DWORD ([MS-DTYP] section 2.2.9) value indicating the size, in bytes,
	// of the data buffer pointed by the lpbData argument. This size MUST be between 1 and
	// RPC_COPY_BUFFER_SIZE (16384) bytes.
	DataSize uint32 `idl:"name:dwDataSize" json:"data_size"`
}

func (o *WriteFileRequest) xxx_ToOp(ctx context.Context, op *xxx_WriteFileOperation) *xxx_WriteFileOperation {
	if op == nil {
		op = &xxx_WriteFileOperation{}
	}
	if o == nil {
		return op
	}
	op.HCopy = o.HCopy
	op.Data = o.Data
	op.DataSize = o.DataSize
	return op
}

func (o *WriteFileRequest) xxx_FromOp(ctx context.Context, op *xxx_WriteFileOperation) {
	if o == nil {
		return
	}
	o.HCopy = op.HCopy
	o.Data = op.Data
	o.DataSize = op.DataSize
}
func (o *WriteFileRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *WriteFileRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_WriteFileOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// WriteFileResponse structure represents the FAX_WriteFile operation response
type WriteFileResponse struct {
	// Return: The FAX_WriteFile return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *WriteFileResponse) xxx_ToOp(ctx context.Context, op *xxx_WriteFileOperation) *xxx_WriteFileOperation {
	if op == nil {
		op = &xxx_WriteFileOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *WriteFileResponse) xxx_FromOp(ctx context.Context, op *xxx_WriteFileOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *WriteFileResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *WriteFileResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_WriteFileOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ReadFileOperation structure represents the FAX_ReadFile operation
type xxx_ReadFileOperation struct {
	HCopy       *fax.Copy `idl:"name:hCopy;pointer:ref" json:"h_copy"`
	MaxDataSize uint32    `idl:"name:dwMaxDataSize" json:"max_data_size"`
	Data        []byte    `idl:"name:lpbData;size_is:(lpdwDataSize);pointer:ref" json:"data"`
	DataSize    uint32    `idl:"name:lpdwDataSize;pointer:ref" json:"data_size"`
	Return      uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_ReadFileOperation) OpNum() int { return 71 }

func (o *xxx_ReadFileOperation) OpName() string { return "/fax/v4/FAX_ReadFile" }

func (o *xxx_ReadFileOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ReadFileOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hCopy {in} (1:{context_handle, pointer=ref, alias=RPC_FAX_COPY_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.HCopy != nil {
			if err := o.HCopy.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.Copy{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwMaxDataSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.MaxDataSize); err != nil {
			return err
		}
	}
	// lpdwDataSize {in, out} (1:{pointer=ref, alias=LPRANGED_DWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DataSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ReadFileOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hCopy {in} (1:{context_handle, pointer=ref, alias=RPC_FAX_COPY_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.HCopy == nil {
			o.HCopy = &fax.Copy{}
		}
		if err := o.HCopy.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwMaxDataSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.MaxDataSize); err != nil {
			return err
		}
	}
	// lpdwDataSize {in, out} (1:{pointer=ref, alias=LPRANGED_DWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DataSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ReadFileOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Data != nil && o.DataSize == 0 {
		o.DataSize = uint32(len(o.Data))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ReadFileOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpbData {out} (1:{pointer=ref, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=lpdwDataSize](uchar))
	{
		dimSize1 := uint64(o.DataSize)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.Data {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.Data[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.Data); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// lpdwDataSize {in, out} (1:{pointer=ref, alias=LPRANGED_DWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DataSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ReadFileOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpbData {out} (1:{pointer=ref, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=lpdwDataSize](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Data", sizeInfo[0])
		}
		o.Data = make([]byte, sizeInfo[0])
		for i1 := range o.Data {
			i1 := i1
			if err := w.ReadData(&o.Data[i1]); err != nil {
				return err
			}
		}
	}
	// lpdwDataSize {in, out} (1:{pointer=ref, alias=LPRANGED_DWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DataSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ReadFileRequest structure represents the FAX_ReadFile operation request
type ReadFileRequest struct {
	// hCopy: A copy handle returned by FAX_StartCopyMessageFromServer.
	HCopy *fax.Copy `idl:"name:hCopy;pointer:ref" json:"h_copy"`
	// dwMaxDataSize: A DWORD ([MS-DTYP] section 2.2.9) value that indicates the maximum
	// size, in bytes, of data to be read and returned in the buffer. The caller MUST set
	// this argument to a value greater than zero before making the call.
	MaxDataSize uint32 `idl:"name:dwMaxDataSize" json:"max_data_size"`
	// lpdwDataSize: A pointer to a DWORD in which to return the size, in bytes, of the
	// data that is sent in this segment. The caller MUST set *lpdwDataSize to the same
	// value as dwMaxDataSize before making the call.
	DataSize uint32 `idl:"name:lpdwDataSize;pointer:ref" json:"data_size"`
}

func (o *ReadFileRequest) xxx_ToOp(ctx context.Context, op *xxx_ReadFileOperation) *xxx_ReadFileOperation {
	if op == nil {
		op = &xxx_ReadFileOperation{}
	}
	if o == nil {
		return op
	}
	op.HCopy = o.HCopy
	op.MaxDataSize = o.MaxDataSize
	op.DataSize = o.DataSize
	return op
}

func (o *ReadFileRequest) xxx_FromOp(ctx context.Context, op *xxx_ReadFileOperation) {
	if o == nil {
		return
	}
	o.HCopy = op.HCopy
	o.MaxDataSize = op.MaxDataSize
	o.DataSize = op.DataSize
}
func (o *ReadFileRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *ReadFileRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ReadFileOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ReadFileResponse structure represents the FAX_ReadFile operation response
type ReadFileResponse struct {
	// lpbData: A pointer to the buffer in which to place the data. This data MUST be allocated
	// by the caller to be at least the size specified by the lpdwDataSize argument. The
	// data to be placed in this buffer is a binary data block read from the file indicated
	// by the dwlMessageId and Folder arguments for the FAX_StartCopyMessageFromServer call,
	// which the client used to obtain the hCopy handle.
	Data []byte `idl:"name:lpbData;size_is:(lpdwDataSize);pointer:ref" json:"data"`
	// lpdwDataSize: A pointer to a DWORD in which to return the size, in bytes, of the
	// data that is sent in this segment. The caller MUST set *lpdwDataSize to the same
	// value as dwMaxDataSize before making the call.
	DataSize uint32 `idl:"name:lpdwDataSize;pointer:ref" json:"data_size"`
	// Return: The FAX_ReadFile return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ReadFileResponse) xxx_ToOp(ctx context.Context, op *xxx_ReadFileOperation) *xxx_ReadFileOperation {
	if op == nil {
		op = &xxx_ReadFileOperation{}
	}
	if o == nil {
		return op
	}
	op.Data = o.Data
	op.DataSize = o.DataSize
	op.Return = o.Return
	return op
}

func (o *ReadFileResponse) xxx_FromOp(ctx context.Context, op *xxx_ReadFileOperation) {
	if o == nil {
		return
	}
	o.Data = op.Data
	o.DataSize = op.DataSize
	o.Return = op.Return
}
func (o *ReadFileResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *ReadFileResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ReadFileOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EndCopyOperation structure represents the FAX_EndCopy operation
type xxx_EndCopyOperation struct {
	LphCopy *fax.Copy `idl:"name:lphCopy;pointer:ref" json:"lph_copy"`
	Return  uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_EndCopyOperation) OpNum() int { return 72 }

func (o *xxx_EndCopyOperation) OpName() string { return "/fax/v4/FAX_EndCopy" }

func (o *xxx_EndCopyOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EndCopyOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lphCopy {in, out} (1:{pointer=ref, alias=PRPC_FAX_COPY_HANDLE}*(1))(2:{context_handle, alias=RPC_FAX_COPY_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.LphCopy != nil {
			if err := o.LphCopy.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.Copy{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_EndCopyOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lphCopy {in, out} (1:{pointer=ref, alias=PRPC_FAX_COPY_HANDLE}*(1))(2:{context_handle, alias=RPC_FAX_COPY_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.LphCopy == nil {
			o.LphCopy = &fax.Copy{}
		}
		if err := o.LphCopy.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EndCopyOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EndCopyOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lphCopy {in, out} (1:{pointer=ref, alias=PRPC_FAX_COPY_HANDLE}*(1))(2:{context_handle, alias=RPC_FAX_COPY_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.LphCopy != nil {
			if err := o.LphCopy.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.Copy{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EndCopyOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lphCopy {in, out} (1:{pointer=ref, alias=PRPC_FAX_COPY_HANDLE}*(1))(2:{context_handle, alias=RPC_FAX_COPY_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.LphCopy == nil {
			o.LphCopy = &fax.Copy{}
		}
		if err := o.LphCopy.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EndCopyRequest structure represents the FAX_EndCopy operation request
type EndCopyRequest struct {
	// lphCopy: A copy handle that MUST be returned by FAX_StartCopyToServer or FAX_StartCopyMessageFromServer.
	LphCopy *fax.Copy `idl:"name:lphCopy;pointer:ref" json:"lph_copy"`
}

func (o *EndCopyRequest) xxx_ToOp(ctx context.Context, op *xxx_EndCopyOperation) *xxx_EndCopyOperation {
	if op == nil {
		op = &xxx_EndCopyOperation{}
	}
	if o == nil {
		return op
	}
	op.LphCopy = o.LphCopy
	return op
}

func (o *EndCopyRequest) xxx_FromOp(ctx context.Context, op *xxx_EndCopyOperation) {
	if o == nil {
		return
	}
	o.LphCopy = op.LphCopy
}
func (o *EndCopyRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EndCopyRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EndCopyOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EndCopyResponse structure represents the FAX_EndCopy operation response
type EndCopyResponse struct {
	// lphCopy: A copy handle that MUST be returned by FAX_StartCopyToServer or FAX_StartCopyMessageFromServer.
	LphCopy *fax.Copy `idl:"name:lphCopy;pointer:ref" json:"lph_copy"`
	// Return: The FAX_EndCopy return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EndCopyResponse) xxx_ToOp(ctx context.Context, op *xxx_EndCopyOperation) *xxx_EndCopyOperation {
	if op == nil {
		op = &xxx_EndCopyOperation{}
	}
	if o == nil {
		return op
	}
	op.LphCopy = o.LphCopy
	op.Return = o.Return
	return op
}

func (o *EndCopyResponse) xxx_FromOp(ctx context.Context, op *xxx_EndCopyOperation) {
	if o == nil {
		return
	}
	o.LphCopy = op.LphCopy
	o.Return = op.Return
}
func (o *EndCopyResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EndCopyResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EndCopyOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_StartServerNotificationOperation structure represents the FAX_StartServerNotification operation
type xxx_StartServerNotificationOperation struct {
	MachineName            string     `idl:"name:lpcwstrMachineName;string;pointer:ref" json:"machine_name"`
	Endpoint               string     `idl:"name:lpcwstrEndPoint;string;pointer:ref" json:"endpoint"`
	Context                uint64     `idl:"name:Context" json:"context"`
	ProtocolSequenceString string     `idl:"name:lpcwstrProtseqString;string;pointer:ref" json:"protocol_sequence_string"`
	EventEx                bool       `idl:"name:bEventEx" json:"event_ex"`
	EventTypes             uint32     `idl:"name:dwEventTypes" json:"event_types"`
	Handle                 *fax.Event `idl:"name:lpHandle;pointer:ref" json:"handle"`
	Return                 uint32     `idl:"name:Return" json:"return"`
}

func (o *xxx_StartServerNotificationOperation) OpNum() int { return 73 }

func (o *xxx_StartServerNotificationOperation) OpName() string {
	return "/fax/v4/FAX_StartServerNotification"
}

func (o *xxx_StartServerNotificationOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartServerNotificationOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lpcwstrMachineName {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.MachineName); err != nil {
			return err
		}
	}
	// lpcwstrEndPoint {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.Endpoint); err != nil {
			return err
		}
	}
	// Context {in} (1:{alias=ULONG64}(uint64))
	{
		if err := w.WriteData(o.Context); err != nil {
			return err
		}
	}
	// lpcwstrProtseqString {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ProtocolSequenceString); err != nil {
			return err
		}
	}
	// bEventEx {in} (1:{alias=BOOL}(int32))
	{
		if !o.EventEx {
			if err := w.WriteData(int32(0)); err != nil {
				return err
			}
		} else {
			if err := w.WriteData(int32(1)); err != nil {
				return err
			}
		}
	}
	// dwEventTypes {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.EventTypes); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartServerNotificationOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lpcwstrMachineName {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.MachineName); err != nil {
			return err
		}
	}
	// lpcwstrEndPoint {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.Endpoint); err != nil {
			return err
		}
	}
	// Context {in} (1:{alias=ULONG64}(uint64))
	{
		if err := w.ReadData(&o.Context); err != nil {
			return err
		}
	}
	// lpcwstrProtseqString {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ProtocolSequenceString); err != nil {
			return err
		}
	}
	// bEventEx {in} (1:{alias=BOOL}(int32))
	{
		var _bEventEx int32
		if err := w.ReadData(&_bEventEx); err != nil {
			return err
		}
		o.EventEx = _bEventEx != 0
	}
	// dwEventTypes {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.EventTypes); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartServerNotificationOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartServerNotificationOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpHandle {out} (1:{pointer=ref, alias=PRPC_FAX_EVENT_HANDLE}*(1))(2:{context_handle, alias=RPC_FAX_EVENT_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.Event{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartServerNotificationOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpHandle {out} (1:{pointer=ref, alias=PRPC_FAX_EVENT_HANDLE}*(1))(2:{context_handle, alias=RPC_FAX_EVENT_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &fax.Event{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// StartServerNotificationRequest structure represents the FAX_StartServerNotification operation request
type StartServerNotificationRequest struct {
	// lpcwstrMachineName: A pointer to a string that contains the name of the fax client
	// machine. The machine name MUST be NULL for a local machine and a fully qualified
	// domain name (FQDN) for a remote machine.
	MachineName string `idl:"name:lpcwstrMachineName;string;pointer:ref" json:"machine_name"`
	// lpcwstrEndPoint: A pointer to a string that contains the client machine RPC server
	// endpoint string. The endpoint MUST be a TCP port between 1024 and 65534 (in increments
	// of 10).
	Endpoint string `idl:"name:lpcwstrEndPoint;string;pointer:ref" json:"endpoint"`
	// Context: A ULONG64 ([MS-DTYP] section 2.2.54) value that can be passed to FAX_OpenConnection
	// (section 3.2.4.5) as a notification context.
	Context uint64 `idl:"name:Context" json:"context"`
	// lpcwstrProtseqString: A pointer to a string that contains the fax client RPC server's
	// protocol sequence string. The protocol sequence string MUST be ncalrpc for local
	// and ncan_ip_tcp for remote.
	ProtocolSequenceString string `idl:"name:lpcwstrProtseqString;string;pointer:ref" json:"protocol_sequence_string"`
	// bEventEx: A Boolean value that indicates which notification method to use for notifications.
	// This parameter is always set to FALSE.
	EventEx bool `idl:"name:bEventEx" json:"event_ex"`
	// dwEventTypes: A DWORD ([MS-DTYP] section 2.2.9) value that indicates which events
	// the client needs to receive. This parameter is always set to FAX_EVENT_TYPE_LEGACY.
	// For more information, see FAX_ENUM_EVENT_TYPE (section 2.2.63).
	EventTypes uint32 `idl:"name:dwEventTypes" json:"event_types"`
}

func (o *StartServerNotificationRequest) xxx_ToOp(ctx context.Context, op *xxx_StartServerNotificationOperation) *xxx_StartServerNotificationOperation {
	if op == nil {
		op = &xxx_StartServerNotificationOperation{}
	}
	if o == nil {
		return op
	}
	op.MachineName = o.MachineName
	op.Endpoint = o.Endpoint
	op.Context = o.Context
	op.ProtocolSequenceString = o.ProtocolSequenceString
	op.EventEx = o.EventEx
	op.EventTypes = o.EventTypes
	return op
}

func (o *StartServerNotificationRequest) xxx_FromOp(ctx context.Context, op *xxx_StartServerNotificationOperation) {
	if o == nil {
		return
	}
	o.MachineName = op.MachineName
	o.Endpoint = op.Endpoint
	o.Context = op.Context
	o.ProtocolSequenceString = op.ProtocolSequenceString
	o.EventEx = op.EventEx
	o.EventTypes = op.EventTypes
}
func (o *StartServerNotificationRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *StartServerNotificationRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_StartServerNotificationOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// StartServerNotificationResponse structure represents the FAX_StartServerNotification operation response
type StartServerNotificationResponse struct {
	// lpHandle: Returned subscription context handle. This handle can be used in the FAX_EndServerNotification
	// (section 3.1.4.1.17) method.
	Handle *fax.Event `idl:"name:lpHandle;pointer:ref" json:"handle"`
	// Return: The FAX_StartServerNotification return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *StartServerNotificationResponse) xxx_ToOp(ctx context.Context, op *xxx_StartServerNotificationOperation) *xxx_StartServerNotificationOperation {
	if op == nil {
		op = &xxx_StartServerNotificationOperation{}
	}
	if o == nil {
		return op
	}
	op.Handle = o.Handle
	op.Return = o.Return
	return op
}

func (o *StartServerNotificationResponse) xxx_FromOp(ctx context.Context, op *xxx_StartServerNotificationOperation) {
	if o == nil {
		return
	}
	o.Handle = op.Handle
	o.Return = op.Return
}
func (o *StartServerNotificationResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *StartServerNotificationResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_StartServerNotificationOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_StartServerNotificationExOperation structure represents the FAX_StartServerNotificationEx operation
type xxx_StartServerNotificationExOperation struct {
	MachineName string       `idl:"name:lpcwstrMachineName;string;pointer:ref" json:"machine_name"`
	Endpoint    string       `idl:"name:lpcwstrEndPoint;string;pointer:ref" json:"endpoint"`
	Context     uint64       `idl:"name:Context" json:"context"`
	ProtocolSeq string       `idl:"name:lpcwstrProtSeq;string;pointer:ref" json:"protocol_seq"`
	EventEx     bool         `idl:"name:bEventEx" json:"event_ex"`
	EventTypes  uint32       `idl:"name:dwEventTypes" json:"event_types"`
	Handle      *fax.EventEx `idl:"name:lpHandle;pointer:ref" json:"handle"`
	Return      uint32       `idl:"name:Return" json:"return"`
}

func (o *xxx_StartServerNotificationExOperation) OpNum() int { return 74 }

func (o *xxx_StartServerNotificationExOperation) OpName() string {
	return "/fax/v4/FAX_StartServerNotificationEx"
}

func (o *xxx_StartServerNotificationExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartServerNotificationExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lpcwstrMachineName {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.MachineName); err != nil {
			return err
		}
	}
	// lpcwstrEndPoint {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.Endpoint); err != nil {
			return err
		}
	}
	// Context {in} (1:{alias=ULONG64}(uint64))
	{
		if err := w.WriteData(o.Context); err != nil {
			return err
		}
	}
	// lpcwstrProtSeq {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ProtocolSeq); err != nil {
			return err
		}
	}
	// bEventEx {in} (1:{alias=BOOL}(int32))
	{
		if !o.EventEx {
			if err := w.WriteData(int32(0)); err != nil {
				return err
			}
		} else {
			if err := w.WriteData(int32(1)); err != nil {
				return err
			}
		}
	}
	// dwEventTypes {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.EventTypes); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartServerNotificationExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lpcwstrMachineName {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.MachineName); err != nil {
			return err
		}
	}
	// lpcwstrEndPoint {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.Endpoint); err != nil {
			return err
		}
	}
	// Context {in} (1:{alias=ULONG64}(uint64))
	{
		if err := w.ReadData(&o.Context); err != nil {
			return err
		}
	}
	// lpcwstrProtSeq {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ProtocolSeq); err != nil {
			return err
		}
	}
	// bEventEx {in} (1:{alias=BOOL}(int32))
	{
		var _bEventEx int32
		if err := w.ReadData(&_bEventEx); err != nil {
			return err
		}
		o.EventEx = _bEventEx != 0
	}
	// dwEventTypes {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.EventTypes); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartServerNotificationExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartServerNotificationExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpHandle {out} (1:{pointer=ref, alias=PRPC_FAX_EVENT_EX_HANDLE}*(1))(2:{context_handle, alias=RPC_FAX_EVENT_EX_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.EventEx{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartServerNotificationExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpHandle {out} (1:{pointer=ref, alias=PRPC_FAX_EVENT_EX_HANDLE}*(1))(2:{context_handle, alias=RPC_FAX_EVENT_EX_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &fax.EventEx{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// StartServerNotificationExRequest structure represents the FAX_StartServerNotificationEx operation request
type StartServerNotificationExRequest struct {
	// lpcwstrMachineName: A pointer to a string containing the name of the fax client machine.
	// The machine name MUST be NULL for a local machine and an FQDN for a remote machine.
	MachineName string `idl:"name:lpcwstrMachineName;string;pointer:ref" json:"machine_name"`
	// lpcwstrEndPoint: A pointer to a string containing the client machine RPC server endpoint
	// string. The endpoint MUST be a TCP port between 1024 and 65534 (in increments of
	// 10).
	Endpoint string `idl:"name:lpcwstrEndPoint;string;pointer:ref" json:"endpoint"`
	// Context: A ULONG64 ([MS-DTYP] section 2.2.54) value that can be passed to FAX_OpenConnection
	// (section 3.2.4.5) as a notification context.
	Context uint64 `idl:"name:Context" json:"context"`
	// lpcwstrProtSeq: A pointer to a string containing the fax client RPC server's protocol
	// sequence string. The protocol used for sending the notifications is always TCP/IP.
	// The protocol sequence string MUST be ncalrpc for local and respectively ncan_ip_tcp
	// for remote. <174>
	ProtocolSeq string `idl:"name:lpcwstrProtSeq;string;pointer:ref" json:"protocol_seq"`
	// bEventEx: A Boolean value that indicates which notification method to use for notifications.
	// If set to TRUE, the registration is for extended events (FAX_EVENT_EX (section 2.2.67)).
	// If FALSE, the registration is for legacy events (FAX_EVENT (section 2.2.66)).
	EventEx bool `idl:"name:bEventEx" json:"event_ex"`
	// dwEventTypes: A DWORD ([MS-DTYP] section 2.2.9) value containing bitwise OR combination
	// of FAX_ENUM_EVENT_TYPE (section 2.2.63) event type flags, events the client needs
	// to receive. During registration the client is allowed to register for multiple events,
	// so that if any of them occur the client will get a notification. Hence bitwise ORing
	// of events is allowed in this case. For more information, see FAX_ENUM_EVENT_TYPE.
	EventTypes uint32 `idl:"name:dwEventTypes" json:"event_types"`
}

func (o *StartServerNotificationExRequest) xxx_ToOp(ctx context.Context, op *xxx_StartServerNotificationExOperation) *xxx_StartServerNotificationExOperation {
	if op == nil {
		op = &xxx_StartServerNotificationExOperation{}
	}
	if o == nil {
		return op
	}
	op.MachineName = o.MachineName
	op.Endpoint = o.Endpoint
	op.Context = o.Context
	op.ProtocolSeq = o.ProtocolSeq
	op.EventEx = o.EventEx
	op.EventTypes = o.EventTypes
	return op
}

func (o *StartServerNotificationExRequest) xxx_FromOp(ctx context.Context, op *xxx_StartServerNotificationExOperation) {
	if o == nil {
		return
	}
	o.MachineName = op.MachineName
	o.Endpoint = op.Endpoint
	o.Context = op.Context
	o.ProtocolSeq = op.ProtocolSeq
	o.EventEx = op.EventEx
	o.EventTypes = op.EventTypes
}
func (o *StartServerNotificationExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *StartServerNotificationExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_StartServerNotificationExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// StartServerNotificationExResponse structure represents the FAX_StartServerNotificationEx operation response
type StartServerNotificationExResponse struct {
	// lpHandle: The returned subscription context handle. This handle can be used in the
	// FAX_EndServerNotification (section 3.1.4.1.17) method.
	Handle *fax.EventEx `idl:"name:lpHandle;pointer:ref" json:"handle"`
	// Return: The FAX_StartServerNotificationEx return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *StartServerNotificationExResponse) xxx_ToOp(ctx context.Context, op *xxx_StartServerNotificationExOperation) *xxx_StartServerNotificationExOperation {
	if op == nil {
		op = &xxx_StartServerNotificationExOperation{}
	}
	if o == nil {
		return op
	}
	op.Handle = o.Handle
	op.Return = o.Return
	return op
}

func (o *StartServerNotificationExResponse) xxx_FromOp(ctx context.Context, op *xxx_StartServerNotificationExOperation) {
	if o == nil {
		return
	}
	o.Handle = op.Handle
	o.Return = op.Return
}
func (o *StartServerNotificationExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *StartServerNotificationExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_StartServerNotificationExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EndServerNotificationOperation structure represents the FAX_EndServerNotification operation
type xxx_EndServerNotificationOperation struct {
	Handle *fax.EventEx `idl:"name:lpHandle;pointer:ref" json:"handle"`
	Return uint32       `idl:"name:Return" json:"return"`
}

func (o *xxx_EndServerNotificationOperation) OpNum() int { return 75 }

func (o *xxx_EndServerNotificationOperation) OpName() string {
	return "/fax/v4/FAX_EndServerNotification"
}

func (o *xxx_EndServerNotificationOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EndServerNotificationOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lpHandle {in, out} (1:{pointer=ref, alias=PRPC_FAX_EVENT_EX_HANDLE}*(1))(2:{context_handle, alias=RPC_FAX_EVENT_EX_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.EventEx{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_EndServerNotificationOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lpHandle {in, out} (1:{pointer=ref, alias=PRPC_FAX_EVENT_EX_HANDLE}*(1))(2:{context_handle, alias=RPC_FAX_EVENT_EX_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &fax.EventEx{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EndServerNotificationOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EndServerNotificationOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpHandle {in, out} (1:{pointer=ref, alias=PRPC_FAX_EVENT_EX_HANDLE}*(1))(2:{context_handle, alias=RPC_FAX_EVENT_EX_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.EventEx{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EndServerNotificationOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpHandle {in, out} (1:{pointer=ref, alias=PRPC_FAX_EVENT_EX_HANDLE}*(1))(2:{context_handle, alias=RPC_FAX_EVENT_EX_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &fax.EventEx{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EndServerNotificationRequest structure represents the FAX_EndServerNotification operation request
type EndServerNotificationRequest struct {
	// lpHandle: A pointer to a previously registered subscription context handle. The lpHandle
	// parameter MUST match the one supplied by the server when the FAX_StartServerNotification
	// family of calls is in use.
	Handle *fax.EventEx `idl:"name:lpHandle;pointer:ref" json:"handle"`
}

func (o *EndServerNotificationRequest) xxx_ToOp(ctx context.Context, op *xxx_EndServerNotificationOperation) *xxx_EndServerNotificationOperation {
	if op == nil {
		op = &xxx_EndServerNotificationOperation{}
	}
	if o == nil {
		return op
	}
	op.Handle = o.Handle
	return op
}

func (o *EndServerNotificationRequest) xxx_FromOp(ctx context.Context, op *xxx_EndServerNotificationOperation) {
	if o == nil {
		return
	}
	o.Handle = op.Handle
}
func (o *EndServerNotificationRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EndServerNotificationRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EndServerNotificationOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EndServerNotificationResponse structure represents the FAX_EndServerNotification operation response
type EndServerNotificationResponse struct {
	// lpHandle: A pointer to a previously registered subscription context handle. The lpHandle
	// parameter MUST match the one supplied by the server when the FAX_StartServerNotification
	// family of calls is in use.
	Handle *fax.EventEx `idl:"name:lpHandle;pointer:ref" json:"handle"`
	// Return: The FAX_EndServerNotification return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EndServerNotificationResponse) xxx_ToOp(ctx context.Context, op *xxx_EndServerNotificationOperation) *xxx_EndServerNotificationOperation {
	if op == nil {
		op = &xxx_EndServerNotificationOperation{}
	}
	if o == nil {
		return op
	}
	op.Handle = o.Handle
	op.Return = o.Return
	return op
}

func (o *EndServerNotificationResponse) xxx_FromOp(ctx context.Context, op *xxx_EndServerNotificationOperation) {
	if o == nil {
		return
	}
	o.Handle = op.Handle
	o.Return = op.Return
}
func (o *EndServerNotificationResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EndServerNotificationResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EndServerNotificationOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetServerActivityOperation structure represents the FAX_GetServerActivity operation
type xxx_GetServerActivityOperation struct {
	ServerActivity *fax.ServerActivity `idl:"name:pServerActivity;pointer:ref" json:"server_activity"`
	Return         uint32              `idl:"name:Return" json:"return"`
}

func (o *xxx_GetServerActivityOperation) OpNum() int { return 76 }

func (o *xxx_GetServerActivityOperation) OpName() string { return "/fax/v4/FAX_GetServerActivity" }

func (o *xxx_GetServerActivityOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServerActivityOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// pServerActivity {in, out} (1:{pointer=ref, alias=PFAX_SERVER_ACTIVITY}*(1))(2:{alias=FAX_SERVER_ACTIVITY}(struct))
	{
		if o.ServerActivity != nil {
			if err := o.ServerActivity.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.ServerActivity{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_GetServerActivityOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// pServerActivity {in, out} (1:{pointer=ref, alias=PFAX_SERVER_ACTIVITY}*(1))(2:{alias=FAX_SERVER_ACTIVITY}(struct))
	{
		if o.ServerActivity == nil {
			o.ServerActivity = &fax.ServerActivity{}
		}
		if err := o.ServerActivity.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServerActivityOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServerActivityOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pServerActivity {in, out} (1:{pointer=ref, alias=PFAX_SERVER_ACTIVITY}*(1))(2:{alias=FAX_SERVER_ACTIVITY}(struct))
	{
		if o.ServerActivity != nil {
			if err := o.ServerActivity.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.ServerActivity{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServerActivityOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pServerActivity {in, out} (1:{pointer=ref, alias=PFAX_SERVER_ACTIVITY}*(1))(2:{alias=FAX_SERVER_ACTIVITY}(struct))
	{
		if o.ServerActivity == nil {
			o.ServerActivity = &fax.ServerActivity{}
		}
		if err := o.ServerActivity.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetServerActivityRequest structure represents the FAX_GetServerActivity operation request
type GetServerActivityRequest struct {
	// pServerActivity: A pointer to a FAX_SERVER_ACTIVITY object.
	ServerActivity *fax.ServerActivity `idl:"name:pServerActivity;pointer:ref" json:"server_activity"`
}

func (o *GetServerActivityRequest) xxx_ToOp(ctx context.Context, op *xxx_GetServerActivityOperation) *xxx_GetServerActivityOperation {
	if op == nil {
		op = &xxx_GetServerActivityOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerActivity = o.ServerActivity
	return op
}

func (o *GetServerActivityRequest) xxx_FromOp(ctx context.Context, op *xxx_GetServerActivityOperation) {
	if o == nil {
		return
	}
	o.ServerActivity = op.ServerActivity
}
func (o *GetServerActivityRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetServerActivityRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetServerActivityOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetServerActivityResponse structure represents the FAX_GetServerActivity operation response
type GetServerActivityResponse struct {
	// pServerActivity: A pointer to a FAX_SERVER_ACTIVITY object.
	ServerActivity *fax.ServerActivity `idl:"name:pServerActivity;pointer:ref" json:"server_activity"`
	// Return: The FAX_GetServerActivity return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetServerActivityResponse) xxx_ToOp(ctx context.Context, op *xxx_GetServerActivityOperation) *xxx_GetServerActivityOperation {
	if op == nil {
		op = &xxx_GetServerActivityOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerActivity = o.ServerActivity
	op.Return = o.Return
	return op
}

func (o *GetServerActivityResponse) xxx_FromOp(ctx context.Context, op *xxx_GetServerActivityOperation) {
	if o == nil {
		return
	}
	o.ServerActivity = op.ServerActivity
	o.Return = op.Return
}
func (o *GetServerActivityResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetServerActivityResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetServerActivityOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetConfigWizardUsedOperation structure represents the FAX_SetConfigWizardUsed operation
type xxx_SetConfigWizardUsedOperation struct {
	ConfigWizardUsed bool   `idl:"name:bConfigWizardUsed" json:"config_wizard_used"`
	Return           uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_SetConfigWizardUsedOperation) OpNum() int { return 77 }

func (o *xxx_SetConfigWizardUsedOperation) OpName() string { return "/fax/v4/FAX_SetConfigWizardUsed" }

func (o *xxx_SetConfigWizardUsedOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetConfigWizardUsedOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// bConfigWizardUsed {in} (1:{alias=BOOL}(int32))
	{
		if !o.ConfigWizardUsed {
			if err := w.WriteData(int32(0)); err != nil {
				return err
			}
		} else {
			if err := w.WriteData(int32(1)); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_SetConfigWizardUsedOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// bConfigWizardUsed {in} (1:{alias=BOOL}(int32))
	{
		var _bConfigWizardUsed int32
		if err := w.ReadData(&_bConfigWizardUsed); err != nil {
			return err
		}
		o.ConfigWizardUsed = _bConfigWizardUsed != 0
	}
	return nil
}

func (o *xxx_SetConfigWizardUsedOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetConfigWizardUsedOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetConfigWizardUsedOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetConfigWizardUsedRequest structure represents the FAX_SetConfigWizardUsed operation request
type SetConfigWizardUsedRequest struct {
	// bConfigWizardUsed: A Boolean value indicating whether the fax configuration wizard
	// was used.
	ConfigWizardUsed bool `idl:"name:bConfigWizardUsed" json:"config_wizard_used"`
}

func (o *SetConfigWizardUsedRequest) xxx_ToOp(ctx context.Context, op *xxx_SetConfigWizardUsedOperation) *xxx_SetConfigWizardUsedOperation {
	if op == nil {
		op = &xxx_SetConfigWizardUsedOperation{}
	}
	if o == nil {
		return op
	}
	op.ConfigWizardUsed = o.ConfigWizardUsed
	return op
}

func (o *SetConfigWizardUsedRequest) xxx_FromOp(ctx context.Context, op *xxx_SetConfigWizardUsedOperation) {
	if o == nil {
		return
	}
	o.ConfigWizardUsed = op.ConfigWizardUsed
}
func (o *SetConfigWizardUsedRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetConfigWizardUsedRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetConfigWizardUsedOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetConfigWizardUsedResponse structure represents the FAX_SetConfigWizardUsed operation response
type SetConfigWizardUsedResponse struct {
	// Return: The FAX_SetConfigWizardUsed return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetConfigWizardUsedResponse) xxx_ToOp(ctx context.Context, op *xxx_SetConfigWizardUsedOperation) *xxx_SetConfigWizardUsedOperation {
	if op == nil {
		op = &xxx_SetConfigWizardUsedOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetConfigWizardUsedResponse) xxx_FromOp(ctx context.Context, op *xxx_SetConfigWizardUsedOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetConfigWizardUsedResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetConfigWizardUsedResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetConfigWizardUsedOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumRoutingExtensionsOperation structure represents the FAX_EnumRoutingExtensions operation
type xxx_EnumRoutingExtensionsOperation struct {
	Buffer     []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	BufferSize uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	ExtsLength uint32 `idl:"name:lpdwNumExts;pointer:ref" json:"exts_length"`
	Return     uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumRoutingExtensionsOperation) OpNum() int { return 78 }

func (o *xxx_EnumRoutingExtensionsOperation) OpName() string {
	return "/fax/v4/FAX_EnumRoutingExtensions"
}

func (o *xxx_EnumRoutingExtensionsOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumRoutingExtensionsOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	return nil
}

func (o *xxx_EnumRoutingExtensionsOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	return nil
}

func (o *xxx_EnumRoutingExtensionsOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Buffer != nil && o.BufferSize == 0 {
		o.BufferSize = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumRoutingExtensionsOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		if o.Buffer != nil || o.BufferSize > 0 {
			_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.BufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Buffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Buffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	// lpdwNumExts {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ExtsLength); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumRoutingExtensionsOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE,pointer=ref}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
			}
			o.Buffer = make([]byte, sizeInfo[0])
			for i1 := range o.Buffer {
				i1 := i1
				if err := w.ReadData(&o.Buffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	// lpdwNumExts {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ExtsLength); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumRoutingExtensionsRequest structure represents the FAX_EnumRoutingExtensions operation request
type EnumRoutingExtensionsRequest struct {
}

func (o *EnumRoutingExtensionsRequest) xxx_ToOp(ctx context.Context, op *xxx_EnumRoutingExtensionsOperation) *xxx_EnumRoutingExtensionsOperation {
	if op == nil {
		op = &xxx_EnumRoutingExtensionsOperation{}
	}
	if o == nil {
		return op
	}
	return op
}

func (o *EnumRoutingExtensionsRequest) xxx_FromOp(ctx context.Context, op *xxx_EnumRoutingExtensionsOperation) {
	if o == nil {
		return
	}
}
func (o *EnumRoutingExtensionsRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumRoutingExtensionsRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumRoutingExtensionsOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumRoutingExtensionsResponse structure represents the FAX_EnumRoutingExtensions operation response
type EnumRoutingExtensionsResponse struct {
	// Buffer: A pointer to the address of a buffer to receive an array of FAX_ROUTING_EXTENSION_INFO
	// (section 2.2.49) structures. Each structure contains information about one fax routing
	// extension, as it pertains to the entire Fax Service.
	Buffer []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	// BufferSize: A pointer to a DWORD ([MS-DTYP] section 2.2.9) in which to return the
	// size, in bytes, of the buffer.
	BufferSize uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	// lpdwNumExts: A pointer to a DWORD variable to receive the number of FAX_ROUTING_EXTENSION_INFO
	// that the method returns in the ppRoutingExtensions parameter. This number MUST equal
	// the total number of fax device routing extensions that are installed on the target
	// server.
	ExtsLength uint32 `idl:"name:lpdwNumExts;pointer:ref" json:"exts_length"`
	// Return: The FAX_EnumRoutingExtensions return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumRoutingExtensionsResponse) xxx_ToOp(ctx context.Context, op *xxx_EnumRoutingExtensionsOperation) *xxx_EnumRoutingExtensionsOperation {
	if op == nil {
		op = &xxx_EnumRoutingExtensionsOperation{}
	}
	if o == nil {
		return op
	}
	op.Buffer = o.Buffer
	op.BufferSize = o.BufferSize
	op.ExtsLength = o.ExtsLength
	op.Return = o.Return
	return op
}

func (o *EnumRoutingExtensionsResponse) xxx_FromOp(ctx context.Context, op *xxx_EnumRoutingExtensionsOperation) {
	if o == nil {
		return
	}
	o.Buffer = op.Buffer
	o.BufferSize = op.BufferSize
	o.ExtsLength = op.ExtsLength
	o.Return = op.Return
}
func (o *EnumRoutingExtensionsResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumRoutingExtensionsResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumRoutingExtensionsOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ConnectFaxServerOperation structure represents the FAX_ConnectFaxServer operation
type xxx_ConnectFaxServerOperation struct {
	ClientAPIVersion uint32       `idl:"name:dwClientAPIVersion" json:"client_api_version"`
	ServerAPIVersion uint32       `idl:"name:lpdwServerAPIVersion;pointer:ref" json:"server_api_version"`
	Handle           *fax.Service `idl:"name:pHandle;pointer:ref" json:"handle"`
	Return           uint32       `idl:"name:Return" json:"return"`
}

func (o *xxx_ConnectFaxServerOperation) OpNum() int { return 79 }

func (o *xxx_ConnectFaxServerOperation) OpName() string { return "/fax/v4/FAX_ConnectFaxServer" }

func (o *xxx_ConnectFaxServerOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ConnectFaxServerOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// dwClientAPIVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ClientAPIVersion); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ConnectFaxServerOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// dwClientAPIVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ClientAPIVersion); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ConnectFaxServerOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ConnectFaxServerOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpdwServerAPIVersion {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ServerAPIVersion); err != nil {
			return err
		}
	}
	// pHandle {out} (1:{pointer=ref, alias=PRPC_FAX_SVC_HANDLE}*(1))(2:{context_handle, alias=RPC_FAX_SVC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.Service{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ConnectFaxServerOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpdwServerAPIVersion {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ServerAPIVersion); err != nil {
			return err
		}
	}
	// pHandle {out} (1:{pointer=ref, alias=PRPC_FAX_SVC_HANDLE}*(1))(2:{context_handle, alias=RPC_FAX_SVC_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &fax.Service{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ConnectFaxServerRequest structure represents the FAX_ConnectFaxServer operation request
type ConnectFaxServerRequest struct {
	// dwClientAPIVersion: A DWORD ([MS-DTYP] section 2.2.9) that MUST contain the protocol
	// version (fax API version) of the client module. This value MUST be one of the constants
	// defined in section 2.2.85 (Protocol and Fax API Version Constants). The value determines
	// the specific FAX_ERR error codes that can be returned by the fax server, as described
	// in the following table. If the fax server receives from the fax client a version
	// number greater than the server’s version number, the server MUST accept the request
	// and MUST consider the client version to be the same as the version supported by the
	// fax server.
	//
	//	+------------------------------+------------------------------------------------------------------+
	//	|                              |                                                                  |
	//	|            VALUE             |                             MEANING                              |
	//	|                              |                                                                  |
	//	+------------------------------+------------------------------------------------------------------+
	//	+------------------------------+------------------------------------------------------------------+
	//	| FAX_API_VERSION_0 0x00000000 | No FAX_ERR_* values can be returned.                             |
	//	+------------------------------+------------------------------------------------------------------+
	//	| FAX_API_VERSION_1 0x00010000 | FAX_ERR_* values in the FAX_ERR 7001-7012 range can be returned. |
	//	+------------------------------+------------------------------------------------------------------+
	//	| FAX_API_VERSION_2 0x00020000 | FAX_ERR_* values in the FAX_ERR 7001-7013 range can be returned. |
	//	+------------------------------+------------------------------------------------------------------+
	//	| FAX_API_VERSION_3 0x00030000 | FAX_ERR_* values in the FAX_ERR 7001-7013 range can be returned. |
	//	+------------------------------+------------------------------------------------------------------+
	ClientAPIVersion uint32 `idl:"name:dwClientAPIVersion" json:"client_api_version"`
}

func (o *ConnectFaxServerRequest) xxx_ToOp(ctx context.Context, op *xxx_ConnectFaxServerOperation) *xxx_ConnectFaxServerOperation {
	if op == nil {
		op = &xxx_ConnectFaxServerOperation{}
	}
	if o == nil {
		return op
	}
	op.ClientAPIVersion = o.ClientAPIVersion
	return op
}

func (o *ConnectFaxServerRequest) xxx_FromOp(ctx context.Context, op *xxx_ConnectFaxServerOperation) {
	if o == nil {
		return
	}
	o.ClientAPIVersion = op.ClientAPIVersion
}
func (o *ConnectFaxServerRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *ConnectFaxServerRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ConnectFaxServerOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ConnectFaxServerResponse structure represents the FAX_ConnectFaxServer operation response
type ConnectFaxServerResponse struct {
	// lpdwServerAPIVersion: A pointer to a DWORD that contains the protocol and fax API
	// version of the fax server that is reported back by the fax server to the fax client.
	// This value MUST be one of the constants defined in section 2.2.85.
	ServerAPIVersion uint32 `idl:"name:lpdwServerAPIVersion;pointer:ref" json:"server_api_version"`
	// pHandle: The connection handle returned by the fax server. The client MUST use this
	// connection handle as the Handle argument for the FAX_ConnectionRefCount call made
	// to disconnect from the fax server at the end of the session.
	Handle *fax.Service `idl:"name:pHandle;pointer:ref" json:"handle"`
	// Return: The FAX_ConnectFaxServer return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ConnectFaxServerResponse) xxx_ToOp(ctx context.Context, op *xxx_ConnectFaxServerOperation) *xxx_ConnectFaxServerOperation {
	if op == nil {
		op = &xxx_ConnectFaxServerOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerAPIVersion = o.ServerAPIVersion
	op.Handle = o.Handle
	op.Return = o.Return
	return op
}

func (o *ConnectFaxServerResponse) xxx_FromOp(ctx context.Context, op *xxx_ConnectFaxServerOperation) {
	if o == nil {
		return
	}
	o.ServerAPIVersion = op.ServerAPIVersion
	o.Handle = op.Handle
	o.Return = op.Return
}
func (o *ConnectFaxServerResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *ConnectFaxServerResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ConnectFaxServerOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetSecurityExOperation structure represents the FAX_GetSecurityEx operation
type xxx_GetSecurityExOperation struct {
	SecurityInformation uint32 `idl:"name:SecurityInformation" json:"security_information"`
	SecurityDescriptor  []byte `idl:"name:pSecurityDescriptor;size_is:(, lpdwBufferSize)" json:"security_descriptor"`
	BufferSize          uint32 `idl:"name:lpdwBufferSize;pointer:ref" json:"buffer_size"`
	Return              uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetSecurityExOperation) OpNum() int { return 80 }

func (o *xxx_GetSecurityExOperation) OpName() string { return "/fax/v4/FAX_GetSecurityEx" }

func (o *xxx_GetSecurityExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetSecurityExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// SecurityInformation {in} (1:{alias=SECURITY_INFORMATION, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.SecurityInformation); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetSecurityExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// SecurityInformation {in} (1:{alias=SECURITY_INFORMATION, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.SecurityInformation); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetSecurityExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.SecurityDescriptor != nil && o.BufferSize == 0 {
		o.BufferSize = uint32(len(o.SecurityDescriptor))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetSecurityExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pSecurityDescriptor {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE}*(1))(3:{alias=BYTE}[dim:0,size_is=lpdwBufferSize](uchar))
	{
		if o.SecurityDescriptor != nil || o.BufferSize > 0 {
			_ptr_pSecurityDescriptor := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.BufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.SecurityDescriptor {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.SecurityDescriptor[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.SecurityDescriptor); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.SecurityDescriptor, _ptr_pSecurityDescriptor); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpdwBufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetSecurityExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pSecurityDescriptor {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE,pointer=ref}*(1))(3:{alias=BYTE}[dim:0,size_is=lpdwBufferSize](uchar))
	{
		_ptr_pSecurityDescriptor := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.SecurityDescriptor", sizeInfo[0])
			}
			o.SecurityDescriptor = make([]byte, sizeInfo[0])
			for i1 := range o.SecurityDescriptor {
				i1 := i1
				if err := w.ReadData(&o.SecurityDescriptor[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_pSecurityDescriptor := func(ptr interface{}) { o.SecurityDescriptor = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.SecurityDescriptor, _s_pSecurityDescriptor, _ptr_pSecurityDescriptor); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpdwBufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetSecurityExRequest structure represents the FAX_GetSecurityEx operation request
type GetSecurityExRequest struct {
	// SecurityInformation: Defines the desired entries, which are indicated as a bitwise
	// OR operation, in the security descriptor to return.
	//
	// §  OWNER_SECURITY_INFORMATION 0x00000001
	//
	// §  GROUP_SECURITY_INFORMATION 0x00000002
	//
	// §  DACL_SECURITY_INFORMATION 0x00000004
	//
	// §  SACL_SECURITY_INFORMATION 0x00000008
	SecurityInformation uint32 `idl:"name:SecurityInformation" json:"security_information"`
}

func (o *GetSecurityExRequest) xxx_ToOp(ctx context.Context, op *xxx_GetSecurityExOperation) *xxx_GetSecurityExOperation {
	if op == nil {
		op = &xxx_GetSecurityExOperation{}
	}
	if o == nil {
		return op
	}
	op.SecurityInformation = o.SecurityInformation
	return op
}

func (o *GetSecurityExRequest) xxx_FromOp(ctx context.Context, op *xxx_GetSecurityExOperation) {
	if o == nil {
		return
	}
	o.SecurityInformation = op.SecurityInformation
}
func (o *GetSecurityExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetSecurityExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetSecurityExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetSecurityExResponse structure represents the FAX_GetSecurityEx operation response
type GetSecurityExResponse struct {
	// pSecurityDescriptor: A pointer to a SECURITY_DESCRIPTOR.
	SecurityDescriptor []byte `idl:"name:pSecurityDescriptor;size_is:(, lpdwBufferSize)" json:"security_descriptor"`
	// lpdwBufferSize: A pointer to a DWORD ([MS-DTYP] section 2.2.9) value that indicates
	// the size of the pSecurityDescriptor buffer.
	BufferSize uint32 `idl:"name:lpdwBufferSize;pointer:ref" json:"buffer_size"`
	// Return: The FAX_GetSecurityEx return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetSecurityExResponse) xxx_ToOp(ctx context.Context, op *xxx_GetSecurityExOperation) *xxx_GetSecurityExOperation {
	if op == nil {
		op = &xxx_GetSecurityExOperation{}
	}
	if o == nil {
		return op
	}
	op.SecurityDescriptor = o.SecurityDescriptor
	op.BufferSize = o.BufferSize
	op.Return = o.Return
	return op
}

func (o *GetSecurityExResponse) xxx_FromOp(ctx context.Context, op *xxx_GetSecurityExOperation) {
	if o == nil {
		return
	}
	o.SecurityDescriptor = op.SecurityDescriptor
	o.BufferSize = op.BufferSize
	o.Return = op.Return
}
func (o *GetSecurityExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetSecurityExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetSecurityExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_RefreshArchiveOperation structure represents the FAX_RefreshArchive operation
type xxx_RefreshArchiveOperation struct {
	Folder fax.MessageFolder `idl:"name:Folder" json:"folder"`
	Return uint32            `idl:"name:Return" json:"return"`
}

func (o *xxx_RefreshArchiveOperation) OpNum() int { return 81 }

func (o *xxx_RefreshArchiveOperation) OpName() string { return "/fax/v4/FAX_RefreshArchive" }

func (o *xxx_RefreshArchiveOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RefreshArchiveOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// Folder {in} (1:{alias=FAX_ENUM_MESSAGE_FOLDER}(enum))
	{
		if err := w.WriteEnum(uint16(o.Folder)); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RefreshArchiveOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// Folder {in} (1:{alias=FAX_ENUM_MESSAGE_FOLDER}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.Folder)); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RefreshArchiveOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RefreshArchiveOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RefreshArchiveOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// RefreshArchiveRequest structure represents the FAX_RefreshArchive operation request
type RefreshArchiveRequest struct {
	// Folder: A value indicating the archive folder to refresh. The value can be either
	// FAX_MESSAGE_FOLDER_INBOX or FAX_MESSAGE_FOLDER_SENTITEMS. For more information, see
	// FAX_ENUM_MESSAGE_FOLDER (section 2.2.2).<146>
	Folder fax.MessageFolder `idl:"name:Folder" json:"folder"`
}

func (o *RefreshArchiveRequest) xxx_ToOp(ctx context.Context, op *xxx_RefreshArchiveOperation) *xxx_RefreshArchiveOperation {
	if op == nil {
		op = &xxx_RefreshArchiveOperation{}
	}
	if o == nil {
		return op
	}
	op.Folder = o.Folder
	return op
}

func (o *RefreshArchiveRequest) xxx_FromOp(ctx context.Context, op *xxx_RefreshArchiveOperation) {
	if o == nil {
		return
	}
	o.Folder = op.Folder
}
func (o *RefreshArchiveRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *RefreshArchiveRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RefreshArchiveOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// RefreshArchiveResponse structure represents the FAX_RefreshArchive operation response
type RefreshArchiveResponse struct {
	// Return: The FAX_RefreshArchive return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *RefreshArchiveResponse) xxx_ToOp(ctx context.Context, op *xxx_RefreshArchiveOperation) *xxx_RefreshArchiveOperation {
	if op == nil {
		op = &xxx_RefreshArchiveOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *RefreshArchiveResponse) xxx_FromOp(ctx context.Context, op *xxx_RefreshArchiveOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *RefreshArchiveResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *RefreshArchiveResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RefreshArchiveOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetRecipientsLimitOperation structure represents the FAX_SetRecipientsLimit operation
type xxx_SetRecipientsLimitOperation struct {
	RecipientsLimit uint32 `idl:"name:dwRecipientsLimit" json:"recipients_limit"`
	Return          uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_SetRecipientsLimitOperation) OpNum() int { return 82 }

func (o *xxx_SetRecipientsLimitOperation) OpName() string { return "/fax/v4/FAX_SetRecipientsLimit" }

func (o *xxx_SetRecipientsLimitOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetRecipientsLimitOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// dwRecipientsLimit {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RecipientsLimit); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetRecipientsLimitOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// dwRecipientsLimit {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RecipientsLimit); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetRecipientsLimitOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetRecipientsLimitOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetRecipientsLimitOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetRecipientsLimitRequest structure represents the FAX_SetRecipientsLimit operation request
type SetRecipientsLimitRequest struct {
	// dwRecipientsLimit: A DWORD ([MS-DTYP] section 2.2.9) that specifies the maximum number
	// of recipients for the fax.
	RecipientsLimit uint32 `idl:"name:dwRecipientsLimit" json:"recipients_limit"`
}

func (o *SetRecipientsLimitRequest) xxx_ToOp(ctx context.Context, op *xxx_SetRecipientsLimitOperation) *xxx_SetRecipientsLimitOperation {
	if op == nil {
		op = &xxx_SetRecipientsLimitOperation{}
	}
	if o == nil {
		return op
	}
	op.RecipientsLimit = o.RecipientsLimit
	return op
}

func (o *SetRecipientsLimitRequest) xxx_FromOp(ctx context.Context, op *xxx_SetRecipientsLimitOperation) {
	if o == nil {
		return
	}
	o.RecipientsLimit = op.RecipientsLimit
}
func (o *SetRecipientsLimitRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetRecipientsLimitRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetRecipientsLimitOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetRecipientsLimitResponse structure represents the FAX_SetRecipientsLimit operation response
type SetRecipientsLimitResponse struct {
	// Return: The FAX_SetRecipientsLimit return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetRecipientsLimitResponse) xxx_ToOp(ctx context.Context, op *xxx_SetRecipientsLimitOperation) *xxx_SetRecipientsLimitOperation {
	if op == nil {
		op = &xxx_SetRecipientsLimitOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetRecipientsLimitResponse) xxx_FromOp(ctx context.Context, op *xxx_SetRecipientsLimitOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetRecipientsLimitResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetRecipientsLimitResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetRecipientsLimitOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetRecipientsLimitOperation structure represents the FAX_GetRecipientsLimit operation
type xxx_GetRecipientsLimitOperation struct {
	RecipientsLimit uint32 `idl:"name:lpdwRecipientsLimit;pointer:ref" json:"recipients_limit"`
	Return          uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetRecipientsLimitOperation) OpNum() int { return 83 }

func (o *xxx_GetRecipientsLimitOperation) OpName() string { return "/fax/v4/FAX_GetRecipientsLimit" }

func (o *xxx_GetRecipientsLimitOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetRecipientsLimitOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	return nil
}

func (o *xxx_GetRecipientsLimitOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	return nil
}

func (o *xxx_GetRecipientsLimitOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetRecipientsLimitOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpdwRecipientsLimit {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RecipientsLimit); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetRecipientsLimitOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpdwRecipientsLimit {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RecipientsLimit); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetRecipientsLimitRequest structure represents the FAX_GetRecipientsLimit operation request
type GetRecipientsLimitRequest struct {
}

func (o *GetRecipientsLimitRequest) xxx_ToOp(ctx context.Context, op *xxx_GetRecipientsLimitOperation) *xxx_GetRecipientsLimitOperation {
	if op == nil {
		op = &xxx_GetRecipientsLimitOperation{}
	}
	if o == nil {
		return op
	}
	return op
}

func (o *GetRecipientsLimitRequest) xxx_FromOp(ctx context.Context, op *xxx_GetRecipientsLimitOperation) {
	if o == nil {
		return
	}
}
func (o *GetRecipientsLimitRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetRecipientsLimitRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetRecipientsLimitOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetRecipientsLimitResponse structure represents the FAX_GetRecipientsLimit operation response
type GetRecipientsLimitResponse struct {
	// lpdwRecipientsLimit: A pointer to a DWORD ([MS-DTYP] section 2.2.9) value. This is
	// set to the maximum number of recipients to which a fax can be sent.
	RecipientsLimit uint32 `idl:"name:lpdwRecipientsLimit;pointer:ref" json:"recipients_limit"`
	// Return: The FAX_GetRecipientsLimit return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetRecipientsLimitResponse) xxx_ToOp(ctx context.Context, op *xxx_GetRecipientsLimitOperation) *xxx_GetRecipientsLimitOperation {
	if op == nil {
		op = &xxx_GetRecipientsLimitOperation{}
	}
	if o == nil {
		return op
	}
	op.RecipientsLimit = o.RecipientsLimit
	op.Return = o.Return
	return op
}

func (o *GetRecipientsLimitResponse) xxx_FromOp(ctx context.Context, op *xxx_GetRecipientsLimitOperation) {
	if o == nil {
		return
	}
	o.RecipientsLimit = op.RecipientsLimit
	o.Return = op.Return
}
func (o *GetRecipientsLimitResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetRecipientsLimitResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetRecipientsLimitOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetServerSKUOperation structure represents the FAX_GetServerSKU operation
type xxx_GetServerSKUOperation struct {
	ServerSKU fax.ProductSKUType `idl:"name:pServerSKU;pointer:ref" json:"server_sku"`
	Return    uint32             `idl:"name:Return" json:"return"`
}

func (o *xxx_GetServerSKUOperation) OpNum() int { return 84 }

func (o *xxx_GetServerSKUOperation) OpName() string { return "/fax/v4/FAX_GetServerSKU" }

func (o *xxx_GetServerSKUOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServerSKUOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	return nil
}

func (o *xxx_GetServerSKUOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	return nil
}

func (o *xxx_GetServerSKUOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServerSKUOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pServerSKU {out} (1:{pointer=ref}*(1))(2:{alias=PRODUCT_SKU_TYPE}(enum))
	{
		if err := w.WriteEnum(uint16(o.ServerSKU)); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServerSKUOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pServerSKU {out} (1:{pointer=ref}*(1))(2:{alias=PRODUCT_SKU_TYPE}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.ServerSKU)); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetServerSKURequest structure represents the FAX_GetServerSKU operation request
type GetServerSKURequest struct {
}

func (o *GetServerSKURequest) xxx_ToOp(ctx context.Context, op *xxx_GetServerSKUOperation) *xxx_GetServerSKUOperation {
	if op == nil {
		op = &xxx_GetServerSKUOperation{}
	}
	if o == nil {
		return op
	}
	return op
}

func (o *GetServerSKURequest) xxx_FromOp(ctx context.Context, op *xxx_GetServerSKUOperation) {
	if o == nil {
		return
	}
}
func (o *GetServerSKURequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetServerSKURequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetServerSKUOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetServerSKUResponse structure represents the FAX_GetServerSKU operation response
type GetServerSKUResponse struct {
	// pServerSKU: A pointer to a PRODUCT_SKU_TYPE (section 2.2.75) enumeration that receives
	// the fax server SKU.
	ServerSKU fax.ProductSKUType `idl:"name:pServerSKU;pointer:ref" json:"server_sku"`
	// Return: The FAX_GetServerSKU return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetServerSKUResponse) xxx_ToOp(ctx context.Context, op *xxx_GetServerSKUOperation) *xxx_GetServerSKUOperation {
	if op == nil {
		op = &xxx_GetServerSKUOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerSKU = o.ServerSKU
	op.Return = o.Return
	return op
}

func (o *GetServerSKUResponse) xxx_FromOp(ctx context.Context, op *xxx_GetServerSKUOperation) {
	if o == nil {
		return
	}
	o.ServerSKU = op.ServerSKU
	o.Return = op.Return
}
func (o *GetServerSKUResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetServerSKUResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetServerSKUOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CheckValidFaxFolderOperation structure represents the FAX_CheckValidFaxFolder operation
type xxx_CheckValidFaxFolderOperation struct {
	Path   string `idl:"name:lpcwstrPath;string;pointer:ref" json:"path"`
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_CheckValidFaxFolderOperation) OpNum() int { return 85 }

func (o *xxx_CheckValidFaxFolderOperation) OpName() string { return "/fax/v4/FAX_CheckValidFaxFolder" }

func (o *xxx_CheckValidFaxFolderOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CheckValidFaxFolderOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lpcwstrPath {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.Path); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CheckValidFaxFolderOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lpcwstrPath {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.Path); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CheckValidFaxFolderOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CheckValidFaxFolderOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CheckValidFaxFolderOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CheckValidFaxFolderRequest structure represents the FAX_CheckValidFaxFolder operation request
type CheckValidFaxFolderRequest struct {
	// lpcwstrPath: A pointer to a null-terminated character string that contains the path
	// to validate, specified as a complete file path. The path can be a UNC path or a path
	// that begins with a drive letter. The path MUST contain a file name. The length of
	// the path, including the terminating null character, MUST be under 180 characters.
	Path string `idl:"name:lpcwstrPath;string;pointer:ref" json:"path"`
}

func (o *CheckValidFaxFolderRequest) xxx_ToOp(ctx context.Context, op *xxx_CheckValidFaxFolderOperation) *xxx_CheckValidFaxFolderOperation {
	if op == nil {
		op = &xxx_CheckValidFaxFolderOperation{}
	}
	if o == nil {
		return op
	}
	op.Path = o.Path
	return op
}

func (o *CheckValidFaxFolderRequest) xxx_FromOp(ctx context.Context, op *xxx_CheckValidFaxFolderOperation) {
	if o == nil {
		return
	}
	o.Path = op.Path
}
func (o *CheckValidFaxFolderRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *CheckValidFaxFolderRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CheckValidFaxFolderOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CheckValidFaxFolderResponse structure represents the FAX_CheckValidFaxFolder operation response
type CheckValidFaxFolderResponse struct {
	// Return: The FAX_CheckValidFaxFolder return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CheckValidFaxFolderResponse) xxx_ToOp(ctx context.Context, op *xxx_CheckValidFaxFolderOperation) *xxx_CheckValidFaxFolderOperation {
	if op == nil {
		op = &xxx_CheckValidFaxFolderOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *CheckValidFaxFolderResponse) xxx_FromOp(ctx context.Context, op *xxx_CheckValidFaxFolderOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *CheckValidFaxFolderResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *CheckValidFaxFolderResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CheckValidFaxFolderOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetJobEx2Operation structure represents the FAX_GetJobEx2 operation
type xxx_GetJobEx2Operation struct {
	MessageID  uint64 `idl:"name:dwlMessageID" json:"message_id"`
	Level      uint32 `idl:"name:level" json:"level"`
	Buffer     []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	BufferSize uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	Return     uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetJobEx2Operation) OpNum() int { return 86 }

func (o *xxx_GetJobEx2Operation) OpName() string { return "/fax/v4/FAX_GetJobEx2" }

func (o *xxx_GetJobEx2Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetJobEx2Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// dwlMessageID {in} (1:{alias=DWORDLONG, names=ULONGLONG}(uint64))
	{
		if err := w.WriteData(o.MessageID); err != nil {
			return err
		}
	}
	// level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Level); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetJobEx2Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// dwlMessageID {in} (1:{alias=DWORDLONG, names=ULONGLONG}(uint64))
	{
		if err := w.ReadData(&o.MessageID); err != nil {
			return err
		}
	}
	// level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Level); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetJobEx2Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Buffer != nil && o.BufferSize == 0 {
		o.BufferSize = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetJobEx2Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		if o.Buffer != nil || o.BufferSize > 0 {
			_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.BufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Buffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Buffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetJobEx2Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE,pointer=ref}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
			}
			o.Buffer = make([]byte, sizeInfo[0])
			for i1 := range o.Buffer {
				i1 := i1
				if err := w.ReadData(&o.Buffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetJobEx2Request structure represents the FAX_GetJobEx2 operation request
type GetJobEx2Request struct {
	// dwlMessageID: A DWORDLONG ([MS-DTYP] section 2.2.13) value that specifies a unique
	// number that identifies a queued or active fax job. The job MUST be an inbound or
	// outbound transmission.
	MessageID uint64 `idl:"name:dwlMessageID" json:"message_id"`
	// level: A DWORD ([MS-DTYP] section 2.2.9) value that indicates the structure to return
	// in Buffer. This value MUST be set to 1.
	Level uint32 `idl:"name:level" json:"level"`
}

func (o *GetJobEx2Request) xxx_ToOp(ctx context.Context, op *xxx_GetJobEx2Operation) *xxx_GetJobEx2Operation {
	if op == nil {
		op = &xxx_GetJobEx2Operation{}
	}
	if o == nil {
		return op
	}
	op.MessageID = o.MessageID
	op.Level = o.Level
	return op
}

func (o *GetJobEx2Request) xxx_FromOp(ctx context.Context, op *xxx_GetJobEx2Operation) {
	if o == nil {
		return
	}
	o.MessageID = op.MessageID
	o.Level = op.Level
}
func (o *GetJobEx2Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetJobEx2Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetJobEx2Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetJobEx2Response structure represents the FAX_GetJobEx2 operation response
type GetJobEx2Response struct {
	// Buffer: A pointer to the address of a buffer that receives a FAX_JOB_ENTRY_EX_1.
	Buffer []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	// BufferSize: A pointer to a DWORD value that specifies the size, in bytes, of the
	// buffer that is pointed to by the Buffer parameter.
	BufferSize uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	// Return: The FAX_GetJobEx2 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetJobEx2Response) xxx_ToOp(ctx context.Context, op *xxx_GetJobEx2Operation) *xxx_GetJobEx2Operation {
	if op == nil {
		op = &xxx_GetJobEx2Operation{}
	}
	if o == nil {
		return op
	}
	op.Buffer = o.Buffer
	op.BufferSize = o.BufferSize
	op.Return = o.Return
	return op
}

func (o *GetJobEx2Response) xxx_FromOp(ctx context.Context, op *xxx_GetJobEx2Operation) {
	if o == nil {
		return
	}
	o.Buffer = op.Buffer
	o.BufferSize = op.BufferSize
	o.Return = op.Return
}
func (o *GetJobEx2Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetJobEx2Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetJobEx2Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumJobsEx2Operation structure represents the FAX_EnumJobsEx2 operation
type xxx_EnumJobsEx2Operation struct {
	AllAccounts bool   `idl:"name:fAllAccounts" json:"all_accounts"`
	AccountName string `idl:"name:lpcwstrAccountName;string;pointer:unique" json:"account_name"`
	JobTypes    uint32 `idl:"name:dwJobTypes" json:"job_types"`
	Level       uint32 `idl:"name:level" json:"level"`
	Buffer      []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	BufferSize  uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	Jobs        uint32 `idl:"name:lpdwJobs;pointer:ref" json:"jobs"`
	Return      uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumJobsEx2Operation) OpNum() int { return 87 }

func (o *xxx_EnumJobsEx2Operation) OpName() string { return "/fax/v4/FAX_EnumJobsEx2" }

func (o *xxx_EnumJobsEx2Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumJobsEx2Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// fAllAccounts {in} (1:{alias=BOOL}(int32))
	{
		if !o.AllAccounts {
			if err := w.WriteData(int32(0)); err != nil {
				return err
			}
		} else {
			if err := w.WriteData(int32(1)); err != nil {
				return err
			}
		}
	}
	// lpcwstrAccountName {in} (1:{string, pointer=unique, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.AccountName != "" {
			_ptr_lpcwstrAccountName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.AccountName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.AccountName, _ptr_lpcwstrAccountName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// dwJobTypes {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.JobTypes); err != nil {
			return err
		}
	}
	// level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Level); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumJobsEx2Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// fAllAccounts {in} (1:{alias=BOOL}(int32))
	{
		var _bAllAccounts int32
		if err := w.ReadData(&_bAllAccounts); err != nil {
			return err
		}
		o.AllAccounts = _bAllAccounts != 0
	}
	// lpcwstrAccountName {in} (1:{string, pointer=unique, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_lpcwstrAccountName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.AccountName); err != nil {
				return err
			}
			return nil
		})
		_s_lpcwstrAccountName := func(ptr interface{}) { o.AccountName = *ptr.(*string) }
		if err := w.ReadPointer(&o.AccountName, _s_lpcwstrAccountName, _ptr_lpcwstrAccountName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// dwJobTypes {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.JobTypes); err != nil {
			return err
		}
	}
	// level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Level); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumJobsEx2Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Buffer != nil && o.BufferSize == 0 {
		o.BufferSize = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumJobsEx2Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		if o.Buffer != nil || o.BufferSize > 0 {
			_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.BufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Buffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Buffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	// lpdwJobs {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Jobs); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumJobsEx2Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE,pointer=ref}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
			}
			o.Buffer = make([]byte, sizeInfo[0])
			for i1 := range o.Buffer {
				i1 := i1
				if err := w.ReadData(&o.Buffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	// lpdwJobs {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Jobs); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumJobsEx2Request structure represents the FAX_EnumJobsEx2 operation request
type EnumJobsEx2Request struct {
	// fAllAccounts: Flag indicating whether the jobs for all accounts are enumerated. If
	// this parameter is nonzero, the jobs for all accounts are enumerated and lpcwstrAccountName
	// is reset to NULL and not taken into account. Otherwise, the lpcwstrAccountName parameter
	// SHOULD indicate which accounts are to be enumerated.
	AllAccounts bool `idl:"name:fAllAccounts" json:"all_accounts"`
	// lpcwstrAccountName: Pointer to a constant, null-terminated character string that
	// indicates which account to enumerate. If this value is set to NULL, the current account's
	// jobs are enumerated. Cross-account enumeration is currently not supported. If the
	// fAllAccounts parameter is nonzero, this value is reset to NULL. The value for this
	// parameter can be obtained using the FAX_EnumAccounts (section 3.1.4.1.18) method.
	AccountName string `idl:"name:lpcwstrAccountName;string;pointer:unique" json:"account_name"`
	// dwJobTypes: A DWORD ([MS-DTYP] section 2.2.9) value that MUST consist of a bitwise
	// combination of the job types defined in section 3.1.1. Only jobs that are of the
	// requested types SHOULD be returned in the buffer.
	JobTypes uint32 `idl:"name:dwJobTypes" json:"job_types"`
	// level: A DWORD value that indicates the type of structure to return in the Buffer
	// parameter. The value MUST be set to 1.
	Level uint32 `idl:"name:level" json:"level"`
}

func (o *EnumJobsEx2Request) xxx_ToOp(ctx context.Context, op *xxx_EnumJobsEx2Operation) *xxx_EnumJobsEx2Operation {
	if op == nil {
		op = &xxx_EnumJobsEx2Operation{}
	}
	if o == nil {
		return op
	}
	op.AllAccounts = o.AllAccounts
	op.AccountName = o.AccountName
	op.JobTypes = o.JobTypes
	op.Level = o.Level
	return op
}

func (o *EnumJobsEx2Request) xxx_FromOp(ctx context.Context, op *xxx_EnumJobsEx2Operation) {
	if o == nil {
		return
	}
	o.AllAccounts = op.AllAccounts
	o.AccountName = op.AccountName
	o.JobTypes = op.JobTypes
	o.Level = op.Level
}
func (o *EnumJobsEx2Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumJobsEx2Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumJobsEx2Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumJobsEx2Response structure represents the FAX_EnumJobsEx2 operation response
type EnumJobsEx2Response struct {
	// Buffer: Pointer to the address of a buffer that will receive an array of FAX_JOB_ENTRY_EX_1
	// (section 2.2.34) structures. Each structure describes one fax job.
	Buffer []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	// BufferSize: Pointer to a DWORD value that returns the size, in bytes, of Buffer.
	BufferSize uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	// lpdwJobs: Pointer to a DWORD value that receives the number of FAX_JOB_ENTRY_EX_1
	// that the method returns in Buffer.
	Jobs uint32 `idl:"name:lpdwJobs;pointer:ref" json:"jobs"`
	// Return: The FAX_EnumJobsEx2 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumJobsEx2Response) xxx_ToOp(ctx context.Context, op *xxx_EnumJobsEx2Operation) *xxx_EnumJobsEx2Operation {
	if op == nil {
		op = &xxx_EnumJobsEx2Operation{}
	}
	if o == nil {
		return op
	}
	op.Buffer = o.Buffer
	op.BufferSize = o.BufferSize
	op.Jobs = o.Jobs
	op.Return = o.Return
	return op
}

func (o *EnumJobsEx2Response) xxx_FromOp(ctx context.Context, op *xxx_EnumJobsEx2Operation) {
	if o == nil {
		return
	}
	o.Buffer = op.Buffer
	o.BufferSize = op.BufferSize
	o.Jobs = op.Jobs
	o.Return = op.Return
}
func (o *EnumJobsEx2Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumJobsEx2Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumJobsEx2Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetMessageExOperation structure represents the FAX_GetMessageEx operation
type xxx_GetMessageExOperation struct {
	MessageID  uint64            `idl:"name:dwlMessageId" json:"message_id"`
	Folder     fax.MessageFolder `idl:"name:Folder" json:"folder"`
	Level      uint32            `idl:"name:level" json:"level"`
	Buffer     []byte            `idl:"name:lppBuffer;size_is:(, lpdwBufferSize)" json:"buffer"`
	BufferSize uint32            `idl:"name:lpdwBufferSize;pointer:ref" json:"buffer_size"`
	Return     uint32            `idl:"name:Return" json:"return"`
}

func (o *xxx_GetMessageExOperation) OpNum() int { return 88 }

func (o *xxx_GetMessageExOperation) OpName() string { return "/fax/v4/FAX_GetMessageEx" }

func (o *xxx_GetMessageExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMessageExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// dwlMessageId {in} (1:{alias=DWORDLONG, names=ULONGLONG}(uint64))
	{
		if err := w.WriteData(o.MessageID); err != nil {
			return err
		}
	}
	// Folder {in} (1:{alias=FAX_ENUM_MESSAGE_FOLDER}(enum))
	{
		if err := w.WriteEnum(uint16(o.Folder)); err != nil {
			return err
		}
	}
	// level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Level); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMessageExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// dwlMessageId {in} (1:{alias=DWORDLONG, names=ULONGLONG}(uint64))
	{
		if err := w.ReadData(&o.MessageID); err != nil {
			return err
		}
	}
	// Folder {in} (1:{alias=FAX_ENUM_MESSAGE_FOLDER}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.Folder)); err != nil {
			return err
		}
	}
	// level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Level); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMessageExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Buffer != nil && o.BufferSize == 0 {
		o.BufferSize = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMessageExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lppBuffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE}*(1))(3:{alias=BYTE}[dim:0,size_is=lpdwBufferSize](uchar))
	{
		if o.Buffer != nil || o.BufferSize > 0 {
			_ptr_lppBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.BufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Buffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Buffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Buffer, _ptr_lppBuffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpdwBufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMessageExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lppBuffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE,pointer=ref}*(1))(3:{alias=BYTE}[dim:0,size_is=lpdwBufferSize](uchar))
	{
		_ptr_lppBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
			}
			o.Buffer = make([]byte, sizeInfo[0])
			for i1 := range o.Buffer {
				i1 := i1
				if err := w.ReadData(&o.Buffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_lppBuffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Buffer, _s_lppBuffer, _ptr_lppBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpdwBufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetMessageExRequest structure represents the FAX_GetMessageEx operation request
type GetMessageExRequest struct {
	// dwlMessageId: A DWORDLONG ([MS-DTYP] section 2.2.13) value that identifies the fax
	// message to retrieve from the archive.
	MessageID uint64 `idl:"name:dwlMessageId" json:"message_id"`
	// Folder: A FAX_ENUM_MESSAGE_FOLDER that indicates the type of the archive where the
	// message resides. The FAX_MESSAGE_FOLDER_QUEUE value is invalid for this parameter.
	Folder fax.MessageFolder `idl:"name:Folder" json:"folder"`
	// level: A DWORD ([MS-DTYP] section 2.2.9) value that indicates the type of structure
	// to return in lppBuffer. The only value currently supported is 1.
	Level uint32 `idl:"name:level" json:"level"`
}

func (o *GetMessageExRequest) xxx_ToOp(ctx context.Context, op *xxx_GetMessageExOperation) *xxx_GetMessageExOperation {
	if op == nil {
		op = &xxx_GetMessageExOperation{}
	}
	if o == nil {
		return op
	}
	op.MessageID = o.MessageID
	op.Folder = o.Folder
	op.Level = o.Level
	return op
}

func (o *GetMessageExRequest) xxx_FromOp(ctx context.Context, op *xxx_GetMessageExOperation) {
	if o == nil {
		return
	}
	o.MessageID = op.MessageID
	o.Folder = op.Folder
	o.Level = op.Level
}
func (o *GetMessageExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetMessageExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetMessageExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetMessageExResponse structure represents the FAX_GetMessageEx operation response
type GetMessageExResponse struct {
	// lppBuffer: A pointer to an array of FAX_MESSAGE_1 structures that contain the retrieved
	// messages.
	Buffer []byte `idl:"name:lppBuffer;size_is:(, lpdwBufferSize)" json:"buffer"`
	// lpdwBufferSize: A pointer to a DWORD value that specifies the size, in bytes, of
	// the buffer that is pointed to by the lppBuffer parameter.
	BufferSize uint32 `idl:"name:lpdwBufferSize;pointer:ref" json:"buffer_size"`
	// Return: The FAX_GetMessageEx return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetMessageExResponse) xxx_ToOp(ctx context.Context, op *xxx_GetMessageExOperation) *xxx_GetMessageExOperation {
	if op == nil {
		op = &xxx_GetMessageExOperation{}
	}
	if o == nil {
		return op
	}
	op.Buffer = o.Buffer
	op.BufferSize = o.BufferSize
	op.Return = o.Return
	return op
}

func (o *GetMessageExResponse) xxx_FromOp(ctx context.Context, op *xxx_GetMessageExOperation) {
	if o == nil {
		return
	}
	o.Buffer = op.Buffer
	o.BufferSize = op.BufferSize
	o.Return = op.Return
}
func (o *GetMessageExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetMessageExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetMessageExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_StartMessagesEnumExOperation structure represents the FAX_StartMessagesEnumEx operation
type xxx_StartMessagesEnumExOperation struct {
	AllAccounts bool              `idl:"name:fAllAccounts" json:"all_accounts"`
	AccountName string            `idl:"name:lpcwstrAccountName;string;pointer:unique" json:"account_name"`
	Folder      fax.MessageFolder `idl:"name:Folder" json:"folder"`
	Level       uint32            `idl:"name:level" json:"level"`
	Handle      *fax.MessageEnum  `idl:"name:lpHandle;pointer:ref" json:"handle"`
	Return      uint32            `idl:"name:Return" json:"return"`
}

func (o *xxx_StartMessagesEnumExOperation) OpNum() int { return 89 }

func (o *xxx_StartMessagesEnumExOperation) OpName() string { return "/fax/v4/FAX_StartMessagesEnumEx" }

func (o *xxx_StartMessagesEnumExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartMessagesEnumExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// fAllAccounts {in} (1:{alias=BOOL}(int32))
	{
		if !o.AllAccounts {
			if err := w.WriteData(int32(0)); err != nil {
				return err
			}
		} else {
			if err := w.WriteData(int32(1)); err != nil {
				return err
			}
		}
	}
	// lpcwstrAccountName {in} (1:{string, pointer=unique, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.AccountName != "" {
			_ptr_lpcwstrAccountName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.AccountName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.AccountName, _ptr_lpcwstrAccountName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Folder {in} (1:{alias=FAX_ENUM_MESSAGE_FOLDER}(enum))
	{
		if err := w.WriteEnum(uint16(o.Folder)); err != nil {
			return err
		}
	}
	// level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Level); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartMessagesEnumExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// fAllAccounts {in} (1:{alias=BOOL}(int32))
	{
		var _bAllAccounts int32
		if err := w.ReadData(&_bAllAccounts); err != nil {
			return err
		}
		o.AllAccounts = _bAllAccounts != 0
	}
	// lpcwstrAccountName {in} (1:{string, pointer=unique, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_lpcwstrAccountName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.AccountName); err != nil {
				return err
			}
			return nil
		})
		_s_lpcwstrAccountName := func(ptr interface{}) { o.AccountName = *ptr.(*string) }
		if err := w.ReadPointer(&o.AccountName, _s_lpcwstrAccountName, _ptr_lpcwstrAccountName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Folder {in} (1:{alias=FAX_ENUM_MESSAGE_FOLDER}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.Folder)); err != nil {
			return err
		}
	}
	// level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Level); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartMessagesEnumExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartMessagesEnumExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpHandle {out} (1:{pointer=ref, alias=PRPC_FAX_MSG_ENUM_HANDLE}*(1))(2:{context_handle, alias=RPC_FAX_MSG_ENUM_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.MessageEnum{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartMessagesEnumExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpHandle {out} (1:{pointer=ref, alias=PRPC_FAX_MSG_ENUM_HANDLE}*(1))(2:{context_handle, alias=RPC_FAX_MSG_ENUM_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &fax.MessageEnum{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// StartMessagesEnumExRequest structure represents the FAX_StartMessagesEnumEx operation request
type StartMessagesEnumExRequest struct {
	// fAllAccounts: A flag indicating whether the messages for all accounts are enumerated.
	// If this parameter is nonzero, the messages for all accounts are enumerated; otherwise,
	// the lpcwstrAccountName parameter indicates which account is enumerated.
	AllAccounts bool `idl:"name:fAllAccounts" json:"all_accounts"`
	// lpcwstrAccountName: A pointer to a constant null-terminated character string that
	// indicates which account to enumerate. If this value is set to NULL, the current account's
	// jobs are enumerated. Cross-account enumeration is currently not supported. The value
	// for this parameter can be obtained using the FAX_EnumAccounts (section 3.1.4.1.18)
	// method.
	AccountName string `idl:"name:lpcwstrAccountName;string;pointer:unique" json:"account_name"`
	// Folder: A FAX_ENUM_MESSAGE_FOLDER (section 2.2.2) enumeration that indicates the
	// type of archive where the message resides. The FAX_MESSAGE_FOLDER_QUEUE value is
	// invalid for this parameter.
	Folder fax.MessageFolder `idl:"name:Folder" json:"folder"`
	// level: A DWORD ([MS-DTYP] section 2.2.9) value that indicates the structure to return.
	// This value MUST be set to 1.
	Level uint32 `idl:"name:level" json:"level"`
}

func (o *StartMessagesEnumExRequest) xxx_ToOp(ctx context.Context, op *xxx_StartMessagesEnumExOperation) *xxx_StartMessagesEnumExOperation {
	if op == nil {
		op = &xxx_StartMessagesEnumExOperation{}
	}
	if o == nil {
		return op
	}
	op.AllAccounts = o.AllAccounts
	op.AccountName = o.AccountName
	op.Folder = o.Folder
	op.Level = o.Level
	return op
}

func (o *StartMessagesEnumExRequest) xxx_FromOp(ctx context.Context, op *xxx_StartMessagesEnumExOperation) {
	if o == nil {
		return
	}
	o.AllAccounts = op.AllAccounts
	o.AccountName = op.AccountName
	o.Folder = op.Folder
	o.Level = op.Level
}
func (o *StartMessagesEnumExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *StartMessagesEnumExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_StartMessagesEnumExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// StartMessagesEnumExResponse structure represents the FAX_StartMessagesEnumEx operation response
type StartMessagesEnumExResponse struct {
	// lpHandle: A pointer to an enumeration handle return value.
	Handle *fax.MessageEnum `idl:"name:lpHandle;pointer:ref" json:"handle"`
	// Return: The FAX_StartMessagesEnumEx return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *StartMessagesEnumExResponse) xxx_ToOp(ctx context.Context, op *xxx_StartMessagesEnumExOperation) *xxx_StartMessagesEnumExOperation {
	if op == nil {
		op = &xxx_StartMessagesEnumExOperation{}
	}
	if o == nil {
		return op
	}
	op.Handle = o.Handle
	op.Return = o.Return
	return op
}

func (o *StartMessagesEnumExResponse) xxx_FromOp(ctx context.Context, op *xxx_StartMessagesEnumExOperation) {
	if o == nil {
		return
	}
	o.Handle = op.Handle
	o.Return = op.Return
}
func (o *StartMessagesEnumExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *StartMessagesEnumExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_StartMessagesEnumExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumMessagesExOperation structure represents the FAX_EnumMessagesEx operation
type xxx_EnumMessagesExOperation struct {
	Enum                    *fax.MessageEnum `idl:"name:hEnum;pointer:ref" json:"enum"`
	MessagesLength          uint32           `idl:"name:dwNumMessages" json:"messages_length"`
	Buffer                  []byte           `idl:"name:lppBuffer;size_is:(, lpdwBufferSize)" json:"buffer"`
	BufferSize              uint32           `idl:"name:lpdwBufferSize;pointer:ref" json:"buffer_size"`
	MessagesRetrievedLength uint32           `idl:"name:lpdwNumMessagesRetrieved;pointer:ref" json:"messages_retrieved_length"`
	Level                   uint32           `idl:"name:lpdwLevel;pointer:ref" json:"level"`
	Return                  uint32           `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumMessagesExOperation) OpNum() int { return 90 }

func (o *xxx_EnumMessagesExOperation) OpName() string { return "/fax/v4/FAX_EnumMessagesEx" }

func (o *xxx_EnumMessagesExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumMessagesExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hEnum {in} (1:{context_handle, pointer=ref, alias=RPC_FAX_MSG_ENUM_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Enum != nil {
			if err := o.Enum.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.MessageEnum{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwNumMessages {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.MessagesLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumMessagesExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hEnum {in} (1:{context_handle, pointer=ref, alias=RPC_FAX_MSG_ENUM_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Enum == nil {
			o.Enum = &fax.MessageEnum{}
		}
		if err := o.Enum.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwNumMessages {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.MessagesLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumMessagesExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Buffer != nil && o.BufferSize == 0 {
		o.BufferSize = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumMessagesExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lppBuffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE}*(1))(3:{alias=BYTE}[dim:0,size_is=lpdwBufferSize](uchar))
	{
		if o.Buffer != nil || o.BufferSize > 0 {
			_ptr_lppBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.BufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Buffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Buffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Buffer, _ptr_lppBuffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpdwBufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	// lpdwNumMessagesRetrieved {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.MessagesRetrievedLength); err != nil {
			return err
		}
	}
	// lpdwLevel {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Level); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumMessagesExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lppBuffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE,pointer=ref}*(1))(3:{alias=BYTE}[dim:0,size_is=lpdwBufferSize](uchar))
	{
		_ptr_lppBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
			}
			o.Buffer = make([]byte, sizeInfo[0])
			for i1 := range o.Buffer {
				i1 := i1
				if err := w.ReadData(&o.Buffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_lppBuffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Buffer, _s_lppBuffer, _ptr_lppBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpdwBufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	// lpdwNumMessagesRetrieved {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.MessagesRetrievedLength); err != nil {
			return err
		}
	}
	// lpdwLevel {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Level); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumMessagesExRequest structure represents the FAX_EnumMessagesEx operation request
type EnumMessagesExRequest struct {
	// hEnum: The enumeration handle returned through the lpHandle output argument by FAX_StartMessagesEnum
	// or FAX_StartMessagesEnumEx.
	Enum *fax.MessageEnum `idl:"name:hEnum;pointer:ref" json:"enum"`
	// dwNumMessages: A DWORD ([MS-DTYP] section 2.2.9) value that indicates the maximum
	// number of messages that the caller requires to enumerate. This value MUST NOT be
	// zero.
	MessagesLength uint32 `idl:"name:dwNumMessages" json:"messages_length"`
}

func (o *EnumMessagesExRequest) xxx_ToOp(ctx context.Context, op *xxx_EnumMessagesExOperation) *xxx_EnumMessagesExOperation {
	if op == nil {
		op = &xxx_EnumMessagesExOperation{}
	}
	if o == nil {
		return op
	}
	op.Enum = o.Enum
	op.MessagesLength = o.MessagesLength
	return op
}

func (o *EnumMessagesExRequest) xxx_FromOp(ctx context.Context, op *xxx_EnumMessagesExOperation) {
	if o == nil {
		return
	}
	o.Enum = op.Enum
	o.MessagesLength = op.MessagesLength
}
func (o *EnumMessagesExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumMessagesExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumMessagesExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumMessagesExResponse structure represents the FAX_EnumMessagesEx operation response
type EnumMessagesExResponse struct {
	// lppBuffer: A pointer to an array of FAX_MESSAGE_1 (section 2.2.37) structures that
	// contain lpdwNumMessagesRetrieved entries.
	Buffer []byte `idl:"name:lppBuffer;size_is:(, lpdwBufferSize)" json:"buffer"`
	// lpdwBufferSize: A pointer to a DWORD value that specifies the size, in bytes, of
	// the buffer.
	BufferSize uint32 `idl:"name:lpdwBufferSize;pointer:ref" json:"buffer_size"`
	// lpdwNumMessagesRetrieved: A pointer to a DWORD value that indicates the actual number
	// of retrieved messages. This value SHOULD NOT exceed dwNumMessages.
	MessagesRetrievedLength uint32 `idl:"name:lpdwNumMessagesRetrieved;pointer:ref" json:"messages_retrieved_length"`
	// lpdwLevel: A pointer to a DWORD value that indicates the structure to return.
	Level uint32 `idl:"name:lpdwLevel;pointer:ref" json:"level"`
	// Return: The FAX_EnumMessagesEx return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumMessagesExResponse) xxx_ToOp(ctx context.Context, op *xxx_EnumMessagesExOperation) *xxx_EnumMessagesExOperation {
	if op == nil {
		op = &xxx_EnumMessagesExOperation{}
	}
	if o == nil {
		return op
	}
	op.Buffer = o.Buffer
	op.BufferSize = o.BufferSize
	op.MessagesRetrievedLength = o.MessagesRetrievedLength
	op.Level = o.Level
	op.Return = o.Return
	return op
}

func (o *EnumMessagesExResponse) xxx_FromOp(ctx context.Context, op *xxx_EnumMessagesExOperation) {
	if o == nil {
		return
	}
	o.Buffer = op.Buffer
	o.BufferSize = op.BufferSize
	o.MessagesRetrievedLength = op.MessagesRetrievedLength
	o.Level = op.Level
	o.Return = op.Return
}
func (o *EnumMessagesExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumMessagesExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumMessagesExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_StartServerNotificationEx2Operation structure represents the FAX_StartServerNotificationEx2 operation
type xxx_StartServerNotificationEx2Operation struct {
	AccountName            string       `idl:"name:lpcwstrAccountName;string;pointer:unique" json:"account_name"`
	MachineName            string       `idl:"name:lpcwstrMachineName;string;pointer:ref" json:"machine_name"`
	Endpoint               string       `idl:"name:lpcwstrEndPoint;string;pointer:ref" json:"endpoint"`
	Context                uint64       `idl:"name:Context" json:"context"`
	ProtocolSequenceString string       `idl:"name:lpcwstrProtseqString;string;pointer:ref" json:"protocol_sequence_string"`
	EventTypes             uint32       `idl:"name:dwEventTypes" json:"event_types"`
	Level                  uint32       `idl:"name:level" json:"level"`
	Handle                 *fax.EventEx `idl:"name:lpHandle;pointer:ref" json:"handle"`
	Return                 uint32       `idl:"name:Return" json:"return"`
}

func (o *xxx_StartServerNotificationEx2Operation) OpNum() int { return 91 }

func (o *xxx_StartServerNotificationEx2Operation) OpName() string {
	return "/fax/v4/FAX_StartServerNotificationEx2"
}

func (o *xxx_StartServerNotificationEx2Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartServerNotificationEx2Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lpcwstrAccountName {in} (1:{string, pointer=unique, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.AccountName != "" {
			_ptr_lpcwstrAccountName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.AccountName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.AccountName, _ptr_lpcwstrAccountName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpcwstrMachineName {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.MachineName); err != nil {
			return err
		}
	}
	// lpcwstrEndPoint {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.Endpoint); err != nil {
			return err
		}
	}
	// Context {in} (1:{alias=ULONG64}(uint64))
	{
		if err := w.WriteData(o.Context); err != nil {
			return err
		}
	}
	// lpcwstrProtseqString {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ProtocolSequenceString); err != nil {
			return err
		}
	}
	// dwEventTypes {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.EventTypes); err != nil {
			return err
		}
	}
	// level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Level); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartServerNotificationEx2Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lpcwstrAccountName {in} (1:{string, pointer=unique, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_lpcwstrAccountName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.AccountName); err != nil {
				return err
			}
			return nil
		})
		_s_lpcwstrAccountName := func(ptr interface{}) { o.AccountName = *ptr.(*string) }
		if err := w.ReadPointer(&o.AccountName, _s_lpcwstrAccountName, _ptr_lpcwstrAccountName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpcwstrMachineName {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.MachineName); err != nil {
			return err
		}
	}
	// lpcwstrEndPoint {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.Endpoint); err != nil {
			return err
		}
	}
	// Context {in} (1:{alias=ULONG64}(uint64))
	{
		if err := w.ReadData(&o.Context); err != nil {
			return err
		}
	}
	// lpcwstrProtseqString {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ProtocolSequenceString); err != nil {
			return err
		}
	}
	// dwEventTypes {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.EventTypes); err != nil {
			return err
		}
	}
	// level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Level); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartServerNotificationEx2Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartServerNotificationEx2Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpHandle {out} (1:{pointer=ref, alias=PRPC_FAX_EVENT_EX_HANDLE}*(1))(2:{context_handle, alias=RPC_FAX_EVENT_EX_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.EventEx{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartServerNotificationEx2Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpHandle {out} (1:{pointer=ref, alias=PRPC_FAX_EVENT_EX_HANDLE}*(1))(2:{context_handle, alias=RPC_FAX_EVENT_EX_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &fax.EventEx{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// StartServerNotificationEx2Request structure represents the FAX_StartServerNotificationEx2 operation request
type StartServerNotificationEx2Request struct {
	// lpcwstrAccountName: A pointer to a constant null-terminated character string that
	// indicates which account to enumerate. If this value is NULL, the current account's
	// jobs are enumerated. Cross-account enumeration currently is not supported.
	AccountName string `idl:"name:lpcwstrAccountName;string;pointer:unique" json:"account_name"`
	// lpcwstrMachineName: A pointer to a null-terminated string that contains the name
	// of the fax client machine.
	MachineName string `idl:"name:lpcwstrMachineName;string;pointer:ref" json:"machine_name"`
	// lpcwstrEndPoint: A pointer to a null-terminated string that contains the client machine
	// RPC server endpoint string.
	Endpoint string `idl:"name:lpcwstrEndPoint;string;pointer:ref" json:"endpoint"`
	// Context: A ULONG64 ([MS-DTYP] section 2.2.54) value that can be passed to FAX_OpenConnection
	// (section 3.2.4.5) as a notification context.
	Context uint64 `idl:"name:Context" json:"context"`
	// lpcwstrProtseqString: A pointer to a null-terminated string that contains the fax
	// client RPC server's protocol sequence string. The protocol that is used for sending
	// the notifications is always TCP/IP.<176>
	ProtocolSequenceString string `idl:"name:lpcwstrProtseqString;string;pointer:ref" json:"protocol_sequence_string"`
	// dwEventTypes: A DWORD ([MS-DTYP] section 2.2.9) value that indicates which events
	// the client needs to receive. For more information, see FAX_ENUM_EVENT_TYPE (section
	// 2.2.63). During registration the client is allowed to register for multiple events,
	// so that if any of them occur the client will get a notification. Hence bitwise ORing
	// of events is allowed in this case. This value cannot be FAX_EVENT_TYPE_LEGACY because
	// the method only supports extended events.
	EventTypes uint32 `idl:"name:dwEventTypes" json:"event_types"`
	// level: A DWORD value that indicates the structure to return. The value MUST be set
	// to 1.
	Level uint32 `idl:"name:level" json:"level"`
}

func (o *StartServerNotificationEx2Request) xxx_ToOp(ctx context.Context, op *xxx_StartServerNotificationEx2Operation) *xxx_StartServerNotificationEx2Operation {
	if op == nil {
		op = &xxx_StartServerNotificationEx2Operation{}
	}
	if o == nil {
		return op
	}
	op.AccountName = o.AccountName
	op.MachineName = o.MachineName
	op.Endpoint = o.Endpoint
	op.Context = o.Context
	op.ProtocolSequenceString = o.ProtocolSequenceString
	op.EventTypes = o.EventTypes
	op.Level = o.Level
	return op
}

func (o *StartServerNotificationEx2Request) xxx_FromOp(ctx context.Context, op *xxx_StartServerNotificationEx2Operation) {
	if o == nil {
		return
	}
	o.AccountName = op.AccountName
	o.MachineName = op.MachineName
	o.Endpoint = op.Endpoint
	o.Context = op.Context
	o.ProtocolSequenceString = op.ProtocolSequenceString
	o.EventTypes = op.EventTypes
	o.Level = op.Level
}
func (o *StartServerNotificationEx2Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *StartServerNotificationEx2Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_StartServerNotificationEx2Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// StartServerNotificationEx2Response structure represents the FAX_StartServerNotificationEx2 operation response
type StartServerNotificationEx2Response struct {
	// lpHandle: A pointer to an RPC_FAX_EVENT_EX_HANDLE (Fax Data Types (section 2.2.74))
	// that returns a subscription context handle. This handle can be used in the FAX_EndServerNotification
	// (section 3.1.4.1.17) method.
	Handle *fax.EventEx `idl:"name:lpHandle;pointer:ref" json:"handle"`
	// Return: The FAX_StartServerNotificationEx2 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *StartServerNotificationEx2Response) xxx_ToOp(ctx context.Context, op *xxx_StartServerNotificationEx2Operation) *xxx_StartServerNotificationEx2Operation {
	if op == nil {
		op = &xxx_StartServerNotificationEx2Operation{}
	}
	if o == nil {
		return op
	}
	op.Handle = o.Handle
	op.Return = o.Return
	return op
}

func (o *StartServerNotificationEx2Response) xxx_FromOp(ctx context.Context, op *xxx_StartServerNotificationEx2Operation) {
	if o == nil {
		return
	}
	o.Handle = op.Handle
	o.Return = op.Return
}
func (o *StartServerNotificationEx2Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *StartServerNotificationEx2Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_StartServerNotificationEx2Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CreateAccountOperation structure represents the FAX_CreateAccount operation
type xxx_CreateAccountOperation struct {
	Level      uint32 `idl:"name:level" json:"level"`
	Buffer     []byte `idl:"name:Buffer;size_is:(BufferSize);pointer:ref" json:"buffer"`
	BufferSize uint32 `idl:"name:BufferSize" json:"buffer_size"`
	Return     uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_CreateAccountOperation) OpNum() int { return 92 }

func (o *xxx_CreateAccountOperation) OpName() string { return "/fax/v4/FAX_CreateAccount" }

func (o *xxx_CreateAccountOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.Buffer != nil && o.BufferSize == 0 {
		o.BufferSize = uint32(len(o.Buffer))
	}
	if o.BufferSize > uint32(1048576) {
		return fmt.Errorf("BufferSize is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateAccountOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Level); err != nil {
			return err
		}
	}
	// Buffer {in} (1:{pointer=ref, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		dimSize1 := uint64(o.BufferSize)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.Buffer {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.Buffer[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// BufferSize {in} (1:{range=(0,1048576), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateAccountOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Level); err != nil {
			return err
		}
	}
	// Buffer {in} (1:{pointer=ref, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
		}
		o.Buffer = make([]byte, sizeInfo[0])
		for i1 := range o.Buffer {
			i1 := i1
			if err := w.ReadData(&o.Buffer[i1]); err != nil {
				return err
			}
		}
	}
	// BufferSize {in} (1:{range=(0,1048576), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateAccountOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateAccountOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateAccountOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CreateAccountRequest structure represents the FAX_CreateAccount operation request
type CreateAccountRequest struct {
	// level: A DWORD ([MS-DTYP] section 2.2.9) value that indicates the type of structure
	// to return in Buffer. The value passed in this parameter MUST be zero.
	Level uint32 `idl:"name:level" json:"level"`
	// Buffer: A pointer to a FAX_ACCOUNT_INFO_0 that contains fax account information.
	// The lpcwstrAccountName member of the FAX_ACCOUNT_INFO_0 MUST be set to the name of
	// the operating system user account for which the new fax user account is to be created,
	// using the same account name. The format of the user account name string is described
	// in section 2.2.24 (FAX_ACCOUNT_INFO_0).
	Buffer []byte `idl:"name:Buffer;size_is:(BufferSize);pointer:ref" json:"buffer"`
	// BufferSize: A DWORD value that indicates the return size, in bytes, of the buffer
	// that is pointed to by the Buffer parameter. The maximum size is FAX_MAX_RPC_BUFFER(section
	// 2.2.82).
	BufferSize uint32 `idl:"name:BufferSize" json:"buffer_size"`
}

func (o *CreateAccountRequest) xxx_ToOp(ctx context.Context, op *xxx_CreateAccountOperation) *xxx_CreateAccountOperation {
	if op == nil {
		op = &xxx_CreateAccountOperation{}
	}
	if o == nil {
		return op
	}
	op.Level = o.Level
	op.Buffer = o.Buffer
	op.BufferSize = o.BufferSize
	return op
}

func (o *CreateAccountRequest) xxx_FromOp(ctx context.Context, op *xxx_CreateAccountOperation) {
	if o == nil {
		return
	}
	o.Level = op.Level
	o.Buffer = op.Buffer
	o.BufferSize = op.BufferSize
}
func (o *CreateAccountRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *CreateAccountRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateAccountOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CreateAccountResponse structure represents the FAX_CreateAccount operation response
type CreateAccountResponse struct {
	// Return: The FAX_CreateAccount return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CreateAccountResponse) xxx_ToOp(ctx context.Context, op *xxx_CreateAccountOperation) *xxx_CreateAccountOperation {
	if op == nil {
		op = &xxx_CreateAccountOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *CreateAccountResponse) xxx_FromOp(ctx context.Context, op *xxx_CreateAccountOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *CreateAccountResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *CreateAccountResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateAccountOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_DeleteAccountOperation structure represents the FAX_DeleteAccount operation
type xxx_DeleteAccountOperation struct {
	AccountName string `idl:"name:lpcwstrAccountName;string;pointer:unique" json:"account_name"`
	Return      uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_DeleteAccountOperation) OpNum() int { return 93 }

func (o *xxx_DeleteAccountOperation) OpName() string { return "/fax/v4/FAX_DeleteAccount" }

func (o *xxx_DeleteAccountOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteAccountOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lpcwstrAccountName {in} (1:{string, pointer=unique, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.AccountName != "" {
			_ptr_lpcwstrAccountName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.AccountName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.AccountName, _ptr_lpcwstrAccountName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteAccountOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lpcwstrAccountName {in} (1:{string, pointer=unique, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_lpcwstrAccountName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.AccountName); err != nil {
				return err
			}
			return nil
		})
		_s_lpcwstrAccountName := func(ptr interface{}) { o.AccountName = *ptr.(*string) }
		if err := w.ReadPointer(&o.AccountName, _s_lpcwstrAccountName, _ptr_lpcwstrAccountName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteAccountOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteAccountOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteAccountOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// DeleteAccountRequest structure represents the FAX_DeleteAccount operation request
type DeleteAccountRequest struct {
	// lpcwstrAccountName: A pointer to a constant, null-terminated character string that
	// contains the name of the account to delete. The value for this parameter can be obtained
	// using the FAX_EnumAccounts (section 3.1.4.1.18) method.
	AccountName string `idl:"name:lpcwstrAccountName;string;pointer:unique" json:"account_name"`
}

func (o *DeleteAccountRequest) xxx_ToOp(ctx context.Context, op *xxx_DeleteAccountOperation) *xxx_DeleteAccountOperation {
	if op == nil {
		op = &xxx_DeleteAccountOperation{}
	}
	if o == nil {
		return op
	}
	op.AccountName = o.AccountName
	return op
}

func (o *DeleteAccountRequest) xxx_FromOp(ctx context.Context, op *xxx_DeleteAccountOperation) {
	if o == nil {
		return
	}
	o.AccountName = op.AccountName
}
func (o *DeleteAccountRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *DeleteAccountRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteAccountOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// DeleteAccountResponse structure represents the FAX_DeleteAccount operation response
type DeleteAccountResponse struct {
	// Return: The FAX_DeleteAccount return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *DeleteAccountResponse) xxx_ToOp(ctx context.Context, op *xxx_DeleteAccountOperation) *xxx_DeleteAccountOperation {
	if op == nil {
		op = &xxx_DeleteAccountOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *DeleteAccountResponse) xxx_FromOp(ctx context.Context, op *xxx_DeleteAccountOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *DeleteAccountResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *DeleteAccountResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteAccountOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumAccountsOperation structure represents the FAX_EnumAccounts operation
type xxx_EnumAccountsOperation struct {
	Level      uint32 `idl:"name:level" json:"level"`
	Buffer     []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	BufferSize uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	Accounts   uint32 `idl:"name:lpdwAccounts;pointer:ref" json:"accounts"`
	Return     uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumAccountsOperation) OpNum() int { return 94 }

func (o *xxx_EnumAccountsOperation) OpName() string { return "/fax/v4/FAX_EnumAccounts" }

func (o *xxx_EnumAccountsOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumAccountsOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Level); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumAccountsOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Level); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumAccountsOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Buffer != nil && o.BufferSize == 0 {
		o.BufferSize = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumAccountsOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		if o.Buffer != nil || o.BufferSize > 0 {
			_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.BufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Buffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Buffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	// lpdwAccounts {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Accounts); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumAccountsOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE,pointer=ref}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
			}
			o.Buffer = make([]byte, sizeInfo[0])
			for i1 := range o.Buffer {
				i1 := i1
				if err := w.ReadData(&o.Buffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	// lpdwAccounts {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Accounts); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumAccountsRequest structure represents the FAX_EnumAccounts operation request
type EnumAccountsRequest struct {
	// level: A DWORD ([MS-DTYP] section 2.2.9) value that indicates the type of structure
	// that is pointed to by Buffer. The value passed in this parameter MUST be zero.
	Level uint32 `idl:"name:level" json:"level"`
}

func (o *EnumAccountsRequest) xxx_ToOp(ctx context.Context, op *xxx_EnumAccountsOperation) *xxx_EnumAccountsOperation {
	if op == nil {
		op = &xxx_EnumAccountsOperation{}
	}
	if o == nil {
		return op
	}
	op.Level = o.Level
	return op
}

func (o *EnumAccountsRequest) xxx_FromOp(ctx context.Context, op *xxx_EnumAccountsOperation) {
	if o == nil {
		return
	}
	o.Level = op.Level
}
func (o *EnumAccountsRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumAccountsRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumAccountsOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumAccountsResponse structure represents the FAX_EnumAccounts operation response
type EnumAccountsResponse struct {
	// Buffer: A pointer to an array of FAX_ACCOUNT_INFO_0 (section 2.2.24) structures that
	// contain fax account information.
	Buffer []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	// BufferSize: A pointer to a DWORD value that specifies the size, in bytes, of the
	// buffer that is pointed to by the Buffer parameter.
	BufferSize uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	// lpdwAccounts: A DWORD that contains the number of accounts whose information is being
	// returned.
	Accounts uint32 `idl:"name:lpdwAccounts;pointer:ref" json:"accounts"`
	// Return: The FAX_EnumAccounts return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumAccountsResponse) xxx_ToOp(ctx context.Context, op *xxx_EnumAccountsOperation) *xxx_EnumAccountsOperation {
	if op == nil {
		op = &xxx_EnumAccountsOperation{}
	}
	if o == nil {
		return op
	}
	op.Buffer = o.Buffer
	op.BufferSize = o.BufferSize
	op.Accounts = o.Accounts
	op.Return = o.Return
	return op
}

func (o *EnumAccountsResponse) xxx_FromOp(ctx context.Context, op *xxx_EnumAccountsOperation) {
	if o == nil {
		return
	}
	o.Buffer = op.Buffer
	o.BufferSize = op.BufferSize
	o.Accounts = op.Accounts
	o.Return = op.Return
}
func (o *EnumAccountsResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumAccountsResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumAccountsOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetAccountInfoOperation structure represents the FAX_GetAccountInfo operation
type xxx_GetAccountInfoOperation struct {
	AccountName string `idl:"name:lpcwstrAccountName;string;pointer:unique" json:"account_name"`
	Level       uint32 `idl:"name:level" json:"level"`
	Buffer      []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	BufferSize  uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	Return      uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetAccountInfoOperation) OpNum() int { return 95 }

func (o *xxx_GetAccountInfoOperation) OpName() string { return "/fax/v4/FAX_GetAccountInfo" }

func (o *xxx_GetAccountInfoOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetAccountInfoOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// lpcwstrAccountName {in} (1:{string, pointer=unique, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.AccountName != "" {
			_ptr_lpcwstrAccountName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.AccountName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.AccountName, _ptr_lpcwstrAccountName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Level); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetAccountInfoOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// lpcwstrAccountName {in} (1:{string, pointer=unique, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_lpcwstrAccountName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.AccountName); err != nil {
				return err
			}
			return nil
		})
		_s_lpcwstrAccountName := func(ptr interface{}) { o.AccountName = *ptr.(*string) }
		if err := w.ReadPointer(&o.AccountName, _s_lpcwstrAccountName, _ptr_lpcwstrAccountName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Level); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetAccountInfoOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Buffer != nil && o.BufferSize == 0 {
		o.BufferSize = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetAccountInfoOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		if o.Buffer != nil || o.BufferSize > 0 {
			_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.BufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Buffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Buffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetAccountInfoOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE,pointer=ref}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
			}
			o.Buffer = make([]byte, sizeInfo[0])
			for i1 := range o.Buffer {
				i1 := i1
				if err := w.ReadData(&o.Buffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetAccountInfoRequest structure represents the FAX_GetAccountInfo operation request
type GetAccountInfoRequest struct {
	// lpcwstrAccountName: A pointer to a constant, null-terminated character string that
	// contains the name of the account for which to retrieve information.
	AccountName string `idl:"name:lpcwstrAccountName;string;pointer:unique" json:"account_name"`
	// level: A DWORD ([MS-DTYP] section 2.2.9) value that indicates the type of structure
	// that is pointed to by Buffer. This MUST be zero.
	Level uint32 `idl:"name:level" json:"level"`
}

func (o *GetAccountInfoRequest) xxx_ToOp(ctx context.Context, op *xxx_GetAccountInfoOperation) *xxx_GetAccountInfoOperation {
	if op == nil {
		op = &xxx_GetAccountInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.AccountName = o.AccountName
	op.Level = o.Level
	return op
}

func (o *GetAccountInfoRequest) xxx_FromOp(ctx context.Context, op *xxx_GetAccountInfoOperation) {
	if o == nil {
		return
	}
	o.AccountName = op.AccountName
	o.Level = op.Level
}
func (o *GetAccountInfoRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetAccountInfoRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetAccountInfoOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetAccountInfoResponse structure represents the FAX_GetAccountInfo operation response
type GetAccountInfoResponse struct {
	// Buffer: A pointer to a FAX_ACCOUNT_INFO_0 (section 2.2.24) structure that contains
	// fax account information.
	Buffer []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	// BufferSize: A pointer to a DWORD value that specifies the size, in bytes, of the
	// structure that is pointed to by the Buffer parameter.
	BufferSize uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	// Return: The FAX_GetAccountInfo return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetAccountInfoResponse) xxx_ToOp(ctx context.Context, op *xxx_GetAccountInfoOperation) *xxx_GetAccountInfoOperation {
	if op == nil {
		op = &xxx_GetAccountInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.Buffer = o.Buffer
	op.BufferSize = o.BufferSize
	op.Return = o.Return
	return op
}

func (o *GetAccountInfoResponse) xxx_FromOp(ctx context.Context, op *xxx_GetAccountInfoOperation) {
	if o == nil {
		return
	}
	o.Buffer = op.Buffer
	o.BufferSize = op.BufferSize
	o.Return = op.Return
}
func (o *GetAccountInfoResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetAccountInfoResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetAccountInfoOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetGeneralConfigurationOperation structure represents the FAX_GetGeneralConfiguration operation
type xxx_GetGeneralConfigurationOperation struct {
	Level      uint32 `idl:"name:level" json:"level"`
	Buffer     []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	BufferSize uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	Return     uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetGeneralConfigurationOperation) OpNum() int { return 96 }

func (o *xxx_GetGeneralConfigurationOperation) OpName() string {
	return "/fax/v4/FAX_GetGeneralConfiguration"
}

func (o *xxx_GetGeneralConfigurationOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetGeneralConfigurationOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Level); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetGeneralConfigurationOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Level); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetGeneralConfigurationOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Buffer != nil && o.BufferSize == 0 {
		o.BufferSize = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetGeneralConfigurationOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		if o.Buffer != nil || o.BufferSize > 0 {
			_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.BufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Buffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Buffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetGeneralConfigurationOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Buffer {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE,pointer=ref}*(1))(3:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
			}
			o.Buffer = make([]byte, sizeInfo[0])
			for i1 := range o.Buffer {
				i1 := i1
				if err := w.ReadData(&o.Buffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// BufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetGeneralConfigurationRequest structure represents the FAX_GetGeneralConfiguration operation request
type GetGeneralConfigurationRequest struct {
	// level: A DWORD ([MS-DTYP] section 2.2.9) value that indicates the type of structure
	// pointed to by Buffer. This MUST be zero.
	Level uint32 `idl:"name:level" json:"level"`
}

func (o *GetGeneralConfigurationRequest) xxx_ToOp(ctx context.Context, op *xxx_GetGeneralConfigurationOperation) *xxx_GetGeneralConfigurationOperation {
	if op == nil {
		op = &xxx_GetGeneralConfigurationOperation{}
	}
	if o == nil {
		return op
	}
	op.Level = o.Level
	return op
}

func (o *GetGeneralConfigurationRequest) xxx_FromOp(ctx context.Context, op *xxx_GetGeneralConfigurationOperation) {
	if o == nil {
		return
	}
	o.Level = op.Level
}
func (o *GetGeneralConfigurationRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetGeneralConfigurationRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetGeneralConfigurationOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetGeneralConfigurationResponse structure represents the FAX_GetGeneralConfiguration operation response
type GetGeneralConfigurationResponse struct {
	// Buffer: A pointer to a FAX_GENERAL_CONFIG (section 2.2.31) structure that contains
	// the server information to retrieve. The buffer indicated by this pointer contains
	// the following:
	//
	// § A serialized FAX_GENERAL_CONFIG filled by server.
	//
	// § A null-terminated, wide character string that indicates the archive folder location
	// on the fax server file system.
	Buffer []byte `idl:"name:Buffer;size_is:(, BufferSize)" json:"buffer"`
	// BufferSize: A pointer to a DWORD ([MS-DTYP] section 2.2.9) value that specifies the
	// size, in bytes, of the buffer that is pointed to by the Buffer parameter.
	BufferSize uint32 `idl:"name:BufferSize;pointer:ref" json:"buffer_size"`
	// Return: The FAX_GetGeneralConfiguration return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetGeneralConfigurationResponse) xxx_ToOp(ctx context.Context, op *xxx_GetGeneralConfigurationOperation) *xxx_GetGeneralConfigurationOperation {
	if op == nil {
		op = &xxx_GetGeneralConfigurationOperation{}
	}
	if o == nil {
		return op
	}
	op.Buffer = o.Buffer
	op.BufferSize = o.BufferSize
	op.Return = o.Return
	return op
}

func (o *GetGeneralConfigurationResponse) xxx_FromOp(ctx context.Context, op *xxx_GetGeneralConfigurationOperation) {
	if o == nil {
		return
	}
	o.Buffer = op.Buffer
	o.BufferSize = op.BufferSize
	o.Return = op.Return
}
func (o *GetGeneralConfigurationResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetGeneralConfigurationResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetGeneralConfigurationOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetGeneralConfigurationOperation structure represents the FAX_SetGeneralConfiguration operation
type xxx_SetGeneralConfigurationOperation struct {
	Level      uint32 `idl:"name:level" json:"level"`
	Buffer     []byte `idl:"name:Buffer;size_is:(BufferSize);pointer:ref" json:"buffer"`
	BufferSize uint32 `idl:"name:BufferSize" json:"buffer_size"`
	Return     uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_SetGeneralConfigurationOperation) OpNum() int { return 97 }

func (o *xxx_SetGeneralConfigurationOperation) OpName() string {
	return "/fax/v4/FAX_SetGeneralConfiguration"
}

func (o *xxx_SetGeneralConfigurationOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.Buffer != nil && o.BufferSize == 0 {
		o.BufferSize = uint32(len(o.Buffer))
	}
	if o.BufferSize > uint32(1048576) {
		return fmt.Errorf("BufferSize is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetGeneralConfigurationOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Level); err != nil {
			return err
		}
	}
	// Buffer {in} (1:{pointer=ref, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		dimSize1 := uint64(o.BufferSize)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.Buffer {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.Buffer[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// BufferSize {in} (1:{range=(0,1048576), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetGeneralConfigurationOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Level); err != nil {
			return err
		}
	}
	// Buffer {in} (1:{pointer=ref, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=BufferSize](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
		}
		o.Buffer = make([]byte, sizeInfo[0])
		for i1 := range o.Buffer {
			i1 := i1
			if err := w.ReadData(&o.Buffer[i1]); err != nil {
				return err
			}
		}
	}
	// BufferSize {in} (1:{range=(0,1048576), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetGeneralConfigurationOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetGeneralConfigurationOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetGeneralConfigurationOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetGeneralConfigurationRequest structure represents the FAX_SetGeneralConfiguration operation request
type SetGeneralConfigurationRequest struct {
	// level: A DWORD ([MS-DTYP] section 2.2.9) value that indicates the type of structure
	// to return in Buffer. This value MUST be set to zero.
	Level uint32 `idl:"name:level" json:"level"`
	// Buffer: A pointer to a FAX_GENERAL_CONFIG that contains the configuration information
	// to set.
	Buffer []byte `idl:"name:Buffer;size_is:(BufferSize);pointer:ref" json:"buffer"`
	// BufferSize: A pointer to a DWORD value that specifies the size, in bytes, of the
	// buffer that is pointed to by the Buffer parameter. The maximum size is FAX_MAX_RPC_BUFFER
	// (section 2.2.82).
	BufferSize uint32 `idl:"name:BufferSize" json:"buffer_size"`
}

func (o *SetGeneralConfigurationRequest) xxx_ToOp(ctx context.Context, op *xxx_SetGeneralConfigurationOperation) *xxx_SetGeneralConfigurationOperation {
	if op == nil {
		op = &xxx_SetGeneralConfigurationOperation{}
	}
	if o == nil {
		return op
	}
	op.Level = o.Level
	op.Buffer = o.Buffer
	op.BufferSize = o.BufferSize
	return op
}

func (o *SetGeneralConfigurationRequest) xxx_FromOp(ctx context.Context, op *xxx_SetGeneralConfigurationOperation) {
	if o == nil {
		return
	}
	o.Level = op.Level
	o.Buffer = op.Buffer
	o.BufferSize = op.BufferSize
}
func (o *SetGeneralConfigurationRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetGeneralConfigurationRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetGeneralConfigurationOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetGeneralConfigurationResponse structure represents the FAX_SetGeneralConfiguration operation response
type SetGeneralConfigurationResponse struct {
	// Return: The FAX_SetGeneralConfiguration return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetGeneralConfigurationResponse) xxx_ToOp(ctx context.Context, op *xxx_SetGeneralConfigurationOperation) *xxx_SetGeneralConfigurationOperation {
	if op == nil {
		op = &xxx_SetGeneralConfigurationOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetGeneralConfigurationResponse) xxx_FromOp(ctx context.Context, op *xxx_SetGeneralConfigurationOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetGeneralConfigurationResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetGeneralConfigurationResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetGeneralConfigurationOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetSecurityEx2Operation structure represents the FAX_GetSecurityEx2 operation
type xxx_GetSecurityEx2Operation struct {
	SecurityInformation uint32 `idl:"name:SecurityInformation" json:"security_information"`
	SecurityDescriptor  []byte `idl:"name:pSecurityDescriptor;size_is:(, lpdwBufferSize)" json:"security_descriptor"`
	BufferSize          uint32 `idl:"name:lpdwBufferSize;pointer:ref" json:"buffer_size"`
	Return              uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetSecurityEx2Operation) OpNum() int { return 98 }

func (o *xxx_GetSecurityEx2Operation) OpName() string { return "/fax/v4/FAX_GetSecurityEx2" }

func (o *xxx_GetSecurityEx2Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetSecurityEx2Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// SecurityInformation {in} (1:{alias=SECURITY_INFORMATION, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.SecurityInformation); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetSecurityEx2Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// SecurityInformation {in} (1:{alias=SECURITY_INFORMATION, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.SecurityInformation); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetSecurityEx2Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.SecurityDescriptor != nil && o.BufferSize == 0 {
		o.BufferSize = uint32(len(o.SecurityDescriptor))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetSecurityEx2Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pSecurityDescriptor {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE}*(1))(3:{alias=BYTE}[dim:0,size_is=lpdwBufferSize](uchar))
	{
		if o.SecurityDescriptor != nil || o.BufferSize > 0 {
			_ptr_pSecurityDescriptor := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.BufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.SecurityDescriptor {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.SecurityDescriptor[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.SecurityDescriptor); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.SecurityDescriptor, _ptr_pSecurityDescriptor); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpdwBufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetSecurityEx2Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pSecurityDescriptor {out} (1:{pointer=ref}*(2))(2:{alias=LPBYTE,pointer=ref}*(1))(3:{alias=BYTE}[dim:0,size_is=lpdwBufferSize](uchar))
	{
		_ptr_pSecurityDescriptor := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.SecurityDescriptor", sizeInfo[0])
			}
			o.SecurityDescriptor = make([]byte, sizeInfo[0])
			for i1 := range o.SecurityDescriptor {
				i1 := i1
				if err := w.ReadData(&o.SecurityDescriptor[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_pSecurityDescriptor := func(ptr interface{}) { o.SecurityDescriptor = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.SecurityDescriptor, _s_pSecurityDescriptor, _ptr_pSecurityDescriptor); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpdwBufferSize {out} (1:{pointer=ref, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetSecurityEx2Request structure represents the FAX_GetSecurityEx2 operation request
type GetSecurityEx2Request struct {
	// SecurityInformation: Defines the desired entries, which are indicated as a bitwise
	// OR operation, in the security descriptor to return.
	//
	// §  OWNER_SECURITY_INFORMATION: 0x00000001
	//
	// §  GROUP_SECURITY_INFORMATION: 0x00000002
	//
	// §  DACL_SECURITY_INFORMATION: 0x00000004
	//
	// §  SACL_SECURITY_INFORMATION: 0x00000008
	//
	// The requested access levels to entries by SecurityInformation can be a combination
	// of the following:
	//
	// § Read Control (requested if any of the bits in SecurityInformation is set by an
	// OR operation with GROUP_SECURITY_INFORMATION, DACL_SECURITY_INFORMATION, and/or OWNER_SECURITY_INFORMATION)
	//
	// § Request for access to set or get SACL (requested if one of the bits in SecurityInformation
	// is set by an OR operation with SACL_SECURITY_INFORMATION)
	SecurityInformation uint32 `idl:"name:SecurityInformation" json:"security_information"`
}

func (o *GetSecurityEx2Request) xxx_ToOp(ctx context.Context, op *xxx_GetSecurityEx2Operation) *xxx_GetSecurityEx2Operation {
	if op == nil {
		op = &xxx_GetSecurityEx2Operation{}
	}
	if o == nil {
		return op
	}
	op.SecurityInformation = o.SecurityInformation
	return op
}

func (o *GetSecurityEx2Request) xxx_FromOp(ctx context.Context, op *xxx_GetSecurityEx2Operation) {
	if o == nil {
		return
	}
	o.SecurityInformation = op.SecurityInformation
}
func (o *GetSecurityEx2Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetSecurityEx2Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetSecurityEx2Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetSecurityEx2Response structure represents the FAX_GetSecurityEx2 operation response
type GetSecurityEx2Response struct {
	// pSecurityDescriptor: A pointer to a SECURITY_DESCRIPTOR, as specified in [MS-DTYP]
	// section 2.
	SecurityDescriptor []byte `idl:"name:pSecurityDescriptor;size_is:(, lpdwBufferSize)" json:"security_descriptor"`
	// lpdwBufferSize: A pointer to a DWORD ([MS-DTYP] section 2.2.9) value that indicates
	// the size, in bytes, of the pSecurityDescriptor buffer.
	BufferSize uint32 `idl:"name:lpdwBufferSize;pointer:ref" json:"buffer_size"`
	// Return: The FAX_GetSecurityEx2 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetSecurityEx2Response) xxx_ToOp(ctx context.Context, op *xxx_GetSecurityEx2Operation) *xxx_GetSecurityEx2Operation {
	if op == nil {
		op = &xxx_GetSecurityEx2Operation{}
	}
	if o == nil {
		return op
	}
	op.SecurityDescriptor = o.SecurityDescriptor
	op.BufferSize = o.BufferSize
	op.Return = o.Return
	return op
}

func (o *GetSecurityEx2Response) xxx_FromOp(ctx context.Context, op *xxx_GetSecurityEx2Operation) {
	if o == nil {
		return
	}
	o.SecurityDescriptor = op.SecurityDescriptor
	o.BufferSize = op.BufferSize
	o.Return = op.Return
}
func (o *GetSecurityEx2Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetSecurityEx2Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetSecurityEx2Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetSecurityEx2Operation structure represents the FAX_SetSecurityEx2 operation
type xxx_SetSecurityEx2Operation struct {
	SecurityInformation uint32 `idl:"name:SecurityInformation" json:"security_information"`
	SecurityDescriptor  []byte `idl:"name:pSecurityDescriptor;size_is:(dwBufferSize);pointer:unique" json:"security_descriptor"`
	BufferSize          uint32 `idl:"name:dwBufferSize" json:"buffer_size"`
	Return              uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_SetSecurityEx2Operation) OpNum() int { return 99 }

func (o *xxx_SetSecurityEx2Operation) OpName() string { return "/fax/v4/FAX_SetSecurityEx2" }

func (o *xxx_SetSecurityEx2Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.SecurityDescriptor != nil && o.BufferSize == 0 {
		o.BufferSize = uint32(len(o.SecurityDescriptor))
	}
	if o.BufferSize > uint32(1048576) {
		return fmt.Errorf("BufferSize is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetSecurityEx2Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// SecurityInformation {in} (1:{alias=SECURITY_INFORMATION, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.SecurityInformation); err != nil {
			return err
		}
	}
	// pSecurityDescriptor {in} (1:{pointer=unique, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=dwBufferSize](uchar))
	{
		if o.SecurityDescriptor != nil || o.BufferSize > 0 {
			_ptr_pSecurityDescriptor := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.BufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.SecurityDescriptor {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.SecurityDescriptor[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.SecurityDescriptor); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.SecurityDescriptor, _ptr_pSecurityDescriptor); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// dwBufferSize {in} (1:{range=(0,1048576), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetSecurityEx2Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// SecurityInformation {in} (1:{alias=SECURITY_INFORMATION, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.SecurityInformation); err != nil {
			return err
		}
	}
	// pSecurityDescriptor {in} (1:{pointer=unique, alias=LPBYTE}*(1))(2:{alias=BYTE}[dim:0,size_is=dwBufferSize](uchar))
	{
		_ptr_pSecurityDescriptor := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.SecurityDescriptor", sizeInfo[0])
			}
			o.SecurityDescriptor = make([]byte, sizeInfo[0])
			for i1 := range o.SecurityDescriptor {
				i1 := i1
				if err := w.ReadData(&o.SecurityDescriptor[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_pSecurityDescriptor := func(ptr interface{}) { o.SecurityDescriptor = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.SecurityDescriptor, _s_pSecurityDescriptor, _ptr_pSecurityDescriptor); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// dwBufferSize {in} (1:{range=(0,1048576), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetSecurityEx2Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetSecurityEx2Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetSecurityEx2Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetSecurityEx2Request structure represents the FAX_SetSecurityEx2 operation request
type SetSecurityEx2Request struct {
	// SecurityInformation: Defines the desired entries, which are indicated as a bitwise
	// OR operation, in the security descriptor to return.
	SecurityInformation uint32 `idl:"name:SecurityInformation" json:"security_information"`
	// pSecurityDescriptor: A pointer to a SECURITY_DESCRIPTOR ([MS-DTYP] section 2.4.6)
	// structure.
	SecurityDescriptor []byte `idl:"name:pSecurityDescriptor;size_is:(dwBufferSize);pointer:unique" json:"security_descriptor"`
	// dwBufferSize: A value that indicates the size, in bytes, of the pSecurityDescriptor
	// buffer. The maximum size is FAX_MAX_RPC_BUFFER (section 2.2.82).
	BufferSize uint32 `idl:"name:dwBufferSize" json:"buffer_size"`
}

func (o *SetSecurityEx2Request) xxx_ToOp(ctx context.Context, op *xxx_SetSecurityEx2Operation) *xxx_SetSecurityEx2Operation {
	if op == nil {
		op = &xxx_SetSecurityEx2Operation{}
	}
	if o == nil {
		return op
	}
	op.SecurityInformation = o.SecurityInformation
	op.SecurityDescriptor = o.SecurityDescriptor
	op.BufferSize = o.BufferSize
	return op
}

func (o *SetSecurityEx2Request) xxx_FromOp(ctx context.Context, op *xxx_SetSecurityEx2Operation) {
	if o == nil {
		return
	}
	o.SecurityInformation = op.SecurityInformation
	o.SecurityDescriptor = op.SecurityDescriptor
	o.BufferSize = op.BufferSize
}
func (o *SetSecurityEx2Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetSecurityEx2Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetSecurityEx2Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetSecurityEx2Response structure represents the FAX_SetSecurityEx2 operation response
type SetSecurityEx2Response struct {
	// Return: The FAX_SetSecurityEx2 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetSecurityEx2Response) xxx_ToOp(ctx context.Context, op *xxx_SetSecurityEx2Operation) *xxx_SetSecurityEx2Operation {
	if op == nil {
		op = &xxx_SetSecurityEx2Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetSecurityEx2Response) xxx_FromOp(ctx context.Context, op *xxx_SetSecurityEx2Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetSecurityEx2Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetSecurityEx2Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetSecurityEx2Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AccessCheckEx2Operation structure represents the FAX_AccessCheckEx2 operation
type xxx_AccessCheckEx2Operation struct {
	AccessMask uint32 `idl:"name:AccessMask" json:"access_mask"`
	Access     bool   `idl:"name:pfAccess;pointer:ref" json:"access"`
	Rights     uint32 `idl:"name:lpdwRights;pointer:unique" json:"rights"`
	Return     uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_AccessCheckEx2Operation) OpNum() int { return 100 }

func (o *xxx_AccessCheckEx2Operation) OpName() string { return "/fax/v4/FAX_AccessCheckEx2" }

func (o *xxx_AccessCheckEx2Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AccessCheckEx2Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// AccessMask {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.AccessMask); err != nil {
			return err
		}
	}
	// lpdwRights {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		// XXX pointer to primitive type, default behavior is to write non-null pointer.
		// if this behavior is not desired, use goext_default_null([cond]) attribute.
		_ptr_lpdwRights := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.Rights); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Rights, _ptr_lpdwRights); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AccessCheckEx2Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// AccessMask {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.AccessMask); err != nil {
			return err
		}
	}
	// lpdwRights {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_lpdwRights := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.Rights); err != nil {
				return err
			}
			return nil
		})
		_s_lpdwRights := func(ptr interface{}) { o.Rights = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.Rights, _s_lpdwRights, _ptr_lpdwRights); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AccessCheckEx2Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AccessCheckEx2Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pfAccess {out} (1:{pointer=ref}*(1))(2:{alias=BOOL}(int32))
	{
		if !o.Access {
			if err := w.WriteData(int32(0)); err != nil {
				return err
			}
		} else {
			if err := w.WriteData(int32(1)); err != nil {
				return err
			}
		}
	}
	// lpdwRights {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		// XXX pointer to primitive type, default behavior is to write non-null pointer.
		// if this behavior is not desired, use goext_default_null([cond]) attribute.
		_ptr_lpdwRights := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.Rights); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Rights, _ptr_lpdwRights); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AccessCheckEx2Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pfAccess {out} (1:{pointer=ref}*(1))(2:{alias=BOOL}(int32))
	{
		var _bAccess int32
		if err := w.ReadData(&_bAccess); err != nil {
			return err
		}
		o.Access = _bAccess != 0
	}
	// lpdwRights {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_lpdwRights := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.Rights); err != nil {
				return err
			}
			return nil
		})
		_s_lpdwRights := func(ptr interface{}) { o.Rights = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.Rights, _s_lpdwRights, _ptr_lpdwRights); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AccessCheckEx2Request structure represents the FAX_AccessCheckEx2 operation request
type AccessCheckEx2Request struct {
	// AccessMask: A DWORD ([MS-DTYP] section 2.2.9) variable that contains a set of bit
	// flags specified by the client to be validated. Zero is a valid value for this parameter
	// and means that no access rights are specified by the client to be validated. This
	// parameter can be any combination of fax-specific access rights, standard access rights,
	// and fax-generic access rights. If this parameter is set to 0x02000000 (MAXIMUM_ALLOWED),
	// on return, the lpdwRights parameter SHOULD receive the maximum access rights granted
	// to the client's fax user account.
	//
	//	+----------------------------------+----------------------------------------------------------------------------------+
	//	|        FAX-GENERIC ACCESS        |                                                                                  |
	//	|              RIGHTS              |                                   DESCRIPTION                                    |
	//	|                                  |                                                                                  |
	//	+----------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_GENERIC_EXECUTE_2 0x00000001 | Includes the read-only rights granted by the FAX_ACCESS_SUBMIT access right.     |
	//	+----------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_GENERIC_READ_2 0x00000020    | Includes the read-only rights granted by the FAX_ACCESS_QUERY_CONFIG access      |
	//	|                                  | right.                                                                           |
	//	+----------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_GENERIC_WRITE_2 0x00000040   | Includes the read-only rights granted by the FAX_ACCESS_MANAGE_CONFIG access     |
	//	|                                  | right.                                                                           |
	//	+----------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_GENERIC_ALL_2 0x000003FF     | Includes the read-only rights granted by the following fax-specific              |
	//	|                                  | access rights: § FAX_ACCESS_SUBMIT § FAX_ACCESS_SUBMIT_NORMAL §                  |
	//	|                                  | FAX_ACCESS_SUBMIT_HIGH § FAX_ACCESS_QUERY_OUT_JOBS § FAX_ACCESS_MANAGE_OUT_JOBS  |
	//	|                                  | § FAX_ACCESS_QUERY_CONFIG § FAX_ACCESS_MANAGE_CONFIG § FAX_ACCESS_QUERY_ARCHIVES |
	//	|                                  | § FAX_ACCESS_MANAGE_ARCHIVES § FAX_ACCESS_MANAGE_RECEIVE_FOLDER                  |
	//	+----------------------------------+----------------------------------------------------------------------------------+
	//
	//
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//	|             FAX-SPECIFIC ACCESS             |                                                                                  |
	//	|                   RIGHTS                    |                                   DESCRIPTION                                    |
	//	|                                             |                                                                                  |
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ACCESS_SUBMIT 0x00000001                | Grants permission to send a low-priority fax transmission to one or more         |
	//	|                                             | recipients.                                                                      |
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ACCESS_SUBMIT_NORMAL 0x00000002         | Grants permission to send a normal-priority fax transmission to one or more      |
	//	|                                             | recipients.                                                                      |
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ACCESS_SUBMIT_HIGH 0x00000004           | Grants permission to send a high-priority fax transmission to one or more        |
	//	|                                             | recipients.                                                                      |
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ACCESS_QUERY_OUT_JOBS 0x00000008        | Grants permission to view the outgoing faxes in the fax queue. By default, no    |
	//	|                                             | users have this permission.                                                      |
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ACCESS_MANAGE_OUT_JOBS 0x00000010       | Grants permission to manage the outgoing faxes in the fax queue by using such    |
	//	|                                             | operations as pause, resume, restart, and delete (section 3.1.4.1.82). By        |
	//	|                                             | default, no users have this permission.                                          |
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ACCESS_QUERY_CONFIG 0x00000020          | Grants permission to view the properties of the Fax Service and to enumerate     |
	//	|                                             | accounts, and to read any account configuration information. By default,         |
	//	|                                             | non-administrator users do not have this permission. Without it, users cannot    |
	//	|                                             | view any of the tree nodes, except for the cover page node in the Fax Service    |
	//	|                                             | Manager.                                                                         |
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ACCESS_MANAGE_CONFIG 0x00000040         | Grants permission to modify the properties of the fax service. By default,       |
	//	|                                             | non-administrator users do not have this permission.                             |
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ACCESS_QUERY_ARCHIVES 0x00000080        | Grants permission to view the sent and received fax messages in the archives. By |
	//	|                                             | default, no users have this permission.                                          |
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ACCESS_MANAGE_ARCHIVES 0x00000100       | Grants permission to manage the sent and received fax messages in the archives   |
	//	|                                             | by using such operations as delete (section 3.1.4.1.70) and copy (sections       |
	//	|                                             | 3.1.4.1.96, 3.1.4.1.97, and 3.1.4.1.15). By default, no users have this          |
	//	|                                             | permission.                                                                      |
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_ACCESS_MANAGE_RECEIVE_FOLDER 0x00000200 | When global routing is not enabled, this permission allows the user to delete    |
	//	|                                             | any messages. When global routing is active, it allows the user to see the       |
	//	|                                             | contents of all receive folder faxes, to delete faxes, and to cancel receive     |
	//	|                                             | transmissions in progress.                                                       |
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	AccessMask uint32 `idl:"name:AccessMask" json:"access_mask"`
	// lpdwRights: A pointer to a DWORD value that receives the fax access rights that this
	// caller is verified to have of those requested in the AccessMask parameter. This value
	// MUST be a DWORD bitwise OR combination of fax-specific access rights, standard access
	// rights, and/or fax-generic access rights limited to those specified by the client
	// in the AccessMask. In order for the client to be verified for the maximum allowed
	// rights, the caller MUST set the AccessMask to 0x02000000 (MAXIMUM_ALLOWED) and the
	// server SHOULD set this output value to the actual rights that this caller is verified
	// to have.
	Rights uint32 `idl:"name:lpdwRights;pointer:unique" json:"rights"`
}

func (o *AccessCheckEx2Request) xxx_ToOp(ctx context.Context, op *xxx_AccessCheckEx2Operation) *xxx_AccessCheckEx2Operation {
	if op == nil {
		op = &xxx_AccessCheckEx2Operation{}
	}
	if o == nil {
		return op
	}
	op.AccessMask = o.AccessMask
	op.Rights = o.Rights
	return op
}

func (o *AccessCheckEx2Request) xxx_FromOp(ctx context.Context, op *xxx_AccessCheckEx2Operation) {
	if o == nil {
		return
	}
	o.AccessMask = op.AccessMask
	o.Rights = op.Rights
}
func (o *AccessCheckEx2Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *AccessCheckEx2Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AccessCheckEx2Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AccessCheckEx2Response structure represents the FAX_AccessCheckEx2 operation response
type AccessCheckEx2Response struct {
	// pfAccess: A pointer to a Boolean value that receives the access check return value.
	// This value MUST be TRUE if the client's fax user account has all of the fax access
	// rights specified by the AccessMask parameter; otherwise, this value MUST be FALSE.
	// If the value submitted by the client for the AccessMask is zero, the value pointed
	// to by the pfAccess parameter SHOULD be FALSE on return.
	Access bool `idl:"name:pfAccess;pointer:ref" json:"access"`
	// lpdwRights: A pointer to a DWORD value that receives the fax access rights that this
	// caller is verified to have of those requested in the AccessMask parameter. This value
	// MUST be a DWORD bitwise OR combination of fax-specific access rights, standard access
	// rights, and/or fax-generic access rights limited to those specified by the client
	// in the AccessMask. In order for the client to be verified for the maximum allowed
	// rights, the caller MUST set the AccessMask to 0x02000000 (MAXIMUM_ALLOWED) and the
	// server SHOULD set this output value to the actual rights that this caller is verified
	// to have.
	Rights uint32 `idl:"name:lpdwRights;pointer:unique" json:"rights"`
	// Return: The FAX_AccessCheckEx2 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AccessCheckEx2Response) xxx_ToOp(ctx context.Context, op *xxx_AccessCheckEx2Operation) *xxx_AccessCheckEx2Operation {
	if op == nil {
		op = &xxx_AccessCheckEx2Operation{}
	}
	if o == nil {
		return op
	}
	op.Access = o.Access
	op.Rights = o.Rights
	op.Return = o.Return
	return op
}

func (o *AccessCheckEx2Response) xxx_FromOp(ctx context.Context, op *xxx_AccessCheckEx2Operation) {
	if o == nil {
		return
	}
	o.Access = op.Access
	o.Rights = op.Rights
	o.Return = op.Return
}
func (o *AccessCheckEx2Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *AccessCheckEx2Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AccessCheckEx2Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ReassignMessageOperation structure represents the FAX_ReAssignMessage operation
type xxx_ReassignMessageOperation struct {
	MessageID    uint64            `idl:"name:dwlMessageId" json:"message_id"`
	ReassignInfo *fax.ReassignInfo `idl:"name:pReAssignInfo;pointer:ref" json:"reassign_info"`
	Return       uint32            `idl:"name:Return" json:"return"`
}

func (o *xxx_ReassignMessageOperation) OpNum() int { return 101 }

func (o *xxx_ReassignMessageOperation) OpName() string { return "/fax/v4/FAX_ReAssignMessage" }

func (o *xxx_ReassignMessageOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ReassignMessageOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// dwlMessageId {in} (1:{alias=DWORDLONG, names=ULONGLONG}(uint64))
	{
		if err := w.WriteData(o.MessageID); err != nil {
			return err
		}
	}
	// pReAssignInfo {in} (1:{pointer=ref, alias=PFAX_REASSIGN_INFO}*(1))(2:{alias=FAX_REASSIGN_INFO}(struct))
	{
		if o.ReassignInfo != nil {
			if err := o.ReassignInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.ReassignInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ReassignMessageOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// dwlMessageId {in} (1:{alias=DWORDLONG, names=ULONGLONG}(uint64))
	{
		if err := w.ReadData(&o.MessageID); err != nil {
			return err
		}
	}
	// pReAssignInfo {in} (1:{pointer=ref, alias=PFAX_REASSIGN_INFO}*(1))(2:{alias=FAX_REASSIGN_INFO}(struct))
	{
		if o.ReassignInfo == nil {
			o.ReassignInfo = &fax.ReassignInfo{}
		}
		if err := o.ReassignInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ReassignMessageOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ReassignMessageOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ReassignMessageOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ReassignMessageRequest structure represents the FAX_ReAssignMessage operation request
type ReassignMessageRequest struct {
	// dwlMessageId: A DWORDLONG ([MS-DTYP] section 2.2.13) value that specifies the identifier
	// of the fax message to reassign.
	MessageID uint64 `idl:"name:dwlMessageId" json:"message_id"`
	// pReAssignInfo: A pointer to a FAX_REASSIGN_INFO (section 2.2.18) structure that contains
	// reassignment information.
	ReassignInfo *fax.ReassignInfo `idl:"name:pReAssignInfo;pointer:ref" json:"reassign_info"`
}

func (o *ReassignMessageRequest) xxx_ToOp(ctx context.Context, op *xxx_ReassignMessageOperation) *xxx_ReassignMessageOperation {
	if op == nil {
		op = &xxx_ReassignMessageOperation{}
	}
	if o == nil {
		return op
	}
	op.MessageID = o.MessageID
	op.ReassignInfo = o.ReassignInfo
	return op
}

func (o *ReassignMessageRequest) xxx_FromOp(ctx context.Context, op *xxx_ReassignMessageOperation) {
	if o == nil {
		return
	}
	o.MessageID = op.MessageID
	o.ReassignInfo = op.ReassignInfo
}
func (o *ReassignMessageRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *ReassignMessageRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ReassignMessageOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ReassignMessageResponse structure represents the FAX_ReAssignMessage operation response
type ReassignMessageResponse struct {
	// Return: The FAX_ReAssignMessage return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ReassignMessageResponse) xxx_ToOp(ctx context.Context, op *xxx_ReassignMessageOperation) *xxx_ReassignMessageOperation {
	if op == nil {
		op = &xxx_ReassignMessageOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *ReassignMessageResponse) xxx_FromOp(ctx context.Context, op *xxx_ReassignMessageOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *ReassignMessageResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *ReassignMessageResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ReassignMessageOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetMessageOperation structure represents the FAX_SetMessage operation
type xxx_SetMessageOperation struct {
	MessageID         uint64                 `idl:"name:dwlMessageId" json:"message_id"`
	Folder            fax.MessageFolder      `idl:"name:Folder" json:"folder"`
	MessageProperties *fax.MessageProperties `idl:"name:lpMessageProps;pointer:ref" json:"message_properties"`
	Return            uint32                 `idl:"name:Return" json:"return"`
}

func (o *xxx_SetMessageOperation) OpNum() int { return 102 }

func (o *xxx_SetMessageOperation) OpName() string { return "/fax/v4/FAX_SetMessage" }

func (o *xxx_SetMessageOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetMessageOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// dwlMessageId {in} (1:{alias=DWORDLONG, names=ULONGLONG}(uint64))
	{
		if err := w.WriteData(o.MessageID); err != nil {
			return err
		}
	}
	// Folder {in} (1:{alias=FAX_ENUM_MESSAGE_FOLDER}(enum))
	{
		if err := w.WriteEnum(uint16(o.Folder)); err != nil {
			return err
		}
	}
	// lpMessageProps {in} (1:{pointer=ref, alias=PFAX_MESSAGE_PROPS}*(1))(2:{alias=FAX_MESSAGE_PROPS}(struct))
	{
		if o.MessageProperties != nil {
			if err := o.MessageProperties.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fax.MessageProperties{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_SetMessageOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// dwlMessageId {in} (1:{alias=DWORDLONG, names=ULONGLONG}(uint64))
	{
		if err := w.ReadData(&o.MessageID); err != nil {
			return err
		}
	}
	// Folder {in} (1:{alias=FAX_ENUM_MESSAGE_FOLDER}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.Folder)); err != nil {
			return err
		}
	}
	// lpMessageProps {in} (1:{pointer=ref, alias=PFAX_MESSAGE_PROPS}*(1))(2:{alias=FAX_MESSAGE_PROPS}(struct))
	{
		if o.MessageProperties == nil {
			o.MessageProperties = &fax.MessageProperties{}
		}
		if err := o.MessageProperties.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetMessageOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetMessageOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetMessageOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetMessageRequest structure represents the FAX_SetMessage operation request
type SetMessageRequest struct {
	// dwlMessageId: The unique ID number of the fax message.
	MessageID uint64 `idl:"name:dwlMessageId" json:"message_id"`
	// Folder: Identifies the location of the fax message. The value in this parameter MUST
	// come from the FAX_ENUM_MESSAGE_FOLDER (section 2.2.2) enumeration. It can be set
	// to the FAX_MESSAGE_FOLDER_INBOX or FAX_MESSAGE_FOLDER_SENTITEMS constant.
	Folder fax.MessageFolder `idl:"name:Folder" json:"folder"`
	// lpMessageProps: This MUST be a pointer to a FAX_MESSAGE_PROPS. Contains the property
	// settings for the fax message identified by dwlMessageId.
	MessageProperties *fax.MessageProperties `idl:"name:lpMessageProps;pointer:ref" json:"message_properties"`
}

func (o *SetMessageRequest) xxx_ToOp(ctx context.Context, op *xxx_SetMessageOperation) *xxx_SetMessageOperation {
	if op == nil {
		op = &xxx_SetMessageOperation{}
	}
	if o == nil {
		return op
	}
	op.MessageID = o.MessageID
	op.Folder = o.Folder
	op.MessageProperties = o.MessageProperties
	return op
}

func (o *SetMessageRequest) xxx_FromOp(ctx context.Context, op *xxx_SetMessageOperation) {
	if o == nil {
		return
	}
	o.MessageID = op.MessageID
	o.Folder = op.Folder
	o.MessageProperties = op.MessageProperties
}
func (o *SetMessageRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetMessageRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetMessageOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetMessageResponse structure represents the FAX_SetMessage operation response
type SetMessageResponse struct {
	// Return: The FAX_SetMessage return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetMessageResponse) xxx_ToOp(ctx context.Context, op *xxx_SetMessageOperation) *xxx_SetMessageOperation {
	if op == nil {
		op = &xxx_SetMessageOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetMessageResponse) xxx_FromOp(ctx context.Context, op *xxx_SetMessageOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetMessageResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetMessageResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetMessageOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetConfigOptionOperation structure represents the FAX_GetConfigOption operation
type xxx_GetConfigOptionOperation struct {
	Option fax.ConfigOption `idl:"name:option" json:"option"`
	Value  uint32           `idl:"name:lpdwValue" json:"value"`
	Return uint32           `idl:"name:Return" json:"return"`
}

func (o *xxx_GetConfigOptionOperation) OpNum() int { return 103 }

func (o *xxx_GetConfigOptionOperation) OpName() string { return "/fax/v4/FAX_GetConfigOption" }

func (o *xxx_GetConfigOptionOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetConfigOptionOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// option {in} (1:{alias=FAX_ENUM_CONFIG_OPTION}(enum))
	{
		if err := w.WriteEnum(uint16(o.Option)); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetConfigOptionOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// option {in} (1:{alias=FAX_ENUM_CONFIG_OPTION}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.Option)); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetConfigOptionOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetConfigOptionOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// lpdwValue {out} (1:{alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Value); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetConfigOptionOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// lpdwValue {out} (1:{alias=LPDWORD,pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Value); err != nil {
			return err
		}
	}
	// Return {out} (1:(error_status_t))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetConfigOptionRequest structure represents the FAX_GetConfigOption operation request
type GetConfigOptionRequest struct {
	// option: Identifies the configuration option to be returned. This parameter MUST be
	// a value from the FAX_ENUM_CONFIG_OPTION (section 2.2.3) enumeration.
	Option fax.ConfigOption `idl:"name:option" json:"option"`
}

func (o *GetConfigOptionRequest) xxx_ToOp(ctx context.Context, op *xxx_GetConfigOptionOperation) *xxx_GetConfigOptionOperation {
	if op == nil {
		op = &xxx_GetConfigOptionOperation{}
	}
	if o == nil {
		return op
	}
	op.Option = o.Option
	return op
}

func (o *GetConfigOptionRequest) xxx_FromOp(ctx context.Context, op *xxx_GetConfigOptionOperation) {
	if o == nil {
		return
	}
	o.Option = op.Option
}
func (o *GetConfigOptionRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetConfigOptionRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetConfigOptionOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetConfigOptionResponse structure represents the FAX_GetConfigOption operation response
type GetConfigOptionResponse struct {
	// lpdwValue: A pointer to a DWORD ([MS-DTYP] section 2.2.9) that holds the value of
	// the configuration option upon return. The value's type depends on the configuration
	// option that was asked for using the option parameter.
	//
	// If option was set to FAX_CONFIG_OPTION_ALLOW_PERSONAL_CP, lpdwValue contains a BOOL
	// that MUST take one of the following values.
	//
	//	+------------------+----------------------------------------------------------+
	//	|                  |                                                          |
	//	|    VALUE/CODE    |                         MEANING                          |
	//	|                  |                                                          |
	//	+------------------+----------------------------------------------------------+
	//	+------------------+----------------------------------------------------------+
	//	| TRUE 0x00000001  | The server allows personal cover page templates.         |
	//	+------------------+----------------------------------------------------------+
	//	| FALSE 0x00000000 | The server allows only server-side cover page templates. |
	//	+------------------+----------------------------------------------------------+
	//
	// If option was set to FAX_CONFIG_OPTION_QUEUE_STATE, lpdwValue is a DWORD value that
	// MUST specify state information about the fax queue defined in section 3.1.1. If this
	// value is zero, both the incoming and outgoing queues are unblocked. Otherwise, this
	// value MUST be a combination of one or more of the following flags.
	//
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	|                                 |                                                                                  |
	//	|           VALUE/CODE            |                                     MEANING                                      |
	//	|                                 |                                                                                  |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_INCOMING_BLOCKED 0x00000001 | The incoming faxes queue is blocked. The fax server does not answer any new      |
	//	|                                 | incoming faxes.                                                                  |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_OUTBOX_BLOCKED 0x00000002   | The outbox queue is blocked. The fax server does not accept submission of new    |
	//	|                                 | faxes. If the outbox is not paused, faxes in the queue are being processed.      |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| FAX_OUTBOX_PAUSED 0x00000004    | The outbox queue is paused. The fax server will not start sending outgoing faxes |
	//	|                                 | from the queue. Fax transmissions in progress are not affected. If the outbox is |
	//	|                                 | not blocked, the fax server still accepts submission of new faxes to the queue.  |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//
	// If option was set to FAX_CONFIG_OPTION_ALLOWED_RECEIPTS, lpdwValue contains a DWORD
	// that MUST be a bitwise combination of one or more of the flags that are specified
	// in FAX_ENUM_DELIVERY_REPORT_TYPES (section 2.2.76).
	//
	// If option was set to FAX_CONFIG_OPTION_INCOMING_FAXES_PUBLIC, lpdwValue contains
	// a BOOL that MUST take one of the following values.
	//
	//	+------------------+----------------------------------------------------+
	//	|                  |                                                    |
	//	|    VALUE/CODE    |                      MEANING                       |
	//	|                  |                                                    |
	//	+------------------+----------------------------------------------------+
	//	+------------------+----------------------------------------------------+
	//	| TRUE 0x00000001  | All incoming faxes can be viewed by all fax users. |
	//	+------------------+----------------------------------------------------+
	//	| FALSE 0x00000000 | Incoming faxes can be viewed only by recipients.   |
	//	+------------------+----------------------------------------------------+
	Value uint32 `idl:"name:lpdwValue" json:"value"`
	// Return: The FAX_GetConfigOption return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetConfigOptionResponse) xxx_ToOp(ctx context.Context, op *xxx_GetConfigOptionOperation) *xxx_GetConfigOptionOperation {
	if op == nil {
		op = &xxx_GetConfigOptionOperation{}
	}
	if o == nil {
		return op
	}
	op.Value = o.Value
	op.Return = o.Return
	return op
}

func (o *GetConfigOptionResponse) xxx_FromOp(ctx context.Context, op *xxx_GetConfigOptionOperation) {
	if o == nil {
		return
	}
	o.Value = op.Value
	o.Return = op.Return
}
func (o *GetConfigOptionResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetConfigOptionResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetConfigOptionOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}
