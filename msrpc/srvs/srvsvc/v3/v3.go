package srvsvc

import (
	"context"
	"fmt"
	"strings"
	"unicode/utf16"

	dcerpc "github.com/oiweiwei/go-msrpc/dcerpc"
	errors "github.com/oiweiwei/go-msrpc/dcerpc/errors"
	uuid "github.com/oiweiwei/go-msrpc/midl/uuid"
	dcetypes "github.com/oiweiwei/go-msrpc/msrpc/dcetypes"
	dtyp "github.com/oiweiwei/go-msrpc/msrpc/dtyp"
	ndr "github.com/oiweiwei/go-msrpc/ndr"
)

var (
	_ = context.Background
	_ = fmt.Errorf
	_ = utf16.Encode
	_ = strings.TrimPrefix
	_ = ndr.ZeroString
	_ = (*uuid.UUID)(nil)
	_ = (*dcerpc.SyntaxID)(nil)
	_ = (*errors.Error)(nil)
	_ = dtyp.GoPackage
	_ = dcetypes.GoPackage
)

var (
	// import guard
	GoPackage = "srvs"
)

var (
	// Syntax UUID
	SrvsvcSyntaxUUID = &uuid.UUID{TimeLow: 0x4b324fc8, TimeMid: 0x1670, TimeHiAndVersion: 0x1d3, ClockSeqHiAndReserved: 0x12, ClockSeqLow: 0x78, Node: [6]uint8{0x5a, 0x47, 0xbf, 0x6e, 0xe1, 0x88}}
	// Syntax ID
	SrvsvcSyntaxV3_0 = &dcerpc.SyntaxID{IfUUID: SrvsvcSyntaxUUID, IfVersionMajor: 3, IfVersionMinor: 0}
)

// srvsvc interface.
type SrvsvcClient interface {

	// Opnum0NotUsedOnWire operation.
	// Opnum0NotUsedOnWire

	// Opnum1NotUsedOnWire operation.
	// Opnum1NotUsedOnWire

	// Opnum2NotUsedOnWire operation.
	// Opnum2NotUsedOnWire

	// Opnum3NotUsedOnWire operation.
	// Opnum3NotUsedOnWire

	// Opnum4NotUsedOnWire operation.
	// Opnum4NotUsedOnWire

	// Opnum5NotUsedOnWire operation.
	// Opnum5NotUsedOnWire

	// Opnum6NotUsedOnWire operation.
	// Opnum6NotUsedOnWire

	// Opnum7NotUsedOnWire operation.
	// Opnum7NotUsedOnWire

	// The NetrConnectionEnum method lists all the treeconnects made to a shared resource
	// on the server or all treeconnects established from a particular computer.
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2.
	ConnectionEnum(context.Context, *ConnectionEnumRequest, ...dcerpc.CallOption) (*ConnectionEnumResponse, error)

	// The NetrFileEnum method MUST return information about some or all open files on a
	// server, depending on the parameters specified, or return an error code.
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2. The most common error codes are
	// listed in the following table.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 NERR_Success            | The client request succeeded.                                                    |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | Access is denied.                                                                |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x0000007C ERROR_INVALID_LEVEL     | The system call level is not correct.                                            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000000EA ERROR_MORE_DATA         | The client request succeeded. More entries are available. Not all entries could  |
	//	|                                    | be returned in the buffer size that is specified by PreferedMaximumLength.       |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000008 ERROR_NOT_ENOUGH_MEMORY | Not enough storage is available to process this command.                         |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x0000084B NERR_BufTooSmall        | The client request succeeded. More entries are available. The buffer size that   |
	//	|                                    | is specified by PreferedMaximumLength was too small to fit even a single entry.  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	FileEnum(context.Context, *FileEnumRequest, ...dcerpc.CallOption) (*FileEnumResponse, error)

	// The NetrFileGetInfo method MUST retrieve information about a particular open server
	// resource or return an error code.
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2. The most common error codes are
	// listed in the following table.
	//
	//	+------------------------------------+----------------------------------------------------------+
	//	|               RETURN               |                                                          |
	//	|             VALUE/CODE             |                       DESCRIPTION                        |
	//	|                                    |                                                          |
	//	+------------------------------------+----------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------+
	//	| 0x00000000 NERR_Success            | The client request succeeded.                            |
	//	+------------------------------------+----------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | Access is denied.                                        |
	//	+------------------------------------+----------------------------------------------------------+
	//	| 0x00000002 ERROR_FILE_NOT_FOUND    | The system cannot find the file specified.               |
	//	+------------------------------------+----------------------------------------------------------+
	//	| 0x0000007C ERROR_INVALID_LEVEL     | The system call level is not correct.                    |
	//	+------------------------------------+----------------------------------------------------------+
	//	| 0x00000008 ERROR_NOT_ENOUGH_MEMORY | Not enough storage is available to process this command. |
	//	+------------------------------------+----------------------------------------------------------+
	//	| 0x0000084B NERR_BufTooSmall        | The supplied buffer is too small.                        |
	//	+------------------------------------+----------------------------------------------------------+
	FileGetInfo(context.Context, *FileGetInfoRequest, ...dcerpc.CallOption) (*FileGetInfoResponse, error)

	// The server receives the NetrFileClose method in an RPC_REQUEST packet. In response,
	// the server MUST force an open resource instance (for example, file, device, or named
	// pipe) on the server to close. This message can be used when an error prevents closure
	// by any other means.
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2. The most common error codes are
	// listed in the following table.
	//
	//	+--------------------------------+-----------------------------------------------------------------+
	//	|             RETURN             |                                                                 |
	//	|           VALUE/CODE           |                           DESCRIPTION                           |
	//	|                                |                                                                 |
	//	+--------------------------------+-----------------------------------------------------------------+
	//	+--------------------------------+-----------------------------------------------------------------+
	//	| 0x00000000 NERR_Success        | The client request succeeded.                                   |
	//	+--------------------------------+-----------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED | Access is denied.                                               |
	//	+--------------------------------+-----------------------------------------------------------------+
	//	| 0x0000090A NERR_FileIdNotFound | There is no open file with the specified identification number. |
	//	+--------------------------------+-----------------------------------------------------------------+
	//
	// This message can be used when an error prevents closure by any other means.
	//
	// The FileId parameter specifies the file identifier of the Open in FileList to close.
	// The value of the FileId parameter MUST correspond to a FileId that is returned in
	// a previous NetrFileEnum message response by the server. The server MUST look up Open
	// in the FileList where FileId matches Open.GlobalFileId. If no match is found, the
	// server MUST return NERR_FileIdNotFound. If a match is found, the server MUST close
	// the Open by invoking an underlying server event as specified in [MS-CIFS] section
	// 3.3.4.13 or [MS-SMB2] section 3.3.4.17, providing FileId as the input parameter.
	//
	// If either CIFS or SMB2 servers return STATUS_SUCCESS, the server MUST return NERR_Success.
	// Otherwise, the server MUST fail the call with a NERR_FileIdNotFound error code.
	//
	// The server SHOULD<49> enforce security measures to verify that the caller has the
	// required permissions to execute this routine. If the caller does not have the required
	// credentials, the server SHOULD<50> fail the call.
	FileClose(context.Context, *FileCloseRequest, ...dcerpc.CallOption) (*FileCloseResponse, error)

	// The NetrSessionEnum method MUST return information about sessions that are established
	// on a server or return an error code.
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2. The most common error codes are
	// listed in the following table.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 NERR_Success            | The client request succeeded.                                                    |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | Access is denied.                                                                |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x0000007C ERROR_INVALID_LEVEL     | The system call level is not correct.                                            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | The parameter is incorrect.                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000000EA ERROR_MORE_DATA         | The client request succeeded. More entries are available. Not all entries could  |
	//	|                                    | be returned in the buffer size that is specified by PreferedMaximumLength.       |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000008 ERROR_NOT_ENOUGH_MEMORY | Not enough storage is available to process this command.                         |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000908 NERR_ClientNameNotFound | A session does not exist with the computer name.                                 |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x0000092F NERR_InvalidComputer    | The computer name is not valid.                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000008AD NERR_UserNotFound       | The user name could not be found.                                                |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	SessionEnum(context.Context, *SessionEnumRequest, ...dcerpc.CallOption) (*SessionEnumResponse, error)

	// The NetrSessionDel method MUST end one or more network sessions between a server
	// and a client.
	//
	// Return Values: This method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. This method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2. The most common error codes are
	// listed in the following table.
	//
	//	+------------------------------------+----------------------------------------------------------+
	//	|               RETURN               |                                                          |
	//	|             VALUE/CODE             |                       DESCRIPTION                        |
	//	|                                    |                                                          |
	//	+------------------------------------+----------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------+
	//	| 0x00000000 NERR_Success            | The client request succeeded.                            |
	//	+------------------------------------+----------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | Access is denied.                                        |
	//	+------------------------------------+----------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | The parameter is incorrect.                              |
	//	+------------------------------------+----------------------------------------------------------+
	//	| 0x00000008 ERROR_NOT_ENOUGH_MEMORY | Not enough storage is available to process this command. |
	//	+------------------------------------+----------------------------------------------------------+
	//	| 0x00000908 NERR_ClientNameNotFound | A session does not exist with the computer name.         |
	//	+------------------------------------+----------------------------------------------------------+
	SessionDelete(context.Context, *SessionDeleteRequest, ...dcerpc.CallOption) (*SessionDeleteResponse, error)

	// The NetrShareAdd method shares a server resource.
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2. The most common error codes are
	// listed in the following table.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 NERR_Success            | The client request succeeded.                                                    |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | Access is denied.                                                                |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x0000007C ERROR_INVALID_LEVEL     | The system call level is not correct.                                            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x0000007B ERROR_INVALID_NAME      | The file name, directory name, or volume label syntax is incorrect.              |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | The client request failed because the specified parameter is invalid. For        |
	//	|                                    | details, see the description that follows for the ParmErr parameter.             |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000008 ERROR_NOT_ENOUGH_MEMORY | Not enough storage is available to process this command.                         |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000846 NERR_DuplicateShare     | The share name is already in use on this server.                                 |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000844 NERR_UnknownDevDir      | The device or directory does not exist.                                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	ShareAdd(context.Context, *ShareAddRequest, ...dcerpc.CallOption) (*ShareAddResponse, error)

	// The NetrShareEnum method retrieves information about each shared resource on a server.
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2. The most common error codes are
	// listed in the following table.
	//
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	|             RETURN             |                                                                                  |
	//	|           VALUE/CODE           |                                   DESCRIPTION                                    |
	//	|                                |                                                                                  |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 NERR_Success        | The client request succeeded.                                                    |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000000EA ERROR_MORE_DATA     | The client request succeeded. More entries are available. Not all entries could  |
	//	|                                | be returned in the buffer size that is specified by PreferedMaximumLength.       |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	| 0x0000007C ERROR_INVALID_LEVEL | The system call level is not correct.                                            |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//
	// If ServerName does not match any Transport.ServerName in TransportList with the SVTI2_SCOPED_NAME
	// bit set in Transport.Flags, the server MUST reset ServerName as "*".
	ShareEnum(context.Context, *ShareEnumRequest, ...dcerpc.CallOption) (*ShareEnumResponse, error)

	// The NetrShareGetInfo method retrieves information about a particular shared resource
	// on the server from the ShareList.
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2. The most common error codes are
	// listed in the following table.
	//
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	|               RETURN               |                                                                       |
	//	|             VALUE/CODE             |                              DESCRIPTION                              |
	//	|                                    |                                                                       |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	| 0x00000000 NERR_Success            | The client request succeeded.                                         |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | Access is denied.                                                     |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	| 0x0000007C ERROR_INVALID_LEVEL     | The system call level is not correct.                                 |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | The client request failed because the specified parameter is invalid. |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	| 0x00000008 ERROR_NOT_ENOUGH_MEMORY | Not enough storage is available to process this command.              |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	| 0x0000084B NERR_BufTooSmall        | The supplied buffer is too small.                                     |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	| 0x00000906 NERR_NetNameNotFound    | The share name does not exist.                                        |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//
	// If ServerName does not match any Transport.ServerName in TransportList with the SVTI2_SCOPED_NAME
	// bit set in Transport.Flags, the server MUST reset ServerName as "*".
	ShareGetInfo(context.Context, *ShareGetInfoRequest, ...dcerpc.CallOption) (*ShareGetInfoResponse, error)

	// The NetrShareSetInfo method sets the parameters of a shared resource in a ShareList.
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2. The most common error codes are
	// listed in the following table.
	//
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	|                 RETURN                  |                                                                                  |
	//	|               VALUE/CODE                |                                   DESCRIPTION                                    |
	//	|                                         |                                                                                  |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 NERR_Success                 | The client request succeeded.                                                    |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED          | Access is denied.                                                                |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER      | The client request failed because the specified parameter is invalid. For        |
	//	|                                         | details, see the description that follows for the ParmErr parameter.             |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000008 ERROR_NOT_ENOUGH_MEMORY      | Not enough storage is available to process this command.                         |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000906 NERR_NetNameNotFound         | The share name does not exist.                                                   |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED          | The server does not support branch cache. <62>                                   |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000424 ERROR_SERVICE_DOES_NOT_EXIST | The branch cache component does not exist as an installed service. <63>          |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x0000007C ERROR_INVALID_LEVEL          | The system call level is not correct.                                            |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	ShareSetInfo(context.Context, *ShareSetInfoRequest, ...dcerpc.CallOption) (*ShareSetInfoResponse, error)

	// The NetrShareDel method deletes a share name from the ShareList, which disconnects
	// all connections to the shared resource. If the share is sticky, all information about
	// the share is also deleted from permanent storage.<67>
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2. The most common error codes are
	// listed in the following table.
	//
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	|               RETURN               |                                                                       |
	//	|             VALUE/CODE             |                              DESCRIPTION                              |
	//	|                                    |                                                                       |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	| 0x00000000 NERR_Success            | The client request succeeded.                                         |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | Access is denied.                                                     |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | The client request failed because the specified parameter is invalid. |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	| 0x00000008 ERROR_NOT_ENOUGH_MEMORY | Not enough storage is available to process this command.              |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	| 0x00000906 NERR_NetNameNotFound    | The share name does not exist.                                        |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//
	// If ServerName does not match any Transport.ServerName in TransportList with the SVTI2_SCOPED_NAME
	// bit set in Transport.Flags, the server MUST reset ServerName as "*".
	ShareDelete(context.Context, *ShareDeleteRequest, ...dcerpc.CallOption) (*ShareDeleteResponse, error)

	// The NetrShareDelSticky method marks the share as nonpersistent by clearing the IsPersistent
	// member of a Share in the ShareList.
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2.
	//
	// The primary use of this method is to delete a sticky share whose root directory has
	// been deleted (thus preventing actual re-creation of the share) but whose entry still
	// exists in permanent storage.<72> This method can also be used to remove the persistence
	// of a share without deleting the current incarnation of the share.
	//
	// If ServerName does not match any Transport.ServerName in TransportList with the SVTI2_SCOPED_NAME
	// bit set in Transport.Flags, the server MUST reset ServerName as "*".
	ShareDeleteSticky(context.Context, *ShareDeleteStickyRequest, ...dcerpc.CallOption) (*ShareDeleteStickyResponse, error)

	// The NetrShareCheck method checks whether a server is sharing a device.
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2. The most common error codes are
	// listed in the following table.
	//
	//	+------------------------------------+----------------------------------------------------------+
	//	|               RETURN               |                                                          |
	//	|             VALUE/CODE             |                       DESCRIPTION                        |
	//	|                                    |                                                          |
	//	+------------------------------------+----------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------+
	//	| 0x00000000 NERR_Success            | The client request succeeded.                            |
	//	+------------------------------------+----------------------------------------------------------+
	//	| 0x00000008 ERROR_NOT_ENOUGH_MEMORY | Not enough storage is available to process this command. |
	//	+------------------------------------+----------------------------------------------------------+
	//	| 0x00000907 NERR_DeviceNotShared    | The device is not shared.                                |
	//	+------------------------------------+----------------------------------------------------------+
	ShareCheck(context.Context, *ShareCheckRequest, ...dcerpc.CallOption) (*ShareCheckResponse, error)

	// The NetrServerGetInfo method retrieves current configuration information for CIFS
	// and SMB Version 1.0 servers.
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2. The most common error codes are
	// listed in the following table.
	//
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	|               RETURN               |                                                                       |
	//	|             VALUE/CODE             |                              DESCRIPTION                              |
	//	|                                    |                                                                       |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	| 0x00000000 NERR_Success            | The client request succeeded.                                         |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | Access is denied.                                                     |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	| 0x0000007C ERROR_INVALID_LEVEL     | The system call level is not correct.                                 |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | The client request failed because the specified parameter is invalid. |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	| 0x00000008 ERROR_NOT_ENOUGH_MEMORY | Not enough storage is available to process this command.              |
	//	+------------------------------------+-----------------------------------------------------------------------+
	GetInfo(context.Context, *GetInfoRequest, ...dcerpc.CallOption) (*GetInfoResponse, error)

	// The NetrServerSetInfo method sets server operating parameters for CIFS and SMB Version
	// 1.0 file servers; it can set them individually or collectively. The information is
	// stored in a way that allows it to remain in effect after the system is reinitialized.<81>
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2. The most common error codes are
	// listed in the following table.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 NERR_Success            | The client request succeeded.                                                    |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | Access is denied.                                                                |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x0000007C ERROR_INVALID_LEVEL     | The system call level is not correct.                                            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | The client request failed because the specified parameter is invalid. For        |
	//	|                                    | details see the description that follows for the ParmErr parameter.              |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000008 ERROR_NOT_ENOUGH_MEMORY | Not enough storage is available to process this command.                         |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	SetInfo(context.Context, *SetInfoRequest, ...dcerpc.CallOption) (*SetInfoResponse, error)

	// The NetrServerDiskEnum method retrieves a list of disk drives on a server. The method
	// returns an array of three-character strings (a drive letter, a colon, and a terminating
	// null character).
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2. The most common error codes are
	// listed in the following table.
	//
	//	+------------------------------------+--------------------------------------------------------------------+
	//	|               RETURN               |                                                                    |
	//	|             VALUE/CODE             |                            DESCRIPTION                             |
	//	|                                    |                                                                    |
	//	+------------------------------------+--------------------------------------------------------------------+
	//	+------------------------------------+--------------------------------------------------------------------+
	//	| 0x00000000 NERR_Success            | The client request succeeded.                                      |
	//	+------------------------------------+--------------------------------------------------------------------+
	//	| 0x0000007C ERROR_INVALID_LEVEL     | The system call level is not correct.                              |
	//	+------------------------------------+--------------------------------------------------------------------+
	//	| 0x00000008 ERROR_NOT_ENOUGH_MEMORY | Not enough storage is available to process this command.           |
	//	+------------------------------------+--------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The caller does not have the permissions to perform the operation. |
	//	+------------------------------------+--------------------------------------------------------------------+
	DiskEnum(context.Context, *DiskEnumRequest, ...dcerpc.CallOption) (*DiskEnumResponse, error)

	// The NetrServerStatisticsGet method retrieves the operating statistics for a service.
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2.
	StatisticsGet(context.Context, *StatisticsGetRequest, ...dcerpc.CallOption) (*StatisticsGetResponse, error)

	// The NetrServerTransportAdd method binds the server to the transport protocol.
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2. The most common error codes are
	// listed in the following table.
	//
	//	+------------------------------------+----------------------------------------------------------+
	//	|               RETURN               |                                                          |
	//	|             VALUE/CODE             |                       DESCRIPTION                        |
	//	|                                    |                                                          |
	//	+------------------------------------+----------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------+
	//	| 0x00000000 NERR_Success            | The client request succeeded.                            |
	//	+------------------------------------+----------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | Access is denied.                                        |
	//	+------------------------------------+----------------------------------------------------------+
	//	| 0x00000034 ERROR_DUP_NAME          | A duplicate name exists on the network.                  |
	//	+------------------------------------+----------------------------------------------------------+
	//	| 0x0000007C ERROR_INVALID_LEVEL     | The system call level is not correct.                    |
	//	+------------------------------------+----------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | The parameter is incorrect.                              |
	//	+------------------------------------+----------------------------------------------------------+
	//	| 0x00000008 ERROR_NOT_ENOUGH_MEMORY | Not enough storage is available to process this command. |
	//	+------------------------------------+----------------------------------------------------------+
	//
	// The NetrServerTransportAdd message MUST be processed in the same way as the NetrServerTransportAddEx
	// message, except that it MUST allow only level 0 (that is, SERVER_TRANSPORT_INFO_0).
	// The NetrServerTransportAddEx message is specified in section 3.1.4.23.
	//
	// The server MAY<91> enforce security measures to verify that the caller has the required
	// permissions to execute this call. If the server enforces these security measures
	// and the caller does not have the required credentials, the server SHOULD<92> fail
	// the call.
	TransportAdd(context.Context, *TransportAddRequest, ...dcerpc.CallOption) (*TransportAddResponse, error)

	// The NetrServerTransportEnum method enumerates the information about transport protocols
	// that the server manages in TransportList.
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2. The most common error codes are
	// listed in the following table.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 NERR_Success            | The client request succeeded.                                                    |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x0000007C ERROR_INVALID_LEVEL     | The system call level is not correct.                                            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000000EA ERROR_MORE_DATA         | The client request succeeded. More entries are available. Not all entries could  |
	//	|                                    | be returned in the buffer size that is specified by PreferedMaximumLength.       |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000008 ERROR_NOT_ENOUGH_MEMORY | Not enough storage is available to process this command.                         |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x0000084B NERR_BufTooSmall        | The client request succeeded. More entries are available. The buffer size that   |
	//	|                                    | is specified by PreferedMaximumLength was too small to fit even a single entry.  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	TransportEnum(context.Context, *TransportEnumRequest, ...dcerpc.CallOption) (*TransportEnumResponse, error)

	// The NetrServerTransportDel method unbinds (or disconnects) the transport protocol
	// from the server. If this method succeeds, the server can no longer communicate with
	// clients by using the specified transport protocol (such as TCP or XNS).
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2. The most common error codes are
	// listed in the following table.
	//
	//	+------------------------------------+----------------------------------------------------------+
	//	|               RETURN               |                                                          |
	//	|             VALUE/CODE             |                       DESCRIPTION                        |
	//	|                                    |                                                          |
	//	+------------------------------------+----------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------+
	//	| 0x00000000 NERR_Success            | The client request succeeded.                            |
	//	+------------------------------------+----------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | Access is denied.                                        |
	//	+------------------------------------+----------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | The parameter is incorrect.                              |
	//	+------------------------------------+----------------------------------------------------------+
	//	| 0x00000008 ERROR_NOT_ENOUGH_MEMORY | Not enough storage is available to process this command. |
	//	+------------------------------------+----------------------------------------------------------+
	//
	// The NetrServerTransportDel message MUST be processed in the same way as the NetrServerTransportDelEx
	// message, except that it MUST allow only level 0 (that is, SERVER_TRANSPORT_INFO_0).
	// The processing for this message is specified in section 3.1.4.26.
	//
	// The server MAY<97> enforce security measures to verify that the caller has the required
	// permissions to execute this call. If the server enforces these security measures
	// and the caller does not have the required credentials, the server SHOULD<98> fail
	// the call.
	TransportDelete(context.Context, *TransportDeleteRequest, ...dcerpc.CallOption) (*TransportDeleteResponse, error)

	// The NetrRemoteTOD method returns the time of day information on a server.
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2.
	RemoteToD(context.Context, *RemoteToDRequest, ...dcerpc.CallOption) (*RemoteToDResponse, error)

	// Opnum29NotUsedOnWire operation.
	// Opnum29NotUsedOnWire

	// The NetprPathType method checks a path name to determine its type.
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2.
	PathType(context.Context, *PathTypeRequest, ...dcerpc.CallOption) (*PathTypeResponse, error)

	// The NetprPathCanonicalize method converts a path name to the canonical format.
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2.
	//
	// If the Flags parameter is not equal to zero, the server SHOULD fail the call with
	// an implementation-specific error code.<110>
	PathCanonicalize(context.Context, *PathCanonicalizeRequest, ...dcerpc.CallOption) (*PathCanonicalizeResponse, error)

	// The NetprPathCompare method performs comparison of two paths.
	//
	// Return Values: Upon successful processing, the server MUST return 0 if both paths
	// are the same, –1 if the first is less than the second, and 1 otherwise. If the
	// method fails, it can return any specific error code value as specified in [MS-ERREF]
	// section 2.2.
	PathCompare(context.Context, *PathCompareRequest, ...dcerpc.CallOption) (*PathCompareResponse, error)

	// The NetprNameValidate method performs checks to ensure that the specified name is
	// a valid name for the specified type.
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2.
	//
	// If the Flags parameter is not equal to zero, the server SHOULD fail the call with
	// an implementation-specific error code.<119>
	NameValidate(context.Context, *NameValidateRequest, ...dcerpc.CallOption) (*NameValidateResponse, error)

	// The NetprNameCanonicalize method converts a name to the canonical format for the
	// specified type.
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2.
	NameCanonicalize(context.Context, *NameCanonicalizeRequest, ...dcerpc.CallOption) (*NameCanonicalizeResponse, error)

	// The NetprNameCompare method does comparison of two names of a specific name type.
	//
	// Return Values: MUST return 0 if both paths are the same. Other values indicate that
	// either the paths are different or an error occurred when the client request was processed.
	NameCompare(context.Context, *NameCompareRequest, ...dcerpc.CallOption) (*NameCompareResponse, error)

	// The NetrShareEnumSticky method retrieves information about each sticky shared resource
	// whose IsPersistent setting is set in a ShareList.
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2. The most common error codes are
	// listed in the following table.
	//
	//	+-----------------------------+----------------------------------------------------------------------------------+
	//	|           RETURN            |                                                                                  |
	//	|         VALUE/CODE          |                                   DESCRIPTION                                    |
	//	|                             |                                                                                  |
	//	+-----------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 NERR_Success     | The client request succeeded.                                                    |
	//	+-----------------------------+----------------------------------------------------------------------------------+
	//	| 0x000000EA ERROR_MORE_DATA  | The client request succeeded. More entries are available. Not all entries could  |
	//	|                             | be returned in the buffer size that is specified by PreferedMaximumLength.       |
	//	+-----------------------------+----------------------------------------------------------------------------------+
	//	| 0x0000084B NERR_BufTooSmall | The client request succeeded. More entries are available. The buffer size that   |
	//	|                             | is specified by PreferedMaximumLength was too small to fit even a single entry.  |
	//	+-----------------------------+----------------------------------------------------------------------------------+
	ShareEnumSticky(context.Context, *ShareEnumStickyRequest, ...dcerpc.CallOption) (*ShareEnumStickyResponse, error)

	// The NetrShareDelStart method performs the initial phase of a two-phase share delete.
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2.
	ShareDeleteStart(context.Context, *ShareDeleteStartRequest, ...dcerpc.CallOption) (*ShareDeleteStartResponse, error)

	// The NetrShareDelCommit method performs the final phase of a two-phase share delete.
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success.
	// Otherwise, the method returns a nonzero error code unless the share being deleted
	// is IPC$. If the share being deleted is IPC$, the return value is not meaningful.
	// The method can take any specific error code value, as specified in [MS-ERREF] section
	// 2.2.
	//
	// The NetrShareDelCommit message is the continuation of the NetrShareDelStart message
	// and MUST cause the share to be actually deleted, which disconnects all connections
	// to the share, or MUST return an error code.
	//
	// This method can be used to delete the IPC$ share as well as other shares. When the
	// share is not IPC$, only a return value of 0 indicates success.
	//
	// This two-phase deletion MUST be used to delete IPC$, which is the share that is used
	// for named pipes. Deleting IPC$ results in the closing of the pipe on which the RPC
	// is being executed. Thus, the client never receives the response to the RPC. The two-phase
	// delete offers a positive response in phase 1 and then an expected error in phase
	// 2.
	//
	// ContextHandle MUST reference the share to be deleted in the NetrShareDelStart method.
	// If a share is not found, the server MUST fail the call with an ERROR_INVALID_PARAMETER
	// error code.
	//
	// If a share is found, but the IsMarkedForDeletion member of the Share is not set,
	// the server MUST fail the call with an ERROR_INVALID_PARAMETER error code.
	//
	// Otherwise, the server MUST delete the share by invoking the underlying server event,
	// as specified in [MS-CIFS] section 3.3.4.11and [MS-SMB2] section 3.3.4.15, providing
	// tuple <ServerName, NetName> as input parameters.
	//
	// The server does not enforce any security measures when processing this call.
	ShareDeleteCommit(context.Context, *ShareDeleteCommitRequest, ...dcerpc.CallOption) (*ShareDeleteCommitResponse, error)

	// The NetrpGetFileSecurity method returns to the caller a copy of the security descriptor
	// that protects a file or directory.
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2.
	GetFileSecurity(context.Context, *GetFileSecurityRequest, ...dcerpc.CallOption) (*GetFileSecurityResponse, error)

	// The NetrpSetFileSecurity method sets the security of a file or directory.
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2.
	SetFileSecurity(context.Context, *SetFileSecurityRequest, ...dcerpc.CallOption) (*SetFileSecurityResponse, error)

	// The NetrServerTransportAddEx method binds the specified server to the transport protocol.
	// This extended method allows the caller to specify information levels 1, 2, and 3
	// beyond what the NetrServerTransportAdd method allows.
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2. The most common error codes are
	// listed in the following table.
	//
	//	+------------------------------------+----------------------------------------------------------+
	//	|               RETURN               |                                                          |
	//	|             VALUE/CODE             |                       DESCRIPTION                        |
	//	|                                    |                                                          |
	//	+------------------------------------+----------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------+
	//	| 0x00000000 NERR_Success            | The client request succeeded.                            |
	//	+------------------------------------+----------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | Access is denied.                                        |
	//	+------------------------------------+----------------------------------------------------------+
	//	| 0x00000034 ERROR_DUP_NAME          | A duplicate name exists on the network.                  |
	//	+------------------------------------+----------------------------------------------------------+
	//	| 0x0000007C ERROR_INVALID_LEVEL     | The system call level is not correct.                    |
	//	+------------------------------------+----------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | The parameter is incorrect.                              |
	//	+------------------------------------+----------------------------------------------------------+
	//	| 0x00000008 ERROR_NOT_ENOUGH_MEMORY | Not enough storage is available to process this command. |
	//	+------------------------------------+----------------------------------------------------------+
	//
	// The server SHOULD<93> enforce security measures to verify that the caller has the
	// required permissions to execute this call. If the caller does not have the required
	// credentials, the server SHOULD<94> fail the call.
	//
	// The Level parameter determines the type of structure that the client has used to
	// specify information about the new transport. The value MUST be 0, 1, 2, or 3. If
	// the Level parameter is not equal to one of the valid values, the server MUST fail
	// the call with an ERROR_INVALID_LEVEL error code.
	//
	// If the Level parameter is 0, the Buffer parameter points to a SERVER_TRANSPORT_INFO_0
	// structure.
	//
	// If the Level parameter is 1, the Buffer parameter points to a SERVER_TRANSPORT_INFO_1
	// structure.
	//
	// If the Level parameter is 2, the Buffer parameter points to a SERVER_TRANSPORT_INFO_2
	// structure.
	//
	// If the Level parameter is 3, the Buffer parameter points to a SERVER_TRANSPORT_INFO_3
	// structure.
	TransportAddEx(context.Context, *TransportAddExRequest, ...dcerpc.CallOption) (*TransportAddExResponse, error)

	// Opnum42NotUsedOnWire operation.
	// Opnum42NotUsedOnWire

	// The NetrDfsGetVersion method checks whether the server is a DFS server and if so,
	// returns the DFS version. An implementation MAY<127> choose to support this method.
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2.
	GetVersion(context.Context, *GetVersionRequest, ...dcerpc.CallOption) (*GetVersionResponse, error)

	// The NetrDfsCreateLocalPartition method marks a share as being a DFS share. In addition,
	// if the RelationInfo parameter is non-NULL, it creates DFS links, as specified in
	// [MS-DFSC], for each of the entries in the RelationInfo parameter. An implementation
	// MAY<132> choose to support this method.
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2.
	CreateLocalPartition(context.Context, *CreateLocalPartitionRequest, ...dcerpc.CallOption) (*CreateLocalPartitionResponse, error)

	// The NetrDfsDeleteLocalPartition method deletes a DFS share (Prefix) on the server.
	// An implementation MAY<138> choose to support this method.
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2.
	DeleteLocalPartition(context.Context, *DeleteLocalPartitionRequest, ...dcerpc.CallOption) (*DeleteLocalPartitionResponse, error)

	// The NetrDfsSetLocalVolumeState method sets a local DFS share online or offline. An
	// implementation MAY<142> choose to support this method.
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2.
	SetLocalVolumeState(context.Context, *SetLocalVolumeStateRequest, ...dcerpc.CallOption) (*SetLocalVolumeStateResponse, error)

	// Opnum47NotUsedOnWire operation.
	// Opnum47NotUsedOnWire

	// The NetrDfsCreateExitPoint method creates a DFS link on the server. An implementation
	// MAY<146> choose to support this method.
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2.
	CreateExitPoint(context.Context, *CreateExitPointRequest, ...dcerpc.CallOption) (*CreateExitPointResponse, error)

	// The NetrDfsDeleteExitPoint method deletes a DFS link on the server. An implementation
	// MAY<155> choose to support this method.
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2.
	DeleteExitPoint(context.Context, *DeleteExitPointRequest, ...dcerpc.CallOption) (*DeleteExitPointResponse, error)

	// The NetrDfsModifyPrefix method changes the path that corresponds to a DFS link on
	// the server. An implementation MAY<151> choose to support this method.
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2.
	ModifyPrefix(context.Context, *ModifyPrefixRequest, ...dcerpc.CallOption) (*ModifyPrefixResponse, error)

	// The NetrDfsFixLocalVolume method provides knowledge of a new DFS share on the server.
	// An implementation MAY<159> choose to support this method.
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2.
	FixLocalVolume(context.Context, *FixLocalVolumeRequest, ...dcerpc.CallOption) (*FixLocalVolumeResponse, error)

	// The NetrDfsManagerReportSiteInfo method obtains a list of names that SHOULD<165>
	// correspond to the Active Directory sites covered by the specified server. An implementation
	// MAY<166> choose to support this method.
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2.
	//
	// The ppSiteInfo parameter is a pointer to a LPDFS_SITELIST_INFO member, which in turn
	// points to the location of a DFS_SITELIST_INFO structure in which the information
	// is returned. That structure has a cSites member that the server SHOULD set to the
	// number of sites returned. The information about the sites themselves MUST be returned
	// in the Site member, which is an array of DFS_SITENAME_INFO structures. The sites
	// the server returns are implementation-specific.<167>
	//
	// The server MAY<168> enforce security measures to verify that the caller has the required
	// permissions to execute this call. If the server enforces these security measures
	// and the caller does not have the required credentials, the server SHOULD<169> fail
	// the call.
	ManagerReportSiteInfo(context.Context, *ManagerReportSiteInfoRequest, ...dcerpc.CallOption) (*ManagerReportSiteInfoResponse, error)

	// The server receives the NetrServerTransportDelEx method in an RPC_REQUEST packet.
	// In response, the server unbinds (or disconnects) the transport protocol from the
	// server. If this method succeeds, the server can no longer communicate with clients
	// by using the specified transport protocol (such as TCP or XNS). This extended method
	// allows level 1 beyond what the NetrServerTransportDel method allows.
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2.<99>
	//
	// The Level parameter determines the type of structure the client has used to specify
	// information about the new transport. Valid values are 0 and 1. If the Level parameter
	// is not equal to one of the valid values, the server MUST fail the call with an ERROR_INVALID_LEVEL
	// error code.
	//
	// If the Level parameter is 0, the Buffer parameter points to a SERVER_TRANSPORT_INFO_0
	// structure. If the Level parameter is 1, the Buffer parameter points to a SERVER_TRANSPORT_INFO_1
	// structure.
	TransportDeleteEx(context.Context, *TransportDeleteExRequest, ...dcerpc.CallOption) (*TransportDeleteExResponse, error)

	// The NetrServerAliasAdd method attaches an alias name to an existing server name and
	// inserts Alias objects into AliasList, through which the shared resource can be accessed
	// either with server name or alias name. An alias is used to identify which resources
	// are visible to an SMB client based on the server name presented in each tree connect
	// request.
	//
	// );
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2. The most common error codes are
	// listed in the following table.
	//
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	|               RETURN               |                                                                       |
	//	|             VALUE/CODE             |                              DESCRIPTION                              |
	//	|                                    |                                                                       |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	| 0x00000000 NERR_Success            | The client request succeeded.                                         |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | Access is denied.                                                     |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | The client request failed because the specified parameter is invalid. |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	| 0x00000008 ERROR_NOT_ENOUGH_MEMORY | Not enough storage is available to process this command.              |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	| 0x00000846 NERR_DuplicateShare     | The alias already exists.                                             |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	| 0x0000007C ERROR_INVALID_LEVEL     | The system call level is not correct.                                 |
	//	+------------------------------------+-----------------------------------------------------------------------+
	AliasAdd(context.Context, *AliasAddRequest, ...dcerpc.CallOption) (*AliasAddResponse, error)

	// The NetrServerAliasEnum method retrieves alias information for a server based on
	// specified alias name or server name.
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2. The most common error codes are
	// listed in the following table.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 NERR_Success            | The client request succeeded.                                                    |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | Access is denied.                                                                |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | The client request failed because the specified parameter is invalid.            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000008 ERROR_NOT_ENOUGH_MEMORY | Not enough storage is available to process this command.                         |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x0000084B NERR_BufTooSmall        | The allocated buffer is too small to hold single entry.                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x0000007C ERROR_INVALID_LEVEL     | The system call level is not correct.                                            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000000EA ERROR_MORE_DATA         | The client request succeeded. More entries are available. Not all entries could  |
	//	|                                    | be returned in the buffer size that is specified by PreferedMaximumLength.       |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	AliasEnum(context.Context, *AliasEnumRequest, ...dcerpc.CallOption) (*AliasEnumResponse, error)

	// The NetrServerAliasDel method deletes an alias name from a server alias list based
	// on specified alias name.
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2. The most common error codes are
	// listed in the following table.
	//
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	|               RETURN               |                                                                       |
	//	|             VALUE/CODE             |                              DESCRIPTION                              |
	//	|                                    |                                                                       |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	| 0x00000000 NERR_Success            | The client request succeeded.                                         |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | Access is denied.                                                     |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | The client request failed because the specified parameter is invalid. |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	| 0x00000008 ERROR_NOT_ENOUGH_MEMORY | Not enough storage is available to process this command.              |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	| 0x00000906 NERR_NetNameNotFound    | The alias does not exist.                                             |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	| 0x0000007C ERROR_INVALID_LEVEL     | The system call level is not correct.                                 |
	//	+------------------------------------+-----------------------------------------------------------------------+
	AliasDelete(context.Context, *AliasDeleteRequest, ...dcerpc.CallOption) (*AliasDeleteResponse, error)

	// The NetrShareDelEx method deletes a share from the ShareList, which disconnects all
	// connections to the shared resource. If the share is sticky, all information about
	// the share is also deleted from permanent storage.<176>
	//
	// Return Values: The method returns 0x00000000 (NERR_Success) to indicate success;
	// otherwise, it returns a nonzero error code. The method can take any specific error
	// code value, as specified in [MS-ERREF] section 2.2. The most common error codes are
	// listed in the following table.
	//
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	|               RETURN               |                                                                       |
	//	|             VALUE/CODE             |                              DESCRIPTION                              |
	//	|                                    |                                                                       |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	| 0x00000000 NERR_Success            | The client request succeeded.                                         |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | Access is denied.                                                     |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | The client request failed because the specified parameter is invalid. |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	| 0x00000008 ERROR_NOT_ENOUGH_MEMORY | Not enough storage is available to process this command.              |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	| 0x00000906 NERR_NetNameNotFound    | The share name does not exist.                                        |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	| 0x0000007C ERROR_INVALID_LEVEL     | The system call level is not correct.                                 |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//
	// The ShareInfo.shi503_netname parameter specifies the name of the share to delete
	// from the ShareList. This MUST be a nonempty null-terminated UTF-16 string; otherwise,
	// the server MUST fail the call with an ERROR_INVALID_PARAMETER error code.
	ShareDeleteEx(context.Context, *ShareDeleteExRequest, ...dcerpc.CallOption) (*ShareDeleteExResponse, error)

	// AlterContext alters the client context.
	AlterContext(context.Context, ...dcerpc.Option) error

	// Conn returns the client connection (unsafe)
	Conn() dcerpc.Conn
}

// ConnectionInfo0 structure represents CONNECTION_INFO_0 RPC structure.
//
// The CONNECTION_INFO_0 structure contains the identifier of a connection.
type ConnectionInfo0 struct {
	// coni0_id:  Specifies a connection identifier. For more information, see Abstract
	// Data Model (section 3.1.1).
	Coni0ID uint32 `idl:"name:coni0_id" json:"coni0_id"`
}

func (o *ConnectionInfo0) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ConnectionInfo0) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Coni0ID); err != nil {
		return err
	}
	return nil
}
func (o *ConnectionInfo0) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Coni0ID); err != nil {
		return err
	}
	return nil
}

// ConnectInfo0Container structure represents CONNECT_INFO_0_CONTAINER RPC structure.
//
// The CONNECT_INFO_0_CONTAINER structure contains a value that indicates the number
// of entries that the NetrConnectionEnum method returns and a pointer to the buffer
// that contains the entries.
type ConnectInfo0Container struct {
	// EntriesRead:  The number of entries returned by the method.
	EntriesRead uint32 `idl:"name:EntriesRead" json:"entries_read"`
	// Buffer:  A pointer to the CONNECTION_INFO_0 entries returned by the method.
	Buffer []*ConnectionInfo0 `idl:"name:Buffer;size_is:(EntriesRead)" json:"buffer"`
}

func (o *ConnectInfo0Container) xxx_PreparePayload(ctx context.Context) error {
	if o.Buffer != nil && o.EntriesRead == 0 {
		o.EntriesRead = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ConnectInfo0Container) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.EntriesRead); err != nil {
		return err
	}
	if o.Buffer != nil || o.EntriesRead > 0 {
		_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.EntriesRead)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Buffer {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Buffer[i1] != nil {
					if err := o.Buffer[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&ConnectionInfo0{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&ConnectionInfo0{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ConnectInfo0Container) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntriesRead); err != nil {
		return err
	}
	_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.EntriesRead > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.EntriesRead)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
		}
		o.Buffer = make([]*ConnectionInfo0, sizeInfo[0])
		for i1 := range o.Buffer {
			i1 := i1
			if o.Buffer[i1] == nil {
				o.Buffer[i1] = &ConnectionInfo0{}
			}
			if err := o.Buffer[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]*ConnectionInfo0) }
	if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
		return err
	}
	return nil
}

// ConnectionInfo1 structure represents CONNECTION_INFO_1 RPC structure.
//
// The CONNECTION_INFO_1 structure contains the identifier of a connection, the number
// of open files, the connection time, the number of users on the connection, and the
// type of connection.
type ConnectionInfo1 struct {
	// coni1_id:  Specifies a connection identifier.
	ID uint32 `idl:"name:coni1_id" json:"id"`
	// coni1_type:  Specifies the type of connection made from the local device name to
	// the shared resource. It MUST be one of the values listed in section 2.2.2.4.
	Type uint32 `idl:"name:coni1_type" json:"type"`
	// coni1_num_opens:  Specifies the number of files that are currently opened by using
	// the connection.
	NumOpens uint32 `idl:"name:coni1_num_opens" json:"num_opens"`
	// coni1_num_users:  Specifies the number of users on the connection.
	NumUsers uint32 `idl:"name:coni1_num_users" json:"num_users"`
	// coni1_time:  Specifies the number of seconds that the connection has been established.
	Time uint32 `idl:"name:coni1_time" json:"time"`
	// coni1_username:  A pointer to a null-terminated Unicode UTF-16 string that specifies
	// the name of the user that is associated with the connection.
	UserName string `idl:"name:coni1_username;string" json:"user_name"`
	// coni1_netname:  A pointer to a null-terminated Unicode UTF-16 Internet host name
	// or NetBIOS host name which is the computer name of the client. The value of this
	// member depends on which name was specified as the Qualifier parameter to the NetrConnectionEnum
	// (section 3.1.4.1) method. The name that is not specified in the Qualifier parameter
	// to NetrConnectionEnum MUST be returned in the coni1_netname field.
	NetworkName string `idl:"name:coni1_netname;string" json:"network_name"`
}

func (o *ConnectionInfo1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ConnectionInfo1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.ID); err != nil {
		return err
	}
	if err := w.WriteData(o.Type); err != nil {
		return err
	}
	if err := w.WriteData(o.NumOpens); err != nil {
		return err
	}
	if err := w.WriteData(o.NumUsers); err != nil {
		return err
	}
	if err := w.WriteData(o.Time); err != nil {
		return err
	}
	if o.UserName != "" {
		_ptr_coni1_username := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.UserName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.UserName, _ptr_coni1_username); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.NetworkName != "" {
		_ptr_coni1_netname := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.NetworkName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.NetworkName, _ptr_coni1_netname); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ConnectionInfo1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.ID); err != nil {
		return err
	}
	if err := w.ReadData(&o.Type); err != nil {
		return err
	}
	if err := w.ReadData(&o.NumOpens); err != nil {
		return err
	}
	if err := w.ReadData(&o.NumUsers); err != nil {
		return err
	}
	if err := w.ReadData(&o.Time); err != nil {
		return err
	}
	_ptr_coni1_username := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.UserName); err != nil {
			return err
		}
		return nil
	})
	_s_coni1_username := func(ptr interface{}) { o.UserName = *ptr.(*string) }
	if err := w.ReadPointer(&o.UserName, _s_coni1_username, _ptr_coni1_username); err != nil {
		return err
	}
	_ptr_coni1_netname := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.NetworkName); err != nil {
			return err
		}
		return nil
	})
	_s_coni1_netname := func(ptr interface{}) { o.NetworkName = *ptr.(*string) }
	if err := w.ReadPointer(&o.NetworkName, _s_coni1_netname, _ptr_coni1_netname); err != nil {
		return err
	}
	return nil
}

// ConnectInfo1Container structure represents CONNECT_INFO_1_CONTAINER RPC structure.
//
// The CONNECT_INFO_1_CONTAINER structure contains a value that indicates the number
// of entries that the NetrConnectionEnum method returns and a pointer to the buffer
// that contains the entries.
type ConnectInfo1Container struct {
	// EntriesRead:  The number of entries returned by the method.
	EntriesRead uint32 `idl:"name:EntriesRead" json:"entries_read"`
	// Buffer:  A pointer to the CONNECTION_INFO_1 entries returned by the method.
	Buffer []*ConnectionInfo1 `idl:"name:Buffer;size_is:(EntriesRead)" json:"buffer"`
}

func (o *ConnectInfo1Container) xxx_PreparePayload(ctx context.Context) error {
	if o.Buffer != nil && o.EntriesRead == 0 {
		o.EntriesRead = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ConnectInfo1Container) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.EntriesRead); err != nil {
		return err
	}
	if o.Buffer != nil || o.EntriesRead > 0 {
		_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.EntriesRead)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Buffer {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Buffer[i1] != nil {
					if err := o.Buffer[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&ConnectionInfo1{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&ConnectionInfo1{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ConnectInfo1Container) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntriesRead); err != nil {
		return err
	}
	_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.EntriesRead > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.EntriesRead)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
		}
		o.Buffer = make([]*ConnectionInfo1, sizeInfo[0])
		for i1 := range o.Buffer {
			i1 := i1
			if o.Buffer[i1] == nil {
				o.Buffer[i1] = &ConnectionInfo1{}
			}
			if err := o.Buffer[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]*ConnectionInfo1) }
	if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
		return err
	}
	return nil
}

// ConnectEnumUnion structure represents CONNECT_ENUM_UNION RPC union.
//
// The CONNECT_ENUM_UNION union contains information about a connection. It is used
// in the definition of the CONNECTION_ENUM_STRUCT structure.
type ConnectEnumUnion struct {
	// Types that are assignable to Value
	//
	// *ConnectEnumUnion_Level0
	// *ConnectEnumUnion_Level1
	Value is_ConnectEnumUnion `json:"value"`
}

func (o *ConnectEnumUnion) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *ConnectEnumUnion_Level0:
		if value != nil {
			return value.Level0
		}
	case *ConnectEnumUnion_Level1:
		if value != nil {
			return value.Level1
		}
	}
	return nil
}

type is_ConnectEnumUnion interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_ConnectEnumUnion()
}

func (o *ConnectEnumUnion) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *ConnectEnumUnion_Level0:
		return uint32(0)
	case *ConnectEnumUnion_Level1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *ConnectEnumUnion) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(0):
		_o, _ := o.Value.(*ConnectEnumUnion_Level0)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ConnectEnumUnion_Level0{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1):
		_o, _ := o.Value.(*ConnectEnumUnion_Level1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ConnectEnumUnion_Level1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *ConnectEnumUnion) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(0):
		o.Value = &ConnectEnumUnion_Level0{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1):
		o.Value = &ConnectEnumUnion_Level1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// ConnectEnumUnion_Level0 structure represents CONNECT_ENUM_UNION RPC union arm.
//
// It has following labels: 0
type ConnectEnumUnion_Level0 struct {
	// Level0:  A pointer to a structure containing information about a connection, as specified
	// in section 2.2.4.3.
	Level0 *ConnectInfo0Container `idl:"name:Level0" json:"level0"`
}

func (*ConnectEnumUnion_Level0) is_ConnectEnumUnion() {}

func (o *ConnectEnumUnion_Level0) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Level0 != nil {
		_ptr_Level0 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Level0 != nil {
				if err := o.Level0.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ConnectInfo0Container{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Level0, _ptr_Level0); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ConnectEnumUnion_Level0) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_Level0 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Level0 == nil {
			o.Level0 = &ConnectInfo0Container{}
		}
		if err := o.Level0.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_Level0 := func(ptr interface{}) { o.Level0 = *ptr.(**ConnectInfo0Container) }
	if err := w.ReadPointer(&o.Level0, _s_Level0, _ptr_Level0); err != nil {
		return err
	}
	return nil
}

// ConnectEnumUnion_Level1 structure represents CONNECT_ENUM_UNION RPC union arm.
//
// It has following labels: 1
type ConnectEnumUnion_Level1 struct {
	// Level1:  A pointer to a structure containing information about a connection, as specified
	// in section 2.2.4.4.
	Level1 *ConnectInfo1Container `idl:"name:Level1" json:"level1"`
}

func (*ConnectEnumUnion_Level1) is_ConnectEnumUnion() {}

func (o *ConnectEnumUnion_Level1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Level1 != nil {
		_ptr_Level1 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Level1 != nil {
				if err := o.Level1.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ConnectInfo1Container{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Level1, _ptr_Level1); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ConnectEnumUnion_Level1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_Level1 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Level1 == nil {
			o.Level1 = &ConnectInfo1Container{}
		}
		if err := o.Level1.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_Level1 := func(ptr interface{}) { o.Level1 = *ptr.(**ConnectInfo1Container) }
	if err := w.ReadPointer(&o.Level1, _s_Level1, _ptr_Level1); err != nil {
		return err
	}
	return nil
}

// ConnectEnum structure represents CONNECT_ENUM_STRUCT RPC structure.
//
// The CONNECT_ENUM_STRUCT structure specifies the information level that the client
// requests when invoking the NetrConnectionEnum (section 3.1.4.1) method and encapsulates
// the CONNECT_ENUM_UNION (section 2.2.3.1) union that receives the entries that are
// enumerated by the server.
type ConnectEnum struct {
	// Level:  Specifies the information level of the data. This parameter MUST have one
	// of the following values.
	//
	//	+-------+--------------------------+
	//	|       |                          |
	//	| VALUE |         MEANING          |
	//	|       |                          |
	//	+-------+--------------------------+
	//	+-------+--------------------------+
	//	|     0 | CONNECT_INFO_0_CONTAINER |
	//	+-------+--------------------------+
	//	|     1 | CONNECT_INFO_1_CONTAINER |
	//	+-------+--------------------------+
	Level uint32 `idl:"name:Level" json:"level"`
	// ConnectInfo:  Contains either a CONNECT_INFO_0_CONTAINER structure or a CONNECT_INFO_1_CONTAINER
	// structure depending on the value of the Level parameter. The enumerated elements
	// are returned in this member.
	ConnectInfo *ConnectEnumUnion `idl:"name:ConnectInfo;switch_is:Level" json:"connect_info"`
}

func (o *ConnectEnum) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ConnectEnum) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.Level); err != nil {
		return err
	}
	_swConnectInfo := uint32(o.Level)
	if o.ConnectInfo != nil {
		if err := o.ConnectInfo.MarshalUnionNDR(ctx, w, _swConnectInfo); err != nil {
			return err
		}
	} else {
		if err := (&ConnectEnumUnion{}).MarshalUnionNDR(ctx, w, _swConnectInfo); err != nil {
			return err
		}
	}
	return nil
}
func (o *ConnectEnum) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.Level); err != nil {
		return err
	}
	if o.ConnectInfo == nil {
		o.ConnectInfo = &ConnectEnumUnion{}
	}
	_swConnectInfo := uint32(o.Level)
	if err := o.ConnectInfo.UnmarshalUnionNDR(ctx, w, _swConnectInfo); err != nil {
		return err
	}
	return nil
}

// FileInfo2 structure represents FILE_INFO_2 RPC structure.
//
// The FILE_INFO_2 structure contains the identifier for a file, device, or pipe.
type FileInfo2 struct {
	// fi2_id:  Specifies a DWORD value that contains the identifier that is assigned to
	// the file, device, or pipe when it was opened. See section 3.1.1 for details.
	ID uint32 `idl:"name:fi2_id" json:"id"`
}

func (o *FileInfo2) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *FileInfo2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.ID); err != nil {
		return err
	}
	return nil
}
func (o *FileInfo2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.ID); err != nil {
		return err
	}
	return nil
}

// FileInfo2Container structure represents FILE_INFO_2_CONTAINER RPC structure.
//
// The FILE_INFO_2_CONTAINER structure contains a value that indicates the number of
// entries that the NetrFileEnum method returns and a pointer to the buffer that contains
// the entries.
type FileInfo2Container struct {
	// EntriesRead:  The number of entries returned by the method.
	EntriesRead uint32 `idl:"name:EntriesRead" json:"entries_read"`
	// Buffer:  A pointer to the FILE_INFO_2 entries returned by the method.
	Buffer []*FileInfo2 `idl:"name:Buffer;size_is:(EntriesRead)" json:"buffer"`
}

func (o *FileInfo2Container) xxx_PreparePayload(ctx context.Context) error {
	if o.Buffer != nil && o.EntriesRead == 0 {
		o.EntriesRead = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *FileInfo2Container) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.EntriesRead); err != nil {
		return err
	}
	if o.Buffer != nil || o.EntriesRead > 0 {
		_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.EntriesRead)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Buffer {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Buffer[i1] != nil {
					if err := o.Buffer[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&FileInfo2{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&FileInfo2{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *FileInfo2Container) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntriesRead); err != nil {
		return err
	}
	_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.EntriesRead > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.EntriesRead)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
		}
		o.Buffer = make([]*FileInfo2, sizeInfo[0])
		for i1 := range o.Buffer {
			i1 := i1
			if o.Buffer[i1] == nil {
				o.Buffer[i1] = &FileInfo2{}
			}
			if err := o.Buffer[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]*FileInfo2) }
	if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
		return err
	}
	return nil
}

// FileInfo3 structure represents FILE_INFO_3 RPC structure.
//
// The FILE_INFO_3 structure contains the identifier and other pertinent information
// about files, devices, and pipes.
type FileInfo3 struct {
	// fi3_id:  Specifies a DWORD value that contains the identifier that is assigned to
	// the file, device, or pipe when it was opened. See section 3.1.1 for details.
	ID uint32 `idl:"name:fi3_id" json:"id"`
	// fi3_permissions:  Specifies a DWORD value that contains the access permissions that
	// are associated with the opening application. This member MUST be a combination of
	// one or more of the following values.
	//
	//	+-----------------------------+----------------------------------------------------------------------------------+
	//	|                             |                                                                                  |
	//	|            VALUE            |                                     MEANING                                      |
	//	|                             |                                                                                  |
	//	+-----------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------+----------------------------------------------------------------------------------+
	//	| PERM_FILE_READ 0x00000001   | Permission to read a resource, and, by default, execute the resource.            |
	//	+-----------------------------+----------------------------------------------------------------------------------+
	//	| PERM_FILE_WRITE 0x00000002  | Permission to write to a resource.                                               |
	//	+-----------------------------+----------------------------------------------------------------------------------+
	//	| PERM_FILE_CREATE 0x00000004 | Permission to create a resource; data can be written when creating the resource. |
	//	+-----------------------------+----------------------------------------------------------------------------------+
	//	| ACCESS_EXEC 0x00000008      | Permission to execute a resource.                                                |
	//	+-----------------------------+----------------------------------------------------------------------------------+
	//	| ACCESS_DELETE 0x00000010    | Permission to delete a resource.                                                 |
	//	+-----------------------------+----------------------------------------------------------------------------------+
	//	| ACCESS_ATRIB 0x00000020     | Permission to modify the attributes of a resource.                               |
	//	+-----------------------------+----------------------------------------------------------------------------------+
	//	| ACCESS_PERM 0x00000040      | Permission to modify the permissions assigned to a resource for a user or        |
	//	|                             | application.                                                                     |
	//	+-----------------------------+----------------------------------------------------------------------------------+
	Permissions uint32 `idl:"name:fi3_permissions" json:"permissions"`
	// fi3_num_locks:  Specifies a DWORD value that contains the number of file locks on
	// the file, device, or pipe.
	NumLocks uint32 `idl:"name:fi3_num_locks" json:"num_locks"`
	// fi3_pathname:  A pointer to a string that specifies the path of the opened file,
	// device, or pipe.
	PathName string `idl:"name:fi3_pathname;string" json:"path_name"`
	// fi3_username:  A pointer to a string that specifies which user opened the file, device,
	// or pipe.
	UserName string `idl:"name:fi3_username;string" json:"user_name"`
}

func (o *FileInfo3) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *FileInfo3) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.ID); err != nil {
		return err
	}
	if err := w.WriteData(o.Permissions); err != nil {
		return err
	}
	if err := w.WriteData(o.NumLocks); err != nil {
		return err
	}
	if o.PathName != "" {
		_ptr_fi3_pathname := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.PathName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.PathName, _ptr_fi3_pathname); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.UserName != "" {
		_ptr_fi3_username := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.UserName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.UserName, _ptr_fi3_username); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *FileInfo3) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.ID); err != nil {
		return err
	}
	if err := w.ReadData(&o.Permissions); err != nil {
		return err
	}
	if err := w.ReadData(&o.NumLocks); err != nil {
		return err
	}
	_ptr_fi3_pathname := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.PathName); err != nil {
			return err
		}
		return nil
	})
	_s_fi3_pathname := func(ptr interface{}) { o.PathName = *ptr.(*string) }
	if err := w.ReadPointer(&o.PathName, _s_fi3_pathname, _ptr_fi3_pathname); err != nil {
		return err
	}
	_ptr_fi3_username := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.UserName); err != nil {
			return err
		}
		return nil
	})
	_s_fi3_username := func(ptr interface{}) { o.UserName = *ptr.(*string) }
	if err := w.ReadPointer(&o.UserName, _s_fi3_username, _ptr_fi3_username); err != nil {
		return err
	}
	return nil
}

// FileInfo3Container structure represents FILE_INFO_3_CONTAINER RPC structure.
//
// The FILE_INFO_3_CONTAINER structure contains a value that indicates the number of
// entries that the NetrFileEnum method returns and a pointer to the buffer that contains
// the entries.
type FileInfo3Container struct {
	// EntriesRead:  The number of entries returned by the method.
	EntriesRead uint32 `idl:"name:EntriesRead" json:"entries_read"`
	// Buffer:  A pointer to the FILE_INFO_3 entries returned by the method.
	Buffer []*FileInfo3 `idl:"name:Buffer;size_is:(EntriesRead)" json:"buffer"`
}

func (o *FileInfo3Container) xxx_PreparePayload(ctx context.Context) error {
	if o.Buffer != nil && o.EntriesRead == 0 {
		o.EntriesRead = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *FileInfo3Container) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.EntriesRead); err != nil {
		return err
	}
	if o.Buffer != nil || o.EntriesRead > 0 {
		_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.EntriesRead)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Buffer {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Buffer[i1] != nil {
					if err := o.Buffer[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&FileInfo3{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&FileInfo3{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *FileInfo3Container) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntriesRead); err != nil {
		return err
	}
	_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.EntriesRead > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.EntriesRead)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
		}
		o.Buffer = make([]*FileInfo3, sizeInfo[0])
		for i1 := range o.Buffer {
			i1 := i1
			if o.Buffer[i1] == nil {
				o.Buffer[i1] = &FileInfo3{}
			}
			if err := o.Buffer[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]*FileInfo3) }
	if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
		return err
	}
	return nil
}

// FileEnumUnion structure represents FILE_ENUM_UNION RPC union.
//
// The FILE_ENUM_UNION union contains information about files, devices, and pipes. It
// is used in the definition of the FILE_ENUM_STRUCT structure.
type FileEnumUnion struct {
	// Types that are assignable to Value
	//
	// *FileEnumUnion_Level2
	// *FileEnumUnion_Level3
	Value is_FileEnumUnion `json:"value"`
}

func (o *FileEnumUnion) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *FileEnumUnion_Level2:
		if value != nil {
			return value.Level2
		}
	case *FileEnumUnion_Level3:
		if value != nil {
			return value.Level3
		}
	}
	return nil
}

type is_FileEnumUnion interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_FileEnumUnion()
}

func (o *FileEnumUnion) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *FileEnumUnion_Level2:
		return uint32(2)
	case *FileEnumUnion_Level3:
		return uint32(3)
	}
	return uint32(0)
}

func (o *FileEnumUnion) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(2):
		_o, _ := o.Value.(*FileEnumUnion_Level2)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&FileEnumUnion_Level2{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(3):
		_o, _ := o.Value.(*FileEnumUnion_Level3)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&FileEnumUnion_Level3{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *FileEnumUnion) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(2):
		o.Value = &FileEnumUnion_Level2{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(3):
		o.Value = &FileEnumUnion_Level3{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// FileEnumUnion_Level2 structure represents FILE_ENUM_UNION RPC union arm.
//
// It has following labels: 2
type FileEnumUnion_Level2 struct {
	// Level2:  A pointer to a structure containing information about a file, device or
	// pipe, as specified in section 2.2.4.8.
	Level2 *FileInfo2Container `idl:"name:Level2" json:"level2"`
}

func (*FileEnumUnion_Level2) is_FileEnumUnion() {}

func (o *FileEnumUnion_Level2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Level2 != nil {
		_ptr_Level2 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Level2 != nil {
				if err := o.Level2.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&FileInfo2Container{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Level2, _ptr_Level2); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *FileEnumUnion_Level2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_Level2 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Level2 == nil {
			o.Level2 = &FileInfo2Container{}
		}
		if err := o.Level2.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_Level2 := func(ptr interface{}) { o.Level2 = *ptr.(**FileInfo2Container) }
	if err := w.ReadPointer(&o.Level2, _s_Level2, _ptr_Level2); err != nil {
		return err
	}
	return nil
}

// FileEnumUnion_Level3 structure represents FILE_ENUM_UNION RPC union arm.
//
// It has following labels: 3
type FileEnumUnion_Level3 struct {
	// Level3:  A pointer to a structure containing information about a file, device or
	// pipe, as specified in section 2.2.4.9.
	Level3 *FileInfo3Container `idl:"name:Level3" json:"level3"`
}

func (*FileEnumUnion_Level3) is_FileEnumUnion() {}

func (o *FileEnumUnion_Level3) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Level3 != nil {
		_ptr_Level3 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Level3 != nil {
				if err := o.Level3.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&FileInfo3Container{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Level3, _ptr_Level3); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *FileEnumUnion_Level3) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_Level3 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Level3 == nil {
			o.Level3 = &FileInfo3Container{}
		}
		if err := o.Level3.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_Level3 := func(ptr interface{}) { o.Level3 = *ptr.(**FileInfo3Container) }
	if err := w.ReadPointer(&o.Level3, _s_Level3, _ptr_Level3); err != nil {
		return err
	}
	return nil
}

// FileEnum structure represents FILE_ENUM_STRUCT RPC structure.
//
// The FILE_ENUM_STRUCT structure specifies the information level that the client requests
// in the NetrFileEnum method and encapsulates the FILE_ENUM_UNION union that receives
// the entries that are enumerated by the server.
type FileEnum struct {
	// Level:  Specifies the information level of the data. This parameter MUST have one
	// of the following values.
	//
	//	+-------+-----------------------+
	//	|       |                       |
	//	| VALUE |        MEANING        |
	//	|       |                       |
	//	+-------+-----------------------+
	//	+-------+-----------------------+
	//	|     2 | FILE_INFO_2_CONTAINER |
	//	+-------+-----------------------+
	//	|     3 | FILE_INFO_3_CONTAINER |
	//	+-------+-----------------------+
	Level uint32 `idl:"name:Level" json:"level"`
	// FileInfo:  Contains a file info container structure whose type is determined by the
	// Level parameter as shown in the preceding table. The enumerated elements are returned
	// in this member.
	FileInfo *FileEnumUnion `idl:"name:FileInfo;switch_is:Level" json:"file_info"`
}

func (o *FileEnum) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *FileEnum) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.Level); err != nil {
		return err
	}
	_swFileInfo := uint32(o.Level)
	if o.FileInfo != nil {
		if err := o.FileInfo.MarshalUnionNDR(ctx, w, _swFileInfo); err != nil {
			return err
		}
	} else {
		if err := (&FileEnumUnion{}).MarshalUnionNDR(ctx, w, _swFileInfo); err != nil {
			return err
		}
	}
	return nil
}
func (o *FileEnum) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.Level); err != nil {
		return err
	}
	if o.FileInfo == nil {
		o.FileInfo = &FileEnumUnion{}
	}
	_swFileInfo := uint32(o.Level)
	if err := o.FileInfo.UnmarshalUnionNDR(ctx, w, _swFileInfo); err != nil {
		return err
	}
	return nil
}

// FileInfo structure represents FILE_INFO RPC union.
//
// The FILE_INFO union contains information about a file, device, or pipe. This union
// is used by the NetrFileGetInfo method.
type FileInfo struct {
	// Types that are assignable to Value
	//
	// *FileInfo_2
	// *FileInfo_3
	Value is_FileInfo `json:"value"`
}

func (o *FileInfo) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *FileInfo_2:
		if value != nil {
			return value.FileInfo2
		}
	case *FileInfo_3:
		if value != nil {
			return value.FileInfo3
		}
	}
	return nil
}

type is_FileInfo interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_FileInfo()
}

func (o *FileInfo) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *FileInfo_2:
		return uint32(2)
	case *FileInfo_3:
		return uint32(3)
	}
	return uint32(0)
}

func (o *FileInfo) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(2):
		_o, _ := o.Value.(*FileInfo_2)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&FileInfo_2{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(3):
		_o, _ := o.Value.(*FileInfo_3)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&FileInfo_3{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *FileInfo) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(2):
		o.Value = &FileInfo_2{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(3):
		o.Value = &FileInfo_3{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// FileInfo_2 structure represents FILE_INFO RPC union arm.
//
// It has following labels: 2
type FileInfo_2 struct {
	// FileInfo2:  A pointer to a structure that contains information about a file, device,
	// or pipe. For more details, see FILE_INFO_2 (section 2.2.4.6).
	FileInfo2 *FileInfo2 `idl:"name:FileInfo2" json:"file_info2"`
}

func (*FileInfo_2) is_FileInfo() {}

func (o *FileInfo_2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.FileInfo2 != nil {
		_ptr_FileInfo2 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.FileInfo2 != nil {
				if err := o.FileInfo2.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&FileInfo2{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.FileInfo2, _ptr_FileInfo2); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *FileInfo_2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_FileInfo2 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.FileInfo2 == nil {
			o.FileInfo2 = &FileInfo2{}
		}
		if err := o.FileInfo2.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_FileInfo2 := func(ptr interface{}) { o.FileInfo2 = *ptr.(**FileInfo2) }
	if err := w.ReadPointer(&o.FileInfo2, _s_FileInfo2, _ptr_FileInfo2); err != nil {
		return err
	}
	return nil
}

// FileInfo_3 structure represents FILE_INFO RPC union arm.
//
// It has following labels: 3
type FileInfo_3 struct {
	// FileInfo3:  A pointer to a structure that contains information about a file, device,
	// or pipe. For more details, see FILE_INFO_3 (section 2.2.4.7).
	FileInfo3 *FileInfo3 `idl:"name:FileInfo3" json:"file_info3"`
}

func (*FileInfo_3) is_FileInfo() {}

func (o *FileInfo_3) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.FileInfo3 != nil {
		_ptr_FileInfo3 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.FileInfo3 != nil {
				if err := o.FileInfo3.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&FileInfo3{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.FileInfo3, _ptr_FileInfo3); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *FileInfo_3) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_FileInfo3 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.FileInfo3 == nil {
			o.FileInfo3 = &FileInfo3{}
		}
		if err := o.FileInfo3.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_FileInfo3 := func(ptr interface{}) { o.FileInfo3 = *ptr.(**FileInfo3) }
	if err := w.ReadPointer(&o.FileInfo3, _s_FileInfo3, _ptr_FileInfo3); err != nil {
		return err
	}
	return nil
}

// SessionInfo0 structure represents SESSION_INFO_0 RPC structure.
//
// The SESSION_INFO_0 structure contains the name of the computer that established the
// session.
type SessionInfo0 struct {
	// sesi0_cname:  A pointer to a null-terminated Unicode UTF-16 Internet host name or
	// NetBIOS host name of the computer that established the session.
	ClientName string `idl:"name:sesi0_cname;string" json:"client_name"`
}

func (o *SessionInfo0) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *SessionInfo0) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(6); err != nil {
		return err
	}
	if o.ClientName != "" {
		_ptr_sesi0_cname := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.ClientName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ClientName, _ptr_sesi0_cname); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *SessionInfo0) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(6); err != nil {
		return err
	}
	_ptr_sesi0_cname := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.ClientName); err != nil {
			return err
		}
		return nil
	})
	_s_sesi0_cname := func(ptr interface{}) { o.ClientName = *ptr.(*string) }
	if err := w.ReadPointer(&o.ClientName, _s_sesi0_cname, _ptr_sesi0_cname); err != nil {
		return err
	}
	return nil
}

// SessionInfo0Container structure represents SESSION_INFO_0_CONTAINER RPC structure.
//
// The SESSION_INFO_0_CONTAINER structure contains a value that indicates the number
// of entries that the NetrSessionEnum method returns and a pointer to the buffer that
// contains the entries.
type SessionInfo0Container struct {
	// EntriesRead:  The number of entries returned by the method.
	EntriesRead uint32 `idl:"name:EntriesRead" json:"entries_read"`
	// Buffer:  A pointer to the SESSION_INFO_0 entries returned by the method.
	Buffer []*SessionInfo0 `idl:"name:Buffer;size_is:(EntriesRead)" json:"buffer"`
}

func (o *SessionInfo0Container) xxx_PreparePayload(ctx context.Context) error {
	if o.Buffer != nil && o.EntriesRead == 0 {
		o.EntriesRead = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *SessionInfo0Container) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.EntriesRead); err != nil {
		return err
	}
	if o.Buffer != nil || o.EntriesRead > 0 {
		_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.EntriesRead)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Buffer {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Buffer[i1] != nil {
					if err := o.Buffer[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&SessionInfo0{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&SessionInfo0{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *SessionInfo0Container) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntriesRead); err != nil {
		return err
	}
	_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.EntriesRead > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.EntriesRead)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
		}
		o.Buffer = make([]*SessionInfo0, sizeInfo[0])
		for i1 := range o.Buffer {
			i1 := i1
			if o.Buffer[i1] == nil {
				o.Buffer[i1] = &SessionInfo0{}
			}
			if err := o.Buffer[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]*SessionInfo0) }
	if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
		return err
	}
	return nil
}

// SessionInfo1 structure represents SESSION_INFO_1 RPC structure.
//
// The SESSION_INFO_1 structure contains information about the session, including the
// name of the computer and user; open files, pipes, and devices that are on the computer;
// session active and idle times; and how the user established the session.
type SessionInfo1 struct {
	// sesi1_cname:  A pointer to a null-terminated Unicode UTF-16 Internet host name or
	// NetBIOS host name of the computer that established the session.
	ClientName string `idl:"name:sesi1_cname;string" json:"client_name"`
	// sesi1_username:  A pointer to a null-terminated Unicode UTF-16 string that specifies
	// the name of the user who established the session.
	UserName string `idl:"name:sesi1_username;string" json:"user_name"`
	// sesi1_num_opens:  Specifies a DWORD value that contains the number of files, devices,
	// and pipes that were opened during the session.
	NumOpens uint32 `idl:"name:sesi1_num_opens" json:"num_opens"`
	// sesi1_time:  Specifies a DWORD value that contains the number of seconds since the
	// session was created.
	Time uint32 `idl:"name:sesi1_time" json:"time"`
	// sesi1_idle_time:  Specifies a DWORD value that contains the number of seconds the
	// session has been idle.
	IdleTime uint32 `idl:"name:sesi1_idle_time" json:"idle_time"`
	// sesi1_user_flags:  Specifies a DWORD value that specifies how the user established
	// the session. This member MUST be a combination of one or more of the values that
	// are defined in 2.2.2.3.
	UserFlags uint32 `idl:"name:sesi1_user_flags" json:"user_flags"`
}

func (o *SessionInfo1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *SessionInfo1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.ClientName != "" {
		_ptr_sesi1_cname := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.ClientName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ClientName, _ptr_sesi1_cname); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.UserName != "" {
		_ptr_sesi1_username := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.UserName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.UserName, _ptr_sesi1_username); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.NumOpens); err != nil {
		return err
	}
	if err := w.WriteData(o.Time); err != nil {
		return err
	}
	if err := w.WriteData(o.IdleTime); err != nil {
		return err
	}
	if err := w.WriteData(o.UserFlags); err != nil {
		return err
	}
	return nil
}
func (o *SessionInfo1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_sesi1_cname := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.ClientName); err != nil {
			return err
		}
		return nil
	})
	_s_sesi1_cname := func(ptr interface{}) { o.ClientName = *ptr.(*string) }
	if err := w.ReadPointer(&o.ClientName, _s_sesi1_cname, _ptr_sesi1_cname); err != nil {
		return err
	}
	_ptr_sesi1_username := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.UserName); err != nil {
			return err
		}
		return nil
	})
	_s_sesi1_username := func(ptr interface{}) { o.UserName = *ptr.(*string) }
	if err := w.ReadPointer(&o.UserName, _s_sesi1_username, _ptr_sesi1_username); err != nil {
		return err
	}
	if err := w.ReadData(&o.NumOpens); err != nil {
		return err
	}
	if err := w.ReadData(&o.Time); err != nil {
		return err
	}
	if err := w.ReadData(&o.IdleTime); err != nil {
		return err
	}
	if err := w.ReadData(&o.UserFlags); err != nil {
		return err
	}
	return nil
}

// SessionInfo1Container structure represents SESSION_INFO_1_CONTAINER RPC structure.
//
// The SESSION_INFO_1_CONTAINER structure contains a value that indicates the number
// of entries that the NetrSessionEnum method returns and a pointer to the buffer that
// contains the entries.
type SessionInfo1Container struct {
	// EntriesRead:  The number of entries returned by the method.
	EntriesRead uint32 `idl:"name:EntriesRead" json:"entries_read"`
	// Buffer:  A pointer to the SESSION_INFO_1 entries returned by the method.
	Buffer []*SessionInfo1 `idl:"name:Buffer;size_is:(EntriesRead)" json:"buffer"`
}

func (o *SessionInfo1Container) xxx_PreparePayload(ctx context.Context) error {
	if o.Buffer != nil && o.EntriesRead == 0 {
		o.EntriesRead = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *SessionInfo1Container) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.EntriesRead); err != nil {
		return err
	}
	if o.Buffer != nil || o.EntriesRead > 0 {
		_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.EntriesRead)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Buffer {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Buffer[i1] != nil {
					if err := o.Buffer[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&SessionInfo1{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&SessionInfo1{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *SessionInfo1Container) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntriesRead); err != nil {
		return err
	}
	_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.EntriesRead > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.EntriesRead)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
		}
		o.Buffer = make([]*SessionInfo1, sizeInfo[0])
		for i1 := range o.Buffer {
			i1 := i1
			if o.Buffer[i1] == nil {
				o.Buffer[i1] = &SessionInfo1{}
			}
			if err := o.Buffer[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]*SessionInfo1) }
	if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
		return err
	}
	return nil
}

// SessionInfo2 structure represents SESSION_INFO_2 RPC structure.
//
// The SESSION_INFO_2 structure contains information about the session, including the
// name of the computer; name of the user; open files, pipes, and devices that are on
// the computer; session active and idle times; how the user established the session;
// and the type of client that established the session.
type SessionInfo2 struct {
	// sesi2_cname:  A pointer to a null-terminated Unicode UTF-16 Internet host name or
	// NetBIOS host name of the computer that established the session.
	ClientName string `idl:"name:sesi2_cname;string" json:"client_name"`
	// sesi2_username:  A pointer to a null-terminated Unicode UTF-16 string that specifies
	// the name of the user who established the session.
	UserName string `idl:"name:sesi2_username;string" json:"user_name"`
	// sesi2_num_opens:  Specifies a DWORD value that contains the number of files, devices,
	// and pipes that were opened during the session.
	NumOpens uint32 `idl:"name:sesi2_num_opens" json:"num_opens"`
	// sesi2_time:  Specifies a DWORD value that contains the number of seconds the session
	// has been active.
	Time uint32 `idl:"name:sesi2_time" json:"time"`
	// sesi2_idle_time:  Specifies a DWORD value that contains the number of seconds the
	// session has been idle.
	IdleTime uint32 `idl:"name:sesi2_idle_time" json:"idle_time"`
	// sesi2_user_flags:  Specifies a DWORD value that describes how the user established
	// the session. This member MUST be a combination of one or more of the values that
	// are defined in section 2.2.2.3.
	UserFlags uint32 `idl:"name:sesi2_user_flags" json:"user_flags"`
	// sesi2_cltype_name:  A pointer to a null-terminated Unicode UTF-16 string that specifies
	// the type of client that established the session. The server simply stores this string,
	// as specified in section 2.2.2.1, and its value does not modify the behavior of the
	// protocol. <9>
	ClientTypeName string `idl:"name:sesi2_cltype_name;string" json:"client_type_name"`
}

func (o *SessionInfo2) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *SessionInfo2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.ClientName != "" {
		_ptr_sesi2_cname := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.ClientName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ClientName, _ptr_sesi2_cname); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.UserName != "" {
		_ptr_sesi2_username := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.UserName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.UserName, _ptr_sesi2_username); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.NumOpens); err != nil {
		return err
	}
	if err := w.WriteData(o.Time); err != nil {
		return err
	}
	if err := w.WriteData(o.IdleTime); err != nil {
		return err
	}
	if err := w.WriteData(o.UserFlags); err != nil {
		return err
	}
	if o.ClientTypeName != "" {
		_ptr_sesi2_cltype_name := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.ClientTypeName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ClientTypeName, _ptr_sesi2_cltype_name); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *SessionInfo2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_sesi2_cname := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.ClientName); err != nil {
			return err
		}
		return nil
	})
	_s_sesi2_cname := func(ptr interface{}) { o.ClientName = *ptr.(*string) }
	if err := w.ReadPointer(&o.ClientName, _s_sesi2_cname, _ptr_sesi2_cname); err != nil {
		return err
	}
	_ptr_sesi2_username := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.UserName); err != nil {
			return err
		}
		return nil
	})
	_s_sesi2_username := func(ptr interface{}) { o.UserName = *ptr.(*string) }
	if err := w.ReadPointer(&o.UserName, _s_sesi2_username, _ptr_sesi2_username); err != nil {
		return err
	}
	if err := w.ReadData(&o.NumOpens); err != nil {
		return err
	}
	if err := w.ReadData(&o.Time); err != nil {
		return err
	}
	if err := w.ReadData(&o.IdleTime); err != nil {
		return err
	}
	if err := w.ReadData(&o.UserFlags); err != nil {
		return err
	}
	_ptr_sesi2_cltype_name := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.ClientTypeName); err != nil {
			return err
		}
		return nil
	})
	_s_sesi2_cltype_name := func(ptr interface{}) { o.ClientTypeName = *ptr.(*string) }
	if err := w.ReadPointer(&o.ClientTypeName, _s_sesi2_cltype_name, _ptr_sesi2_cltype_name); err != nil {
		return err
	}
	return nil
}

// SessionInfo2Container structure represents SESSION_INFO_2_CONTAINER RPC structure.
//
// The SESSION_INFO_2_CONTAINER structure contains a value that indicates the number
// of entries that the NetrSessionEnum method returns and a pointer to the buffer that
// contains the entries.
type SessionInfo2Container struct {
	// EntriesRead:  The number of entries returned by the method.
	EntriesRead uint32 `idl:"name:EntriesRead" json:"entries_read"`
	// Buffer:  A pointer to the SESSION_INFO_2 entries returned by the method.
	Buffer []*SessionInfo2 `idl:"name:Buffer;size_is:(EntriesRead)" json:"buffer"`
}

func (o *SessionInfo2Container) xxx_PreparePayload(ctx context.Context) error {
	if o.Buffer != nil && o.EntriesRead == 0 {
		o.EntriesRead = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *SessionInfo2Container) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.EntriesRead); err != nil {
		return err
	}
	if o.Buffer != nil || o.EntriesRead > 0 {
		_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.EntriesRead)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Buffer {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Buffer[i1] != nil {
					if err := o.Buffer[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&SessionInfo2{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&SessionInfo2{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *SessionInfo2Container) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntriesRead); err != nil {
		return err
	}
	_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.EntriesRead > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.EntriesRead)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
		}
		o.Buffer = make([]*SessionInfo2, sizeInfo[0])
		for i1 := range o.Buffer {
			i1 := i1
			if o.Buffer[i1] == nil {
				o.Buffer[i1] = &SessionInfo2{}
			}
			if err := o.Buffer[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]*SessionInfo2) }
	if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
		return err
	}
	return nil
}

// SessionInfo10 structure represents SESSION_INFO_10 RPC structure.
//
// The SESSION_INFO_10 structure contains information about the session, including the
// name of the computer, the name of the user, and the active and idle times for the
// session.
type SessionInfo10 struct {
	// sesi10_cname:  A pointer to a null-terminated Unicode UTF-16 Internet host name or
	// NetBIOS host name of the computer that established the session.
	ClientName string `idl:"name:sesi10_cname;string" json:"client_name"`
	// sesi10_username:  A pointer to a null-terminated Unicode UTF-16 string specifying
	// the name of the user who established the session.
	UserName string `idl:"name:sesi10_username;string" json:"user_name"`
	// sesi10_time:  Specifies the number of seconds the session has been active.
	Time uint32 `idl:"name:sesi10_time" json:"time"`
	// sesi10_idle_time:  Specifies the number of seconds the session has been idle.
	IdleTime uint32 `idl:"name:sesi10_idle_time" json:"idle_time"`
}

func (o *SessionInfo10) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *SessionInfo10) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.ClientName != "" {
		_ptr_sesi10_cname := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.ClientName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ClientName, _ptr_sesi10_cname); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.UserName != "" {
		_ptr_sesi10_username := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.UserName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.UserName, _ptr_sesi10_username); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Time); err != nil {
		return err
	}
	if err := w.WriteData(o.IdleTime); err != nil {
		return err
	}
	return nil
}
func (o *SessionInfo10) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_sesi10_cname := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.ClientName); err != nil {
			return err
		}
		return nil
	})
	_s_sesi10_cname := func(ptr interface{}) { o.ClientName = *ptr.(*string) }
	if err := w.ReadPointer(&o.ClientName, _s_sesi10_cname, _ptr_sesi10_cname); err != nil {
		return err
	}
	_ptr_sesi10_username := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.UserName); err != nil {
			return err
		}
		return nil
	})
	_s_sesi10_username := func(ptr interface{}) { o.UserName = *ptr.(*string) }
	if err := w.ReadPointer(&o.UserName, _s_sesi10_username, _ptr_sesi10_username); err != nil {
		return err
	}
	if err := w.ReadData(&o.Time); err != nil {
		return err
	}
	if err := w.ReadData(&o.IdleTime); err != nil {
		return err
	}
	return nil
}

// SessionInfo10Container structure represents SESSION_INFO_10_CONTAINER RPC structure.
//
// The SESSION_INFO_10_CONTAINER structure contains a value that indicates the number
// of entries that the NetrSessionEnum method returns and a pointer to the buffer that
// contains the entries.
type SessionInfo10Container struct {
	// EntriesRead:  The number of entries returned by the method.
	EntriesRead uint32 `idl:"name:EntriesRead" json:"entries_read"`
	// Buffer:  A pointer to the SESSION_INFO_10 entries returned by the method.
	Buffer []*SessionInfo10 `idl:"name:Buffer;size_is:(EntriesRead)" json:"buffer"`
}

func (o *SessionInfo10Container) xxx_PreparePayload(ctx context.Context) error {
	if o.Buffer != nil && o.EntriesRead == 0 {
		o.EntriesRead = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *SessionInfo10Container) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.EntriesRead); err != nil {
		return err
	}
	if o.Buffer != nil || o.EntriesRead > 0 {
		_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.EntriesRead)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Buffer {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Buffer[i1] != nil {
					if err := o.Buffer[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&SessionInfo10{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&SessionInfo10{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *SessionInfo10Container) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntriesRead); err != nil {
		return err
	}
	_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.EntriesRead > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.EntriesRead)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
		}
		o.Buffer = make([]*SessionInfo10, sizeInfo[0])
		for i1 := range o.Buffer {
			i1 := i1
			if o.Buffer[i1] == nil {
				o.Buffer[i1] = &SessionInfo10{}
			}
			if err := o.Buffer[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]*SessionInfo10) }
	if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
		return err
	}
	return nil
}

// SessionInfo502 structure represents SESSION_INFO_502 RPC structure.
//
// The SESSION_INFO_502 structure contains information about the session, including
// the name of the computer; the name of the user; open files, pipes, and devices that
// are on the computer; the client type; session active and idle times; how the user
// established the session; and the name of the transport that the client is using.
type SessionInfo502 struct {
	// sesi502_cname:  A pointer to a null-terminated Unicode UTF-16 Internet host name
	// or NetBIOS host name of the computer that established the session.
	ClientName string `idl:"name:sesi502_cname;string" json:"client_name"`
	// sesi502_username:  A pointer to a null-terminated Unicode UTF-16 string that specifies
	// the name of the user who established the session.
	UserName string `idl:"name:sesi502_username;string" json:"user_name"`
	// sesi502_num_opens:  Specifies the number of files, devices, and pipes that were opened
	// during the session.
	NumOpens uint32 `idl:"name:sesi502_num_opens" json:"num_opens"`
	// sesi502_time:  Specifies the number of seconds the session has been active.
	Time uint32 `idl:"name:sesi502_time" json:"time"`
	// sesi502_idle_time:  Specifies the number of seconds the session has been idle.
	IdleTime uint32 `idl:"name:sesi502_idle_time" json:"idle_time"`
	// sesi502_user_flags:  Specifies a value that describes how the user established the
	// session. This member MUST be a combination of one or more of the values that are
	// listed in section 2.2.2.3.
	UserFlags uint32 `idl:"name:sesi502_user_flags" json:"user_flags"`
	// sesi502_cltype_name:  A pointer to a null-terminated Unicode UTF-16 string that specifies
	// the type of client that established the session. The server simply stores this string,
	// as specified in section 2.2.2.1, and its value does not modify the behavior of the
	// protocol.<10>
	ClientTypeName string `idl:"name:sesi502_cltype_name;string" json:"client_type_name"`
	// sesi502_transport:  Specifies the name of the transport that the client is using
	// to communicate with the server.
	Transport string `idl:"name:sesi502_transport;string" json:"transport"`
}

func (o *SessionInfo502) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *SessionInfo502) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.ClientName != "" {
		_ptr_sesi502_cname := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.ClientName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ClientName, _ptr_sesi502_cname); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.UserName != "" {
		_ptr_sesi502_username := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.UserName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.UserName, _ptr_sesi502_username); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.NumOpens); err != nil {
		return err
	}
	if err := w.WriteData(o.Time); err != nil {
		return err
	}
	if err := w.WriteData(o.IdleTime); err != nil {
		return err
	}
	if err := w.WriteData(o.UserFlags); err != nil {
		return err
	}
	if o.ClientTypeName != "" {
		_ptr_sesi502_cltype_name := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.ClientTypeName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ClientTypeName, _ptr_sesi502_cltype_name); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.Transport != "" {
		_ptr_sesi502_transport := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Transport); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Transport, _ptr_sesi502_transport); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *SessionInfo502) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_sesi502_cname := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.ClientName); err != nil {
			return err
		}
		return nil
	})
	_s_sesi502_cname := func(ptr interface{}) { o.ClientName = *ptr.(*string) }
	if err := w.ReadPointer(&o.ClientName, _s_sesi502_cname, _ptr_sesi502_cname); err != nil {
		return err
	}
	_ptr_sesi502_username := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.UserName); err != nil {
			return err
		}
		return nil
	})
	_s_sesi502_username := func(ptr interface{}) { o.UserName = *ptr.(*string) }
	if err := w.ReadPointer(&o.UserName, _s_sesi502_username, _ptr_sesi502_username); err != nil {
		return err
	}
	if err := w.ReadData(&o.NumOpens); err != nil {
		return err
	}
	if err := w.ReadData(&o.Time); err != nil {
		return err
	}
	if err := w.ReadData(&o.IdleTime); err != nil {
		return err
	}
	if err := w.ReadData(&o.UserFlags); err != nil {
		return err
	}
	_ptr_sesi502_cltype_name := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.ClientTypeName); err != nil {
			return err
		}
		return nil
	})
	_s_sesi502_cltype_name := func(ptr interface{}) { o.ClientTypeName = *ptr.(*string) }
	if err := w.ReadPointer(&o.ClientTypeName, _s_sesi502_cltype_name, _ptr_sesi502_cltype_name); err != nil {
		return err
	}
	_ptr_sesi502_transport := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Transport); err != nil {
			return err
		}
		return nil
	})
	_s_sesi502_transport := func(ptr interface{}) { o.Transport = *ptr.(*string) }
	if err := w.ReadPointer(&o.Transport, _s_sesi502_transport, _ptr_sesi502_transport); err != nil {
		return err
	}
	return nil
}

// SessionInfo502Container structure represents SESSION_INFO_502_CONTAINER RPC structure.
//
// The SESSION_INFO_502_CONTAINER structure contains a value that indicates the number
// of entries that the NetrSessionEnum method returns and a pointer to the buffer that
// contains the entries.
type SessionInfo502Container struct {
	// EntriesRead:  The number of entries returned by the method.
	EntriesRead uint32 `idl:"name:EntriesRead" json:"entries_read"`
	// Buffer:  A pointer to the SESSION_INFO_502 entries returned by the method.
	Buffer []*SessionInfo502 `idl:"name:Buffer;size_is:(EntriesRead)" json:"buffer"`
}

func (o *SessionInfo502Container) xxx_PreparePayload(ctx context.Context) error {
	if o.Buffer != nil && o.EntriesRead == 0 {
		o.EntriesRead = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *SessionInfo502Container) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.EntriesRead); err != nil {
		return err
	}
	if o.Buffer != nil || o.EntriesRead > 0 {
		_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.EntriesRead)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Buffer {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Buffer[i1] != nil {
					if err := o.Buffer[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&SessionInfo502{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&SessionInfo502{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *SessionInfo502Container) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntriesRead); err != nil {
		return err
	}
	_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.EntriesRead > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.EntriesRead)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
		}
		o.Buffer = make([]*SessionInfo502, sizeInfo[0])
		for i1 := range o.Buffer {
			i1 := i1
			if o.Buffer[i1] == nil {
				o.Buffer[i1] = &SessionInfo502{}
			}
			if err := o.Buffer[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]*SessionInfo502) }
	if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
		return err
	}
	return nil
}

// SessionEnumUnion structure represents SESSION_ENUM_UNION RPC union.
//
// The SESSION_ENUM_UNION union contains information about sessions. It is used in the
// definition of the SESSION_ENUM_STRUCT structure.
type SessionEnumUnion struct {
	// Types that are assignable to Value
	//
	// *SessionEnumUnion_Level0
	// *SessionEnumUnion_Level1
	// *SessionEnumUnion_Level2
	// *SessionEnumUnion_Level10
	// *SessionEnumUnion_Level502
	Value is_SessionEnumUnion `json:"value"`
}

func (o *SessionEnumUnion) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *SessionEnumUnion_Level0:
		if value != nil {
			return value.Level0
		}
	case *SessionEnumUnion_Level1:
		if value != nil {
			return value.Level1
		}
	case *SessionEnumUnion_Level2:
		if value != nil {
			return value.Level2
		}
	case *SessionEnumUnion_Level10:
		if value != nil {
			return value.Level10
		}
	case *SessionEnumUnion_Level502:
		if value != nil {
			return value.Level502
		}
	}
	return nil
}

type is_SessionEnumUnion interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_SessionEnumUnion()
}

func (o *SessionEnumUnion) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *SessionEnumUnion_Level0:
		return uint32(0)
	case *SessionEnumUnion_Level1:
		return uint32(1)
	case *SessionEnumUnion_Level2:
		return uint32(2)
	case *SessionEnumUnion_Level10:
		return uint32(10)
	case *SessionEnumUnion_Level502:
		return uint32(502)
	}
	return uint32(0)
}

func (o *SessionEnumUnion) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(0):
		_o, _ := o.Value.(*SessionEnumUnion_Level0)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&SessionEnumUnion_Level0{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1):
		_o, _ := o.Value.(*SessionEnumUnion_Level1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&SessionEnumUnion_Level1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(2):
		_o, _ := o.Value.(*SessionEnumUnion_Level2)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&SessionEnumUnion_Level2{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(10):
		_o, _ := o.Value.(*SessionEnumUnion_Level10)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&SessionEnumUnion_Level10{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(502):
		_o, _ := o.Value.(*SessionEnumUnion_Level502)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&SessionEnumUnion_Level502{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *SessionEnumUnion) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(0):
		o.Value = &SessionEnumUnion_Level0{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1):
		o.Value = &SessionEnumUnion_Level1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(2):
		o.Value = &SessionEnumUnion_Level2{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(10):
		o.Value = &SessionEnumUnion_Level10{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(502):
		o.Value = &SessionEnumUnion_Level502{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// SessionEnumUnion_Level0 structure represents SESSION_ENUM_UNION RPC union arm.
//
// It has following labels: 0
type SessionEnumUnion_Level0 struct {
	// Level0:  A pointer to a structure that contains information about sessions, as specified
	// in section 2.2.4.16.
	Level0 *SessionInfo0Container `idl:"name:Level0" json:"level0"`
}

func (*SessionEnumUnion_Level0) is_SessionEnumUnion() {}

func (o *SessionEnumUnion_Level0) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Level0 != nil {
		_ptr_Level0 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Level0 != nil {
				if err := o.Level0.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&SessionInfo0Container{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Level0, _ptr_Level0); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *SessionEnumUnion_Level0) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_Level0 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Level0 == nil {
			o.Level0 = &SessionInfo0Container{}
		}
		if err := o.Level0.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_Level0 := func(ptr interface{}) { o.Level0 = *ptr.(**SessionInfo0Container) }
	if err := w.ReadPointer(&o.Level0, _s_Level0, _ptr_Level0); err != nil {
		return err
	}
	return nil
}

// SessionEnumUnion_Level1 structure represents SESSION_ENUM_UNION RPC union arm.
//
// It has following labels: 1
type SessionEnumUnion_Level1 struct {
	// Level1:  A pointer to a structure that contains information about sessions, as specified
	// in section 2.2.4.17.
	Level1 *SessionInfo1Container `idl:"name:Level1" json:"level1"`
}

func (*SessionEnumUnion_Level1) is_SessionEnumUnion() {}

func (o *SessionEnumUnion_Level1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Level1 != nil {
		_ptr_Level1 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Level1 != nil {
				if err := o.Level1.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&SessionInfo1Container{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Level1, _ptr_Level1); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *SessionEnumUnion_Level1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_Level1 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Level1 == nil {
			o.Level1 = &SessionInfo1Container{}
		}
		if err := o.Level1.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_Level1 := func(ptr interface{}) { o.Level1 = *ptr.(**SessionInfo1Container) }
	if err := w.ReadPointer(&o.Level1, _s_Level1, _ptr_Level1); err != nil {
		return err
	}
	return nil
}

// SessionEnumUnion_Level2 structure represents SESSION_ENUM_UNION RPC union arm.
//
// It has following labels: 2
type SessionEnumUnion_Level2 struct {
	// Level2:  A pointer to a structure that contains information about sessions, as specified
	// in section 2.2.4.18.
	Level2 *SessionInfo2Container `idl:"name:Level2" json:"level2"`
}

func (*SessionEnumUnion_Level2) is_SessionEnumUnion() {}

func (o *SessionEnumUnion_Level2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Level2 != nil {
		_ptr_Level2 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Level2 != nil {
				if err := o.Level2.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&SessionInfo2Container{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Level2, _ptr_Level2); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *SessionEnumUnion_Level2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_Level2 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Level2 == nil {
			o.Level2 = &SessionInfo2Container{}
		}
		if err := o.Level2.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_Level2 := func(ptr interface{}) { o.Level2 = *ptr.(**SessionInfo2Container) }
	if err := w.ReadPointer(&o.Level2, _s_Level2, _ptr_Level2); err != nil {
		return err
	}
	return nil
}

// SessionEnumUnion_Level10 structure represents SESSION_ENUM_UNION RPC union arm.
//
// It has following labels: 10
type SessionEnumUnion_Level10 struct {
	// Level10:  A pointer to a structure that contains information about sessions, as specified
	// in section 2.2.4.19.
	Level10 *SessionInfo10Container `idl:"name:Level10" json:"level10"`
}

func (*SessionEnumUnion_Level10) is_SessionEnumUnion() {}

func (o *SessionEnumUnion_Level10) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Level10 != nil {
		_ptr_Level10 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Level10 != nil {
				if err := o.Level10.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&SessionInfo10Container{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Level10, _ptr_Level10); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *SessionEnumUnion_Level10) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_Level10 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Level10 == nil {
			o.Level10 = &SessionInfo10Container{}
		}
		if err := o.Level10.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_Level10 := func(ptr interface{}) { o.Level10 = *ptr.(**SessionInfo10Container) }
	if err := w.ReadPointer(&o.Level10, _s_Level10, _ptr_Level10); err != nil {
		return err
	}
	return nil
}

// SessionEnumUnion_Level502 structure represents SESSION_ENUM_UNION RPC union arm.
//
// It has following labels: 502
type SessionEnumUnion_Level502 struct {
	// Level502:  A pointer to a structure that contains information about sessions, as
	// specified in section 2.2.4.20.
	Level502 *SessionInfo502Container `idl:"name:Level502" json:"level502"`
}

func (*SessionEnumUnion_Level502) is_SessionEnumUnion() {}

func (o *SessionEnumUnion_Level502) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Level502 != nil {
		_ptr_Level502 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Level502 != nil {
				if err := o.Level502.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&SessionInfo502Container{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Level502, _ptr_Level502); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *SessionEnumUnion_Level502) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_Level502 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Level502 == nil {
			o.Level502 = &SessionInfo502Container{}
		}
		if err := o.Level502.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_Level502 := func(ptr interface{}) { o.Level502 = *ptr.(**SessionInfo502Container) }
	if err := w.ReadPointer(&o.Level502, _s_Level502, _ptr_Level502); err != nil {
		return err
	}
	return nil
}

// SessionEnum structure represents SESSION_ENUM_STRUCT RPC structure.
//
// The SESSION_ENUM_STRUCT structure specifies the information level that the client
// requests in the NetrSessionEnum method and encapsulates the SESSION_ENUM_UNION union
// that receives the entries that are enumerated by the server.
type SessionEnum struct {
	// Level:  Specifies the information level of the data. This parameter MUST have one
	// of the following values.
	//
	//	+-------+----------------------------+
	//	|       |                            |
	//	| VALUE |          MEANING           |
	//	|       |                            |
	//	+-------+----------------------------+
	//	+-------+----------------------------+
	//	|     0 | SESSION_INFO_0_CONTAINER   |
	//	+-------+----------------------------+
	//	|     1 | SESSION_INFO_1_CONTAINER   |
	//	+-------+----------------------------+
	//	|     2 | SESSION_INFO_2_CONTAINER   |
	//	+-------+----------------------------+
	//	|    10 | SESSION_INFO_10_CONTAINER  |
	//	+-------+----------------------------+
	//	|   502 | SESSION_INFO_502_CONTAINER |
	//	+-------+----------------------------+
	Level uint32 `idl:"name:Level" json:"level"`
	// SessionInfo:  Contains a session info container whose type is specified by the Level
	// parameter, as shown in the preceding table. The enumerated session entries are returned
	// in this member.
	SessionInfo *SessionEnumUnion `idl:"name:SessionInfo;switch_is:Level" json:"session_info"`
}

func (o *SessionEnum) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *SessionEnum) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.Level); err != nil {
		return err
	}
	_swSessionInfo := uint32(o.Level)
	if o.SessionInfo != nil {
		if err := o.SessionInfo.MarshalUnionNDR(ctx, w, _swSessionInfo); err != nil {
			return err
		}
	} else {
		if err := (&SessionEnumUnion{}).MarshalUnionNDR(ctx, w, _swSessionInfo); err != nil {
			return err
		}
	}
	return nil
}
func (o *SessionEnum) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.Level); err != nil {
		return err
	}
	if o.SessionInfo == nil {
		o.SessionInfo = &SessionEnumUnion{}
	}
	_swSessionInfo := uint32(o.Level)
	if err := o.SessionInfo.UnmarshalUnionNDR(ctx, w, _swSessionInfo); err != nil {
		return err
	}
	return nil
}

// ShareInfo502I structure represents SHARE_INFO_502_I RPC structure.
//
// The SHARE_INFO_502_I structure contains information about the shared resource, including
// the name of the resource, type, and permissions, the number of connections, and other
// pertinent information.
type ShareInfo502I struct {
	// shi502_netname:  A pointer to a null-terminated Unicode UTF-16 string that specifies
	// the name of a shared resource. The server MUST ignore this member when processing
	// the NetrShareSetInfo (section 3.1.4.11) method.
	NetworkName string `idl:"name:shi502_netname;string" json:"network_name"`
	// shi502_type:  Specifies a DWORD value that indicates the type of share. The server
	// MUST ignore this member when processing the NetrShareSetInfo method; otherwise, it
	// MUST be one of the values that are listed in section 2.2.2.4.
	Type uint32 `idl:"name:shi502_type" json:"type"`
	// shi502_remark:  A pointer to a null-terminated Unicode UTF-16 string that specifies
	// an optional comment about the shared resource.
	Remark string `idl:"name:shi502_remark;string" json:"remark"`
	// shi502_permissions:  This field is not used. The server MUST ignore the value of
	// this parameter on receipt.
	Permissions uint32 `idl:"name:shi502_permissions" json:"permissions"`
	// shi502_max_uses:  Specifies a DWORD value that indicates the maximum number of concurrent
	// connections that the shared resource can accommodate. If the value that is specified
	// by shi502_max_uses is 0xFFFFFFFF, the maximum number of connections MUST be unlimited.
	MaxUses uint32 `idl:"name:shi502_max_uses" json:"max_uses"`
	// shi502_current_uses:  Specifies a DWORD value that indicates the number of current
	// connections to the resource. The server MUST ignore this member on receipt.
	CurrentUses uint32 `idl:"name:shi502_current_uses" json:"current_uses"`
	// shi502_path:  A pointer to a null-terminated Unicode UTF-16 string that contains
	// the local path for the shared resource. For disks, shi502_path is the path that is
	// being shared. For print queues, shi502_path is the name of the print queue that is
	// being shared. For communication devices, shi502_path is the name of the communication
	// device that is being shared. For interprocess communications (IPC), shi502_path is
	// the name of the interprocess communication that is being shared. The server MUST
	// ignore this member when processing the NetrShareSetInfo method.
	Path string `idl:"name:shi502_path;string" json:"path"`
	// shi502_passwd:  This field is not used. The client MUST send a NULL (zero-length)
	// string and the server MUST ignore the value of this parameter on receipt.
	Password string `idl:"name:shi502_passwd;string" json:"password"`
	// shi502_reserved:  The length of the security descriptor that is being passed in the
	// shi502_security_descriptor member.
	securitydescriptorlength uint32 `idl:"name:shi502_reserved" json:"security_descriptor_length"`
	// shi502_security_descriptor:  Specifies the SECURITY_DESCRIPTOR, as described in [MS-DTYP]
	// section 2.4.6, that is associated with this share.
	SecurityDescriptor []byte `idl:"name:shi502_security_descriptor;size_is:(shi502_reserved)" json:"security_descriptor"`
}

func (o *ShareInfo502I) xxx_PreparePayload(ctx context.Context) error {
	if o.SecurityDescriptor != nil && o.securitydescriptorlength == 0 {
		o.securitydescriptorlength = uint32(len(o.SecurityDescriptor))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareInfo502I) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.NetworkName != "" {
		_ptr_shi502_netname := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.NetworkName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.NetworkName, _ptr_shi502_netname); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Type); err != nil {
		return err
	}
	if o.Remark != "" {
		_ptr_shi502_remark := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Remark); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Remark, _ptr_shi502_remark); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Permissions); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxUses); err != nil {
		return err
	}
	if err := w.WriteData(o.CurrentUses); err != nil {
		return err
	}
	if o.Path != "" {
		_ptr_shi502_path := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Path); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Path, _ptr_shi502_path); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.Password != "" {
		_ptr_shi502_passwd := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Password); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Password, _ptr_shi502_passwd); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.securitydescriptorlength); err != nil {
		return err
	}
	if o.SecurityDescriptor != nil || o.securitydescriptorlength > 0 {
		_ptr_shi502_security_descriptor := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.securitydescriptorlength)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.SecurityDescriptor {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.SecurityDescriptor[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.SecurityDescriptor); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.SecurityDescriptor, _ptr_shi502_security_descriptor); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareInfo502I) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_shi502_netname := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.NetworkName); err != nil {
			return err
		}
		return nil
	})
	_s_shi502_netname := func(ptr interface{}) { o.NetworkName = *ptr.(*string) }
	if err := w.ReadPointer(&o.NetworkName, _s_shi502_netname, _ptr_shi502_netname); err != nil {
		return err
	}
	if err := w.ReadData(&o.Type); err != nil {
		return err
	}
	_ptr_shi502_remark := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Remark); err != nil {
			return err
		}
		return nil
	})
	_s_shi502_remark := func(ptr interface{}) { o.Remark = *ptr.(*string) }
	if err := w.ReadPointer(&o.Remark, _s_shi502_remark, _ptr_shi502_remark); err != nil {
		return err
	}
	if err := w.ReadData(&o.Permissions); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxUses); err != nil {
		return err
	}
	if err := w.ReadData(&o.CurrentUses); err != nil {
		return err
	}
	_ptr_shi502_path := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Path); err != nil {
			return err
		}
		return nil
	})
	_s_shi502_path := func(ptr interface{}) { o.Path = *ptr.(*string) }
	if err := w.ReadPointer(&o.Path, _s_shi502_path, _ptr_shi502_path); err != nil {
		return err
	}
	_ptr_shi502_passwd := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Password); err != nil {
			return err
		}
		return nil
	})
	_s_shi502_passwd := func(ptr interface{}) { o.Password = *ptr.(*string) }
	if err := w.ReadPointer(&o.Password, _s_shi502_passwd, _ptr_shi502_passwd); err != nil {
		return err
	}
	if err := w.ReadData(&o.securitydescriptorlength); err != nil {
		return err
	}
	_ptr_shi502_security_descriptor := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.securitydescriptorlength > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.securitydescriptorlength)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.SecurityDescriptor", sizeInfo[0])
		}
		o.SecurityDescriptor = make([]byte, sizeInfo[0])
		for i1 := range o.SecurityDescriptor {
			i1 := i1
			if err := w.ReadData(&o.SecurityDescriptor[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_shi502_security_descriptor := func(ptr interface{}) { o.SecurityDescriptor = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.SecurityDescriptor, _s_shi502_security_descriptor, _ptr_shi502_security_descriptor); err != nil {
		return err
	}
	return nil
}

// ShareInfo503I structure represents SHARE_INFO_503_I RPC structure.
//
// The SHARE_INFO_503_I structure contains information about the shared resource, including
// the name of the resource, type, and permissions, the number of connections, and other
// pertinent information.
type ShareInfo503I struct {
	// shi503_netname:  A pointer to a null-terminated Unicode UTF-16 string that specifies
	// the name of a shared resource. The server MUST ignore this member when processing
	// the NetrShareSetInfo (section 3.1.4.11) method.
	NetworkName string `idl:"name:shi503_netname;string" json:"network_name"`
	// shi503_type:  Specifies a DWORD value that indicates the type of share. The server
	// MUST ignore this member when processing the NetrShareSetInfo method. Otherwise, it
	// MUST be one of the values listed in section 2.2.2.4.
	Type uint32 `idl:"name:shi503_type" json:"type"`
	// shi503_remark:  A pointer to a null-terminated Unicode UTF-16 string that specifies
	// an optional comment about the shared resource.
	Remark string `idl:"name:shi503_remark;string" json:"remark"`
	// shi503_permissions:  This field is not used. The server MUST ignore the value of
	// this parameter on receipt.
	Permissions uint32 `idl:"name:shi503_permissions" json:"permissions"`
	// shi503_max_uses:  Specifies a DWORD value that indicates the maximum number of concurrent
	// connections that the shared resource can accommodate. If the value is 0xFFFFFFFF,
	// the maximum number of connections MUST be unlimited.
	MaxUses uint32 `idl:"name:shi503_max_uses" json:"max_uses"`
	// shi503_current_uses:  Specifies a DWORD value that indicates the number of current
	// connections to the resource. The server MUST ignore this member on receipt.
	CurrentUses uint32 `idl:"name:shi503_current_uses" json:"current_uses"`
	// shi503_path:  A pointer to a null-terminated Unicode UTF-16 string that contains
	// the local path for the shared resource. For disks, it is the path being shared. For
	// print queues, it is the name of the print queue being shared. The server MUST ignore
	// this member when processing the NetrShareSetInfo method.
	Path string `idl:"name:shi503_path;string" json:"path"`
	// shi503_passwd:  This field is not used. The client MUST send a NULL (zero-length)
	// string, and the server MUST ignore the value of this parameter on receipt.
	Password string `idl:"name:shi503_passwd;string" json:"password"`
	// shi503_servername:  A pointer to a string that specifies the DNS or NetBIOS name
	// of the server on which the shared resource resides. It SHOULD be either "*" or the
	// string matching one of the server names. Otherwise, the default server name will
	// be used in <shi503_netname, default server name> to locate a scoped share as specified
	// in section 2.2.4.102. A value of "*" indicates that there is no configured server
	// name.
	Servername string `idl:"name:shi503_servername;string" json:"servername"`
	// shi503_reserved:  The length of the security descriptor passed in the shi503_security_descriptor
	// member.
	securitydescriptorlength uint32 `idl:"name:shi503_reserved" json:"security_descriptor_length"`
	// shi503_security_descriptor:  Specifies the SECURITY_DESCRIPTOR, as described in [MS-DTYP]
	// section 2.4.6, that is associated with this share.
	SecurityDescriptor []byte `idl:"name:shi503_security_descriptor;size_is:(shi503_reserved)" json:"security_descriptor"`
}

func (o *ShareInfo503I) xxx_PreparePayload(ctx context.Context) error {
	if o.SecurityDescriptor != nil && o.securitydescriptorlength == 0 {
		o.securitydescriptorlength = uint32(len(o.SecurityDescriptor))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareInfo503I) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.NetworkName != "" {
		_ptr_shi503_netname := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.NetworkName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.NetworkName, _ptr_shi503_netname); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Type); err != nil {
		return err
	}
	if o.Remark != "" {
		_ptr_shi503_remark := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Remark); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Remark, _ptr_shi503_remark); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Permissions); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxUses); err != nil {
		return err
	}
	if err := w.WriteData(o.CurrentUses); err != nil {
		return err
	}
	if o.Path != "" {
		_ptr_shi503_path := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Path); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Path, _ptr_shi503_path); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.Password != "" {
		_ptr_shi503_passwd := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Password); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Password, _ptr_shi503_passwd); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.Servername != "" {
		_ptr_shi503_servername := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Servername); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Servername, _ptr_shi503_servername); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.securitydescriptorlength); err != nil {
		return err
	}
	if o.SecurityDescriptor != nil || o.securitydescriptorlength > 0 {
		_ptr_shi503_security_descriptor := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.securitydescriptorlength)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.SecurityDescriptor {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.SecurityDescriptor[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.SecurityDescriptor); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.SecurityDescriptor, _ptr_shi503_security_descriptor); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareInfo503I) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_shi503_netname := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.NetworkName); err != nil {
			return err
		}
		return nil
	})
	_s_shi503_netname := func(ptr interface{}) { o.NetworkName = *ptr.(*string) }
	if err := w.ReadPointer(&o.NetworkName, _s_shi503_netname, _ptr_shi503_netname); err != nil {
		return err
	}
	if err := w.ReadData(&o.Type); err != nil {
		return err
	}
	_ptr_shi503_remark := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Remark); err != nil {
			return err
		}
		return nil
	})
	_s_shi503_remark := func(ptr interface{}) { o.Remark = *ptr.(*string) }
	if err := w.ReadPointer(&o.Remark, _s_shi503_remark, _ptr_shi503_remark); err != nil {
		return err
	}
	if err := w.ReadData(&o.Permissions); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxUses); err != nil {
		return err
	}
	if err := w.ReadData(&o.CurrentUses); err != nil {
		return err
	}
	_ptr_shi503_path := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Path); err != nil {
			return err
		}
		return nil
	})
	_s_shi503_path := func(ptr interface{}) { o.Path = *ptr.(*string) }
	if err := w.ReadPointer(&o.Path, _s_shi503_path, _ptr_shi503_path); err != nil {
		return err
	}
	_ptr_shi503_passwd := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Password); err != nil {
			return err
		}
		return nil
	})
	_s_shi503_passwd := func(ptr interface{}) { o.Password = *ptr.(*string) }
	if err := w.ReadPointer(&o.Password, _s_shi503_passwd, _ptr_shi503_passwd); err != nil {
		return err
	}
	_ptr_shi503_servername := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Servername); err != nil {
			return err
		}
		return nil
	})
	_s_shi503_servername := func(ptr interface{}) { o.Servername = *ptr.(*string) }
	if err := w.ReadPointer(&o.Servername, _s_shi503_servername, _ptr_shi503_servername); err != nil {
		return err
	}
	if err := w.ReadData(&o.securitydescriptorlength); err != nil {
		return err
	}
	_ptr_shi503_security_descriptor := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.securitydescriptorlength > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.securitydescriptorlength)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.SecurityDescriptor", sizeInfo[0])
		}
		o.SecurityDescriptor = make([]byte, sizeInfo[0])
		for i1 := range o.SecurityDescriptor {
			i1 := i1
			if err := w.ReadData(&o.SecurityDescriptor[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_shi503_security_descriptor := func(ptr interface{}) { o.SecurityDescriptor = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.SecurityDescriptor, _s_shi503_security_descriptor, _ptr_shi503_security_descriptor); err != nil {
		return err
	}
	return nil
}

// ShareInfo503Container structure represents SHARE_INFO_503_CONTAINER RPC structure.
//
// The SHARE_INFO_503_CONTAINER structure contains a value that indicates the number
// of entries the NetrShareEnum method returns and a pointer to the buffer that contains
// the entries.
type ShareInfo503Container struct {
	// EntriesRead:  The number of entries returned by the method.
	EntriesRead uint32 `idl:"name:EntriesRead" json:"entries_read"`
	// Buffer:  A pointer to the SHARE_INFO_503_I entries returned by the method.
	Buffer []*ShareInfo503I `idl:"name:Buffer;size_is:(EntriesRead)" json:"buffer"`
}

func (o *ShareInfo503Container) xxx_PreparePayload(ctx context.Context) error {
	if o.Buffer != nil && o.EntriesRead == 0 {
		o.EntriesRead = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareInfo503Container) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.EntriesRead); err != nil {
		return err
	}
	if o.Buffer != nil || o.EntriesRead > 0 {
		_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.EntriesRead)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Buffer {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Buffer[i1] != nil {
					if err := o.Buffer[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&ShareInfo503I{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&ShareInfo503I{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareInfo503Container) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntriesRead); err != nil {
		return err
	}
	_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.EntriesRead > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.EntriesRead)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
		}
		o.Buffer = make([]*ShareInfo503I, sizeInfo[0])
		for i1 := range o.Buffer {
			i1 := i1
			if o.Buffer[i1] == nil {
				o.Buffer[i1] = &ShareInfo503I{}
			}
			if err := o.Buffer[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]*ShareInfo503I) }
	if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
		return err
	}
	return nil
}

// ShareInfo1501I structure represents SHARE_INFO_1501_I RPC structure.
//
// The SHARE_INFO_1501_I structure contains a security descriptor in self-relative format
// and a DWORD that contains its length.<16> For a description of the fields in this
// structure, see the description for the SHARE_INFO_502_I (section 2.2.4.26) structure
// (shi1501_xxx denotes the same information as shi502_xxx).
type ShareInfo1501I struct {
	securitydescriptorlength uint32 `idl:"name:shi1501_reserved" json:"security_descriptor_length"`
	SecurityDescriptor       []byte `idl:"name:shi1501_security_descriptor;size_is:(shi1501_reserved)" json:"security_descriptor"`
}

func (o *ShareInfo1501I) xxx_PreparePayload(ctx context.Context) error {
	if o.SecurityDescriptor != nil && o.securitydescriptorlength == 0 {
		o.securitydescriptorlength = uint32(len(o.SecurityDescriptor))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareInfo1501I) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.securitydescriptorlength); err != nil {
		return err
	}
	if o.SecurityDescriptor != nil || o.securitydescriptorlength > 0 {
		_ptr_shi1501_security_descriptor := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.securitydescriptorlength)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.SecurityDescriptor {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.SecurityDescriptor[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.SecurityDescriptor); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.SecurityDescriptor, _ptr_shi1501_security_descriptor); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareInfo1501I) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.securitydescriptorlength); err != nil {
		return err
	}
	_ptr_shi1501_security_descriptor := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.securitydescriptorlength > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.securitydescriptorlength)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.SecurityDescriptor", sizeInfo[0])
		}
		o.SecurityDescriptor = make([]byte, sizeInfo[0])
		for i1 := range o.SecurityDescriptor {
			i1 := i1
			if err := w.ReadData(&o.SecurityDescriptor[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_shi1501_security_descriptor := func(ptr interface{}) { o.SecurityDescriptor = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.SecurityDescriptor, _s_shi1501_security_descriptor, _ptr_shi1501_security_descriptor); err != nil {
		return err
	}
	return nil
}

// ShareInfo0 structure represents SHARE_INFO_0 RPC structure.
//
// The SHARE_INFO_0 structure contains the name of the shared resource. For a description
// of the fields in this structure, see the description for the SHARE_INFO_502_I (section
// 2.2.4.26) structure (shi0_xxx denotes the same information as shi502_xxx).
type ShareInfo0 struct {
	NetworkName string `idl:"name:shi0_netname;string" json:"network_name"`
}

func (o *ShareInfo0) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareInfo0) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(6); err != nil {
		return err
	}
	if o.NetworkName != "" {
		_ptr_shi0_netname := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.NetworkName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.NetworkName, _ptr_shi0_netname); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareInfo0) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(6); err != nil {
		return err
	}
	_ptr_shi0_netname := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.NetworkName); err != nil {
			return err
		}
		return nil
	})
	_s_shi0_netname := func(ptr interface{}) { o.NetworkName = *ptr.(*string) }
	if err := w.ReadPointer(&o.NetworkName, _s_shi0_netname, _ptr_shi0_netname); err != nil {
		return err
	}
	return nil
}

// ShareInfo0Container structure represents SHARE_INFO_0_CONTAINER RPC structure.
//
// The SHARE_INFO_0_CONTAINER structure contains a value that indicates the number of
// entries that the NetrShareEnum method returns and a pointer to the buffer that contains
// the entries.
type ShareInfo0Container struct {
	// EntriesRead:  The number of entries returned by the method.
	EntriesRead uint32 `idl:"name:EntriesRead" json:"entries_read"`
	// Buffer:  A pointer to the SHARE_INFO_0 entries returned by the method.
	Buffer []*ShareInfo0 `idl:"name:Buffer;size_is:(EntriesRead)" json:"buffer"`
}

func (o *ShareInfo0Container) xxx_PreparePayload(ctx context.Context) error {
	if o.Buffer != nil && o.EntriesRead == 0 {
		o.EntriesRead = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareInfo0Container) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.EntriesRead); err != nil {
		return err
	}
	if o.Buffer != nil || o.EntriesRead > 0 {
		_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.EntriesRead)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Buffer {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Buffer[i1] != nil {
					if err := o.Buffer[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&ShareInfo0{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&ShareInfo0{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareInfo0Container) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntriesRead); err != nil {
		return err
	}
	_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.EntriesRead > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.EntriesRead)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
		}
		o.Buffer = make([]*ShareInfo0, sizeInfo[0])
		for i1 := range o.Buffer {
			i1 := i1
			if o.Buffer[i1] == nil {
				o.Buffer[i1] = &ShareInfo0{}
			}
			if err := o.Buffer[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]*ShareInfo0) }
	if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
		return err
	}
	return nil
}

// ShareInfo1 structure represents SHARE_INFO_1 RPC structure.
//
// The SHARE_INFO_1 structure contains information about the shared resource, including
// the name and type of the resource and a comment associated with the resource. For
// a description of the fields in this structure, see the description for the SHARE_INFO_502_I
// (section 2.2.4.26) structure (shi1_xxx denotes the same information as shi502_xxx).
type ShareInfo1 struct {
	NetworkName string `idl:"name:shi1_netname;string" json:"network_name"`
	Type        uint32 `idl:"name:shi1_type" json:"type"`
	Remark      string `idl:"name:shi1_remark;string" json:"remark"`
}

func (o *ShareInfo1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareInfo1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.NetworkName != "" {
		_ptr_shi1_netname := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.NetworkName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.NetworkName, _ptr_shi1_netname); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Type); err != nil {
		return err
	}
	if o.Remark != "" {
		_ptr_shi1_remark := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Remark); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Remark, _ptr_shi1_remark); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareInfo1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_shi1_netname := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.NetworkName); err != nil {
			return err
		}
		return nil
	})
	_s_shi1_netname := func(ptr interface{}) { o.NetworkName = *ptr.(*string) }
	if err := w.ReadPointer(&o.NetworkName, _s_shi1_netname, _ptr_shi1_netname); err != nil {
		return err
	}
	if err := w.ReadData(&o.Type); err != nil {
		return err
	}
	_ptr_shi1_remark := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Remark); err != nil {
			return err
		}
		return nil
	})
	_s_shi1_remark := func(ptr interface{}) { o.Remark = *ptr.(*string) }
	if err := w.ReadPointer(&o.Remark, _s_shi1_remark, _ptr_shi1_remark); err != nil {
		return err
	}
	return nil
}

// ShareInfo1Container structure represents SHARE_INFO_1_CONTAINER RPC structure.
//
// The SHARE_INFO_1_CONTAINER structure contains a value that indicates the number of
// entries that the NetrShareEnum method returns and a pointer to the buffer that contains
// the entries.
type ShareInfo1Container struct {
	// EntriesRead:  The number of entries returned by the method.
	EntriesRead uint32 `idl:"name:EntriesRead" json:"entries_read"`
	// Buffer:  A pointer to the SHARE_INFO_1 entries returned by the method.
	Buffer []*ShareInfo1 `idl:"name:Buffer;size_is:(EntriesRead)" json:"buffer"`
}

func (o *ShareInfo1Container) xxx_PreparePayload(ctx context.Context) error {
	if o.Buffer != nil && o.EntriesRead == 0 {
		o.EntriesRead = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareInfo1Container) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.EntriesRead); err != nil {
		return err
	}
	if o.Buffer != nil || o.EntriesRead > 0 {
		_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.EntriesRead)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Buffer {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Buffer[i1] != nil {
					if err := o.Buffer[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&ShareInfo1{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&ShareInfo1{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareInfo1Container) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntriesRead); err != nil {
		return err
	}
	_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.EntriesRead > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.EntriesRead)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
		}
		o.Buffer = make([]*ShareInfo1, sizeInfo[0])
		for i1 := range o.Buffer {
			i1 := i1
			if o.Buffer[i1] == nil {
				o.Buffer[i1] = &ShareInfo1{}
			}
			if err := o.Buffer[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]*ShareInfo1) }
	if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
		return err
	}
	return nil
}

// ShareInfo2 structure represents SHARE_INFO_2 RPC structure.
//
// The SHARE_INFO_2 structure contains information about the shared resource, including
// the name, type, and permissions of the resource, comments associated with the resource,
// the maximum number of concurrent connections, the number of current connections,
// the local path for the resource, and a password for the current connection. For a
// description of the fields in this structure, see the description for the SHARE_INFO_502_I
// (section 2.2.4.26) structure (shi2_xxx denotes the same information as shi502_xxx).
type ShareInfo2 struct {
	NetworkName string `idl:"name:shi2_netname;string" json:"network_name"`
	Type        uint32 `idl:"name:shi2_type" json:"type"`
	Remark      string `idl:"name:shi2_remark;string" json:"remark"`
	Permissions uint32 `idl:"name:shi2_permissions" json:"permissions"`
	MaxUses     uint32 `idl:"name:shi2_max_uses" json:"max_uses"`
	CurrentUses uint32 `idl:"name:shi2_current_uses" json:"current_uses"`
	Path        string `idl:"name:shi2_path;string" json:"path"`
	Password    string `idl:"name:shi2_passwd;string" json:"password"`
}

func (o *ShareInfo2) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareInfo2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.NetworkName != "" {
		_ptr_shi2_netname := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.NetworkName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.NetworkName, _ptr_shi2_netname); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Type); err != nil {
		return err
	}
	if o.Remark != "" {
		_ptr_shi2_remark := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Remark); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Remark, _ptr_shi2_remark); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Permissions); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxUses); err != nil {
		return err
	}
	if err := w.WriteData(o.CurrentUses); err != nil {
		return err
	}
	if o.Path != "" {
		_ptr_shi2_path := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Path); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Path, _ptr_shi2_path); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.Password != "" {
		_ptr_shi2_passwd := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Password); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Password, _ptr_shi2_passwd); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareInfo2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_shi2_netname := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.NetworkName); err != nil {
			return err
		}
		return nil
	})
	_s_shi2_netname := func(ptr interface{}) { o.NetworkName = *ptr.(*string) }
	if err := w.ReadPointer(&o.NetworkName, _s_shi2_netname, _ptr_shi2_netname); err != nil {
		return err
	}
	if err := w.ReadData(&o.Type); err != nil {
		return err
	}
	_ptr_shi2_remark := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Remark); err != nil {
			return err
		}
		return nil
	})
	_s_shi2_remark := func(ptr interface{}) { o.Remark = *ptr.(*string) }
	if err := w.ReadPointer(&o.Remark, _s_shi2_remark, _ptr_shi2_remark); err != nil {
		return err
	}
	if err := w.ReadData(&o.Permissions); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxUses); err != nil {
		return err
	}
	if err := w.ReadData(&o.CurrentUses); err != nil {
		return err
	}
	_ptr_shi2_path := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Path); err != nil {
			return err
		}
		return nil
	})
	_s_shi2_path := func(ptr interface{}) { o.Path = *ptr.(*string) }
	if err := w.ReadPointer(&o.Path, _s_shi2_path, _ptr_shi2_path); err != nil {
		return err
	}
	_ptr_shi2_passwd := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Password); err != nil {
			return err
		}
		return nil
	})
	_s_shi2_passwd := func(ptr interface{}) { o.Password = *ptr.(*string) }
	if err := w.ReadPointer(&o.Password, _s_shi2_passwd, _ptr_shi2_passwd); err != nil {
		return err
	}
	return nil
}

// ShareInfo2Container structure represents SHARE_INFO_2_CONTAINER RPC structure.
//
// The SHARE_INFO_2_CONTAINER structure contains a value that indicates the number of
// entries that the NetrShareEnum method returns and a pointer to the buffer that contains
// the entries.
type ShareInfo2Container struct {
	// EntriesRead:  The number of entries returned by the method.
	EntriesRead uint32 `idl:"name:EntriesRead" json:"entries_read"`
	// Buffer:  A pointer to the SHARE_INFO_2 entries returned by the method.
	Buffer []*ShareInfo2 `idl:"name:Buffer;size_is:(EntriesRead)" json:"buffer"`
}

func (o *ShareInfo2Container) xxx_PreparePayload(ctx context.Context) error {
	if o.Buffer != nil && o.EntriesRead == 0 {
		o.EntriesRead = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareInfo2Container) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.EntriesRead); err != nil {
		return err
	}
	if o.Buffer != nil || o.EntriesRead > 0 {
		_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.EntriesRead)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Buffer {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Buffer[i1] != nil {
					if err := o.Buffer[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&ShareInfo2{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&ShareInfo2{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareInfo2Container) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntriesRead); err != nil {
		return err
	}
	_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.EntriesRead > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.EntriesRead)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
		}
		o.Buffer = make([]*ShareInfo2, sizeInfo[0])
		for i1 := range o.Buffer {
			i1 := i1
			if o.Buffer[i1] == nil {
				o.Buffer[i1] = &ShareInfo2{}
			}
			if err := o.Buffer[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]*ShareInfo2) }
	if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
		return err
	}
	return nil
}

// ShareInfo501 structure represents SHARE_INFO_501 RPC structure.
//
// The SHARE_INFO_501 structure contains information about the shared resource, including
// the name and type of the resource and a comment that is associated with the resource.
// For a description of the fields in this structure, see the description for the SHARE_INFO_502_I
// (section 2.2.4.26) structure (shi501_netname, shi501_type, and shi501_remark denote
// the same information as shi502_xxx in section 2.2.4.26, and shi501_flags denotes
// the same information as shi1005_flags in section 2.2.4.29).
type ShareInfo501 struct {
	NetworkName string `idl:"name:shi501_netname;string" json:"network_name"`
	Type        uint32 `idl:"name:shi501_type" json:"type"`
	Remark      string `idl:"name:shi501_remark;string" json:"remark"`
	Flags       uint32 `idl:"name:shi501_flags" json:"flags"`
}

func (o *ShareInfo501) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareInfo501) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.NetworkName != "" {
		_ptr_shi501_netname := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.NetworkName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.NetworkName, _ptr_shi501_netname); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Type); err != nil {
		return err
	}
	if o.Remark != "" {
		_ptr_shi501_remark := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Remark); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Remark, _ptr_shi501_remark); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	return nil
}
func (o *ShareInfo501) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_shi501_netname := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.NetworkName); err != nil {
			return err
		}
		return nil
	})
	_s_shi501_netname := func(ptr interface{}) { o.NetworkName = *ptr.(*string) }
	if err := w.ReadPointer(&o.NetworkName, _s_shi501_netname, _ptr_shi501_netname); err != nil {
		return err
	}
	if err := w.ReadData(&o.Type); err != nil {
		return err
	}
	_ptr_shi501_remark := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Remark); err != nil {
			return err
		}
		return nil
	})
	_s_shi501_remark := func(ptr interface{}) { o.Remark = *ptr.(*string) }
	if err := w.ReadPointer(&o.Remark, _s_shi501_remark, _ptr_shi501_remark); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	return nil
}

// ShareInfo501Container structure represents SHARE_INFO_501_CONTAINER RPC structure.
//
// The SHARE_INFO_501_CONTAINER structure contains a value that indicates the number
// of entries that the NetrShareEnum method returns and a pointer to the buffer that
// contains the entries.
type ShareInfo501Container struct {
	// EntriesRead:  The number of entries returned by the method.
	EntriesRead uint32 `idl:"name:EntriesRead" json:"entries_read"`
	// Buffer:  A pointer to the SHARE_INFO_501 entries returned by the method.
	Buffer []*ShareInfo501 `idl:"name:Buffer;size_is:(EntriesRead)" json:"buffer"`
}

func (o *ShareInfo501Container) xxx_PreparePayload(ctx context.Context) error {
	if o.Buffer != nil && o.EntriesRead == 0 {
		o.EntriesRead = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareInfo501Container) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.EntriesRead); err != nil {
		return err
	}
	if o.Buffer != nil || o.EntriesRead > 0 {
		_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.EntriesRead)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Buffer {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Buffer[i1] != nil {
					if err := o.Buffer[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&ShareInfo501{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&ShareInfo501{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareInfo501Container) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntriesRead); err != nil {
		return err
	}
	_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.EntriesRead > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.EntriesRead)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
		}
		o.Buffer = make([]*ShareInfo501, sizeInfo[0])
		for i1 := range o.Buffer {
			i1 := i1
			if o.Buffer[i1] == nil {
				o.Buffer[i1] = &ShareInfo501{}
			}
			if err := o.Buffer[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]*ShareInfo501) }
	if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
		return err
	}
	return nil
}

// ShareInfo502Container structure represents SHARE_INFO_502_CONTAINER RPC structure.
//
// The SHARE_INFO_502_CONTAINER structure contains a value that indicates the number
// of entries that the NetrShareEnum method returns and a pointer to the buffer that
// contains the entries.
type ShareInfo502Container struct {
	// EntriesRead:  The number of entries returned by the method.
	EntriesRead uint32 `idl:"name:EntriesRead" json:"entries_read"`
	// Buffer:  A pointer to the SHARE_INFO_502_I entries returned by the method.
	Buffer []*ShareInfo502I `idl:"name:Buffer;size_is:(EntriesRead)" json:"buffer"`
}

func (o *ShareInfo502Container) xxx_PreparePayload(ctx context.Context) error {
	if o.Buffer != nil && o.EntriesRead == 0 {
		o.EntriesRead = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareInfo502Container) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.EntriesRead); err != nil {
		return err
	}
	if o.Buffer != nil || o.EntriesRead > 0 {
		_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.EntriesRead)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Buffer {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Buffer[i1] != nil {
					if err := o.Buffer[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&ShareInfo502I{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&ShareInfo502I{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareInfo502Container) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntriesRead); err != nil {
		return err
	}
	_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.EntriesRead > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.EntriesRead)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
		}
		o.Buffer = make([]*ShareInfo502I, sizeInfo[0])
		for i1 := range o.Buffer {
			i1 := i1
			if o.Buffer[i1] == nil {
				o.Buffer[i1] = &ShareInfo502I{}
			}
			if err := o.Buffer[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]*ShareInfo502I) }
	if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
		return err
	}
	return nil
}

// ShareEnumUnion structure represents SHARE_ENUM_UNION RPC union.
//
// The SHARE_ENUM_UNION union contains information about shares. It is used in the definition
// of the SHARE_ENUM_STRUCT structure.
type ShareEnumUnion struct {
	// Types that are assignable to Value
	//
	// *ShareEnumUnion_Level0
	// *ShareEnumUnion_Level1
	// *ShareEnumUnion_Level2
	// *ShareEnumUnion_Level501
	// *ShareEnumUnion_Level502
	// *ShareEnumUnion_Level503
	Value is_ShareEnumUnion `json:"value"`
}

func (o *ShareEnumUnion) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *ShareEnumUnion_Level0:
		if value != nil {
			return value.Level0
		}
	case *ShareEnumUnion_Level1:
		if value != nil {
			return value.Level1
		}
	case *ShareEnumUnion_Level2:
		if value != nil {
			return value.Level2
		}
	case *ShareEnumUnion_Level501:
		if value != nil {
			return value.Level501
		}
	case *ShareEnumUnion_Level502:
		if value != nil {
			return value.Level502
		}
	case *ShareEnumUnion_Level503:
		if value != nil {
			return value.Level503
		}
	}
	return nil
}

type is_ShareEnumUnion interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_ShareEnumUnion()
}

func (o *ShareEnumUnion) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *ShareEnumUnion_Level0:
		return uint32(0)
	case *ShareEnumUnion_Level1:
		return uint32(1)
	case *ShareEnumUnion_Level2:
		return uint32(2)
	case *ShareEnumUnion_Level501:
		return uint32(501)
	case *ShareEnumUnion_Level502:
		return uint32(502)
	case *ShareEnumUnion_Level503:
		return uint32(503)
	}
	return uint32(0)
}

func (o *ShareEnumUnion) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(0):
		_o, _ := o.Value.(*ShareEnumUnion_Level0)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ShareEnumUnion_Level0{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1):
		_o, _ := o.Value.(*ShareEnumUnion_Level1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ShareEnumUnion_Level1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(2):
		_o, _ := o.Value.(*ShareEnumUnion_Level2)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ShareEnumUnion_Level2{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(501):
		_o, _ := o.Value.(*ShareEnumUnion_Level501)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ShareEnumUnion_Level501{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(502):
		_o, _ := o.Value.(*ShareEnumUnion_Level502)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ShareEnumUnion_Level502{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(503):
		_o, _ := o.Value.(*ShareEnumUnion_Level503)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ShareEnumUnion_Level503{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *ShareEnumUnion) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(0):
		o.Value = &ShareEnumUnion_Level0{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1):
		o.Value = &ShareEnumUnion_Level1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(2):
		o.Value = &ShareEnumUnion_Level2{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(501):
		o.Value = &ShareEnumUnion_Level501{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(502):
		o.Value = &ShareEnumUnion_Level502{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(503):
		o.Value = &ShareEnumUnion_Level503{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// ShareEnumUnion_Level0 structure represents SHARE_ENUM_UNION RPC union arm.
//
// It has following labels: 0
type ShareEnumUnion_Level0 struct {
	// Level0:  A pointer to a structure that contains information about shares, as specified
	// in section 2.2.4.32.
	Level0 *ShareInfo0Container `idl:"name:Level0" json:"level0"`
}

func (*ShareEnumUnion_Level0) is_ShareEnumUnion() {}

func (o *ShareEnumUnion_Level0) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Level0 != nil {
		_ptr_Level0 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Level0 != nil {
				if err := o.Level0.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ShareInfo0Container{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Level0, _ptr_Level0); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareEnumUnion_Level0) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_Level0 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Level0 == nil {
			o.Level0 = &ShareInfo0Container{}
		}
		if err := o.Level0.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_Level0 := func(ptr interface{}) { o.Level0 = *ptr.(**ShareInfo0Container) }
	if err := w.ReadPointer(&o.Level0, _s_Level0, _ptr_Level0); err != nil {
		return err
	}
	return nil
}

// ShareEnumUnion_Level1 structure represents SHARE_ENUM_UNION RPC union arm.
//
// It has following labels: 1
type ShareEnumUnion_Level1 struct {
	// Level1:  A pointer to a structure that contains information about shares, as specified
	// in section 2.2.4.33.
	Level1 *ShareInfo1Container `idl:"name:Level1" json:"level1"`
}

func (*ShareEnumUnion_Level1) is_ShareEnumUnion() {}

func (o *ShareEnumUnion_Level1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Level1 != nil {
		_ptr_Level1 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Level1 != nil {
				if err := o.Level1.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ShareInfo1Container{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Level1, _ptr_Level1); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareEnumUnion_Level1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_Level1 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Level1 == nil {
			o.Level1 = &ShareInfo1Container{}
		}
		if err := o.Level1.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_Level1 := func(ptr interface{}) { o.Level1 = *ptr.(**ShareInfo1Container) }
	if err := w.ReadPointer(&o.Level1, _s_Level1, _ptr_Level1); err != nil {
		return err
	}
	return nil
}

// ShareEnumUnion_Level2 structure represents SHARE_ENUM_UNION RPC union arm.
//
// It has following labels: 2
type ShareEnumUnion_Level2 struct {
	// Level2:  A pointer to a structure that contains information about shares, as specified
	// in section 2.2.4.34.
	Level2 *ShareInfo2Container `idl:"name:Level2" json:"level2"`
}

func (*ShareEnumUnion_Level2) is_ShareEnumUnion() {}

func (o *ShareEnumUnion_Level2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Level2 != nil {
		_ptr_Level2 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Level2 != nil {
				if err := o.Level2.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ShareInfo2Container{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Level2, _ptr_Level2); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareEnumUnion_Level2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_Level2 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Level2 == nil {
			o.Level2 = &ShareInfo2Container{}
		}
		if err := o.Level2.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_Level2 := func(ptr interface{}) { o.Level2 = *ptr.(**ShareInfo2Container) }
	if err := w.ReadPointer(&o.Level2, _s_Level2, _ptr_Level2); err != nil {
		return err
	}
	return nil
}

// ShareEnumUnion_Level501 structure represents SHARE_ENUM_UNION RPC union arm.
//
// It has following labels: 501
type ShareEnumUnion_Level501 struct {
	// Level501:  A pointer to a structure that contains information about shares, as specified
	// in section 2.2.4.35.
	Level501 *ShareInfo501Container `idl:"name:Level501" json:"level501"`
}

func (*ShareEnumUnion_Level501) is_ShareEnumUnion() {}

func (o *ShareEnumUnion_Level501) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Level501 != nil {
		_ptr_Level501 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Level501 != nil {
				if err := o.Level501.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ShareInfo501Container{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Level501, _ptr_Level501); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareEnumUnion_Level501) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_Level501 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Level501 == nil {
			o.Level501 = &ShareInfo501Container{}
		}
		if err := o.Level501.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_Level501 := func(ptr interface{}) { o.Level501 = *ptr.(**ShareInfo501Container) }
	if err := w.ReadPointer(&o.Level501, _s_Level501, _ptr_Level501); err != nil {
		return err
	}
	return nil
}

// ShareEnumUnion_Level502 structure represents SHARE_ENUM_UNION RPC union arm.
//
// It has following labels: 502
type ShareEnumUnion_Level502 struct {
	// Level502:  A pointer to a structure that contains information about shares, as specified
	// in section 2.2.4.36.
	Level502 *ShareInfo502Container `idl:"name:Level502" json:"level502"`
}

func (*ShareEnumUnion_Level502) is_ShareEnumUnion() {}

func (o *ShareEnumUnion_Level502) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Level502 != nil {
		_ptr_Level502 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Level502 != nil {
				if err := o.Level502.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ShareInfo502Container{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Level502, _ptr_Level502); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareEnumUnion_Level502) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_Level502 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Level502 == nil {
			o.Level502 = &ShareInfo502Container{}
		}
		if err := o.Level502.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_Level502 := func(ptr interface{}) { o.Level502 = *ptr.(**ShareInfo502Container) }
	if err := w.ReadPointer(&o.Level502, _s_Level502, _ptr_Level502); err != nil {
		return err
	}
	return nil
}

// ShareEnumUnion_Level503 structure represents SHARE_ENUM_UNION RPC union arm.
//
// It has following labels: 503
type ShareEnumUnion_Level503 struct {
	// Level503:  A pointer to a structure that contains information about shares, as specified
	// in section 2.2.4.37.
	Level503 *ShareInfo503Container `idl:"name:Level503" json:"level503"`
}

func (*ShareEnumUnion_Level503) is_ShareEnumUnion() {}

func (o *ShareEnumUnion_Level503) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Level503 != nil {
		_ptr_Level503 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Level503 != nil {
				if err := o.Level503.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ShareInfo503Container{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Level503, _ptr_Level503); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareEnumUnion_Level503) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_Level503 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Level503 == nil {
			o.Level503 = &ShareInfo503Container{}
		}
		if err := o.Level503.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_Level503 := func(ptr interface{}) { o.Level503 = *ptr.(**ShareInfo503Container) }
	if err := w.ReadPointer(&o.Level503, _s_Level503, _ptr_Level503); err != nil {
		return err
	}
	return nil
}

// ShareEnum structure represents SHARE_ENUM_STRUCT RPC structure.
//
// The SHARE_ENUM_STRUCT structure specifies the information level that the client requests
// in the NetrShareEnum method and encapsulates the SHARE_ENUM_UNION union that receives
// the entries enumerated by the server.
type ShareEnum struct {
	// Level:  Specifies the information level of the data. This parameter MUST have one
	// of the following values.
	//
	//	+-------+--------------------------+
	//	|       |                          |
	//	| VALUE |         MEANING          |
	//	|       |                          |
	//	+-------+--------------------------+
	//	+-------+--------------------------+
	//	|     0 | SHARE_INFO_0_CONTAINER   |
	//	+-------+--------------------------+
	//	|     1 | SHARE_INFO_1_CONTAINER   |
	//	+-------+--------------------------+
	//	|     2 | SHARE_INFO_2_CONTAINER   |
	//	+-------+--------------------------+
	//	|   501 | SHARE_INFO_501_CONTAINER |
	//	+-------+--------------------------+
	//	|   502 | SHARE_INFO_502_CONTAINER |
	//	+-------+--------------------------+
	//	|   503 | SHARE_INFO_503_CONTAINER |
	//	+-------+--------------------------+
	Level uint32 `idl:"name:Level" json:"level"`
	// ShareInfo:  Contains a share information container whose type is specified by the
	// Level parameter as the preceding table shows. The enumerated share entries are returned
	// in this member.
	ShareInfo *ShareEnumUnion `idl:"name:ShareInfo;switch_is:Level" json:"share_info"`
}

func (o *ShareEnum) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareEnum) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.Level); err != nil {
		return err
	}
	_swShareInfo := uint32(o.Level)
	if o.ShareInfo != nil {
		if err := o.ShareInfo.MarshalUnionNDR(ctx, w, _swShareInfo); err != nil {
			return err
		}
	} else {
		if err := (&ShareEnumUnion{}).MarshalUnionNDR(ctx, w, _swShareInfo); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareEnum) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.Level); err != nil {
		return err
	}
	if o.ShareInfo == nil {
		o.ShareInfo = &ShareEnumUnion{}
	}
	_swShareInfo := uint32(o.Level)
	if err := o.ShareInfo.UnmarshalUnionNDR(ctx, w, _swShareInfo); err != nil {
		return err
	}
	return nil
}

// ShareInfo1004 structure represents SHARE_INFO_1004 RPC structure.
//
// The SHARE_INFO_1004 structure contains a comment that is associated with the shared
// resource. For a description of the fields in this structure, see the description
// for the SHARE_INFO_502_I (section 2.2.4.26) structure (shi1004_xxx denotes the same
// information as shi502_xxx).
type ShareInfo1004 struct {
	Shi1004Remark string `idl:"name:shi1004_remark;string" json:"shi1004_remark"`
}

func (o *ShareInfo1004) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareInfo1004) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(6); err != nil {
		return err
	}
	if o.Shi1004Remark != "" {
		_ptr_shi1004_remark := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Shi1004Remark); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Shi1004Remark, _ptr_shi1004_remark); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareInfo1004) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(6); err != nil {
		return err
	}
	_ptr_shi1004_remark := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Shi1004Remark); err != nil {
			return err
		}
		return nil
	})
	_s_shi1004_remark := func(ptr interface{}) { o.Shi1004Remark = *ptr.(*string) }
	if err := w.ReadPointer(&o.Shi1004Remark, _s_shi1004_remark, _ptr_shi1004_remark); err != nil {
		return err
	}
	return nil
}

// ShareInfo1006 structure represents SHARE_INFO_1006 RPC structure.
//
// The SHARE_INFO_1006 structure specifies the maximum number of concurrent connections
// that the shared resource can accommodate. For a description of the fields in this
// structure, see the description for the SHARE_INFO_502_I (section 2.2.4.26) structure
// (shi1006_xxx denotes the same information as shi502_xxx).
type ShareInfo1006 struct {
	MaxUses uint32 `idl:"name:shi1006_max_uses" json:"max_uses"`
}

func (o *ShareInfo1006) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareInfo1006) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxUses); err != nil {
		return err
	}
	return nil
}
func (o *ShareInfo1006) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxUses); err != nil {
		return err
	}
	return nil
}

// ShareInfo1005 structure represents SHARE_INFO_1005 RPC structure.
//
// The SHARE_INFO_1005 structure contains information about the shared resource.
type ShareInfo1005 struct {
	// shi1005_flags:   Specifies a DWORD bitmask value that MUST contain zero or more of
	// the following values. The bit locations that are named CSC_MASK in the following
	// table MUST contain a client-side caching state value as given in section 2.2.2.5.
	// The server MUST ignore SHI1005_FLAGS_DFS and SHI1005_FLAGS_DFS_ROOT as it processes
	// the NetrShareSetInfo method.
	//
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                                      |                                                                                  |
	//	|                        VALUE                         |                                     MEANING                                      |
	//	|                                                      |                                                                                  |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| SHI1005_FLAGS_DFS 0x00000001                         | The specified share is present in a DFS tree structure.                          |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| SHI1005_FLAGS_DFS_ROOT 0x00000002                    | The specified share is present in a DFS tree structure.                          |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| CSC_MASK 0x00000030                                  | Provides a mask for one of the four possible client-side caching (CSC) (section  |
	//	|                                                      | 2.2.2.5) states.                                                                 |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| SHI1005_FLAGS_RESTRICT_EXCLUSIVE_OPENS 0x00000100    | The specified share disallows exclusive file opens that deny reads to an open    |
	//	|                                                      | file.                                                                            |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| SHI1005_FLAGS_FORCE_SHARED_DELETE 0x00000200         | The specified share disallows clients from opening files on the share in an      |
	//	|                                                      | exclusive mode that prevents the file from being deleted until the client closes |
	//	|                                                      | the file.                                                                        |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| SHI1005_FLAGS_ALLOW_NAMESPACE_CACHING 0x00000400     | Clients are allowed to cache the namespace of the specified share.               |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| SHI1005_FLAGS_ACCESS_BASED_DIRECTORY_ENUM 0x00000800 | The server filters directory entries based on the access permissions of the      |
	//	|                                                      | client.<11>                                                                      |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| SHI1005_FLAGS_FORCE_LEVELII_OPLOCK 0x00001000        | The server does not issue exclusive caching rights on this share.<12>            |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| SHI1005_FLAGS_ENABLE_HASH 0x00002000                 | The share supports hash generation for branch cache retrieval of data. It is     |
	//	|                                                      | only valid if the server supports the branch cache capability and the branch     |
	//	|                                                      | cache component is installed.<13>                                                |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| SHI1005_FLAGS_ENABLE_CA 0x00004000                   | A highly available share.<14>                                                    |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| SHI1005_FLAGS_ENCRYPT_DATA 0x00008000                | A share on which remote file access is encrypted.<15>                            |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| SHI1005_FLAGS_COMPRESS_DATA 0x00100000               | A share on which remote file access is requested to be compressed.               |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	Flags uint32 `idl:"name:shi1005_flags" json:"flags"`
}

func (o *ShareInfo1005) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareInfo1005) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	return nil
}
func (o *ShareInfo1005) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	return nil
}

// ShareInfo structure represents SHARE_INFO RPC union.
//
// The SHARE_INFO union contains information about a share.
type ShareInfo struct {
	// Types that are assignable to Value
	//
	// *ShareInfo_0
	// *ShareInfo_1
	// *ShareInfo_2
	// *ShareInfo_502
	// *ShareInfo_1004
	// *ShareInfo_1006
	// *ShareInfo_1501
	// *ShareInfo_1005
	// *ShareInfo_501
	// *ShareInfo_503
	Value is_ShareInfo `json:"value"`
}

func (o *ShareInfo) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *ShareInfo_0:
		if value != nil {
			return value.ShareInfo0
		}
	case *ShareInfo_1:
		if value != nil {
			return value.ShareInfo1
		}
	case *ShareInfo_2:
		if value != nil {
			return value.ShareInfo2
		}
	case *ShareInfo_502:
		if value != nil {
			return value.ShareInfo502
		}
	case *ShareInfo_1004:
		if value != nil {
			return value.ShareInfo1004
		}
	case *ShareInfo_1006:
		if value != nil {
			return value.ShareInfo1006
		}
	case *ShareInfo_1501:
		if value != nil {
			return value.ShareInfo1501
		}
	case *ShareInfo_1005:
		if value != nil {
			return value.ShareInfo1005
		}
	case *ShareInfo_501:
		if value != nil {
			return value.ShareInfo501
		}
	case *ShareInfo_503:
		if value != nil {
			return value.ShareInfo503
		}
	}
	return nil
}

type is_ShareInfo interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_ShareInfo()
}

func (o *ShareInfo) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *ShareInfo_0:
		return uint32(0)
	case *ShareInfo_1:
		return uint32(1)
	case *ShareInfo_2:
		return uint32(2)
	case *ShareInfo_502:
		return uint32(502)
	case *ShareInfo_1004:
		return uint32(1004)
	case *ShareInfo_1006:
		return uint32(1006)
	case *ShareInfo_1501:
		return uint32(1501)
	case *ShareInfo_1005:
		return uint32(1005)
	case *ShareInfo_501:
		return uint32(501)
	case *ShareInfo_503:
		return uint32(503)
	}
	return uint32(0)
}

func (o *ShareInfo) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(0):
		_o, _ := o.Value.(*ShareInfo_0)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ShareInfo_0{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1):
		_o, _ := o.Value.(*ShareInfo_1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ShareInfo_1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(2):
		_o, _ := o.Value.(*ShareInfo_2)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ShareInfo_2{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(502):
		_o, _ := o.Value.(*ShareInfo_502)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ShareInfo_502{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1004):
		_o, _ := o.Value.(*ShareInfo_1004)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ShareInfo_1004{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1006):
		_o, _ := o.Value.(*ShareInfo_1006)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ShareInfo_1006{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1501):
		_o, _ := o.Value.(*ShareInfo_1501)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ShareInfo_1501{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1005):
		_o, _ := o.Value.(*ShareInfo_1005)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ShareInfo_1005{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(501):
		_o, _ := o.Value.(*ShareInfo_501)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ShareInfo_501{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(503):
		_o, _ := o.Value.(*ShareInfo_503)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ShareInfo_503{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
	}
	return nil
}

func (o *ShareInfo) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(0):
		o.Value = &ShareInfo_0{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1):
		o.Value = &ShareInfo_1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(2):
		o.Value = &ShareInfo_2{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(502):
		o.Value = &ShareInfo_502{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1004):
		o.Value = &ShareInfo_1004{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1006):
		o.Value = &ShareInfo_1006{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1501):
		o.Value = &ShareInfo_1501{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1005):
		o.Value = &ShareInfo_1005{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(501):
		o.Value = &ShareInfo_501{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(503):
		o.Value = &ShareInfo_503{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
	}
	return nil
}

// ShareInfo_0 structure represents SHARE_INFO RPC union arm.
//
// It has following labels: 0
type ShareInfo_0 struct {
	// ShareInfo0:  A pointer to a structure that contains information about a share, as
	// specified in section 2.2.4.22.
	ShareInfo0 *ShareInfo0 `idl:"name:ShareInfo0" json:"share_info0"`
}

func (*ShareInfo_0) is_ShareInfo() {}

func (o *ShareInfo_0) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ShareInfo0 != nil {
		_ptr_ShareInfo0 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ShareInfo0 != nil {
				if err := o.ShareInfo0.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ShareInfo0{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ShareInfo0, _ptr_ShareInfo0); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareInfo_0) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ShareInfo0 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ShareInfo0 == nil {
			o.ShareInfo0 = &ShareInfo0{}
		}
		if err := o.ShareInfo0.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ShareInfo0 := func(ptr interface{}) { o.ShareInfo0 = *ptr.(**ShareInfo0) }
	if err := w.ReadPointer(&o.ShareInfo0, _s_ShareInfo0, _ptr_ShareInfo0); err != nil {
		return err
	}
	return nil
}

// ShareInfo_1 structure represents SHARE_INFO RPC union arm.
//
// It has following labels: 1
type ShareInfo_1 struct {
	// ShareInfo1:  A pointer to a structure that contains information about a share, as
	// specified in section 2.2.4.23.
	ShareInfo1 *ShareInfo1 `idl:"name:ShareInfo1" json:"share_info1"`
}

func (*ShareInfo_1) is_ShareInfo() {}

func (o *ShareInfo_1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ShareInfo1 != nil {
		_ptr_ShareInfo1 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ShareInfo1 != nil {
				if err := o.ShareInfo1.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ShareInfo1{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ShareInfo1, _ptr_ShareInfo1); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareInfo_1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ShareInfo1 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ShareInfo1 == nil {
			o.ShareInfo1 = &ShareInfo1{}
		}
		if err := o.ShareInfo1.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ShareInfo1 := func(ptr interface{}) { o.ShareInfo1 = *ptr.(**ShareInfo1) }
	if err := w.ReadPointer(&o.ShareInfo1, _s_ShareInfo1, _ptr_ShareInfo1); err != nil {
		return err
	}
	return nil
}

// ShareInfo_2 structure represents SHARE_INFO RPC union arm.
//
// It has following labels: 2
type ShareInfo_2 struct {
	// ShareInfo2:  A pointer to a structure that contains information about a share, as
	// specified in section 2.2.4.24.
	ShareInfo2 *ShareInfo2 `idl:"name:ShareInfo2" json:"share_info2"`
}

func (*ShareInfo_2) is_ShareInfo() {}

func (o *ShareInfo_2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ShareInfo2 != nil {
		_ptr_ShareInfo2 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ShareInfo2 != nil {
				if err := o.ShareInfo2.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ShareInfo2{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ShareInfo2, _ptr_ShareInfo2); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareInfo_2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ShareInfo2 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ShareInfo2 == nil {
			o.ShareInfo2 = &ShareInfo2{}
		}
		if err := o.ShareInfo2.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ShareInfo2 := func(ptr interface{}) { o.ShareInfo2 = *ptr.(**ShareInfo2) }
	if err := w.ReadPointer(&o.ShareInfo2, _s_ShareInfo2, _ptr_ShareInfo2); err != nil {
		return err
	}
	return nil
}

// ShareInfo_502 structure represents SHARE_INFO RPC union arm.
//
// It has following labels: 502
type ShareInfo_502 struct {
	// ShareInfo502:  A pointer to a structure that contains information about a share,
	// as specified in section 2.2.4.26.
	ShareInfo502 *ShareInfo502I `idl:"name:ShareInfo502" json:"share_info502"`
}

func (*ShareInfo_502) is_ShareInfo() {}

func (o *ShareInfo_502) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ShareInfo502 != nil {
		_ptr_ShareInfo502 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ShareInfo502 != nil {
				if err := o.ShareInfo502.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ShareInfo502I{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ShareInfo502, _ptr_ShareInfo502); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareInfo_502) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ShareInfo502 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ShareInfo502 == nil {
			o.ShareInfo502 = &ShareInfo502I{}
		}
		if err := o.ShareInfo502.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ShareInfo502 := func(ptr interface{}) { o.ShareInfo502 = *ptr.(**ShareInfo502I) }
	if err := w.ReadPointer(&o.ShareInfo502, _s_ShareInfo502, _ptr_ShareInfo502); err != nil {
		return err
	}
	return nil
}

// ShareInfo_1004 structure represents SHARE_INFO RPC union arm.
//
// It has following labels: 1004
type ShareInfo_1004 struct {
	// ShareInfo1004:  A pointer to a structure that contains information about a share,
	// as specified in section 2.2.4.28.
	ShareInfo1004 *ShareInfo1004 `idl:"name:ShareInfo1004" json:"share_info1004"`
}

func (*ShareInfo_1004) is_ShareInfo() {}

func (o *ShareInfo_1004) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ShareInfo1004 != nil {
		_ptr_ShareInfo1004 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ShareInfo1004 != nil {
				if err := o.ShareInfo1004.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ShareInfo1004{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ShareInfo1004, _ptr_ShareInfo1004); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareInfo_1004) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ShareInfo1004 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ShareInfo1004 == nil {
			o.ShareInfo1004 = &ShareInfo1004{}
		}
		if err := o.ShareInfo1004.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ShareInfo1004 := func(ptr interface{}) { o.ShareInfo1004 = *ptr.(**ShareInfo1004) }
	if err := w.ReadPointer(&o.ShareInfo1004, _s_ShareInfo1004, _ptr_ShareInfo1004); err != nil {
		return err
	}
	return nil
}

// ShareInfo_1006 structure represents SHARE_INFO RPC union arm.
//
// It has following labels: 1006
type ShareInfo_1006 struct {
	// ShareInfo1006:  A pointer to a structure that contains information about a share,
	// as specified in section 2.2.4.30.
	ShareInfo1006 *ShareInfo1006 `idl:"name:ShareInfo1006" json:"share_info1006"`
}

func (*ShareInfo_1006) is_ShareInfo() {}

func (o *ShareInfo_1006) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ShareInfo1006 != nil {
		_ptr_ShareInfo1006 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ShareInfo1006 != nil {
				if err := o.ShareInfo1006.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ShareInfo1006{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ShareInfo1006, _ptr_ShareInfo1006); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareInfo_1006) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ShareInfo1006 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ShareInfo1006 == nil {
			o.ShareInfo1006 = &ShareInfo1006{}
		}
		if err := o.ShareInfo1006.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ShareInfo1006 := func(ptr interface{}) { o.ShareInfo1006 = *ptr.(**ShareInfo1006) }
	if err := w.ReadPointer(&o.ShareInfo1006, _s_ShareInfo1006, _ptr_ShareInfo1006); err != nil {
		return err
	}
	return nil
}

// ShareInfo_1501 structure represents SHARE_INFO RPC union arm.
//
// It has following labels: 1501
type ShareInfo_1501 struct {
	// ShareInfo1501:  A pointer to a structure that contains information about a share,
	// as specified in section 2.2.4.31.
	ShareInfo1501 *ShareInfo1501I `idl:"name:ShareInfo1501" json:"share_info1501"`
}

func (*ShareInfo_1501) is_ShareInfo() {}

func (o *ShareInfo_1501) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ShareInfo1501 != nil {
		_ptr_ShareInfo1501 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ShareInfo1501 != nil {
				if err := o.ShareInfo1501.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ShareInfo1501I{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ShareInfo1501, _ptr_ShareInfo1501); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareInfo_1501) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ShareInfo1501 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ShareInfo1501 == nil {
			o.ShareInfo1501 = &ShareInfo1501I{}
		}
		if err := o.ShareInfo1501.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ShareInfo1501 := func(ptr interface{}) { o.ShareInfo1501 = *ptr.(**ShareInfo1501I) }
	if err := w.ReadPointer(&o.ShareInfo1501, _s_ShareInfo1501, _ptr_ShareInfo1501); err != nil {
		return err
	}
	return nil
}

// ShareInfo_1005 structure represents SHARE_INFO RPC union arm.
//
// It has following labels: 1005
type ShareInfo_1005 struct {
	// ShareInfo1005:  A pointer to a structure that contains information about a share,
	// as specified in section 2.2.4.29.
	ShareInfo1005 *ShareInfo1005 `idl:"name:ShareInfo1005" json:"share_info1005"`
}

func (*ShareInfo_1005) is_ShareInfo() {}

func (o *ShareInfo_1005) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ShareInfo1005 != nil {
		_ptr_ShareInfo1005 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ShareInfo1005 != nil {
				if err := o.ShareInfo1005.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ShareInfo1005{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ShareInfo1005, _ptr_ShareInfo1005); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareInfo_1005) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ShareInfo1005 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ShareInfo1005 == nil {
			o.ShareInfo1005 = &ShareInfo1005{}
		}
		if err := o.ShareInfo1005.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ShareInfo1005 := func(ptr interface{}) { o.ShareInfo1005 = *ptr.(**ShareInfo1005) }
	if err := w.ReadPointer(&o.ShareInfo1005, _s_ShareInfo1005, _ptr_ShareInfo1005); err != nil {
		return err
	}
	return nil
}

// ShareInfo_501 structure represents SHARE_INFO RPC union arm.
//
// It has following labels: 501
type ShareInfo_501 struct {
	// ShareInfo501:  A pointer to a structure that contains information about a share,
	// as specified in section 2.2.4.25.
	ShareInfo501 *ShareInfo501 `idl:"name:ShareInfo501" json:"share_info501"`
}

func (*ShareInfo_501) is_ShareInfo() {}

func (o *ShareInfo_501) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ShareInfo501 != nil {
		_ptr_ShareInfo501 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ShareInfo501 != nil {
				if err := o.ShareInfo501.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ShareInfo501{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ShareInfo501, _ptr_ShareInfo501); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareInfo_501) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ShareInfo501 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ShareInfo501 == nil {
			o.ShareInfo501 = &ShareInfo501{}
		}
		if err := o.ShareInfo501.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ShareInfo501 := func(ptr interface{}) { o.ShareInfo501 = *ptr.(**ShareInfo501) }
	if err := w.ReadPointer(&o.ShareInfo501, _s_ShareInfo501, _ptr_ShareInfo501); err != nil {
		return err
	}
	return nil
}

// ShareInfo_503 structure represents SHARE_INFO RPC union arm.
//
// It has following labels: 503
type ShareInfo_503 struct {
	// ShareInfo503:  A pointer to a structure that contains information about a share,
	// as specified in section 2.2.4.27.
	ShareInfo503 *ShareInfo503I `idl:"name:ShareInfo503" json:"share_info503"`
}

func (*ShareInfo_503) is_ShareInfo() {}

func (o *ShareInfo_503) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ShareInfo503 != nil {
		_ptr_ShareInfo503 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ShareInfo503 != nil {
				if err := o.ShareInfo503.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ShareInfo503I{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ShareInfo503, _ptr_ShareInfo503); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareInfo_503) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ShareInfo503 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ShareInfo503 == nil {
			o.ShareInfo503 = &ShareInfo503I{}
		}
		if err := o.ShareInfo503.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ShareInfo503 := func(ptr interface{}) { o.ShareInfo503 = *ptr.(**ShareInfo503I) }
	if err := w.ReadPointer(&o.ShareInfo503, _s_ShareInfo503, _ptr_ShareInfo503); err != nil {
		return err
	}
	return nil
}

// ServerInfo102 structure represents SERVER_INFO_102 RPC structure.
//
// The SERVER_INFO_102 structure contains information about the specified server, including
// the name, platform, and type of server, attributes, and associated software. For
// information about the fields in this structure, see the description for the SERVER_INFO_103
// structure (sv102_xxx denotes the same information as sv103_xxx).
type ServerInfo102 struct {
	PlatformID    uint32 `idl:"name:sv102_platform_id" json:"platform_id"`
	Name          string `idl:"name:sv102_name;string" json:"name"`
	VersionMajor  uint32 `idl:"name:sv102_version_major" json:"version_major"`
	VersionMinor  uint32 `idl:"name:sv102_version_minor" json:"version_minor"`
	Type          uint32 `idl:"name:sv102_type" json:"type"`
	Comment       string `idl:"name:sv102_comment;string" json:"comment"`
	Users         uint32 `idl:"name:sv102_users" json:"users"`
	Disc          int32  `idl:"name:sv102_disc" json:"disc"`
	Hidden        int32  `idl:"name:sv102_hidden" json:"hidden"`
	Announce      uint32 `idl:"name:sv102_announce" json:"announce"`
	AnnounceDelta uint32 `idl:"name:sv102_anndelta" json:"announce_delta"`
	Licenses      uint32 `idl:"name:sv102_licenses" json:"licenses"`
	UserPath      string `idl:"name:sv102_userpath;string" json:"user_path"`
}

func (o *ServerInfo102) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo102) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.PlatformID); err != nil {
		return err
	}
	if o.Name != "" {
		_ptr_sv102_name := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Name); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Name, _ptr_sv102_name); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.VersionMajor); err != nil {
		return err
	}
	if err := w.WriteData(o.VersionMinor); err != nil {
		return err
	}
	if err := w.WriteData(o.Type); err != nil {
		return err
	}
	if o.Comment != "" {
		_ptr_sv102_comment := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Comment); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Comment, _ptr_sv102_comment); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Users); err != nil {
		return err
	}
	if err := w.WriteData(o.Disc); err != nil {
		return err
	}
	if err := w.WriteData(o.Hidden); err != nil {
		return err
	}
	if err := w.WriteData(o.Announce); err != nil {
		return err
	}
	if err := w.WriteData(o.AnnounceDelta); err != nil {
		return err
	}
	if err := w.WriteData(o.Licenses); err != nil {
		return err
	}
	if o.UserPath != "" {
		_ptr_sv102_userpath := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.UserPath); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.UserPath, _ptr_sv102_userpath); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo102) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.PlatformID); err != nil {
		return err
	}
	_ptr_sv102_name := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Name); err != nil {
			return err
		}
		return nil
	})
	_s_sv102_name := func(ptr interface{}) { o.Name = *ptr.(*string) }
	if err := w.ReadPointer(&o.Name, _s_sv102_name, _ptr_sv102_name); err != nil {
		return err
	}
	if err := w.ReadData(&o.VersionMajor); err != nil {
		return err
	}
	if err := w.ReadData(&o.VersionMinor); err != nil {
		return err
	}
	if err := w.ReadData(&o.Type); err != nil {
		return err
	}
	_ptr_sv102_comment := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Comment); err != nil {
			return err
		}
		return nil
	})
	_s_sv102_comment := func(ptr interface{}) { o.Comment = *ptr.(*string) }
	if err := w.ReadPointer(&o.Comment, _s_sv102_comment, _ptr_sv102_comment); err != nil {
		return err
	}
	if err := w.ReadData(&o.Users); err != nil {
		return err
	}
	if err := w.ReadData(&o.Disc); err != nil {
		return err
	}
	if err := w.ReadData(&o.Hidden); err != nil {
		return err
	}
	if err := w.ReadData(&o.Announce); err != nil {
		return err
	}
	if err := w.ReadData(&o.AnnounceDelta); err != nil {
		return err
	}
	if err := w.ReadData(&o.Licenses); err != nil {
		return err
	}
	_ptr_sv102_userpath := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.UserPath); err != nil {
			return err
		}
		return nil
	})
	_s_sv102_userpath := func(ptr interface{}) { o.UserPath = *ptr.(*string) }
	if err := w.ReadPointer(&o.UserPath, _s_sv102_userpath, _ptr_sv102_userpath); err != nil {
		return err
	}
	return nil
}

// ServerInfo103 structure represents SERVER_INFO_103 RPC structure.
//
// The SERVER_INFO_103 structure contains information about CIFS and SMB Version 1.0
// file servers, including the name, platform, type of server, attributes, associated
// software, and capabilities.
type ServerInfo103 struct {
	// sv103_platform_id:  Specifies the information level to use for platform-specific
	// information. This member can be one of the values that are listed in PLATFORM IDs
	// (section 2.2.2.6). The server MUST ignore this field during a NetrServerSetInfo operation.
	PlatformID uint32 `idl:"name:sv103_platform_id" json:"platform_id"`
	// sv103_name:  A pointer to a null-terminated Unicode UTF-16 Internet host name or
	// NetBIOS host name of a server.
	Name string `idl:"name:sv103_name;string" json:"name"`
	// sv103_version_major:  Specifies the major release version number of the operating
	// system. The server MUST ignore this field during a NetrServerSetInfo operation. The
	// server MUST set this field to an implementation-specific major release version number
	// that corresponds to the host operating system on a NetrServerGetInfo operation.<17>
	VersionMajor uint32 `idl:"name:sv103_version_major" json:"version_major"`
	// sv103_version_minor:  Specifies the minor release version number of the operating
	// system. The server MUST ignore this field during a NetrServerSetInfo operation. The
	// server MUST set this field to an implementation-specific minor release version number
	// that corresponds to the host operating system on a NetrServerGetInfo operation.<18>
	VersionMinor uint32 `idl:"name:sv103_version_minor" json:"version_minor"`
	// sv103_type:  Specifies the type of software the computer is running. This member
	// MUST be a combination of one or more of the values that are listed in section 2.2.2.7.
	// The server MUST ignore this field during a NetrServerSetInfo operation.
	Type uint32 `idl:"name:sv103_type" json:"type"`
	// sv103_comment:  An optional pointer to a null-terminated Unicode UTF-16 string that
	// specifies a comment that describes the server.
	Comment string `idl:"name:sv103_comment;string" json:"comment"`
	// sv103_users:  Specifies the number of users who can attempt to log on to the server.
	// The range of values MUST be from 0x00000001 to 0xFFFFFFFF, inclusive. The server
	// enforces a ceiling, based on the particular SKU that is running on the server, by
	// taking a minimum of the specified value and the ceiling.
	Users uint32 `idl:"name:sv103_users" json:"users"`
	// sv103_disc:  Specifies the automatic disconnect time, in minutes. A session MUST
	// be disconnected if it is idle longer than the period of time that the sv103_disc
	// member specifies. If the value of sv103_disc is SV_NODISC (0xFFFFFFFF), an automatic
	// disconnect MUST NOT be enabled. The range of values MUST be from 0x00000001 to 0xFFFFFFFF,
	// inclusive.
	Disc int32 `idl:"name:sv103_disc" json:"disc"`
	// sv103_hidden:  A Boolean that specifies whether the server is hidden or visible to
	// other computers in the same network domain. It MUST be set to TRUE (1) to indicate
	// that the server is hidden; or it MUST be set to FALSE (0) to indicate that the server
	// is visible. The default value is FALSE (0).
	Hidden bool `idl:"name:sv103_hidden" json:"hidden"`
	// sv103_announce:  Specifies the network announce rate, in seconds. This rate determines
	// how often the server is announced to other computers on the network for discovery
	// by using the CIFS Browser Protocol. For more information, see [MS-BRWS]. The range
	// of values MUST be from 1 to 65535, inclusive.
	Announce uint32 `idl:"name:sv103_announce" json:"announce"`
	// sv103_anndelta:  Specifies the delta value for the announce rate, in milliseconds.
	// This value specifies how much the announce rate can vary from the period of time
	// that is specified in the sv103_announce member. The delta value enables the server
	// to set randomly varied announce rates in the range sv103_announce to sv103_announce+sv103_anndelta,
	// inclusive, to prevent many servers from announcing at the same time. The range of
	// values MUST be from 0 to 65535, inclusive.
	AnnounceDelta uint32 `idl:"name:sv103_anndelta" json:"announce_delta"`
	// sv103_licenses:  Unused. The server MUST ignore this field during a NetrServerSetInfo
	// operation. The server MUST return 0 during a NetrServerGetInfo operation.
	Licenses uint32 `idl:"name:sv103_licenses" json:"licenses"`
	// sv103_userpath:  A pointer to a null-terminated Unicode UTF-16 string that specifies
	// the path to the user directories. Due to historical reasons, the default path is
	// "c:\". The client can set this field to any value. The server stores this string
	// and returns it when queried. This field has no effect on the server.
	UserPath string `idl:"name:sv103_userpath;string" json:"user_path"`
	// sv103_capabilities:  Specifies the capabilities of the server. This MUST be a combination
	// of zero or more of the following flags. The server MUST ignore this field during
	// a NetrServerSetInfo operation. If the server does not support any of the following
	// capabilities, it MUST set this field to 0x0000.
	//
	//	+------------------------------------+----------------------------------------------------------------------------+
	//	|                                    |                                                                            |
	//	|               VALUE                |                                  MEANING                                   |
	//	|                                    |                                                                            |
	//	+------------------------------------+----------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------+
	//	| SRV_SUPPORT_HASH_GENERATION 0x0001 | Hash generation for branch cache functionality is supported by the server. |
	//	+------------------------------------+----------------------------------------------------------------------------+
	//	| SRV_HASH_GENERATION_ACTIVE 0x0002  | The branch cache component is installed.<19>                               |
	//	+------------------------------------+----------------------------------------------------------------------------+
	Capabilities uint32 `idl:"name:sv103_capabilities" json:"capabilities"`
}

func (o *ServerInfo103) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo103) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.PlatformID); err != nil {
		return err
	}
	if o.Name != "" {
		_ptr_sv103_name := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Name); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Name, _ptr_sv103_name); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.VersionMajor); err != nil {
		return err
	}
	if err := w.WriteData(o.VersionMinor); err != nil {
		return err
	}
	if err := w.WriteData(o.Type); err != nil {
		return err
	}
	if o.Comment != "" {
		_ptr_sv103_comment := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Comment); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Comment, _ptr_sv103_comment); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Users); err != nil {
		return err
	}
	if err := w.WriteData(o.Disc); err != nil {
		return err
	}
	if !o.Hidden {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Announce); err != nil {
		return err
	}
	if err := w.WriteData(o.AnnounceDelta); err != nil {
		return err
	}
	if err := w.WriteData(o.Licenses); err != nil {
		return err
	}
	if o.UserPath != "" {
		_ptr_sv103_userpath := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.UserPath); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.UserPath, _ptr_sv103_userpath); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Capabilities); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo103) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.PlatformID); err != nil {
		return err
	}
	_ptr_sv103_name := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Name); err != nil {
			return err
		}
		return nil
	})
	_s_sv103_name := func(ptr interface{}) { o.Name = *ptr.(*string) }
	if err := w.ReadPointer(&o.Name, _s_sv103_name, _ptr_sv103_name); err != nil {
		return err
	}
	if err := w.ReadData(&o.VersionMajor); err != nil {
		return err
	}
	if err := w.ReadData(&o.VersionMinor); err != nil {
		return err
	}
	if err := w.ReadData(&o.Type); err != nil {
		return err
	}
	_ptr_sv103_comment := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Comment); err != nil {
			return err
		}
		return nil
	})
	_s_sv103_comment := func(ptr interface{}) { o.Comment = *ptr.(*string) }
	if err := w.ReadPointer(&o.Comment, _s_sv103_comment, _ptr_sv103_comment); err != nil {
		return err
	}
	if err := w.ReadData(&o.Users); err != nil {
		return err
	}
	if err := w.ReadData(&o.Disc); err != nil {
		return err
	}
	var _bHidden int32
	if err := w.ReadData(&_bHidden); err != nil {
		return err
	}
	o.Hidden = _bHidden != 0
	if err := w.ReadData(&o.Announce); err != nil {
		return err
	}
	if err := w.ReadData(&o.AnnounceDelta); err != nil {
		return err
	}
	if err := w.ReadData(&o.Licenses); err != nil {
		return err
	}
	_ptr_sv103_userpath := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.UserPath); err != nil {
			return err
		}
		return nil
	})
	_s_sv103_userpath := func(ptr interface{}) { o.UserPath = *ptr.(*string) }
	if err := w.ReadPointer(&o.UserPath, _s_sv103_userpath, _ptr_sv103_userpath); err != nil {
		return err
	}
	if err := w.ReadData(&o.Capabilities); err != nil {
		return err
	}
	return nil
}

// ServerInfo502 structure represents SERVER_INFO_502 RPC structure.
//
// The SERVER_INFO_502 structure contains information about a specified server. For
// a description of the fields in this structure, see the description for the SERVER_INFO_599
// structure (sv502_xxx denotes the same information as sv599_xxx).
type ServerInfo502 struct {
	SessionOpens            uint32 `idl:"name:sv502_sessopens" json:"session_opens"`
	SessionServices         uint32 `idl:"name:sv502_sessvcs" json:"session_services"`
	OpenSearch              uint32 `idl:"name:sv502_opensearch" json:"open_search"`
	SizeRequestBuffer       uint32 `idl:"name:sv502_sizreqbuf" json:"size_request_buffer"`
	InitWorkItems           uint32 `idl:"name:sv502_initworkitems" json:"init_work_items"`
	MaxWorkItems            uint32 `idl:"name:sv502_maxworkitems" json:"max_work_items"`
	RawWorkItems            uint32 `idl:"name:sv502_rawworkitems" json:"raw_work_items"`
	IRPStackSize            uint32 `idl:"name:sv502_irpstacksize" json:"irp_stack_size"`
	MaxRawBufferLength      uint32 `idl:"name:sv502_maxrawbuflen" json:"max_raw_buffer_length"`
	SessionUsers            uint32 `idl:"name:sv502_sessusers" json:"session_users"`
	SessionConnections      uint32 `idl:"name:sv502_sessconns" json:"session_connections"`
	MaxPagedMemoryUsage     uint32 `idl:"name:sv502_maxpagedmemoryusage" json:"max_paged_memory_usage"`
	MaxNonPagedMemoryUsage  uint32 `idl:"name:sv502_maxnonpagedmemoryusage" json:"max_non_paged_memory_usage"`
	EnableSoftCompatibility int32  `idl:"name:sv502_enablesoftcompat" json:"enable_soft_compatibility"`
	EnableForcedLogoff      int32  `idl:"name:sv502_enableforcedlogoff" json:"enable_forced_logoff"`
	TimeSource              int32  `idl:"name:sv502_timesource" json:"time_source"`
	AcceptDownLevelAPIs     int32  `idl:"name:sv502_acceptdownlevelapis" json:"accept_down_level_apis"`
	LMAnnounce              int32  `idl:"name:sv502_lmannounce" json:"lm_announce"`
}

func (o *ServerInfo502) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo502) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.SessionOpens); err != nil {
		return err
	}
	if err := w.WriteData(o.SessionServices); err != nil {
		return err
	}
	if err := w.WriteData(o.OpenSearch); err != nil {
		return err
	}
	if err := w.WriteData(o.SizeRequestBuffer); err != nil {
		return err
	}
	if err := w.WriteData(o.InitWorkItems); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxWorkItems); err != nil {
		return err
	}
	if err := w.WriteData(o.RawWorkItems); err != nil {
		return err
	}
	if err := w.WriteData(o.IRPStackSize); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxRawBufferLength); err != nil {
		return err
	}
	if err := w.WriteData(o.SessionUsers); err != nil {
		return err
	}
	if err := w.WriteData(o.SessionConnections); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxPagedMemoryUsage); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxNonPagedMemoryUsage); err != nil {
		return err
	}
	if err := w.WriteData(o.EnableSoftCompatibility); err != nil {
		return err
	}
	if err := w.WriteData(o.EnableForcedLogoff); err != nil {
		return err
	}
	if err := w.WriteData(o.TimeSource); err != nil {
		return err
	}
	if err := w.WriteData(o.AcceptDownLevelAPIs); err != nil {
		return err
	}
	if err := w.WriteData(o.LMAnnounce); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo502) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.SessionOpens); err != nil {
		return err
	}
	if err := w.ReadData(&o.SessionServices); err != nil {
		return err
	}
	if err := w.ReadData(&o.OpenSearch); err != nil {
		return err
	}
	if err := w.ReadData(&o.SizeRequestBuffer); err != nil {
		return err
	}
	if err := w.ReadData(&o.InitWorkItems); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxWorkItems); err != nil {
		return err
	}
	if err := w.ReadData(&o.RawWorkItems); err != nil {
		return err
	}
	if err := w.ReadData(&o.IRPStackSize); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxRawBufferLength); err != nil {
		return err
	}
	if err := w.ReadData(&o.SessionUsers); err != nil {
		return err
	}
	if err := w.ReadData(&o.SessionConnections); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxPagedMemoryUsage); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxNonPagedMemoryUsage); err != nil {
		return err
	}
	if err := w.ReadData(&o.EnableSoftCompatibility); err != nil {
		return err
	}
	if err := w.ReadData(&o.EnableForcedLogoff); err != nil {
		return err
	}
	if err := w.ReadData(&o.TimeSource); err != nil {
		return err
	}
	if err := w.ReadData(&o.AcceptDownLevelAPIs); err != nil {
		return err
	}
	if err := w.ReadData(&o.LMAnnounce); err != nil {
		return err
	}
	return nil
}

// ServerInfo503 structure represents SERVER_INFO_503 RPC structure.
//
// The SERVER_INFO_503 structure contains information about a specified server. For
// a description of the fields in this structure, see the description for the SERVER_INFO_599
// structure (sv503_xxx denotes the same information as sv599_xxx).
type ServerInfo503 struct {
	SessionOpens                   uint32 `idl:"name:sv503_sessopens" json:"session_opens"`
	SessionServices                uint32 `idl:"name:sv503_sessvcs" json:"session_services"`
	OpenSearch                     uint32 `idl:"name:sv503_opensearch" json:"open_search"`
	SizeRequestBuffer              uint32 `idl:"name:sv503_sizreqbuf" json:"size_request_buffer"`
	InitWorkItems                  uint32 `idl:"name:sv503_initworkitems" json:"init_work_items"`
	MaxWorkItems                   uint32 `idl:"name:sv503_maxworkitems" json:"max_work_items"`
	RawWorkItems                   uint32 `idl:"name:sv503_rawworkitems" json:"raw_work_items"`
	IRPStackSize                   uint32 `idl:"name:sv503_irpstacksize" json:"irp_stack_size"`
	MaxRawBufferLength             uint32 `idl:"name:sv503_maxrawbuflen" json:"max_raw_buffer_length"`
	SessionUsers                   uint32 `idl:"name:sv503_sessusers" json:"session_users"`
	SessionConnections             uint32 `idl:"name:sv503_sessconns" json:"session_connections"`
	MaxPagedMemoryUsage            uint32 `idl:"name:sv503_maxpagedmemoryusage" json:"max_paged_memory_usage"`
	MaxNonPagedMemoryUsage         uint32 `idl:"name:sv503_maxnonpagedmemoryusage" json:"max_non_paged_memory_usage"`
	EnableSoftCompatibility        int32  `idl:"name:sv503_enablesoftcompat" json:"enable_soft_compatibility"`
	EnableForcedLogoff             int32  `idl:"name:sv503_enableforcedlogoff" json:"enable_forced_logoff"`
	TimeSource                     int32  `idl:"name:sv503_timesource" json:"time_source"`
	AcceptDownLevelAPIs            int32  `idl:"name:sv503_acceptdownlevelapis" json:"accept_down_level_apis"`
	LMAnnounce                     int32  `idl:"name:sv503_lmannounce" json:"lm_announce"`
	Domain                         string `idl:"name:sv503_domain;string" json:"domain"`
	MaxCopyReadLength              uint32 `idl:"name:sv503_maxcopyreadlen" json:"max_copy_read_length"`
	MaxCopyWriteLength             uint32 `idl:"name:sv503_maxcopywritelen" json:"max_copy_write_length"`
	MinKeepSearch                  uint32 `idl:"name:sv503_minkeepsearch" json:"min_keep_search"`
	MaxKeepSearch                  uint32 `idl:"name:sv503_maxkeepsearch" json:"max_keep_search"`
	MinKeepComplSearch             uint32 `idl:"name:sv503_minkeepcomplsearch" json:"min_keep_compl_search"`
	MaxKeepComplSearch             uint32 `idl:"name:sv503_maxkeepcomplsearch" json:"max_keep_compl_search"`
	ThreadCountAdd                 uint32 `idl:"name:sv503_threadcountadd" json:"thread_count_add"`
	NumBlockThreads                uint32 `idl:"name:sv503_numblockthreads" json:"num_block_threads"`
	ScavTimeout                    uint32 `idl:"name:sv503_scavtimeout" json:"scav_timeout"`
	MinReceiveQueue                uint32 `idl:"name:sv503_minrcvqueue" json:"min_receive_queue"`
	MinFreeWorkItems               uint32 `idl:"name:sv503_minfreeworkitems" json:"min_free_work_items"`
	ExactMemSize                   uint32 `idl:"name:sv503_xactmemsize" json:"exact_mem_size"`
	ThreadPriority                 uint32 `idl:"name:sv503_threadpriority" json:"thread_priority"`
	MaxMPXCount                    uint32 `idl:"name:sv503_maxmpxct" json:"max_mpx_count"`
	OperationLockBreakWait         uint32 `idl:"name:sv503_oplockbreakwait" json:"operation_lock_break_wait"`
	OperationLockBreakResponseWait uint32 `idl:"name:sv503_oplockbreakresponsewait" json:"operation_lock_break_response_wait"`
	EnableOperationLocks           int32  `idl:"name:sv503_enableoplocks" json:"enable_operation_locks"`
	Enableoplockforceclose         int32  `idl:"name:sv503_enableoplockforceclose" json:"enableoplockforceclose"`
	EnableFCBOpens                 int32  `idl:"name:sv503_enablefcbopens" json:"enable_fcb_opens"`
	EnableRaw                      int32  `idl:"name:sv503_enableraw" json:"enable_raw"`
	EnableSharedNetDrives          int32  `idl:"name:sv503_enablesharednetdrives" json:"enable_shared_net_drives"`
	MinFreeConnections             uint32 `idl:"name:sv503_minfreeconnections" json:"min_free_connections"`
	MaxFreeConnections             uint32 `idl:"name:sv503_maxfreeconnections" json:"max_free_connections"`
}

func (o *ServerInfo503) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo503) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.SessionOpens); err != nil {
		return err
	}
	if err := w.WriteData(o.SessionServices); err != nil {
		return err
	}
	if err := w.WriteData(o.OpenSearch); err != nil {
		return err
	}
	if err := w.WriteData(o.SizeRequestBuffer); err != nil {
		return err
	}
	if err := w.WriteData(o.InitWorkItems); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxWorkItems); err != nil {
		return err
	}
	if err := w.WriteData(o.RawWorkItems); err != nil {
		return err
	}
	if err := w.WriteData(o.IRPStackSize); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxRawBufferLength); err != nil {
		return err
	}
	if err := w.WriteData(o.SessionUsers); err != nil {
		return err
	}
	if err := w.WriteData(o.SessionConnections); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxPagedMemoryUsage); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxNonPagedMemoryUsage); err != nil {
		return err
	}
	if err := w.WriteData(o.EnableSoftCompatibility); err != nil {
		return err
	}
	if err := w.WriteData(o.EnableForcedLogoff); err != nil {
		return err
	}
	if err := w.WriteData(o.TimeSource); err != nil {
		return err
	}
	if err := w.WriteData(o.AcceptDownLevelAPIs); err != nil {
		return err
	}
	if err := w.WriteData(o.LMAnnounce); err != nil {
		return err
	}
	if o.Domain != "" {
		_ptr_sv503_domain := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Domain); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Domain, _ptr_sv503_domain); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.MaxCopyReadLength); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxCopyWriteLength); err != nil {
		return err
	}
	if err := w.WriteData(o.MinKeepSearch); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxKeepSearch); err != nil {
		return err
	}
	if err := w.WriteData(o.MinKeepComplSearch); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxKeepComplSearch); err != nil {
		return err
	}
	if err := w.WriteData(o.ThreadCountAdd); err != nil {
		return err
	}
	if err := w.WriteData(o.NumBlockThreads); err != nil {
		return err
	}
	if err := w.WriteData(o.ScavTimeout); err != nil {
		return err
	}
	if err := w.WriteData(o.MinReceiveQueue); err != nil {
		return err
	}
	if err := w.WriteData(o.MinFreeWorkItems); err != nil {
		return err
	}
	if err := w.WriteData(o.ExactMemSize); err != nil {
		return err
	}
	if err := w.WriteData(o.ThreadPriority); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxMPXCount); err != nil {
		return err
	}
	if err := w.WriteData(o.OperationLockBreakWait); err != nil {
		return err
	}
	if err := w.WriteData(o.OperationLockBreakResponseWait); err != nil {
		return err
	}
	if err := w.WriteData(o.EnableOperationLocks); err != nil {
		return err
	}
	if err := w.WriteData(o.Enableoplockforceclose); err != nil {
		return err
	}
	if err := w.WriteData(o.EnableFCBOpens); err != nil {
		return err
	}
	if err := w.WriteData(o.EnableRaw); err != nil {
		return err
	}
	if err := w.WriteData(o.EnableSharedNetDrives); err != nil {
		return err
	}
	if err := w.WriteData(o.MinFreeConnections); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxFreeConnections); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo503) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.SessionOpens); err != nil {
		return err
	}
	if err := w.ReadData(&o.SessionServices); err != nil {
		return err
	}
	if err := w.ReadData(&o.OpenSearch); err != nil {
		return err
	}
	if err := w.ReadData(&o.SizeRequestBuffer); err != nil {
		return err
	}
	if err := w.ReadData(&o.InitWorkItems); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxWorkItems); err != nil {
		return err
	}
	if err := w.ReadData(&o.RawWorkItems); err != nil {
		return err
	}
	if err := w.ReadData(&o.IRPStackSize); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxRawBufferLength); err != nil {
		return err
	}
	if err := w.ReadData(&o.SessionUsers); err != nil {
		return err
	}
	if err := w.ReadData(&o.SessionConnections); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxPagedMemoryUsage); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxNonPagedMemoryUsage); err != nil {
		return err
	}
	if err := w.ReadData(&o.EnableSoftCompatibility); err != nil {
		return err
	}
	if err := w.ReadData(&o.EnableForcedLogoff); err != nil {
		return err
	}
	if err := w.ReadData(&o.TimeSource); err != nil {
		return err
	}
	if err := w.ReadData(&o.AcceptDownLevelAPIs); err != nil {
		return err
	}
	if err := w.ReadData(&o.LMAnnounce); err != nil {
		return err
	}
	_ptr_sv503_domain := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Domain); err != nil {
			return err
		}
		return nil
	})
	_s_sv503_domain := func(ptr interface{}) { o.Domain = *ptr.(*string) }
	if err := w.ReadPointer(&o.Domain, _s_sv503_domain, _ptr_sv503_domain); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxCopyReadLength); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxCopyWriteLength); err != nil {
		return err
	}
	if err := w.ReadData(&o.MinKeepSearch); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxKeepSearch); err != nil {
		return err
	}
	if err := w.ReadData(&o.MinKeepComplSearch); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxKeepComplSearch); err != nil {
		return err
	}
	if err := w.ReadData(&o.ThreadCountAdd); err != nil {
		return err
	}
	if err := w.ReadData(&o.NumBlockThreads); err != nil {
		return err
	}
	if err := w.ReadData(&o.ScavTimeout); err != nil {
		return err
	}
	if err := w.ReadData(&o.MinReceiveQueue); err != nil {
		return err
	}
	if err := w.ReadData(&o.MinFreeWorkItems); err != nil {
		return err
	}
	if err := w.ReadData(&o.ExactMemSize); err != nil {
		return err
	}
	if err := w.ReadData(&o.ThreadPriority); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxMPXCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.OperationLockBreakWait); err != nil {
		return err
	}
	if err := w.ReadData(&o.OperationLockBreakResponseWait); err != nil {
		return err
	}
	if err := w.ReadData(&o.EnableOperationLocks); err != nil {
		return err
	}
	if err := w.ReadData(&o.Enableoplockforceclose); err != nil {
		return err
	}
	if err := w.ReadData(&o.EnableFCBOpens); err != nil {
		return err
	}
	if err := w.ReadData(&o.EnableRaw); err != nil {
		return err
	}
	if err := w.ReadData(&o.EnableSharedNetDrives); err != nil {
		return err
	}
	if err := w.ReadData(&o.MinFreeConnections); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxFreeConnections); err != nil {
		return err
	}
	return nil
}

// ServerInfo599 structure represents SERVER_INFO_599 RPC structure.
//
// The SERVER_INFO_599 structure contains information about a specified server. The
// SERVER_INFO_599 fields involve implementation-specific details of CIFS and SMB Version
// 1.0 file servers. These fields can vary in how they apply to any given implementation.
// For more information, see section 3.1.4.18.
type ServerInfo599 struct {
	// sv599_sessopens:  Specifies the number of files that can be open in one session.
	// The range of values MUST be from 1 to 16384, inclusive.<20>
	SessionOpens uint32 `idl:"name:sv599_sessopens" json:"session_opens"`
	// sv599_sessvcs:  Specifies the maximum number of sessions that are permitted per client.
	// This value MUST be set to one.
	SessionServices uint32 `idl:"name:sv599_sessvcs" json:"session_services"`
	// sv599_opensearch:  Specifies the number of search operations that can be carried
	// out simultaneously. The range of values MUST be from 1 to 2,048, inclusive.
	OpenSearch uint32 `idl:"name:sv599_opensearch" json:"open_search"`
	// sv599_sizreqbuf:  Specifies the size, in bytes, of each server buffer. This field
	// MUST be ignored by the server on receipt for set operations. The range of values
	// MUST be 1,024 to 65,535, inclusive.<21>
	SizeRequestBuffer uint32 `idl:"name:sv599_sizreqbuf" json:"size_request_buffer"`
	// sv599_initworkitems:  Specifies the initial number of receive buffers, or work items,
	// that the server uses. The range of values for get operations MUST be from 1 to 512,
	// inclusive. This field MUST be ignored by the server on receipt for set operations.
	InitWorkItems uint32 `idl:"name:sv599_initworkitems" json:"init_work_items"`
	// sv599_maxworkitems:  Specifies the maximum number of receive buffers, or work items,
	// that the server can allocate. If this limit is reached, the transport MUST initiate
	// flow control. The range of values MUST be from 1 to 65,535, inclusive. The server
	// enforces a ceiling based on the particular SKU that is running on the server by taking
	// a minimum specified value and the ceiling.
	MaxWorkItems uint32 `idl:"name:sv599_maxworkitems" json:"max_work_items"`
	// sv599_rawworkitems:  Specifies the number of special work items the server uses for
	// raw mode I/O. A larger value for this member can increase performance, but it requires
	// more memory. The range of values for get operations MUST be from 1 to 512, inclusive.
	// This field MUST be ignored by the server on receipt for set operations.
	RawWorkItems uint32 `idl:"name:sv599_rawworkitems" json:"raw_work_items"`
	// sv599_irpstacksize:  Specifies the number of stack locations that the server allocated
	// in I/O request packets (IRPs). This field MUST be ignored by the server on receipt
	// for set operations. The range of values MUST be 11 to 50, inclusive.<22>
	IRPStackSize uint32 `idl:"name:sv599_irpstacksize" json:"irp_stack_size"`
	// sv599_maxrawbuflen:  The server MUST validate the value on receipt. This value MUST
	// be set to 65,535. Due to historical reasons, the server does not store this value.
	MaxRawBufferLength uint32 `idl:"name:sv599_maxrawbuflen" json:"max_raw_buffer_length"`
	// sv599_sessusers:  Specifies the maximum number of users who can be logged on to the
	// server in a single connection. The range of values MUST be from 1 to 2,048, inclusive.
	SessionUsers uint32 `idl:"name:sv599_sessusers" json:"session_users"`
	// sv599_sessconns:  Specifies the maximum number of tree connections that can be made
	// on the server in a single session. The range of values MUST be from 1 to 2,048, inclusive.
	SessionConnections uint32 `idl:"name:sv599_sessconns" json:"session_connections"`
	// sv599_maxpagedmemoryusage:  Specifies the maximum size of pageable memory, in bytes,
	// that the server can allocate at any one time. The range of values MUST be from 0x00400000
	// to 0xFFFFFFFF, inclusive.<23>
	MaxPagedMemoryUsage uint32 `idl:"name:sv599_maxpagedmemoryusage" json:"max_paged_memory_usage"`
	// sv599_maxnonpagedmemoryusage:  Specifies the maximum size of nonpaged memory in bytes
	// that the server can allocate at any one time. The range of values MUST be from 0x00400000
	// to 0xFFFFFFFF, inclusive.<24>
	MaxNonPagedMemoryUsage uint32 `idl:"name:sv599_maxnonpagedmemoryusage" json:"max_non_paged_memory_usage"`
	// sv599_enablesoftcompat:  A Boolean that specifies the SoftCompatibility capability
	// of the server. This field MUST be set to TRUE (1) to enable the SoftCompatibility
	// feature, or it MUST be set to FALSE (0) to disable the SoftCompatibility feature.
	// The default value is TRUE (1). This setting affects the open mode when the client
	// does not have read/write permission to the file it is accessing. If this feature
	// is enabled, the server uses share access (parameter to CreateFile) equal to FILE_SHARE_READ
	// and does not mark the open as compatibility mode open; otherwise, share access is
	// set equal to 0, and the open is marked as compatibility mode open.
	EnableSoftCompatibility int32 `idl:"name:sv599_enablesoftcompat" json:"enable_soft_compatibility"`
	// sv599_enableforcedlogoff:  A Boolean that specifies whether or not the server forces
	// a client to disconnect, even if the client has open files, after the client's logon
	// time has expired. This field MUST be set to TRUE (1) for the server to force a client
	// to disconnect under those circumstances, or it MUST be set to FALSE (0) for the server
	// not to force a client to disconnect under those circumstances. The default value
	// is TRUE (1).
	EnableForcedLogoff int32 `idl:"name:sv599_enableforcedlogoff" json:"enable_forced_logoff"`
	// sv599_timesource:  A Boolean that specifies whether the server is a reliable time
	// source.
	TimeSource int32 `idl:"name:sv599_timesource" json:"time_source"`
	// sv599_acceptdownlevelapis:  A Boolean that specifies whether the server accepts method
	// calls from previous-generation NTLM clients. This field MUST be set to TRUE (1) to
	// enable the server to accept method calls from previous-generation NTLM clients, or
	// it MUST be set to FALSE (0) to disable the server from accepting method calls from
	// previous NTLM clients. The default value is TRUE (1). This field MUST be ignored
	// by the server on receipt.
	AcceptDownLevelAPIs int32 `idl:"name:sv599_acceptdownlevelapis" json:"accept_down_level_apis"`
	// sv599_lmannounce:  A Boolean that specifies whether the server is visible to NTLM
	// 2.x clients. The default value is FALSE (0). If this feature is enabled, the server
	// announces its presence through LanMan or NetBIOS announcements.
	LMAnnounce int32 `idl:"name:sv599_lmannounce" json:"lm_announce"`
	// sv599_domain:  A pointer to a Unicode UTF character string that specifies the name
	// of the server's domain. This field cannot be modified by clients.
	Domain string `idl:"name:sv599_domain;string" json:"domain"`
	// sv599_maxcopyreadlen:  The server MUST validate this value on receipt. The range
	// of values MUST be from 0x00000000 to 0xFFFFFFFF, inclusive. Due to historical reasons,
	// the server does not store this value.
	MaxCopyReadLength uint32 `idl:"name:sv599_maxcopyreadlen" json:"max_copy_read_length"`
	// sv599_maxcopywritelen:  The server MUST validate this value on receipt. The range
	// of values MUST be from 0x00000000 to 0xFFFFFFFF, inclusive. Due to historical reasons,
	// the server does not store this value.
	MaxCopyWriteLength uint32 `idl:"name:sv599_maxcopywritelen" json:"max_copy_write_length"`
	// sv599_minkeepsearch:  The server MUST validate this value on receipt. The range of
	// values MUST be from 5 to 5,000, inclusive. Due to historical reasons, the server
	// does not store this value.
	MinKeepSearch uint32 `idl:"name:sv599_minkeepsearch" json:"min_keep_search"`
	// sv599_maxkeepsearch:  Specifies the length of time, in seconds, that the server retains
	// information about incomplete directory search operations. For more information about
	// directory searches, see [MS-CIFS] sections 2.2.6.2 and 2.2.6.3. The range of values
	// MUST be from 10 to 10,000, inclusive.
	MaxKeepSearch uint32 `idl:"name:sv599_maxkeepsearch" json:"max_keep_search"`
	// sv599_minkeepcomplsearch:  The server MUST validate this value on receipt. The range
	// of values MUST be from 1 to 1,000, inclusive. Due to historical reasons, the server
	// does not store this value.
	MinKeepComplSearch uint32 `idl:"name:sv599_minkeepcomplsearch" json:"min_keep_compl_search"`
	// sv599_maxkeepcomplsearch:  The server MUST validate this value on receipt. The range
	// of values MUST be from 2 to 10,000, inclusive. Due to historical reasons, the server
	// does not store this value.
	MaxKeepComplSearch uint32 `idl:"name:sv599_maxkeepcomplsearch" json:"max_keep_compl_search"`
	// sv599_threadcountadd:  Unused. This field MUST be ignored on receipt.
	ThreadCountAdd uint32 `idl:"name:sv599_threadcountadd" json:"thread_count_add"`
	// sv599_numblockthreads:  Unused. This field MUST be ignored on receipt.
	NumBlockThreads uint32 `idl:"name:sv599_numblockthreads" json:"num_block_threads"`
	// sv599_scavtimeout:  Specifies the period of time, in seconds, that an implementation-specific
	// timer on the server remains idle before waking up to service requests. This timer
	// runs periodic maintenance tasks that monitor time-out requests, log errors, update
	// server statistics, and update the connection Quality of Service (QoS) by querying
	// the underlying transport. The range of values MUST be from 1 to 300, inclusive.
	ScavTimeout uint32 `idl:"name:sv599_scavtimeout" json:"scav_timeout"`
	// sv599_minrcvqueue:  Specifies the minimum number of free receive work items that
	// the server requires before it begins to allocate more. The server keeps a pool of
	// free work items for each worker queue. When a new request is posted to this queue,
	// a work item is picked from the pool to hold that request while it is being processed.
	// The work item is returned to the pool after the processing is done. If the number
	// of free work items (that is, work items that are not being used to process a request)
	// for a queue falls below this setting, the server will request more work items to
	// be allocated for the queue. The range of values MUST be from 0 to 10, inclusive.
	MinReceiveQueue uint32 `idl:"name:sv599_minrcvqueue" json:"min_receive_queue"`
	// sv599_minfreeworkitems:  Specifies the minimum number of available receive work items
	// that the server requires to begin processing a server message block. The range of
	// values MUST be from 0 to 10, inclusive.
	MinFreeWorkItems uint32 `idl:"name:sv599_minfreeworkitems" json:"min_free_work_items"`
	// sv599_xactmemsize:  Specifies the size, in bytes, of the shared memory region that
	// is used to process server methods. The range of values MUST be from 0x10000 (64 KB)
	// to 0x1000000 (16 MB), inclusive. This field MUST be ignored by the server on receipt
	// for set operations.
	ExactMemSize uint32 `idl:"name:sv599_xactmemsize" json:"exact_mem_size"`
	// sv599_threadpriority:  Specifies the priority of all server threads in relation to
	// the base priority of the process. The range of values MUST be from 0 to 15, inclusive.
	// This field MUST be ignored by the server on receipt for set operations.
	ThreadPriority uint32 `idl:"name:sv599_threadpriority" json:"thread_priority"`
	// sv599_maxmpxct:  Specifies the maximum number of outstanding requests that any one
	// client can send to the server. The range of values MUST be from 1 to 65,535, inclusive.
	MaxMPXCount uint32 `idl:"name:sv599_maxmpxct" json:"max_mpx_count"`
	// sv599_oplockbreakwait:  Specifies the period of time, in seconds, to wait before
	// timing out an opportunistic lock break request. For more information about opportunistic
	// locks, see  [MS-CIFS] section  3.2.4.18. The range of values MUST be from 10 to
	// 180, inclusive.
	OperationLockBreakWait uint32 `idl:"name:sv599_oplockbreakwait" json:"operation_lock_break_wait"`
	// sv599_oplockbreakresponsewait:  Specifies the period of time, in seconds, that the
	// server waits for a client to respond to an opportunistic lock break request from
	// the server. For more information about opportunistic locks, see [MS-CIFS] section
	// 3.2.4.18. The range of values MUST be from 10 to 180, inclusive.
	OperationLockBreakResponseWait uint32 `idl:"name:sv599_oplockbreakresponsewait" json:"operation_lock_break_response_wait"`
	// sv599_enableoplocks:  A Boolean that specifies whether the server allows clients
	// to use opportunistic locks on files. Opportunistic locks are a significant performance
	// enhancement, but they have the potential to cause lost cached data on some networks,
	// particularly wide-area networks. For more information about opportunistic locks,
	// see [MS-CIFS] section 3.2.4.18. This field MUST be set to TRUE (1) to enable clients
	// to use opportunistic locks on files, or it MUST be set to FALSE (0) to restrict clients
	// from using opportunistic locks on files. The default value is TRUE (1).
	EnableOperationLocks int32 `idl:"name:sv599_enableoplocks" json:"enable_operation_locks"`
	// sv599_enableoplockforceclose:  Unused. MUST be set to zero and ignored on receipt.
	Enableoplockforceclose int32 `idl:"name:sv599_enableoplockforceclose" json:"enableoplockforceclose"`
	// sv599_enablefcbopens:  Specifies whether several MS-DOS File Control Blocks (FCBs)
	// are placed in a single location accessible to the server. If enabled, this option
	// can save resources on the server. This field MUST be set to TRUE (1) to place multiple
	// MS-DOS FCBs in a single location accessible to the server, and it MUST be set to
	// FALSE (0) otherwise. The default value is TRUE (1).
	EnableFCBOpens int32 `idl:"name:sv599_enablefcbopens" json:"enable_fcb_opens"`
	// sv599_enableraw:  Specifies whether the server processes raw SMBs. If enabled, this
	// allows more data to transfer per transaction and improves performance. However, it
	// is possible that processing raw SMBs can impede performance on certain networks.
	// This field MUST be set to TRUE (1) to indicate that the server processes raw SMBs,
	// and it MUST be set to FALSE (0) to indicate that the server does not process raw
	// SMBs. The server MUST maintain the value of this member. The default value is TRUE
	// (1).
	EnableRaw int32 `idl:"name:sv599_enableraw" json:"enable_raw"`
	// sv599_enablesharednetdrives:  Specifies whether the server allows redirected server
	// drives to be shared. The default value is FALSE (0).
	EnableSharedNetDrives int32 `idl:"name:sv599_enablesharednetdrives" json:"enable_shared_net_drives"`
	// sv599_minfreeconnections:  Specifies the minimum number of free connection blocks
	// that are maintained per endpoint. The server MUST set these aside to handle bursts
	// of requests by clients to connect to the server. The range of values MUST be from
	// 2 to 1,024.<25>
	MinFreeConnections uint32 `idl:"name:sv599_minfreeconnections" json:"min_free_connections"`
	// sv599_maxfreeconnections:  Specifies the maximum number of free connection blocks
	// that are maintained per endpoint. The server MUST set these aside to handle bursts
	// of requests by clients to connect to the server. The range of values MUST be from
	// 2 to 16,384.<26>
	MaxFreeConnections uint32 `idl:"name:sv599_maxfreeconnections" json:"max_free_connections"`
	// sv599_initsesstable:  Specifies the initial session table size for the server in
	// terms of the number of records (session structures used by the server internally
	// to represent active sessions). The range of values MUST be from 1 to 64, inclusive.
	InitSessionTable uint32 `idl:"name:sv599_initsesstable" json:"init_session_table"`
	// sv599_initconntable:  Specifies the initial connection table size for the server
	// in terms of the number of records (connection structures used by the server internally
	// to represent active connections). The range of values MUST be from 1 to 128, inclusive.
	InitConnectionTable uint32 `idl:"name:sv599_initconntable" json:"init_connection_table"`
	// sv599_initfiletable:  Specifies the initial file table size for the server in terms
	// of the number of records (file structures used by the server internally to represent
	// current open resources). The range of values MUST be from 1 to 256, inclusive.
	InitFileTable uint32 `idl:"name:sv599_initfiletable" json:"init_file_table"`
	// sv599_initsearchtable:  Specifies the initial search table size for the server in
	// terms of the number of records (search structures used by the server internally to
	// represent active searches). The range of values MUST be from 1 to 2,048, inclusive.
	InitSearchTable uint32 `idl:"name:sv599_initsearchtable" json:"init_search_table"`
	// sv599_alertschedule:  Specifies the time, in minutes, between two invocations of
	// an implementation-specific algorithm on the server. This algorithm monitors server
	// errors and disk space limits, and it generates the implementation-specific failure
	// events. The range of values MUST be from 1 to 65,535, inclusive.
	AlertSchedule uint32 `idl:"name:sv599_alertschedule" json:"alert_schedule"`
	// sv599_errorthreshold:  Specifies the number of failed operations (non-network) that
	// the server logs before raising an administrative alert. The particular operations
	// whose failure causes the count of failed non-network operations to be incremented
	// is implementation-dependent. The range of values MUST be from 1 to 65,535, inclusive.
	ErrorThreshold uint32 `idl:"name:sv599_errorthreshold" json:"error_threshold"`
	// sv599_networkerrorthreshold:  Specifies the minimum percentage of failed network
	// operations that the server records before raising an administrative alert. An alert
	// MUST be raised when (the number of failed network operations / the number of all
	// attempted network operations) * 100 is greater than or equal to this value. The range
	// of values MUST be from 1 to 100, inclusive.
	NetworkErrorThreshold uint32 `idl:"name:sv599_networkerrorthreshold" json:"network_error_threshold"`
	// sv599_diskspacethreshold:  Specifies the percent of free disk at which to raise an
	// administrative alert. The range of values MUST be from 0 to 99, inclusive.
	DiskSpaceThreshold uint32 `idl:"name:sv599_diskspacethreshold" json:"disk_space_threshold"`
	// sv599_reserved:  Reserved. This field MUST be set to zero.
	_ uint32 `idl:"name:sv599_reserved"`
	// sv599_maxlinkdelay:  Specifies the maximum link delay, in seconds, for the server.
	// The server enables raw I/O [MS-SMB] for a connection only if oplocks are enabled
	// for this connection and the link delay on the connection is less than or equal to
	// this value. The range of values MUST be from 0x00000000 to 0x10000000, inclusive.
	MaxLinkDelay uint32 `idl:"name:sv599_maxlinkdelay" json:"max_link_delay"`
	// sv599_minlinkthroughput:  Specifies the minimum link throughput, in bytes/second,
	// for the server. The server enables oplocks for a connection only if its current throughput
	// is greater than or equal to this value. The range of values MUST be from 0x00000000
	// to 0xFFFFFFFF, inclusive.
	MinLinkThroughput uint32 `idl:"name:sv599_minlinkthroughput" json:"min_link_throughput"`
	// sv599_linkinfovalidtime:  Specifies the time interval, in seconds, during which the
	// server can use the computed link information before having to compute it again. The
	// range of values MUST be from 0x00000000 to 0x10000000, inclusive.
	LinkInfoValidTime uint32 `idl:"name:sv599_linkinfovalidtime" json:"link_info_valid_time"`
	// sv599_scavqosinfoupdatetime:  Specifies the time interval for which an implementation-specific
	// timer on the server has to update QoS information. This time interval allows the
	// client to have the QoS information update done less frequently than the other tasks
	// done by the timer. The range of values MUST be from 0x00000000 to 0x10000000, inclusive.
	ScavQoSInfoUpdateTime uint32 `idl:"name:sv599_scavqosinfoupdatetime" json:"scav_qos_info_update_time"`
	// sv599_maxworkitemidletime:  Specifies the maximum work item idle time, in seconds.
	// For historical reasons, the server only stores this value, and it has no effect on
	// server operation. The range of values MUST be from 10 to 1,800, inclusive.
	MaxWorkItemIdleTime uint32 `idl:"name:sv599_maxworkitemidletime" json:"max_work_item_idle_time"`
}

func (o *ServerInfo599) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo599) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.SessionOpens); err != nil {
		return err
	}
	if err := w.WriteData(o.SessionServices); err != nil {
		return err
	}
	if err := w.WriteData(o.OpenSearch); err != nil {
		return err
	}
	if err := w.WriteData(o.SizeRequestBuffer); err != nil {
		return err
	}
	if err := w.WriteData(o.InitWorkItems); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxWorkItems); err != nil {
		return err
	}
	if err := w.WriteData(o.RawWorkItems); err != nil {
		return err
	}
	if err := w.WriteData(o.IRPStackSize); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxRawBufferLength); err != nil {
		return err
	}
	if err := w.WriteData(o.SessionUsers); err != nil {
		return err
	}
	if err := w.WriteData(o.SessionConnections); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxPagedMemoryUsage); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxNonPagedMemoryUsage); err != nil {
		return err
	}
	if err := w.WriteData(o.EnableSoftCompatibility); err != nil {
		return err
	}
	if err := w.WriteData(o.EnableForcedLogoff); err != nil {
		return err
	}
	if err := w.WriteData(o.TimeSource); err != nil {
		return err
	}
	if err := w.WriteData(o.AcceptDownLevelAPIs); err != nil {
		return err
	}
	if err := w.WriteData(o.LMAnnounce); err != nil {
		return err
	}
	if o.Domain != "" {
		_ptr_sv599_domain := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Domain); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Domain, _ptr_sv599_domain); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.MaxCopyReadLength); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxCopyWriteLength); err != nil {
		return err
	}
	if err := w.WriteData(o.MinKeepSearch); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxKeepSearch); err != nil {
		return err
	}
	if err := w.WriteData(o.MinKeepComplSearch); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxKeepComplSearch); err != nil {
		return err
	}
	if err := w.WriteData(o.ThreadCountAdd); err != nil {
		return err
	}
	if err := w.WriteData(o.NumBlockThreads); err != nil {
		return err
	}
	if err := w.WriteData(o.ScavTimeout); err != nil {
		return err
	}
	if err := w.WriteData(o.MinReceiveQueue); err != nil {
		return err
	}
	if err := w.WriteData(o.MinFreeWorkItems); err != nil {
		return err
	}
	if err := w.WriteData(o.ExactMemSize); err != nil {
		return err
	}
	if err := w.WriteData(o.ThreadPriority); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxMPXCount); err != nil {
		return err
	}
	if err := w.WriteData(o.OperationLockBreakWait); err != nil {
		return err
	}
	if err := w.WriteData(o.OperationLockBreakResponseWait); err != nil {
		return err
	}
	if err := w.WriteData(o.EnableOperationLocks); err != nil {
		return err
	}
	if err := w.WriteData(o.Enableoplockforceclose); err != nil {
		return err
	}
	if err := w.WriteData(o.EnableFCBOpens); err != nil {
		return err
	}
	if err := w.WriteData(o.EnableRaw); err != nil {
		return err
	}
	if err := w.WriteData(o.EnableSharedNetDrives); err != nil {
		return err
	}
	if err := w.WriteData(o.MinFreeConnections); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxFreeConnections); err != nil {
		return err
	}
	if err := w.WriteData(o.InitSessionTable); err != nil {
		return err
	}
	if err := w.WriteData(o.InitConnectionTable); err != nil {
		return err
	}
	if err := w.WriteData(o.InitFileTable); err != nil {
		return err
	}
	if err := w.WriteData(o.InitSearchTable); err != nil {
		return err
	}
	if err := w.WriteData(o.AlertSchedule); err != nil {
		return err
	}
	if err := w.WriteData(o.ErrorThreshold); err != nil {
		return err
	}
	if err := w.WriteData(o.NetworkErrorThreshold); err != nil {
		return err
	}
	if err := w.WriteData(o.DiskSpaceThreshold); err != nil {
		return err
	}
	// reserved sv599_reserved
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxLinkDelay); err != nil {
		return err
	}
	if err := w.WriteData(o.MinLinkThroughput); err != nil {
		return err
	}
	if err := w.WriteData(o.LinkInfoValidTime); err != nil {
		return err
	}
	if err := w.WriteData(o.ScavQoSInfoUpdateTime); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxWorkItemIdleTime); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo599) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.SessionOpens); err != nil {
		return err
	}
	if err := w.ReadData(&o.SessionServices); err != nil {
		return err
	}
	if err := w.ReadData(&o.OpenSearch); err != nil {
		return err
	}
	if err := w.ReadData(&o.SizeRequestBuffer); err != nil {
		return err
	}
	if err := w.ReadData(&o.InitWorkItems); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxWorkItems); err != nil {
		return err
	}
	if err := w.ReadData(&o.RawWorkItems); err != nil {
		return err
	}
	if err := w.ReadData(&o.IRPStackSize); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxRawBufferLength); err != nil {
		return err
	}
	if err := w.ReadData(&o.SessionUsers); err != nil {
		return err
	}
	if err := w.ReadData(&o.SessionConnections); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxPagedMemoryUsage); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxNonPagedMemoryUsage); err != nil {
		return err
	}
	if err := w.ReadData(&o.EnableSoftCompatibility); err != nil {
		return err
	}
	if err := w.ReadData(&o.EnableForcedLogoff); err != nil {
		return err
	}
	if err := w.ReadData(&o.TimeSource); err != nil {
		return err
	}
	if err := w.ReadData(&o.AcceptDownLevelAPIs); err != nil {
		return err
	}
	if err := w.ReadData(&o.LMAnnounce); err != nil {
		return err
	}
	_ptr_sv599_domain := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Domain); err != nil {
			return err
		}
		return nil
	})
	_s_sv599_domain := func(ptr interface{}) { o.Domain = *ptr.(*string) }
	if err := w.ReadPointer(&o.Domain, _s_sv599_domain, _ptr_sv599_domain); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxCopyReadLength); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxCopyWriteLength); err != nil {
		return err
	}
	if err := w.ReadData(&o.MinKeepSearch); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxKeepSearch); err != nil {
		return err
	}
	if err := w.ReadData(&o.MinKeepComplSearch); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxKeepComplSearch); err != nil {
		return err
	}
	if err := w.ReadData(&o.ThreadCountAdd); err != nil {
		return err
	}
	if err := w.ReadData(&o.NumBlockThreads); err != nil {
		return err
	}
	if err := w.ReadData(&o.ScavTimeout); err != nil {
		return err
	}
	if err := w.ReadData(&o.MinReceiveQueue); err != nil {
		return err
	}
	if err := w.ReadData(&o.MinFreeWorkItems); err != nil {
		return err
	}
	if err := w.ReadData(&o.ExactMemSize); err != nil {
		return err
	}
	if err := w.ReadData(&o.ThreadPriority); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxMPXCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.OperationLockBreakWait); err != nil {
		return err
	}
	if err := w.ReadData(&o.OperationLockBreakResponseWait); err != nil {
		return err
	}
	if err := w.ReadData(&o.EnableOperationLocks); err != nil {
		return err
	}
	if err := w.ReadData(&o.Enableoplockforceclose); err != nil {
		return err
	}
	if err := w.ReadData(&o.EnableFCBOpens); err != nil {
		return err
	}
	if err := w.ReadData(&o.EnableRaw); err != nil {
		return err
	}
	if err := w.ReadData(&o.EnableSharedNetDrives); err != nil {
		return err
	}
	if err := w.ReadData(&o.MinFreeConnections); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxFreeConnections); err != nil {
		return err
	}
	if err := w.ReadData(&o.InitSessionTable); err != nil {
		return err
	}
	if err := w.ReadData(&o.InitConnectionTable); err != nil {
		return err
	}
	if err := w.ReadData(&o.InitFileTable); err != nil {
		return err
	}
	if err := w.ReadData(&o.InitSearchTable); err != nil {
		return err
	}
	if err := w.ReadData(&o.AlertSchedule); err != nil {
		return err
	}
	if err := w.ReadData(&o.ErrorThreshold); err != nil {
		return err
	}
	if err := w.ReadData(&o.NetworkErrorThreshold); err != nil {
		return err
	}
	if err := w.ReadData(&o.DiskSpaceThreshold); err != nil {
		return err
	}
	// reserved sv599_reserved
	var _sv599_reserved uint32
	if err := w.ReadData(&_sv599_reserved); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxLinkDelay); err != nil {
		return err
	}
	if err := w.ReadData(&o.MinLinkThroughput); err != nil {
		return err
	}
	if err := w.ReadData(&o.LinkInfoValidTime); err != nil {
		return err
	}
	if err := w.ReadData(&o.ScavQoSInfoUpdateTime); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxWorkItemIdleTime); err != nil {
		return err
	}
	return nil
}

// ServerInfo1005 structure represents SERVER_INFO_1005 RPC structure.
//
// The SERVER_INFO_1005 structure contains information about a specified server.
type ServerInfo1005 struct {
	// sv1005_comment:  This member is defined in the sv103_comment member in SERVER_INFO_103
	// (section 2.2.4.43).
	Comment string `idl:"name:sv1005_comment;string" json:"comment"`
}

func (o *ServerInfo1005) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1005) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(6); err != nil {
		return err
	}
	if o.Comment != "" {
		_ptr_sv1005_comment := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Comment); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Comment, _ptr_sv1005_comment); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1005) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(6); err != nil {
		return err
	}
	_ptr_sv1005_comment := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Comment); err != nil {
			return err
		}
		return nil
	})
	_s_sv1005_comment := func(ptr interface{}) { o.Comment = *ptr.(*string) }
	if err := w.ReadPointer(&o.Comment, _s_sv1005_comment, _ptr_sv1005_comment); err != nil {
		return err
	}
	return nil
}

// ServerInfo1107 structure represents SERVER_INFO_1107 RPC structure.
//
// The SERVER_INFO_1107 structure contains information about a specified server.
type ServerInfo1107 struct {
	// sv1107_users:  This member is defined in the sv103_users member in SERVER_INFO_103
	// (section 2.2.4.43).
	Users uint32 `idl:"name:sv1107_users" json:"users"`
}

func (o *ServerInfo1107) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1107) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Users); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1107) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Users); err != nil {
		return err
	}
	return nil
}

// ServerInfo1010 structure represents SERVER_INFO_1010 RPC structure.
//
// The SERVER_INFO_1010 structure contains information about a specified server.
type ServerInfo1010 struct {
	// sv1010_disc:  This member is defined in the sv103_disc member in SERVER_INFO_103
	// (section 2.2.4.43).
	Disc int32 `idl:"name:sv1010_disc" json:"disc"`
}

func (o *ServerInfo1010) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1010) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Disc); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1010) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Disc); err != nil {
		return err
	}
	return nil
}

// ServerInfo1016 structure represents SERVER_INFO_1016 RPC structure.
//
// The SERVER_INFO_1016 structure contains information about a specified server.
type ServerInfo1016 struct {
	// sv1016_hidden:  This member is defined in the sv103_hidden member in SERVER_INFO_103
	// (section 2.2.4.43).
	Hidden int32 `idl:"name:sv1016_hidden" json:"hidden"`
}

func (o *ServerInfo1016) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1016) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Hidden); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1016) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Hidden); err != nil {
		return err
	}
	return nil
}

// ServerInfo1017 structure represents SERVER_INFO_1017 RPC structure.
//
// The SERVER_INFO_1017 structure contains information about a specified server.
type ServerInfo1017 struct {
	// sv1017_announce:  This member is defined in the sv103_announce member in SERVER_INFO_103
	// (section 2.2.4.43).
	Announce uint32 `idl:"name:sv1017_announce" json:"announce"`
}

func (o *ServerInfo1017) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1017) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Announce); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1017) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Announce); err != nil {
		return err
	}
	return nil
}

// ServerInfo1018 structure represents SERVER_INFO_1018 RPC structure.
//
// The SERVER_INFO_1018 structure contains information about a specified server.
type ServerInfo1018 struct {
	// sv1018_anndelta:  This member is defined in the sv103_ anndelta member in SERVER_INFO_103
	// (section 2.2.4.43).
	AnnounceDelta uint32 `idl:"name:sv1018_anndelta" json:"announce_delta"`
}

func (o *ServerInfo1018) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1018) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.AnnounceDelta); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1018) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.AnnounceDelta); err != nil {
		return err
	}
	return nil
}

// ServerInfo1501 structure represents SERVER_INFO_1501 RPC structure.
//
// The SERVER_INFO_1501 structure contains information about a specified server.
type ServerInfo1501 struct {
	// sv1501_sessopens:  This member is defined in the sv599_sessopens member in SERVER_INFO_599
	// (section 2.2.4.46).
	SessionOpens uint32 `idl:"name:sv1501_sessopens" json:"session_opens"`
}

func (o *ServerInfo1501) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1501) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.SessionOpens); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1501) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.SessionOpens); err != nil {
		return err
	}
	return nil
}

// ServerInfo1502 structure represents SERVER_INFO_1502 RPC structure.
//
// The SERVER_INFO_1502 structure contains information about a specified server.
type ServerInfo1502 struct {
	// sv1502_sessvcs:  This member is defined in the sv599_sessvcs member in SERVER_INFO_599
	// (section 2.2.4.46).
	SessionServices uint32 `idl:"name:sv1502_sessvcs" json:"session_services"`
}

func (o *ServerInfo1502) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1502) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.SessionServices); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1502) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.SessionServices); err != nil {
		return err
	}
	return nil
}

// ServerInfo1503 structure represents SERVER_INFO_1503 RPC structure.
//
// The SERVER_INFO_1503 structure contains information about a specified server.
type ServerInfo1503 struct {
	// sv1503_opensearch:  This member is defined in the sv599_opensearch member in SERVER_INFO_599
	// (section 2.2.4.46).
	OpenSearch uint32 `idl:"name:sv1503_opensearch" json:"open_search"`
}

func (o *ServerInfo1503) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1503) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.OpenSearch); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1503) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.OpenSearch); err != nil {
		return err
	}
	return nil
}

// ServerInfo1506 structure represents SERVER_INFO_1506 RPC structure.
//
// The SERVER_INFO_1506 structure contains information about a specified server.
type ServerInfo1506 struct {
	// sv1506_maxworkitems:  This member is defined in the sv599_maxworkitems member in
	// SERVER_INFO_599 (section 2.2.4.46).
	MaxWorkItems uint32 `idl:"name:sv1506_maxworkitems" json:"max_work_items"`
}

func (o *ServerInfo1506) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1506) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxWorkItems); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1506) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxWorkItems); err != nil {
		return err
	}
	return nil
}

// ServerInfo1510 structure represents SERVER_INFO_1510 RPC structure.
//
// The SERVER_INFO_1510 structure contains information about a specified server.
type ServerInfo1510 struct {
	// sv1510_sessusers:  This member is defined in the sv599_sessusers member in SERVER_INFO_599
	// (section 2.2.4.46).
	SessionUsers uint32 `idl:"name:sv1510_sessusers" json:"session_users"`
}

func (o *ServerInfo1510) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1510) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.SessionUsers); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1510) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.SessionUsers); err != nil {
		return err
	}
	return nil
}

// ServerInfo1511 structure represents SERVER_INFO_1511 RPC structure.
//
// The SERVER_INFO_1511 structure contains information about a specified server.
type ServerInfo1511 struct {
	// sv1511_sessconns:  This member is defined in the sv599_sessconns member in SERVER_INFO_599
	// (section 2.2.4.46).
	SessionConnections uint32 `idl:"name:sv1511_sessconns" json:"session_connections"`
}

func (o *ServerInfo1511) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1511) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.SessionConnections); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1511) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.SessionConnections); err != nil {
		return err
	}
	return nil
}

// ServerInfo1512 structure represents SERVER_INFO_1512 RPC structure.
//
// The SERVER_INFO_1512 structure contains information about a specified server.
type ServerInfo1512 struct {
	// sv1512_maxnonpagedmemoryusage:  This member is defined in the sv599_maxnonpagedmemoryusage
	// member in SERVER_INFO_599 (section 2.2.4.46).
	MaxNonPagedMemoryUsage uint32 `idl:"name:sv1512_maxnonpagedmemoryusage" json:"max_non_paged_memory_usage"`
}

func (o *ServerInfo1512) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1512) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxNonPagedMemoryUsage); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1512) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxNonPagedMemoryUsage); err != nil {
		return err
	}
	return nil
}

// ServerInfo1513 structure represents SERVER_INFO_1513 RPC structure.
//
// The SERVER_INFO_1513 structure contains information about a specified server.
type ServerInfo1513 struct {
	// sv1513_maxpagedmemoryusage:  This member is defined in the sv599_maxpagedmemoryusage
	// member in SERVER_INFO_599 (section 2.2.4.46).
	MaxPagedMemoryUsage uint32 `idl:"name:sv1513_maxpagedmemoryusage" json:"max_paged_memory_usage"`
}

func (o *ServerInfo1513) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1513) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxPagedMemoryUsage); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1513) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxPagedMemoryUsage); err != nil {
		return err
	}
	return nil
}

// ServerInfo1514 structure represents SERVER_INFO_1514 RPC structure.
//
// The SERVER_INFO_1514 structure contains information about a specified server.
type ServerInfo1514 struct {
	// sv1514_enablesoftcompat:  This member is defined in the sv599_enablesoftcompat member
	// in SERVER_INFO_599 (section 2.2.4.46).
	EnableSoftCompatibility int32 `idl:"name:sv1514_enablesoftcompat" json:"enable_soft_compatibility"`
}

func (o *ServerInfo1514) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1514) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.EnableSoftCompatibility); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1514) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.EnableSoftCompatibility); err != nil {
		return err
	}
	return nil
}

// ServerInfo1515 structure represents SERVER_INFO_1515 RPC structure.
//
// The SERVER_INFO_1515 structure contains information about a specified server.
type ServerInfo1515 struct {
	// sv1515_enableforcedlogoff:  This member is defined in the sv599_enableforcedlogoff
	// member in SERVER_INFO_599 (section 2.2.4.46).
	EnableForcedLogoff int32 `idl:"name:sv1515_enableforcedlogoff" json:"enable_forced_logoff"`
}

func (o *ServerInfo1515) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1515) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.EnableForcedLogoff); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1515) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.EnableForcedLogoff); err != nil {
		return err
	}
	return nil
}

// ServerInfo1516 structure represents SERVER_INFO_1516 RPC structure.
//
// The SERVER_INFO_1516 structure contains information about a specified server.
type ServerInfo1516 struct {
	// sv1516_timesource:  This member is defined in the sv599_timesource member in SERVER_INFO_599
	// (section 2.2.4.46).
	TimeSource int32 `idl:"name:sv1516_timesource" json:"time_source"`
}

func (o *ServerInfo1516) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1516) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.TimeSource); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1516) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.TimeSource); err != nil {
		return err
	}
	return nil
}

// ServerInfo1518 structure represents SERVER_INFO_1518 RPC structure.
//
// The SERVER_INFO_1518 structure contains information about a specified server.
type ServerInfo1518 struct {
	// sv1518_lmannounce:  This member is defined in the sv599_lmannounce member in SERVER_INFO_599
	// (section 2.2.4.46).
	LMAnnounce int32 `idl:"name:sv1518_lmannounce" json:"lm_announce"`
}

func (o *ServerInfo1518) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1518) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.LMAnnounce); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1518) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.LMAnnounce); err != nil {
		return err
	}
	return nil
}

// ServerInfo1523 structure represents SERVER_INFO_1523 RPC structure.
//
// The SERVER_INFO_1523 structure contains information about a specified server.
type ServerInfo1523 struct {
	// sv1523_maxkeepsearch:  This member is defined in the sv599_maxkeepsearch member in
	// SERVER_INFO_599 (section 2.2.4.46).
	MaxKeepSearch uint32 `idl:"name:sv1523_maxkeepsearch" json:"max_keep_search"`
}

func (o *ServerInfo1523) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1523) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxKeepSearch); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1523) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxKeepSearch); err != nil {
		return err
	}
	return nil
}

// ServerInfo1528 structure represents SERVER_INFO_1528 RPC structure.
//
// The SERVER_INFO_1528 structure contains information about a specified server.
type ServerInfo1528 struct {
	// sv1528_scavtimeout:  This member is defined in the sv599_scavtimeout member in SERVER_INFO_599
	// (section 2.2.4.46).
	ScavTimeout uint32 `idl:"name:sv1528_scavtimeout" json:"scav_timeout"`
}

func (o *ServerInfo1528) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1528) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.ScavTimeout); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1528) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.ScavTimeout); err != nil {
		return err
	}
	return nil
}

// ServerInfo1529 structure represents SERVER_INFO_1529 RPC structure.
//
// The SERVER_INFO_1529 structure contains information about a specified server.
type ServerInfo1529 struct {
	// sv1529_minrcvqueue:  This member is defined in the sv599_minrcvqueue member in SERVER_INFO_599
	// (section 2.2.4.46).
	MinReceiveQueue uint32 `idl:"name:sv1529_minrcvqueue" json:"min_receive_queue"`
}

func (o *ServerInfo1529) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1529) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.MinReceiveQueue); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1529) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.MinReceiveQueue); err != nil {
		return err
	}
	return nil
}

// ServerInfo1530 structure represents SERVER_INFO_1530 RPC structure.
//
// The SERVER_INFO_1530 structure contains information about a specified server.
type ServerInfo1530 struct {
	// sv1530_minfreeworkitems:  This member is defined in the sv599_minfreeworkitems member
	// in SERVER_INFO_599 (section 2.2.4.46).
	MinFreeWorkItems uint32 `idl:"name:sv1530_minfreeworkitems" json:"min_free_work_items"`
}

func (o *ServerInfo1530) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1530) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.MinFreeWorkItems); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1530) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.MinFreeWorkItems); err != nil {
		return err
	}
	return nil
}

// ServerInfo1533 structure represents SERVER_INFO_1533 RPC structure.
//
// The SERVER_INFO_1533 structure contains information about a specified server.
type ServerInfo1533 struct {
	// sv1533_maxmpxct:  This member is defined in the sv599_maxmpxct member in SERVER_INFO_599
	// (section 2.2.4.46).
	MaxMPXCount uint32 `idl:"name:sv1533_maxmpxct" json:"max_mpx_count"`
}

func (o *ServerInfo1533) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1533) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxMPXCount); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1533) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxMPXCount); err != nil {
		return err
	}
	return nil
}

// ServerInfo1534 structure represents SERVER_INFO_1534 RPC structure.
//
// The SERVER_INFO_1534 structure contains information about a specified server.
type ServerInfo1534 struct {
	// sv1534_oplockbreakwait:  This member is defined in the sv599_oplockbreakwait member
	// in SERVER_INFO_599 (section 2.2.4.46).
	OperationLockBreakWait uint32 `idl:"name:sv1534_oplockbreakwait" json:"operation_lock_break_wait"`
}

func (o *ServerInfo1534) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1534) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.OperationLockBreakWait); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1534) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.OperationLockBreakWait); err != nil {
		return err
	}
	return nil
}

// ServerInfo1535 structure represents SERVER_INFO_1535 RPC structure.
//
// The SERVER_INFO_1535 structure contains information about a specified server.
type ServerInfo1535 struct {
	// sv1535_oplockbreakresponsewait:  This member is defined in the sv599_oplockbreakresponsewait
	// member in SERVER_INFO_599 (section 2.2.4.46).
	OperationLockBreakResponseWait uint32 `idl:"name:sv1535_oplockbreakresponsewait" json:"operation_lock_break_response_wait"`
}

func (o *ServerInfo1535) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1535) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.OperationLockBreakResponseWait); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1535) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.OperationLockBreakResponseWait); err != nil {
		return err
	}
	return nil
}

// ServerInfo1536 structure represents SERVER_INFO_1536 RPC structure.
//
// The SERVER_INFO_1536 structure contains information about a specified server.
type ServerInfo1536 struct {
	// sv1536_enableoplocks:  This member is defined in the sv599_enableoplocks member in
	// SERVER_INFO_599 (section 2.2.4.46).
	EnableOperationLocks int32 `idl:"name:sv1536_enableoplocks" json:"enable_operation_locks"`
}

func (o *ServerInfo1536) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1536) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.EnableOperationLocks); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1536) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.EnableOperationLocks); err != nil {
		return err
	}
	return nil
}

// ServerInfo1538 structure represents SERVER_INFO_1538 RPC structure.
//
// The SERVER_INFO_1538 structure contains information about a specified server.
type ServerInfo1538 struct {
	// sv1538_enablefcbopens:  This member is defined in the sv599_enablefcbopens member
	// in SERVER_INFO_599 (section 2.2.4.46).
	EnableFCBOpens int32 `idl:"name:sv1538_enablefcbopens" json:"enable_fcb_opens"`
}

func (o *ServerInfo1538) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1538) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.EnableFCBOpens); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1538) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.EnableFCBOpens); err != nil {
		return err
	}
	return nil
}

// ServerInfo1539 structure represents SERVER_INFO_1539 RPC structure.
//
// The SERVER_INFO_1539 structure contains information about a specified server.
type ServerInfo1539 struct {
	// sv1539_enableraw:  This member is defined in the sv599_enableraw member in SERVER_INFO_599
	// (section 2.2.4.46).
	EnableRaw int32 `idl:"name:sv1539_enableraw" json:"enable_raw"`
}

func (o *ServerInfo1539) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1539) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.EnableRaw); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1539) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.EnableRaw); err != nil {
		return err
	}
	return nil
}

// ServerInfo1540 structure represents SERVER_INFO_1540 RPC structure.
//
// The SERVER_INFO_1540 structure contains information about a specified server.
type ServerInfo1540 struct {
	// sv1540_enablesharednetdrives:  This member is defined in the sv599_enablesharednetdrives
	// member in SERVER_INFO_599 (section 2.2.4.46).
	EnableSharedNetDrives int32 `idl:"name:sv1540_enablesharednetdrives" json:"enable_shared_net_drives"`
}

func (o *ServerInfo1540) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1540) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.EnableSharedNetDrives); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1540) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.EnableSharedNetDrives); err != nil {
		return err
	}
	return nil
}

// ServerInfo1541 structure represents SERVER_INFO_1541 RPC structure.
//
// The SERVER_INFO_1541 structure contains information about a specified server.
type ServerInfo1541 struct {
	// sv1541_minfreeconnections:  This member is defined in the sv599_minfreeconnections
	// member in SERVER_INFO_599 (section 2.2.4.46).
	MinFreeConnections int32 `idl:"name:sv1541_minfreeconnections" json:"min_free_connections"`
}

func (o *ServerInfo1541) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1541) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.MinFreeConnections); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1541) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.MinFreeConnections); err != nil {
		return err
	}
	return nil
}

// ServerInfo1542 structure represents SERVER_INFO_1542 RPC structure.
//
// The SERVER_INFO_1542 structure contains information about a specified server.
type ServerInfo1542 struct {
	// sv1542_maxfreeconnections:  This member is defined in the sv599_maxfreeconnections
	// member in SERVER_INFO_599 (section 2.2.4.46).
	MaxFreeConnections int32 `idl:"name:sv1542_maxfreeconnections" json:"max_free_connections"`
}

func (o *ServerInfo1542) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1542) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxFreeConnections); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1542) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxFreeConnections); err != nil {
		return err
	}
	return nil
}

// ServerInfo1543 structure represents SERVER_INFO_1543 RPC structure.
//
// The SERVER_INFO_1543 structure contains information about a specified server.
type ServerInfo1543 struct {
	// sv1543_initsesstable:  This member is defined in the sv599_initsesstable member in
	// SERVER_INFO_599 (section 2.2.4.46).
	InitSessionTable uint32 `idl:"name:sv1543_initsesstable" json:"init_session_table"`
}

func (o *ServerInfo1543) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1543) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.InitSessionTable); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1543) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.InitSessionTable); err != nil {
		return err
	}
	return nil
}

// ServerInfo1544 structure represents SERVER_INFO_1544 RPC structure.
//
// The SERVER_INFO_1544 structure contains information about a specified server.
type ServerInfo1544 struct {
	// sv1544_initconntable:  This member is defined in the sv599_initconntable member in
	// SERVER_INFO_599 (section 2.2.4.46).
	InitConnectionTable uint32 `idl:"name:sv1544_initconntable" json:"init_connection_table"`
}

func (o *ServerInfo1544) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1544) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.InitConnectionTable); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1544) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.InitConnectionTable); err != nil {
		return err
	}
	return nil
}

// ServerInfo1545 structure represents SERVER_INFO_1545 RPC structure.
//
// The SERVER_INFO_1545 structure contains information about a specified server.
type ServerInfo1545 struct {
	// sv1545_initfiletable:  This member is defined in the sv599_initfiletable member in
	// SERVER_INFO_599 (section 2.2.4.46).
	InitFileTable uint32 `idl:"name:sv1545_initfiletable" json:"init_file_table"`
}

func (o *ServerInfo1545) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1545) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.InitFileTable); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1545) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.InitFileTable); err != nil {
		return err
	}
	return nil
}

// ServerInfo1546 structure represents SERVER_INFO_1546 RPC structure.
//
// The SERVER_INFO_1546 structure contains information about a specified server.
type ServerInfo1546 struct {
	// sv1546_initsearchtable:  This member is defined in the sv599_initsearchtable member
	// in SERVER_INFO_599 (section 2.2.4.46).
	InitSearchTable uint32 `idl:"name:sv1546_initsearchtable" json:"init_search_table"`
}

func (o *ServerInfo1546) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1546) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.InitSearchTable); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1546) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.InitSearchTable); err != nil {
		return err
	}
	return nil
}

// ServerInfo1547 structure represents SERVER_INFO_1547 RPC structure.
//
// The SERVER_INFO_1547 structure contains information about a specified server.
type ServerInfo1547 struct {
	// sv1547_alertschedule:  This member is defined in the sv599_alertschedule member in
	// SERVER_INFO_599 (section 2.2.4.46).
	AlertSchedule uint32 `idl:"name:sv1547_alertschedule" json:"alert_schedule"`
}

func (o *ServerInfo1547) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1547) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.AlertSchedule); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1547) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.AlertSchedule); err != nil {
		return err
	}
	return nil
}

// ServerInfo1548 structure represents SERVER_INFO_1548 RPC structure.
//
// The SERVER_INFO_1548 structure contains information about a specified server.
type ServerInfo1548 struct {
	// sv1548_errorthreshold:  This member is defined in the sv599_errorthreshold member
	// in SERVER_INFO_599 (section 2.2.4.46).
	ErrorThreshold uint32 `idl:"name:sv1548_errorthreshold" json:"error_threshold"`
}

func (o *ServerInfo1548) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1548) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.ErrorThreshold); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1548) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.ErrorThreshold); err != nil {
		return err
	}
	return nil
}

// ServerInfo1549 structure represents SERVER_INFO_1549 RPC structure.
//
// The SERVER_INFO_1549 structure contains information about a specified server.
type ServerInfo1549 struct {
	// sv1549_networkerrorthreshold:  This member is defined in the sv599_networkerrorthreshold
	// member in SERVER_INFO_599 (section 2.2.4.46).
	NetworkErrorThreshold uint32 `idl:"name:sv1549_networkerrorthreshold" json:"network_error_threshold"`
}

func (o *ServerInfo1549) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1549) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.NetworkErrorThreshold); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1549) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.NetworkErrorThreshold); err != nil {
		return err
	}
	return nil
}

// ServerInfo1550 structure represents SERVER_INFO_1550 RPC structure.
//
// The SERVER_INFO_1550 structure contains information about a specified server.
type ServerInfo1550 struct {
	// sv1550_diskspacethreshold:  This member is defined in the sv599_diskspacethreshold
	// member in SERVER_INFO_599 (section 2.2.4.46).
	DiskSpaceThreshold uint32 `idl:"name:sv1550_diskspacethreshold" json:"disk_space_threshold"`
}

func (o *ServerInfo1550) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1550) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.DiskSpaceThreshold); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1550) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.DiskSpaceThreshold); err != nil {
		return err
	}
	return nil
}

// ServerInfo1552 structure represents SERVER_INFO_1552 RPC structure.
//
// The SERVER_INFO_1552 structure contains information about a specified server.
type ServerInfo1552 struct {
	// sv1552_maxlinkdelay:  This member is defined in the sv599_maxlinkdelay member in
	// SERVER_INFO_599 (section 2.2.4.46).
	MaxLinkDelay uint32 `idl:"name:sv1552_maxlinkdelay" json:"max_link_delay"`
}

func (o *ServerInfo1552) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1552) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxLinkDelay); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1552) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxLinkDelay); err != nil {
		return err
	}
	return nil
}

// ServerInfo1553 structure represents SERVER_INFO_1553 RPC structure.
//
// The SERVER_INFO_1553 structure contains information about a specified server.
type ServerInfo1553 struct {
	// sv1553_minlinkthroughput:  This member is defined in the sv599_minlinkthroughput
	// member in SERVER_INFO_599 (section 2.2.4.46).
	MinLinkThroughput uint32 `idl:"name:sv1553_minlinkthroughput" json:"min_link_throughput"`
}

func (o *ServerInfo1553) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1553) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.MinLinkThroughput); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1553) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.MinLinkThroughput); err != nil {
		return err
	}
	return nil
}

// ServerInfo1554 structure represents SERVER_INFO_1554 RPC structure.
//
// The SERVER_INFO_1554 structure contains information about a specified server.
type ServerInfo1554 struct {
	// sv1554_linkinfovalidtime:  This member is defined in the sv599_linkinfovalidtime
	// member in SERVER_INFO_599 (section 2.2.4.46).
	LinkInfoValidTime uint32 `idl:"name:sv1554_linkinfovalidtime" json:"link_info_valid_time"`
}

func (o *ServerInfo1554) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1554) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.LinkInfoValidTime); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1554) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.LinkInfoValidTime); err != nil {
		return err
	}
	return nil
}

// ServerInfo1555 structure represents SERVER_INFO_1555 RPC structure.
//
// The SERVER_INFO_1555 structure contains information about a specified server.
type ServerInfo1555 struct {
	// sv1555_scavqosinfoupdatetime:  This member is defined in the sv599_scavqosinfoupdatetime
	// member in SERVER_INFO_599 (section 2.2.4.46).
	ScavQoSInfoUpdateTime uint32 `idl:"name:sv1555_scavqosinfoupdatetime" json:"scav_qos_info_update_time"`
}

func (o *ServerInfo1555) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1555) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.ScavQoSInfoUpdateTime); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1555) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.ScavQoSInfoUpdateTime); err != nil {
		return err
	}
	return nil
}

// ServerInfo1556 structure represents SERVER_INFO_1556 RPC structure.
//
// The SERVER_INFO_1556 structure contains information about a specified server.
type ServerInfo1556 struct {
	// sv1556_maxworkitemidletime:  This member is defined in the sv599_maxworkitemidletime
	// member in SERVER_INFO_599 (section 2.2.4.46).
	MaxWorkItemIdleTime uint32 `idl:"name:sv1556_maxworkitemidletime" json:"max_work_item_idle_time"`
}

func (o *ServerInfo1556) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo1556) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxWorkItemIdleTime); err != nil {
		return err
	}
	return nil
}
func (o *ServerInfo1556) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxWorkItemIdleTime); err != nil {
		return err
	}
	return nil
}

// ServerInfo structure represents SERVER_INFO RPC union.
//
// The SERVER_INFO union contains information about a server.
type ServerInfo struct {
	// Types that are assignable to Value
	//
	// *ServerInfo_100
	// *ServerInfo_101
	// *ServerInfo_102
	// *ServerInfo_103
	// *ServerInfo_502
	// *ServerInfo_503
	// *ServerInfo_599
	// *ServerInfo_1005
	// *ServerInfo_1107
	// *ServerInfo_1010
	// *ServerInfo_1016
	// *ServerInfo_1017
	// *ServerInfo_1018
	// *ServerInfo_1501
	// *ServerInfo_1502
	// *ServerInfo_1503
	// *ServerInfo_1506
	// *ServerInfo_1510
	// *ServerInfo_1511
	// *ServerInfo_1512
	// *ServerInfo_1513
	// *ServerInfo_1514
	// *ServerInfo_1515
	// *ServerInfo_1516
	// *ServerInfo_1518
	// *ServerInfo_1523
	// *ServerInfo_1528
	// *ServerInfo_1529
	// *ServerInfo_1530
	// *ServerInfo_1533
	// *ServerInfo_1534
	// *ServerInfo_1535
	// *ServerInfo_1536
	// *ServerInfo_1538
	// *ServerInfo_1539
	// *ServerInfo_1540
	// *ServerInfo_1541
	// *ServerInfo_1542
	// *ServerInfo_1543
	// *ServerInfo_1544
	// *ServerInfo_1545
	// *ServerInfo_1546
	// *ServerInfo_1547
	// *ServerInfo_1548
	// *ServerInfo_1549
	// *ServerInfo_1550
	// *ServerInfo_1552
	// *ServerInfo_1553
	// *ServerInfo_1554
	// *ServerInfo_1555
	// *ServerInfo_1556
	Value is_ServerInfo `json:"value"`
}

func (o *ServerInfo) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *ServerInfo_100:
		if value != nil {
			return value.ServerInfo100
		}
	case *ServerInfo_101:
		if value != nil {
			return value.ServerInfo101
		}
	case *ServerInfo_102:
		if value != nil {
			return value.ServerInfo102
		}
	case *ServerInfo_103:
		if value != nil {
			return value.ServerInfo103
		}
	case *ServerInfo_502:
		if value != nil {
			return value.ServerInfo502
		}
	case *ServerInfo_503:
		if value != nil {
			return value.ServerInfo503
		}
	case *ServerInfo_599:
		if value != nil {
			return value.ServerInfo599
		}
	case *ServerInfo_1005:
		if value != nil {
			return value.ServerInfo1005
		}
	case *ServerInfo_1107:
		if value != nil {
			return value.ServerInfo1107
		}
	case *ServerInfo_1010:
		if value != nil {
			return value.ServerInfo1010
		}
	case *ServerInfo_1016:
		if value != nil {
			return value.ServerInfo1016
		}
	case *ServerInfo_1017:
		if value != nil {
			return value.ServerInfo1017
		}
	case *ServerInfo_1018:
		if value != nil {
			return value.ServerInfo1018
		}
	case *ServerInfo_1501:
		if value != nil {
			return value.ServerInfo1501
		}
	case *ServerInfo_1502:
		if value != nil {
			return value.ServerInfo1502
		}
	case *ServerInfo_1503:
		if value != nil {
			return value.ServerInfo1503
		}
	case *ServerInfo_1506:
		if value != nil {
			return value.ServerInfo1506
		}
	case *ServerInfo_1510:
		if value != nil {
			return value.ServerInfo1510
		}
	case *ServerInfo_1511:
		if value != nil {
			return value.ServerInfo1511
		}
	case *ServerInfo_1512:
		if value != nil {
			return value.ServerInfo1512
		}
	case *ServerInfo_1513:
		if value != nil {
			return value.ServerInfo1513
		}
	case *ServerInfo_1514:
		if value != nil {
			return value.ServerInfo1514
		}
	case *ServerInfo_1515:
		if value != nil {
			return value.ServerInfo1515
		}
	case *ServerInfo_1516:
		if value != nil {
			return value.ServerInfo1516
		}
	case *ServerInfo_1518:
		if value != nil {
			return value.ServerInfo1518
		}
	case *ServerInfo_1523:
		if value != nil {
			return value.ServerInfo1523
		}
	case *ServerInfo_1528:
		if value != nil {
			return value.ServerInfo1528
		}
	case *ServerInfo_1529:
		if value != nil {
			return value.ServerInfo1529
		}
	case *ServerInfo_1530:
		if value != nil {
			return value.ServerInfo1530
		}
	case *ServerInfo_1533:
		if value != nil {
			return value.ServerInfo1533
		}
	case *ServerInfo_1534:
		if value != nil {
			return value.ServerInfo1534
		}
	case *ServerInfo_1535:
		if value != nil {
			return value.ServerInfo1535
		}
	case *ServerInfo_1536:
		if value != nil {
			return value.ServerInfo1536
		}
	case *ServerInfo_1538:
		if value != nil {
			return value.ServerInfo1538
		}
	case *ServerInfo_1539:
		if value != nil {
			return value.ServerInfo1539
		}
	case *ServerInfo_1540:
		if value != nil {
			return value.ServerInfo1540
		}
	case *ServerInfo_1541:
		if value != nil {
			return value.ServerInfo1541
		}
	case *ServerInfo_1542:
		if value != nil {
			return value.ServerInfo1542
		}
	case *ServerInfo_1543:
		if value != nil {
			return value.ServerInfo1543
		}
	case *ServerInfo_1544:
		if value != nil {
			return value.ServerInfo1544
		}
	case *ServerInfo_1545:
		if value != nil {
			return value.ServerInfo1545
		}
	case *ServerInfo_1546:
		if value != nil {
			return value.ServerInfo1546
		}
	case *ServerInfo_1547:
		if value != nil {
			return value.ServerInfo1547
		}
	case *ServerInfo_1548:
		if value != nil {
			return value.ServerInfo1548
		}
	case *ServerInfo_1549:
		if value != nil {
			return value.ServerInfo1549
		}
	case *ServerInfo_1550:
		if value != nil {
			return value.ServerInfo1550
		}
	case *ServerInfo_1552:
		if value != nil {
			return value.ServerInfo1552
		}
	case *ServerInfo_1553:
		if value != nil {
			return value.ServerInfo1553
		}
	case *ServerInfo_1554:
		if value != nil {
			return value.ServerInfo1554
		}
	case *ServerInfo_1555:
		if value != nil {
			return value.ServerInfo1555
		}
	case *ServerInfo_1556:
		if value != nil {
			return value.ServerInfo1556
		}
	}
	return nil
}

type is_ServerInfo interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_ServerInfo()
}

func (o *ServerInfo) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *ServerInfo_100:
		return uint32(100)
	case *ServerInfo_101:
		return uint32(101)
	case *ServerInfo_102:
		return uint32(102)
	case *ServerInfo_103:
		return uint32(103)
	case *ServerInfo_502:
		return uint32(502)
	case *ServerInfo_503:
		return uint32(503)
	case *ServerInfo_599:
		return uint32(599)
	case *ServerInfo_1005:
		return uint32(1005)
	case *ServerInfo_1107:
		return uint32(1107)
	case *ServerInfo_1010:
		return uint32(1010)
	case *ServerInfo_1016:
		return uint32(1016)
	case *ServerInfo_1017:
		return uint32(1017)
	case *ServerInfo_1018:
		return uint32(1018)
	case *ServerInfo_1501:
		return uint32(1501)
	case *ServerInfo_1502:
		return uint32(1502)
	case *ServerInfo_1503:
		return uint32(1503)
	case *ServerInfo_1506:
		return uint32(1506)
	case *ServerInfo_1510:
		return uint32(1510)
	case *ServerInfo_1511:
		return uint32(1511)
	case *ServerInfo_1512:
		return uint32(1512)
	case *ServerInfo_1513:
		return uint32(1513)
	case *ServerInfo_1514:
		return uint32(1514)
	case *ServerInfo_1515:
		return uint32(1515)
	case *ServerInfo_1516:
		return uint32(1516)
	case *ServerInfo_1518:
		return uint32(1518)
	case *ServerInfo_1523:
		return uint32(1523)
	case *ServerInfo_1528:
		return uint32(1528)
	case *ServerInfo_1529:
		return uint32(1529)
	case *ServerInfo_1530:
		return uint32(1530)
	case *ServerInfo_1533:
		return uint32(1533)
	case *ServerInfo_1534:
		return uint32(1534)
	case *ServerInfo_1535:
		return uint32(1535)
	case *ServerInfo_1536:
		return uint32(1536)
	case *ServerInfo_1538:
		return uint32(1538)
	case *ServerInfo_1539:
		return uint32(1539)
	case *ServerInfo_1540:
		return uint32(1540)
	case *ServerInfo_1541:
		return uint32(1541)
	case *ServerInfo_1542:
		return uint32(1542)
	case *ServerInfo_1543:
		return uint32(1543)
	case *ServerInfo_1544:
		return uint32(1544)
	case *ServerInfo_1545:
		return uint32(1545)
	case *ServerInfo_1546:
		return uint32(1546)
	case *ServerInfo_1547:
		return uint32(1547)
	case *ServerInfo_1548:
		return uint32(1548)
	case *ServerInfo_1549:
		return uint32(1549)
	case *ServerInfo_1550:
		return uint32(1550)
	case *ServerInfo_1552:
		return uint32(1552)
	case *ServerInfo_1553:
		return uint32(1553)
	case *ServerInfo_1554:
		return uint32(1554)
	case *ServerInfo_1555:
		return uint32(1555)
	case *ServerInfo_1556:
		return uint32(1556)
	}
	return uint32(0)
}

func (o *ServerInfo) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(100):
		_o, _ := o.Value.(*ServerInfo_100)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_100{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(101):
		_o, _ := o.Value.(*ServerInfo_101)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_101{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(102):
		_o, _ := o.Value.(*ServerInfo_102)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_102{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(103):
		_o, _ := o.Value.(*ServerInfo_103)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_103{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(502):
		_o, _ := o.Value.(*ServerInfo_502)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_502{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(503):
		_o, _ := o.Value.(*ServerInfo_503)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_503{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(599):
		_o, _ := o.Value.(*ServerInfo_599)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_599{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1005):
		_o, _ := o.Value.(*ServerInfo_1005)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1005{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1107):
		_o, _ := o.Value.(*ServerInfo_1107)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1107{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1010):
		_o, _ := o.Value.(*ServerInfo_1010)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1010{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1016):
		_o, _ := o.Value.(*ServerInfo_1016)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1016{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1017):
		_o, _ := o.Value.(*ServerInfo_1017)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1017{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1018):
		_o, _ := o.Value.(*ServerInfo_1018)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1018{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1501):
		_o, _ := o.Value.(*ServerInfo_1501)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1501{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1502):
		_o, _ := o.Value.(*ServerInfo_1502)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1502{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1503):
		_o, _ := o.Value.(*ServerInfo_1503)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1503{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1506):
		_o, _ := o.Value.(*ServerInfo_1506)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1506{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1510):
		_o, _ := o.Value.(*ServerInfo_1510)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1510{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1511):
		_o, _ := o.Value.(*ServerInfo_1511)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1511{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1512):
		_o, _ := o.Value.(*ServerInfo_1512)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1512{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1513):
		_o, _ := o.Value.(*ServerInfo_1513)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1513{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1514):
		_o, _ := o.Value.(*ServerInfo_1514)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1514{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1515):
		_o, _ := o.Value.(*ServerInfo_1515)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1515{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1516):
		_o, _ := o.Value.(*ServerInfo_1516)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1516{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1518):
		_o, _ := o.Value.(*ServerInfo_1518)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1518{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1523):
		_o, _ := o.Value.(*ServerInfo_1523)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1523{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1528):
		_o, _ := o.Value.(*ServerInfo_1528)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1528{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1529):
		_o, _ := o.Value.(*ServerInfo_1529)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1529{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1530):
		_o, _ := o.Value.(*ServerInfo_1530)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1530{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1533):
		_o, _ := o.Value.(*ServerInfo_1533)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1533{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1534):
		_o, _ := o.Value.(*ServerInfo_1534)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1534{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1535):
		_o, _ := o.Value.(*ServerInfo_1535)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1535{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1536):
		_o, _ := o.Value.(*ServerInfo_1536)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1536{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1538):
		_o, _ := o.Value.(*ServerInfo_1538)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1538{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1539):
		_o, _ := o.Value.(*ServerInfo_1539)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1539{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1540):
		_o, _ := o.Value.(*ServerInfo_1540)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1540{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1541):
		_o, _ := o.Value.(*ServerInfo_1541)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1541{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1542):
		_o, _ := o.Value.(*ServerInfo_1542)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1542{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1543):
		_o, _ := o.Value.(*ServerInfo_1543)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1543{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1544):
		_o, _ := o.Value.(*ServerInfo_1544)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1544{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1545):
		_o, _ := o.Value.(*ServerInfo_1545)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1545{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1546):
		_o, _ := o.Value.(*ServerInfo_1546)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1546{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1547):
		_o, _ := o.Value.(*ServerInfo_1547)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1547{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1548):
		_o, _ := o.Value.(*ServerInfo_1548)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1548{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1549):
		_o, _ := o.Value.(*ServerInfo_1549)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1549{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1550):
		_o, _ := o.Value.(*ServerInfo_1550)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1550{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1552):
		_o, _ := o.Value.(*ServerInfo_1552)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1552{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1553):
		_o, _ := o.Value.(*ServerInfo_1553)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1553{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1554):
		_o, _ := o.Value.(*ServerInfo_1554)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1554{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1555):
		_o, _ := o.Value.(*ServerInfo_1555)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1555{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1556):
		_o, _ := o.Value.(*ServerInfo_1556)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo_1556{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *ServerInfo) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(100):
		o.Value = &ServerInfo_100{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(101):
		o.Value = &ServerInfo_101{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(102):
		o.Value = &ServerInfo_102{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(103):
		o.Value = &ServerInfo_103{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(502):
		o.Value = &ServerInfo_502{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(503):
		o.Value = &ServerInfo_503{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(599):
		o.Value = &ServerInfo_599{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1005):
		o.Value = &ServerInfo_1005{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1107):
		o.Value = &ServerInfo_1107{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1010):
		o.Value = &ServerInfo_1010{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1016):
		o.Value = &ServerInfo_1016{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1017):
		o.Value = &ServerInfo_1017{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1018):
		o.Value = &ServerInfo_1018{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1501):
		o.Value = &ServerInfo_1501{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1502):
		o.Value = &ServerInfo_1502{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1503):
		o.Value = &ServerInfo_1503{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1506):
		o.Value = &ServerInfo_1506{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1510):
		o.Value = &ServerInfo_1510{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1511):
		o.Value = &ServerInfo_1511{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1512):
		o.Value = &ServerInfo_1512{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1513):
		o.Value = &ServerInfo_1513{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1514):
		o.Value = &ServerInfo_1514{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1515):
		o.Value = &ServerInfo_1515{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1516):
		o.Value = &ServerInfo_1516{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1518):
		o.Value = &ServerInfo_1518{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1523):
		o.Value = &ServerInfo_1523{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1528):
		o.Value = &ServerInfo_1528{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1529):
		o.Value = &ServerInfo_1529{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1530):
		o.Value = &ServerInfo_1530{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1533):
		o.Value = &ServerInfo_1533{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1534):
		o.Value = &ServerInfo_1534{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1535):
		o.Value = &ServerInfo_1535{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1536):
		o.Value = &ServerInfo_1536{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1538):
		o.Value = &ServerInfo_1538{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1539):
		o.Value = &ServerInfo_1539{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1540):
		o.Value = &ServerInfo_1540{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1541):
		o.Value = &ServerInfo_1541{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1542):
		o.Value = &ServerInfo_1542{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1543):
		o.Value = &ServerInfo_1543{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1544):
		o.Value = &ServerInfo_1544{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1545):
		o.Value = &ServerInfo_1545{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1546):
		o.Value = &ServerInfo_1546{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1547):
		o.Value = &ServerInfo_1547{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1548):
		o.Value = &ServerInfo_1548{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1549):
		o.Value = &ServerInfo_1549{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1550):
		o.Value = &ServerInfo_1550{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1552):
		o.Value = &ServerInfo_1552{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1553):
		o.Value = &ServerInfo_1553{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1554):
		o.Value = &ServerInfo_1554{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1555):
		o.Value = &ServerInfo_1555{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1556):
		o.Value = &ServerInfo_1556{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// ServerInfo_100 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 100
type ServerInfo_100 struct {
	// ServerInfo100:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.40.
	ServerInfo100 *dtyp.ServerInfo100 `idl:"name:ServerInfo100" json:"server_info100"`
}

func (*ServerInfo_100) is_ServerInfo() {}

func (o *ServerInfo_100) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo100 != nil {
		_ptr_ServerInfo100 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo100 != nil {
				if err := o.ServerInfo100.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&dtyp.ServerInfo100{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo100, _ptr_ServerInfo100); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_100) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo100 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo100 == nil {
			o.ServerInfo100 = &dtyp.ServerInfo100{}
		}
		if err := o.ServerInfo100.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo100 := func(ptr interface{}) { o.ServerInfo100 = *ptr.(**dtyp.ServerInfo100) }
	if err := w.ReadPointer(&o.ServerInfo100, _s_ServerInfo100, _ptr_ServerInfo100); err != nil {
		return err
	}
	return nil
}

// ServerInfo_101 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 101
type ServerInfo_101 struct {
	// ServerInfo101:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.41.
	ServerInfo101 *dtyp.ServerInfo101 `idl:"name:ServerInfo101" json:"server_info101"`
}

func (*ServerInfo_101) is_ServerInfo() {}

func (o *ServerInfo_101) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo101 != nil {
		_ptr_ServerInfo101 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo101 != nil {
				if err := o.ServerInfo101.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&dtyp.ServerInfo101{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo101, _ptr_ServerInfo101); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_101) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo101 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo101 == nil {
			o.ServerInfo101 = &dtyp.ServerInfo101{}
		}
		if err := o.ServerInfo101.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo101 := func(ptr interface{}) { o.ServerInfo101 = *ptr.(**dtyp.ServerInfo101) }
	if err := w.ReadPointer(&o.ServerInfo101, _s_ServerInfo101, _ptr_ServerInfo101); err != nil {
		return err
	}
	return nil
}

// ServerInfo_102 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 102
type ServerInfo_102 struct {
	// ServerInfo102:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.42.
	ServerInfo102 *ServerInfo102 `idl:"name:ServerInfo102" json:"server_info102"`
}

func (*ServerInfo_102) is_ServerInfo() {}

func (o *ServerInfo_102) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo102 != nil {
		_ptr_ServerInfo102 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo102 != nil {
				if err := o.ServerInfo102.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo102{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo102, _ptr_ServerInfo102); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_102) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo102 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo102 == nil {
			o.ServerInfo102 = &ServerInfo102{}
		}
		if err := o.ServerInfo102.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo102 := func(ptr interface{}) { o.ServerInfo102 = *ptr.(**ServerInfo102) }
	if err := w.ReadPointer(&o.ServerInfo102, _s_ServerInfo102, _ptr_ServerInfo102); err != nil {
		return err
	}
	return nil
}

// ServerInfo_103 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 103
type ServerInfo_103 struct {
	// ServerInfo103:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.43.<8>
	ServerInfo103 *ServerInfo103 `idl:"name:ServerInfo103" json:"server_info103"`
}

func (*ServerInfo_103) is_ServerInfo() {}

func (o *ServerInfo_103) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo103 != nil {
		_ptr_ServerInfo103 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo103 != nil {
				if err := o.ServerInfo103.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo103{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo103, _ptr_ServerInfo103); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_103) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo103 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo103 == nil {
			o.ServerInfo103 = &ServerInfo103{}
		}
		if err := o.ServerInfo103.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo103 := func(ptr interface{}) { o.ServerInfo103 = *ptr.(**ServerInfo103) }
	if err := w.ReadPointer(&o.ServerInfo103, _s_ServerInfo103, _ptr_ServerInfo103); err != nil {
		return err
	}
	return nil
}

// ServerInfo_502 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 502
type ServerInfo_502 struct {
	// ServerInfo502:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.44.
	ServerInfo502 *ServerInfo502 `idl:"name:ServerInfo502" json:"server_info502"`
}

func (*ServerInfo_502) is_ServerInfo() {}

func (o *ServerInfo_502) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo502 != nil {
		_ptr_ServerInfo502 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo502 != nil {
				if err := o.ServerInfo502.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo502{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo502, _ptr_ServerInfo502); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_502) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo502 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo502 == nil {
			o.ServerInfo502 = &ServerInfo502{}
		}
		if err := o.ServerInfo502.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo502 := func(ptr interface{}) { o.ServerInfo502 = *ptr.(**ServerInfo502) }
	if err := w.ReadPointer(&o.ServerInfo502, _s_ServerInfo502, _ptr_ServerInfo502); err != nil {
		return err
	}
	return nil
}

// ServerInfo_503 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 503
type ServerInfo_503 struct {
	// ServerInfo503:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.45.
	ServerInfo503 *ServerInfo503 `idl:"name:ServerInfo503" json:"server_info503"`
}

func (*ServerInfo_503) is_ServerInfo() {}

func (o *ServerInfo_503) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo503 != nil {
		_ptr_ServerInfo503 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo503 != nil {
				if err := o.ServerInfo503.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo503{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo503, _ptr_ServerInfo503); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_503) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo503 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo503 == nil {
			o.ServerInfo503 = &ServerInfo503{}
		}
		if err := o.ServerInfo503.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo503 := func(ptr interface{}) { o.ServerInfo503 = *ptr.(**ServerInfo503) }
	if err := w.ReadPointer(&o.ServerInfo503, _s_ServerInfo503, _ptr_ServerInfo503); err != nil {
		return err
	}
	return nil
}

// ServerInfo_599 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 599
type ServerInfo_599 struct {
	// ServerInfo599:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.46.
	ServerInfo599 *ServerInfo599 `idl:"name:ServerInfo599" json:"server_info599"`
}

func (*ServerInfo_599) is_ServerInfo() {}

func (o *ServerInfo_599) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo599 != nil {
		_ptr_ServerInfo599 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo599 != nil {
				if err := o.ServerInfo599.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo599{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo599, _ptr_ServerInfo599); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_599) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo599 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo599 == nil {
			o.ServerInfo599 = &ServerInfo599{}
		}
		if err := o.ServerInfo599.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo599 := func(ptr interface{}) { o.ServerInfo599 = *ptr.(**ServerInfo599) }
	if err := w.ReadPointer(&o.ServerInfo599, _s_ServerInfo599, _ptr_ServerInfo599); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1005 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1005
type ServerInfo_1005 struct {
	// ServerInfo1005:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.47.
	ServerInfo1005 *ServerInfo1005 `idl:"name:ServerInfo1005" json:"server_info1005"`
}

func (*ServerInfo_1005) is_ServerInfo() {}

func (o *ServerInfo_1005) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1005 != nil {
		_ptr_ServerInfo1005 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1005 != nil {
				if err := o.ServerInfo1005.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1005{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1005, _ptr_ServerInfo1005); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1005) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1005 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1005 == nil {
			o.ServerInfo1005 = &ServerInfo1005{}
		}
		if err := o.ServerInfo1005.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1005 := func(ptr interface{}) { o.ServerInfo1005 = *ptr.(**ServerInfo1005) }
	if err := w.ReadPointer(&o.ServerInfo1005, _s_ServerInfo1005, _ptr_ServerInfo1005); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1107 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1107
type ServerInfo_1107 struct {
	// ServerInfo1107:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.48.
	ServerInfo1107 *ServerInfo1107 `idl:"name:ServerInfo1107" json:"server_info1107"`
}

func (*ServerInfo_1107) is_ServerInfo() {}

func (o *ServerInfo_1107) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1107 != nil {
		_ptr_ServerInfo1107 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1107 != nil {
				if err := o.ServerInfo1107.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1107{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1107, _ptr_ServerInfo1107); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1107) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1107 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1107 == nil {
			o.ServerInfo1107 = &ServerInfo1107{}
		}
		if err := o.ServerInfo1107.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1107 := func(ptr interface{}) { o.ServerInfo1107 = *ptr.(**ServerInfo1107) }
	if err := w.ReadPointer(&o.ServerInfo1107, _s_ServerInfo1107, _ptr_ServerInfo1107); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1010 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1010
type ServerInfo_1010 struct {
	// ServerInfo1010:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.49.
	ServerInfo1010 *ServerInfo1010 `idl:"name:ServerInfo1010" json:"server_info1010"`
}

func (*ServerInfo_1010) is_ServerInfo() {}

func (o *ServerInfo_1010) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1010 != nil {
		_ptr_ServerInfo1010 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1010 != nil {
				if err := o.ServerInfo1010.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1010{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1010, _ptr_ServerInfo1010); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1010) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1010 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1010 == nil {
			o.ServerInfo1010 = &ServerInfo1010{}
		}
		if err := o.ServerInfo1010.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1010 := func(ptr interface{}) { o.ServerInfo1010 = *ptr.(**ServerInfo1010) }
	if err := w.ReadPointer(&o.ServerInfo1010, _s_ServerInfo1010, _ptr_ServerInfo1010); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1016 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1016
type ServerInfo_1016 struct {
	// ServerInfo1016:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.50.
	ServerInfo1016 *ServerInfo1016 `idl:"name:ServerInfo1016" json:"server_info1016"`
}

func (*ServerInfo_1016) is_ServerInfo() {}

func (o *ServerInfo_1016) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1016 != nil {
		_ptr_ServerInfo1016 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1016 != nil {
				if err := o.ServerInfo1016.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1016{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1016, _ptr_ServerInfo1016); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1016) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1016 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1016 == nil {
			o.ServerInfo1016 = &ServerInfo1016{}
		}
		if err := o.ServerInfo1016.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1016 := func(ptr interface{}) { o.ServerInfo1016 = *ptr.(**ServerInfo1016) }
	if err := w.ReadPointer(&o.ServerInfo1016, _s_ServerInfo1016, _ptr_ServerInfo1016); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1017 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1017
type ServerInfo_1017 struct {
	// ServerInfo1017:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.51.
	ServerInfo1017 *ServerInfo1017 `idl:"name:ServerInfo1017" json:"server_info1017"`
}

func (*ServerInfo_1017) is_ServerInfo() {}

func (o *ServerInfo_1017) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1017 != nil {
		_ptr_ServerInfo1017 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1017 != nil {
				if err := o.ServerInfo1017.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1017{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1017, _ptr_ServerInfo1017); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1017) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1017 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1017 == nil {
			o.ServerInfo1017 = &ServerInfo1017{}
		}
		if err := o.ServerInfo1017.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1017 := func(ptr interface{}) { o.ServerInfo1017 = *ptr.(**ServerInfo1017) }
	if err := w.ReadPointer(&o.ServerInfo1017, _s_ServerInfo1017, _ptr_ServerInfo1017); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1018 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1018
type ServerInfo_1018 struct {
	// ServerInfo1018:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.52.
	ServerInfo1018 *ServerInfo1018 `idl:"name:ServerInfo1018" json:"server_info1018"`
}

func (*ServerInfo_1018) is_ServerInfo() {}

func (o *ServerInfo_1018) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1018 != nil {
		_ptr_ServerInfo1018 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1018 != nil {
				if err := o.ServerInfo1018.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1018{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1018, _ptr_ServerInfo1018); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1018) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1018 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1018 == nil {
			o.ServerInfo1018 = &ServerInfo1018{}
		}
		if err := o.ServerInfo1018.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1018 := func(ptr interface{}) { o.ServerInfo1018 = *ptr.(**ServerInfo1018) }
	if err := w.ReadPointer(&o.ServerInfo1018, _s_ServerInfo1018, _ptr_ServerInfo1018); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1501 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1501
type ServerInfo_1501 struct {
	// ServerInfo1501:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.53.
	ServerInfo1501 *ServerInfo1501 `idl:"name:ServerInfo1501" json:"server_info1501"`
}

func (*ServerInfo_1501) is_ServerInfo() {}

func (o *ServerInfo_1501) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1501 != nil {
		_ptr_ServerInfo1501 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1501 != nil {
				if err := o.ServerInfo1501.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1501{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1501, _ptr_ServerInfo1501); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1501) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1501 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1501 == nil {
			o.ServerInfo1501 = &ServerInfo1501{}
		}
		if err := o.ServerInfo1501.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1501 := func(ptr interface{}) { o.ServerInfo1501 = *ptr.(**ServerInfo1501) }
	if err := w.ReadPointer(&o.ServerInfo1501, _s_ServerInfo1501, _ptr_ServerInfo1501); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1502 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1502
type ServerInfo_1502 struct {
	// ServerInfo1502:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.54.
	ServerInfo1502 *ServerInfo1502 `idl:"name:ServerInfo1502" json:"server_info1502"`
}

func (*ServerInfo_1502) is_ServerInfo() {}

func (o *ServerInfo_1502) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1502 != nil {
		_ptr_ServerInfo1502 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1502 != nil {
				if err := o.ServerInfo1502.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1502{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1502, _ptr_ServerInfo1502); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1502) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1502 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1502 == nil {
			o.ServerInfo1502 = &ServerInfo1502{}
		}
		if err := o.ServerInfo1502.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1502 := func(ptr interface{}) { o.ServerInfo1502 = *ptr.(**ServerInfo1502) }
	if err := w.ReadPointer(&o.ServerInfo1502, _s_ServerInfo1502, _ptr_ServerInfo1502); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1503 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1503
type ServerInfo_1503 struct {
	// ServerInfo1503:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.55.
	ServerInfo1503 *ServerInfo1503 `idl:"name:ServerInfo1503" json:"server_info1503"`
}

func (*ServerInfo_1503) is_ServerInfo() {}

func (o *ServerInfo_1503) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1503 != nil {
		_ptr_ServerInfo1503 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1503 != nil {
				if err := o.ServerInfo1503.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1503{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1503, _ptr_ServerInfo1503); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1503) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1503 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1503 == nil {
			o.ServerInfo1503 = &ServerInfo1503{}
		}
		if err := o.ServerInfo1503.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1503 := func(ptr interface{}) { o.ServerInfo1503 = *ptr.(**ServerInfo1503) }
	if err := w.ReadPointer(&o.ServerInfo1503, _s_ServerInfo1503, _ptr_ServerInfo1503); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1506 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1506
type ServerInfo_1506 struct {
	// ServerInfo1506:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.56.
	ServerInfo1506 *ServerInfo1506 `idl:"name:ServerInfo1506" json:"server_info1506"`
}

func (*ServerInfo_1506) is_ServerInfo() {}

func (o *ServerInfo_1506) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1506 != nil {
		_ptr_ServerInfo1506 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1506 != nil {
				if err := o.ServerInfo1506.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1506{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1506, _ptr_ServerInfo1506); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1506) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1506 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1506 == nil {
			o.ServerInfo1506 = &ServerInfo1506{}
		}
		if err := o.ServerInfo1506.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1506 := func(ptr interface{}) { o.ServerInfo1506 = *ptr.(**ServerInfo1506) }
	if err := w.ReadPointer(&o.ServerInfo1506, _s_ServerInfo1506, _ptr_ServerInfo1506); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1510 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1510
type ServerInfo_1510 struct {
	// ServerInfo1510:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.57.
	ServerInfo1510 *ServerInfo1510 `idl:"name:ServerInfo1510" json:"server_info1510"`
}

func (*ServerInfo_1510) is_ServerInfo() {}

func (o *ServerInfo_1510) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1510 != nil {
		_ptr_ServerInfo1510 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1510 != nil {
				if err := o.ServerInfo1510.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1510{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1510, _ptr_ServerInfo1510); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1510) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1510 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1510 == nil {
			o.ServerInfo1510 = &ServerInfo1510{}
		}
		if err := o.ServerInfo1510.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1510 := func(ptr interface{}) { o.ServerInfo1510 = *ptr.(**ServerInfo1510) }
	if err := w.ReadPointer(&o.ServerInfo1510, _s_ServerInfo1510, _ptr_ServerInfo1510); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1511 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1511
type ServerInfo_1511 struct {
	// ServerInfo1511:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.58.
	ServerInfo1511 *ServerInfo1511 `idl:"name:ServerInfo1511" json:"server_info1511"`
}

func (*ServerInfo_1511) is_ServerInfo() {}

func (o *ServerInfo_1511) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1511 != nil {
		_ptr_ServerInfo1511 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1511 != nil {
				if err := o.ServerInfo1511.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1511{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1511, _ptr_ServerInfo1511); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1511) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1511 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1511 == nil {
			o.ServerInfo1511 = &ServerInfo1511{}
		}
		if err := o.ServerInfo1511.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1511 := func(ptr interface{}) { o.ServerInfo1511 = *ptr.(**ServerInfo1511) }
	if err := w.ReadPointer(&o.ServerInfo1511, _s_ServerInfo1511, _ptr_ServerInfo1511); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1512 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1512
type ServerInfo_1512 struct {
	// ServerInfo1512:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.59.
	ServerInfo1512 *ServerInfo1512 `idl:"name:ServerInfo1512" json:"server_info1512"`
}

func (*ServerInfo_1512) is_ServerInfo() {}

func (o *ServerInfo_1512) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1512 != nil {
		_ptr_ServerInfo1512 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1512 != nil {
				if err := o.ServerInfo1512.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1512{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1512, _ptr_ServerInfo1512); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1512) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1512 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1512 == nil {
			o.ServerInfo1512 = &ServerInfo1512{}
		}
		if err := o.ServerInfo1512.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1512 := func(ptr interface{}) { o.ServerInfo1512 = *ptr.(**ServerInfo1512) }
	if err := w.ReadPointer(&o.ServerInfo1512, _s_ServerInfo1512, _ptr_ServerInfo1512); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1513 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1513
type ServerInfo_1513 struct {
	// ServerInfo1513:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.60.
	ServerInfo1513 *ServerInfo1513 `idl:"name:ServerInfo1513" json:"server_info1513"`
}

func (*ServerInfo_1513) is_ServerInfo() {}

func (o *ServerInfo_1513) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1513 != nil {
		_ptr_ServerInfo1513 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1513 != nil {
				if err := o.ServerInfo1513.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1513{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1513, _ptr_ServerInfo1513); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1513) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1513 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1513 == nil {
			o.ServerInfo1513 = &ServerInfo1513{}
		}
		if err := o.ServerInfo1513.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1513 := func(ptr interface{}) { o.ServerInfo1513 = *ptr.(**ServerInfo1513) }
	if err := w.ReadPointer(&o.ServerInfo1513, _s_ServerInfo1513, _ptr_ServerInfo1513); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1514 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1514
type ServerInfo_1514 struct {
	// ServerInfo1514:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.61.
	ServerInfo1514 *ServerInfo1514 `idl:"name:ServerInfo1514" json:"server_info1514"`
}

func (*ServerInfo_1514) is_ServerInfo() {}

func (o *ServerInfo_1514) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1514 != nil {
		_ptr_ServerInfo1514 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1514 != nil {
				if err := o.ServerInfo1514.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1514{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1514, _ptr_ServerInfo1514); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1514) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1514 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1514 == nil {
			o.ServerInfo1514 = &ServerInfo1514{}
		}
		if err := o.ServerInfo1514.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1514 := func(ptr interface{}) { o.ServerInfo1514 = *ptr.(**ServerInfo1514) }
	if err := w.ReadPointer(&o.ServerInfo1514, _s_ServerInfo1514, _ptr_ServerInfo1514); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1515 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1515
type ServerInfo_1515 struct {
	// ServerInfo1515:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.62
	ServerInfo1515 *ServerInfo1515 `idl:"name:ServerInfo1515" json:"server_info1515"`
}

func (*ServerInfo_1515) is_ServerInfo() {}

func (o *ServerInfo_1515) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1515 != nil {
		_ptr_ServerInfo1515 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1515 != nil {
				if err := o.ServerInfo1515.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1515{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1515, _ptr_ServerInfo1515); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1515) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1515 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1515 == nil {
			o.ServerInfo1515 = &ServerInfo1515{}
		}
		if err := o.ServerInfo1515.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1515 := func(ptr interface{}) { o.ServerInfo1515 = *ptr.(**ServerInfo1515) }
	if err := w.ReadPointer(&o.ServerInfo1515, _s_ServerInfo1515, _ptr_ServerInfo1515); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1516 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1516
type ServerInfo_1516 struct {
	// ServerInfo1516:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.63.
	ServerInfo1516 *ServerInfo1516 `idl:"name:ServerInfo1516" json:"server_info1516"`
}

func (*ServerInfo_1516) is_ServerInfo() {}

func (o *ServerInfo_1516) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1516 != nil {
		_ptr_ServerInfo1516 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1516 != nil {
				if err := o.ServerInfo1516.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1516{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1516, _ptr_ServerInfo1516); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1516) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1516 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1516 == nil {
			o.ServerInfo1516 = &ServerInfo1516{}
		}
		if err := o.ServerInfo1516.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1516 := func(ptr interface{}) { o.ServerInfo1516 = *ptr.(**ServerInfo1516) }
	if err := w.ReadPointer(&o.ServerInfo1516, _s_ServerInfo1516, _ptr_ServerInfo1516); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1518 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1518
type ServerInfo_1518 struct {
	// ServerInfo1518:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.64.
	ServerInfo1518 *ServerInfo1518 `idl:"name:ServerInfo1518" json:"server_info1518"`
}

func (*ServerInfo_1518) is_ServerInfo() {}

func (o *ServerInfo_1518) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1518 != nil {
		_ptr_ServerInfo1518 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1518 != nil {
				if err := o.ServerInfo1518.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1518{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1518, _ptr_ServerInfo1518); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1518) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1518 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1518 == nil {
			o.ServerInfo1518 = &ServerInfo1518{}
		}
		if err := o.ServerInfo1518.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1518 := func(ptr interface{}) { o.ServerInfo1518 = *ptr.(**ServerInfo1518) }
	if err := w.ReadPointer(&o.ServerInfo1518, _s_ServerInfo1518, _ptr_ServerInfo1518); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1523 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1523
type ServerInfo_1523 struct {
	// ServerInfo1523:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.65.
	ServerInfo1523 *ServerInfo1523 `idl:"name:ServerInfo1523" json:"server_info1523"`
}

func (*ServerInfo_1523) is_ServerInfo() {}

func (o *ServerInfo_1523) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1523 != nil {
		_ptr_ServerInfo1523 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1523 != nil {
				if err := o.ServerInfo1523.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1523{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1523, _ptr_ServerInfo1523); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1523) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1523 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1523 == nil {
			o.ServerInfo1523 = &ServerInfo1523{}
		}
		if err := o.ServerInfo1523.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1523 := func(ptr interface{}) { o.ServerInfo1523 = *ptr.(**ServerInfo1523) }
	if err := w.ReadPointer(&o.ServerInfo1523, _s_ServerInfo1523, _ptr_ServerInfo1523); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1528 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1528
type ServerInfo_1528 struct {
	// ServerInfo1528:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.66.
	ServerInfo1528 *ServerInfo1528 `idl:"name:ServerInfo1528" json:"server_info1528"`
}

func (*ServerInfo_1528) is_ServerInfo() {}

func (o *ServerInfo_1528) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1528 != nil {
		_ptr_ServerInfo1528 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1528 != nil {
				if err := o.ServerInfo1528.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1528{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1528, _ptr_ServerInfo1528); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1528) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1528 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1528 == nil {
			o.ServerInfo1528 = &ServerInfo1528{}
		}
		if err := o.ServerInfo1528.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1528 := func(ptr interface{}) { o.ServerInfo1528 = *ptr.(**ServerInfo1528) }
	if err := w.ReadPointer(&o.ServerInfo1528, _s_ServerInfo1528, _ptr_ServerInfo1528); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1529 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1529
type ServerInfo_1529 struct {
	// ServerInfo1529:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.67.
	ServerInfo1529 *ServerInfo1529 `idl:"name:ServerInfo1529" json:"server_info1529"`
}

func (*ServerInfo_1529) is_ServerInfo() {}

func (o *ServerInfo_1529) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1529 != nil {
		_ptr_ServerInfo1529 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1529 != nil {
				if err := o.ServerInfo1529.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1529{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1529, _ptr_ServerInfo1529); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1529) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1529 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1529 == nil {
			o.ServerInfo1529 = &ServerInfo1529{}
		}
		if err := o.ServerInfo1529.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1529 := func(ptr interface{}) { o.ServerInfo1529 = *ptr.(**ServerInfo1529) }
	if err := w.ReadPointer(&o.ServerInfo1529, _s_ServerInfo1529, _ptr_ServerInfo1529); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1530 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1530
type ServerInfo_1530 struct {
	// ServerInfo1530:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.68.
	ServerInfo1530 *ServerInfo1530 `idl:"name:ServerInfo1530" json:"server_info1530"`
}

func (*ServerInfo_1530) is_ServerInfo() {}

func (o *ServerInfo_1530) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1530 != nil {
		_ptr_ServerInfo1530 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1530 != nil {
				if err := o.ServerInfo1530.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1530{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1530, _ptr_ServerInfo1530); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1530) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1530 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1530 == nil {
			o.ServerInfo1530 = &ServerInfo1530{}
		}
		if err := o.ServerInfo1530.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1530 := func(ptr interface{}) { o.ServerInfo1530 = *ptr.(**ServerInfo1530) }
	if err := w.ReadPointer(&o.ServerInfo1530, _s_ServerInfo1530, _ptr_ServerInfo1530); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1533 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1533
type ServerInfo_1533 struct {
	// ServerInfo1533:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.69.
	ServerInfo1533 *ServerInfo1533 `idl:"name:ServerInfo1533" json:"server_info1533"`
}

func (*ServerInfo_1533) is_ServerInfo() {}

func (o *ServerInfo_1533) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1533 != nil {
		_ptr_ServerInfo1533 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1533 != nil {
				if err := o.ServerInfo1533.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1533{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1533, _ptr_ServerInfo1533); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1533) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1533 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1533 == nil {
			o.ServerInfo1533 = &ServerInfo1533{}
		}
		if err := o.ServerInfo1533.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1533 := func(ptr interface{}) { o.ServerInfo1533 = *ptr.(**ServerInfo1533) }
	if err := w.ReadPointer(&o.ServerInfo1533, _s_ServerInfo1533, _ptr_ServerInfo1533); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1534 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1534
type ServerInfo_1534 struct {
	// ServerInfo1534:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.70.
	ServerInfo1534 *ServerInfo1534 `idl:"name:ServerInfo1534" json:"server_info1534"`
}

func (*ServerInfo_1534) is_ServerInfo() {}

func (o *ServerInfo_1534) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1534 != nil {
		_ptr_ServerInfo1534 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1534 != nil {
				if err := o.ServerInfo1534.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1534{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1534, _ptr_ServerInfo1534); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1534) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1534 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1534 == nil {
			o.ServerInfo1534 = &ServerInfo1534{}
		}
		if err := o.ServerInfo1534.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1534 := func(ptr interface{}) { o.ServerInfo1534 = *ptr.(**ServerInfo1534) }
	if err := w.ReadPointer(&o.ServerInfo1534, _s_ServerInfo1534, _ptr_ServerInfo1534); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1535 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1535
type ServerInfo_1535 struct {
	// ServerInfo1535:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.71.
	ServerInfo1535 *ServerInfo1535 `idl:"name:ServerInfo1535" json:"server_info1535"`
}

func (*ServerInfo_1535) is_ServerInfo() {}

func (o *ServerInfo_1535) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1535 != nil {
		_ptr_ServerInfo1535 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1535 != nil {
				if err := o.ServerInfo1535.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1535{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1535, _ptr_ServerInfo1535); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1535) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1535 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1535 == nil {
			o.ServerInfo1535 = &ServerInfo1535{}
		}
		if err := o.ServerInfo1535.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1535 := func(ptr interface{}) { o.ServerInfo1535 = *ptr.(**ServerInfo1535) }
	if err := w.ReadPointer(&o.ServerInfo1535, _s_ServerInfo1535, _ptr_ServerInfo1535); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1536 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1536
type ServerInfo_1536 struct {
	// ServerInfo1536:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.72.
	ServerInfo1536 *ServerInfo1536 `idl:"name:ServerInfo1536" json:"server_info1536"`
}

func (*ServerInfo_1536) is_ServerInfo() {}

func (o *ServerInfo_1536) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1536 != nil {
		_ptr_ServerInfo1536 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1536 != nil {
				if err := o.ServerInfo1536.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1536{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1536, _ptr_ServerInfo1536); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1536) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1536 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1536 == nil {
			o.ServerInfo1536 = &ServerInfo1536{}
		}
		if err := o.ServerInfo1536.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1536 := func(ptr interface{}) { o.ServerInfo1536 = *ptr.(**ServerInfo1536) }
	if err := w.ReadPointer(&o.ServerInfo1536, _s_ServerInfo1536, _ptr_ServerInfo1536); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1538 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1538
type ServerInfo_1538 struct {
	// ServerInfo1538:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.73.
	ServerInfo1538 *ServerInfo1538 `idl:"name:ServerInfo1538" json:"server_info1538"`
}

func (*ServerInfo_1538) is_ServerInfo() {}

func (o *ServerInfo_1538) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1538 != nil {
		_ptr_ServerInfo1538 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1538 != nil {
				if err := o.ServerInfo1538.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1538{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1538, _ptr_ServerInfo1538); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1538) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1538 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1538 == nil {
			o.ServerInfo1538 = &ServerInfo1538{}
		}
		if err := o.ServerInfo1538.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1538 := func(ptr interface{}) { o.ServerInfo1538 = *ptr.(**ServerInfo1538) }
	if err := w.ReadPointer(&o.ServerInfo1538, _s_ServerInfo1538, _ptr_ServerInfo1538); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1539 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1539
type ServerInfo_1539 struct {
	// ServerInfo1539:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.74.
	ServerInfo1539 *ServerInfo1539 `idl:"name:ServerInfo1539" json:"server_info1539"`
}

func (*ServerInfo_1539) is_ServerInfo() {}

func (o *ServerInfo_1539) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1539 != nil {
		_ptr_ServerInfo1539 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1539 != nil {
				if err := o.ServerInfo1539.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1539{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1539, _ptr_ServerInfo1539); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1539) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1539 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1539 == nil {
			o.ServerInfo1539 = &ServerInfo1539{}
		}
		if err := o.ServerInfo1539.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1539 := func(ptr interface{}) { o.ServerInfo1539 = *ptr.(**ServerInfo1539) }
	if err := w.ReadPointer(&o.ServerInfo1539, _s_ServerInfo1539, _ptr_ServerInfo1539); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1540 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1540
type ServerInfo_1540 struct {
	// ServerInfo1540:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.75.
	ServerInfo1540 *ServerInfo1540 `idl:"name:ServerInfo1540" json:"server_info1540"`
}

func (*ServerInfo_1540) is_ServerInfo() {}

func (o *ServerInfo_1540) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1540 != nil {
		_ptr_ServerInfo1540 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1540 != nil {
				if err := o.ServerInfo1540.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1540{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1540, _ptr_ServerInfo1540); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1540) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1540 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1540 == nil {
			o.ServerInfo1540 = &ServerInfo1540{}
		}
		if err := o.ServerInfo1540.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1540 := func(ptr interface{}) { o.ServerInfo1540 = *ptr.(**ServerInfo1540) }
	if err := w.ReadPointer(&o.ServerInfo1540, _s_ServerInfo1540, _ptr_ServerInfo1540); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1541 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1541
type ServerInfo_1541 struct {
	// ServerInfo1541:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.76.
	ServerInfo1541 *ServerInfo1541 `idl:"name:ServerInfo1541" json:"server_info1541"`
}

func (*ServerInfo_1541) is_ServerInfo() {}

func (o *ServerInfo_1541) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1541 != nil {
		_ptr_ServerInfo1541 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1541 != nil {
				if err := o.ServerInfo1541.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1541{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1541, _ptr_ServerInfo1541); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1541) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1541 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1541 == nil {
			o.ServerInfo1541 = &ServerInfo1541{}
		}
		if err := o.ServerInfo1541.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1541 := func(ptr interface{}) { o.ServerInfo1541 = *ptr.(**ServerInfo1541) }
	if err := w.ReadPointer(&o.ServerInfo1541, _s_ServerInfo1541, _ptr_ServerInfo1541); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1542 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1542
type ServerInfo_1542 struct {
	// ServerInfo1542:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.77.
	ServerInfo1542 *ServerInfo1542 `idl:"name:ServerInfo1542" json:"server_info1542"`
}

func (*ServerInfo_1542) is_ServerInfo() {}

func (o *ServerInfo_1542) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1542 != nil {
		_ptr_ServerInfo1542 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1542 != nil {
				if err := o.ServerInfo1542.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1542{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1542, _ptr_ServerInfo1542); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1542) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1542 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1542 == nil {
			o.ServerInfo1542 = &ServerInfo1542{}
		}
		if err := o.ServerInfo1542.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1542 := func(ptr interface{}) { o.ServerInfo1542 = *ptr.(**ServerInfo1542) }
	if err := w.ReadPointer(&o.ServerInfo1542, _s_ServerInfo1542, _ptr_ServerInfo1542); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1543 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1543
type ServerInfo_1543 struct {
	// ServerInfo1543:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.78.
	ServerInfo1543 *ServerInfo1543 `idl:"name:ServerInfo1543" json:"server_info1543"`
}

func (*ServerInfo_1543) is_ServerInfo() {}

func (o *ServerInfo_1543) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1543 != nil {
		_ptr_ServerInfo1543 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1543 != nil {
				if err := o.ServerInfo1543.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1543{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1543, _ptr_ServerInfo1543); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1543) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1543 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1543 == nil {
			o.ServerInfo1543 = &ServerInfo1543{}
		}
		if err := o.ServerInfo1543.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1543 := func(ptr interface{}) { o.ServerInfo1543 = *ptr.(**ServerInfo1543) }
	if err := w.ReadPointer(&o.ServerInfo1543, _s_ServerInfo1543, _ptr_ServerInfo1543); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1544 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1544
type ServerInfo_1544 struct {
	// ServerInfo1544:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.79.
	ServerInfo1544 *ServerInfo1544 `idl:"name:ServerInfo1544" json:"server_info1544"`
}

func (*ServerInfo_1544) is_ServerInfo() {}

func (o *ServerInfo_1544) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1544 != nil {
		_ptr_ServerInfo1544 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1544 != nil {
				if err := o.ServerInfo1544.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1544{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1544, _ptr_ServerInfo1544); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1544) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1544 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1544 == nil {
			o.ServerInfo1544 = &ServerInfo1544{}
		}
		if err := o.ServerInfo1544.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1544 := func(ptr interface{}) { o.ServerInfo1544 = *ptr.(**ServerInfo1544) }
	if err := w.ReadPointer(&o.ServerInfo1544, _s_ServerInfo1544, _ptr_ServerInfo1544); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1545 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1545
type ServerInfo_1545 struct {
	// ServerInfo1545:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.80.
	ServerInfo1545 *ServerInfo1545 `idl:"name:ServerInfo1545" json:"server_info1545"`
}

func (*ServerInfo_1545) is_ServerInfo() {}

func (o *ServerInfo_1545) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1545 != nil {
		_ptr_ServerInfo1545 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1545 != nil {
				if err := o.ServerInfo1545.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1545{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1545, _ptr_ServerInfo1545); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1545) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1545 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1545 == nil {
			o.ServerInfo1545 = &ServerInfo1545{}
		}
		if err := o.ServerInfo1545.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1545 := func(ptr interface{}) { o.ServerInfo1545 = *ptr.(**ServerInfo1545) }
	if err := w.ReadPointer(&o.ServerInfo1545, _s_ServerInfo1545, _ptr_ServerInfo1545); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1546 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1546
type ServerInfo_1546 struct {
	// ServerInfo1546:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.81.
	ServerInfo1546 *ServerInfo1546 `idl:"name:ServerInfo1546" json:"server_info1546"`
}

func (*ServerInfo_1546) is_ServerInfo() {}

func (o *ServerInfo_1546) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1546 != nil {
		_ptr_ServerInfo1546 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1546 != nil {
				if err := o.ServerInfo1546.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1546{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1546, _ptr_ServerInfo1546); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1546) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1546 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1546 == nil {
			o.ServerInfo1546 = &ServerInfo1546{}
		}
		if err := o.ServerInfo1546.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1546 := func(ptr interface{}) { o.ServerInfo1546 = *ptr.(**ServerInfo1546) }
	if err := w.ReadPointer(&o.ServerInfo1546, _s_ServerInfo1546, _ptr_ServerInfo1546); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1547 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1547
type ServerInfo_1547 struct {
	// ServerInfo1547:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.82.
	ServerInfo1547 *ServerInfo1547 `idl:"name:ServerInfo1547" json:"server_info1547"`
}

func (*ServerInfo_1547) is_ServerInfo() {}

func (o *ServerInfo_1547) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1547 != nil {
		_ptr_ServerInfo1547 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1547 != nil {
				if err := o.ServerInfo1547.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1547{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1547, _ptr_ServerInfo1547); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1547) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1547 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1547 == nil {
			o.ServerInfo1547 = &ServerInfo1547{}
		}
		if err := o.ServerInfo1547.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1547 := func(ptr interface{}) { o.ServerInfo1547 = *ptr.(**ServerInfo1547) }
	if err := w.ReadPointer(&o.ServerInfo1547, _s_ServerInfo1547, _ptr_ServerInfo1547); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1548 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1548
type ServerInfo_1548 struct {
	// ServerInfo1548:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.83.
	ServerInfo1548 *ServerInfo1548 `idl:"name:ServerInfo1548" json:"server_info1548"`
}

func (*ServerInfo_1548) is_ServerInfo() {}

func (o *ServerInfo_1548) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1548 != nil {
		_ptr_ServerInfo1548 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1548 != nil {
				if err := o.ServerInfo1548.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1548{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1548, _ptr_ServerInfo1548); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1548) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1548 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1548 == nil {
			o.ServerInfo1548 = &ServerInfo1548{}
		}
		if err := o.ServerInfo1548.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1548 := func(ptr interface{}) { o.ServerInfo1548 = *ptr.(**ServerInfo1548) }
	if err := w.ReadPointer(&o.ServerInfo1548, _s_ServerInfo1548, _ptr_ServerInfo1548); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1549 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1549
type ServerInfo_1549 struct {
	// ServerInfo1549:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.84.
	ServerInfo1549 *ServerInfo1549 `idl:"name:ServerInfo1549" json:"server_info1549"`
}

func (*ServerInfo_1549) is_ServerInfo() {}

func (o *ServerInfo_1549) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1549 != nil {
		_ptr_ServerInfo1549 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1549 != nil {
				if err := o.ServerInfo1549.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1549{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1549, _ptr_ServerInfo1549); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1549) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1549 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1549 == nil {
			o.ServerInfo1549 = &ServerInfo1549{}
		}
		if err := o.ServerInfo1549.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1549 := func(ptr interface{}) { o.ServerInfo1549 = *ptr.(**ServerInfo1549) }
	if err := w.ReadPointer(&o.ServerInfo1549, _s_ServerInfo1549, _ptr_ServerInfo1549); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1550 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1550
type ServerInfo_1550 struct {
	// ServerInfo1550:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.85.
	ServerInfo1550 *ServerInfo1550 `idl:"name:ServerInfo1550" json:"server_info1550"`
}

func (*ServerInfo_1550) is_ServerInfo() {}

func (o *ServerInfo_1550) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1550 != nil {
		_ptr_ServerInfo1550 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1550 != nil {
				if err := o.ServerInfo1550.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1550{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1550, _ptr_ServerInfo1550); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1550) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1550 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1550 == nil {
			o.ServerInfo1550 = &ServerInfo1550{}
		}
		if err := o.ServerInfo1550.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1550 := func(ptr interface{}) { o.ServerInfo1550 = *ptr.(**ServerInfo1550) }
	if err := w.ReadPointer(&o.ServerInfo1550, _s_ServerInfo1550, _ptr_ServerInfo1550); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1552 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1552
type ServerInfo_1552 struct {
	// ServerInfo1552:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.86.
	ServerInfo1552 *ServerInfo1552 `idl:"name:ServerInfo1552" json:"server_info1552"`
}

func (*ServerInfo_1552) is_ServerInfo() {}

func (o *ServerInfo_1552) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1552 != nil {
		_ptr_ServerInfo1552 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1552 != nil {
				if err := o.ServerInfo1552.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1552{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1552, _ptr_ServerInfo1552); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1552) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1552 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1552 == nil {
			o.ServerInfo1552 = &ServerInfo1552{}
		}
		if err := o.ServerInfo1552.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1552 := func(ptr interface{}) { o.ServerInfo1552 = *ptr.(**ServerInfo1552) }
	if err := w.ReadPointer(&o.ServerInfo1552, _s_ServerInfo1552, _ptr_ServerInfo1552); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1553 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1553
type ServerInfo_1553 struct {
	// ServerInfo1553:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.87.
	ServerInfo1553 *ServerInfo1553 `idl:"name:ServerInfo1553" json:"server_info1553"`
}

func (*ServerInfo_1553) is_ServerInfo() {}

func (o *ServerInfo_1553) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1553 != nil {
		_ptr_ServerInfo1553 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1553 != nil {
				if err := o.ServerInfo1553.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1553{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1553, _ptr_ServerInfo1553); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1553) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1553 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1553 == nil {
			o.ServerInfo1553 = &ServerInfo1553{}
		}
		if err := o.ServerInfo1553.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1553 := func(ptr interface{}) { o.ServerInfo1553 = *ptr.(**ServerInfo1553) }
	if err := w.ReadPointer(&o.ServerInfo1553, _s_ServerInfo1553, _ptr_ServerInfo1553); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1554 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1554
type ServerInfo_1554 struct {
	// ServerInfo1554:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.88.
	ServerInfo1554 *ServerInfo1554 `idl:"name:ServerInfo1554" json:"server_info1554"`
}

func (*ServerInfo_1554) is_ServerInfo() {}

func (o *ServerInfo_1554) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1554 != nil {
		_ptr_ServerInfo1554 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1554 != nil {
				if err := o.ServerInfo1554.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1554{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1554, _ptr_ServerInfo1554); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1554) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1554 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1554 == nil {
			o.ServerInfo1554 = &ServerInfo1554{}
		}
		if err := o.ServerInfo1554.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1554 := func(ptr interface{}) { o.ServerInfo1554 = *ptr.(**ServerInfo1554) }
	if err := w.ReadPointer(&o.ServerInfo1554, _s_ServerInfo1554, _ptr_ServerInfo1554); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1555 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1555
type ServerInfo_1555 struct {
	// ServerInfo1555:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.89.
	ServerInfo1555 *ServerInfo1555 `idl:"name:ServerInfo1555" json:"server_info1555"`
}

func (*ServerInfo_1555) is_ServerInfo() {}

func (o *ServerInfo_1555) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1555 != nil {
		_ptr_ServerInfo1555 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1555 != nil {
				if err := o.ServerInfo1555.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1555{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1555, _ptr_ServerInfo1555); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1555) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1555 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1555 == nil {
			o.ServerInfo1555 = &ServerInfo1555{}
		}
		if err := o.ServerInfo1555.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1555 := func(ptr interface{}) { o.ServerInfo1555 = *ptr.(**ServerInfo1555) }
	if err := w.ReadPointer(&o.ServerInfo1555, _s_ServerInfo1555, _ptr_ServerInfo1555); err != nil {
		return err
	}
	return nil
}

// ServerInfo_1556 structure represents SERVER_INFO RPC union arm.
//
// It has following labels: 1556
type ServerInfo_1556 struct {
	// ServerInfo1556:  A pointer to a structure that contains information about a server,
	// as specified in section 2.2.4.90.
	ServerInfo1556 *ServerInfo1556 `idl:"name:ServerInfo1556" json:"server_info1556"`
}

func (*ServerInfo_1556) is_ServerInfo() {}

func (o *ServerInfo_1556) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerInfo1556 != nil {
		_ptr_ServerInfo1556 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerInfo1556 != nil {
				if err := o.ServerInfo1556.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerInfo1556{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerInfo1556, _ptr_ServerInfo1556); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerInfo_1556) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerInfo1556 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerInfo1556 == nil {
			o.ServerInfo1556 = &ServerInfo1556{}
		}
		if err := o.ServerInfo1556.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerInfo1556 := func(ptr interface{}) { o.ServerInfo1556 = *ptr.(**ServerInfo1556) }
	if err := w.ReadPointer(&o.ServerInfo1556, _s_ServerInfo1556, _ptr_ServerInfo1556); err != nil {
		return err
	}
	return nil
}

// DiskInfo structure represents DISK_INFO RPC structure.
//
// The DISK_INFO structure contains information (the drive letter) about the disk device
// on the server.
type DiskInfo struct {
	// Disk:  The drive identifier of the disk device. This MUST consist of two Unicode
	// UTF-16 characters followed by the null-terminating character (for example, "A:\0").
	// The first character in this string MUST be a drive letter in the range "A" through
	// "Z", inclusive. The second character MUST be the ":" character.
	Disk string `idl:"name:Disk;string" json:"disk"`
}

func (o *DiskInfo) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *DiskInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(7); err != nil {
		return err
	}
	sizeInfo := []uint64{
		0,
	}
	dimLength1 := ndr.UTF16NLen(o.Disk)
	sizeInfo[0] = dimLength1
	if err := w.WriteSize(0); err != nil {
		return err
	}
	if err := w.WriteSize(dimLength1); err != nil {
		return err
	}
	_Disk_buf := utf16.Encode([]rune(o.Disk))
	if uint64(len(_Disk_buf)) > 3-1 {
		_Disk_buf = _Disk_buf[:3-1]
	}
	if o.Disk != ndr.ZeroString {
		_Disk_buf = append(_Disk_buf, uint16(0))
	}
	for i1 := range _Disk_buf {
		i1 := i1
		if uint64(i1) >= sizeInfo[0] {
			break
		}
		if err := w.WriteData(_Disk_buf[i1]); err != nil {
			return err
		}
	}
	return nil
}
func (o *DiskInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(7); err != nil {
		return err
	}
	sizeInfo := []uint64{
		0,
	}
	for sz1 := range sizeInfo {
		if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
			return err
		}
		if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
			return err
		}
	}
	var _Disk_buf []uint16
	if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
		return fmt.Errorf("buffer overflow for size %d of array _Disk_buf", sizeInfo[0])
	}
	_Disk_buf = make([]uint16, sizeInfo[0])
	for i1 := range _Disk_buf {
		i1 := i1
		if err := w.ReadData(&_Disk_buf[i1]); err != nil {
			return err
		}
	}
	o.Disk = strings.TrimRight(string(utf16.Decode(_Disk_buf)), ndr.ZeroString)
	return nil
}

// DiskEnumContainer structure represents DISK_ENUM_CONTAINER RPC structure.
//
// The DISK_ENUM_CONTAINER structure contains a value that indicates the number of entries
// that the NetrServerDiskEnum method returns and a pointer to the buffer that contains
// the entries.
type DiskEnumContainer struct {
	// EntriesRead:  The number of entries that the method returns.
	EntriesRead uint32 `idl:"name:EntriesRead" json:"entries_read"`
	// Buffer:  A pointer to the DISK_INFO entries that the method returns.
	Buffer []*DiskInfo `idl:"name:Buffer;size_is:(EntriesRead);length_is:(EntriesRead)" json:"buffer"`
}

func (o *DiskEnumContainer) xxx_PreparePayload(ctx context.Context) error {
	if o.Buffer != nil && o.EntriesRead == 0 {
		o.EntriesRead = uint32(len(o.Buffer))
	}
	if o.Buffer != nil && o.EntriesRead == 0 {
		o.EntriesRead = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *DiskEnumContainer) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.EntriesRead); err != nil {
		return err
	}
	if o.Buffer != nil || o.EntriesRead > 0 {
		_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.EntriesRead)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			dimLength1 := uint64(o.EntriesRead)
			if dimLength1 > sizeInfo[0] {
				dimLength1 = sizeInfo[0]
			} else {
				sizeInfo[0] = dimLength1
			}
			if err := w.WriteSize(0); err != nil {
				return err
			}
			if err := w.WriteSize(dimLength1); err != nil {
				return err
			}
			for i1 := range o.Buffer {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Buffer[i1] != nil {
					if err := o.Buffer[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&DiskInfo{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&DiskInfo{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *DiskEnumContainer) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntriesRead); err != nil {
		return err
	}
	_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
		}
		o.Buffer = make([]*DiskInfo, sizeInfo[0])
		for i1 := range o.Buffer {
			i1 := i1
			if o.Buffer[i1] == nil {
				o.Buffer[i1] = &DiskInfo{}
			}
			if err := o.Buffer[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]*DiskInfo) }
	if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
		return err
	}
	return nil
}

// ServerTransportInfo0 structure represents SERVER_TRANSPORT_INFO_0 RPC structure.
//
// The SERVER_TRANSPORT_INFO_0 structure contains information about the specified transport
// protocol, including the name, address, and location on the network. The definitions
// of fields in this structure are specified in section 2.2.4.96. Fields having names
// of the form svti0_xxx MUST be defined as in the corresponding SERVER_TRANSPORT_INFO_3
// fields with names of the form svti3_xxx.
type ServerTransportInfo0 struct {
	NumberOfClients        uint32 `idl:"name:svti0_numberofvcs" json:"number_of_clients"`
	TransportName          string `idl:"name:svti0_transportname;string" json:"transport_name"`
	TransportAddress       []byte `idl:"name:svti0_transportaddress;size_is:(svti0_transportaddresslength)" json:"transport_address"`
	TransportAddressLength uint32 `idl:"name:svti0_transportaddresslength" json:"transport_address_length"`
	NetworkAddress         string `idl:"name:svti0_networkaddress;string" json:"network_address"`
}

func (o *ServerTransportInfo0) xxx_PreparePayload(ctx context.Context) error {
	if o.TransportAddress != nil && o.TransportAddressLength == 0 {
		o.TransportAddressLength = uint32(len(o.TransportAddress))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerTransportInfo0) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.NumberOfClients); err != nil {
		return err
	}
	if o.TransportName != "" {
		_ptr_svti0_transportname := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.TransportName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.TransportName, _ptr_svti0_transportname); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.TransportAddress != nil || o.TransportAddressLength > 0 {
		_ptr_svti0_transportaddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.TransportAddressLength)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.TransportAddress {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.TransportAddress[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.TransportAddress); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.TransportAddress, _ptr_svti0_transportaddress); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.TransportAddressLength); err != nil {
		return err
	}
	if o.NetworkAddress != "" {
		_ptr_svti0_networkaddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.NetworkAddress); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.NetworkAddress, _ptr_svti0_networkaddress); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerTransportInfo0) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.NumberOfClients); err != nil {
		return err
	}
	_ptr_svti0_transportname := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.TransportName); err != nil {
			return err
		}
		return nil
	})
	_s_svti0_transportname := func(ptr interface{}) { o.TransportName = *ptr.(*string) }
	if err := w.ReadPointer(&o.TransportName, _s_svti0_transportname, _ptr_svti0_transportname); err != nil {
		return err
	}
	_ptr_svti0_transportaddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.TransportAddressLength > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.TransportAddressLength)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.TransportAddress", sizeInfo[0])
		}
		o.TransportAddress = make([]byte, sizeInfo[0])
		for i1 := range o.TransportAddress {
			i1 := i1
			if err := w.ReadData(&o.TransportAddress[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_svti0_transportaddress := func(ptr interface{}) { o.TransportAddress = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.TransportAddress, _s_svti0_transportaddress, _ptr_svti0_transportaddress); err != nil {
		return err
	}
	if err := w.ReadData(&o.TransportAddressLength); err != nil {
		return err
	}
	_ptr_svti0_networkaddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.NetworkAddress); err != nil {
			return err
		}
		return nil
	})
	_s_svti0_networkaddress := func(ptr interface{}) { o.NetworkAddress = *ptr.(*string) }
	if err := w.ReadPointer(&o.NetworkAddress, _s_svti0_networkaddress, _ptr_svti0_networkaddress); err != nil {
		return err
	}
	return nil
}

// ServerXportInfo0Container structure represents SERVER_XPORT_INFO_0_CONTAINER RPC structure.
//
// The SERVER_XPORT_INFO_0_CONTAINER structure contains a value that indicates the number
// of entries that the NetrServerTransportEnum method returns and a pointer to the buffer
// that contains the entries.
type ServerXportInfo0Container struct {
	// EntriesRead:  The number of entries that the method returns.
	EntriesRead uint32 `idl:"name:EntriesRead" json:"entries_read"`
	// Buffer:  A pointer to the SERVER_TRANSPORT_INFO_0 entries that the method returns.
	Buffer []*ServerTransportInfo0 `idl:"name:Buffer;size_is:(EntriesRead)" json:"buffer"`
}

func (o *ServerXportInfo0Container) xxx_PreparePayload(ctx context.Context) error {
	if o.Buffer != nil && o.EntriesRead == 0 {
		o.EntriesRead = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerXportInfo0Container) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.EntriesRead); err != nil {
		return err
	}
	if o.Buffer != nil || o.EntriesRead > 0 {
		_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.EntriesRead)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Buffer {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Buffer[i1] != nil {
					if err := o.Buffer[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&ServerTransportInfo0{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&ServerTransportInfo0{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerXportInfo0Container) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntriesRead); err != nil {
		return err
	}
	_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.EntriesRead > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.EntriesRead)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
		}
		o.Buffer = make([]*ServerTransportInfo0, sizeInfo[0])
		for i1 := range o.Buffer {
			i1 := i1
			if o.Buffer[i1] == nil {
				o.Buffer[i1] = &ServerTransportInfo0{}
			}
			if err := o.Buffer[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]*ServerTransportInfo0) }
	if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
		return err
	}
	return nil
}

// ServerTransportInfo1 structure represents SERVER_TRANSPORT_INFO_1 RPC structure.
//
// The SERVER_TRANSPORT_INFO_1 structure contains information about the specified transport
// protocol, including the name, address, and location on the network. The definitions
// of fields in this structure are specified in section 2.2.4.96. Fields having names
// of the form svti1_xxx MUST be defined as in the corresponding SERVER_TRANSPORT_INFO_3
// fields with names of the form svti3_xxx.
type ServerTransportInfo1 struct {
	NumberOfClients        uint32 `idl:"name:svti1_numberofvcs" json:"number_of_clients"`
	TransportName          string `idl:"name:svti1_transportname;string" json:"transport_name"`
	TransportAddress       []byte `idl:"name:svti1_transportaddress;size_is:(svti1_transportaddresslength)" json:"transport_address"`
	TransportAddressLength uint32 `idl:"name:svti1_transportaddresslength" json:"transport_address_length"`
	NetworkAddress         string `idl:"name:svti1_networkaddress;string" json:"network_address"`
	Domain                 string `idl:"name:svti1_domain;string" json:"domain"`
}

func (o *ServerTransportInfo1) xxx_PreparePayload(ctx context.Context) error {
	if o.TransportAddress != nil && o.TransportAddressLength == 0 {
		o.TransportAddressLength = uint32(len(o.TransportAddress))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerTransportInfo1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.NumberOfClients); err != nil {
		return err
	}
	if o.TransportName != "" {
		_ptr_svti1_transportname := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.TransportName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.TransportName, _ptr_svti1_transportname); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.TransportAddress != nil || o.TransportAddressLength > 0 {
		_ptr_svti1_transportaddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.TransportAddressLength)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.TransportAddress {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.TransportAddress[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.TransportAddress); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.TransportAddress, _ptr_svti1_transportaddress); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.TransportAddressLength); err != nil {
		return err
	}
	if o.NetworkAddress != "" {
		_ptr_svti1_networkaddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.NetworkAddress); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.NetworkAddress, _ptr_svti1_networkaddress); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.Domain != "" {
		_ptr_svti1_domain := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Domain); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Domain, _ptr_svti1_domain); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerTransportInfo1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.NumberOfClients); err != nil {
		return err
	}
	_ptr_svti1_transportname := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.TransportName); err != nil {
			return err
		}
		return nil
	})
	_s_svti1_transportname := func(ptr interface{}) { o.TransportName = *ptr.(*string) }
	if err := w.ReadPointer(&o.TransportName, _s_svti1_transportname, _ptr_svti1_transportname); err != nil {
		return err
	}
	_ptr_svti1_transportaddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.TransportAddressLength > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.TransportAddressLength)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.TransportAddress", sizeInfo[0])
		}
		o.TransportAddress = make([]byte, sizeInfo[0])
		for i1 := range o.TransportAddress {
			i1 := i1
			if err := w.ReadData(&o.TransportAddress[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_svti1_transportaddress := func(ptr interface{}) { o.TransportAddress = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.TransportAddress, _s_svti1_transportaddress, _ptr_svti1_transportaddress); err != nil {
		return err
	}
	if err := w.ReadData(&o.TransportAddressLength); err != nil {
		return err
	}
	_ptr_svti1_networkaddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.NetworkAddress); err != nil {
			return err
		}
		return nil
	})
	_s_svti1_networkaddress := func(ptr interface{}) { o.NetworkAddress = *ptr.(*string) }
	if err := w.ReadPointer(&o.NetworkAddress, _s_svti1_networkaddress, _ptr_svti1_networkaddress); err != nil {
		return err
	}
	_ptr_svti1_domain := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Domain); err != nil {
			return err
		}
		return nil
	})
	_s_svti1_domain := func(ptr interface{}) { o.Domain = *ptr.(*string) }
	if err := w.ReadPointer(&o.Domain, _s_svti1_domain, _ptr_svti1_domain); err != nil {
		return err
	}
	return nil
}

// ServerXportInfo1Container structure represents SERVER_XPORT_INFO_1_CONTAINER RPC structure.
//
// The SERVER_XPORT_INFO_1_CONTAINER structure contains a value that indicates the number
// of entries that the NetrServerTransportEnum method returns and a pointer to the buffer
// that contains the entries.
type ServerXportInfo1Container struct {
	// EntriesRead:  The number of entries that the method returns.
	EntriesRead uint32 `idl:"name:EntriesRead" json:"entries_read"`
	// Buffer:  A pointer to the SERVER_TRANSPORT_INFO_1 entries that the method returns.
	Buffer []*ServerTransportInfo1 `idl:"name:Buffer;size_is:(EntriesRead)" json:"buffer"`
}

func (o *ServerXportInfo1Container) xxx_PreparePayload(ctx context.Context) error {
	if o.Buffer != nil && o.EntriesRead == 0 {
		o.EntriesRead = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerXportInfo1Container) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.EntriesRead); err != nil {
		return err
	}
	if o.Buffer != nil || o.EntriesRead > 0 {
		_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.EntriesRead)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Buffer {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Buffer[i1] != nil {
					if err := o.Buffer[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&ServerTransportInfo1{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&ServerTransportInfo1{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerXportInfo1Container) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntriesRead); err != nil {
		return err
	}
	_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.EntriesRead > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.EntriesRead)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
		}
		o.Buffer = make([]*ServerTransportInfo1, sizeInfo[0])
		for i1 := range o.Buffer {
			i1 := i1
			if o.Buffer[i1] == nil {
				o.Buffer[i1] = &ServerTransportInfo1{}
			}
			if err := o.Buffer[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]*ServerTransportInfo1) }
	if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
		return err
	}
	return nil
}

// ServerTransportInfo2 structure represents SERVER_TRANSPORT_INFO_2 RPC structure.
//
// The SERVER_TRANSPORT_INFO_2 structure contains information about the specified transport
// protocol, including the name and address. The definitions of fields in this structure
// are specified in section 2.2.4.96. Fields having names of the form svti2_xxx MUST
// be defined as in the corresponding SERVER_TRANSPORT_INFO_3 fields with names of the
// form svti3_xxx.
type ServerTransportInfo2 struct {
	NumberOfClients        uint32 `idl:"name:svti2_numberofvcs" json:"number_of_clients"`
	TransportName          string `idl:"name:svti2_transportname;string" json:"transport_name"`
	TransportAddress       []byte `idl:"name:svti2_transportaddress;size_is:(svti2_transportaddresslength)" json:"transport_address"`
	TransportAddressLength uint32 `idl:"name:svti2_transportaddresslength" json:"transport_address_length"`
	NetworkAddress         string `idl:"name:svti2_networkaddress;string" json:"network_address"`
	Domain                 string `idl:"name:svti2_domain;string" json:"domain"`
	Flags                  uint32 `idl:"name:svti2_flags" json:"flags"`
}

func (o *ServerTransportInfo2) xxx_PreparePayload(ctx context.Context) error {
	if o.TransportAddress != nil && o.TransportAddressLength == 0 {
		o.TransportAddressLength = uint32(len(o.TransportAddress))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerTransportInfo2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.NumberOfClients); err != nil {
		return err
	}
	if o.TransportName != "" {
		_ptr_svti2_transportname := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.TransportName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.TransportName, _ptr_svti2_transportname); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.TransportAddress != nil || o.TransportAddressLength > 0 {
		_ptr_svti2_transportaddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.TransportAddressLength)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.TransportAddress {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.TransportAddress[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.TransportAddress); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.TransportAddress, _ptr_svti2_transportaddress); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.TransportAddressLength); err != nil {
		return err
	}
	if o.NetworkAddress != "" {
		_ptr_svti2_networkaddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.NetworkAddress); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.NetworkAddress, _ptr_svti2_networkaddress); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.Domain != "" {
		_ptr_svti2_domain := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Domain); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Domain, _ptr_svti2_domain); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	return nil
}
func (o *ServerTransportInfo2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.NumberOfClients); err != nil {
		return err
	}
	_ptr_svti2_transportname := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.TransportName); err != nil {
			return err
		}
		return nil
	})
	_s_svti2_transportname := func(ptr interface{}) { o.TransportName = *ptr.(*string) }
	if err := w.ReadPointer(&o.TransportName, _s_svti2_transportname, _ptr_svti2_transportname); err != nil {
		return err
	}
	_ptr_svti2_transportaddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.TransportAddressLength > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.TransportAddressLength)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.TransportAddress", sizeInfo[0])
		}
		o.TransportAddress = make([]byte, sizeInfo[0])
		for i1 := range o.TransportAddress {
			i1 := i1
			if err := w.ReadData(&o.TransportAddress[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_svti2_transportaddress := func(ptr interface{}) { o.TransportAddress = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.TransportAddress, _s_svti2_transportaddress, _ptr_svti2_transportaddress); err != nil {
		return err
	}
	if err := w.ReadData(&o.TransportAddressLength); err != nil {
		return err
	}
	_ptr_svti2_networkaddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.NetworkAddress); err != nil {
			return err
		}
		return nil
	})
	_s_svti2_networkaddress := func(ptr interface{}) { o.NetworkAddress = *ptr.(*string) }
	if err := w.ReadPointer(&o.NetworkAddress, _s_svti2_networkaddress, _ptr_svti2_networkaddress); err != nil {
		return err
	}
	_ptr_svti2_domain := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Domain); err != nil {
			return err
		}
		return nil
	})
	_s_svti2_domain := func(ptr interface{}) { o.Domain = *ptr.(*string) }
	if err := w.ReadPointer(&o.Domain, _s_svti2_domain, _ptr_svti2_domain); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	return nil
}

// ServerXportInfo2Container structure represents SERVER_XPORT_INFO_2_CONTAINER RPC structure.
//
// The SERVER_XPORT_INFO_2_CONTAINER structure contains a value that indicates the number
// of entries that the NetrServerTransportEnum method returns and a pointer to the buffer
// that contains the entries.
type ServerXportInfo2Container struct {
	// EntriesRead:  The number of entries that the method returns.
	EntriesRead uint32 `idl:"name:EntriesRead" json:"entries_read"`
	// Buffer:  A pointer to the SERVER_TRANSPORT_INFO_2 entries that the method returns.
	Buffer []*ServerTransportInfo2 `idl:"name:Buffer;size_is:(EntriesRead)" json:"buffer"`
}

func (o *ServerXportInfo2Container) xxx_PreparePayload(ctx context.Context) error {
	if o.Buffer != nil && o.EntriesRead == 0 {
		o.EntriesRead = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerXportInfo2Container) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.EntriesRead); err != nil {
		return err
	}
	if o.Buffer != nil || o.EntriesRead > 0 {
		_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.EntriesRead)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Buffer {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Buffer[i1] != nil {
					if err := o.Buffer[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&ServerTransportInfo2{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&ServerTransportInfo2{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerXportInfo2Container) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntriesRead); err != nil {
		return err
	}
	_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.EntriesRead > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.EntriesRead)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
		}
		o.Buffer = make([]*ServerTransportInfo2, sizeInfo[0])
		for i1 := range o.Buffer {
			i1 := i1
			if o.Buffer[i1] == nil {
				o.Buffer[i1] = &ServerTransportInfo2{}
			}
			if err := o.Buffer[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]*ServerTransportInfo2) }
	if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
		return err
	}
	return nil
}

// ServerTransportInfo3 structure represents SERVER_TRANSPORT_INFO_3 RPC structure.
//
// The SERVER_TRANSPORT_INFO_3 structure contains information about the specified transport
// protocol, including the name, address, and password (credentials).
type ServerTransportInfo3 struct {
	// svti3_numberofvcs:  Specifies a DWORD value that indicates the number of clients
	// that are connected to the server and that are using the transport protocol that is
	// specified by the svti3_transportname member.
	NumberOfClients uint32 `idl:"name:svti3_numberofvcs" json:"number_of_clients"`
	// svti3_transportname:   A pointer to a null-terminated Unicode string that contains
	// the implementation-specific name of a device that implements support for the transport.
	// This field is provided by the transport driver and can depend on the physical network
	// adapter over which the transport runs.<27>
	TransportName string `idl:"name:svti3_transportname;string" json:"transport_name"`
	// svti3_transportaddress:  A pointer to a variable that contains the transport address
	// that the server is using on the transport device that is specified by the svti3_transportname
	// member. <28>
	TransportAddress []byte `idl:"name:svti3_transportaddress;size_is:(svti3_transportaddresslength)" json:"transport_address"`
	// svti3_transportaddresslength:  Specifies a DWORD value that contains the length,
	// in bytes, of the svti3_transportaddress member.<29>
	TransportAddressLength uint32 `idl:"name:svti3_transportaddresslength" json:"transport_address_length"`
	// svti3_networkaddress:  A pointer to a null-terminated character string that contains
	// the address that the network adapter is using. The string is transport-specific.
	// The server MUST ignore this field on receipt.<30>
	NetworkAddress string `idl:"name:svti3_networkaddress;string" json:"network_address"`
	// svti3_domain:  A pointer to a null-terminated character string that contains the
	// name of the domain to which the server announces its presence.
	Domain string `idl:"name:svti3_domain;string" json:"domain"`
	// svti3_flags:  This member MUST be a combination of zero or more of the following
	// values.
	//
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	|                                   |                                                                                  |
	//	|               VALUE               |                                     MEANING                                      |
	//	|                                   |                                                                                  |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SVTI2_REMAP_PIPE_NAMES 0x00000002 | If this value is set for an endpoint, client requests that arrive over the       |
	//	|                                   | transport to open a named pipe MUST be rerouted (remapped) to the local pipe     |
	//	|                                   | name $$\ServerName\PipeName.                                                     |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| SVTI2_SCOPED_NAME 0x00000004      | If this value is set for an endpoint, all shares attached to svti3_transportname |
	//	|                                   | are scoped shares.                                                               |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	Flags uint32 `idl:"name:svti3_flags" json:"flags"`
	// svti3_passwordlength:  Specifies a DWORD value that indicates the number of valid
	// bytes in the svti3_password member.
	PasswordLength uint32 `idl:"name:svti3_passwordlength" json:"password_length"`
	// svti3_password:  Specifies the credentials to use for the new transport address.
	// If the svti3_passwordlength member is zero, the credentials for the server MUST be
	// used.
	Password []byte `idl:"name:svti3_password" json:"password"`
}

func (o *ServerTransportInfo3) xxx_PreparePayload(ctx context.Context) error {
	if o.TransportAddress != nil && o.TransportAddressLength == 0 {
		o.TransportAddressLength = uint32(len(o.TransportAddress))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerTransportInfo3) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.NumberOfClients); err != nil {
		return err
	}
	if o.TransportName != "" {
		_ptr_svti3_transportname := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.TransportName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.TransportName, _ptr_svti3_transportname); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.TransportAddress != nil || o.TransportAddressLength > 0 {
		_ptr_svti3_transportaddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.TransportAddressLength)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.TransportAddress {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.TransportAddress[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.TransportAddress); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.TransportAddress, _ptr_svti3_transportaddress); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.TransportAddressLength); err != nil {
		return err
	}
	if o.NetworkAddress != "" {
		_ptr_svti3_networkaddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.NetworkAddress); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.NetworkAddress, _ptr_svti3_networkaddress); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.Domain != "" {
		_ptr_svti3_domain := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Domain); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Domain, _ptr_svti3_domain); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	if err := w.WriteData(o.PasswordLength); err != nil {
		return err
	}
	for i1 := range o.Password {
		i1 := i1
		if uint64(i1) >= 256 {
			break
		}
		if err := w.WriteData(o.Password[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Password); uint64(i1) < 256; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerTransportInfo3) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.NumberOfClients); err != nil {
		return err
	}
	_ptr_svti3_transportname := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.TransportName); err != nil {
			return err
		}
		return nil
	})
	_s_svti3_transportname := func(ptr interface{}) { o.TransportName = *ptr.(*string) }
	if err := w.ReadPointer(&o.TransportName, _s_svti3_transportname, _ptr_svti3_transportname); err != nil {
		return err
	}
	_ptr_svti3_transportaddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.TransportAddressLength > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.TransportAddressLength)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.TransportAddress", sizeInfo[0])
		}
		o.TransportAddress = make([]byte, sizeInfo[0])
		for i1 := range o.TransportAddress {
			i1 := i1
			if err := w.ReadData(&o.TransportAddress[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_svti3_transportaddress := func(ptr interface{}) { o.TransportAddress = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.TransportAddress, _s_svti3_transportaddress, _ptr_svti3_transportaddress); err != nil {
		return err
	}
	if err := w.ReadData(&o.TransportAddressLength); err != nil {
		return err
	}
	_ptr_svti3_networkaddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.NetworkAddress); err != nil {
			return err
		}
		return nil
	})
	_s_svti3_networkaddress := func(ptr interface{}) { o.NetworkAddress = *ptr.(*string) }
	if err := w.ReadPointer(&o.NetworkAddress, _s_svti3_networkaddress, _ptr_svti3_networkaddress); err != nil {
		return err
	}
	_ptr_svti3_domain := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Domain); err != nil {
			return err
		}
		return nil
	})
	_s_svti3_domain := func(ptr interface{}) { o.Domain = *ptr.(*string) }
	if err := w.ReadPointer(&o.Domain, _s_svti3_domain, _ptr_svti3_domain); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	if err := w.ReadData(&o.PasswordLength); err != nil {
		return err
	}
	o.Password = make([]byte, 256)
	for i1 := range o.Password {
		i1 := i1
		if err := w.ReadData(&o.Password[i1]); err != nil {
			return err
		}
	}
	return nil
}

// ServerXportInfo3Container structure represents SERVER_XPORT_INFO_3_CONTAINER RPC structure.
//
// The SERVER_XPORT_INFO_3_CONTAINER structure contains a value that indicates the number
// of entries that the NetrServerTransportEnum method returns and a pointer to the buffer
// that contains the entries.
type ServerXportInfo3Container struct {
	// EntriesRead:  The number of entries that the method returns.
	EntriesRead uint32 `idl:"name:EntriesRead" json:"entries_read"`
	// Buffer:  A pointer to the SERVER_TRANSPORT_INFO_3 entries that the method returns.
	Buffer []*ServerTransportInfo3 `idl:"name:Buffer;size_is:(EntriesRead)" json:"buffer"`
}

func (o *ServerXportInfo3Container) xxx_PreparePayload(ctx context.Context) error {
	if o.Buffer != nil && o.EntriesRead == 0 {
		o.EntriesRead = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerXportInfo3Container) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.EntriesRead); err != nil {
		return err
	}
	if o.Buffer != nil || o.EntriesRead > 0 {
		_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.EntriesRead)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Buffer {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Buffer[i1] != nil {
					if err := o.Buffer[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&ServerTransportInfo3{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&ServerTransportInfo3{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerXportInfo3Container) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntriesRead); err != nil {
		return err
	}
	_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.EntriesRead > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.EntriesRead)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
		}
		o.Buffer = make([]*ServerTransportInfo3, sizeInfo[0])
		for i1 := range o.Buffer {
			i1 := i1
			if o.Buffer[i1] == nil {
				o.Buffer[i1] = &ServerTransportInfo3{}
			}
			if err := o.Buffer[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]*ServerTransportInfo3) }
	if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
		return err
	}
	return nil
}

// TransportInfo structure represents TRANSPORT_INFO RPC union.
//
// The TRANSPORT_INFO union contains information about a transport over which a file
// server is operational.
type TransportInfo struct {
	// Types that are assignable to Value
	//
	// *TransportInfo_Transport0
	// *TransportInfo_Transport1
	// *TransportInfo_Transport2
	// *TransportInfo_Transport3
	Value is_TransportInfo `json:"value"`
}

func (o *TransportInfo) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *TransportInfo_Transport0:
		if value != nil {
			return value.Transport0
		}
	case *TransportInfo_Transport1:
		if value != nil {
			return value.Transport1
		}
	case *TransportInfo_Transport2:
		if value != nil {
			return value.Transport2
		}
	case *TransportInfo_Transport3:
		if value != nil {
			return value.Transport3
		}
	}
	return nil
}

type is_TransportInfo interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_TransportInfo()
}

func (o *TransportInfo) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *TransportInfo_Transport0:
		return uint32(0)
	case *TransportInfo_Transport1:
		return uint32(1)
	case *TransportInfo_Transport2:
		return uint32(2)
	case *TransportInfo_Transport3:
		return uint32(3)
	}
	return uint32(0)
}

func (o *TransportInfo) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(0):
		_o, _ := o.Value.(*TransportInfo_Transport0)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&TransportInfo_Transport0{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1):
		_o, _ := o.Value.(*TransportInfo_Transport1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&TransportInfo_Transport1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(2):
		_o, _ := o.Value.(*TransportInfo_Transport2)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&TransportInfo_Transport2{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(3):
		_o, _ := o.Value.(*TransportInfo_Transport3)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&TransportInfo_Transport3{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *TransportInfo) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(0):
		o.Value = &TransportInfo_Transport0{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1):
		o.Value = &TransportInfo_Transport1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(2):
		o.Value = &TransportInfo_Transport2{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(3):
		o.Value = &TransportInfo_Transport3{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// TransportInfo_Transport0 structure represents TRANSPORT_INFO RPC union arm.
//
// It has following labels: 0
type TransportInfo_Transport0 struct {
	// Transport0:  A pointer to a structure containing information about a file server
	// transport, as specified in section 2.2.4.93.
	Transport0 *ServerTransportInfo0 `idl:"name:Transport0" json:"transport0"`
}

func (*TransportInfo_Transport0) is_TransportInfo() {}

func (o *TransportInfo_Transport0) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Transport0 != nil {
		if err := o.Transport0.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ServerTransportInfo0{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *TransportInfo_Transport0) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.Transport0 == nil {
		o.Transport0 = &ServerTransportInfo0{}
	}
	if err := o.Transport0.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// TransportInfo_Transport1 structure represents TRANSPORT_INFO RPC union arm.
//
// It has following labels: 1
type TransportInfo_Transport1 struct {
	// Transport1:  A pointer to a structure containing information about a file server
	// transport, as specified in section 2.2.4.94.
	Transport1 *ServerTransportInfo1 `idl:"name:Transport1" json:"transport1"`
}

func (*TransportInfo_Transport1) is_TransportInfo() {}

func (o *TransportInfo_Transport1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Transport1 != nil {
		if err := o.Transport1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ServerTransportInfo1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *TransportInfo_Transport1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.Transport1 == nil {
		o.Transport1 = &ServerTransportInfo1{}
	}
	if err := o.Transport1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// TransportInfo_Transport2 structure represents TRANSPORT_INFO RPC union arm.
//
// It has following labels: 2
type TransportInfo_Transport2 struct {
	// Transport2:  A pointer to a structure containing information about a file server
	// transport, as specified in section 2.2.4.95.
	Transport2 *ServerTransportInfo2 `idl:"name:Transport2" json:"transport2"`
}

func (*TransportInfo_Transport2) is_TransportInfo() {}

func (o *TransportInfo_Transport2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Transport2 != nil {
		if err := o.Transport2.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ServerTransportInfo2{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *TransportInfo_Transport2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.Transport2 == nil {
		o.Transport2 = &ServerTransportInfo2{}
	}
	if err := o.Transport2.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// TransportInfo_Transport3 structure represents TRANSPORT_INFO RPC union arm.
//
// It has following labels: 3
type TransportInfo_Transport3 struct {
	// Transport3:  A pointer to a structure containing information about a file server
	// transport, as specified in section 2.2.4.96.
	Transport3 *ServerTransportInfo3 `idl:"name:Transport3" json:"transport3"`
}

func (*TransportInfo_Transport3) is_TransportInfo() {}

func (o *TransportInfo_Transport3) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Transport3 != nil {
		if err := o.Transport3.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ServerTransportInfo3{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *TransportInfo_Transport3) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.Transport3 == nil {
		o.Transport3 = &ServerTransportInfo3{}
	}
	if err := o.Transport3.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// ServerXportEnumUnion structure represents SERVER_XPORT_ENUM_UNION RPC union.
//
// The SERVER_XPORT_ENUM_UNION union contains information about file server transports.
type ServerXportEnumUnion struct {
	// Types that are assignable to Value
	//
	// *ServerXportEnumUnion_Level0
	// *ServerXportEnumUnion_Level1
	// *ServerXportEnumUnion_Level2
	// *ServerXportEnumUnion_Level3
	Value is_ServerXportEnumUnion `json:"value"`
}

func (o *ServerXportEnumUnion) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *ServerXportEnumUnion_Level0:
		if value != nil {
			return value.Level0
		}
	case *ServerXportEnumUnion_Level1:
		if value != nil {
			return value.Level1
		}
	case *ServerXportEnumUnion_Level2:
		if value != nil {
			return value.Level2
		}
	case *ServerXportEnumUnion_Level3:
		if value != nil {
			return value.Level3
		}
	}
	return nil
}

type is_ServerXportEnumUnion interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_ServerXportEnumUnion()
}

func (o *ServerXportEnumUnion) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *ServerXportEnumUnion_Level0:
		return uint32(0)
	case *ServerXportEnumUnion_Level1:
		return uint32(1)
	case *ServerXportEnumUnion_Level2:
		return uint32(2)
	case *ServerXportEnumUnion_Level3:
		return uint32(3)
	}
	return uint32(0)
}

func (o *ServerXportEnumUnion) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(0):
		_o, _ := o.Value.(*ServerXportEnumUnion_Level0)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerXportEnumUnion_Level0{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1):
		_o, _ := o.Value.(*ServerXportEnumUnion_Level1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerXportEnumUnion_Level1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(2):
		_o, _ := o.Value.(*ServerXportEnumUnion_Level2)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerXportEnumUnion_Level2{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(3):
		_o, _ := o.Value.(*ServerXportEnumUnion_Level3)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerXportEnumUnion_Level3{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *ServerXportEnumUnion) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(0):
		o.Value = &ServerXportEnumUnion_Level0{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1):
		o.Value = &ServerXportEnumUnion_Level1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(2):
		o.Value = &ServerXportEnumUnion_Level2{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(3):
		o.Value = &ServerXportEnumUnion_Level3{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// ServerXportEnumUnion_Level0 structure represents SERVER_XPORT_ENUM_UNION RPC union arm.
//
// It has following labels: 0
type ServerXportEnumUnion_Level0 struct {
	// Level0:  A pointer to a structure containing information about file server transports,
	// as specified in section 2.2.4.97.
	Level0 *ServerXportInfo0Container `idl:"name:Level0" json:"level0"`
}

func (*ServerXportEnumUnion_Level0) is_ServerXportEnumUnion() {}

func (o *ServerXportEnumUnion_Level0) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Level0 != nil {
		_ptr_Level0 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Level0 != nil {
				if err := o.Level0.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerXportInfo0Container{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Level0, _ptr_Level0); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerXportEnumUnion_Level0) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_Level0 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Level0 == nil {
			o.Level0 = &ServerXportInfo0Container{}
		}
		if err := o.Level0.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_Level0 := func(ptr interface{}) { o.Level0 = *ptr.(**ServerXportInfo0Container) }
	if err := w.ReadPointer(&o.Level0, _s_Level0, _ptr_Level0); err != nil {
		return err
	}
	return nil
}

// ServerXportEnumUnion_Level1 structure represents SERVER_XPORT_ENUM_UNION RPC union arm.
//
// It has following labels: 1
type ServerXportEnumUnion_Level1 struct {
	// Level1:  A pointer to a structure containing information about file server transports,
	// as specified in section 2.2.4.98.
	Level1 *ServerXportInfo1Container `idl:"name:Level1" json:"level1"`
}

func (*ServerXportEnumUnion_Level1) is_ServerXportEnumUnion() {}

func (o *ServerXportEnumUnion_Level1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Level1 != nil {
		_ptr_Level1 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Level1 != nil {
				if err := o.Level1.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerXportInfo1Container{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Level1, _ptr_Level1); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerXportEnumUnion_Level1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_Level1 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Level1 == nil {
			o.Level1 = &ServerXportInfo1Container{}
		}
		if err := o.Level1.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_Level1 := func(ptr interface{}) { o.Level1 = *ptr.(**ServerXportInfo1Container) }
	if err := w.ReadPointer(&o.Level1, _s_Level1, _ptr_Level1); err != nil {
		return err
	}
	return nil
}

// ServerXportEnumUnion_Level2 structure represents SERVER_XPORT_ENUM_UNION RPC union arm.
//
// It has following labels: 2
type ServerXportEnumUnion_Level2 struct {
	// Level2:  A pointer to a structure containing information about file server transports,
	// as specified in section 2.2.4.99.
	Level2 *ServerXportInfo2Container `idl:"name:Level2" json:"level2"`
}

func (*ServerXportEnumUnion_Level2) is_ServerXportEnumUnion() {}

func (o *ServerXportEnumUnion_Level2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Level2 != nil {
		_ptr_Level2 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Level2 != nil {
				if err := o.Level2.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerXportInfo2Container{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Level2, _ptr_Level2); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerXportEnumUnion_Level2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_Level2 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Level2 == nil {
			o.Level2 = &ServerXportInfo2Container{}
		}
		if err := o.Level2.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_Level2 := func(ptr interface{}) { o.Level2 = *ptr.(**ServerXportInfo2Container) }
	if err := w.ReadPointer(&o.Level2, _s_Level2, _ptr_Level2); err != nil {
		return err
	}
	return nil
}

// ServerXportEnumUnion_Level3 structure represents SERVER_XPORT_ENUM_UNION RPC union arm.
//
// It has following labels: 3
type ServerXportEnumUnion_Level3 struct {
	// Level3:  A pointer to a structure containing information about file server transports,
	// as specified in section 2.2.4.100.
	Level3 *ServerXportInfo3Container `idl:"name:Level3" json:"level3"`
}

func (*ServerXportEnumUnion_Level3) is_ServerXportEnumUnion() {}

func (o *ServerXportEnumUnion_Level3) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Level3 != nil {
		_ptr_Level3 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Level3 != nil {
				if err := o.Level3.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerXportInfo3Container{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Level3, _ptr_Level3); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerXportEnumUnion_Level3) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_Level3 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Level3 == nil {
			o.Level3 = &ServerXportInfo3Container{}
		}
		if err := o.Level3.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_Level3 := func(ptr interface{}) { o.Level3 = *ptr.(**ServerXportInfo3Container) }
	if err := w.ReadPointer(&o.Level3, _s_Level3, _ptr_Level3); err != nil {
		return err
	}
	return nil
}

// ServerXportEnum structure represents SERVER_XPORT_ENUM_STRUCT RPC structure.
//
// The SERVER_XPORT_ENUM_STRUCT structure specifies the information level that the client
// requests in the NetrServerTransportEnum method and encapsulates the SERVER_XPORT_ENUM_UNION
// union that receives the entries that are enumerated by the server.
type ServerXportEnum struct {
	// Level:  Specifies the information level of the data. This parameter MUST have one
	// of the following values.
	//
	//	+-------+-------------------------------+
	//	|       |                               |
	//	| VALUE |            MEANING            |
	//	|       |                               |
	//	+-------+-------------------------------+
	//	+-------+-------------------------------+
	//	|     0 | SERVER_XPORT_INFO_0_CONTAINER |
	//	+-------+-------------------------------+
	//	|     1 | SERVER_XPORT_INFO_1_CONTAINER |
	//	+-------+-------------------------------+
	//	|     2 | SERVER_XPORT_INFO_2_CONTAINER |
	//	+-------+-------------------------------+
	//	|     3 | SERVER_XPORT_INFO_3_CONTAINER |
	//	+-------+-------------------------------+
	Level uint32 `idl:"name:Level" json:"level"`
	// XportInfo:  Contains information about file server transports in the format that
	// is determined by the Level parameter, as shown in the preceding table. This member
	// receives the enumerated information.
	XportInfo *ServerXportEnumUnion `idl:"name:XportInfo;switch_is:Level" json:"xport_info"`
}

func (o *ServerXportEnum) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerXportEnum) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.Level); err != nil {
		return err
	}
	_swXportInfo := uint32(o.Level)
	if o.XportInfo != nil {
		if err := o.XportInfo.MarshalUnionNDR(ctx, w, _swXportInfo); err != nil {
			return err
		}
	} else {
		if err := (&ServerXportEnumUnion{}).MarshalUnionNDR(ctx, w, _swXportInfo); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerXportEnum) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.Level); err != nil {
		return err
	}
	if o.XportInfo == nil {
		o.XportInfo = &ServerXportEnumUnion{}
	}
	_swXportInfo := uint32(o.Level)
	if err := o.XportInfo.UnmarshalUnionNDR(ctx, w, _swXportInfo); err != nil {
		return err
	}
	return nil
}

// ShareDeleteHandle structure represents SHARE_DEL_HANDLE RPC structure.
type ShareDeleteHandle dcetypes.ContextHandle

func (o *ShareDeleteHandle) ContextHandle() *dcetypes.ContextHandle {
	return (*dcetypes.ContextHandle)(o)
}

func (o *ShareDeleteHandle) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareDeleteHandle) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Attributes); err != nil {
		return err
	}
	if o.UUID != nil {
		if err := o.UUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *ShareDeleteHandle) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Attributes); err != nil {
		return err
	}
	if o.UUID == nil {
		o.UUID = &dtyp.GUID{}
	}
	if err := o.UUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// ADTSecurityDescriptor structure represents ADT_SECURITY_DESCRIPTOR RPC structure.
//
// The ADT_SECURITY_DESCRIPTOR structure contains a security descriptor in self-relative
// format and a value that includes the length of the buffer that contains the descriptor.
// For more information, see [MS-DTYP] section 2.4.6.
type ADTSecurityDescriptor struct {
	// Length:  The length of the Buffer member.
	Length uint32 `idl:"name:Length" json:"length"`
	// Buffer:  A buffer for the security descriptor in self-relative form. For more information,
	// see [MS-DTYP] section 2.4.6.
	Buffer []byte `idl:"name:Buffer;size_is:(Length)" json:"buffer"`
}

func (o *ADTSecurityDescriptor) xxx_PreparePayload(ctx context.Context) error {
	if o.Buffer != nil && o.Length == 0 {
		o.Length = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ADTSecurityDescriptor) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.Length); err != nil {
		return err
	}
	if o.Buffer != nil || o.Length > 0 {
		_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.Length)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Buffer {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.Buffer[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ADTSecurityDescriptor) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.Length); err != nil {
		return err
	}
	_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.Length > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.Length)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
		}
		o.Buffer = make([]byte, sizeInfo[0])
		for i1 := range o.Buffer {
			i1 := i1
			if err := w.ReadData(&o.Buffer[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
		return err
	}
	return nil
}

// StatServer0 structure represents STAT_SERVER_0 RPC structure.
//
// The STAT_SERVER_0 structure contains statistical information about the server.
type StatServer0 struct {
	// sts0_start:  Specifies a DWORD value that indicates the time when statistics collection
	// started (or when the statistics were last cleared). The value MUST be stored as the
	// number of seconds that have elapsed since 00:00:00, January 1, 1970, Greenwich Mean
	// Time (GMT). To calculate the length of time that statistics have been collected,
	// subtract the value of this member from the present time.
	Start uint32 `idl:"name:sts0_start" json:"start"`
	// sts0_fopens:  Specifies a DWORD value that indicates the number of Opens that have
	// been created on a server. This MUST include the number of times named pipes are opened.
	FileOpens uint32 `idl:"name:sts0_fopens" json:"file_opens"`
	// sts0_devopens:  Specifies a DWORD value that indicates the number of times a server
	// device has been opened. This field MUST be set to 0.
	DeviceOpens uint32 `idl:"name:sts0_devopens" json:"device_opens"`
	// sts0_jobsqueued:  Specifies a DWORD value that indicates the number of server print
	// jobs that are spooled.
	JobsQueued uint32 `idl:"name:sts0_jobsqueued" json:"jobs_queued"`
	// sts0_sopens:  Specifies a DWORD value that indicates the number of sessions that
	// have been established to a server.
	SessOpens uint32 `idl:"name:sts0_sopens" json:"sess_opens"`
	// sts0_stimedout:  Specifies a DWORD value that indicates the number of times a session
	// is disconnected.
	SessTimeouts uint32 `idl:"name:sts0_stimedout" json:"sess_timeouts"`
	// sts0_serrorout:  Specifies a DWORD value that indicates the number of times a session
	// failed with an error. This field MUST be set to 0.
	SessErrors uint32 `idl:"name:sts0_serrorout" json:"sess_errors"`
	// sts0_pwerrors:  Specifies a DWORD value that indicates the number of password violations
	// that the server has detected.
	PasswordErrors uint32 `idl:"name:sts0_pwerrors" json:"password_errors"`
	// sts0_permerrors:  Specifies a DWORD value that indicates the number of access permission
	// errors that have occurred on the server.
	PermErrors uint32 `idl:"name:sts0_permerrors" json:"perm_errors"`
	// sts0_syserrors:  Specifies a DWORD value that indicates the number of system errors
	// that have occurred on the server. This field MUST be set to 0.
	SystemErrors uint32 `idl:"name:sts0_syserrors" json:"system_errors"`
	// sts0_bytessent_low:  Specifies the low-order DWORD of the number of server bytes
	// sent on the network.
	BytesSentLow uint32 `idl:"name:sts0_bytessent_low" json:"bytes_sent_low"`
	// sts0_bytessent_high:  Specifies the high-order DWORD of the number of server bytes
	// sent on the network.
	BytesSentHigh uint32 `idl:"name:sts0_bytessent_high" json:"bytes_sent_high"`
	// sts0_bytesrcvd_low:  Specifies the low-order DWORD of the number of server bytes
	// received from the network.
	BytesReceivedLow uint32 `idl:"name:sts0_bytesrcvd_low" json:"bytes_received_low"`
	// sts0_bytesrcvd_high:  Specifies the high-order DWORD of the number of server bytes
	// received from the network.
	BytesReceivedHigh uint32 `idl:"name:sts0_bytesrcvd_high" json:"bytes_received_high"`
	// sts0_avresponse:  Specifies a DWORD value that indicates the average server response
	// time, in milliseconds. This field MUST be set to 0.
	AvgResponse uint32 `idl:"name:sts0_avresponse" json:"avg_response"`
	// sts0_reqbufneed:  Specifies a DWORD value that indicates the number of times the
	// server required a request buffer but failed to allocate one. This field MUST be set
	// to 0.
	RequestBufferNeed uint32 `idl:"name:sts0_reqbufneed" json:"request_buffer_need"`
	// sts0_bigbufneed:  Specifies a DWORD value that indicates the number of times the
	// server required a large buffer but failed to allocate one. This field MUST be set
	// to 0.
	BigBufferNeed uint32 `idl:"name:sts0_bigbufneed" json:"big_buffer_need"`
}

func (o *StatServer0) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *StatServer0) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Start); err != nil {
		return err
	}
	if err := w.WriteData(o.FileOpens); err != nil {
		return err
	}
	if err := w.WriteData(o.DeviceOpens); err != nil {
		return err
	}
	if err := w.WriteData(o.JobsQueued); err != nil {
		return err
	}
	if err := w.WriteData(o.SessOpens); err != nil {
		return err
	}
	if err := w.WriteData(o.SessTimeouts); err != nil {
		return err
	}
	if err := w.WriteData(o.SessErrors); err != nil {
		return err
	}
	if err := w.WriteData(o.PasswordErrors); err != nil {
		return err
	}
	if err := w.WriteData(o.PermErrors); err != nil {
		return err
	}
	if err := w.WriteData(o.SystemErrors); err != nil {
		return err
	}
	if err := w.WriteData(o.BytesSentLow); err != nil {
		return err
	}
	if err := w.WriteData(o.BytesSentHigh); err != nil {
		return err
	}
	if err := w.WriteData(o.BytesReceivedLow); err != nil {
		return err
	}
	if err := w.WriteData(o.BytesReceivedHigh); err != nil {
		return err
	}
	if err := w.WriteData(o.AvgResponse); err != nil {
		return err
	}
	if err := w.WriteData(o.RequestBufferNeed); err != nil {
		return err
	}
	if err := w.WriteData(o.BigBufferNeed); err != nil {
		return err
	}
	return nil
}
func (o *StatServer0) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Start); err != nil {
		return err
	}
	if err := w.ReadData(&o.FileOpens); err != nil {
		return err
	}
	if err := w.ReadData(&o.DeviceOpens); err != nil {
		return err
	}
	if err := w.ReadData(&o.JobsQueued); err != nil {
		return err
	}
	if err := w.ReadData(&o.SessOpens); err != nil {
		return err
	}
	if err := w.ReadData(&o.SessTimeouts); err != nil {
		return err
	}
	if err := w.ReadData(&o.SessErrors); err != nil {
		return err
	}
	if err := w.ReadData(&o.PasswordErrors); err != nil {
		return err
	}
	if err := w.ReadData(&o.PermErrors); err != nil {
		return err
	}
	if err := w.ReadData(&o.SystemErrors); err != nil {
		return err
	}
	if err := w.ReadData(&o.BytesSentLow); err != nil {
		return err
	}
	if err := w.ReadData(&o.BytesSentHigh); err != nil {
		return err
	}
	if err := w.ReadData(&o.BytesReceivedLow); err != nil {
		return err
	}
	if err := w.ReadData(&o.BytesReceivedHigh); err != nil {
		return err
	}
	if err := w.ReadData(&o.AvgResponse); err != nil {
		return err
	}
	if err := w.ReadData(&o.RequestBufferNeed); err != nil {
		return err
	}
	if err := w.ReadData(&o.BigBufferNeed); err != nil {
		return err
	}
	return nil
}

// TimeOfDayInfo structure represents TIME_OF_DAY_INFO RPC structure.
//
// The TIME_OF_DAY_INFO structure contains information about the time of day from a
// remote server.
type TimeOfDayInfo struct {
	// tod_elapsedt:  Specifies a DWORD value that contains the number of seconds since
	// 00:00:00, January 1, 1970, GMT.
	ElapsedTime uint32 `idl:"name:tod_elapsedt" json:"elapsed_time"`
	// tod_msecs:  Specifies a DWORD value that contains the number of milliseconds from
	// an arbitrary starting point (system reset).
	Msecs uint32 `idl:"name:tod_msecs" json:"msecs"`
	// tod_hours:  Specifies a DWORD value that contains the current hour. This value MUST
	// be in the range 0 through 23, inclusive.
	Hours uint32 `idl:"name:tod_hours" json:"hours"`
	// tod_mins:  Specifies a DWORD value that contains the current minute. This value MUST
	// be in the range 0 through 59, inclusive.
	Mins uint32 `idl:"name:tod_mins" json:"mins"`
	// tod_secs:  Specifies a DWORD value that contains the current second. This value MUST
	// be in the range 0 through 59, inclusive.
	Secs uint32 `idl:"name:tod_secs" json:"secs"`
	// tod_hunds:  Specifies a DWORD value that contains the current hundredth second (0.01
	// second). This value MUST be in the range 0 through 99, inclusive.
	Hunds uint32 `idl:"name:tod_hunds" json:"hunds"`
	// tod_timezone:  Specifies the time zone of the server. This value MUST be calculated,
	// in minutes, from Greenwich Mean Time (GMT). For time zones that are west of Greenwich,
	// the value MUST be positive; for time zones that are east of Greenwich, the value
	// MUST be negative. A value of –1 MUST indicate that the time zone is undefined.
	Timezone int32 `idl:"name:tod_timezone" json:"timezone"`
	// tod_tinterval:  Specifies a DWORD value that contains the time interval for each
	// tick of the clock. Each integral integer MUST represent one ten-thousandth second
	// (0.0001 second).
	Tinterval uint32 `idl:"name:tod_tinterval" json:"tinterval"`
	// tod_day:   Specifies a DWORD value that contains the day of the month. This value
	// MUST be in the range 1 through 31, inclusive.
	Day uint32 `idl:"name:tod_day" json:"day"`
	// tod_month:  Specifies a DWORD value that contains the month of the year. This value
	// MUST be in the range 1 through 12, inclusive.
	Month uint32 `idl:"name:tod_month" json:"month"`
	// tod_year:  Specifies a DWORD value that contains the year.
	Year uint32 `idl:"name:tod_year" json:"year"`
	// tod_weekday:  Specifies a DWORD value that contains the day of the week. This value
	// MUST be in the range 0 through 6, inclusive, where 0 is Sunday, 1 is Monday, and
	// so on.
	Weekday uint32 `idl:"name:tod_weekday" json:"weekday"`
}

func (o *TimeOfDayInfo) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *TimeOfDayInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.ElapsedTime); err != nil {
		return err
	}
	if err := w.WriteData(o.Msecs); err != nil {
		return err
	}
	if err := w.WriteData(o.Hours); err != nil {
		return err
	}
	if err := w.WriteData(o.Mins); err != nil {
		return err
	}
	if err := w.WriteData(o.Secs); err != nil {
		return err
	}
	if err := w.WriteData(o.Hunds); err != nil {
		return err
	}
	if err := w.WriteData(o.Timezone); err != nil {
		return err
	}
	if err := w.WriteData(o.Tinterval); err != nil {
		return err
	}
	if err := w.WriteData(o.Day); err != nil {
		return err
	}
	if err := w.WriteData(o.Month); err != nil {
		return err
	}
	if err := w.WriteData(o.Year); err != nil {
		return err
	}
	if err := w.WriteData(o.Weekday); err != nil {
		return err
	}
	return nil
}
func (o *TimeOfDayInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.ElapsedTime); err != nil {
		return err
	}
	if err := w.ReadData(&o.Msecs); err != nil {
		return err
	}
	if err := w.ReadData(&o.Hours); err != nil {
		return err
	}
	if err := w.ReadData(&o.Mins); err != nil {
		return err
	}
	if err := w.ReadData(&o.Secs); err != nil {
		return err
	}
	if err := w.ReadData(&o.Hunds); err != nil {
		return err
	}
	if err := w.ReadData(&o.Timezone); err != nil {
		return err
	}
	if err := w.ReadData(&o.Tinterval); err != nil {
		return err
	}
	if err := w.ReadData(&o.Day); err != nil {
		return err
	}
	if err := w.ReadData(&o.Month); err != nil {
		return err
	}
	if err := w.ReadData(&o.Year); err != nil {
		return err
	}
	if err := w.ReadData(&o.Weekday); err != nil {
		return err
	}
	return nil
}

// NetDFSEntryID structure represents NET_DFS_ENTRY_ID RPC structure.
//
// The NET_DFS_ENTRY_ID structure specifies a DFS local partition.
type NetDFSEntryID struct {
	// Uid:  Specifies the unique identifier for the partition.
	UID *dtyp.GUID `idl:"name:Uid" json:"uid"`
	// Prefix:  A pointer to a null-terminated Unicode UTF-16 string that contains the path
	// prefix for the partition.
	Prefix string `idl:"name:Prefix;string" json:"prefix"`
}

func (o *NetDFSEntryID) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *NetDFSEntryID) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.UID != nil {
		if err := o.UID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.Prefix != "" {
		_ptr_Prefix := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Prefix); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Prefix, _ptr_Prefix); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *NetDFSEntryID) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if o.UID == nil {
		o.UID = &dtyp.GUID{}
	}
	if err := o.UID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_Prefix := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Prefix); err != nil {
			return err
		}
		return nil
	})
	_s_Prefix := func(ptr interface{}) { o.Prefix = *ptr.(*string) }
	if err := w.ReadPointer(&o.Prefix, _s_Prefix, _ptr_Prefix); err != nil {
		return err
	}
	return nil
}

// NetDFSEntryIDContainer structure represents NET_DFS_ENTRY_ID_CONTAINER RPC structure.
//
// The NET_DFS_ENTRY_ID_CONTAINER structure contains a pointer to a buffer that contains
// NET_DFS_ENTRY_ID entries and a value that indicates the count of entries in the buffer.
type NetDFSEntryIDContainer struct {
	// Count:  The count of buffer array entries returned by the method.
	Count uint32 `idl:"name:Count" json:"count"`
	// Buffer:  An array of NET_DFS_ENTRY_ID entries returned by the method.
	Buffer []*NetDFSEntryID `idl:"name:Buffer;size_is:(Count)" json:"buffer"`
}

func (o *NetDFSEntryIDContainer) xxx_PreparePayload(ctx context.Context) error {
	if o.Buffer != nil && o.Count == 0 {
		o.Count = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *NetDFSEntryIDContainer) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.Count); err != nil {
		return err
	}
	if o.Buffer != nil || o.Count > 0 {
		_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.Count)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Buffer {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Buffer[i1] != nil {
					if err := o.Buffer[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&NetDFSEntryID{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&NetDFSEntryID{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *NetDFSEntryIDContainer) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.Count); err != nil {
		return err
	}
	_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.Count > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.Count)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
		}
		o.Buffer = make([]*NetDFSEntryID, sizeInfo[0])
		for i1 := range o.Buffer {
			i1 := i1
			if o.Buffer[i1] == nil {
				o.Buffer[i1] = &NetDFSEntryID{}
			}
			if err := o.Buffer[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]*NetDFSEntryID) }
	if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
		return err
	}
	return nil
}

// SiteNameInfo structure represents DFS_SITENAME_INFO RPC structure.
//
// The DFS_SITENAME_INFO structure specifies a site name.
type SiteNameInfo struct {
	// SiteFlags:  This member MUST be a combination of zero or more of the following values.
	//
	//	+-----------------------------+----------------------------------------------------------------------------------+
	//	|                             |                                                                                  |
	//	|            VALUE            |                                     MEANING                                      |
	//	|                             |                                                                                  |
	//	+-----------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------+----------------------------------------------------------------------------------+
	//	| DFS_SITE_PRIMARY 0x00000001 | The site name was returned by the DsrGetSiteName method, as specified in         |
	//	|                             | [MS-NRPC] section 3.5.4.3.6.                                                     |
	//	+-----------------------------+----------------------------------------------------------------------------------+
	SiteFlags uint32 `idl:"name:SiteFlags" json:"site_flags"`
	// SiteName:  A pointer to a null-terminated Unicode UTF-16 string that specifies a
	// unique site name.
	SiteName string `idl:"name:SiteName;string;pointer:unique" json:"site_name"`
}

func (o *SiteNameInfo) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *SiteNameInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.SiteFlags); err != nil {
		return err
	}
	if o.SiteName != "" {
		_ptr_SiteName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.SiteName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.SiteName, _ptr_SiteName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *SiteNameInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.SiteFlags); err != nil {
		return err
	}
	_ptr_SiteName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.SiteName); err != nil {
			return err
		}
		return nil
	})
	_s_SiteName := func(ptr interface{}) { o.SiteName = *ptr.(*string) }
	if err := w.ReadPointer(&o.SiteName, _s_SiteName, _ptr_SiteName); err != nil {
		return err
	}
	return nil
}

// SiteListInfo structure represents DFS_SITELIST_INFO RPC structure.
//
// The DFS_SITELIST_INFO structure contains a value that indicates the count of entries
// and an array of DFS_SITELIST_INFO entries that the NetrDfsManagerReportSiteInfo method
// returns.
type SiteListInfo struct {
	// cSites:  A count of site array entries returned by the method.
	SitesCount uint32 `idl:"name:cSites" json:"sites_count"`
	// Site:  An array of DFS_SITENAME_INFO entries that the method returns.
	Site []*SiteNameInfo `idl:"name:Site;size_is:(cSites)" json:"site"`
}

func (o *SiteListInfo) xxx_PreparePayload(ctx context.Context) error {
	if o.Site != nil && o.SitesCount == 0 {
		o.SitesCount = uint32(len(o.Site))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *SiteListInfo) NDRSizeInfo() []uint64 {
	dimSize1 := uint64(o.SitesCount)
	return []uint64{
		dimSize1,
	}
}
func (o *SiteListInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for sz1 := range sizeInfo {
			if err := w.WriteSize(sizeInfo[sz1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.SitesCount); err != nil {
		return err
	}
	for i1 := range o.Site {
		i1 := i1
		if uint64(i1) >= sizeInfo[0] {
			break
		}
		if o.Site[i1] != nil {
			if err := o.Site[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&SiteNameInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.Site); uint64(i1) < sizeInfo[0]; i1++ {
		if err := (&SiteNameInfo{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *SiteListInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for i1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[i1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.SitesCount); err != nil {
		return err
	}
	// XXX: for opaque unmarshaling
	if o.SitesCount > 0 && sizeInfo[0] == 0 {
		sizeInfo[0] = uint64(o.SitesCount)
	}
	if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
		return fmt.Errorf("buffer overflow for size %d of array o.Site", sizeInfo[0])
	}
	o.Site = make([]*SiteNameInfo, sizeInfo[0])
	for i1 := range o.Site {
		i1 := i1
		if o.Site[i1] == nil {
			o.Site[i1] = &SiteNameInfo{}
		}
		if err := o.Site[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// ServerAliasInfo0 structure represents SERVER_ALIAS_INFO_0 RPC structure.
//
// The SERVER_ALIAS_INFO_0 structure contains the information about alias, including
// alias name and server target name.
type ServerAliasInfo0 struct {
	// srvai0_alias:  An empty string or a pointer to a null-terminated Unicode UTF-16 string
	// that specifies the name of a specified alias. It MUST be an empty string if srvai0_default
	// is nonzero and MUST be a non-empty string if srvai0_default is 0.
	Alias string `idl:"name:srvai0_alias;string" json:"alias"`
	// srvai0_target:  A pointer to a null-terminated Unicode UTF-16 string. It specifies
	// the server name that alias is attached to. The server MUST ignore this member when
	// processing the NetrServerAliasDel method.
	Target string `idl:"name:srvai0_target;string" json:"target"`
	// srvai0_default:  A BOOLEAN value. If it is set to TRUE, srvai0_target MUST replace
	// the default server name that is used to locate a scoped share in NetrShareAdd/NetrShareDel/NetrShareSetInfo.
	// If a scoped share cannot be found through a tuple of <share name, server name> due
	// to a server name mismatch, the default server name is used in <share name, default
	// server name> to continue scoped share searching. The server MUST ignore srvai0_default
	// when processing the NetrServerAliasDel method.
	Default bool `idl:"name:srvai0_default" json:"default"`
	// srvai0_reserved:  This field is not used. The server MUST ignore the value of this
	// parameter on receipt.
	_ uint32 `idl:"name:srvai0_reserved"`
}

func (o *ServerAliasInfo0) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerAliasInfo0) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.Alias != "" {
		_ptr_srvai0_alias := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Alias); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Alias, _ptr_srvai0_alias); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.Target != "" {
		_ptr_srvai0_target := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Target); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Target, _ptr_srvai0_target); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Default); err != nil {
		return err
	}
	// reserved srvai0_reserved
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	return nil
}
func (o *ServerAliasInfo0) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_srvai0_alias := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Alias); err != nil {
			return err
		}
		return nil
	})
	_s_srvai0_alias := func(ptr interface{}) { o.Alias = *ptr.(*string) }
	if err := w.ReadPointer(&o.Alias, _s_srvai0_alias, _ptr_srvai0_alias); err != nil {
		return err
	}
	_ptr_srvai0_target := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Target); err != nil {
			return err
		}
		return nil
	})
	_s_srvai0_target := func(ptr interface{}) { o.Target = *ptr.(*string) }
	if err := w.ReadPointer(&o.Target, _s_srvai0_target, _ptr_srvai0_target); err != nil {
		return err
	}
	if err := w.ReadData(&o.Default); err != nil {
		return err
	}
	// reserved srvai0_reserved
	var _srvai0_reserved uint32
	if err := w.ReadData(&_srvai0_reserved); err != nil {
		return err
	}
	return nil
}

// ServerAliasInfo0Container structure represents SERVER_ALIAS_INFO_0_CONTAINER RPC structure.
//
// The SERVER_ALIAS_INFO_0_CONTAINER structure contains a value that indicates the number
// of entries that the NetrServerAliasEnum method returns and a pointer to the buffer
// that contains the entries.
type ServerAliasInfo0Container struct {
	// EntriesRead:  The number of entries that the method returns.
	EntriesRead uint32 `idl:"name:EntriesRead" json:"entries_read"`
	// Buffer:  A pointer to the SERVER_ALIAS_INFO_0 entries that the method returns.
	Buffer []*ServerAliasInfo0 `idl:"name:Buffer;size_is:(EntriesRead)" json:"buffer"`
}

func (o *ServerAliasInfo0Container) xxx_PreparePayload(ctx context.Context) error {
	if o.Buffer != nil && o.EntriesRead == 0 {
		o.EntriesRead = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerAliasInfo0Container) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.EntriesRead); err != nil {
		return err
	}
	if o.Buffer != nil || o.EntriesRead > 0 {
		_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.EntriesRead)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Buffer {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Buffer[i1] != nil {
					if err := o.Buffer[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&ServerAliasInfo0{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&ServerAliasInfo0{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerAliasInfo0Container) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntriesRead); err != nil {
		return err
	}
	_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.EntriesRead > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.EntriesRead)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
		}
		o.Buffer = make([]*ServerAliasInfo0, sizeInfo[0])
		for i1 := range o.Buffer {
			i1 := i1
			if o.Buffer[i1] == nil {
				o.Buffer[i1] = &ServerAliasInfo0{}
			}
			if err := o.Buffer[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]*ServerAliasInfo0) }
	if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
		return err
	}
	return nil
}

// ServerAliasEnum structure represents SERVER_ALIAS_ENUM_STRUCT RPC structure.
//
// The SERVER_ALIAS_ENUM_STRUCT structure specifies the information level that the client
// requests in the NetrServerAliasEnum method and encapsulates the SERVER_ALIAS_ENUM_UNION
// union that receives the entries that are enumerated by the server.
type ServerAliasEnum struct {
	// Level:  Specifies the information level of the data. This parameter MUST have one
	// of the following values.
	//
	//	+-------+-------------------------------+
	//	|       |                               |
	//	| VALUE |            MEANING            |
	//	|       |                               |
	//	+-------+-------------------------------+
	//	+-------+-------------------------------+
	//	|     0 | SERVER_ALIAS_INFO_0_CONTAINER |
	//	+-------+-------------------------------+
	Level uint32 `idl:"name:Level" json:"level"`
	// ServerAliasInfo:  Contains information about server aliases in the format that is
	// determined by the Level parameter, as shown in the preceding table. This member receives
	// the enumerated information.
	ServerAliasInfo *ServerAliasEnum_ServerAliasInfo `idl:"name:ServerAliasInfo;switch_is:Level" json:"server_alias_info"`
}

func (o *ServerAliasEnum) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerAliasEnum) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.Level); err != nil {
		return err
	}
	_swServerAliasInfo := uint32(o.Level)
	if o.ServerAliasInfo != nil {
		if err := o.ServerAliasInfo.MarshalUnionNDR(ctx, w, _swServerAliasInfo); err != nil {
			return err
		}
	} else {
		if err := (&ServerAliasEnum_ServerAliasInfo{}).MarshalUnionNDR(ctx, w, _swServerAliasInfo); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerAliasEnum) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.Level); err != nil {
		return err
	}
	if o.ServerAliasInfo == nil {
		o.ServerAliasInfo = &ServerAliasEnum_ServerAliasInfo{}
	}
	_swServerAliasInfo := uint32(o.Level)
	if err := o.ServerAliasInfo.UnmarshalUnionNDR(ctx, w, _swServerAliasInfo); err != nil {
		return err
	}
	return nil
}

// ServerAliasEnum_ServerAliasInfo structure represents SERVER_ALIAS_ENUM_STRUCT union anonymous member.
//
// The SERVER_ALIAS_ENUM_STRUCT structure specifies the information level that the client
// requests in the NetrServerAliasEnum method and encapsulates the SERVER_ALIAS_ENUM_UNION
// union that receives the entries that are enumerated by the server.
type ServerAliasEnum_ServerAliasInfo struct {
	// Types that are assignable to Value
	//
	// *ServerAliasInfo_Level0
	Value is_ServerAliasEnum_ServerAliasInfo `json:"value"`
}

func (o *ServerAliasEnum_ServerAliasInfo) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *ServerAliasInfo_Level0:
		if value != nil {
			return value.Level0
		}
	}
	return nil
}

type is_ServerAliasEnum_ServerAliasInfo interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_ServerAliasEnum_ServerAliasInfo()
}

func (o *ServerAliasEnum_ServerAliasInfo) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *ServerAliasInfo_Level0:
		return uint32(0)
	}
	return uint32(0)
}

func (o *ServerAliasEnum_ServerAliasInfo) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(0):
		_o, _ := o.Value.(*ServerAliasInfo_Level0)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerAliasInfo_Level0{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *ServerAliasEnum_ServerAliasInfo) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(0):
		o.Value = &ServerAliasInfo_Level0{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// ServerAliasInfo_Level0 structure represents ServerAliasEnum_ServerAliasInfo RPC union arm.
//
// It has following labels: 0
type ServerAliasInfo_Level0 struct {
	Level0 *ServerAliasInfo0Container `idl:"name:Level0" json:"level0"`
}

func (*ServerAliasInfo_Level0) is_ServerAliasEnum_ServerAliasInfo() {}

func (o *ServerAliasInfo_Level0) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Level0 != nil {
		_ptr_Level0 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Level0 != nil {
				if err := o.Level0.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerAliasInfo0Container{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Level0, _ptr_Level0); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerAliasInfo_Level0) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_Level0 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Level0 == nil {
			o.Level0 = &ServerAliasInfo0Container{}
		}
		if err := o.Level0.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_Level0 := func(ptr interface{}) { o.Level0 = *ptr.(**ServerAliasInfo0Container) }
	if err := w.ReadPointer(&o.Level0, _s_Level0, _ptr_Level0); err != nil {
		return err
	}
	return nil
}

// ServerAliasInfo structure represents SERVER_ALIAS_INFO RPC union.
//
// The SERVER_ALIAS_INFO union contains information about an alias attached to a server
// name.
type ServerAliasInfo struct {
	// Types that are assignable to Value
	//
	// *ServerAliasInfo_0
	Value is_ServerAliasInfo `json:"value"`
}

func (o *ServerAliasInfo) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *ServerAliasInfo_0:
		if value != nil {
			return value.ServerAliasInfo0
		}
	}
	return nil
}

type is_ServerAliasInfo interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_ServerAliasInfo()
}

func (o *ServerAliasInfo) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *ServerAliasInfo_0:
		return uint32(0)
	}
	return uint32(0)
}

func (o *ServerAliasInfo) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(0):
		_o, _ := o.Value.(*ServerAliasInfo_0)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerAliasInfo_0{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *ServerAliasInfo) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(0):
		o.Value = &ServerAliasInfo_0{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// ServerAliasInfo_0 structure represents SERVER_ALIAS_INFO RPC union arm.
//
// It has following labels: 0
type ServerAliasInfo_0 struct {
	// ServerAliasInfo0:  A pointer to a structure containing information about an alias
	// attached to a server, as specified in section 2.2.4.102.
	ServerAliasInfo0 *ServerAliasInfo0 `idl:"name:ServerAliasInfo0" json:"server_alias_info0"`
}

func (*ServerAliasInfo_0) is_ServerAliasInfo() {}

func (o *ServerAliasInfo_0) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerAliasInfo0 != nil {
		_ptr_ServerAliasInfo0 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerAliasInfo0 != nil {
				if err := o.ServerAliasInfo0.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServerAliasInfo0{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerAliasInfo0, _ptr_ServerAliasInfo0); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerAliasInfo_0) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ServerAliasInfo0 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerAliasInfo0 == nil {
			o.ServerAliasInfo0 = &ServerAliasInfo0{}
		}
		if err := o.ServerAliasInfo0.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ServerAliasInfo0 := func(ptr interface{}) { o.ServerAliasInfo0 = *ptr.(**ServerAliasInfo0) }
	if err := w.ReadPointer(&o.ServerAliasInfo0, _s_ServerAliasInfo0, _ptr_ServerAliasInfo0); err != nil {
		return err
	}
	return nil
}

type xxx_DefaultSrvsvcClient struct {
	cc dcerpc.Conn
}

func (o *xxx_DefaultSrvsvcClient) ConnectionEnum(ctx context.Context, in *ConnectionEnumRequest, opts ...dcerpc.CallOption) (*ConnectionEnumResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ConnectionEnumResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) FileEnum(ctx context.Context, in *FileEnumRequest, opts ...dcerpc.CallOption) (*FileEnumResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &FileEnumResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) FileGetInfo(ctx context.Context, in *FileGetInfoRequest, opts ...dcerpc.CallOption) (*FileGetInfoResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &FileGetInfoResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) FileClose(ctx context.Context, in *FileCloseRequest, opts ...dcerpc.CallOption) (*FileCloseResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &FileCloseResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) SessionEnum(ctx context.Context, in *SessionEnumRequest, opts ...dcerpc.CallOption) (*SessionEnumResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SessionEnumResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) SessionDelete(ctx context.Context, in *SessionDeleteRequest, opts ...dcerpc.CallOption) (*SessionDeleteResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SessionDeleteResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) ShareAdd(ctx context.Context, in *ShareAddRequest, opts ...dcerpc.CallOption) (*ShareAddResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ShareAddResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) ShareEnum(ctx context.Context, in *ShareEnumRequest, opts ...dcerpc.CallOption) (*ShareEnumResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ShareEnumResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) ShareGetInfo(ctx context.Context, in *ShareGetInfoRequest, opts ...dcerpc.CallOption) (*ShareGetInfoResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ShareGetInfoResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) ShareSetInfo(ctx context.Context, in *ShareSetInfoRequest, opts ...dcerpc.CallOption) (*ShareSetInfoResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ShareSetInfoResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) ShareDelete(ctx context.Context, in *ShareDeleteRequest, opts ...dcerpc.CallOption) (*ShareDeleteResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ShareDeleteResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) ShareDeleteSticky(ctx context.Context, in *ShareDeleteStickyRequest, opts ...dcerpc.CallOption) (*ShareDeleteStickyResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ShareDeleteStickyResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) ShareCheck(ctx context.Context, in *ShareCheckRequest, opts ...dcerpc.CallOption) (*ShareCheckResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ShareCheckResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) GetInfo(ctx context.Context, in *GetInfoRequest, opts ...dcerpc.CallOption) (*GetInfoResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetInfoResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) SetInfo(ctx context.Context, in *SetInfoRequest, opts ...dcerpc.CallOption) (*SetInfoResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetInfoResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) DiskEnum(ctx context.Context, in *DiskEnumRequest, opts ...dcerpc.CallOption) (*DiskEnumResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &DiskEnumResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) StatisticsGet(ctx context.Context, in *StatisticsGetRequest, opts ...dcerpc.CallOption) (*StatisticsGetResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &StatisticsGetResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) TransportAdd(ctx context.Context, in *TransportAddRequest, opts ...dcerpc.CallOption) (*TransportAddResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &TransportAddResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) TransportEnum(ctx context.Context, in *TransportEnumRequest, opts ...dcerpc.CallOption) (*TransportEnumResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &TransportEnumResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) TransportDelete(ctx context.Context, in *TransportDeleteRequest, opts ...dcerpc.CallOption) (*TransportDeleteResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &TransportDeleteResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) RemoteToD(ctx context.Context, in *RemoteToDRequest, opts ...dcerpc.CallOption) (*RemoteToDResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &RemoteToDResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) PathType(ctx context.Context, in *PathTypeRequest, opts ...dcerpc.CallOption) (*PathTypeResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &PathTypeResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) PathCanonicalize(ctx context.Context, in *PathCanonicalizeRequest, opts ...dcerpc.CallOption) (*PathCanonicalizeResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &PathCanonicalizeResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) PathCompare(ctx context.Context, in *PathCompareRequest, opts ...dcerpc.CallOption) (*PathCompareResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &PathCompareResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != int32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) NameValidate(ctx context.Context, in *NameValidateRequest, opts ...dcerpc.CallOption) (*NameValidateResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &NameValidateResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) NameCanonicalize(ctx context.Context, in *NameCanonicalizeRequest, opts ...dcerpc.CallOption) (*NameCanonicalizeResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &NameCanonicalizeResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) NameCompare(ctx context.Context, in *NameCompareRequest, opts ...dcerpc.CallOption) (*NameCompareResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &NameCompareResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != int32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) ShareEnumSticky(ctx context.Context, in *ShareEnumStickyRequest, opts ...dcerpc.CallOption) (*ShareEnumStickyResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ShareEnumStickyResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) ShareDeleteStart(ctx context.Context, in *ShareDeleteStartRequest, opts ...dcerpc.CallOption) (*ShareDeleteStartResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ShareDeleteStartResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) ShareDeleteCommit(ctx context.Context, in *ShareDeleteCommitRequest, opts ...dcerpc.CallOption) (*ShareDeleteCommitResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ShareDeleteCommitResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) GetFileSecurity(ctx context.Context, in *GetFileSecurityRequest, opts ...dcerpc.CallOption) (*GetFileSecurityResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetFileSecurityResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) SetFileSecurity(ctx context.Context, in *SetFileSecurityRequest, opts ...dcerpc.CallOption) (*SetFileSecurityResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetFileSecurityResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) TransportAddEx(ctx context.Context, in *TransportAddExRequest, opts ...dcerpc.CallOption) (*TransportAddExResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &TransportAddExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) GetVersion(ctx context.Context, in *GetVersionRequest, opts ...dcerpc.CallOption) (*GetVersionResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetVersionResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) CreateLocalPartition(ctx context.Context, in *CreateLocalPartitionRequest, opts ...dcerpc.CallOption) (*CreateLocalPartitionResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CreateLocalPartitionResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) DeleteLocalPartition(ctx context.Context, in *DeleteLocalPartitionRequest, opts ...dcerpc.CallOption) (*DeleteLocalPartitionResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &DeleteLocalPartitionResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) SetLocalVolumeState(ctx context.Context, in *SetLocalVolumeStateRequest, opts ...dcerpc.CallOption) (*SetLocalVolumeStateResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetLocalVolumeStateResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) CreateExitPoint(ctx context.Context, in *CreateExitPointRequest, opts ...dcerpc.CallOption) (*CreateExitPointResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CreateExitPointResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) DeleteExitPoint(ctx context.Context, in *DeleteExitPointRequest, opts ...dcerpc.CallOption) (*DeleteExitPointResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &DeleteExitPointResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) ModifyPrefix(ctx context.Context, in *ModifyPrefixRequest, opts ...dcerpc.CallOption) (*ModifyPrefixResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ModifyPrefixResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) FixLocalVolume(ctx context.Context, in *FixLocalVolumeRequest, opts ...dcerpc.CallOption) (*FixLocalVolumeResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &FixLocalVolumeResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) ManagerReportSiteInfo(ctx context.Context, in *ManagerReportSiteInfoRequest, opts ...dcerpc.CallOption) (*ManagerReportSiteInfoResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ManagerReportSiteInfoResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) TransportDeleteEx(ctx context.Context, in *TransportDeleteExRequest, opts ...dcerpc.CallOption) (*TransportDeleteExResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &TransportDeleteExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) AliasAdd(ctx context.Context, in *AliasAddRequest, opts ...dcerpc.CallOption) (*AliasAddResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AliasAddResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) AliasEnum(ctx context.Context, in *AliasEnumRequest, opts ...dcerpc.CallOption) (*AliasEnumResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AliasEnumResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) AliasDelete(ctx context.Context, in *AliasDeleteRequest, opts ...dcerpc.CallOption) (*AliasDeleteResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AliasDeleteResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) ShareDeleteEx(ctx context.Context, in *ShareDeleteExRequest, opts ...dcerpc.CallOption) (*ShareDeleteExResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ShareDeleteExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultSrvsvcClient) AlterContext(ctx context.Context, opts ...dcerpc.Option) error {
	return o.cc.AlterContext(ctx, opts...)
}

func (o *xxx_DefaultSrvsvcClient) Conn() dcerpc.Conn {
	return o.cc
}

func NewSrvsvcClient(ctx context.Context, cc dcerpc.Conn, opts ...dcerpc.Option) (SrvsvcClient, error) {
	cc, err := cc.Bind(ctx, append(opts, dcerpc.WithAbstractSyntax(SrvsvcSyntaxV3_0))...)
	if err != nil {
		return nil, err
	}
	return &xxx_DefaultSrvsvcClient{cc: cc}, nil
}

// xxx_ConnectionEnumOperation structure represents the NetrConnectionEnum operation
type xxx_ConnectionEnumOperation struct {
	ServerName             string       `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	Qualifier              string       `idl:"name:Qualifier;string;pointer:unique" json:"qualifier"`
	Info                   *ConnectEnum `idl:"name:InfoStruct" json:"info"`
	PreferredMaximumLength uint32       `idl:"name:PreferedMaximumLength" json:"preferred_maximum_length"`
	TotalEntries           uint32       `idl:"name:TotalEntries" json:"total_entries"`
	Resume                 uint32       `idl:"name:ResumeHandle;pointer:unique" json:"resume"`
	Return                 uint32       `idl:"name:Return" json:"return"`
}

func (o *xxx_ConnectionEnumOperation) OpNum() int { return 8 }

func (o *xxx_ConnectionEnumOperation) OpName() string { return "/srvsvc/v3/NetrConnectionEnum" }

func (o *xxx_ConnectionEnumOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ConnectionEnumOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Qualifier {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.Qualifier != "" {
			_ptr_Qualifier := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.Qualifier); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.Qualifier, _ptr_Qualifier); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// InfoStruct {in, out} (1:{alias=LPCONNECT_ENUM_STRUCT}*(1))(2:{alias=CONNECT_ENUM_STRUCT}(struct))
	{
		if o.Info != nil {
			if err := o.Info.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ConnectEnum{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// PreferedMaximumLength {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PreferredMaximumLength); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=unique}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ResumeHandle := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.Resume); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Resume, _ptr_ResumeHandle); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ConnectionEnumOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Qualifier {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_Qualifier := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.Qualifier); err != nil {
				return err
			}
			return nil
		})
		_s_Qualifier := func(ptr interface{}) { o.Qualifier = *ptr.(*string) }
		if err := w.ReadPointer(&o.Qualifier, _s_Qualifier, _ptr_Qualifier); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// InfoStruct {in, out} (1:{alias=LPCONNECT_ENUM_STRUCT,pointer=ref}*(1))(2:{alias=CONNECT_ENUM_STRUCT}(struct))
	{
		if o.Info == nil {
			o.Info = &ConnectEnum{}
		}
		if err := o.Info.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// PreferedMaximumLength {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PreferredMaximumLength); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=unique}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ResumeHandle := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.Resume); err != nil {
				return err
			}
			return nil
		})
		_s_ResumeHandle := func(ptr interface{}) { o.Resume = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.Resume, _s_ResumeHandle, _ptr_ResumeHandle); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ConnectionEnumOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ConnectionEnumOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// InfoStruct {in, out} (1:{alias=LPCONNECT_ENUM_STRUCT}*(1))(2:{alias=CONNECT_ENUM_STRUCT}(struct))
	{
		if o.Info != nil {
			if err := o.Info.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ConnectEnum{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// TotalEntries {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.TotalEntries); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=unique}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ResumeHandle := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.Resume); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Resume, _ptr_ResumeHandle); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ConnectionEnumOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// InfoStruct {in, out} (1:{alias=LPCONNECT_ENUM_STRUCT,pointer=ref}*(1))(2:{alias=CONNECT_ENUM_STRUCT}(struct))
	{
		if o.Info == nil {
			o.Info = &ConnectEnum{}
		}
		if err := o.Info.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// TotalEntries {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.TotalEntries); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=unique}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ResumeHandle := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.Resume); err != nil {
				return err
			}
			return nil
		})
		_s_ResumeHandle := func(ptr interface{}) { o.Resume = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.Resume, _s_ResumeHandle, _ptr_ResumeHandle); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ConnectionEnumRequest structure represents the NetrConnectionEnum operation request
type ConnectionEnumRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle (see [C706] sections
	// 4.3.5 and 5.1.5.2). The server MUST ignore this parameter.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// Qualifier: A pointer to a null-terminated UTF-16 string that specifies a share name
	// or computer name for the connections of interest to the client.
	Qualifier string `idl:"name:Qualifier;string;pointer:unique" json:"qualifier"`
	// InfoStruct: A pointer to a structure, in the format of a CONNECT_ENUM_STRUCT (section
	// 2.2.4.5). The CONNECT_ENUM_STRUCT structure has a Level member that specifies the
	// type of structure to return. The Level member MUST be one of the values specified
	// in section 2.2.4.5.
	Info *ConnectEnum `idl:"name:InfoStruct" json:"info"`
	// PreferedMaximumLength: Specifies the preferred maximum length, in bytes, of the returned
	// data. If the value that is specified is MAX_PREFERRED_LENGTH (section 2.2.2.2), the
	// method MUST attempt to return all entries.
	PreferredMaximumLength uint32 `idl:"name:PreferedMaximumLength" json:"preferred_maximum_length"`
	// ResumeHandle: A pointer to a value that contains a handle that is used to continue
	// an existing TreeConnect search. The handle MUST be zero on the first call and left
	// unchanged for subsequent calls. If ResumeHandle is NULL, a resume handle MUST NOT
	// be stored. If this parameter is not NULL and the method returns ERROR_MORE_DATA,
	// this parameter receives an implementation-specific nonzero value that can be passed
	// in subsequent calls to this method to continue with the enumeration.
	Resume uint32 `idl:"name:ResumeHandle;pointer:unique" json:"resume"`
}

func (o *ConnectionEnumRequest) xxx_ToOp(ctx context.Context, op *xxx_ConnectionEnumOperation) *xxx_ConnectionEnumOperation {
	if op == nil {
		op = &xxx_ConnectionEnumOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.Qualifier = o.Qualifier
	op.Info = o.Info
	op.PreferredMaximumLength = o.PreferredMaximumLength
	op.Resume = o.Resume
	return op
}

func (o *ConnectionEnumRequest) xxx_FromOp(ctx context.Context, op *xxx_ConnectionEnumOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.Qualifier = op.Qualifier
	o.Info = op.Info
	o.PreferredMaximumLength = op.PreferredMaximumLength
	o.Resume = op.Resume
}
func (o *ConnectionEnumRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *ConnectionEnumRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ConnectionEnumOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ConnectionEnumResponse structure represents the NetrConnectionEnum operation response
type ConnectionEnumResponse struct {
	// InfoStruct: A pointer to a structure, in the format of a CONNECT_ENUM_STRUCT (section
	// 2.2.4.5). The CONNECT_ENUM_STRUCT structure has a Level member that specifies the
	// type of structure to return. The Level member MUST be one of the values specified
	// in section 2.2.4.5.
	Info *ConnectEnum `idl:"name:InfoStruct" json:"info"`
	// TotalEntries: The total number of entries that could have been enumerated if the
	// buffer had been big enough to hold all the entries.
	TotalEntries uint32 `idl:"name:TotalEntries" json:"total_entries"`
	// ResumeHandle: A pointer to a value that contains a handle that is used to continue
	// an existing TreeConnect search. The handle MUST be zero on the first call and left
	// unchanged for subsequent calls. If ResumeHandle is NULL, a resume handle MUST NOT
	// be stored. If this parameter is not NULL and the method returns ERROR_MORE_DATA,
	// this parameter receives an implementation-specific nonzero value that can be passed
	// in subsequent calls to this method to continue with the enumeration.
	Resume uint32 `idl:"name:ResumeHandle;pointer:unique" json:"resume"`
	// Return: The NetrConnectionEnum return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ConnectionEnumResponse) xxx_ToOp(ctx context.Context, op *xxx_ConnectionEnumOperation) *xxx_ConnectionEnumOperation {
	if op == nil {
		op = &xxx_ConnectionEnumOperation{}
	}
	if o == nil {
		return op
	}
	op.Info = o.Info
	op.TotalEntries = o.TotalEntries
	op.Resume = o.Resume
	op.Return = o.Return
	return op
}

func (o *ConnectionEnumResponse) xxx_FromOp(ctx context.Context, op *xxx_ConnectionEnumOperation) {
	if o == nil {
		return
	}
	o.Info = op.Info
	o.TotalEntries = op.TotalEntries
	o.Resume = op.Resume
	o.Return = op.Return
}
func (o *ConnectionEnumResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *ConnectionEnumResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ConnectionEnumOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_FileEnumOperation structure represents the NetrFileEnum operation
type xxx_FileEnumOperation struct {
	ServerName             string    `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	BasePath               string    `idl:"name:BasePath;string;pointer:unique" json:"base_path"`
	UserName               string    `idl:"name:UserName;string;pointer:unique" json:"user_name"`
	Info                   *FileEnum `idl:"name:InfoStruct" json:"info"`
	PreferredMaximumLength uint32    `idl:"name:PreferedMaximumLength" json:"preferred_maximum_length"`
	TotalEntries           uint32    `idl:"name:TotalEntries" json:"total_entries"`
	Resume                 uint32    `idl:"name:ResumeHandle;pointer:unique" json:"resume"`
	Return                 uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_FileEnumOperation) OpNum() int { return 9 }

func (o *xxx_FileEnumOperation) OpName() string { return "/srvsvc/v3/NetrFileEnum" }

func (o *xxx_FileEnumOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FileEnumOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// BasePath {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.BasePath != "" {
			_ptr_BasePath := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.BasePath); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.BasePath, _ptr_BasePath); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// UserName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.UserName != "" {
			_ptr_UserName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.UserName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.UserName, _ptr_UserName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// InfoStruct {in, out} (1:{alias=PFILE_ENUM_STRUCT}*(1))(2:{alias=FILE_ENUM_STRUCT}(struct))
	{
		if o.Info != nil {
			if err := o.Info.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&FileEnum{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// PreferedMaximumLength {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PreferredMaximumLength); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=unique}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ResumeHandle := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.Resume); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Resume, _ptr_ResumeHandle); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FileEnumOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// BasePath {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_BasePath := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.BasePath); err != nil {
				return err
			}
			return nil
		})
		_s_BasePath := func(ptr interface{}) { o.BasePath = *ptr.(*string) }
		if err := w.ReadPointer(&o.BasePath, _s_BasePath, _ptr_BasePath); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// UserName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_UserName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.UserName); err != nil {
				return err
			}
			return nil
		})
		_s_UserName := func(ptr interface{}) { o.UserName = *ptr.(*string) }
		if err := w.ReadPointer(&o.UserName, _s_UserName, _ptr_UserName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// InfoStruct {in, out} (1:{alias=PFILE_ENUM_STRUCT,pointer=ref}*(1))(2:{alias=FILE_ENUM_STRUCT}(struct))
	{
		if o.Info == nil {
			o.Info = &FileEnum{}
		}
		if err := o.Info.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// PreferedMaximumLength {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PreferredMaximumLength); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=unique}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ResumeHandle := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.Resume); err != nil {
				return err
			}
			return nil
		})
		_s_ResumeHandle := func(ptr interface{}) { o.Resume = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.Resume, _s_ResumeHandle, _ptr_ResumeHandle); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FileEnumOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FileEnumOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// InfoStruct {in, out} (1:{alias=PFILE_ENUM_STRUCT}*(1))(2:{alias=FILE_ENUM_STRUCT}(struct))
	{
		if o.Info != nil {
			if err := o.Info.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&FileEnum{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// TotalEntries {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.TotalEntries); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=unique}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ResumeHandle := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.Resume); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Resume, _ptr_ResumeHandle); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FileEnumOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// InfoStruct {in, out} (1:{alias=PFILE_ENUM_STRUCT,pointer=ref}*(1))(2:{alias=FILE_ENUM_STRUCT}(struct))
	{
		if o.Info == nil {
			o.Info = &FileEnum{}
		}
		if err := o.Info.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// TotalEntries {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.TotalEntries); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=unique}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ResumeHandle := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.Resume); err != nil {
				return err
			}
			return nil
		})
		_s_ResumeHandle := func(ptr interface{}) { o.Resume = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.Resume, _s_ResumeHandle, _ptr_ResumeHandle); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// FileEnumRequest structure represents the NetrFileEnum operation request
type FileEnumRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle (see [C706] sections
	// 4.3.5 and 5.1.5.2). The server MUST ignore this parameter.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// BasePath: A pointer to a null-terminated UTF-16 string that specifies a path component.
	BasePath string `idl:"name:BasePath;string;pointer:unique" json:"base_path"`
	// UserName: A pointer to a null-terminated UTF-16 string that specifies the name of
	// a user.
	UserName string `idl:"name:UserName;string;pointer:unique" json:"user_name"`
	// InfoStruct: A pointer to a structure, in the format of a FILE_ENUM_STRUCT. The FILE_ENUM_STRUCT
	// structure has a Level field that specifies the type of structure to return. The Level
	// member MUST be one of the values specified in section 2.2.4.10.
	Info *FileEnum `idl:"name:InfoStruct" json:"info"`
	// PreferedMaximumLength: Specifies the preferred maximum length, in bytes, of returned
	// data. If the value that is specified is MAX_PREFERRED_LENGTH, the method MUST attempt
	// to return all entries.
	PreferredMaximumLength uint32 `idl:"name:PreferedMaximumLength" json:"preferred_maximum_length"`
	// ResumeHandle: A pointer to a value that contains a handle that is used to continue
	// an Open connection search. The handle MUST be zero on the first call and left unchanged
	// for subsequent calls. If ResumeHandle is NULL, a resume handle MUST NOT be stored.
	// If this parameter is not NULL and the method returns ERROR_MORE_DATA, this parameter
	// receives an implementation-specific nonzero value that can be passed in subsequent
	// calls to this method to continue with the enumeration.
	Resume uint32 `idl:"name:ResumeHandle;pointer:unique" json:"resume"`
}

func (o *FileEnumRequest) xxx_ToOp(ctx context.Context, op *xxx_FileEnumOperation) *xxx_FileEnumOperation {
	if op == nil {
		op = &xxx_FileEnumOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.BasePath = o.BasePath
	op.UserName = o.UserName
	op.Info = o.Info
	op.PreferredMaximumLength = o.PreferredMaximumLength
	op.Resume = o.Resume
	return op
}

func (o *FileEnumRequest) xxx_FromOp(ctx context.Context, op *xxx_FileEnumOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.BasePath = op.BasePath
	o.UserName = op.UserName
	o.Info = op.Info
	o.PreferredMaximumLength = op.PreferredMaximumLength
	o.Resume = op.Resume
}
func (o *FileEnumRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *FileEnumRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_FileEnumOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// FileEnumResponse structure represents the NetrFileEnum operation response
type FileEnumResponse struct {
	// InfoStruct: A pointer to a structure, in the format of a FILE_ENUM_STRUCT. The FILE_ENUM_STRUCT
	// structure has a Level field that specifies the type of structure to return. The Level
	// member MUST be one of the values specified in section 2.2.4.10.
	Info *FileEnum `idl:"name:InfoStruct" json:"info"`
	// TotalEntries: The total number of entries that could have been enumerated if the
	// buffer had been big enough to hold all the entries.
	TotalEntries uint32 `idl:"name:TotalEntries" json:"total_entries"`
	// ResumeHandle: A pointer to a value that contains a handle that is used to continue
	// an Open connection search. The handle MUST be zero on the first call and left unchanged
	// for subsequent calls. If ResumeHandle is NULL, a resume handle MUST NOT be stored.
	// If this parameter is not NULL and the method returns ERROR_MORE_DATA, this parameter
	// receives an implementation-specific nonzero value that can be passed in subsequent
	// calls to this method to continue with the enumeration.
	Resume uint32 `idl:"name:ResumeHandle;pointer:unique" json:"resume"`
	// Return: The NetrFileEnum return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *FileEnumResponse) xxx_ToOp(ctx context.Context, op *xxx_FileEnumOperation) *xxx_FileEnumOperation {
	if op == nil {
		op = &xxx_FileEnumOperation{}
	}
	if o == nil {
		return op
	}
	op.Info = o.Info
	op.TotalEntries = o.TotalEntries
	op.Resume = o.Resume
	op.Return = o.Return
	return op
}

func (o *FileEnumResponse) xxx_FromOp(ctx context.Context, op *xxx_FileEnumOperation) {
	if o == nil {
		return
	}
	o.Info = op.Info
	o.TotalEntries = op.TotalEntries
	o.Resume = op.Resume
	o.Return = op.Return
}
func (o *FileEnumResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *FileEnumResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_FileEnumOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_FileGetInfoOperation structure represents the NetrFileGetInfo operation
type xxx_FileGetInfoOperation struct {
	ServerName string    `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	FileID     uint32    `idl:"name:FileId" json:"file_id"`
	Level      uint32    `idl:"name:Level" json:"level"`
	Info       *FileInfo `idl:"name:InfoStruct;switch_is:Level" json:"info"`
	Return     uint32    `idl:"name:Return" json:"return"`
}

func (o *xxx_FileGetInfoOperation) OpNum() int { return 10 }

func (o *xxx_FileGetInfoOperation) OpName() string { return "/srvsvc/v3/NetrFileGetInfo" }

func (o *xxx_FileGetInfoOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FileGetInfoOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// FileId {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.FileID); err != nil {
			return err
		}
	}
	// Level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Level); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FileGetInfoOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// FileId {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.FileID); err != nil {
			return err
		}
	}
	// Level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Level); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FileGetInfoOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FileGetInfoOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// InfoStruct {out} (1:{switch_type={}(uint32), alias=LPFILE_INFO}*(1))(2:{switch_type={}(uint32), alias=FILE_INFO}(union))
	{
		_swInfo := uint32(o.Level)
		if o.Info != nil {
			if err := o.Info.MarshalUnionNDR(ctx, w, _swInfo); err != nil {
				return err
			}
		} else {
			if err := (&FileInfo{}).MarshalUnionNDR(ctx, w, _swInfo); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FileGetInfoOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// InfoStruct {out} (1:{switch_type={}(uint32), alias=LPFILE_INFO,pointer=ref}*(1))(2:{switch_type={}(uint32), alias=FILE_INFO}(union))
	{
		if o.Info == nil {
			o.Info = &FileInfo{}
		}
		_swInfo := uint32(o.Level)
		if err := o.Info.UnmarshalUnionNDR(ctx, w, _swInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// FileGetInfoRequest structure represents the NetrFileGetInfo operation request
type FileGetInfoRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle (see [C706] sections
	// 4.3.5 and 5.1.5.2). The server MUST ignore this parameter.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// FileId: Specifies the file identifier of the open resource to return information
	// for. The value of this parameter MUST have been returned in a previous NetrFileEnum
	// method call.
	FileID uint32 `idl:"name:FileId" json:"file_id"`
	// Level: Specifies the information level of the data. This parameter MUST have one
	// of the following values.
	//
	//	+-------+-------------+
	//	|       |             |
	//	| VALUE |   MEANING   |
	//	|       |             |
	//	+-------+-------------+
	//	+-------+-------------+
	//	|     2 | FILE_INFO_2 |
	//	+-------+-------------+
	//	|     3 | FILE_INFO_3 |
	//	+-------+-------------+
	Level uint32 `idl:"name:Level" json:"level"`
}

func (o *FileGetInfoRequest) xxx_ToOp(ctx context.Context, op *xxx_FileGetInfoOperation) *xxx_FileGetInfoOperation {
	if op == nil {
		op = &xxx_FileGetInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.FileID = o.FileID
	op.Level = o.Level
	return op
}

func (o *FileGetInfoRequest) xxx_FromOp(ctx context.Context, op *xxx_FileGetInfoOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.FileID = op.FileID
	o.Level = op.Level
}
func (o *FileGetInfoRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *FileGetInfoRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_FileGetInfoOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// FileGetInfoResponse structure represents the NetrFileGetInfo operation response
type FileGetInfoResponse struct {
	// XXX: Level is an implicit input depedency for output parameters
	Level uint32 `idl:"name:Level" json:"level"`

	// InfoStruct: This parameter is of type LPFILE_INFO, which is defined in section 2.2.3.3.
	// Its contents are determined by the value of the Level member, as shown in the previous
	// parameter table.
	Info *FileInfo `idl:"name:InfoStruct;switch_is:Level" json:"info"`
	// Return: The NetrFileGetInfo return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *FileGetInfoResponse) xxx_ToOp(ctx context.Context, op *xxx_FileGetInfoOperation) *xxx_FileGetInfoOperation {
	if op == nil {
		op = &xxx_FileGetInfoOperation{}
	}
	if o == nil {
		return op
	}
	// XXX: implicit input dependencies for output parameters
	if op.Level == uint32(0) {
		op.Level = o.Level
	}

	op.Info = o.Info
	op.Return = o.Return
	return op
}

func (o *FileGetInfoResponse) xxx_FromOp(ctx context.Context, op *xxx_FileGetInfoOperation) {
	if o == nil {
		return
	}
	// XXX: implicit input dependencies for output parameters
	o.Level = op.Level

	o.Info = op.Info
	o.Return = op.Return
}
func (o *FileGetInfoResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *FileGetInfoResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_FileGetInfoOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_FileCloseOperation structure represents the NetrFileClose operation
type xxx_FileCloseOperation struct {
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	FileID     uint32 `idl:"name:FileId" json:"file_id"`
	Return     uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_FileCloseOperation) OpNum() int { return 11 }

func (o *xxx_FileCloseOperation) OpName() string { return "/srvsvc/v3/NetrFileClose" }

func (o *xxx_FileCloseOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FileCloseOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// FileId {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.FileID); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FileCloseOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// FileId {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.FileID); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FileCloseOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FileCloseOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FileCloseOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// FileCloseRequest structure represents the NetrFileClose operation request
type FileCloseRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle (see [C706] sections
	// 4.3.5 and 5.1.5.2). The server MUST ignore this parameter.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// FileId: Specifies the file identifier of the open file, device, or pipe to close.
	FileID uint32 `idl:"name:FileId" json:"file_id"`
}

func (o *FileCloseRequest) xxx_ToOp(ctx context.Context, op *xxx_FileCloseOperation) *xxx_FileCloseOperation {
	if op == nil {
		op = &xxx_FileCloseOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.FileID = o.FileID
	return op
}

func (o *FileCloseRequest) xxx_FromOp(ctx context.Context, op *xxx_FileCloseOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.FileID = op.FileID
}
func (o *FileCloseRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *FileCloseRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_FileCloseOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// FileCloseResponse structure represents the NetrFileClose operation response
type FileCloseResponse struct {
	// Return: The NetrFileClose return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *FileCloseResponse) xxx_ToOp(ctx context.Context, op *xxx_FileCloseOperation) *xxx_FileCloseOperation {
	if op == nil {
		op = &xxx_FileCloseOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *FileCloseResponse) xxx_FromOp(ctx context.Context, op *xxx_FileCloseOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *FileCloseResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *FileCloseResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_FileCloseOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SessionEnumOperation structure represents the NetrSessionEnum operation
type xxx_SessionEnumOperation struct {
	ServerName             string       `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	ClientName             string       `idl:"name:ClientName;string;pointer:unique" json:"client_name"`
	UserName               string       `idl:"name:UserName;string;pointer:unique" json:"user_name"`
	Info                   *SessionEnum `idl:"name:InfoStruct" json:"info"`
	PreferredMaximumLength uint32       `idl:"name:PreferedMaximumLength" json:"preferred_maximum_length"`
	TotalEntries           uint32       `idl:"name:TotalEntries" json:"total_entries"`
	Resume                 uint32       `idl:"name:ResumeHandle;pointer:unique" json:"resume"`
	Return                 uint32       `idl:"name:Return" json:"return"`
}

func (o *xxx_SessionEnumOperation) OpNum() int { return 12 }

func (o *xxx_SessionEnumOperation) OpName() string { return "/srvsvc/v3/NetrSessionEnum" }

func (o *xxx_SessionEnumOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SessionEnumOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ClientName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.ClientName != "" {
			_ptr_ClientName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ClientName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ClientName, _ptr_ClientName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// UserName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.UserName != "" {
			_ptr_UserName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.UserName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.UserName, _ptr_UserName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// InfoStruct {in, out} (1:{alias=PSESSION_ENUM_STRUCT}*(1))(2:{alias=SESSION_ENUM_STRUCT}(struct))
	{
		if o.Info != nil {
			if err := o.Info.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&SessionEnum{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// PreferedMaximumLength {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PreferredMaximumLength); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=unique}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ResumeHandle := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.Resume); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Resume, _ptr_ResumeHandle); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SessionEnumOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ClientName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_ClientName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ClientName); err != nil {
				return err
			}
			return nil
		})
		_s_ClientName := func(ptr interface{}) { o.ClientName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ClientName, _s_ClientName, _ptr_ClientName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// UserName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_UserName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.UserName); err != nil {
				return err
			}
			return nil
		})
		_s_UserName := func(ptr interface{}) { o.UserName = *ptr.(*string) }
		if err := w.ReadPointer(&o.UserName, _s_UserName, _ptr_UserName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// InfoStruct {in, out} (1:{alias=PSESSION_ENUM_STRUCT,pointer=ref}*(1))(2:{alias=SESSION_ENUM_STRUCT}(struct))
	{
		if o.Info == nil {
			o.Info = &SessionEnum{}
		}
		if err := o.Info.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// PreferedMaximumLength {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PreferredMaximumLength); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=unique}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ResumeHandle := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.Resume); err != nil {
				return err
			}
			return nil
		})
		_s_ResumeHandle := func(ptr interface{}) { o.Resume = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.Resume, _s_ResumeHandle, _ptr_ResumeHandle); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SessionEnumOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SessionEnumOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// InfoStruct {in, out} (1:{alias=PSESSION_ENUM_STRUCT}*(1))(2:{alias=SESSION_ENUM_STRUCT}(struct))
	{
		if o.Info != nil {
			if err := o.Info.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&SessionEnum{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// TotalEntries {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.TotalEntries); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=unique}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ResumeHandle := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.Resume); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Resume, _ptr_ResumeHandle); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SessionEnumOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// InfoStruct {in, out} (1:{alias=PSESSION_ENUM_STRUCT,pointer=ref}*(1))(2:{alias=SESSION_ENUM_STRUCT}(struct))
	{
		if o.Info == nil {
			o.Info = &SessionEnum{}
		}
		if err := o.Info.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// TotalEntries {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.TotalEntries); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=unique}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ResumeHandle := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.Resume); err != nil {
				return err
			}
			return nil
		})
		_s_ResumeHandle := func(ptr interface{}) { o.Resume = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.Resume, _s_ResumeHandle, _ptr_ResumeHandle); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SessionEnumRequest structure represents the NetrSessionEnum operation request
type SessionEnumRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle (see [C706] sections
	// 4.3.5 and 5.1.5.2). The server MUST ignore this parameter.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// ClientName: A pointer to a null-terminated UTF-16 string that specifies the name
	// of the computer session for which information is to be returned. This string MUST
	// be one of the following: a NULL (zero-length) string; or a string that MUST begin
	// with \\.
	ClientName string `idl:"name:ClientName;string;pointer:unique" json:"client_name"`
	// UserName: A pointer to a null-terminated UTF-16 string that specifies the user name
	// for which information is to be returned.
	UserName string `idl:"name:UserName;string;pointer:unique" json:"user_name"`
	// InfoStruct: A pointer to a structure, in the format of a SESSION_ENUM_STRUCT. The
	// SESSION_ENUM_STRUCT structure has a Level member that specifies the type of structure
	// to return. The Level member MUST be one of the values specified in section 2.2.4.21.
	Info *SessionEnum `idl:"name:InfoStruct" json:"info"`
	// PreferedMaximumLength: Specifies the preferred maximum length, in bytes, of the returned
	// data. If the value that is specified is MAX_PREFERRED_LENGTH, the method MUST attempt
	// to return all entries.
	PreferredMaximumLength uint32 `idl:"name:PreferedMaximumLength" json:"preferred_maximum_length"`
	// ResumeHandle: A pointer to a value that contains a handle that is used to continue
	// an existing session search in SessionList, as specified in section 3.1.1.1. The handle
	// MUST be zero on the first call and remain unchanged for subsequent calls. If the
	// ResumeHandle parameter is NULL, no resume handle MUST be stored. If this parameter
	// is not NULL and the method returns ERROR_MORE_DATA, this parameter receives an implementation-specific
	// nonzero value that can be passed in subsequent calls to this method to continue with
	// the enumeration.
	Resume uint32 `idl:"name:ResumeHandle;pointer:unique" json:"resume"`
}

func (o *SessionEnumRequest) xxx_ToOp(ctx context.Context, op *xxx_SessionEnumOperation) *xxx_SessionEnumOperation {
	if op == nil {
		op = &xxx_SessionEnumOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.ClientName = o.ClientName
	op.UserName = o.UserName
	op.Info = o.Info
	op.PreferredMaximumLength = o.PreferredMaximumLength
	op.Resume = o.Resume
	return op
}

func (o *SessionEnumRequest) xxx_FromOp(ctx context.Context, op *xxx_SessionEnumOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.ClientName = op.ClientName
	o.UserName = op.UserName
	o.Info = op.Info
	o.PreferredMaximumLength = op.PreferredMaximumLength
	o.Resume = op.Resume
}
func (o *SessionEnumRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SessionEnumRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SessionEnumOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SessionEnumResponse structure represents the NetrSessionEnum operation response
type SessionEnumResponse struct {
	// InfoStruct: A pointer to a structure, in the format of a SESSION_ENUM_STRUCT. The
	// SESSION_ENUM_STRUCT structure has a Level member that specifies the type of structure
	// to return. The Level member MUST be one of the values specified in section 2.2.4.21.
	Info *SessionEnum `idl:"name:InfoStruct" json:"info"`
	// TotalEntries: The total number of entries that could have been enumerated if the
	// buffer had been big enough to hold all the entries.
	TotalEntries uint32 `idl:"name:TotalEntries" json:"total_entries"`
	// ResumeHandle: A pointer to a value that contains a handle that is used to continue
	// an existing session search in SessionList, as specified in section 3.1.1.1. The handle
	// MUST be zero on the first call and remain unchanged for subsequent calls. If the
	// ResumeHandle parameter is NULL, no resume handle MUST be stored. If this parameter
	// is not NULL and the method returns ERROR_MORE_DATA, this parameter receives an implementation-specific
	// nonzero value that can be passed in subsequent calls to this method to continue with
	// the enumeration.
	Resume uint32 `idl:"name:ResumeHandle;pointer:unique" json:"resume"`
	// Return: The NetrSessionEnum return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SessionEnumResponse) xxx_ToOp(ctx context.Context, op *xxx_SessionEnumOperation) *xxx_SessionEnumOperation {
	if op == nil {
		op = &xxx_SessionEnumOperation{}
	}
	if o == nil {
		return op
	}
	op.Info = o.Info
	op.TotalEntries = o.TotalEntries
	op.Resume = o.Resume
	op.Return = o.Return
	return op
}

func (o *SessionEnumResponse) xxx_FromOp(ctx context.Context, op *xxx_SessionEnumOperation) {
	if o == nil {
		return
	}
	o.Info = op.Info
	o.TotalEntries = op.TotalEntries
	o.Resume = op.Resume
	o.Return = op.Return
}
func (o *SessionEnumResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SessionEnumResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SessionEnumOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SessionDeleteOperation structure represents the NetrSessionDel operation
type xxx_SessionDeleteOperation struct {
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	ClientName string `idl:"name:ClientName;string;pointer:unique" json:"client_name"`
	UserName   string `idl:"name:UserName;string;pointer:unique" json:"user_name"`
	Return     uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_SessionDeleteOperation) OpNum() int { return 13 }

func (o *xxx_SessionDeleteOperation) OpName() string { return "/srvsvc/v3/NetrSessionDel" }

func (o *xxx_SessionDeleteOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SessionDeleteOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ClientName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.ClientName != "" {
			_ptr_ClientName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ClientName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ClientName, _ptr_ClientName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// UserName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.UserName != "" {
			_ptr_UserName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.UserName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.UserName, _ptr_UserName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SessionDeleteOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ClientName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_ClientName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ClientName); err != nil {
				return err
			}
			return nil
		})
		_s_ClientName := func(ptr interface{}) { o.ClientName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ClientName, _s_ClientName, _ptr_ClientName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// UserName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_UserName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.UserName); err != nil {
				return err
			}
			return nil
		})
		_s_UserName := func(ptr interface{}) { o.UserName = *ptr.(*string) }
		if err := w.ReadPointer(&o.UserName, _s_UserName, _ptr_UserName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SessionDeleteOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SessionDeleteOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SessionDeleteOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SessionDeleteRequest structure represents the NetrSessionDel operation request
type SessionDeleteRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle (see [C706] sections
	// 4.3.5 and 5.1.5.2). The server MUST ignore this parameter.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// ClientName: A pointer to a null-terminated UTF-16 string that specifies the computer
	// name of the client whose sessions are to be disconnected. This string MUST be one
	// of the following: a NULL (zero-length) string; or a string that MUST begin with \\.
	ClientName string `idl:"name:ClientName;string;pointer:unique" json:"client_name"`
	// UserName: A pointer to a null-terminated UTF-16 string that specifies the user name
	// whose sessions are to be terminated.
	UserName string `idl:"name:UserName;string;pointer:unique" json:"user_name"`
}

func (o *SessionDeleteRequest) xxx_ToOp(ctx context.Context, op *xxx_SessionDeleteOperation) *xxx_SessionDeleteOperation {
	if op == nil {
		op = &xxx_SessionDeleteOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.ClientName = o.ClientName
	op.UserName = o.UserName
	return op
}

func (o *SessionDeleteRequest) xxx_FromOp(ctx context.Context, op *xxx_SessionDeleteOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.ClientName = op.ClientName
	o.UserName = op.UserName
}
func (o *SessionDeleteRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SessionDeleteRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SessionDeleteOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SessionDeleteResponse structure represents the NetrSessionDel operation response
type SessionDeleteResponse struct {
	// Return: The NetrSessionDel return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SessionDeleteResponse) xxx_ToOp(ctx context.Context, op *xxx_SessionDeleteOperation) *xxx_SessionDeleteOperation {
	if op == nil {
		op = &xxx_SessionDeleteOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SessionDeleteResponse) xxx_FromOp(ctx context.Context, op *xxx_SessionDeleteOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SessionDeleteResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SessionDeleteResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SessionDeleteOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ShareAddOperation structure represents the NetrShareAdd operation
type xxx_ShareAddOperation struct {
	ServerName     string     `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	Level          uint32     `idl:"name:Level" json:"level"`
	Info           *ShareInfo `idl:"name:InfoStruct;switch_is:Level" json:"info"`
	ParameterError uint32     `idl:"name:ParmErr;pointer:unique" json:"parameter_error"`
	Return         uint32     `idl:"name:Return" json:"return"`
}

func (o *xxx_ShareAddOperation) OpNum() int { return 14 }

func (o *xxx_ShareAddOperation) OpName() string { return "/srvsvc/v3/NetrShareAdd" }

func (o *xxx_ShareAddOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareAddOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Level); err != nil {
			return err
		}
	}
	// InfoStruct {in} (1:{switch_type={}(uint32), alias=LPSHARE_INFO}*(1))(2:{switch_type={}(uint32), alias=SHARE_INFO}(union))
	{
		_swInfo := uint32(o.Level)
		if o.Info != nil {
			if err := o.Info.MarshalUnionNDR(ctx, w, _swInfo); err != nil {
				return err
			}
		} else {
			if err := (&ShareInfo{}).MarshalUnionNDR(ctx, w, _swInfo); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ParmErr {in, out} (1:{pointer=unique}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ParmErr := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.ParameterError); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ParameterError, _ptr_ParmErr); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareAddOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Level); err != nil {
			return err
		}
	}
	// InfoStruct {in} (1:{switch_type={}(uint32), alias=LPSHARE_INFO,pointer=ref}*(1))(2:{switch_type={}(uint32), alias=SHARE_INFO}(union))
	{
		if o.Info == nil {
			o.Info = &ShareInfo{}
		}
		_swInfo := uint32(o.Level)
		if err := o.Info.UnmarshalUnionNDR(ctx, w, _swInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ParmErr {in, out} (1:{pointer=unique}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ParmErr := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.ParameterError); err != nil {
				return err
			}
			return nil
		})
		_s_ParmErr := func(ptr interface{}) { o.ParameterError = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.ParameterError, _s_ParmErr, _ptr_ParmErr); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareAddOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareAddOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ParmErr {in, out} (1:{pointer=unique}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ParmErr := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.ParameterError); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ParameterError, _ptr_ParmErr); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareAddOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ParmErr {in, out} (1:{pointer=unique}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ParmErr := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.ParameterError); err != nil {
				return err
			}
			return nil
		})
		_s_ParmErr := func(ptr interface{}) { o.ParameterError = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.ParameterError, _s_ParmErr, _ptr_ParmErr); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ShareAddRequest structure represents the NetrShareAdd operation request
type ShareAddRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle (see [C706] sections
	// 4.3.5 and 5.1.5.2). The server MUST ignore this parameter.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// Level: Specifies the information level of the data. This parameter MUST be one of
	// the following values.
	//
	//	+-------+-----------------------------------------+
	//	|       |                                         |
	//	| VALUE |                 MEANING                 |
	//	|       |                                         |
	//	+-------+-----------------------------------------+
	//	+-------+-----------------------------------------+
	//	|     2 | The buffer is of type SHARE_INFO_2.     |
	//	+-------+-----------------------------------------+
	//	|   502 | The buffer is of type SHARE_INFO_502_I. |
	//	+-------+-----------------------------------------+
	//	|   503 | The buffer is of type SHARE_INFO_503_I. |
	//	+-------+-----------------------------------------+
	Level uint32 `idl:"name:Level" json:"level"`
	// InfoStruct: A pointer to the SHARE_INFO union. The contents of the InfoStruct parameter
	// depend on the value of the Level parameter. The client MUST set the STYPE_CLUSTER_FS,
	// STYPE_CLUSTER_SOFS, and STYPE_CLUSTER_DFS bits in the shi*_type field of the SHARE_INFO
	// union to zero; the server MUST ignore them on receipt.
	Info *ShareInfo `idl:"name:InfoStruct;switch_is:Level" json:"info"`
	// ParmErr: A pointer to a value that receives the index of the first member of the
	// share information structure that caused an ERROR_INVALID_PARAMETER error code, if
	// it occurs.
	ParameterError uint32 `idl:"name:ParmErr;pointer:unique" json:"parameter_error"`
}

func (o *ShareAddRequest) xxx_ToOp(ctx context.Context, op *xxx_ShareAddOperation) *xxx_ShareAddOperation {
	if op == nil {
		op = &xxx_ShareAddOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.Level = o.Level
	op.Info = o.Info
	op.ParameterError = o.ParameterError
	return op
}

func (o *ShareAddRequest) xxx_FromOp(ctx context.Context, op *xxx_ShareAddOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.Level = op.Level
	o.Info = op.Info
	o.ParameterError = op.ParameterError
}
func (o *ShareAddRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *ShareAddRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ShareAddOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ShareAddResponse structure represents the NetrShareAdd operation response
type ShareAddResponse struct {
	// ParmErr: A pointer to a value that receives the index of the first member of the
	// share information structure that caused an ERROR_INVALID_PARAMETER error code, if
	// it occurs.
	ParameterError uint32 `idl:"name:ParmErr;pointer:unique" json:"parameter_error"`
	// Return: The NetrShareAdd return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ShareAddResponse) xxx_ToOp(ctx context.Context, op *xxx_ShareAddOperation) *xxx_ShareAddOperation {
	if op == nil {
		op = &xxx_ShareAddOperation{}
	}
	if o == nil {
		return op
	}
	op.ParameterError = o.ParameterError
	op.Return = o.Return
	return op
}

func (o *ShareAddResponse) xxx_FromOp(ctx context.Context, op *xxx_ShareAddOperation) {
	if o == nil {
		return
	}
	o.ParameterError = op.ParameterError
	o.Return = op.Return
}
func (o *ShareAddResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *ShareAddResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ShareAddOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ShareEnumOperation structure represents the NetrShareEnum operation
type xxx_ShareEnumOperation struct {
	ServerName             string     `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	Info                   *ShareEnum `idl:"name:InfoStruct" json:"info"`
	PreferredMaximumLength uint32     `idl:"name:PreferedMaximumLength" json:"preferred_maximum_length"`
	TotalEntries           uint32     `idl:"name:TotalEntries" json:"total_entries"`
	Resume                 uint32     `idl:"name:ResumeHandle;pointer:unique" json:"resume"`
	Return                 uint32     `idl:"name:Return" json:"return"`
}

func (o *xxx_ShareEnumOperation) OpNum() int { return 15 }

func (o *xxx_ShareEnumOperation) OpName() string { return "/srvsvc/v3/NetrShareEnum" }

func (o *xxx_ShareEnumOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareEnumOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// InfoStruct {in, out} (1:{alias=LPSHARE_ENUM_STRUCT}*(1))(2:{alias=SHARE_ENUM_STRUCT}(struct))
	{
		if o.Info != nil {
			if err := o.Info.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ShareEnum{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// PreferedMaximumLength {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PreferredMaximumLength); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=unique}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ResumeHandle := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.Resume); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Resume, _ptr_ResumeHandle); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareEnumOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// InfoStruct {in, out} (1:{alias=LPSHARE_ENUM_STRUCT,pointer=ref}*(1))(2:{alias=SHARE_ENUM_STRUCT}(struct))
	{
		if o.Info == nil {
			o.Info = &ShareEnum{}
		}
		if err := o.Info.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// PreferedMaximumLength {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PreferredMaximumLength); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=unique}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ResumeHandle := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.Resume); err != nil {
				return err
			}
			return nil
		})
		_s_ResumeHandle := func(ptr interface{}) { o.Resume = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.Resume, _s_ResumeHandle, _ptr_ResumeHandle); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareEnumOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareEnumOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// InfoStruct {in, out} (1:{alias=LPSHARE_ENUM_STRUCT}*(1))(2:{alias=SHARE_ENUM_STRUCT}(struct))
	{
		if o.Info != nil {
			if err := o.Info.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ShareEnum{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// TotalEntries {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.TotalEntries); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=unique}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ResumeHandle := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.Resume); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Resume, _ptr_ResumeHandle); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareEnumOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// InfoStruct {in, out} (1:{alias=LPSHARE_ENUM_STRUCT,pointer=ref}*(1))(2:{alias=SHARE_ENUM_STRUCT}(struct))
	{
		if o.Info == nil {
			o.Info = &ShareEnum{}
		}
		if err := o.Info.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// TotalEntries {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.TotalEntries); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=unique}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ResumeHandle := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.Resume); err != nil {
				return err
			}
			return nil
		})
		_s_ResumeHandle := func(ptr interface{}) { o.Resume = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.Resume, _s_ResumeHandle, _ptr_ResumeHandle); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ShareEnumRequest structure represents the NetrShareEnum operation request
type ShareEnumRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle (see [C706] sections
	// 4.3.5 and 5.1.5.2). If this parameter is NULL, the local computer is used.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// InfoStruct: A pointer to a structure, in the format of a SHARE_ENUM_STRUCT (section
	// 2.2.4.38), as specified in section 2.2.4.38. The SHARE_ENUM_STRUCT structure has
	// a Level member that specifies the type of structure to return in the ShareInfo member.
	// The Level member MUST be one of the values specified in section 2.2.4.38.
	Info *ShareEnum `idl:"name:InfoStruct" json:"info"`
	// PreferedMaximumLength: Specifies the preferred maximum length, in bytes, of the returned
	// data. If the specified value is MAX_PREFERRED_LENGTH, the method MUST attempt to
	// return all entries.
	PreferredMaximumLength uint32 `idl:"name:PreferedMaximumLength" json:"preferred_maximum_length"`
	// ResumeHandle: A pointer to a value that contains a handle, which is used to continue
	// an existing share search in ShareList. The handle MUST be zero on the first call
	// and remain unchanged for subsequent calls. If the ResumeHandle parameter is NULL,
	// no resume handle MUST be stored. If this parameter is not NULL and the method returns
	// ERROR_MORE_DATA, this parameter receives a nonzero value that can be passed in subsequent
	// calls to this method to continue with the enumeration in ShareList.
	Resume uint32 `idl:"name:ResumeHandle;pointer:unique" json:"resume"`
}

func (o *ShareEnumRequest) xxx_ToOp(ctx context.Context, op *xxx_ShareEnumOperation) *xxx_ShareEnumOperation {
	if op == nil {
		op = &xxx_ShareEnumOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.Info = o.Info
	op.PreferredMaximumLength = o.PreferredMaximumLength
	op.Resume = o.Resume
	return op
}

func (o *ShareEnumRequest) xxx_FromOp(ctx context.Context, op *xxx_ShareEnumOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.Info = op.Info
	o.PreferredMaximumLength = op.PreferredMaximumLength
	o.Resume = op.Resume
}
func (o *ShareEnumRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *ShareEnumRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ShareEnumOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ShareEnumResponse structure represents the NetrShareEnum operation response
type ShareEnumResponse struct {
	// InfoStruct: A pointer to a structure, in the format of a SHARE_ENUM_STRUCT (section
	// 2.2.4.38), as specified in section 2.2.4.38. The SHARE_ENUM_STRUCT structure has
	// a Level member that specifies the type of structure to return in the ShareInfo member.
	// The Level member MUST be one of the values specified in section 2.2.4.38.
	Info *ShareEnum `idl:"name:InfoStruct" json:"info"`
	// TotalEntries: The total number of entries that could have been enumerated if the
	// buffer had been big enough to hold all the entries.
	TotalEntries uint32 `idl:"name:TotalEntries" json:"total_entries"`
	// ResumeHandle: A pointer to a value that contains a handle, which is used to continue
	// an existing share search in ShareList. The handle MUST be zero on the first call
	// and remain unchanged for subsequent calls. If the ResumeHandle parameter is NULL,
	// no resume handle MUST be stored. If this parameter is not NULL and the method returns
	// ERROR_MORE_DATA, this parameter receives a nonzero value that can be passed in subsequent
	// calls to this method to continue with the enumeration in ShareList.
	Resume uint32 `idl:"name:ResumeHandle;pointer:unique" json:"resume"`
	// Return: The NetrShareEnum return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ShareEnumResponse) xxx_ToOp(ctx context.Context, op *xxx_ShareEnumOperation) *xxx_ShareEnumOperation {
	if op == nil {
		op = &xxx_ShareEnumOperation{}
	}
	if o == nil {
		return op
	}
	op.Info = o.Info
	op.TotalEntries = o.TotalEntries
	op.Resume = o.Resume
	op.Return = o.Return
	return op
}

func (o *ShareEnumResponse) xxx_FromOp(ctx context.Context, op *xxx_ShareEnumOperation) {
	if o == nil {
		return
	}
	o.Info = op.Info
	o.TotalEntries = op.TotalEntries
	o.Resume = op.Resume
	o.Return = op.Return
}
func (o *ShareEnumResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *ShareEnumResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ShareEnumOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ShareGetInfoOperation structure represents the NetrShareGetInfo operation
type xxx_ShareGetInfoOperation struct {
	ServerName string     `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	NetName    string     `idl:"name:NetName;string" json:"net_name"`
	Level      uint32     `idl:"name:Level" json:"level"`
	Info       *ShareInfo `idl:"name:InfoStruct;switch_is:Level" json:"info"`
	Return     uint32     `idl:"name:Return" json:"return"`
}

func (o *xxx_ShareGetInfoOperation) OpNum() int { return 16 }

func (o *xxx_ShareGetInfoOperation) OpName() string { return "/srvsvc/v3/NetrShareGetInfo" }

func (o *xxx_ShareGetInfoOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareGetInfoOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// NetName {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.NetName); err != nil {
			return err
		}
	}
	// Level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Level); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareGetInfoOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// NetName {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.NetName); err != nil {
			return err
		}
	}
	// Level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Level); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareGetInfoOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareGetInfoOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// InfoStruct {out} (1:{switch_type={}(uint32), alias=LPSHARE_INFO}*(1))(2:{switch_type={}(uint32), alias=SHARE_INFO}(union))
	{
		_swInfo := uint32(o.Level)
		if o.Info != nil {
			if err := o.Info.MarshalUnionNDR(ctx, w, _swInfo); err != nil {
				return err
			}
		} else {
			if err := (&ShareInfo{}).MarshalUnionNDR(ctx, w, _swInfo); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareGetInfoOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// InfoStruct {out} (1:{switch_type={}(uint32), alias=LPSHARE_INFO,pointer=ref}*(1))(2:{switch_type={}(uint32), alias=SHARE_INFO}(union))
	{
		if o.Info == nil {
			o.Info = &ShareInfo{}
		}
		_swInfo := uint32(o.Level)
		if err := o.Info.UnmarshalUnionNDR(ctx, w, _swInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ShareGetInfoRequest structure represents the NetrShareGetInfo operation request
type ShareGetInfoRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle ([C706] sections 4.3.5
	// and 5.1.5.2). If this parameter is NULL, the local computer is used.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// NetName: A pointer to a null-terminated UTF-16 string that specifies the name of
	// the share to return information for.
	NetName string `idl:"name:NetName;string" json:"net_name"`
	// Level: Specifies the information level of the data. This parameter MUST be one of
	// the following values.
	//
	//	+-------+--------------------+
	//	|       |                    |
	//	| VALUE |      MEANING       |
	//	|       |                    |
	//	+-------+--------------------+
	//	+-------+--------------------+
	//	|     0 | LPSHARE_INFO_0     |
	//	+-------+--------------------+
	//	|     1 | LPSHARE_INFO_1     |
	//	+-------+--------------------+
	//	|     2 | LPSHARE_INFO_2     |
	//	+-------+--------------------+
	//	|   501 | LPSHARE_INFO_501   |
	//	+-------+--------------------+
	//	|   502 | LPSHARE_INFO_502_I |
	//	+-------+--------------------+
	//	|   503 | LPSHARE_INFO_503_I |
	//	+-------+--------------------+
	//	|  1005 | LPSHARE_INFO_1005  |
	//	+-------+--------------------+
	Level uint32 `idl:"name:Level" json:"level"`
}

func (o *ShareGetInfoRequest) xxx_ToOp(ctx context.Context, op *xxx_ShareGetInfoOperation) *xxx_ShareGetInfoOperation {
	if op == nil {
		op = &xxx_ShareGetInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.NetName = o.NetName
	op.Level = o.Level
	return op
}

func (o *ShareGetInfoRequest) xxx_FromOp(ctx context.Context, op *xxx_ShareGetInfoOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.NetName = op.NetName
	o.Level = op.Level
}
func (o *ShareGetInfoRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *ShareGetInfoRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ShareGetInfoOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ShareGetInfoResponse structure represents the NetrShareGetInfo operation response
type ShareGetInfoResponse struct {
	// XXX: Level is an implicit input depedency for output parameters
	Level uint32 `idl:"name:Level" json:"level"`

	// InfoStruct: This parameter is of type LPSHARE_INFO union, as specified in section
	// 2.2.3.6. Its contents are determined by the value of the Level parameter, as shown
	// in the preceding table.
	Info *ShareInfo `idl:"name:InfoStruct;switch_is:Level" json:"info"`
	// Return: The NetrShareGetInfo return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ShareGetInfoResponse) xxx_ToOp(ctx context.Context, op *xxx_ShareGetInfoOperation) *xxx_ShareGetInfoOperation {
	if op == nil {
		op = &xxx_ShareGetInfoOperation{}
	}
	if o == nil {
		return op
	}
	// XXX: implicit input dependencies for output parameters
	if op.Level == uint32(0) {
		op.Level = o.Level
	}

	op.Info = o.Info
	op.Return = o.Return
	return op
}

func (o *ShareGetInfoResponse) xxx_FromOp(ctx context.Context, op *xxx_ShareGetInfoOperation) {
	if o == nil {
		return
	}
	// XXX: implicit input dependencies for output parameters
	o.Level = op.Level

	o.Info = op.Info
	o.Return = op.Return
}
func (o *ShareGetInfoResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *ShareGetInfoResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ShareGetInfoOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ShareSetInfoOperation structure represents the NetrShareSetInfo operation
type xxx_ShareSetInfoOperation struct {
	ServerName     string     `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	NetName        string     `idl:"name:NetName;string" json:"net_name"`
	Level          uint32     `idl:"name:Level" json:"level"`
	ShareInfo      *ShareInfo `idl:"name:ShareInfo;switch_is:Level" json:"share_info"`
	ParameterError uint32     `idl:"name:ParmErr;pointer:unique" json:"parameter_error"`
	Return         uint32     `idl:"name:Return" json:"return"`
}

func (o *xxx_ShareSetInfoOperation) OpNum() int { return 17 }

func (o *xxx_ShareSetInfoOperation) OpName() string { return "/srvsvc/v3/NetrShareSetInfo" }

func (o *xxx_ShareSetInfoOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareSetInfoOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// NetName {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.NetName); err != nil {
			return err
		}
	}
	// Level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Level); err != nil {
			return err
		}
	}
	// ShareInfo {in} (1:{switch_type={}(uint32), alias=LPSHARE_INFO}*(1))(2:{switch_type={}(uint32), alias=SHARE_INFO}(union))
	{
		_swShareInfo := uint32(o.Level)
		if o.ShareInfo != nil {
			if err := o.ShareInfo.MarshalUnionNDR(ctx, w, _swShareInfo); err != nil {
				return err
			}
		} else {
			if err := (&ShareInfo{}).MarshalUnionNDR(ctx, w, _swShareInfo); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ParmErr {in, out} (1:{pointer=unique}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ParmErr := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.ParameterError); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ParameterError, _ptr_ParmErr); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareSetInfoOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// NetName {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.NetName); err != nil {
			return err
		}
	}
	// Level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Level); err != nil {
			return err
		}
	}
	// ShareInfo {in} (1:{switch_type={}(uint32), alias=LPSHARE_INFO,pointer=ref}*(1))(2:{switch_type={}(uint32), alias=SHARE_INFO}(union))
	{
		if o.ShareInfo == nil {
			o.ShareInfo = &ShareInfo{}
		}
		_swShareInfo := uint32(o.Level)
		if err := o.ShareInfo.UnmarshalUnionNDR(ctx, w, _swShareInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ParmErr {in, out} (1:{pointer=unique}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ParmErr := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.ParameterError); err != nil {
				return err
			}
			return nil
		})
		_s_ParmErr := func(ptr interface{}) { o.ParameterError = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.ParameterError, _s_ParmErr, _ptr_ParmErr); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareSetInfoOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareSetInfoOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ParmErr {in, out} (1:{pointer=unique}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ParmErr := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.ParameterError); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ParameterError, _ptr_ParmErr); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareSetInfoOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ParmErr {in, out} (1:{pointer=unique}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ParmErr := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.ParameterError); err != nil {
				return err
			}
			return nil
		})
		_s_ParmErr := func(ptr interface{}) { o.ParameterError = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.ParameterError, _s_ParmErr, _ptr_ParmErr); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ShareSetInfoRequest structure represents the NetrShareSetInfo operation request
type ShareSetInfoRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle ([C706] sections 4.3.5
	// and 5.1.5.2). If this parameter is NULL, the local computer is used.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// NetName: A pointer to a null-terminated UTF-16 string that specifies the name of
	// the share to set information for.
	NetName string `idl:"name:NetName;string" json:"net_name"`
	// Level: Specifies the information level of the data. This parameter MUST be one of
	// the following values.
	//
	//	+-------+---------------------+
	//	|       |                     |
	//	| VALUE |       MEANING       |
	//	|       |                     |
	//	+-------+---------------------+
	//	+-------+---------------------+
	//	|     1 | LPSHARE_INFO_1      |
	//	+-------+---------------------+
	//	|     2 | LPSHARE_INFO_2      |
	//	+-------+---------------------+
	//	|   502 | SHARE_INFO_502_I    |
	//	+-------+---------------------+
	//	|   503 | SHARE_INFO_503_I    |
	//	+-------+---------------------+
	//	|  1004 | LPSHARE_INFO_1004   |
	//	+-------+---------------------+
	//	|  1005 | LPSHARE_INFO_1005   |
	//	+-------+---------------------+
	//	|  1006 | LPSHARE_INFO_1006   |
	//	+-------+---------------------+
	//	|  1501 | LPSHARE_INFO_1501_I |
	//	+-------+---------------------+
	Level uint32 `idl:"name:Level" json:"level"`
	// ShareInfo: This parameter is of type LPSHARE_INFO union, as specified in section
	// 2.2.3.6. Its contents are determined by the value of the Level parameter, as shown
	// in the preceding table. This parameter MUST NOT contain a null value. If the Level
	// parameter is equal to 1, 2, 502, or 503, the client MUST set the STYPE_CLUSTER_FS,
	// STYPE_CLUSTER_SOFS, and STYPE_CLUSTER_DFS bits in the shi*_type field of the SHARE_INFO
	// union to zero; the server MUST ignore them on receipt.
	ShareInfo *ShareInfo `idl:"name:ShareInfo;switch_is:Level" json:"share_info"`
	// ParmErr: A pointer to a value that receives the index of the first member of the
	// share information structure that caused the ERROR_INVALID_PARAMETER error, if it
	// occurs.
	ParameterError uint32 `idl:"name:ParmErr;pointer:unique" json:"parameter_error"`
}

func (o *ShareSetInfoRequest) xxx_ToOp(ctx context.Context, op *xxx_ShareSetInfoOperation) *xxx_ShareSetInfoOperation {
	if op == nil {
		op = &xxx_ShareSetInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.NetName = o.NetName
	op.Level = o.Level
	op.ShareInfo = o.ShareInfo
	op.ParameterError = o.ParameterError
	return op
}

func (o *ShareSetInfoRequest) xxx_FromOp(ctx context.Context, op *xxx_ShareSetInfoOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.NetName = op.NetName
	o.Level = op.Level
	o.ShareInfo = op.ShareInfo
	o.ParameterError = op.ParameterError
}
func (o *ShareSetInfoRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *ShareSetInfoRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ShareSetInfoOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ShareSetInfoResponse structure represents the NetrShareSetInfo operation response
type ShareSetInfoResponse struct {
	// ParmErr: A pointer to a value that receives the index of the first member of the
	// share information structure that caused the ERROR_INVALID_PARAMETER error, if it
	// occurs.
	ParameterError uint32 `idl:"name:ParmErr;pointer:unique" json:"parameter_error"`
	// Return: The NetrShareSetInfo return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ShareSetInfoResponse) xxx_ToOp(ctx context.Context, op *xxx_ShareSetInfoOperation) *xxx_ShareSetInfoOperation {
	if op == nil {
		op = &xxx_ShareSetInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.ParameterError = o.ParameterError
	op.Return = o.Return
	return op
}

func (o *ShareSetInfoResponse) xxx_FromOp(ctx context.Context, op *xxx_ShareSetInfoOperation) {
	if o == nil {
		return
	}
	o.ParameterError = op.ParameterError
	o.Return = op.Return
}
func (o *ShareSetInfoResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *ShareSetInfoResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ShareSetInfoOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ShareDeleteOperation structure represents the NetrShareDel operation
type xxx_ShareDeleteOperation struct {
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	NetName    string `idl:"name:NetName;string" json:"net_name"`
	_          uint32 `idl:"name:Reserved"`
	Return     uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_ShareDeleteOperation) OpNum() int { return 18 }

func (o *xxx_ShareDeleteOperation) OpName() string { return "/srvsvc/v3/NetrShareDel" }

func (o *xxx_ShareDeleteOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareDeleteOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// NetName {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.NetName); err != nil {
			return err
		}
	}
	// Reserved {in} (1:{alias=DWORD}(uint32))
	{
		// reserved Reserved
		if err := w.WriteData(uint32(0)); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareDeleteOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// NetName {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.NetName); err != nil {
			return err
		}
	}
	// Reserved {in} (1:{alias=DWORD}(uint32))
	{
		// reserved Reserved
		var _Reserved uint32
		if err := w.ReadData(&_Reserved); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareDeleteOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareDeleteOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareDeleteOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ShareDeleteRequest structure represents the NetrShareDel operation request
type ShareDeleteRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle ([C706] sections 4.3.5
	// and 5.1.5.2). If this parameter is NULL, the local computer is used.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// NetName: A pointer to a null-terminated UTF-16 string that specifies the name of
	// the share to delete.
	NetName string `idl:"name:NetName;string" json:"net_name"`
}

func (o *ShareDeleteRequest) xxx_ToOp(ctx context.Context, op *xxx_ShareDeleteOperation) *xxx_ShareDeleteOperation {
	if op == nil {
		op = &xxx_ShareDeleteOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.NetName = o.NetName
	return op
}

func (o *ShareDeleteRequest) xxx_FromOp(ctx context.Context, op *xxx_ShareDeleteOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.NetName = op.NetName
}
func (o *ShareDeleteRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *ShareDeleteRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ShareDeleteOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ShareDeleteResponse structure represents the NetrShareDel operation response
type ShareDeleteResponse struct {
	// Return: The NetrShareDel return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ShareDeleteResponse) xxx_ToOp(ctx context.Context, op *xxx_ShareDeleteOperation) *xxx_ShareDeleteOperation {
	if op == nil {
		op = &xxx_ShareDeleteOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *ShareDeleteResponse) xxx_FromOp(ctx context.Context, op *xxx_ShareDeleteOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *ShareDeleteResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *ShareDeleteResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ShareDeleteOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ShareDeleteStickyOperation structure represents the NetrShareDelSticky operation
type xxx_ShareDeleteStickyOperation struct {
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	NetName    string `idl:"name:NetName;string" json:"net_name"`
	_          uint32 `idl:"name:Reserved"`
	Return     uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_ShareDeleteStickyOperation) OpNum() int { return 19 }

func (o *xxx_ShareDeleteStickyOperation) OpName() string { return "/srvsvc/v3/NetrShareDelSticky" }

func (o *xxx_ShareDeleteStickyOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareDeleteStickyOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// NetName {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.NetName); err != nil {
			return err
		}
	}
	// Reserved {in} (1:{alias=DWORD}(uint32))
	{
		// reserved Reserved
		if err := w.WriteData(uint32(0)); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareDeleteStickyOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// NetName {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.NetName); err != nil {
			return err
		}
	}
	// Reserved {in} (1:{alias=DWORD}(uint32))
	{
		// reserved Reserved
		var _Reserved uint32
		if err := w.ReadData(&_Reserved); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareDeleteStickyOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareDeleteStickyOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareDeleteStickyOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ShareDeleteStickyRequest structure represents the NetrShareDelSticky operation request
type ShareDeleteStickyRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle ([C706] sections 4.3.5
	// and 5.1.5.2). If this parameter is NULL, the local computer is used.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// NetName: A pointer to a null-terminated UTF-16 string that specifies the name of
	// the share to delete.
	NetName string `idl:"name:NetName;string" json:"net_name"`
}

func (o *ShareDeleteStickyRequest) xxx_ToOp(ctx context.Context, op *xxx_ShareDeleteStickyOperation) *xxx_ShareDeleteStickyOperation {
	if op == nil {
		op = &xxx_ShareDeleteStickyOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.NetName = o.NetName
	return op
}

func (o *ShareDeleteStickyRequest) xxx_FromOp(ctx context.Context, op *xxx_ShareDeleteStickyOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.NetName = op.NetName
}
func (o *ShareDeleteStickyRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *ShareDeleteStickyRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ShareDeleteStickyOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ShareDeleteStickyResponse structure represents the NetrShareDelSticky operation response
type ShareDeleteStickyResponse struct {
	// Return: The NetrShareDelSticky return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ShareDeleteStickyResponse) xxx_ToOp(ctx context.Context, op *xxx_ShareDeleteStickyOperation) *xxx_ShareDeleteStickyOperation {
	if op == nil {
		op = &xxx_ShareDeleteStickyOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *ShareDeleteStickyResponse) xxx_FromOp(ctx context.Context, op *xxx_ShareDeleteStickyOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *ShareDeleteStickyResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *ShareDeleteStickyResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ShareDeleteStickyOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ShareCheckOperation structure represents the NetrShareCheck operation
type xxx_ShareCheckOperation struct {
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	Device     string `idl:"name:Device;string" json:"device"`
	Type       uint32 `idl:"name:Type" json:"type"`
	Return     uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_ShareCheckOperation) OpNum() int { return 20 }

func (o *xxx_ShareCheckOperation) OpName() string { return "/srvsvc/v3/NetrShareCheck" }

func (o *xxx_ShareCheckOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareCheckOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Device {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.Device); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareCheckOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Device {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.Device); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareCheckOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareCheckOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Type {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Type); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareCheckOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Type {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Type); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ShareCheckRequest structure represents the NetrShareCheck operation request
type ShareCheckRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle (see [C706] sections
	// 4.3.5 and 5.1.5.2). The server MUST ignore this parameter.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// Device: A pointer to a null-terminated UTF-16 string that specifies the name of the
	// device to check for shared access.
	Device string `idl:"name:Device;string" json:"device"`
}

func (o *ShareCheckRequest) xxx_ToOp(ctx context.Context, op *xxx_ShareCheckOperation) *xxx_ShareCheckOperation {
	if op == nil {
		op = &xxx_ShareCheckOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.Device = o.Device
	return op
}

func (o *ShareCheckRequest) xxx_FromOp(ctx context.Context, op *xxx_ShareCheckOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.Device = op.Device
}
func (o *ShareCheckRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *ShareCheckRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ShareCheckOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ShareCheckResponse structure represents the NetrShareCheck operation response
type ShareCheckResponse struct {
	// Type: A pointer to a DWORD that receives the type of the shared device. This parameter
	// is set only if the method returns successfully. On success, the server MUST set this
	// parameter as specified in section 2.2.2.4, except that STYPE_SPECIAL is not returned.
	Type uint32 `idl:"name:Type" json:"type"`
	// Return: The NetrShareCheck return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ShareCheckResponse) xxx_ToOp(ctx context.Context, op *xxx_ShareCheckOperation) *xxx_ShareCheckOperation {
	if op == nil {
		op = &xxx_ShareCheckOperation{}
	}
	if o == nil {
		return op
	}
	op.Type = o.Type
	op.Return = o.Return
	return op
}

func (o *ShareCheckResponse) xxx_FromOp(ctx context.Context, op *xxx_ShareCheckOperation) {
	if o == nil {
		return
	}
	o.Type = op.Type
	o.Return = op.Return
}
func (o *ShareCheckResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *ShareCheckResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ShareCheckOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetInfoOperation structure represents the NetrServerGetInfo operation
type xxx_GetInfoOperation struct {
	ServerName string      `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	Level      uint32      `idl:"name:Level" json:"level"`
	Info       *ServerInfo `idl:"name:InfoStruct;switch_is:Level" json:"info"`
	Return     uint32      `idl:"name:Return" json:"return"`
}

func (o *xxx_GetInfoOperation) OpNum() int { return 21 }

func (o *xxx_GetInfoOperation) OpName() string { return "/srvsvc/v3/NetrServerGetInfo" }

func (o *xxx_GetInfoOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetInfoOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Level); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetInfoOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Level); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetInfoOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetInfoOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// InfoStruct {out} (1:{switch_type={}(uint32), alias=LPSERVER_INFO}*(1))(2:{switch_type={}(uint32), alias=SERVER_INFO}(union))
	{
		_swInfo := uint32(o.Level)
		if o.Info != nil {
			if err := o.Info.MarshalUnionNDR(ctx, w, _swInfo); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo{}).MarshalUnionNDR(ctx, w, _swInfo); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetInfoOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// InfoStruct {out} (1:{switch_type={}(uint32), alias=LPSERVER_INFO,pointer=ref}*(1))(2:{switch_type={}(uint32), alias=SERVER_INFO}(union))
	{
		if o.Info == nil {
			o.Info = &ServerInfo{}
		}
		_swInfo := uint32(o.Level)
		if err := o.Info.UnmarshalUnionNDR(ctx, w, _swInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetInfoRequest structure represents the NetrServerGetInfo operation request
type GetInfoRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle (see [C706] sections
	// 4.3.5 and 5.1.5.2).
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// Level: Specifies the information level of the data. The value of the Level parameter
	// determines the contents of the InfoStruct parameter. This parameter MUST be one of
	// the following values.
	//
	//	+-------+-------------------+
	//	|       |                   |
	//	| VALUE |      MEANING      |
	//	|       |                   |
	//	+-------+-------------------+
	//	+-------+-------------------+
	//	|   100 | LPSERVER_INFO_100 |
	//	+-------+-------------------+
	//	|   101 | LPSERVER_INFO_101 |
	//	+-------+-------------------+
	//	|   102 | LPSERVER_INFO_102 |
	//	+-------+-------------------+
	//	|   103 | LPSERVER_INFO_103 |
	//	+-------+-------------------+
	//	|   502 | LPSERVER_INFO_502 |
	//	+-------+-------------------+
	//	|   503 | LPSERVER_INFO_503 |
	//	+-------+-------------------+
	Level uint32 `idl:"name:Level" json:"level"`
}

func (o *GetInfoRequest) xxx_ToOp(ctx context.Context, op *xxx_GetInfoOperation) *xxx_GetInfoOperation {
	if op == nil {
		op = &xxx_GetInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.Level = o.Level
	return op
}

func (o *GetInfoRequest) xxx_FromOp(ctx context.Context, op *xxx_GetInfoOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.Level = op.Level
}
func (o *GetInfoRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetInfoRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetInfoOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetInfoResponse structure represents the NetrServerGetInfo operation response
type GetInfoResponse struct {
	// XXX: Level is an implicit input depedency for output parameters
	Level uint32 `idl:"name:Level" json:"level"`

	// InfoStruct: This is a structure of type LPSERVER_INFO, as specified in section 2.2.3.7.
	// The content of the InfoStruct parameter is determined by the Level parameter, as
	// the preceding table shows.
	Info *ServerInfo `idl:"name:InfoStruct;switch_is:Level" json:"info"`
	// Return: The NetrServerGetInfo return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetInfoResponse) xxx_ToOp(ctx context.Context, op *xxx_GetInfoOperation) *xxx_GetInfoOperation {
	if op == nil {
		op = &xxx_GetInfoOperation{}
	}
	if o == nil {
		return op
	}
	// XXX: implicit input dependencies for output parameters
	if op.Level == uint32(0) {
		op.Level = o.Level
	}

	op.Info = o.Info
	op.Return = o.Return
	return op
}

func (o *GetInfoResponse) xxx_FromOp(ctx context.Context, op *xxx_GetInfoOperation) {
	if o == nil {
		return
	}
	// XXX: implicit input dependencies for output parameters
	o.Level = op.Level

	o.Info = op.Info
	o.Return = op.Return
}
func (o *GetInfoResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetInfoResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetInfoOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetInfoOperation structure represents the NetrServerSetInfo operation
type xxx_SetInfoOperation struct {
	ServerName     string      `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	Level          uint32      `idl:"name:Level" json:"level"`
	ServerInfo     *ServerInfo `idl:"name:ServerInfo;switch_is:Level" json:"server_info"`
	ParameterError uint32      `idl:"name:ParmErr;pointer:unique" json:"parameter_error"`
	Return         uint32      `idl:"name:Return" json:"return"`
}

func (o *xxx_SetInfoOperation) OpNum() int { return 22 }

func (o *xxx_SetInfoOperation) OpName() string { return "/srvsvc/v3/NetrServerSetInfo" }

func (o *xxx_SetInfoOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetInfoOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Level); err != nil {
			return err
		}
	}
	// ServerInfo {in} (1:{switch_type={}(uint32), alias=LPSERVER_INFO}*(1))(2:{switch_type={}(uint32), alias=SERVER_INFO}(union))
	{
		_swServerInfo := uint32(o.Level)
		if o.ServerInfo != nil {
			if err := o.ServerInfo.MarshalUnionNDR(ctx, w, _swServerInfo); err != nil {
				return err
			}
		} else {
			if err := (&ServerInfo{}).MarshalUnionNDR(ctx, w, _swServerInfo); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ParmErr {in, out} (1:{pointer=unique}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ParmErr := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.ParameterError); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ParameterError, _ptr_ParmErr); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetInfoOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Level); err != nil {
			return err
		}
	}
	// ServerInfo {in} (1:{switch_type={}(uint32), alias=LPSERVER_INFO,pointer=ref}*(1))(2:{switch_type={}(uint32), alias=SERVER_INFO}(union))
	{
		if o.ServerInfo == nil {
			o.ServerInfo = &ServerInfo{}
		}
		_swServerInfo := uint32(o.Level)
		if err := o.ServerInfo.UnmarshalUnionNDR(ctx, w, _swServerInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ParmErr {in, out} (1:{pointer=unique}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ParmErr := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.ParameterError); err != nil {
				return err
			}
			return nil
		})
		_s_ParmErr := func(ptr interface{}) { o.ParameterError = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.ParameterError, _s_ParmErr, _ptr_ParmErr); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetInfoOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetInfoOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ParmErr {in, out} (1:{pointer=unique}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ParmErr := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.ParameterError); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ParameterError, _ptr_ParmErr); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetInfoOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ParmErr {in, out} (1:{pointer=unique}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ParmErr := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.ParameterError); err != nil {
				return err
			}
			return nil
		})
		_s_ParmErr := func(ptr interface{}) { o.ParameterError = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.ParameterError, _s_ParmErr, _ptr_ParmErr); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetInfoRequest structure represents the NetrServerSetInfo operation request
type SetInfoRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle (see [C706] sections
	// 4.3.5 and 5.1.5.2). The server MUST ignore this parameter.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// Level: Specifies the information level of the data. The value of the Level parameter
	// determines the contents of the ServerInfo parameter. This parameter MUST be one of
	// the values in the following table. The NetrServerSetInfo method does not support
	// a Level value of 103. If a Level value of 103 is specified, the server MUST return
	// ERROR_INVALID_LEVEL.
	//
	//	+-------+--------------------+
	//	|       |                    |
	//	| VALUE |      MEANING       |
	//	|       |                    |
	//	+-------+--------------------+
	//	+-------+--------------------+
	//	|   101 | LPSERVER_INFO_101  |
	//	+-------+--------------------+
	//	|   102 | LPSERVER_INFO_102  |
	//	+-------+--------------------+
	//	|   502 | LPSERVER_INFO_502  |
	//	+-------+--------------------+
	//	|   503 | LPSERVER_INFO_503  |
	//	+-------+--------------------+
	//	|   599 | LPSERVER_INFO_599  |
	//	+-------+--------------------+
	//	|  1005 | LPSERVER_INFO_1005 |
	//	+-------+--------------------+
	//	|  1107 | LPSERVER_INFO_1107 |
	//	+-------+--------------------+
	//	|  1010 | LPSERVER_INFO_1010 |
	//	+-------+--------------------+
	//	|  1016 | LPSERVER_INFO_1016 |
	//	+-------+--------------------+
	//	|  1017 | LPSERVER_INFO_1017 |
	//	+-------+--------------------+
	//	|  1018 | LPSERVER_INFO_1018 |
	//	+-------+--------------------+
	//	|  1501 | LPSERVER_INFO_1501 |
	//	+-------+--------------------+
	//	|  1502 | LPSERVER_INFO_1502 |
	//	+-------+--------------------+
	//	|  1503 | LPSERVER_INFO_1503 |
	//	+-------+--------------------+
	//	|  1506 | LPSERVER_INFO_1506 |
	//	+-------+--------------------+
	//	|  1510 | LPSERVER_INFO_1510 |
	//	+-------+--------------------+
	//	|  1511 | LPSERVER_INFO_1511 |
	//	+-------+--------------------+
	//	|  1512 | LPSERVER_INFO_1512 |
	//	+-------+--------------------+
	//	|  1513 | LPSERVER_INFO_1513 |
	//	+-------+--------------------+
	//	|  1514 | LPSERVER_INFO_1514 |
	//	+-------+--------------------+
	//	|  1515 | LPSERVER_INFO_1515 |
	//	+-------+--------------------+
	//	|  1516 | LPSERVER_INFO_1516 |
	//	+-------+--------------------+
	//	|  1518 | LPSERVER_INFO_1518 |
	//	+-------+--------------------+
	//	|  1523 | LPSERVER_INFO_1523 |
	//	+-------+--------------------+
	//	|  1528 | LPSERVER_INFO_1528 |
	//	+-------+--------------------+
	//	|  1529 | LPSERVER_INFO_1529 |
	//	+-------+--------------------+
	//	|  1530 | LPSERVER_INFO_1530 |
	//	+-------+--------------------+
	//	|  1533 | LPSERVER_INFO_1533 |
	//	+-------+--------------------+
	//	|  1534 | LPSERVER_INFO_1534 |
	//	+-------+--------------------+
	//	|  1535 | LPSERVER_INFO_1535 |
	//	+-------+--------------------+
	//	|  1536 | LPSERVER_INFO_1536 |
	//	+-------+--------------------+
	//	|  1538 | LPSERVER_INFO_1538 |
	//	+-------+--------------------+
	//	|  1539 | LPSERVER_INFO_1539 |
	//	+-------+--------------------+
	//	|  1540 | LPSERVER_INFO_1540 |
	//	+-------+--------------------+
	//	|  1541 | LPSERVER_INFO_1541 |
	//	+-------+--------------------+
	//	|  1542 | LPSERVER_INFO_1542 |
	//	+-------+--------------------+
	//	|  1543 | LPSERVER_INFO_1543 |
	//	+-------+--------------------+
	//	|  1544 | LPSERVER_INFO_1544 |
	//	+-------+--------------------+
	//	|  1545 | LPSERVER_INFO_1545 |
	//	+-------+--------------------+
	//	|  1546 | LPSERVER_INFO_1546 |
	//	+-------+--------------------+
	//	|  1547 | LPSERVER_INFO_1547 |
	//	+-------+--------------------+
	//	|  1548 | LPSERVER_INFO_1548 |
	//	+-------+--------------------+
	//	|  1549 | LPSERVER_INFO_1549 |
	//	+-------+--------------------+
	//	|  1550 | LPSERVER_INFO_1550 |
	//	+-------+--------------------+
	//	|  1552 | LPSERVER_INFO_1552 |
	//	+-------+--------------------+
	//	|  1553 | LPSERVER_INFO_1553 |
	//	+-------+--------------------+
	//	|  1554 | LPSERVER_INFO_1554 |
	//	+-------+--------------------+
	//	|  1555 | LPSERVER_INFO_1555 |
	//	+-------+--------------------+
	//	|  1556 | LPSERVER_INFO_1556 |
	//	+-------+--------------------+
	Level uint32 `idl:"name:Level" json:"level"`
	// ServerInfo: This is a structure of type LPSERVER_INFO, as specified in section 2.2.3.7.
	// The content of the ServerInfo parameter is determined by the Level parameter, as
	// the preceding table shows.
	ServerInfo *ServerInfo `idl:"name:ServerInfo;switch_is:Level" json:"server_info"`
	// ParmErr: A pointer to a value that receives the index of the first member of the
	// server information structure that caused an ERROR_INVALID_PARAMETER error code, if
	// it occurs.
	ParameterError uint32 `idl:"name:ParmErr;pointer:unique" json:"parameter_error"`
}

func (o *SetInfoRequest) xxx_ToOp(ctx context.Context, op *xxx_SetInfoOperation) *xxx_SetInfoOperation {
	if op == nil {
		op = &xxx_SetInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.Level = o.Level
	op.ServerInfo = o.ServerInfo
	op.ParameterError = o.ParameterError
	return op
}

func (o *SetInfoRequest) xxx_FromOp(ctx context.Context, op *xxx_SetInfoOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.Level = op.Level
	o.ServerInfo = op.ServerInfo
	o.ParameterError = op.ParameterError
}
func (o *SetInfoRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetInfoRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetInfoOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetInfoResponse structure represents the NetrServerSetInfo operation response
type SetInfoResponse struct {
	// ParmErr: A pointer to a value that receives the index of the first member of the
	// server information structure that caused an ERROR_INVALID_PARAMETER error code, if
	// it occurs.
	ParameterError uint32 `idl:"name:ParmErr;pointer:unique" json:"parameter_error"`
	// Return: The NetrServerSetInfo return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetInfoResponse) xxx_ToOp(ctx context.Context, op *xxx_SetInfoOperation) *xxx_SetInfoOperation {
	if op == nil {
		op = &xxx_SetInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.ParameterError = o.ParameterError
	op.Return = o.Return
	return op
}

func (o *SetInfoResponse) xxx_FromOp(ctx context.Context, op *xxx_SetInfoOperation) {
	if o == nil {
		return
	}
	o.ParameterError = op.ParameterError
	o.Return = op.Return
}
func (o *SetInfoResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetInfoResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetInfoOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_DiskEnumOperation structure represents the NetrServerDiskEnum operation
type xxx_DiskEnumOperation struct {
	ServerName             string             `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	Level                  uint32             `idl:"name:Level" json:"level"`
	DiskInfo               *DiskEnumContainer `idl:"name:DiskInfoStruct" json:"disk_info"`
	PreferredMaximumLength uint32             `idl:"name:PreferedMaximumLength" json:"preferred_maximum_length"`
	TotalEntries           uint32             `idl:"name:TotalEntries" json:"total_entries"`
	Resume                 uint32             `idl:"name:ResumeHandle;pointer:unique" json:"resume"`
	Return                 uint32             `idl:"name:Return" json:"return"`
}

func (o *xxx_DiskEnumOperation) OpNum() int { return 23 }

func (o *xxx_DiskEnumOperation) OpName() string { return "/srvsvc/v3/NetrServerDiskEnum" }

func (o *xxx_DiskEnumOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DiskEnumOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Level); err != nil {
			return err
		}
	}
	// DiskInfoStruct {in, out} (1:{pointer=ref}*(1))(2:{alias=DISK_ENUM_CONTAINER}(struct))
	{
		if o.DiskInfo != nil {
			if err := o.DiskInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DiskEnumContainer{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// PreferedMaximumLength {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PreferredMaximumLength); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=unique}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ResumeHandle := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.Resume); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Resume, _ptr_ResumeHandle); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DiskEnumOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Level); err != nil {
			return err
		}
	}
	// DiskInfoStruct {in, out} (1:{pointer=ref}*(1))(2:{alias=DISK_ENUM_CONTAINER}(struct))
	{
		if o.DiskInfo == nil {
			o.DiskInfo = &DiskEnumContainer{}
		}
		if err := o.DiskInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// PreferedMaximumLength {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PreferredMaximumLength); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=unique}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ResumeHandle := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.Resume); err != nil {
				return err
			}
			return nil
		})
		_s_ResumeHandle := func(ptr interface{}) { o.Resume = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.Resume, _s_ResumeHandle, _ptr_ResumeHandle); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DiskEnumOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DiskEnumOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// DiskInfoStruct {in, out} (1:{pointer=ref}*(1))(2:{alias=DISK_ENUM_CONTAINER}(struct))
	{
		if o.DiskInfo != nil {
			if err := o.DiskInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DiskEnumContainer{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// TotalEntries {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.TotalEntries); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=unique}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ResumeHandle := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.Resume); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Resume, _ptr_ResumeHandle); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DiskEnumOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// DiskInfoStruct {in, out} (1:{pointer=ref}*(1))(2:{alias=DISK_ENUM_CONTAINER}(struct))
	{
		if o.DiskInfo == nil {
			o.DiskInfo = &DiskEnumContainer{}
		}
		if err := o.DiskInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// TotalEntries {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.TotalEntries); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=unique}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ResumeHandle := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.Resume); err != nil {
				return err
			}
			return nil
		})
		_s_ResumeHandle := func(ptr interface{}) { o.Resume = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.Resume, _s_ResumeHandle, _ptr_ResumeHandle); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// DiskEnumRequest structure represents the NetrServerDiskEnum operation request
type DiskEnumRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle (see [C706] sections
	// 4.3.5 and 5.1.5.2). The server MUST ignore this parameter.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// Level: Specifies the information level of the data. It MUST be the following value.
	//
	//	+-------+----------------------------------+
	//	|       |                                  |
	//	| VALUE |             MEANING              |
	//	|       |                                  |
	//	+-------+----------------------------------+
	//	+-------+----------------------------------+
	//	|     0 | The buffer is of type DISK_INFO. |
	//	+-------+----------------------------------+
	Level uint32 `idl:"name:Level" json:"level"`
	// DiskInfoStruct: A pointer to a structure of type DISK_ENUM_CONTAINER, as specified
	// in section 2.2.4.92. Although this parameter is defined as an [in, out] parameter,
	// it is used only as an [out] parameter. The server MUST ignore any values that are
	// passed in this parameter.
	DiskInfo *DiskEnumContainer `idl:"name:DiskInfoStruct" json:"disk_info"`
	// PreferedMaximumLength: The server MUST ignore this parameter.
	PreferredMaximumLength uint32 `idl:"name:PreferedMaximumLength" json:"preferred_maximum_length"`
	// ResumeHandle: The server MUST ignore this parameter.
	Resume uint32 `idl:"name:ResumeHandle;pointer:unique" json:"resume"`
}

func (o *DiskEnumRequest) xxx_ToOp(ctx context.Context, op *xxx_DiskEnumOperation) *xxx_DiskEnumOperation {
	if op == nil {
		op = &xxx_DiskEnumOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.Level = o.Level
	op.DiskInfo = o.DiskInfo
	op.PreferredMaximumLength = o.PreferredMaximumLength
	op.Resume = o.Resume
	return op
}

func (o *DiskEnumRequest) xxx_FromOp(ctx context.Context, op *xxx_DiskEnumOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.Level = op.Level
	o.DiskInfo = op.DiskInfo
	o.PreferredMaximumLength = op.PreferredMaximumLength
	o.Resume = op.Resume
}
func (o *DiskEnumRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *DiskEnumRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DiskEnumOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// DiskEnumResponse structure represents the NetrServerDiskEnum operation response
type DiskEnumResponse struct {
	// DiskInfoStruct: A pointer to a structure of type DISK_ENUM_CONTAINER, as specified
	// in section 2.2.4.92. Although this parameter is defined as an [in, out] parameter,
	// it is used only as an [out] parameter. The server MUST ignore any values that are
	// passed in this parameter.
	DiskInfo *DiskEnumContainer `idl:"name:DiskInfoStruct" json:"disk_info"`
	// TotalEntries: The number of entries being returned in the Buffer member of the DiskInfoStruct
	// parameter. This MUST be in the range 0–26.
	TotalEntries uint32 `idl:"name:TotalEntries" json:"total_entries"`
	// ResumeHandle: The server MUST ignore this parameter.
	Resume uint32 `idl:"name:ResumeHandle;pointer:unique" json:"resume"`
	// Return: The NetrServerDiskEnum return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *DiskEnumResponse) xxx_ToOp(ctx context.Context, op *xxx_DiskEnumOperation) *xxx_DiskEnumOperation {
	if op == nil {
		op = &xxx_DiskEnumOperation{}
	}
	if o == nil {
		return op
	}
	op.DiskInfo = o.DiskInfo
	op.TotalEntries = o.TotalEntries
	op.Resume = o.Resume
	op.Return = o.Return
	return op
}

func (o *DiskEnumResponse) xxx_FromOp(ctx context.Context, op *xxx_DiskEnumOperation) {
	if o == nil {
		return
	}
	o.DiskInfo = op.DiskInfo
	o.TotalEntries = op.TotalEntries
	o.Resume = op.Resume
	o.Return = op.Return
}
func (o *DiskEnumResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *DiskEnumResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DiskEnumOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_StatisticsGetOperation structure represents the NetrServerStatisticsGet operation
type xxx_StatisticsGetOperation struct {
	ServerName string       `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	Service    string       `idl:"name:Service;string;pointer:unique" json:"service"`
	Level      uint32       `idl:"name:Level" json:"level"`
	Options    uint32       `idl:"name:Options" json:"options"`
	Info       *StatServer0 `idl:"name:InfoStruct" json:"info"`
	Return     uint32       `idl:"name:Return" json:"return"`
}

func (o *xxx_StatisticsGetOperation) OpNum() int { return 24 }

func (o *xxx_StatisticsGetOperation) OpName() string { return "/srvsvc/v3/NetrServerStatisticsGet" }

func (o *xxx_StatisticsGetOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StatisticsGetOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Service {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.Service != "" {
			_ptr_Service := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.Service); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.Service, _ptr_Service); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Level); err != nil {
			return err
		}
	}
	// Options {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Options); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StatisticsGetOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Service {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_Service := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.Service); err != nil {
				return err
			}
			return nil
		})
		_s_Service := func(ptr interface{}) { o.Service = *ptr.(*string) }
		if err := w.ReadPointer(&o.Service, _s_Service, _ptr_Service); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Level); err != nil {
			return err
		}
	}
	// Options {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Options); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StatisticsGetOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StatisticsGetOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// InfoStruct {out} (1:{pointer=ref}*(2))(2:{alias=LPSTAT_SERVER_0}*(1))(3:{alias=STAT_SERVER_0}(struct))
	{
		if o.Info != nil {
			_ptr_InfoStruct := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Info != nil {
					if err := o.Info.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&StatServer0{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Info, _ptr_InfoStruct); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StatisticsGetOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// InfoStruct {out} (1:{pointer=ref}*(2))(2:{alias=LPSTAT_SERVER_0,pointer=ref}*(1))(3:{alias=STAT_SERVER_0}(struct))
	{
		_ptr_InfoStruct := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Info == nil {
				o.Info = &StatServer0{}
			}
			if err := o.Info.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_InfoStruct := func(ptr interface{}) { o.Info = *ptr.(**StatServer0) }
		if err := w.ReadPointer(&o.Info, _s_InfoStruct, _ptr_InfoStruct); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// StatisticsGetRequest structure represents the NetrServerStatisticsGet operation request
type StatisticsGetRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle (see [C706] sections
	// 4.3.5 and 5.1.5.2). The server MUST ignore this parameter.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// Service: A pointer to a null-terminated UTF-16 string. This parameter MUST be ignored
	// on receipt.
	Service string `idl:"name:Service;string;pointer:unique" json:"service"`
	// Level: Specifies the information level of the data. This MUST be set to 0.
	Level uint32 `idl:"name:Level" json:"level"`
	// Options: Reserved; MUST be 0.
	Options uint32 `idl:"name:Options" json:"options"`
}

func (o *StatisticsGetRequest) xxx_ToOp(ctx context.Context, op *xxx_StatisticsGetOperation) *xxx_StatisticsGetOperation {
	if op == nil {
		op = &xxx_StatisticsGetOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.Service = o.Service
	op.Level = o.Level
	op.Options = o.Options
	return op
}

func (o *StatisticsGetRequest) xxx_FromOp(ctx context.Context, op *xxx_StatisticsGetOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.Service = op.Service
	o.Level = op.Level
	o.Options = op.Options
}
func (o *StatisticsGetRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *StatisticsGetRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_StatisticsGetOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// StatisticsGetResponse structure represents the NetrServerStatisticsGet operation response
type StatisticsGetResponse struct {
	// InfoStruct: A pointer to the buffer that receives the data, as specified in section
	// 2.2.4.39. This pointer is in the format of STAT_SERVER_0.
	Info *StatServer0 `idl:"name:InfoStruct" json:"info"`
	// Return: The NetrServerStatisticsGet return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *StatisticsGetResponse) xxx_ToOp(ctx context.Context, op *xxx_StatisticsGetOperation) *xxx_StatisticsGetOperation {
	if op == nil {
		op = &xxx_StatisticsGetOperation{}
	}
	if o == nil {
		return op
	}
	op.Info = o.Info
	op.Return = o.Return
	return op
}

func (o *StatisticsGetResponse) xxx_FromOp(ctx context.Context, op *xxx_StatisticsGetOperation) {
	if o == nil {
		return
	}
	o.Info = op.Info
	o.Return = op.Return
}
func (o *StatisticsGetResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *StatisticsGetResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_StatisticsGetOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_TransportAddOperation structure represents the NetrServerTransportAdd operation
type xxx_TransportAddOperation struct {
	ServerName string                `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	Level      uint32                `idl:"name:Level" json:"level"`
	Buffer     *ServerTransportInfo0 `idl:"name:Buffer" json:"buffer"`
	Return     uint32                `idl:"name:Return" json:"return"`
}

func (o *xxx_TransportAddOperation) OpNum() int { return 25 }

func (o *xxx_TransportAddOperation) OpName() string { return "/srvsvc/v3/NetrServerTransportAdd" }

func (o *xxx_TransportAddOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_TransportAddOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Level); err != nil {
			return err
		}
	}
	// Buffer {in} (1:{alias=LPSERVER_TRANSPORT_INFO_0}*(1))(2:{alias=SERVER_TRANSPORT_INFO_0}(struct))
	{
		if o.Buffer != nil {
			if err := o.Buffer.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerTransportInfo0{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_TransportAddOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Level); err != nil {
			return err
		}
	}
	// Buffer {in} (1:{alias=LPSERVER_TRANSPORT_INFO_0,pointer=ref}*(1))(2:{alias=SERVER_TRANSPORT_INFO_0}(struct))
	{
		if o.Buffer == nil {
			o.Buffer = &ServerTransportInfo0{}
		}
		if err := o.Buffer.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_TransportAddOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_TransportAddOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_TransportAddOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// TransportAddRequest structure represents the NetrServerTransportAdd operation request
type TransportAddRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle (see [C706] sections
	// 4.3.5 and 5.1.5.2). The server MUST ignore this parameter.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// Level: Specifies the information level of the data. This parameter MUST be zero.
	Level uint32 `idl:"name:Level" json:"level"`
	// Buffer: A pointer to the SERVER_TRANSPORT_INFO_0 structure that describes the data.
	Buffer *ServerTransportInfo0 `idl:"name:Buffer" json:"buffer"`
}

func (o *TransportAddRequest) xxx_ToOp(ctx context.Context, op *xxx_TransportAddOperation) *xxx_TransportAddOperation {
	if op == nil {
		op = &xxx_TransportAddOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.Level = o.Level
	op.Buffer = o.Buffer
	return op
}

func (o *TransportAddRequest) xxx_FromOp(ctx context.Context, op *xxx_TransportAddOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.Level = op.Level
	o.Buffer = op.Buffer
}
func (o *TransportAddRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *TransportAddRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_TransportAddOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// TransportAddResponse structure represents the NetrServerTransportAdd operation response
type TransportAddResponse struct {
	// Return: The NetrServerTransportAdd return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *TransportAddResponse) xxx_ToOp(ctx context.Context, op *xxx_TransportAddOperation) *xxx_TransportAddOperation {
	if op == nil {
		op = &xxx_TransportAddOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *TransportAddResponse) xxx_FromOp(ctx context.Context, op *xxx_TransportAddOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *TransportAddResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *TransportAddResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_TransportAddOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_TransportEnumOperation structure represents the NetrServerTransportEnum operation
type xxx_TransportEnumOperation struct {
	ServerName             string           `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	Info                   *ServerXportEnum `idl:"name:InfoStruct" json:"info"`
	PreferredMaximumLength uint32           `idl:"name:PreferedMaximumLength" json:"preferred_maximum_length"`
	TotalEntries           uint32           `idl:"name:TotalEntries" json:"total_entries"`
	Resume                 uint32           `idl:"name:ResumeHandle;pointer:unique" json:"resume"`
	Return                 uint32           `idl:"name:Return" json:"return"`
}

func (o *xxx_TransportEnumOperation) OpNum() int { return 26 }

func (o *xxx_TransportEnumOperation) OpName() string { return "/srvsvc/v3/NetrServerTransportEnum" }

func (o *xxx_TransportEnumOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_TransportEnumOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// InfoStruct {in, out} (1:{alias=LPSERVER_XPORT_ENUM_STRUCT}*(1))(2:{alias=SERVER_XPORT_ENUM_STRUCT}(struct))
	{
		if o.Info != nil {
			if err := o.Info.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerXportEnum{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// PreferedMaximumLength {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PreferredMaximumLength); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=unique}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ResumeHandle := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.Resume); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Resume, _ptr_ResumeHandle); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_TransportEnumOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// InfoStruct {in, out} (1:{alias=LPSERVER_XPORT_ENUM_STRUCT,pointer=ref}*(1))(2:{alias=SERVER_XPORT_ENUM_STRUCT}(struct))
	{
		if o.Info == nil {
			o.Info = &ServerXportEnum{}
		}
		if err := o.Info.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// PreferedMaximumLength {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PreferredMaximumLength); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=unique}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ResumeHandle := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.Resume); err != nil {
				return err
			}
			return nil
		})
		_s_ResumeHandle := func(ptr interface{}) { o.Resume = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.Resume, _s_ResumeHandle, _ptr_ResumeHandle); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_TransportEnumOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_TransportEnumOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// InfoStruct {in, out} (1:{alias=LPSERVER_XPORT_ENUM_STRUCT}*(1))(2:{alias=SERVER_XPORT_ENUM_STRUCT}(struct))
	{
		if o.Info != nil {
			if err := o.Info.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerXportEnum{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// TotalEntries {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.TotalEntries); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=unique}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ResumeHandle := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.Resume); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Resume, _ptr_ResumeHandle); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_TransportEnumOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// InfoStruct {in, out} (1:{alias=LPSERVER_XPORT_ENUM_STRUCT,pointer=ref}*(1))(2:{alias=SERVER_XPORT_ENUM_STRUCT}(struct))
	{
		if o.Info == nil {
			o.Info = &ServerXportEnum{}
		}
		if err := o.Info.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// TotalEntries {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.TotalEntries); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=unique}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ResumeHandle := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.Resume); err != nil {
				return err
			}
			return nil
		})
		_s_ResumeHandle := func(ptr interface{}) { o.Resume = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.Resume, _s_ResumeHandle, _ptr_ResumeHandle); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// TransportEnumRequest structure represents the NetrServerTransportEnum operation request
type TransportEnumRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle (see [C706] sections
	// 4.3.5 and 5.1.5.2). The server MUST ignore this parameter.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// InfoStruct: A pointer to a structure, in the format of a SERVER_XPORT_ENUM_STRUCT
	// structure that receives the data. The SERVER_XPORT_ENUM_STRUCT structure has a Level
	// member that specifies the type of the structure to return in the XportInfo member.
	// The Level member MUST be set to one of the values in section 2.2.4.101 (excluding
	// SERVER_XPORT_INFO_3_CONTAINER).
	Info *ServerXportEnum `idl:"name:InfoStruct" json:"info"`
	// PreferedMaximumLength: Specifies the preferred maximum length, in bytes, of returned
	// data. If the value that is specified is MAX_PREFERRED_LENGTH (section 2.2.2.2), the
	// method MUST attempt to return all entries.
	PreferredMaximumLength uint32 `idl:"name:PreferedMaximumLength" json:"preferred_maximum_length"`
	// ResumeHandle: A pointer to a value that contains a handle that is used to continue
	// an existing connection search. The handle MUST be zero on the first call and remain
	// unchanged for subsequent calls. If the ResumeHandle parameter is NULL, no resume
	// handle MUST be stored. If this parameter is not NULL and the method returns ERROR_MORE_DATA,
	// this parameter receives an implementation-specific nonzero value that can be passed
	// in subsequent calls to this method to continue with the enumeration.
	Resume uint32 `idl:"name:ResumeHandle;pointer:unique" json:"resume"`
}

func (o *TransportEnumRequest) xxx_ToOp(ctx context.Context, op *xxx_TransportEnumOperation) *xxx_TransportEnumOperation {
	if op == nil {
		op = &xxx_TransportEnumOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.Info = o.Info
	op.PreferredMaximumLength = o.PreferredMaximumLength
	op.Resume = o.Resume
	return op
}

func (o *TransportEnumRequest) xxx_FromOp(ctx context.Context, op *xxx_TransportEnumOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.Info = op.Info
	o.PreferredMaximumLength = op.PreferredMaximumLength
	o.Resume = op.Resume
}
func (o *TransportEnumRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *TransportEnumRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_TransportEnumOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// TransportEnumResponse structure represents the NetrServerTransportEnum operation response
type TransportEnumResponse struct {
	// InfoStruct: A pointer to a structure, in the format of a SERVER_XPORT_ENUM_STRUCT
	// structure that receives the data. The SERVER_XPORT_ENUM_STRUCT structure has a Level
	// member that specifies the type of the structure to return in the XportInfo member.
	// The Level member MUST be set to one of the values in section 2.2.4.101 (excluding
	// SERVER_XPORT_INFO_3_CONTAINER).
	Info *ServerXportEnum `idl:"name:InfoStruct" json:"info"`
	// TotalEntries: The total number of entries that can be enumerated if the buffer is
	// large enough to hold all the entries.
	TotalEntries uint32 `idl:"name:TotalEntries" json:"total_entries"`
	// ResumeHandle: A pointer to a value that contains a handle that is used to continue
	// an existing connection search. The handle MUST be zero on the first call and remain
	// unchanged for subsequent calls. If the ResumeHandle parameter is NULL, no resume
	// handle MUST be stored. If this parameter is not NULL and the method returns ERROR_MORE_DATA,
	// this parameter receives an implementation-specific nonzero value that can be passed
	// in subsequent calls to this method to continue with the enumeration.
	Resume uint32 `idl:"name:ResumeHandle;pointer:unique" json:"resume"`
	// Return: The NetrServerTransportEnum return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *TransportEnumResponse) xxx_ToOp(ctx context.Context, op *xxx_TransportEnumOperation) *xxx_TransportEnumOperation {
	if op == nil {
		op = &xxx_TransportEnumOperation{}
	}
	if o == nil {
		return op
	}
	op.Info = o.Info
	op.TotalEntries = o.TotalEntries
	op.Resume = o.Resume
	op.Return = o.Return
	return op
}

func (o *TransportEnumResponse) xxx_FromOp(ctx context.Context, op *xxx_TransportEnumOperation) {
	if o == nil {
		return
	}
	o.Info = op.Info
	o.TotalEntries = op.TotalEntries
	o.Resume = op.Resume
	o.Return = op.Return
}
func (o *TransportEnumResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *TransportEnumResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_TransportEnumOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_TransportDeleteOperation structure represents the NetrServerTransportDel operation
type xxx_TransportDeleteOperation struct {
	ServerName string                `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	Level      uint32                `idl:"name:Level" json:"level"`
	Buffer     *ServerTransportInfo0 `idl:"name:Buffer" json:"buffer"`
	Return     uint32                `idl:"name:Return" json:"return"`
}

func (o *xxx_TransportDeleteOperation) OpNum() int { return 27 }

func (o *xxx_TransportDeleteOperation) OpName() string { return "/srvsvc/v3/NetrServerTransportDel" }

func (o *xxx_TransportDeleteOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_TransportDeleteOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Level); err != nil {
			return err
		}
	}
	// Buffer {in} (1:{alias=LPSERVER_TRANSPORT_INFO_0}*(1))(2:{alias=SERVER_TRANSPORT_INFO_0}(struct))
	{
		if o.Buffer != nil {
			if err := o.Buffer.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerTransportInfo0{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_TransportDeleteOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Level); err != nil {
			return err
		}
	}
	// Buffer {in} (1:{alias=LPSERVER_TRANSPORT_INFO_0,pointer=ref}*(1))(2:{alias=SERVER_TRANSPORT_INFO_0}(struct))
	{
		if o.Buffer == nil {
			o.Buffer = &ServerTransportInfo0{}
		}
		if err := o.Buffer.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_TransportDeleteOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_TransportDeleteOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_TransportDeleteOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// TransportDeleteRequest structure represents the NetrServerTransportDel operation request
type TransportDeleteRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle (see [C706] sections
	// 4.3.5 and 5.1.5.2). The server MUST ignore this parameter.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// Level: Specifies the information level of the data. This SHOULD be zero and MUST
	// be ignored on receipt.
	//
	//	+-------+------------------------------------------------+
	//	|       |                                                |
	//	| VALUE |                    MEANING                     |
	//	|       |                                                |
	//	+-------+------------------------------------------------+
	//	+-------+------------------------------------------------+
	//	|     0 | The buffer is of type SERVER_TRANSPORT_INFO_0. |
	//	+-------+------------------------------------------------+
	Level uint32 `idl:"name:Level" json:"level"`
	// Buffer: A pointer to the SERVER_TRANSPORT_INFO_0 structure that contains information
	// about the transport.
	Buffer *ServerTransportInfo0 `idl:"name:Buffer" json:"buffer"`
}

func (o *TransportDeleteRequest) xxx_ToOp(ctx context.Context, op *xxx_TransportDeleteOperation) *xxx_TransportDeleteOperation {
	if op == nil {
		op = &xxx_TransportDeleteOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.Level = o.Level
	op.Buffer = o.Buffer
	return op
}

func (o *TransportDeleteRequest) xxx_FromOp(ctx context.Context, op *xxx_TransportDeleteOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.Level = op.Level
	o.Buffer = op.Buffer
}
func (o *TransportDeleteRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *TransportDeleteRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_TransportDeleteOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// TransportDeleteResponse structure represents the NetrServerTransportDel operation response
type TransportDeleteResponse struct {
	// Return: The NetrServerTransportDel return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *TransportDeleteResponse) xxx_ToOp(ctx context.Context, op *xxx_TransportDeleteOperation) *xxx_TransportDeleteOperation {
	if op == nil {
		op = &xxx_TransportDeleteOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *TransportDeleteResponse) xxx_FromOp(ctx context.Context, op *xxx_TransportDeleteOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *TransportDeleteResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *TransportDeleteResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_TransportDeleteOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_RemoteToDOperation structure represents the NetrRemoteTOD operation
type xxx_RemoteToDOperation struct {
	ServerName    string         `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	BufferPointer *TimeOfDayInfo `idl:"name:BufferPtr" json:"buffer_pointer"`
	Return        uint32         `idl:"name:Return" json:"return"`
}

func (o *xxx_RemoteToDOperation) OpNum() int { return 28 }

func (o *xxx_RemoteToDOperation) OpName() string { return "/srvsvc/v3/NetrRemoteTOD" }

func (o *xxx_RemoteToDOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoteToDOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoteToDOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoteToDOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoteToDOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// BufferPtr {out} (1:{pointer=ref}*(2))(2:{alias=LPTIME_OF_DAY_INFO}*(1))(3:{alias=TIME_OF_DAY_INFO}(struct))
	{
		if o.BufferPointer != nil {
			_ptr_BufferPtr := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.BufferPointer != nil {
					if err := o.BufferPointer.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&TimeOfDayInfo{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.BufferPointer, _ptr_BufferPtr); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoteToDOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// BufferPtr {out} (1:{pointer=ref}*(2))(2:{alias=LPTIME_OF_DAY_INFO,pointer=ref}*(1))(3:{alias=TIME_OF_DAY_INFO}(struct))
	{
		_ptr_BufferPtr := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.BufferPointer == nil {
				o.BufferPointer = &TimeOfDayInfo{}
			}
			if err := o.BufferPointer.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_BufferPtr := func(ptr interface{}) { o.BufferPointer = *ptr.(**TimeOfDayInfo) }
		if err := w.ReadPointer(&o.BufferPointer, _s_BufferPtr, _ptr_BufferPtr); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// RemoteToDRequest structure represents the NetrRemoteTOD operation request
type RemoteToDRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle (see [C706] sections
	// 4.3.5 and 5.1.5.2). The server MUST ignore this parameter.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
}

func (o *RemoteToDRequest) xxx_ToOp(ctx context.Context, op *xxx_RemoteToDOperation) *xxx_RemoteToDOperation {
	if op == nil {
		op = &xxx_RemoteToDOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	return op
}

func (o *RemoteToDRequest) xxx_FromOp(ctx context.Context, op *xxx_RemoteToDOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
}
func (o *RemoteToDRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *RemoteToDRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemoteToDOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// RemoteToDResponse structure represents the NetrRemoteTOD operation response
type RemoteToDResponse struct {
	// BufferPtr: A pointer to a structure of type TIME_OF_DAY_INFO where the information
	// is returned.
	BufferPointer *TimeOfDayInfo `idl:"name:BufferPtr" json:"buffer_pointer"`
	// Return: The NetrRemoteTOD return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *RemoteToDResponse) xxx_ToOp(ctx context.Context, op *xxx_RemoteToDOperation) *xxx_RemoteToDOperation {
	if op == nil {
		op = &xxx_RemoteToDOperation{}
	}
	if o == nil {
		return op
	}
	op.BufferPointer = o.BufferPointer
	op.Return = o.Return
	return op
}

func (o *RemoteToDResponse) xxx_FromOp(ctx context.Context, op *xxx_RemoteToDOperation) {
	if o == nil {
		return
	}
	o.BufferPointer = op.BufferPointer
	o.Return = op.Return
}
func (o *RemoteToDResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *RemoteToDResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemoteToDOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_PathTypeOperation structure represents the NetprPathType operation
type xxx_PathTypeOperation struct {
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	PathName   string `idl:"name:PathName;string" json:"path_name"`
	PathType   uint32 `idl:"name:PathType" json:"path_type"`
	Flags      uint32 `idl:"name:Flags" json:"flags"`
	Return     uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_PathTypeOperation) OpNum() int { return 30 }

func (o *xxx_PathTypeOperation) OpName() string { return "/srvsvc/v3/NetprPathType" }

func (o *xxx_PathTypeOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_PathTypeOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// PathName {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.PathName); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_PathTypeOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// PathName {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.PathName); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_PathTypeOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_PathTypeOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// PathType {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PathType); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_PathTypeOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// PathType {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PathType); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// PathTypeRequest structure represents the NetprPathType operation request
type PathTypeRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle (see [C706] sections
	// 4.3.5 and 5.1.5.2). The server MUST ignore this parameter.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// PathName: A pointer to a null-terminated UTF-16 string that specifies the path name
	// to check.
	PathName string `idl:"name:PathName;string" json:"path_name"`
	// Flags: A bitmask that MUST contain the bitwise OR of zero or more of the following
	// values specifying controlling flags.
	//
	//	+------------+----------------------------------------------------------------------------------+
	//	|            |                                                                                  |
	//	|   VALUE    |                                     MEANING                                      |
	//	|            |                                                                                  |
	//	+------------+----------------------------------------------------------------------------------+
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00000001 | If set, the method uses old-style path rules (128-byte paths, 8.3 components)    |
	//	|            | when validating the path. This flag is set on MS-DOS and OS/2 1.1 systems.       |
	//	+------------+----------------------------------------------------------------------------------+
	Flags uint32 `idl:"name:Flags" json:"flags"`
}

func (o *PathTypeRequest) xxx_ToOp(ctx context.Context, op *xxx_PathTypeOperation) *xxx_PathTypeOperation {
	if op == nil {
		op = &xxx_PathTypeOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.PathName = o.PathName
	op.Flags = o.Flags
	return op
}

func (o *PathTypeRequest) xxx_FromOp(ctx context.Context, op *xxx_PathTypeOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.PathName = op.PathName
	o.Flags = op.Flags
}
func (o *PathTypeRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *PathTypeRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_PathTypeOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// PathTypeResponse structure represents the NetprPathType operation response
type PathTypeResponse struct {
	// PathType: A path type is returned. It MUST be one of the values that are defined
	// in section 2.2.2.9.
	PathType uint32 `idl:"name:PathType" json:"path_type"`
	// Return: The NetprPathType return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *PathTypeResponse) xxx_ToOp(ctx context.Context, op *xxx_PathTypeOperation) *xxx_PathTypeOperation {
	if op == nil {
		op = &xxx_PathTypeOperation{}
	}
	if o == nil {
		return op
	}
	op.PathType = o.PathType
	op.Return = o.Return
	return op
}

func (o *PathTypeResponse) xxx_FromOp(ctx context.Context, op *xxx_PathTypeOperation) {
	if o == nil {
		return
	}
	o.PathType = op.PathType
	o.Return = op.Return
}
func (o *PathTypeResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *PathTypeResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_PathTypeOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_PathCanonicalizeOperation structure represents the NetprPathCanonicalize operation
type xxx_PathCanonicalizeOperation struct {
	ServerName         string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	PathName           string `idl:"name:PathName;string" json:"path_name"`
	OutputBuffer       []byte `idl:"name:Outbuf;size_is:(OutbufLen)" json:"output_buffer"`
	OutputBufferLength uint32 `idl:"name:OutbufLen" json:"output_buffer_length"`
	Prefix             string `idl:"name:Prefix;string" json:"prefix"`
	PathType           uint32 `idl:"name:PathType" json:"path_type"`
	Flags              uint32 `idl:"name:Flags" json:"flags"`
	Return             uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_PathCanonicalizeOperation) OpNum() int { return 31 }

func (o *xxx_PathCanonicalizeOperation) OpName() string { return "/srvsvc/v3/NetprPathCanonicalize" }

func (o *xxx_PathCanonicalizeOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.OutputBufferLength > uint32(64000) {
		return fmt.Errorf("OutputBufferLength is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_PathCanonicalizeOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// PathName {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.PathName); err != nil {
			return err
		}
	}
	// OutbufLen {in} (1:{range=(0,64000), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutputBufferLength); err != nil {
			return err
		}
	}
	// Prefix {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.Prefix); err != nil {
			return err
		}
	}
	// PathType {in, out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PathType); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_PathCanonicalizeOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// PathName {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.PathName); err != nil {
			return err
		}
	}
	// OutbufLen {in} (1:{range=(0,64000), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutputBufferLength); err != nil {
			return err
		}
	}
	// Prefix {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.Prefix); err != nil {
			return err
		}
	}
	// PathType {in, out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PathType); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_PathCanonicalizeOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_PathCanonicalizeOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Outbuf {out} (1:{pointer=ref}*(1)[dim:0,size_is=OutbufLen](uchar))
	{
		dimSize1 := uint64(o.OutputBufferLength)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.OutputBuffer {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.OutputBuffer[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.OutputBuffer); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// PathType {in, out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PathType); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_PathCanonicalizeOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Outbuf {out} (1:{pointer=ref}*(1)[dim:0,size_is=OutbufLen](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.OutputBuffer", sizeInfo[0])
		}
		o.OutputBuffer = make([]byte, sizeInfo[0])
		for i1 := range o.OutputBuffer {
			i1 := i1
			if err := w.ReadData(&o.OutputBuffer[i1]); err != nil {
				return err
			}
		}
	}
	// PathType {in, out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PathType); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// PathCanonicalizeRequest structure represents the NetprPathCanonicalize operation request
type PathCanonicalizeRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle (see [C706] sections
	// 4.3.5 and 5.1.5.2). The server MUST ignore this parameter.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// PathName: A pointer to a null-terminated UTF-16 string that specifies the path name
	// to canonicalize.
	PathName string `idl:"name:PathName;string" json:"path_name"`
	// OutbufLen: The length, in bytes, of the output buffer, Outbuf. The value of this
	// field MUST be within the range 0–64,000, inclusive.
	OutputBufferLength uint32 `idl:"name:OutbufLen" json:"output_buffer_length"`
	// Prefix: A pointer to a null-terminated UTF-16 string that specifies an optional prefix
	// to use when canonicalizing a relative path name.
	Prefix string `idl:"name:Prefix;string" json:"prefix"`
	// PathType: A place to store the path type. This parameter MUST be set by the client
	// either to zero or to one of the values defined in section 2.2.2.9. After successful
	// completion of the request, the server MUST set PathType to one of the values defined
	// in section 2.2.2.9.
	PathType uint32 `idl:"name:PathType" json:"path_type"`
	// Flags: Reserved, MUST be zero.
	Flags uint32 `idl:"name:Flags" json:"flags"`
}

func (o *PathCanonicalizeRequest) xxx_ToOp(ctx context.Context, op *xxx_PathCanonicalizeOperation) *xxx_PathCanonicalizeOperation {
	if op == nil {
		op = &xxx_PathCanonicalizeOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.PathName = o.PathName
	op.OutputBufferLength = o.OutputBufferLength
	op.Prefix = o.Prefix
	op.PathType = o.PathType
	op.Flags = o.Flags
	return op
}

func (o *PathCanonicalizeRequest) xxx_FromOp(ctx context.Context, op *xxx_PathCanonicalizeOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.PathName = op.PathName
	o.OutputBufferLength = op.OutputBufferLength
	o.Prefix = op.Prefix
	o.PathType = op.PathType
	o.Flags = op.Flags
}
func (o *PathCanonicalizeRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *PathCanonicalizeRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_PathCanonicalizeOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// PathCanonicalizeResponse structure represents the NetprPathCanonicalize operation response
type PathCanonicalizeResponse struct {
	// XXX: OutbufLen is an implicit input depedency for output parameters
	OutputBufferLength uint32 `idl:"name:OutbufLen" json:"output_buffer_length"`

	// Outbuf: A pointer to the output buffer where the canonicalized path name is returned.
	OutputBuffer []byte `idl:"name:Outbuf;size_is:(OutbufLen)" json:"output_buffer"`
	// PathType: A place to store the path type. This parameter MUST be set by the client
	// either to zero or to one of the values defined in section 2.2.2.9. After successful
	// completion of the request, the server MUST set PathType to one of the values defined
	// in section 2.2.2.9.
	PathType uint32 `idl:"name:PathType" json:"path_type"`
	// Return: The NetprPathCanonicalize return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *PathCanonicalizeResponse) xxx_ToOp(ctx context.Context, op *xxx_PathCanonicalizeOperation) *xxx_PathCanonicalizeOperation {
	if op == nil {
		op = &xxx_PathCanonicalizeOperation{}
	}
	if o == nil {
		return op
	}
	// XXX: implicit input dependencies for output parameters
	if op.OutputBufferLength == uint32(0) {
		op.OutputBufferLength = o.OutputBufferLength
	}

	op.OutputBuffer = o.OutputBuffer
	op.PathType = o.PathType
	op.Return = o.Return
	return op
}

func (o *PathCanonicalizeResponse) xxx_FromOp(ctx context.Context, op *xxx_PathCanonicalizeOperation) {
	if o == nil {
		return
	}
	// XXX: implicit input dependencies for output parameters
	o.OutputBufferLength = op.OutputBufferLength

	o.OutputBuffer = op.OutputBuffer
	o.PathType = op.PathType
	o.Return = op.Return
}
func (o *PathCanonicalizeResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *PathCanonicalizeResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_PathCanonicalizeOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_PathCompareOperation structure represents the NetprPathCompare operation
type xxx_PathCompareOperation struct {
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	PathName1  string `idl:"name:PathName1;string" json:"path_name1"`
	PathName2  string `idl:"name:PathName2;string" json:"path_name2"`
	PathType   uint32 `idl:"name:PathType" json:"path_type"`
	Flags      uint32 `idl:"name:Flags" json:"flags"`
	Return     int32  `idl:"name:Return" json:"return"`
}

func (o *xxx_PathCompareOperation) OpNum() int { return 32 }

func (o *xxx_PathCompareOperation) OpName() string { return "/srvsvc/v3/NetprPathCompare" }

func (o *xxx_PathCompareOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_PathCompareOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// PathName1 {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.PathName1); err != nil {
			return err
		}
	}
	// PathName2 {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.PathName2); err != nil {
			return err
		}
	}
	// PathType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PathType); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_PathCompareOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// PathName1 {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.PathName1); err != nil {
			return err
		}
	}
	// PathName2 {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.PathName2); err != nil {
			return err
		}
	}
	// PathType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PathType); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_PathCompareOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_PathCompareOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(int32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_PathCompareOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(int32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// PathCompareRequest structure represents the NetprPathCompare operation request
type PathCompareRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle (see [C706] sections
	// 4.3.5 and 5.1.5.2). The server MUST ignore this parameter.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// PathName1: A pointer to a null-terminated UTF-16 string that contains the first PathName
	// to compare.
	PathName1 string `idl:"name:PathName1;string" json:"path_name1"`
	// PathName2: A pointer to a null-terminated UTF-16 string that contains the second
	// PathName to compare.
	PathName2 string `idl:"name:PathName2;string" json:"path_name2"`
	// PathType: The type of PathName, as specified in section 2.2.2.9.
	PathType uint32 `idl:"name:PathType" json:"path_type"`
	// Flags: A bitmask that MUST contain the bitwise OR of zero or more of the following
	// values that specify controlling flags.
	//
	//	+------------+---------------------------------------------------------------------+
	//	|            |                                                                     |
	//	|   VALUE    |                               MEANING                               |
	//	|            |                                                                     |
	//	+------------+---------------------------------------------------------------------+
	//	+------------+---------------------------------------------------------------------+
	//	| 0x00000001 | SHOULD be set if both of the paths have already been canonicalized. |
	//	+------------+---------------------------------------------------------------------+
	Flags uint32 `idl:"name:Flags" json:"flags"`
}

func (o *PathCompareRequest) xxx_ToOp(ctx context.Context, op *xxx_PathCompareOperation) *xxx_PathCompareOperation {
	if op == nil {
		op = &xxx_PathCompareOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.PathName1 = o.PathName1
	op.PathName2 = o.PathName2
	op.PathType = o.PathType
	op.Flags = o.Flags
	return op
}

func (o *PathCompareRequest) xxx_FromOp(ctx context.Context, op *xxx_PathCompareOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.PathName1 = op.PathName1
	o.PathName2 = op.PathName2
	o.PathType = op.PathType
	o.Flags = op.Flags
}
func (o *PathCompareRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *PathCompareRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_PathCompareOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// PathCompareResponse structure represents the NetprPathCompare operation response
type PathCompareResponse struct {
	// Return: The NetprPathCompare return value.
	Return int32 `idl:"name:Return" json:"return"`
}

func (o *PathCompareResponse) xxx_ToOp(ctx context.Context, op *xxx_PathCompareOperation) *xxx_PathCompareOperation {
	if op == nil {
		op = &xxx_PathCompareOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *PathCompareResponse) xxx_FromOp(ctx context.Context, op *xxx_PathCompareOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *PathCompareResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *PathCompareResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_PathCompareOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_NameValidateOperation structure represents the NetprNameValidate operation
type xxx_NameValidateOperation struct {
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	Name       string `idl:"name:Name;string" json:"name"`
	NameType   uint32 `idl:"name:NameType" json:"name_type"`
	Flags      uint32 `idl:"name:Flags" json:"flags"`
	Return     uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_NameValidateOperation) OpNum() int { return 33 }

func (o *xxx_NameValidateOperation) OpName() string { return "/srvsvc/v3/NetprNameValidate" }

func (o *xxx_NameValidateOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NameValidateOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Name {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.Name); err != nil {
			return err
		}
	}
	// NameType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.NameType); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NameValidateOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Name {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.Name); err != nil {
			return err
		}
	}
	// NameType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.NameType); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NameValidateOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NameValidateOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NameValidateOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// NameValidateRequest structure represents the NetprNameValidate operation request
type NameValidateRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle (see [C706] sections
	// 4.3.5 and 5.1.5.2). The server MUST ignore this parameter.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// Name: A pointer to a null-terminated UTF-16 string that specifies the name to check.
	Name string `idl:"name:Name;string" json:"name"`
	// NameType: The type of Name. It MUST be one of the values defined in section 2.2.2.8.
	NameType uint32 `idl:"name:NameType" json:"name_type"`
	// Flags: Reserved, MUST be zero.
	Flags uint32 `idl:"name:Flags" json:"flags"`
}

func (o *NameValidateRequest) xxx_ToOp(ctx context.Context, op *xxx_NameValidateOperation) *xxx_NameValidateOperation {
	if op == nil {
		op = &xxx_NameValidateOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.Name = o.Name
	op.NameType = o.NameType
	op.Flags = o.Flags
	return op
}

func (o *NameValidateRequest) xxx_FromOp(ctx context.Context, op *xxx_NameValidateOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.Name = op.Name
	o.NameType = op.NameType
	o.Flags = op.Flags
}
func (o *NameValidateRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *NameValidateRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_NameValidateOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// NameValidateResponse structure represents the NetprNameValidate operation response
type NameValidateResponse struct {
	// Return: The NetprNameValidate return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *NameValidateResponse) xxx_ToOp(ctx context.Context, op *xxx_NameValidateOperation) *xxx_NameValidateOperation {
	if op == nil {
		op = &xxx_NameValidateOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *NameValidateResponse) xxx_FromOp(ctx context.Context, op *xxx_NameValidateOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *NameValidateResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *NameValidateResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_NameValidateOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_NameCanonicalizeOperation structure represents the NetprNameCanonicalize operation
type xxx_NameCanonicalizeOperation struct {
	ServerName         string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	Name               string `idl:"name:Name;string" json:"name"`
	OutputBuffer       string `idl:"name:Outbuf;size_is:(OutbufLen)" json:"output_buffer"`
	OutputBufferLength uint32 `idl:"name:OutbufLen" json:"output_buffer_length"`
	NameType           uint32 `idl:"name:NameType" json:"name_type"`
	Flags              uint32 `idl:"name:Flags" json:"flags"`
	Return             uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_NameCanonicalizeOperation) OpNum() int { return 34 }

func (o *xxx_NameCanonicalizeOperation) OpName() string { return "/srvsvc/v3/NetprNameCanonicalize" }

func (o *xxx_NameCanonicalizeOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.OutputBufferLength > uint32(64000) {
		return fmt.Errorf("OutputBufferLength is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NameCanonicalizeOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Name {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.Name); err != nil {
			return err
		}
	}
	// OutbufLen {in} (1:{range=(0,64000), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutputBufferLength); err != nil {
			return err
		}
	}
	// NameType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.NameType); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NameCanonicalizeOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Name {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.Name); err != nil {
			return err
		}
	}
	// OutbufLen {in} (1:{range=(0,64000), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutputBufferLength); err != nil {
			return err
		}
	}
	// NameType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.NameType); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NameCanonicalizeOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NameCanonicalizeOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Outbuf {out} (1:{pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,size_is=OutbufLen,string](wchar))
	{
		dimSize1 := uint64(o.OutputBufferLength)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		_OutputBuffer_buf := utf16.Encode([]rune(o.OutputBuffer))
		if uint64(len(_OutputBuffer_buf)) > sizeInfo[0] {
			_OutputBuffer_buf = _OutputBuffer_buf[:sizeInfo[0]]
		}
		for i1 := range _OutputBuffer_buf {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(_OutputBuffer_buf[i1]); err != nil {
				return err
			}
		}
		for i1 := len(_OutputBuffer_buf); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint16(0)); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NameCanonicalizeOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Outbuf {out} (1:{pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,size_is=OutbufLen,string](wchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		var _OutputBuffer_buf []uint16
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array _OutputBuffer_buf", sizeInfo[0])
		}
		_OutputBuffer_buf = make([]uint16, sizeInfo[0])
		for i1 := range _OutputBuffer_buf {
			i1 := i1
			if err := w.ReadData(&_OutputBuffer_buf[i1]); err != nil {
				return err
			}
		}
		o.OutputBuffer = strings.TrimRight(string(utf16.Decode(_OutputBuffer_buf)), ndr.ZeroString)
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// NameCanonicalizeRequest structure represents the NetprNameCanonicalize operation request
type NameCanonicalizeRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle (see [C706] sections
	// 4.3.5 and 5.1.5.2). The server MUST ignore this parameter.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// Name: A pointer to a null-terminated UTF-16 string specifying the name to canonicalize.
	Name string `idl:"name:Name;string" json:"name"`
	// OutbufLen: The length of output buffer Outbuf. The value of this field MUST be within
	// the range 0 through 64,000, inclusive.
	OutputBufferLength uint32 `idl:"name:OutbufLen" json:"output_buffer_length"`
	// NameType: The type of Name, as specified in section 2.2.2.8.
	NameType uint32 `idl:"name:NameType" json:"name_type"`
	// Flags: A bitmask that MUST contain the bitwise OR of zero or more of the following
	// values that specify controlling flags.
	//
	//	+------------+----------------------------------------------------------------------------------+
	//	|            |                                                                                  |
	//	|   VALUE    |                                     MEANING                                      |
	//	|            |                                                                                  |
	//	+------------+----------------------------------------------------------------------------------+
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x80000000 | LM2.x compatible name canonicalization.                                          |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00000001 | If set, the method requires the length of the output buffer to be sufficient     |
	//	|            | to hold any name of the specified type. Otherwise, the buffer length only needs  |
	//	|            | to be large enough to hold the canonicalized version of the input name that is   |
	//	|            | specified in this invocation of the method.                                      |
	//	+------------+----------------------------------------------------------------------------------+
	Flags uint32 `idl:"name:Flags" json:"flags"`
}

func (o *NameCanonicalizeRequest) xxx_ToOp(ctx context.Context, op *xxx_NameCanonicalizeOperation) *xxx_NameCanonicalizeOperation {
	if op == nil {
		op = &xxx_NameCanonicalizeOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.Name = o.Name
	op.OutputBufferLength = o.OutputBufferLength
	op.NameType = o.NameType
	op.Flags = o.Flags
	return op
}

func (o *NameCanonicalizeRequest) xxx_FromOp(ctx context.Context, op *xxx_NameCanonicalizeOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.Name = op.Name
	o.OutputBufferLength = op.OutputBufferLength
	o.NameType = op.NameType
	o.Flags = op.Flags
}
func (o *NameCanonicalizeRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *NameCanonicalizeRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_NameCanonicalizeOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// NameCanonicalizeResponse structure represents the NetprNameCanonicalize operation response
type NameCanonicalizeResponse struct {
	// XXX: OutbufLen is an implicit input depedency for output parameters
	OutputBufferLength uint32 `idl:"name:OutbufLen" json:"output_buffer_length"`

	// Outbuf: A pointer to a null-terminated UTF-16 string that is the buffer where the
	// canonicalized name is returned.
	OutputBuffer string `idl:"name:Outbuf;size_is:(OutbufLen)" json:"output_buffer"`
	// Return: The NetprNameCanonicalize return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *NameCanonicalizeResponse) xxx_ToOp(ctx context.Context, op *xxx_NameCanonicalizeOperation) *xxx_NameCanonicalizeOperation {
	if op == nil {
		op = &xxx_NameCanonicalizeOperation{}
	}
	if o == nil {
		return op
	}
	// XXX: implicit input dependencies for output parameters
	if op.OutputBufferLength == uint32(0) {
		op.OutputBufferLength = o.OutputBufferLength
	}

	op.OutputBuffer = o.OutputBuffer
	op.Return = o.Return
	return op
}

func (o *NameCanonicalizeResponse) xxx_FromOp(ctx context.Context, op *xxx_NameCanonicalizeOperation) {
	if o == nil {
		return
	}
	// XXX: implicit input dependencies for output parameters
	o.OutputBufferLength = op.OutputBufferLength

	o.OutputBuffer = op.OutputBuffer
	o.Return = op.Return
}
func (o *NameCanonicalizeResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *NameCanonicalizeResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_NameCanonicalizeOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_NameCompareOperation structure represents the NetprNameCompare operation
type xxx_NameCompareOperation struct {
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	Name1      string `idl:"name:Name1;string" json:"name1"`
	Name2      string `idl:"name:Name2;string" json:"name2"`
	NameType   uint32 `idl:"name:NameType" json:"name_type"`
	Flags      uint32 `idl:"name:Flags" json:"flags"`
	Return     int32  `idl:"name:Return" json:"return"`
}

func (o *xxx_NameCompareOperation) OpNum() int { return 35 }

func (o *xxx_NameCompareOperation) OpName() string { return "/srvsvc/v3/NetprNameCompare" }

func (o *xxx_NameCompareOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NameCompareOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Name1 {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.Name1); err != nil {
			return err
		}
	}
	// Name2 {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.Name2); err != nil {
			return err
		}
	}
	// NameType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.NameType); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NameCompareOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Name1 {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.Name1); err != nil {
			return err
		}
	}
	// Name2 {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.Name2); err != nil {
			return err
		}
	}
	// NameType {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.NameType); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NameCompareOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NameCompareOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(int32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NameCompareOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(int32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// NameCompareRequest structure represents the NetprNameCompare operation request
type NameCompareRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle (see [C706] sections
	// 4.3.5 and 5.1.5.2). The server MUST ignore this parameter.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// Name1: A pointer to a null-terminated UTF-16 string that contains the first name
	// to compare.
	Name1 string `idl:"name:Name1;string" json:"name1"`
	// Name2: A pointer to a null-terminated UTF-16 string that contains the second name
	// to compare.
	Name2 string `idl:"name:Name2;string" json:"name2"`
	// NameType: The type of names, as specified in section 2.2.2.8.
	NameType uint32 `idl:"name:NameType" json:"name_type"`
	// Flags: A bitmask that MUST contain the bitwise OR of zero or more of the following
	// values, which specify controlling flags.
	//
	//	+------------+----------------------------------------------------------------------------------+
	//	|            |                                                                                  |
	//	|   VALUE    |                                     MEANING                                      |
	//	|            |                                                                                  |
	//	+------------+----------------------------------------------------------------------------------+
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x80000000 | Enable LM2.x compatibility.                                                      |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00000001 | SHOULD be set if both names have already been canonicalized (by using            |
	//	|            | NetprNameCanonicalize).                                                          |
	//	+------------+----------------------------------------------------------------------------------+
	Flags uint32 `idl:"name:Flags" json:"flags"`
}

func (o *NameCompareRequest) xxx_ToOp(ctx context.Context, op *xxx_NameCompareOperation) *xxx_NameCompareOperation {
	if op == nil {
		op = &xxx_NameCompareOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.Name1 = o.Name1
	op.Name2 = o.Name2
	op.NameType = o.NameType
	op.Flags = o.Flags
	return op
}

func (o *NameCompareRequest) xxx_FromOp(ctx context.Context, op *xxx_NameCompareOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.Name1 = op.Name1
	o.Name2 = op.Name2
	o.NameType = op.NameType
	o.Flags = op.Flags
}
func (o *NameCompareRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *NameCompareRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_NameCompareOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// NameCompareResponse structure represents the NetprNameCompare operation response
type NameCompareResponse struct {
	// Return: The NetprNameCompare return value.
	Return int32 `idl:"name:Return" json:"return"`
}

func (o *NameCompareResponse) xxx_ToOp(ctx context.Context, op *xxx_NameCompareOperation) *xxx_NameCompareOperation {
	if op == nil {
		op = &xxx_NameCompareOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *NameCompareResponse) xxx_FromOp(ctx context.Context, op *xxx_NameCompareOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *NameCompareResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *NameCompareResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_NameCompareOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ShareEnumStickyOperation structure represents the NetrShareEnumSticky operation
type xxx_ShareEnumStickyOperation struct {
	ServerName             string     `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	Info                   *ShareEnum `idl:"name:InfoStruct" json:"info"`
	PreferredMaximumLength uint32     `idl:"name:PreferedMaximumLength" json:"preferred_maximum_length"`
	TotalEntries           uint32     `idl:"name:TotalEntries" json:"total_entries"`
	Resume                 uint32     `idl:"name:ResumeHandle;pointer:unique" json:"resume"`
	Return                 uint32     `idl:"name:Return" json:"return"`
}

func (o *xxx_ShareEnumStickyOperation) OpNum() int { return 36 }

func (o *xxx_ShareEnumStickyOperation) OpName() string { return "/srvsvc/v3/NetrShareEnumSticky" }

func (o *xxx_ShareEnumStickyOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareEnumStickyOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// InfoStruct {in, out} (1:{alias=LPSHARE_ENUM_STRUCT}*(1))(2:{alias=SHARE_ENUM_STRUCT}(struct))
	{
		if o.Info != nil {
			if err := o.Info.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ShareEnum{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// PreferedMaximumLength {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PreferredMaximumLength); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=unique}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ResumeHandle := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.Resume); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Resume, _ptr_ResumeHandle); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareEnumStickyOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// InfoStruct {in, out} (1:{alias=LPSHARE_ENUM_STRUCT,pointer=ref}*(1))(2:{alias=SHARE_ENUM_STRUCT}(struct))
	{
		if o.Info == nil {
			o.Info = &ShareEnum{}
		}
		if err := o.Info.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// PreferedMaximumLength {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PreferredMaximumLength); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=unique}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ResumeHandle := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.Resume); err != nil {
				return err
			}
			return nil
		})
		_s_ResumeHandle := func(ptr interface{}) { o.Resume = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.Resume, _s_ResumeHandle, _ptr_ResumeHandle); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareEnumStickyOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareEnumStickyOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// InfoStruct {in, out} (1:{alias=LPSHARE_ENUM_STRUCT}*(1))(2:{alias=SHARE_ENUM_STRUCT}(struct))
	{
		if o.Info != nil {
			if err := o.Info.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ShareEnum{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// TotalEntries {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.TotalEntries); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=unique}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ResumeHandle := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.Resume); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Resume, _ptr_ResumeHandle); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareEnumStickyOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// InfoStruct {in, out} (1:{alias=LPSHARE_ENUM_STRUCT,pointer=ref}*(1))(2:{alias=SHARE_ENUM_STRUCT}(struct))
	{
		if o.Info == nil {
			o.Info = &ShareEnum{}
		}
		if err := o.Info.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// TotalEntries {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.TotalEntries); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=unique}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ResumeHandle := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.Resume); err != nil {
				return err
			}
			return nil
		})
		_s_ResumeHandle := func(ptr interface{}) { o.Resume = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.Resume, _s_ResumeHandle, _ptr_ResumeHandle); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ShareEnumStickyRequest structure represents the NetrShareEnumSticky operation request
type ShareEnumStickyRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle (see [C706] sections
	// 4.3.5 and 5.1.5.2). If this parameter is NULL, the local computer is used.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// InfoStruct: A pointer to a structure, in the format of a SHARE_ENUM_STRUCT (section
	// 2.2.4.38). The SHARE_ENUM_STRUCT structure has a Level member that specifies the
	// type of structure to return in the ShareInfo member. The Level member MUST be set
	// to one of the values specified in section 2.2.4.38 (excluding SHARE_INFO_501_CONTAINER).
	Info *ShareEnum `idl:"name:InfoStruct" json:"info"`
	// PreferedMaximumLength: Specifies the preferred maximum length, in bytes, of the returned
	// data. If the specified value is MAX_PREFERRED_LENGTH, the method MUST attempt to
	// return all entries.
	PreferredMaximumLength uint32 `idl:"name:PreferedMaximumLength" json:"preferred_maximum_length"`
	// ResumeHandle: A pointer to a value that contains a handle, which is used to continue
	// an existing connection search. The handle MUST be zero on the first call and remain
	// unchanged for subsequent calls. If the ResumeHandle parameter is NULL, a resume handle
	// MUST NOT be stored. If this parameter is not NULL and the method returns ERROR_MORE_DATA,
	// this parameter receives an implementation-specific nonzero value that can be passed
	// in subsequent calls to this method to continue with the enumeration.
	Resume uint32 `idl:"name:ResumeHandle;pointer:unique" json:"resume"`
}

func (o *ShareEnumStickyRequest) xxx_ToOp(ctx context.Context, op *xxx_ShareEnumStickyOperation) *xxx_ShareEnumStickyOperation {
	if op == nil {
		op = &xxx_ShareEnumStickyOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.Info = o.Info
	op.PreferredMaximumLength = o.PreferredMaximumLength
	op.Resume = o.Resume
	return op
}

func (o *ShareEnumStickyRequest) xxx_FromOp(ctx context.Context, op *xxx_ShareEnumStickyOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.Info = op.Info
	o.PreferredMaximumLength = op.PreferredMaximumLength
	o.Resume = op.Resume
}
func (o *ShareEnumStickyRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *ShareEnumStickyRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ShareEnumStickyOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ShareEnumStickyResponse structure represents the NetrShareEnumSticky operation response
type ShareEnumStickyResponse struct {
	// InfoStruct: A pointer to a structure, in the format of a SHARE_ENUM_STRUCT (section
	// 2.2.4.38). The SHARE_ENUM_STRUCT structure has a Level member that specifies the
	// type of structure to return in the ShareInfo member. The Level member MUST be set
	// to one of the values specified in section 2.2.4.38 (excluding SHARE_INFO_501_CONTAINER).
	Info *ShareEnum `idl:"name:InfoStruct" json:"info"`
	// TotalEntries: The total number of entries that could have been enumerated if the
	// buffer had been big enough to hold all the entries.
	TotalEntries uint32 `idl:"name:TotalEntries" json:"total_entries"`
	// ResumeHandle: A pointer to a value that contains a handle, which is used to continue
	// an existing connection search. The handle MUST be zero on the first call and remain
	// unchanged for subsequent calls. If the ResumeHandle parameter is NULL, a resume handle
	// MUST NOT be stored. If this parameter is not NULL and the method returns ERROR_MORE_DATA,
	// this parameter receives an implementation-specific nonzero value that can be passed
	// in subsequent calls to this method to continue with the enumeration.
	Resume uint32 `idl:"name:ResumeHandle;pointer:unique" json:"resume"`
	// Return: The NetrShareEnumSticky return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ShareEnumStickyResponse) xxx_ToOp(ctx context.Context, op *xxx_ShareEnumStickyOperation) *xxx_ShareEnumStickyOperation {
	if op == nil {
		op = &xxx_ShareEnumStickyOperation{}
	}
	if o == nil {
		return op
	}
	op.Info = o.Info
	op.TotalEntries = o.TotalEntries
	op.Resume = o.Resume
	op.Return = o.Return
	return op
}

func (o *ShareEnumStickyResponse) xxx_FromOp(ctx context.Context, op *xxx_ShareEnumStickyOperation) {
	if o == nil {
		return
	}
	o.Info = op.Info
	o.TotalEntries = op.TotalEntries
	o.Resume = op.Resume
	o.Return = op.Return
}
func (o *ShareEnumStickyResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *ShareEnumStickyResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ShareEnumStickyOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ShareDeleteStartOperation structure represents the NetrShareDelStart operation
type xxx_ShareDeleteStartOperation struct {
	ServerName    string             `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	NetName       string             `idl:"name:NetName;string" json:"net_name"`
	_             uint32             `idl:"name:Reserved"`
	ContextHandle *ShareDeleteHandle `idl:"name:ContextHandle" json:"context_handle"`
	Return        uint32             `idl:"name:Return" json:"return"`
}

func (o *xxx_ShareDeleteStartOperation) OpNum() int { return 37 }

func (o *xxx_ShareDeleteStartOperation) OpName() string { return "/srvsvc/v3/NetrShareDelStart" }

func (o *xxx_ShareDeleteStartOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareDeleteStartOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// NetName {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.NetName); err != nil {
			return err
		}
	}
	// Reserved {in} (1:{alias=DWORD}(uint32))
	{
		// reserved Reserved
		if err := w.WriteData(uint32(0)); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareDeleteStartOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// NetName {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.NetName); err != nil {
			return err
		}
	}
	// Reserved {in} (1:{alias=DWORD}(uint32))
	{
		// reserved Reserved
		var _Reserved uint32
		if err := w.ReadData(&_Reserved); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareDeleteStartOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareDeleteStartOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ContextHandle {out} (1:{alias=PSHARE_DEL_HANDLE}*(1))(2:{context_handle, alias=SHARE_DEL_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ContextHandle != nil {
			if err := o.ContextHandle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ShareDeleteHandle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareDeleteStartOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ContextHandle {out} (1:{alias=PSHARE_DEL_HANDLE,pointer=ref}*(1))(2:{context_handle, alias=SHARE_DEL_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ContextHandle == nil {
			o.ContextHandle = &ShareDeleteHandle{}
		}
		if err := o.ContextHandle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ShareDeleteStartRequest structure represents the NetrShareDelStart operation request
type ShareDeleteStartRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle (see [C706] sections
	// 4.3.5 and 5.1.5.2). If this parameter is NULL, the local computer is used.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// NetName: A pointer to a null-terminated UTF-16 string that specifies the name of
	// the share to delete.
	NetName string `idl:"name:NetName;string" json:"net_name"`
}

func (o *ShareDeleteStartRequest) xxx_ToOp(ctx context.Context, op *xxx_ShareDeleteStartOperation) *xxx_ShareDeleteStartOperation {
	if op == nil {
		op = &xxx_ShareDeleteStartOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.NetName = o.NetName
	return op
}

func (o *ShareDeleteStartRequest) xxx_FromOp(ctx context.Context, op *xxx_ShareDeleteStartOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.NetName = op.NetName
}
func (o *ShareDeleteStartRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *ShareDeleteStartRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ShareDeleteStartOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ShareDeleteStartResponse structure represents the NetrShareDelStart operation response
type ShareDeleteStartResponse struct {
	// ContextHandle: A handle for the second phase of the two-phase share delete, in the
	// form of a PSHARE_DEL_HANDLE (section 2.2.1.3) data type.
	ContextHandle *ShareDeleteHandle `idl:"name:ContextHandle" json:"context_handle"`
	// Return: The NetrShareDelStart return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ShareDeleteStartResponse) xxx_ToOp(ctx context.Context, op *xxx_ShareDeleteStartOperation) *xxx_ShareDeleteStartOperation {
	if op == nil {
		op = &xxx_ShareDeleteStartOperation{}
	}
	if o == nil {
		return op
	}
	op.ContextHandle = o.ContextHandle
	op.Return = o.Return
	return op
}

func (o *ShareDeleteStartResponse) xxx_FromOp(ctx context.Context, op *xxx_ShareDeleteStartOperation) {
	if o == nil {
		return
	}
	o.ContextHandle = op.ContextHandle
	o.Return = op.Return
}
func (o *ShareDeleteStartResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *ShareDeleteStartResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ShareDeleteStartOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ShareDeleteCommitOperation structure represents the NetrShareDelCommit operation
type xxx_ShareDeleteCommitOperation struct {
	ContextHandle *ShareDeleteHandle `idl:"name:ContextHandle" json:"context_handle"`
	Return        uint32             `idl:"name:Return" json:"return"`
}

func (o *xxx_ShareDeleteCommitOperation) OpNum() int { return 38 }

func (o *xxx_ShareDeleteCommitOperation) OpName() string { return "/srvsvc/v3/NetrShareDelCommit" }

func (o *xxx_ShareDeleteCommitOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareDeleteCommitOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ContextHandle {in, out} (1:{alias=PSHARE_DEL_HANDLE}*(1))(2:{context_handle, alias=SHARE_DEL_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ContextHandle != nil {
			if err := o.ContextHandle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ShareDeleteHandle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_ShareDeleteCommitOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ContextHandle {in, out} (1:{alias=PSHARE_DEL_HANDLE,pointer=ref}*(1))(2:{context_handle, alias=SHARE_DEL_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ContextHandle == nil {
			o.ContextHandle = &ShareDeleteHandle{}
		}
		if err := o.ContextHandle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareDeleteCommitOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareDeleteCommitOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ContextHandle {in, out} (1:{alias=PSHARE_DEL_HANDLE}*(1))(2:{context_handle, alias=SHARE_DEL_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ContextHandle != nil {
			if err := o.ContextHandle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ShareDeleteHandle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareDeleteCommitOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ContextHandle {in, out} (1:{alias=PSHARE_DEL_HANDLE,pointer=ref}*(1))(2:{context_handle, alias=SHARE_DEL_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.ContextHandle == nil {
			o.ContextHandle = &ShareDeleteHandle{}
		}
		if err := o.ContextHandle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ShareDeleteCommitRequest structure represents the NetrShareDelCommit operation request
type ShareDeleteCommitRequest struct {
	// ContextHandle: A handle returned by the first phase of a two-phase share delete.
	ContextHandle *ShareDeleteHandle `idl:"name:ContextHandle" json:"context_handle"`
}

func (o *ShareDeleteCommitRequest) xxx_ToOp(ctx context.Context, op *xxx_ShareDeleteCommitOperation) *xxx_ShareDeleteCommitOperation {
	if op == nil {
		op = &xxx_ShareDeleteCommitOperation{}
	}
	if o == nil {
		return op
	}
	op.ContextHandle = o.ContextHandle
	return op
}

func (o *ShareDeleteCommitRequest) xxx_FromOp(ctx context.Context, op *xxx_ShareDeleteCommitOperation) {
	if o == nil {
		return
	}
	o.ContextHandle = op.ContextHandle
}
func (o *ShareDeleteCommitRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *ShareDeleteCommitRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ShareDeleteCommitOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ShareDeleteCommitResponse structure represents the NetrShareDelCommit operation response
type ShareDeleteCommitResponse struct {
	// ContextHandle: A handle returned by the first phase of a two-phase share delete.
	ContextHandle *ShareDeleteHandle `idl:"name:ContextHandle" json:"context_handle"`
	// Return: The NetrShareDelCommit return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ShareDeleteCommitResponse) xxx_ToOp(ctx context.Context, op *xxx_ShareDeleteCommitOperation) *xxx_ShareDeleteCommitOperation {
	if op == nil {
		op = &xxx_ShareDeleteCommitOperation{}
	}
	if o == nil {
		return op
	}
	op.ContextHandle = o.ContextHandle
	op.Return = o.Return
	return op
}

func (o *ShareDeleteCommitResponse) xxx_FromOp(ctx context.Context, op *xxx_ShareDeleteCommitOperation) {
	if o == nil {
		return
	}
	o.ContextHandle = op.ContextHandle
	o.Return = op.Return
}
func (o *ShareDeleteCommitResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *ShareDeleteCommitResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ShareDeleteCommitOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetFileSecurityOperation structure represents the NetrpGetFileSecurity operation
type xxx_GetFileSecurityOperation struct {
	ServerName           string                 `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	ShareName            string                 `idl:"name:ShareName;string;pointer:unique" json:"share_name"`
	FileName             string                 `idl:"name:lpFileName;string" json:"file_name"`
	RequestedInformation uint32                 `idl:"name:RequestedInformation" json:"requested_information"`
	SecurityDescriptor   *ADTSecurityDescriptor `idl:"name:SecurityDescriptor" json:"security_descriptor"`
	Return               uint32                 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetFileSecurityOperation) OpNum() int { return 39 }

func (o *xxx_GetFileSecurityOperation) OpName() string { return "/srvsvc/v3/NetrpGetFileSecurity" }

func (o *xxx_GetFileSecurityOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetFileSecurityOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ShareName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.ShareName != "" {
			_ptr_ShareName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ShareName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ShareName, _ptr_ShareName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpFileName {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.FileName); err != nil {
			return err
		}
	}
	// RequestedInformation {in} (1:{alias=SECURITY_INFORMATION, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.RequestedInformation); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetFileSecurityOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ShareName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_ShareName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ShareName); err != nil {
				return err
			}
			return nil
		})
		_s_ShareName := func(ptr interface{}) { o.ShareName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ShareName, _s_ShareName, _ptr_ShareName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpFileName {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.FileName); err != nil {
			return err
		}
	}
	// RequestedInformation {in} (1:{alias=SECURITY_INFORMATION, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RequestedInformation); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetFileSecurityOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetFileSecurityOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// SecurityDescriptor {out} (1:{pointer=ref}*(2))(2:{alias=PADT_SECURITY_DESCRIPTOR}*(1))(3:{alias=ADT_SECURITY_DESCRIPTOR}(struct))
	{
		if o.SecurityDescriptor != nil {
			_ptr_SecurityDescriptor := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.SecurityDescriptor != nil {
					if err := o.SecurityDescriptor.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&ADTSecurityDescriptor{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.SecurityDescriptor, _ptr_SecurityDescriptor); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetFileSecurityOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// SecurityDescriptor {out} (1:{pointer=ref}*(2))(2:{alias=PADT_SECURITY_DESCRIPTOR,pointer=ref}*(1))(3:{alias=ADT_SECURITY_DESCRIPTOR}(struct))
	{
		_ptr_SecurityDescriptor := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.SecurityDescriptor == nil {
				o.SecurityDescriptor = &ADTSecurityDescriptor{}
			}
			if err := o.SecurityDescriptor.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_SecurityDescriptor := func(ptr interface{}) { o.SecurityDescriptor = *ptr.(**ADTSecurityDescriptor) }
		if err := w.ReadPointer(&o.SecurityDescriptor, _s_SecurityDescriptor, _ptr_SecurityDescriptor); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetFileSecurityRequest structure represents the NetrpGetFileSecurity operation request
type GetFileSecurityRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle (see [C706] sections
	// 4.3.5 and 5.1.5.2). The server MUST ignore this parameter.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// ShareName: A pointer to a null-terminated UTF-16 string that specifies the share
	// name on which the file is found.
	ShareName string `idl:"name:ShareName;string;pointer:unique" json:"share_name"`
	// lpFileName: A pointer to a null-terminated UTF-16 string that specifies the name
	// of the file or directory whose security is being retrieved. The name MUST specify
	// the full path to the file from the ShareName parameter.
	FileName string `idl:"name:lpFileName;string" json:"file_name"`
	// RequestedInformation: The type of security information being requested, as specified
	// in [MS-DTYP] section 2.4.7.
	RequestedInformation uint32 `idl:"name:RequestedInformation" json:"requested_information"`
}

func (o *GetFileSecurityRequest) xxx_ToOp(ctx context.Context, op *xxx_GetFileSecurityOperation) *xxx_GetFileSecurityOperation {
	if op == nil {
		op = &xxx_GetFileSecurityOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.ShareName = o.ShareName
	op.FileName = o.FileName
	op.RequestedInformation = o.RequestedInformation
	return op
}

func (o *GetFileSecurityRequest) xxx_FromOp(ctx context.Context, op *xxx_GetFileSecurityOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.ShareName = op.ShareName
	o.FileName = op.FileName
	o.RequestedInformation = op.RequestedInformation
}
func (o *GetFileSecurityRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetFileSecurityRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetFileSecurityOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetFileSecurityResponse structure represents the NetrpGetFileSecurity operation response
type GetFileSecurityResponse struct {
	// SecurityDescriptor: A pointer to a PADT_SECURITY_DESCRIPTOR structure, where the
	// desired information is returned.
	SecurityDescriptor *ADTSecurityDescriptor `idl:"name:SecurityDescriptor" json:"security_descriptor"`
	// Return: The NetrpGetFileSecurity return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetFileSecurityResponse) xxx_ToOp(ctx context.Context, op *xxx_GetFileSecurityOperation) *xxx_GetFileSecurityOperation {
	if op == nil {
		op = &xxx_GetFileSecurityOperation{}
	}
	if o == nil {
		return op
	}
	op.SecurityDescriptor = o.SecurityDescriptor
	op.Return = o.Return
	return op
}

func (o *GetFileSecurityResponse) xxx_FromOp(ctx context.Context, op *xxx_GetFileSecurityOperation) {
	if o == nil {
		return
	}
	o.SecurityDescriptor = op.SecurityDescriptor
	o.Return = op.Return
}
func (o *GetFileSecurityResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetFileSecurityResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetFileSecurityOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetFileSecurityOperation structure represents the NetrpSetFileSecurity operation
type xxx_SetFileSecurityOperation struct {
	ServerName          string                 `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	ShareName           string                 `idl:"name:ShareName;string;pointer:unique" json:"share_name"`
	FileName            string                 `idl:"name:lpFileName;string" json:"file_name"`
	SecurityInformation uint32                 `idl:"name:SecurityInformation" json:"security_information"`
	SecurityDescriptor  *ADTSecurityDescriptor `idl:"name:SecurityDescriptor" json:"security_descriptor"`
	Return              uint32                 `idl:"name:Return" json:"return"`
}

func (o *xxx_SetFileSecurityOperation) OpNum() int { return 40 }

func (o *xxx_SetFileSecurityOperation) OpName() string { return "/srvsvc/v3/NetrpSetFileSecurity" }

func (o *xxx_SetFileSecurityOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFileSecurityOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ShareName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.ShareName != "" {
			_ptr_ShareName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ShareName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ShareName, _ptr_ShareName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// lpFileName {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.FileName); err != nil {
			return err
		}
	}
	// SecurityInformation {in} (1:{alias=SECURITY_INFORMATION, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.SecurityInformation); err != nil {
			return err
		}
	}
	// SecurityDescriptor {in} (1:{alias=PADT_SECURITY_DESCRIPTOR}*(1))(2:{alias=ADT_SECURITY_DESCRIPTOR}(struct))
	{
		if o.SecurityDescriptor != nil {
			if err := o.SecurityDescriptor.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ADTSecurityDescriptor{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFileSecurityOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ShareName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_ShareName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ShareName); err != nil {
				return err
			}
			return nil
		})
		_s_ShareName := func(ptr interface{}) { o.ShareName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ShareName, _s_ShareName, _ptr_ShareName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// lpFileName {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.FileName); err != nil {
			return err
		}
	}
	// SecurityInformation {in} (1:{alias=SECURITY_INFORMATION, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.SecurityInformation); err != nil {
			return err
		}
	}
	// SecurityDescriptor {in} (1:{alias=PADT_SECURITY_DESCRIPTOR,pointer=ref}*(1))(2:{alias=ADT_SECURITY_DESCRIPTOR}(struct))
	{
		if o.SecurityDescriptor == nil {
			o.SecurityDescriptor = &ADTSecurityDescriptor{}
		}
		if err := o.SecurityDescriptor.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFileSecurityOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFileSecurityOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFileSecurityOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetFileSecurityRequest structure represents the NetrpSetFileSecurity operation request
type SetFileSecurityRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle (see [C706] sections
	// 4.3.5 and 5.1.5.2). The server MUST ignore this parameter.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// ShareName: A pointer to a null-terminated UTF-16 string that specifies the share
	// name on which the file is found.
	ShareName string `idl:"name:ShareName;string;pointer:unique" json:"share_name"`
	// lpFileName: A pointer to a null-terminated UTF-16 string that specifies the name
	// of the file or directory whose security is being set.
	FileName string `idl:"name:lpFileName;string" json:"file_name"`
	// SecurityInformation: The type of security information being set, as specified in
	// [MS-DTYP] section 2.4.7.
	SecurityInformation uint32 `idl:"name:SecurityInformation" json:"security_information"`
	// SecurityDescriptor: A pointer to a PADT_SECURITY_DESCRIPTOR structure, which provides
	// the security descriptor to set.
	SecurityDescriptor *ADTSecurityDescriptor `idl:"name:SecurityDescriptor" json:"security_descriptor"`
}

func (o *SetFileSecurityRequest) xxx_ToOp(ctx context.Context, op *xxx_SetFileSecurityOperation) *xxx_SetFileSecurityOperation {
	if op == nil {
		op = &xxx_SetFileSecurityOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.ShareName = o.ShareName
	op.FileName = o.FileName
	op.SecurityInformation = o.SecurityInformation
	op.SecurityDescriptor = o.SecurityDescriptor
	return op
}

func (o *SetFileSecurityRequest) xxx_FromOp(ctx context.Context, op *xxx_SetFileSecurityOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.ShareName = op.ShareName
	o.FileName = op.FileName
	o.SecurityInformation = op.SecurityInformation
	o.SecurityDescriptor = op.SecurityDescriptor
}
func (o *SetFileSecurityRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetFileSecurityRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetFileSecurityOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetFileSecurityResponse structure represents the NetrpSetFileSecurity operation response
type SetFileSecurityResponse struct {
	// Return: The NetrpSetFileSecurity return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetFileSecurityResponse) xxx_ToOp(ctx context.Context, op *xxx_SetFileSecurityOperation) *xxx_SetFileSecurityOperation {
	if op == nil {
		op = &xxx_SetFileSecurityOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetFileSecurityResponse) xxx_FromOp(ctx context.Context, op *xxx_SetFileSecurityOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetFileSecurityResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetFileSecurityResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetFileSecurityOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_TransportAddExOperation structure represents the NetrServerTransportAddEx operation
type xxx_TransportAddExOperation struct {
	ServerName string         `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	Level      uint32         `idl:"name:Level" json:"level"`
	Buffer     *TransportInfo `idl:"name:Buffer;switch_is:Level" json:"buffer"`
	Return     uint32         `idl:"name:Return" json:"return"`
}

func (o *xxx_TransportAddExOperation) OpNum() int { return 41 }

func (o *xxx_TransportAddExOperation) OpName() string { return "/srvsvc/v3/NetrServerTransportAddEx" }

func (o *xxx_TransportAddExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_TransportAddExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Level); err != nil {
			return err
		}
	}
	// Buffer {in} (1:{switch_type={}(uint32), alias=LPTRANSPORT_INFO}*(1))(2:{switch_type={}(uint32), alias=TRANSPORT_INFO}(union))
	{
		_swBuffer := uint32(o.Level)
		if o.Buffer != nil {
			if err := o.Buffer.MarshalUnionNDR(ctx, w, _swBuffer); err != nil {
				return err
			}
		} else {
			if err := (&TransportInfo{}).MarshalUnionNDR(ctx, w, _swBuffer); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_TransportAddExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Level); err != nil {
			return err
		}
	}
	// Buffer {in} (1:{switch_type={}(uint32), alias=LPTRANSPORT_INFO,pointer=ref}*(1))(2:{switch_type={}(uint32), alias=TRANSPORT_INFO}(union))
	{
		if o.Buffer == nil {
			o.Buffer = &TransportInfo{}
		}
		_swBuffer := uint32(o.Level)
		if err := o.Buffer.UnmarshalUnionNDR(ctx, w, _swBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_TransportAddExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_TransportAddExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_TransportAddExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// TransportAddExRequest structure represents the NetrServerTransportAddEx operation request
type TransportAddExRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle (see [C706] sections
	// 4.3.5 and 5.1.5.2). The server MUST ignore this parameter.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// Level: Specifies the information level of the data. This parameter MUST be the following
	// value.
	//
	//	+-------+------------------------------------------------+
	//	|       |                                                |
	//	| VALUE |                    MEANING                     |
	//	|       |                                                |
	//	+-------+------------------------------------------------+
	//	+-------+------------------------------------------------+
	//	|     0 | The buffer is of type SERVER_TRANSPORT_INFO_0. |
	//	+-------+------------------------------------------------+
	//	|     1 | The buffer is of type SERVER_TRANSPORT_INFO_1. |
	//	+-------+------------------------------------------------+
	//	|     2 | The buffer is of type SERVER_TRANSPORT_INFO_2. |
	//	+-------+------------------------------------------------+
	//	|     3 | The buffer is of type SERVER_TRANSPORT_INFO_3. |
	//	+-------+------------------------------------------------+
	Level uint32 `idl:"name:Level" json:"level"`
	// Buffer: A pointer to the TRANSPORT_INFO union that describes the data. The type of
	// data depends on the value of the Level parameter, as the preceding table shows.
	Buffer *TransportInfo `idl:"name:Buffer;switch_is:Level" json:"buffer"`
}

func (o *TransportAddExRequest) xxx_ToOp(ctx context.Context, op *xxx_TransportAddExOperation) *xxx_TransportAddExOperation {
	if op == nil {
		op = &xxx_TransportAddExOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.Level = o.Level
	op.Buffer = o.Buffer
	return op
}

func (o *TransportAddExRequest) xxx_FromOp(ctx context.Context, op *xxx_TransportAddExOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.Level = op.Level
	o.Buffer = op.Buffer
}
func (o *TransportAddExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *TransportAddExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_TransportAddExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// TransportAddExResponse structure represents the NetrServerTransportAddEx operation response
type TransportAddExResponse struct {
	// Return: The NetrServerTransportAddEx return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *TransportAddExResponse) xxx_ToOp(ctx context.Context, op *xxx_TransportAddExOperation) *xxx_TransportAddExOperation {
	if op == nil {
		op = &xxx_TransportAddExOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *TransportAddExResponse) xxx_FromOp(ctx context.Context, op *xxx_TransportAddExOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *TransportAddExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *TransportAddExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_TransportAddExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetVersionOperation structure represents the NetrDfsGetVersion operation
type xxx_GetVersionOperation struct {
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	Version    uint32 `idl:"name:Version" json:"version"`
	Return     uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetVersionOperation) OpNum() int { return 43 }

func (o *xxx_GetVersionOperation) OpName() string { return "/srvsvc/v3/NetrDfsGetVersion" }

func (o *xxx_GetVersionOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetVersionOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetVersionOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetVersionOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetVersionOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Version {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Version); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetVersionOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Version {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Version); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetVersionRequest structure represents the NetrDfsGetVersion operation request
type GetVersionRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle (see [C706] sections
	// 4.3.5 and 5.1.5.2). The server MUST ignore this parameter.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
}

func (o *GetVersionRequest) xxx_ToOp(ctx context.Context, op *xxx_GetVersionOperation) *xxx_GetVersionOperation {
	if op == nil {
		op = &xxx_GetVersionOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	return op
}

func (o *GetVersionRequest) xxx_FromOp(ctx context.Context, op *xxx_GetVersionOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
}
func (o *GetVersionRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetVersionRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetVersionOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetVersionResponse structure represents the NetrDfsGetVersion operation response
type GetVersionResponse struct {
	// Version: A pointer to a DWORD where the server returns the DFS version.
	Version uint32 `idl:"name:Version" json:"version"`
	// Return: The NetrDfsGetVersion return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetVersionResponse) xxx_ToOp(ctx context.Context, op *xxx_GetVersionOperation) *xxx_GetVersionOperation {
	if op == nil {
		op = &xxx_GetVersionOperation{}
	}
	if o == nil {
		return op
	}
	op.Version = o.Version
	op.Return = o.Return
	return op
}

func (o *GetVersionResponse) xxx_FromOp(ctx context.Context, op *xxx_GetVersionOperation) {
	if o == nil {
		return
	}
	o.Version = op.Version
	o.Return = op.Return
}
func (o *GetVersionResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetVersionResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetVersionOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CreateLocalPartitionOperation structure represents the NetrDfsCreateLocalPartition operation
type xxx_CreateLocalPartitionOperation struct {
	ServerName   string                  `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	ShareName    string                  `idl:"name:ShareName;string" json:"share_name"`
	EntryUID     *dtyp.GUID              `idl:"name:EntryUid" json:"entry_uid"`
	EntryPrefix  string                  `idl:"name:EntryPrefix;string" json:"entry_prefix"`
	ShortName    string                  `idl:"name:ShortName;string" json:"short_name"`
	RelationInfo *NetDFSEntryIDContainer `idl:"name:RelationInfo" json:"relation_info"`
	Force        int32                   `idl:"name:Force" json:"force"`
	Return       uint32                  `idl:"name:Return" json:"return"`
}

func (o *xxx_CreateLocalPartitionOperation) OpNum() int { return 44 }

func (o *xxx_CreateLocalPartitionOperation) OpName() string {
	return "/srvsvc/v3/NetrDfsCreateLocalPartition"
}

func (o *xxx_CreateLocalPartitionOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateLocalPartitionOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ShareName {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ShareName); err != nil {
			return err
		}
	}
	// EntryUid {in} (1:{pointer=ref}*(1))(2:{alias=GUID}(struct))
	{
		if o.EntryUID != nil {
			if err := o.EntryUID.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// EntryPrefix {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.EntryPrefix); err != nil {
			return err
		}
	}
	// ShortName {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ShortName); err != nil {
			return err
		}
	}
	// RelationInfo {in} (1:{alias=LPNET_DFS_ENTRY_ID_CONTAINER}*(1))(2:{alias=NET_DFS_ENTRY_ID_CONTAINER}(struct))
	{
		if o.RelationInfo != nil {
			if err := o.RelationInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&NetDFSEntryIDContainer{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Force {in} (1:(int32))
	{
		if err := w.WriteData(o.Force); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateLocalPartitionOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ShareName {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ShareName); err != nil {
			return err
		}
	}
	// EntryUid {in} (1:{pointer=ref}*(1))(2:{alias=GUID}(struct))
	{
		if o.EntryUID == nil {
			o.EntryUID = &dtyp.GUID{}
		}
		if err := o.EntryUID.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// EntryPrefix {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.EntryPrefix); err != nil {
			return err
		}
	}
	// ShortName {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ShortName); err != nil {
			return err
		}
	}
	// RelationInfo {in} (1:{alias=LPNET_DFS_ENTRY_ID_CONTAINER,pointer=ref}*(1))(2:{alias=NET_DFS_ENTRY_ID_CONTAINER}(struct))
	{
		if o.RelationInfo == nil {
			o.RelationInfo = &NetDFSEntryIDContainer{}
		}
		if err := o.RelationInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Force {in} (1:(int32))
	{
		if err := w.ReadData(&o.Force); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateLocalPartitionOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateLocalPartitionOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateLocalPartitionOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CreateLocalPartitionRequest structure represents the NetrDfsCreateLocalPartition operation request
type CreateLocalPartitionRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle (see [C706] sections
	// 4.3.5 and 5.1.5.2). The server MUST ignore this parameter.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// ShareName: A pointer to a null-terminated UTF-16 string that specifies the name of
	// a local disk share on the server to add to DFS.
	ShareName string `idl:"name:ShareName;string" json:"share_name"`
	// EntryUid: A pointer to a GUID type that specifies the GUID for this DFS share. The
	// GUID for this share MUST NOT match a GUID for an existing local partition.<133>
	EntryUID *dtyp.GUID `idl:"name:EntryUid" json:"entry_uid"`
	// EntryPrefix: A pointer to a null-terminated UTF-16 string that specifies the path
	// of the DFS share.
	EntryPrefix string `idl:"name:EntryPrefix;string" json:"entry_prefix"`
	// ShortName: A pointer to a null-terminated UTF-16 string that specifies the short-name
	// version (8.3 format) of the EntryPrefix parameter.
	ShortName string `idl:"name:ShortName;string" json:"short_name"`
	// RelationInfo: A pointer to a NET_DFS_ENTRY_ID_CONTAINER structure. Specifies the
	// DFS child links that are under the DFS share that is specified by the EntryPrefix
	// parameter.
	RelationInfo *NetDFSEntryIDContainer `idl:"name:RelationInfo" json:"relation_info"`
	// Force: The Force parameter is ignored and MUST be set to zero.
	Force int32 `idl:"name:Force" json:"force"`
}

func (o *CreateLocalPartitionRequest) xxx_ToOp(ctx context.Context, op *xxx_CreateLocalPartitionOperation) *xxx_CreateLocalPartitionOperation {
	if op == nil {
		op = &xxx_CreateLocalPartitionOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.ShareName = o.ShareName
	op.EntryUID = o.EntryUID
	op.EntryPrefix = o.EntryPrefix
	op.ShortName = o.ShortName
	op.RelationInfo = o.RelationInfo
	op.Force = o.Force
	return op
}

func (o *CreateLocalPartitionRequest) xxx_FromOp(ctx context.Context, op *xxx_CreateLocalPartitionOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.ShareName = op.ShareName
	o.EntryUID = op.EntryUID
	o.EntryPrefix = op.EntryPrefix
	o.ShortName = op.ShortName
	o.RelationInfo = op.RelationInfo
	o.Force = op.Force
}
func (o *CreateLocalPartitionRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *CreateLocalPartitionRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateLocalPartitionOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CreateLocalPartitionResponse structure represents the NetrDfsCreateLocalPartition operation response
type CreateLocalPartitionResponse struct {
	// Return: The NetrDfsCreateLocalPartition return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CreateLocalPartitionResponse) xxx_ToOp(ctx context.Context, op *xxx_CreateLocalPartitionOperation) *xxx_CreateLocalPartitionOperation {
	if op == nil {
		op = &xxx_CreateLocalPartitionOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *CreateLocalPartitionResponse) xxx_FromOp(ctx context.Context, op *xxx_CreateLocalPartitionOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *CreateLocalPartitionResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *CreateLocalPartitionResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateLocalPartitionOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_DeleteLocalPartitionOperation structure represents the NetrDfsDeleteLocalPartition operation
type xxx_DeleteLocalPartitionOperation struct {
	ServerName string     `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	UID        *dtyp.GUID `idl:"name:Uid" json:"uid"`
	Prefix     string     `idl:"name:Prefix;string" json:"prefix"`
	Return     uint32     `idl:"name:Return" json:"return"`
}

func (o *xxx_DeleteLocalPartitionOperation) OpNum() int { return 45 }

func (o *xxx_DeleteLocalPartitionOperation) OpName() string {
	return "/srvsvc/v3/NetrDfsDeleteLocalPartition"
}

func (o *xxx_DeleteLocalPartitionOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteLocalPartitionOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Uid {in} (1:{pointer=ref}*(1))(2:{alias=GUID}(struct))
	{
		if o.UID != nil {
			if err := o.UID.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Prefix {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.Prefix); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteLocalPartitionOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Uid {in} (1:{pointer=ref}*(1))(2:{alias=GUID}(struct))
	{
		if o.UID == nil {
			o.UID = &dtyp.GUID{}
		}
		if err := o.UID.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Prefix {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.Prefix); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteLocalPartitionOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteLocalPartitionOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteLocalPartitionOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// DeleteLocalPartitionRequest structure represents the NetrDfsDeleteLocalPartition operation request
type DeleteLocalPartitionRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle (see [C706] sections
	// 4.3.5 and 5.1.5.2). The server MUST ignore this parameter.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// Uid: Specifies the GUID of the DFS share to delete. This GUID MUST be obtained by
	// using the NetrDfsGetInfo (Opnum 4) method, which is specified in [MS-DFSNM] section
	// 3.1.4.1.6.
	UID *dtyp.GUID `idl:"name:Uid" json:"uid"`
	// Prefix: A pointer to a null-terminated UTF-16 string that contains the path to the
	// DFS share.
	Prefix string `idl:"name:Prefix;string" json:"prefix"`
}

func (o *DeleteLocalPartitionRequest) xxx_ToOp(ctx context.Context, op *xxx_DeleteLocalPartitionOperation) *xxx_DeleteLocalPartitionOperation {
	if op == nil {
		op = &xxx_DeleteLocalPartitionOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.UID = o.UID
	op.Prefix = o.Prefix
	return op
}

func (o *DeleteLocalPartitionRequest) xxx_FromOp(ctx context.Context, op *xxx_DeleteLocalPartitionOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.UID = op.UID
	o.Prefix = op.Prefix
}
func (o *DeleteLocalPartitionRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *DeleteLocalPartitionRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteLocalPartitionOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// DeleteLocalPartitionResponse structure represents the NetrDfsDeleteLocalPartition operation response
type DeleteLocalPartitionResponse struct {
	// Return: The NetrDfsDeleteLocalPartition return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *DeleteLocalPartitionResponse) xxx_ToOp(ctx context.Context, op *xxx_DeleteLocalPartitionOperation) *xxx_DeleteLocalPartitionOperation {
	if op == nil {
		op = &xxx_DeleteLocalPartitionOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *DeleteLocalPartitionResponse) xxx_FromOp(ctx context.Context, op *xxx_DeleteLocalPartitionOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *DeleteLocalPartitionResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *DeleteLocalPartitionResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteLocalPartitionOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetLocalVolumeStateOperation structure represents the NetrDfsSetLocalVolumeState operation
type xxx_SetLocalVolumeStateOperation struct {
	ServerName string     `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	UID        *dtyp.GUID `idl:"name:Uid" json:"uid"`
	Prefix     string     `idl:"name:Prefix;string" json:"prefix"`
	State      uint32     `idl:"name:State" json:"state"`
	Return     uint32     `idl:"name:Return" json:"return"`
}

func (o *xxx_SetLocalVolumeStateOperation) OpNum() int { return 46 }

func (o *xxx_SetLocalVolumeStateOperation) OpName() string {
	return "/srvsvc/v3/NetrDfsSetLocalVolumeState"
}

func (o *xxx_SetLocalVolumeStateOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetLocalVolumeStateOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Uid {in} (1:{pointer=ref}*(1))(2:{alias=GUID}(struct))
	{
		if o.UID != nil {
			if err := o.UID.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Prefix {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.Prefix); err != nil {
			return err
		}
	}
	// State {in} (1:(uint32))
	{
		if err := w.WriteData(o.State); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetLocalVolumeStateOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Uid {in} (1:{pointer=ref}*(1))(2:{alias=GUID}(struct))
	{
		if o.UID == nil {
			o.UID = &dtyp.GUID{}
		}
		if err := o.UID.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Prefix {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.Prefix); err != nil {
			return err
		}
	}
	// State {in} (1:(uint32))
	{
		if err := w.ReadData(&o.State); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetLocalVolumeStateOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetLocalVolumeStateOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetLocalVolumeStateOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetLocalVolumeStateRequest structure represents the NetrDfsSetLocalVolumeState operation request
type SetLocalVolumeStateRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle (see [C706] sections
	// 4.3.5 and 5.1.5.2). The server MUST ignore this parameter.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// Uid: Specifies the GUID of the DFS share. This GUID MUST be obtained by using the
	// NetrDfsGetInfo (Opnum 4) method, as specified in [MS-DFSNM] section 3.1.4.1.6.
	UID *dtyp.GUID `idl:"name:Uid" json:"uid"`
	// Prefix: A pointer to a null-terminated UTF-16 string that specifies the path to the
	// DFS share.
	Prefix string `idl:"name:Prefix;string" json:"prefix"`
	// State: A DWORD that specifies the new state for the DFS share. To set the share to
	// offline, the State parameter MUST be (0x80). The State parameter MUST be set to any
	// other value to take the share online.
	State uint32 `idl:"name:State" json:"state"`
}

func (o *SetLocalVolumeStateRequest) xxx_ToOp(ctx context.Context, op *xxx_SetLocalVolumeStateOperation) *xxx_SetLocalVolumeStateOperation {
	if op == nil {
		op = &xxx_SetLocalVolumeStateOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.UID = o.UID
	op.Prefix = o.Prefix
	op.State = o.State
	return op
}

func (o *SetLocalVolumeStateRequest) xxx_FromOp(ctx context.Context, op *xxx_SetLocalVolumeStateOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.UID = op.UID
	o.Prefix = op.Prefix
	o.State = op.State
}
func (o *SetLocalVolumeStateRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetLocalVolumeStateRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetLocalVolumeStateOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetLocalVolumeStateResponse structure represents the NetrDfsSetLocalVolumeState operation response
type SetLocalVolumeStateResponse struct {
	// Return: The NetrDfsSetLocalVolumeState return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetLocalVolumeStateResponse) xxx_ToOp(ctx context.Context, op *xxx_SetLocalVolumeStateOperation) *xxx_SetLocalVolumeStateOperation {
	if op == nil {
		op = &xxx_SetLocalVolumeStateOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetLocalVolumeStateResponse) xxx_FromOp(ctx context.Context, op *xxx_SetLocalVolumeStateOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetLocalVolumeStateResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetLocalVolumeStateResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetLocalVolumeStateOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CreateExitPointOperation structure represents the NetrDfsCreateExitPoint operation
type xxx_CreateExitPointOperation struct {
	ServerName        string     `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	UID               *dtyp.GUID `idl:"name:Uid" json:"uid"`
	Prefix            string     `idl:"name:Prefix;string" json:"prefix"`
	Type              uint32     `idl:"name:Type" json:"type"`
	ShortPrefixLength uint32     `idl:"name:ShortPrefixLen" json:"short_prefix_length"`
	ShortPrefix       string     `idl:"name:ShortPrefix;size_is:(ShortPrefixLen)" json:"short_prefix"`
	Return            uint32     `idl:"name:Return" json:"return"`
}

func (o *xxx_CreateExitPointOperation) OpNum() int { return 48 }

func (o *xxx_CreateExitPointOperation) OpName() string { return "/srvsvc/v3/NetrDfsCreateExitPoint" }

func (o *xxx_CreateExitPointOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.ShortPrefixLength > uint32(32) {
		return fmt.Errorf("ShortPrefixLength is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateExitPointOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Uid {in} (1:{pointer=ref}*(1))(2:{alias=GUID}(struct))
	{
		if o.UID != nil {
			if err := o.UID.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Prefix {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.Prefix); err != nil {
			return err
		}
	}
	// Type {in} (1:(uint32))
	{
		if err := w.WriteData(o.Type); err != nil {
			return err
		}
	}
	// ShortPrefixLen {in} (1:{range=(0,32), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ShortPrefixLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateExitPointOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Uid {in} (1:{pointer=ref}*(1))(2:{alias=GUID}(struct))
	{
		if o.UID == nil {
			o.UID = &dtyp.GUID{}
		}
		if err := o.UID.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Prefix {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.Prefix); err != nil {
			return err
		}
	}
	// Type {in} (1:(uint32))
	{
		if err := w.ReadData(&o.Type); err != nil {
			return err
		}
	}
	// ShortPrefixLen {in} (1:{range=(0,32), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ShortPrefixLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateExitPointOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateExitPointOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ShortPrefix {out} (1:{pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,size_is=ShortPrefixLen,string](wchar))
	{
		dimSize1 := uint64(o.ShortPrefixLength)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		_ShortPrefix_buf := utf16.Encode([]rune(o.ShortPrefix))
		if uint64(len(_ShortPrefix_buf)) > sizeInfo[0] {
			_ShortPrefix_buf = _ShortPrefix_buf[:sizeInfo[0]]
		}
		for i1 := range _ShortPrefix_buf {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(_ShortPrefix_buf[i1]); err != nil {
				return err
			}
		}
		for i1 := len(_ShortPrefix_buf); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint16(0)); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateExitPointOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ShortPrefix {out} (1:{pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,size_is=ShortPrefixLen,string](wchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		var _ShortPrefix_buf []uint16
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array _ShortPrefix_buf", sizeInfo[0])
		}
		_ShortPrefix_buf = make([]uint16, sizeInfo[0])
		for i1 := range _ShortPrefix_buf {
			i1 := i1
			if err := w.ReadData(&_ShortPrefix_buf[i1]); err != nil {
				return err
			}
		}
		o.ShortPrefix = strings.TrimRight(string(utf16.Decode(_ShortPrefix_buf)), ndr.ZeroString)
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CreateExitPointRequest structure represents the NetrDfsCreateExitPoint operation request
type CreateExitPointRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle (see [C706] sections
	// 4.3.5 and 5.1.5.2). The server MUST ignore this parameter.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// Uid: Specifies the GUID for the DFS link. This GUID MUST be obtained by using the
	// NetrDfsGetInfo (Opnum 4) method, which is specified in [MS-DFSNM] section 3.1.4.1.6.
	UID *dtyp.GUID `idl:"name:Uid" json:"uid"`
	// Prefix: A pointer to a null-terminated UTF-16 string that specifies the path of the
	// DFS link.
	Prefix string `idl:"name:Prefix;string" json:"prefix"`
	// Type: This parameter MUST be one of the values that are specified in section 2.2.2.13.
	Type uint32 `idl:"name:Type" json:"type"`
	// ShortPrefixLen: Specifies the size of the buffer passed in the ShortPrefix. The value
	// of this field MUST be within the range 0 through 32, inclusive.
	ShortPrefixLength uint32 `idl:"name:ShortPrefixLen" json:"short_prefix_length"`
}

func (o *CreateExitPointRequest) xxx_ToOp(ctx context.Context, op *xxx_CreateExitPointOperation) *xxx_CreateExitPointOperation {
	if op == nil {
		op = &xxx_CreateExitPointOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.UID = o.UID
	op.Prefix = o.Prefix
	op.Type = o.Type
	op.ShortPrefixLength = o.ShortPrefixLength
	return op
}

func (o *CreateExitPointRequest) xxx_FromOp(ctx context.Context, op *xxx_CreateExitPointOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.UID = op.UID
	o.Prefix = op.Prefix
	o.Type = op.Type
	o.ShortPrefixLength = op.ShortPrefixLength
}
func (o *CreateExitPointRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *CreateExitPointRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateExitPointOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CreateExitPointResponse structure represents the NetrDfsCreateExitPoint operation response
type CreateExitPointResponse struct {
	// XXX: ShortPrefixLen is an implicit input depedency for output parameters
	ShortPrefixLength uint32 `idl:"name:ShortPrefixLen" json:"short_prefix_length"`

	// ShortPrefix: A pointer to a null-terminated UTF-16 string that is the buffer where
	// the name of the DFS namespace root or link is returned.<147>
	ShortPrefix string `idl:"name:ShortPrefix;size_is:(ShortPrefixLen)" json:"short_prefix"`
	// Return: The NetrDfsCreateExitPoint return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CreateExitPointResponse) xxx_ToOp(ctx context.Context, op *xxx_CreateExitPointOperation) *xxx_CreateExitPointOperation {
	if op == nil {
		op = &xxx_CreateExitPointOperation{}
	}
	if o == nil {
		return op
	}
	// XXX: implicit input dependencies for output parameters
	if op.ShortPrefixLength == uint32(0) {
		op.ShortPrefixLength = o.ShortPrefixLength
	}

	op.ShortPrefix = o.ShortPrefix
	op.Return = o.Return
	return op
}

func (o *CreateExitPointResponse) xxx_FromOp(ctx context.Context, op *xxx_CreateExitPointOperation) {
	if o == nil {
		return
	}
	// XXX: implicit input dependencies for output parameters
	o.ShortPrefixLength = op.ShortPrefixLength

	o.ShortPrefix = op.ShortPrefix
	o.Return = op.Return
}
func (o *CreateExitPointResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *CreateExitPointResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateExitPointOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_DeleteExitPointOperation structure represents the NetrDfsDeleteExitPoint operation
type xxx_DeleteExitPointOperation struct {
	ServerName string     `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	UID        *dtyp.GUID `idl:"name:Uid" json:"uid"`
	Prefix     string     `idl:"name:Prefix;string" json:"prefix"`
	Type       uint32     `idl:"name:Type" json:"type"`
	Return     uint32     `idl:"name:Return" json:"return"`
}

func (o *xxx_DeleteExitPointOperation) OpNum() int { return 49 }

func (o *xxx_DeleteExitPointOperation) OpName() string { return "/srvsvc/v3/NetrDfsDeleteExitPoint" }

func (o *xxx_DeleteExitPointOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteExitPointOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Uid {in} (1:{pointer=ref}*(1))(2:{alias=GUID}(struct))
	{
		if o.UID != nil {
			if err := o.UID.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Prefix {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.Prefix); err != nil {
			return err
		}
	}
	// Type {in} (1:(uint32))
	{
		if err := w.WriteData(o.Type); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteExitPointOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Uid {in} (1:{pointer=ref}*(1))(2:{alias=GUID}(struct))
	{
		if o.UID == nil {
			o.UID = &dtyp.GUID{}
		}
		if err := o.UID.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Prefix {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.Prefix); err != nil {
			return err
		}
	}
	// Type {in} (1:(uint32))
	{
		if err := w.ReadData(&o.Type); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteExitPointOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteExitPointOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteExitPointOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// DeleteExitPointRequest structure represents the NetrDfsDeleteExitPoint operation request
type DeleteExitPointRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) point that identifies the server.
	// The client MUST map this structure to an RPC binding handle (see [C706] sections
	// 4.3.5 and 5.1.5.2). The server MUST ignore this parameter.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// Uid: Specifies the GUID that corresponds to the DFS link that is specified by the
	// Prefix parameter. This GUID MUST be obtained by using the NetrDfsGetInfo (Opnum 4)
	// method, specified in [MS-DFSNM] section 3.1.4.1.6.
	UID *dtyp.GUID `idl:"name:Uid" json:"uid"`
	// Prefix: A pointer to a null-terminated UTF-16 string that specifies the path of the
	// DFS link.
	Prefix string `idl:"name:Prefix;string" json:"prefix"`
	// Type: This parameter MUST be one of the values listed in section 2.2.2.13.
	Type uint32 `idl:"name:Type" json:"type"`
}

func (o *DeleteExitPointRequest) xxx_ToOp(ctx context.Context, op *xxx_DeleteExitPointOperation) *xxx_DeleteExitPointOperation {
	if op == nil {
		op = &xxx_DeleteExitPointOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.UID = o.UID
	op.Prefix = o.Prefix
	op.Type = o.Type
	return op
}

func (o *DeleteExitPointRequest) xxx_FromOp(ctx context.Context, op *xxx_DeleteExitPointOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.UID = op.UID
	o.Prefix = op.Prefix
	o.Type = op.Type
}
func (o *DeleteExitPointRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *DeleteExitPointRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteExitPointOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// DeleteExitPointResponse structure represents the NetrDfsDeleteExitPoint operation response
type DeleteExitPointResponse struct {
	// Return: The NetrDfsDeleteExitPoint return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *DeleteExitPointResponse) xxx_ToOp(ctx context.Context, op *xxx_DeleteExitPointOperation) *xxx_DeleteExitPointOperation {
	if op == nil {
		op = &xxx_DeleteExitPointOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *DeleteExitPointResponse) xxx_FromOp(ctx context.Context, op *xxx_DeleteExitPointOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *DeleteExitPointResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *DeleteExitPointResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteExitPointOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ModifyPrefixOperation structure represents the NetrDfsModifyPrefix operation
type xxx_ModifyPrefixOperation struct {
	ServerName string     `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	UID        *dtyp.GUID `idl:"name:Uid" json:"uid"`
	Prefix     string     `idl:"name:Prefix;string" json:"prefix"`
	Return     uint32     `idl:"name:Return" json:"return"`
}

func (o *xxx_ModifyPrefixOperation) OpNum() int { return 50 }

func (o *xxx_ModifyPrefixOperation) OpName() string { return "/srvsvc/v3/NetrDfsModifyPrefix" }

func (o *xxx_ModifyPrefixOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ModifyPrefixOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Uid {in} (1:{pointer=ref}*(1))(2:{alias=GUID}(struct))
	{
		if o.UID != nil {
			if err := o.UID.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Prefix {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.Prefix); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ModifyPrefixOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Uid {in} (1:{pointer=ref}*(1))(2:{alias=GUID}(struct))
	{
		if o.UID == nil {
			o.UID = &dtyp.GUID{}
		}
		if err := o.UID.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Prefix {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.Prefix); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ModifyPrefixOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ModifyPrefixOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ModifyPrefixOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ModifyPrefixRequest structure represents the NetrDfsModifyPrefix operation request
type ModifyPrefixRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle (see [C706] sections
	// 4.3.5 and 5.1.5.2). The server MUST ignore this parameter.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// Uid: Specifies the GUID that corresponds to the DFS link that needs to be changed.
	// This GUID MUST be obtained by using the NetrDfsGetInfo (Opnum 4) method, specified
	// in [MS-DFSNM] section 3.1.4.1.6.
	UID *dtyp.GUID `idl:"name:Uid" json:"uid"`
	// Prefix: A pointer to a null-terminated UTF-16 string that specifies the path of the
	// updated DFS link.
	Prefix string `idl:"name:Prefix;string" json:"prefix"`
}

func (o *ModifyPrefixRequest) xxx_ToOp(ctx context.Context, op *xxx_ModifyPrefixOperation) *xxx_ModifyPrefixOperation {
	if op == nil {
		op = &xxx_ModifyPrefixOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.UID = o.UID
	op.Prefix = o.Prefix
	return op
}

func (o *ModifyPrefixRequest) xxx_FromOp(ctx context.Context, op *xxx_ModifyPrefixOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.UID = op.UID
	o.Prefix = op.Prefix
}
func (o *ModifyPrefixRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *ModifyPrefixRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ModifyPrefixOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ModifyPrefixResponse structure represents the NetrDfsModifyPrefix operation response
type ModifyPrefixResponse struct {
	// Return: The NetrDfsModifyPrefix return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ModifyPrefixResponse) xxx_ToOp(ctx context.Context, op *xxx_ModifyPrefixOperation) *xxx_ModifyPrefixOperation {
	if op == nil {
		op = &xxx_ModifyPrefixOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *ModifyPrefixResponse) xxx_FromOp(ctx context.Context, op *xxx_ModifyPrefixOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *ModifyPrefixResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *ModifyPrefixResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ModifyPrefixOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_FixLocalVolumeOperation structure represents the NetrDfsFixLocalVolume operation
type xxx_FixLocalVolumeOperation struct {
	ServerName        string                  `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	VolumeName        string                  `idl:"name:VolumeName;string" json:"volume_name"`
	EntryType         uint32                  `idl:"name:EntryType" json:"entry_type"`
	ServiceType       uint32                  `idl:"name:ServiceType" json:"service_type"`
	StorageID         string                  `idl:"name:StgId;string" json:"storage_id"`
	EntryUID          *dtyp.GUID              `idl:"name:EntryUid" json:"entry_uid"`
	EntryPrefix       string                  `idl:"name:EntryPrefix;string" json:"entry_prefix"`
	RelationInfo      *NetDFSEntryIDContainer `idl:"name:RelationInfo" json:"relation_info"`
	CreateDisposition uint32                  `idl:"name:CreateDisposition" json:"create_disposition"`
	Return            uint32                  `idl:"name:Return" json:"return"`
}

func (o *xxx_FixLocalVolumeOperation) OpNum() int { return 51 }

func (o *xxx_FixLocalVolumeOperation) OpName() string { return "/srvsvc/v3/NetrDfsFixLocalVolume" }

func (o *xxx_FixLocalVolumeOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FixLocalVolumeOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// VolumeName {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.VolumeName); err != nil {
			return err
		}
	}
	// EntryType {in} (1:(uint32))
	{
		if err := w.WriteData(o.EntryType); err != nil {
			return err
		}
	}
	// ServiceType {in} (1:(uint32))
	{
		if err := w.WriteData(o.ServiceType); err != nil {
			return err
		}
	}
	// StgId {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.StorageID); err != nil {
			return err
		}
	}
	// EntryUid {in} (1:{pointer=ref}*(1))(2:{alias=GUID}(struct))
	{
		if o.EntryUID != nil {
			if err := o.EntryUID.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// EntryPrefix {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.EntryPrefix); err != nil {
			return err
		}
	}
	// RelationInfo {in} (1:{alias=LPNET_DFS_ENTRY_ID_CONTAINER}*(1))(2:{alias=NET_DFS_ENTRY_ID_CONTAINER}(struct))
	{
		if o.RelationInfo != nil {
			if err := o.RelationInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&NetDFSEntryIDContainer{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// CreateDisposition {in} (1:(uint32))
	{
		if err := w.WriteData(o.CreateDisposition); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FixLocalVolumeOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// VolumeName {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.VolumeName); err != nil {
			return err
		}
	}
	// EntryType {in} (1:(uint32))
	{
		if err := w.ReadData(&o.EntryType); err != nil {
			return err
		}
	}
	// ServiceType {in} (1:(uint32))
	{
		if err := w.ReadData(&o.ServiceType); err != nil {
			return err
		}
	}
	// StgId {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.StorageID); err != nil {
			return err
		}
	}
	// EntryUid {in} (1:{pointer=ref}*(1))(2:{alias=GUID}(struct))
	{
		if o.EntryUID == nil {
			o.EntryUID = &dtyp.GUID{}
		}
		if err := o.EntryUID.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// EntryPrefix {in} (1:{string, pointer=ref}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.EntryPrefix); err != nil {
			return err
		}
	}
	// RelationInfo {in} (1:{alias=LPNET_DFS_ENTRY_ID_CONTAINER,pointer=ref}*(1))(2:{alias=NET_DFS_ENTRY_ID_CONTAINER}(struct))
	{
		if o.RelationInfo == nil {
			o.RelationInfo = &NetDFSEntryIDContainer{}
		}
		if err := o.RelationInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// CreateDisposition {in} (1:(uint32))
	{
		if err := w.ReadData(&o.CreateDisposition); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FixLocalVolumeOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FixLocalVolumeOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FixLocalVolumeOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// FixLocalVolumeRequest structure represents the NetrDfsFixLocalVolume operation request
type FixLocalVolumeRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle (see [C706] sections
	// 4.3.5 and 5.1.5.2). The server MUST ignore this parameter.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// VolumeName: A pointer to a null-terminated UTF-16 string that specifies the target
	// for the DFS root share. This target MUST be local to the server; for example, \??\C:\DfsShare.<160>
	// This target SHOULD NOT contain a directory that is in DFS, and it SHOULD NOT be a
	// child of a DFS share. If the specified volume name is not valid, the server SHOULD
	// fail the call by using an implementation-specific error code.
	VolumeName string `idl:"name:VolumeName;string" json:"volume_name"`
	// EntryType: This parameter MUST be one of the values listed in section 2.2.2.13. If
	// the specified entry type is not valid, the server SHOULD fail the call with an implementation-specific
	// error code.
	EntryType uint32 `idl:"name:EntryType" json:"entry_type"`
	// ServiceType: This parameter MUST be a combination of one or more of the following
	// values. If the specified service type is not valid, the server SHOULD fail the call
	// with an implementation-specific error code.
	//
	//	+-----------------------------------------+--------------------------------+
	//	|                                         |                                |
	//	|                  VALUE                  |            MEANING             |
	//	|                                         |                                |
	//	+-----------------------------------------+--------------------------------+
	//	+-----------------------------------------+--------------------------------+
	//	| DFS_SERVICE_TYPE_MASTER 0x00000001      | Master service                 |
	//	+-----------------------------------------+--------------------------------+
	//	| DFS_SERVICE_TYPE_READONLY 0x00000002    | Read-only service              |
	//	+-----------------------------------------+--------------------------------+
	//	| DFS_SERVICE_TYPE_LOCAL 0x00000004       | Local service                  |
	//	+-----------------------------------------+--------------------------------+
	//	| DFS_SERVICE_TYPE_REFERRAL 0x00000008    | Referral service               |
	//	+-----------------------------------------+--------------------------------+
	//	| DFS_SERVICE_TYPE_ACTIVE 0x000000010     | Active service                 |
	//	+-----------------------------------------+--------------------------------+
	//	| DFS_SERVICE_TYPE_DOWN_LEVEL 0x000000020 | Down-level service             |
	//	+-----------------------------------------+--------------------------------+
	//	| DFS_SERVICE_TYPE_COSTLIER 0x000000040   | Costlier service than previous |
	//	+-----------------------------------------+--------------------------------+
	//	| DFS_SERVICE_TYPE_OFFLINE 0x000000080    | Service is offline             |
	//	+-----------------------------------------+--------------------------------+
	ServiceType uint32 `idl:"name:ServiceType" json:"service_type"`
	// StgId: A pointer to a variable that specifies an ID for the local storage. The server
	// MUST ignore the value that is passed in for the StgId parameter.
	StorageID string `idl:"name:StgId;string" json:"storage_id"`
	// EntryUid: Specifies the GUID that corresponds to the DFS share. This GUID MUST be
	// obtained by using the NetrDfsGetInfo (Opnum 4) method, which is specified in [MS-DFSNM]
	// section 3.1.4.1.6.
	EntryUID *dtyp.GUID `idl:"name:EntryUid" json:"entry_uid"`
	// EntryPrefix: A pointer to a null-terminated UTF-16 string that specifies the path
	// of the DFS share to be updated.
	EntryPrefix string `idl:"name:EntryPrefix;string" json:"entry_prefix"`
	// RelationInfo: A pointer to a NET_DFS_ENTRY_ID_CONTAINER structure as specified in
	// section 2.2.4.108. Specifies the DFS child links under the DFS share as specified
	// by the EntryPrefix parameter.
	RelationInfo *NetDFSEntryIDContainer `idl:"name:RelationInfo" json:"relation_info"`
	// CreateDisposition: Specifies what to do, depending on whether the share already exists.
	// This field MUST be set to one of the following values.
	//
	//	+---------------------------+----------------------------------------------------------------------------------+
	//	|                           |                                                                                  |
	//	|           VALUE           |                                     MEANING                                      |
	//	|                           |                                                                                  |
	//	+---------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------+----------------------------------------------------------------------------------+
	//	| FILE_SUPERSEDE 0x00000000 | If the share already exists, replace it with the specified share. If it does not |
	//	|                           | exist, create the specified share.                                               |
	//	+---------------------------+----------------------------------------------------------------------------------+
	//	| FILE_OPEN 0x00000001      | If the share already exists, fail the request and do not create or open the      |
	//	|                           | specified share. If it does not exist, create the specified share.               |
	//	+---------------------------+----------------------------------------------------------------------------------+
	//	| FILE_CREATE 0x00000002    | If the file already exists, open it instead of creating a new share. If it does  |
	//	|                           | not exist, fail the request and do not create a new share.                       |
	//	+---------------------------+----------------------------------------------------------------------------------+
	CreateDisposition uint32 `idl:"name:CreateDisposition" json:"create_disposition"`
}

func (o *FixLocalVolumeRequest) xxx_ToOp(ctx context.Context, op *xxx_FixLocalVolumeOperation) *xxx_FixLocalVolumeOperation {
	if op == nil {
		op = &xxx_FixLocalVolumeOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.VolumeName = o.VolumeName
	op.EntryType = o.EntryType
	op.ServiceType = o.ServiceType
	op.StorageID = o.StorageID
	op.EntryUID = o.EntryUID
	op.EntryPrefix = o.EntryPrefix
	op.RelationInfo = o.RelationInfo
	op.CreateDisposition = o.CreateDisposition
	return op
}

func (o *FixLocalVolumeRequest) xxx_FromOp(ctx context.Context, op *xxx_FixLocalVolumeOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.VolumeName = op.VolumeName
	o.EntryType = op.EntryType
	o.ServiceType = op.ServiceType
	o.StorageID = op.StorageID
	o.EntryUID = op.EntryUID
	o.EntryPrefix = op.EntryPrefix
	o.RelationInfo = op.RelationInfo
	o.CreateDisposition = op.CreateDisposition
}
func (o *FixLocalVolumeRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *FixLocalVolumeRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_FixLocalVolumeOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// FixLocalVolumeResponse structure represents the NetrDfsFixLocalVolume operation response
type FixLocalVolumeResponse struct {
	// Return: The NetrDfsFixLocalVolume return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *FixLocalVolumeResponse) xxx_ToOp(ctx context.Context, op *xxx_FixLocalVolumeOperation) *xxx_FixLocalVolumeOperation {
	if op == nil {
		op = &xxx_FixLocalVolumeOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *FixLocalVolumeResponse) xxx_FromOp(ctx context.Context, op *xxx_FixLocalVolumeOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *FixLocalVolumeResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *FixLocalVolumeResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_FixLocalVolumeOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ManagerReportSiteInfoOperation structure represents the NetrDfsManagerReportSiteInfo operation
type xxx_ManagerReportSiteInfoOperation struct {
	ServerName string        `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	SiteInfo   *SiteListInfo `idl:"name:ppSiteInfo;pointer:unique" json:"site_info"`
	Return     uint32        `idl:"name:Return" json:"return"`
}

func (o *xxx_ManagerReportSiteInfoOperation) OpNum() int { return 52 }

func (o *xxx_ManagerReportSiteInfoOperation) OpName() string {
	return "/srvsvc/v3/NetrDfsManagerReportSiteInfo"
}

func (o *xxx_ManagerReportSiteInfoOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ManagerReportSiteInfoOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ppSiteInfo {in, out} (1:{pointer=unique}*(2))(2:{alias=LPDFS_SITELIST_INFO}*(1))(3:{alias=DFS_SITELIST_INFO}(struct))
	{
		if o.SiteInfo != nil {
			_ptr_ppSiteInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.SiteInfo != nil {
					_ptr_ppSiteInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
						if o.SiteInfo != nil {
							if err := o.SiteInfo.MarshalNDR(ctx, w); err != nil {
								return err
							}
						} else {
							if err := (&SiteListInfo{}).MarshalNDR(ctx, w); err != nil {
								return err
							}
						}
						return nil
					})
					if err := w.WritePointer(&o.SiteInfo, _ptr_ppSiteInfo); err != nil {
						return err
					}
				} else {
					if err := w.WritePointer(nil); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.SiteInfo, _ptr_ppSiteInfo); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ManagerReportSiteInfoOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ppSiteInfo {in, out} (1:{pointer=unique}*(2))(2:{alias=LPDFS_SITELIST_INFO,pointer=ref}*(1))(3:{alias=DFS_SITELIST_INFO}(struct))
	{
		_ptr_ppSiteInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			_ptr_ppSiteInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
				if o.SiteInfo == nil {
					o.SiteInfo = &SiteListInfo{}
				}
				if err := o.SiteInfo.UnmarshalNDR(ctx, w); err != nil {
					return err
				}
				return nil
			})
			_s_ppSiteInfo := func(ptr interface{}) { o.SiteInfo = *ptr.(**SiteListInfo) }
			if err := w.ReadPointer(&o.SiteInfo, _s_ppSiteInfo, _ptr_ppSiteInfo); err != nil {
				return err
			}
			return nil
		})
		_s_ppSiteInfo := func(ptr interface{}) { o.SiteInfo = *ptr.(**SiteListInfo) }
		if err := w.ReadPointer(&o.SiteInfo, _s_ppSiteInfo, _ptr_ppSiteInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ManagerReportSiteInfoOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ManagerReportSiteInfoOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ppSiteInfo {in, out} (1:{pointer=unique}*(2))(2:{alias=LPDFS_SITELIST_INFO}*(1))(3:{alias=DFS_SITELIST_INFO}(struct))
	{
		if o.SiteInfo != nil {
			_ptr_ppSiteInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.SiteInfo != nil {
					_ptr_ppSiteInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
						if o.SiteInfo != nil {
							if err := o.SiteInfo.MarshalNDR(ctx, w); err != nil {
								return err
							}
						} else {
							if err := (&SiteListInfo{}).MarshalNDR(ctx, w); err != nil {
								return err
							}
						}
						return nil
					})
					if err := w.WritePointer(&o.SiteInfo, _ptr_ppSiteInfo); err != nil {
						return err
					}
				} else {
					if err := w.WritePointer(nil); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.SiteInfo, _ptr_ppSiteInfo); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ManagerReportSiteInfoOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ppSiteInfo {in, out} (1:{pointer=unique}*(2))(2:{alias=LPDFS_SITELIST_INFO,pointer=ref}*(1))(3:{alias=DFS_SITELIST_INFO}(struct))
	{
		_ptr_ppSiteInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			_ptr_ppSiteInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
				if o.SiteInfo == nil {
					o.SiteInfo = &SiteListInfo{}
				}
				if err := o.SiteInfo.UnmarshalNDR(ctx, w); err != nil {
					return err
				}
				return nil
			})
			_s_ppSiteInfo := func(ptr interface{}) { o.SiteInfo = *ptr.(**SiteListInfo) }
			if err := w.ReadPointer(&o.SiteInfo, _s_ppSiteInfo, _ptr_ppSiteInfo); err != nil {
				return err
			}
			return nil
		})
		_s_ppSiteInfo := func(ptr interface{}) { o.SiteInfo = *ptr.(**SiteListInfo) }
		if err := w.ReadPointer(&o.SiteInfo, _s_ppSiteInfo, _ptr_ppSiteInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ManagerReportSiteInfoRequest structure represents the NetrDfsManagerReportSiteInfo operation request
type ManagerReportSiteInfoRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle (see [C706] sections
	// 4.3.5 and 5.1.5.2).
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// ppSiteInfo: A pointer to an LPDFS_SITELIST_INFO structure, which in turn points to
	// the location of a DFS_SITELIST_INFO structure in which the information is returned.
	SiteInfo *SiteListInfo `idl:"name:ppSiteInfo;pointer:unique" json:"site_info"`
}

func (o *ManagerReportSiteInfoRequest) xxx_ToOp(ctx context.Context, op *xxx_ManagerReportSiteInfoOperation) *xxx_ManagerReportSiteInfoOperation {
	if op == nil {
		op = &xxx_ManagerReportSiteInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.SiteInfo = o.SiteInfo
	return op
}

func (o *ManagerReportSiteInfoRequest) xxx_FromOp(ctx context.Context, op *xxx_ManagerReportSiteInfoOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.SiteInfo = op.SiteInfo
}
func (o *ManagerReportSiteInfoRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *ManagerReportSiteInfoRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ManagerReportSiteInfoOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ManagerReportSiteInfoResponse structure represents the NetrDfsManagerReportSiteInfo operation response
type ManagerReportSiteInfoResponse struct {
	// ppSiteInfo: A pointer to an LPDFS_SITELIST_INFO structure, which in turn points to
	// the location of a DFS_SITELIST_INFO structure in which the information is returned.
	SiteInfo *SiteListInfo `idl:"name:ppSiteInfo;pointer:unique" json:"site_info"`
	// Return: The NetrDfsManagerReportSiteInfo return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ManagerReportSiteInfoResponse) xxx_ToOp(ctx context.Context, op *xxx_ManagerReportSiteInfoOperation) *xxx_ManagerReportSiteInfoOperation {
	if op == nil {
		op = &xxx_ManagerReportSiteInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.SiteInfo = o.SiteInfo
	op.Return = o.Return
	return op
}

func (o *ManagerReportSiteInfoResponse) xxx_FromOp(ctx context.Context, op *xxx_ManagerReportSiteInfoOperation) {
	if o == nil {
		return
	}
	o.SiteInfo = op.SiteInfo
	o.Return = op.Return
}
func (o *ManagerReportSiteInfoResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *ManagerReportSiteInfoResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ManagerReportSiteInfoOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_TransportDeleteExOperation structure represents the NetrServerTransportDelEx operation
type xxx_TransportDeleteExOperation struct {
	ServerName string         `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	Level      uint32         `idl:"name:Level" json:"level"`
	Buffer     *TransportInfo `idl:"name:Buffer;switch_is:Level" json:"buffer"`
	Return     uint32         `idl:"name:Return" json:"return"`
}

func (o *xxx_TransportDeleteExOperation) OpNum() int { return 53 }

func (o *xxx_TransportDeleteExOperation) OpName() string {
	return "/srvsvc/v3/NetrServerTransportDelEx"
}

func (o *xxx_TransportDeleteExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_TransportDeleteExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Level); err != nil {
			return err
		}
	}
	// Buffer {in} (1:{switch_type={}(uint32), alias=LPTRANSPORT_INFO}*(1))(2:{switch_type={}(uint32), alias=TRANSPORT_INFO}(union))
	{
		_swBuffer := uint32(o.Level)
		if o.Buffer != nil {
			if err := o.Buffer.MarshalUnionNDR(ctx, w, _swBuffer); err != nil {
				return err
			}
		} else {
			if err := (&TransportInfo{}).MarshalUnionNDR(ctx, w, _swBuffer); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_TransportDeleteExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Level); err != nil {
			return err
		}
	}
	// Buffer {in} (1:{switch_type={}(uint32), alias=LPTRANSPORT_INFO,pointer=ref}*(1))(2:{switch_type={}(uint32), alias=TRANSPORT_INFO}(union))
	{
		if o.Buffer == nil {
			o.Buffer = &TransportInfo{}
		}
		_swBuffer := uint32(o.Level)
		if err := o.Buffer.UnmarshalUnionNDR(ctx, w, _swBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_TransportDeleteExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_TransportDeleteExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_TransportDeleteExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// TransportDeleteExRequest structure represents the NetrServerTransportDelEx operation request
type TransportDeleteExRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle (see [C706] sections
	// 4.3.5 and 5.1.5.2). The server MUST ignore this parameter.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// Level: Specifies the information level of the data. It MUST be one of the following
	// values.
	//
	//	+-------+------------------------------------------------------+
	//	|       |                                                      |
	//	| VALUE |                       MEANING                        |
	//	|       |                                                      |
	//	+-------+------------------------------------------------------+
	//	+-------+------------------------------------------------------+
	//	|     0 | The buffer is of type SERVER_XPORT_INFO_0_CONTAINER. |
	//	+-------+------------------------------------------------------+
	//	|     1 | The buffer is of type SERVER_XPORT_INFO_1_CONTAINER. |
	//	+-------+------------------------------------------------------+
	Level uint32 `idl:"name:Level" json:"level"`
	// Buffer: A pointer to the TRANSPORT_INFO union that contains information about the
	// transport. The value of the Level parameter determines the type of the contents of
	// the Buffer parameter, as the preceding table shows.
	Buffer *TransportInfo `idl:"name:Buffer;switch_is:Level" json:"buffer"`
}

func (o *TransportDeleteExRequest) xxx_ToOp(ctx context.Context, op *xxx_TransportDeleteExOperation) *xxx_TransportDeleteExOperation {
	if op == nil {
		op = &xxx_TransportDeleteExOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.Level = o.Level
	op.Buffer = o.Buffer
	return op
}

func (o *TransportDeleteExRequest) xxx_FromOp(ctx context.Context, op *xxx_TransportDeleteExOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.Level = op.Level
	o.Buffer = op.Buffer
}
func (o *TransportDeleteExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *TransportDeleteExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_TransportDeleteExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// TransportDeleteExResponse structure represents the NetrServerTransportDelEx operation response
type TransportDeleteExResponse struct {
	// Return: The NetrServerTransportDelEx return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *TransportDeleteExResponse) xxx_ToOp(ctx context.Context, op *xxx_TransportDeleteExOperation) *xxx_TransportDeleteExOperation {
	if op == nil {
		op = &xxx_TransportDeleteExOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *TransportDeleteExResponse) xxx_FromOp(ctx context.Context, op *xxx_TransportDeleteExOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *TransportDeleteExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *TransportDeleteExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_TransportDeleteExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AliasAddOperation structure represents the NetrServerAliasAdd operation
type xxx_AliasAddOperation struct {
	ServerName string           `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	Level      uint32           `idl:"name:Level" json:"level"`
	Info       *ServerAliasInfo `idl:"name:InfoStruct;switch_is:Level" json:"info"`
	Return     uint32           `idl:"name:Return" json:"return"`
}

func (o *xxx_AliasAddOperation) OpNum() int { return 54 }

func (o *xxx_AliasAddOperation) OpName() string { return "/srvsvc/v3/NetrServerAliasAdd" }

func (o *xxx_AliasAddOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AliasAddOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Level); err != nil {
			return err
		}
	}
	// InfoStruct {in} (1:{switch_type={}(uint32), alias=LPSERVER_ALIAS_INFO}*(1))(2:{switch_type={}(uint32), alias=SERVER_ALIAS_INFO}(union))
	{
		_swInfo := uint32(o.Level)
		if o.Info != nil {
			if err := o.Info.MarshalUnionNDR(ctx, w, _swInfo); err != nil {
				return err
			}
		} else {
			if err := (&ServerAliasInfo{}).MarshalUnionNDR(ctx, w, _swInfo); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AliasAddOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Level); err != nil {
			return err
		}
	}
	// InfoStruct {in} (1:{switch_type={}(uint32), alias=LPSERVER_ALIAS_INFO,pointer=ref}*(1))(2:{switch_type={}(uint32), alias=SERVER_ALIAS_INFO}(union))
	{
		if o.Info == nil {
			o.Info = &ServerAliasInfo{}
		}
		_swInfo := uint32(o.Level)
		if err := o.Info.UnmarshalUnionNDR(ctx, w, _swInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AliasAddOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AliasAddOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AliasAddOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AliasAddRequest structure represents the NetrServerAliasAdd operation request
type AliasAddRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) that identifies the server. The client
	// MUST map this structure to an RPC binding handle (see [C706] sections 4.3.5 and 5.1.5.2).
	// The server MUST ignore this parameter.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// Level: Specifies the information level of the data. It MUST be one of the following
	// values.
	//
	//	+-------+------------------------------------------------------+
	//	|       |                                                      |
	//	| VALUE |                       MEANING                        |
	//	|       |                                                      |
	//	+-------+------------------------------------------------------+
	//	+-------+------------------------------------------------------+
	//	|     0 | The buffer is of type SERVER_ALIAS_INFO_0_CONTAINER. |
	//	+-------+------------------------------------------------------+
	Level uint32 `idl:"name:Level" json:"level"`
	// InfoStruct: A pointer to the SERVER_ALIAS_INFO union that contains information about
	// the alias. The value of the Level parameter determines the type of the contents of
	// the InfoStruct parameter, as the preceding table shows.
	Info *ServerAliasInfo `idl:"name:InfoStruct;switch_is:Level" json:"info"`
}

func (o *AliasAddRequest) xxx_ToOp(ctx context.Context, op *xxx_AliasAddOperation) *xxx_AliasAddOperation {
	if op == nil {
		op = &xxx_AliasAddOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.Level = o.Level
	op.Info = o.Info
	return op
}

func (o *AliasAddRequest) xxx_FromOp(ctx context.Context, op *xxx_AliasAddOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.Level = op.Level
	o.Info = op.Info
}
func (o *AliasAddRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *AliasAddRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AliasAddOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AliasAddResponse structure represents the NetrServerAliasAdd operation response
type AliasAddResponse struct {
	// Return: The NetrServerAliasAdd return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AliasAddResponse) xxx_ToOp(ctx context.Context, op *xxx_AliasAddOperation) *xxx_AliasAddOperation {
	if op == nil {
		op = &xxx_AliasAddOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *AliasAddResponse) xxx_FromOp(ctx context.Context, op *xxx_AliasAddOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *AliasAddResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *AliasAddResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AliasAddOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AliasEnumOperation structure represents the NetrServerAliasEnum operation
type xxx_AliasEnumOperation struct {
	ServerName             string           `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	Info                   *ServerAliasEnum `idl:"name:InfoStruct" json:"info"`
	PreferredMaximumLength uint32           `idl:"name:PreferedMaximumLength" json:"preferred_maximum_length"`
	TotalEntries           uint32           `idl:"name:TotalEntries" json:"total_entries"`
	Resume                 uint32           `idl:"name:ResumeHandle;pointer:unique" json:"resume"`
	Return                 uint32           `idl:"name:Return" json:"return"`
}

func (o *xxx_AliasEnumOperation) OpNum() int { return 55 }

func (o *xxx_AliasEnumOperation) OpName() string { return "/srvsvc/v3/NetrServerAliasEnum" }

func (o *xxx_AliasEnumOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AliasEnumOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// InfoStruct {in, out} (1:{alias=LPSERVER_ALIAS_ENUM_STRUCT}*(1))(2:{alias=SERVER_ALIAS_ENUM_STRUCT}(struct))
	{
		if o.Info != nil {
			if err := o.Info.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerAliasEnum{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// PreferedMaximumLength {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PreferredMaximumLength); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ResumeHandle := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.Resume); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Resume, _ptr_ResumeHandle); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AliasEnumOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// InfoStruct {in, out} (1:{alias=LPSERVER_ALIAS_ENUM_STRUCT,pointer=ref}*(1))(2:{alias=SERVER_ALIAS_ENUM_STRUCT}(struct))
	{
		if o.Info == nil {
			o.Info = &ServerAliasEnum{}
		}
		if err := o.Info.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// PreferedMaximumLength {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PreferredMaximumLength); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ResumeHandle := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.Resume); err != nil {
				return err
			}
			return nil
		})
		_s_ResumeHandle := func(ptr interface{}) { o.Resume = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.Resume, _s_ResumeHandle, _ptr_ResumeHandle); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AliasEnumOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AliasEnumOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// InfoStruct {in, out} (1:{alias=LPSERVER_ALIAS_ENUM_STRUCT}*(1))(2:{alias=SERVER_ALIAS_ENUM_STRUCT}(struct))
	{
		if o.Info != nil {
			if err := o.Info.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerAliasEnum{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// TotalEntries {out} (1:{alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.TotalEntries); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ResumeHandle := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := w.WriteData(o.Resume); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Resume, _ptr_ResumeHandle); err != nil {
			return err
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AliasEnumOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// InfoStruct {in, out} (1:{alias=LPSERVER_ALIAS_ENUM_STRUCT,pointer=ref}*(1))(2:{alias=SERVER_ALIAS_ENUM_STRUCT}(struct))
	{
		if o.Info == nil {
			o.Info = &ServerAliasEnum{}
		}
		if err := o.Info.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// TotalEntries {out} (1:{alias=LPDWORD,pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.TotalEntries); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=unique, alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		_ptr_ResumeHandle := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := w.ReadData(&o.Resume); err != nil {
				return err
			}
			return nil
		})
		_s_ResumeHandle := func(ptr interface{}) { o.Resume = *ptr.(*uint32) }
		if err := w.ReadPointer(&o.Resume, _s_ResumeHandle, _ptr_ResumeHandle); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AliasEnumRequest structure represents the NetrServerAliasEnum operation request
type AliasEnumRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle (see [C706] sections
	// 4.3.5 and 5.1.5.2). The server MUST ignore this parameter.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// InfoStruct: A pointer to a structure, in the format of a SERVER_ALIAS_ENUM_STRUCT,
	// as specified in section 2.2.4.104. The SERVER_ALIAS_ENUM_STRUCT structure has a Level
	// member that specifies the type of structure to return in the ServerAliasInfo member.
	// The Level member MUST be one of the values specified in section 2.2.4.104.
	Info *ServerAliasEnum `idl:"name:InfoStruct" json:"info"`
	// PreferedMaximumLength: Specifies the preferred maximum length, in bytes, of the returned
	// data. If the specified value is MAX_PREFERRED_LENGTH, the method MUST attempt to
	// return all entries.
	PreferredMaximumLength uint32 `idl:"name:PreferedMaximumLength" json:"preferred_maximum_length"`
	// ResumeHandle: A pointer to a value that contains a handle, which is used to continue
	// an existing alias search in AliasList. The handle MUST be zero on the first call
	// and remain unchanged for subsequent calls. If the ResumeHandle parameter is NULL,
	// no resume handle MUST be stored. If this parameter is not NULL and the method returns
	// ERROR_MORE_DATA, this parameter receives an implementation-specific nonzero value
	// that can be passed in subsequent calls to this method to continue with the enumeration.
	Resume uint32 `idl:"name:ResumeHandle;pointer:unique" json:"resume"`
}

func (o *AliasEnumRequest) xxx_ToOp(ctx context.Context, op *xxx_AliasEnumOperation) *xxx_AliasEnumOperation {
	if op == nil {
		op = &xxx_AliasEnumOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.Info = o.Info
	op.PreferredMaximumLength = o.PreferredMaximumLength
	op.Resume = o.Resume
	return op
}

func (o *AliasEnumRequest) xxx_FromOp(ctx context.Context, op *xxx_AliasEnumOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.Info = op.Info
	o.PreferredMaximumLength = op.PreferredMaximumLength
	o.Resume = op.Resume
}
func (o *AliasEnumRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *AliasEnumRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AliasEnumOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AliasEnumResponse structure represents the NetrServerAliasEnum operation response
type AliasEnumResponse struct {
	// InfoStruct: A pointer to a structure, in the format of a SERVER_ALIAS_ENUM_STRUCT,
	// as specified in section 2.2.4.104. The SERVER_ALIAS_ENUM_STRUCT structure has a Level
	// member that specifies the type of structure to return in the ServerAliasInfo member.
	// The Level member MUST be one of the values specified in section 2.2.4.104.
	Info *ServerAliasEnum `idl:"name:InfoStruct" json:"info"`
	// TotalEntries: The total number of entries that could have been enumerated if the
	// buffer had been big enough to hold all the entries.
	TotalEntries uint32 `idl:"name:TotalEntries" json:"total_entries"`
	// ResumeHandle: A pointer to a value that contains a handle, which is used to continue
	// an existing alias search in AliasList. The handle MUST be zero on the first call
	// and remain unchanged for subsequent calls. If the ResumeHandle parameter is NULL,
	// no resume handle MUST be stored. If this parameter is not NULL and the method returns
	// ERROR_MORE_DATA, this parameter receives an implementation-specific nonzero value
	// that can be passed in subsequent calls to this method to continue with the enumeration.
	Resume uint32 `idl:"name:ResumeHandle;pointer:unique" json:"resume"`
	// Return: The NetrServerAliasEnum return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AliasEnumResponse) xxx_ToOp(ctx context.Context, op *xxx_AliasEnumOperation) *xxx_AliasEnumOperation {
	if op == nil {
		op = &xxx_AliasEnumOperation{}
	}
	if o == nil {
		return op
	}
	op.Info = o.Info
	op.TotalEntries = o.TotalEntries
	op.Resume = o.Resume
	op.Return = o.Return
	return op
}

func (o *AliasEnumResponse) xxx_FromOp(ctx context.Context, op *xxx_AliasEnumOperation) {
	if o == nil {
		return
	}
	o.Info = op.Info
	o.TotalEntries = op.TotalEntries
	o.Resume = op.Resume
	o.Return = op.Return
}
func (o *AliasEnumResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *AliasEnumResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AliasEnumOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AliasDeleteOperation structure represents the NetrServerAliasDel operation
type xxx_AliasDeleteOperation struct {
	ServerName string           `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	Level      uint32           `idl:"name:Level" json:"level"`
	Info       *ServerAliasInfo `idl:"name:InfoStruct;switch_is:Level" json:"info"`
	Return     uint32           `idl:"name:Return" json:"return"`
}

func (o *xxx_AliasDeleteOperation) OpNum() int { return 56 }

func (o *xxx_AliasDeleteOperation) OpName() string { return "/srvsvc/v3/NetrServerAliasDel" }

func (o *xxx_AliasDeleteOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AliasDeleteOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Level); err != nil {
			return err
		}
	}
	// InfoStruct {in} (1:{switch_type={}(uint32), alias=LPSERVER_ALIAS_INFO}*(1))(2:{switch_type={}(uint32), alias=SERVER_ALIAS_INFO}(union))
	{
		_swInfo := uint32(o.Level)
		if o.Info != nil {
			if err := o.Info.MarshalUnionNDR(ctx, w, _swInfo); err != nil {
				return err
			}
		} else {
			if err := (&ServerAliasInfo{}).MarshalUnionNDR(ctx, w, _swInfo); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AliasDeleteOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Level); err != nil {
			return err
		}
	}
	// InfoStruct {in} (1:{switch_type={}(uint32), alias=LPSERVER_ALIAS_INFO,pointer=ref}*(1))(2:{switch_type={}(uint32), alias=SERVER_ALIAS_INFO}(union))
	{
		if o.Info == nil {
			o.Info = &ServerAliasInfo{}
		}
		_swInfo := uint32(o.Level)
		if err := o.Info.UnmarshalUnionNDR(ctx, w, _swInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AliasDeleteOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AliasDeleteOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AliasDeleteOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AliasDeleteRequest structure represents the NetrServerAliasDel operation request
type AliasDeleteRequest struct {
	// ServerName: An SRVSVC_HANDLE (section 2.2.1.1) pointer that identifies the server.
	// The client MUST map this structure to an RPC binding handle ([C706] sections 4.3.5
	// and 5.1.5.2). If this parameter is NULL, the local computer is used.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// Level: Specifies the information level of the data. It MUST be one of the following
	// values.
	//
	//	+-------+------------------------------------------------------+
	//	|       |                                                      |
	//	| VALUE |                       MEANING                        |
	//	|       |                                                      |
	//	+-------+------------------------------------------------------+
	//	+-------+------------------------------------------------------+
	//	|     0 | The buffer is of type SERVER_ALIAS_INFO_0_CONTAINER. |
	//	+-------+------------------------------------------------------+
	Level uint32 `idl:"name:Level" json:"level"`
	// InfoStruct: A pointer to the SERVER_ALIAS_INFO union that contains information about
	// the alias. The value of the Level parameter determines the type of the contents of
	// the InfoStruct parameter, as the preceding table shows.
	Info *ServerAliasInfo `idl:"name:InfoStruct;switch_is:Level" json:"info"`
}

func (o *AliasDeleteRequest) xxx_ToOp(ctx context.Context, op *xxx_AliasDeleteOperation) *xxx_AliasDeleteOperation {
	if op == nil {
		op = &xxx_AliasDeleteOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.Level = o.Level
	op.Info = o.Info
	return op
}

func (o *AliasDeleteRequest) xxx_FromOp(ctx context.Context, op *xxx_AliasDeleteOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.Level = op.Level
	o.Info = op.Info
}
func (o *AliasDeleteRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *AliasDeleteRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AliasDeleteOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AliasDeleteResponse structure represents the NetrServerAliasDel operation response
type AliasDeleteResponse struct {
	// Return: The NetrServerAliasDel return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AliasDeleteResponse) xxx_ToOp(ctx context.Context, op *xxx_AliasDeleteOperation) *xxx_AliasDeleteOperation {
	if op == nil {
		op = &xxx_AliasDeleteOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *AliasDeleteResponse) xxx_FromOp(ctx context.Context, op *xxx_AliasDeleteOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *AliasDeleteResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *AliasDeleteResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AliasDeleteOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ShareDeleteExOperation structure represents the NetrShareDelEx operation
type xxx_ShareDeleteExOperation struct {
	ServerName string     `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	Level      uint32     `idl:"name:Level" json:"level"`
	ShareInfo  *ShareInfo `idl:"name:ShareInfo;switch_is:Level" json:"share_info"`
	Return     uint32     `idl:"name:Return" json:"return"`
}

func (o *xxx_ShareDeleteExOperation) OpNum() int { return 57 }

func (o *xxx_ShareDeleteExOperation) OpName() string { return "/srvsvc/v3/NetrShareDelEx" }

func (o *xxx_ShareDeleteExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareDeleteExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Level); err != nil {
			return err
		}
	}
	// ShareInfo {in} (1:{switch_type={}(uint32), alias=LPSHARE_INFO}*(1))(2:{switch_type={}(uint32), alias=SHARE_INFO}(union))
	{
		_swShareInfo := uint32(o.Level)
		if o.ShareInfo != nil {
			if err := o.ShareInfo.MarshalUnionNDR(ctx, w, _swShareInfo); err != nil {
				return err
			}
		} else {
			if err := (&ShareInfo{}).MarshalUnionNDR(ctx, w, _swShareInfo); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareDeleteExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=SRVSVC_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Level); err != nil {
			return err
		}
	}
	// ShareInfo {in} (1:{switch_type={}(uint32), alias=LPSHARE_INFO,pointer=ref}*(1))(2:{switch_type={}(uint32), alias=SHARE_INFO}(union))
	{
		if o.ShareInfo == nil {
			o.ShareInfo = &ShareInfo{}
		}
		_swShareInfo := uint32(o.Level)
		if err := o.ShareInfo.UnmarshalUnionNDR(ctx, w, _swShareInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareDeleteExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareDeleteExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ShareDeleteExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ShareDeleteExRequest structure represents the NetrShareDelEx operation request
type ShareDeleteExRequest struct {
	// ServerName: An SRVSVC_HANDLE pointer that identifies the server. The client MUST
	// map this structure to an RPC binding handle ([C706] sections 4.3.5 and 5.1.5.2).
	// The server MUST ignore this parameter.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// Level: Specifies the information level of the data. This parameter MUST be one of
	// the following values.
	//
	//	+-------+--------------------+
	//	|       |                    |
	//	| VALUE |      MEANING       |
	//	|       |                    |
	//	+-------+--------------------+
	//	+-------+--------------------+
	//	|   503 | LPSHARE_INFO_503_I |
	//	+-------+--------------------+
	Level uint32 `idl:"name:Level" json:"level"`
	// ShareInfo: This parameter is of type LPSHARE_INFO union, as specified in section
	// 2.2.3.6. Its contents are determined by the value of the Level parameter, as shown
	// in the preceding table. This parameter MUST NOT contain a null value.
	ShareInfo *ShareInfo `idl:"name:ShareInfo;switch_is:Level" json:"share_info"`
}

func (o *ShareDeleteExRequest) xxx_ToOp(ctx context.Context, op *xxx_ShareDeleteExOperation) *xxx_ShareDeleteExOperation {
	if op == nil {
		op = &xxx_ShareDeleteExOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.Level = o.Level
	op.ShareInfo = o.ShareInfo
	return op
}

func (o *ShareDeleteExRequest) xxx_FromOp(ctx context.Context, op *xxx_ShareDeleteExOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.Level = op.Level
	o.ShareInfo = op.ShareInfo
}
func (o *ShareDeleteExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *ShareDeleteExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ShareDeleteExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ShareDeleteExResponse structure represents the NetrShareDelEx operation response
type ShareDeleteExResponse struct {
	// Return: The NetrShareDelEx return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ShareDeleteExResponse) xxx_ToOp(ctx context.Context, op *xxx_ShareDeleteExOperation) *xxx_ShareDeleteExOperation {
	if op == nil {
		op = &xxx_ShareDeleteExOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *ShareDeleteExResponse) xxx_FromOp(ctx context.Context, op *xxx_ShareDeleteExOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *ShareDeleteExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *ShareDeleteExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ShareDeleteExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}
