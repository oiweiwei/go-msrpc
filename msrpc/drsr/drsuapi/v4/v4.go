package drsuapi

import (
	"context"
	"fmt"
	"strings"
	"unicode/utf16"

	dcerpc "github.com/oiweiwei/go-msrpc/dcerpc"
	errors "github.com/oiweiwei/go-msrpc/dcerpc/errors"
	uuid "github.com/oiweiwei/go-msrpc/midl/uuid"
	dcetypes "github.com/oiweiwei/go-msrpc/msrpc/dcetypes"
	dtyp "github.com/oiweiwei/go-msrpc/msrpc/dtyp"
	ndr "github.com/oiweiwei/go-msrpc/ndr"
)

var (
	_ = context.Background
	_ = fmt.Errorf
	_ = utf16.Encode
	_ = strings.TrimPrefix
	_ = ndr.ZeroString
	_ = (*uuid.UUID)(nil)
	_ = (*dcerpc.SyntaxID)(nil)
	_ = (*errors.Error)(nil)
	_ = dcetypes.GoPackage
	_ = dtyp.GoPackage
)

var (
	// import guard
	GoPackage = "drsr"
)

var (
	// Syntax UUID
	DrsuapiSyntaxUUID = &uuid.UUID{TimeLow: 0xe3514235, TimeMid: 0x4b06, TimeHiAndVersion: 0x11d1, ClockSeqHiAndReserved: 0xab, ClockSeqLow: 0x4, Node: [6]uint8{0x0, 0xc0, 0x4f, 0xc2, 0xdc, 0xd2}}
	// Syntax ID
	DrsuapiSyntaxV4_0 = &dcerpc.SyntaxID{IfUUID: DrsuapiSyntaxUUID, IfVersionMajor: 4, IfVersionMinor: 0}
)

// drsuapi interface.
type DrsuapiClient interface {

	// The IDL_DRSBind method creates a context handle that is necessary to call any other
	// method in this interface.
	//
	// Return Values: 0 if successful, otherwise a Windows error code.
	//
	// Exceptions Thrown: This method does not throw exceptions beyond those thrown by the
	// underlying RPC protocol.
	Bind(context.Context, *BindRequest, ...dcerpc.CallOption) (*BindResponse, error)

	// The IDL_DRSUnbind method destroys a context handle previously created by the IDL_DRSBind
	// method.
	//
	// Return Values: 0 if successful, or a Windows error code if a failure occurs.
	//
	// Exceptions Thrown: This method might throw the following exception beyond those thrown
	// by the underlying RPC protocol (as specified in [MS-RPCE]): ERROR_INVALID_HANDLE.
	Unbind(context.Context, *UnbindRequest, ...dcerpc.CallOption) (*UnbindResponse, error)

	// The IDL_DRSReplicaSync method triggers replication from another DC.
	//
	// Return Values: 0 if successful, otherwise a Windows error code.
	//
	// Exceptions Thrown: This method might throw the following exceptions beyond those
	// thrown by the underlying RPC protocol (as specified in [MS-RPCE]): ERROR_INVALID_HANDLE,
	// ERROR_DS_DRS_EXTENSIONS_CHANGED, ERROR_DS_DIFFERENT_REPL_EPOCHS, and  ERROR_INVALID_PARAMETER.
	SyncReplica(context.Context, *SyncReplicaRequest, ...dcerpc.CallOption) (*SyncReplicaResponse, error)

	// The IDL_DRSGetNCChanges method replicates updates from an NC replica on the server.
	//
	// Return Values: 0 if successful, otherwise a Windows error code.
	//
	// Exceptions Thrown: This method might throw the following exceptions beyond those
	// thrown by the underlying RPC protocol (as specified in [MS-RPCE]): ERROR_INVALID_HANDLE,
	// ERROR_DS_DRS_EXTENSIONS_CHANGED, ERROR_DS_DIFFERENT_REPL_EPOCHS, and  ERROR_INVALID_PARAMETER.
	GetNCChanges(context.Context, *GetNCChangesRequest, ...dcerpc.CallOption) (*GetNCChangesResponse, error)

	// The IDL_DRSUpdateRefs method adds or deletes a value from the repsTo of a specified
	// NC replica.
	//
	// Return Values: 0 if successful, otherwise a Windows error code.
	//
	// Exceptions Thrown: This method might throw the following exceptions beyond those
	// thrown by the underlying RPC protocol (as specified in [MS-RPCE]): ERROR_INVALID_HANDLE,
	// ERROR_DS_DRS_EXTENSIONS_CHANGED, ERROR_DS_DIFFERENT_REPL_EPOCHS, and  ERROR_INVALID_PARAMETER.
	UpdateReferences(context.Context, *UpdateReferencesRequest, ...dcerpc.CallOption) (*UpdateReferencesResponse, error)

	// The IDL_DRSReplicaAdd method adds a replication source reference for the specified
	// NC.
	//
	// Return Values: 0 if successful, otherwise a Windows error code.
	//
	// Exceptions Thrown: This method might throw the following exceptions beyond those
	// thrown by the underlying RPC protocol (as specified in [MS-RPCE]): ERROR_INVALID_HANDLE,
	// ERROR_DS_DRS_EXTENSIONS_CHANGED, ERROR_DS_DIFFERENT_REPL_EPOCHS, and  ERROR_INVALID_PARAMETER.
	AddReplica(context.Context, *AddReplicaRequest, ...dcerpc.CallOption) (*AddReplicaResponse, error)

	// The IDL_DRSReplicaDel method deletes a replication source reference for the specified
	// NC.
	//
	// Return Values: 0 if successful, otherwise a Windows error code.
	//
	// Exceptions Thrown: This method might throw the following exceptions beyond those
	// thrown by the underlying RPC protocol (as specified in [MS-RPCE]): ERROR_INVALID_HANDLE,
	// ERROR_DS_DRS_EXTENSIONS_CHANGED, ERROR_DS_DIFFERENT_REPL_EPOCHS, and  ERROR_INVALID_PARAMETER.
	DeleteReplica(context.Context, *DeleteReplicaRequest, ...dcerpc.CallOption) (*DeleteReplicaResponse, error)

	// The IDL_DRSReplicaModify method updates the value for repsFrom for the NC replica.
	//
	// Return Values: 0 if successful, or a Windows error code if a failure occurs.
	//
	// Exceptions Thrown: This method might throw the following exceptions beyond those
	// thrown by the underlying RPC protocol (as specified in [MS-RPCE]): ERROR_INVALID_HANDLE,
	// ERROR_DS_DRS_EXTENSIONS_CHANGED, ERROR_DS_DIFFERENT_REPL_EPOCHS, and  ERROR_INVALID_PARAMETER.
	ModifyReplica(context.Context, *ModifyReplicaRequest, ...dcerpc.CallOption) (*ModifyReplicaResponse, error)

	// The IDL_DRSVerifyNames method resolves a sequence of object identities.
	//
	// Return Values: 0 if successful, otherwise a Windows error code.
	//
	// Exceptions Thrown: This method might throw the following exceptions beyond those
	// thrown by the underlying RPC protocol (as specified in [MS-RPCE]): ERROR_INVALID_HANDLE,
	// ERROR_DS_DRS_EXTENSIONS_CHANGED, ERROR_DS_DIFFERENT_REPL_EPOCHS, and  ERROR_INVALID_PARAMETER.
	VerifyNames(context.Context, *VerifyNamesRequest, ...dcerpc.CallOption) (*VerifyNamesResponse, error)

	// The IDL_DRSGetMemberships method retrieves group membership for an object.
	//
	// Return Values: 0 if successful, otherwise a Windows error code.
	//
	// Exceptions Thrown: This method might throw the following exceptions beyond those
	// thrown by the underlying RPC protocol (as specified in [MS-RPCE]): ERROR_INVALID_HANDLE,
	// ERROR_DS_DRS_EXTENSIONS_CHANGED, ERROR_DS_DIFFERENT_REPL_EPOCHS, and  ERROR_INVALID_PARAMETER.
	GetMemberships(context.Context, *GetMembershipsRequest, ...dcerpc.CallOption) (*GetMembershipsResponse, error)

	// The IDL_DRSInterDomainMove method is a helper method used in a cross-NC move LDAP
	// operation.
	//
	// Return Values: 0 if successful, otherwise a Windows error code.
	//
	// Exceptions Thrown: This method might throw the following exceptions beyond those
	// thrown by the underlying RPC protocol (as specified in [MS-RPCE]): ERROR_INVALID_HANDLE,
	// ERROR_DS_DRS_EXTENSIONS_CHANGED, ERROR_DS_DIFFERENT_REPL_EPOCHS, and  ERROR_INVALID_PARAMETER.
	InterdomainMove(context.Context, *InterdomainMoveRequest, ...dcerpc.CallOption) (*InterdomainMoveResponse, error)

	// If the server is the PDC emulator FSMO role owner, the IDL_DRSGetNT4ChangeLog method
	// returns either a sequence of PDC change log entries or the NT4 replication state,
	// or both, as requested by the client.
	//
	// Return Values: 0 or ERROR_MORE_DATA if successful; another Windows error code if
	// a failure occurred.
	//
	// Exceptions Thrown: This method might throw the following exceptions beyond those
	// thrown by the underlying RPC protocol (as specified in [MS-RPCE]): ERROR_INVALID_HANDLE,
	// ERROR_DS_DRS_EXTENSIONS_CHANGED, ERROR_DS_DIFFERENT_REPL_EPOCHS, and  ERROR_INVALID_PARAMETER.
	GetNT4ChangeLog(context.Context, *GetNT4ChangeLogRequest, ...dcerpc.CallOption) (*GetNT4ChangeLogResponse, error)

	// The IDL_DRSCrackNames method looks up each of a set of objects in the directory and
	// returns it to the caller in the requested format.
	//
	// Return Values: 0 if successful, otherwise a Windows error code.
	//
	// Exceptions Thrown: This method might throw the following exceptions beyond those
	// thrown by the underlying RPC protocol (as specified in [MS-RPCE]): ERROR_INVALID_HANDLE,
	// ERROR_DS_DRS_EXTENSIONS_CHANGED, ERROR_DS_DIFFERENT_REPL_EPOCHS, and  ERROR_INVALID_PARAMETER.
	CrackNames(context.Context, *CrackNamesRequest, ...dcerpc.CallOption) (*CrackNamesResponse, error)

	// The IDL_DRSWriteSPN method updates the set of SPNs on an object.
	//
	// Return Values: 0 if successful, or a Windows error code if a failure occurs.
	//
	// Exceptions Thrown: This method might throw the following exceptions beyond those
	// thrown by the underlying RPC protocol (as specified in [MS-RPCE]): ERROR_INVALID_HANDLE,
	// ERROR_DS_DRS_EXTENSIONS_CHANGED, ERROR_DS_DIFFERENT_REPL_EPOCHS, and  ERROR_INVALID_PARAMETER.
	WriteSPN(context.Context, *WriteSPNRequest, ...dcerpc.CallOption) (*WriteSPNResponse, error)

	// The IDL_DRSRemoveDsServer method removes the representation (also known as metadata)
	// of a DC from the directory.
	//
	// Return Values: 0 if successful or a Windows error code if a failure occurs.
	//
	// Exceptions Thrown: This method might throw the following exceptions beyond those
	// thrown by the underlying RPC protocol (as specified in [MS-RPCE]): ERROR_INVALID_HANDLE,
	// ERROR_DS_DRS_EXTENSIONS_CHANGED, ERROR_DS_DIFFERENT_REPL_EPOCHS, and  ERROR_INVALID_PARAMETER.
	RemoveDSServer(context.Context, *RemoveDSServerRequest, ...dcerpc.CallOption) (*RemoveDSServerResponse, error)

	// The IDL_DRSRemoveDsDomain method removes the representation (also known as metadata)
	// of a domain from the directory.
	//
	// Return Values: 0 if successful, or a Windows error code if a failure occurs.
	//
	// Exceptions Thrown: This method might throw the following exceptions beyond those
	// thrown by the underlying RPC protocol (as specified in [MS-RPCE]): ERROR_INVALID_HANDLE,
	// ERROR_DS_DRS_EXTENSIONS_CHANGED, ERROR_DS_DIFFERENT_REPL_EPOCHS, and  ERROR_INVALID_PARAMETER.
	RemoveDSDomain(context.Context, *RemoveDSDomainRequest, ...dcerpc.CallOption) (*RemoveDSDomainResponse, error)

	// The IDL_DRSDomainControllerInfo method retrieves information about DCs in a given
	// domain.
	//
	// Return Values: 0 if successful, otherwise a Windows error code.
	//
	// Exceptions Thrown: This method might throw the following exceptions beyond those
	// thrown by the underlying RPC protocol (as specified in [MS-RPCE]): ERROR_INVALID_HANDLE,
	// ERROR_DS_DRS_EXTENSIONS_CHANGED, ERROR_DS_DIFFERENT_REPL_EPOCHS, and  ERROR_INVALID_PARAMETER.
	DomainControllerInfo(context.Context, *DomainControllerInfoRequest, ...dcerpc.CallOption) (*DomainControllerInfoResponse, error)

	// The IDL_DRSAddEntry method adds one or more objects.
	//
	// Return Values: 0 if successful, otherwise a Windows error code.
	//
	// Exceptions Thrown: This method might throw the following exceptions beyond those
	// thrown by the underlying RPC protocol (as specified in [MS-RPCE]): ERROR_INVALID_HANDLE,
	// ERROR_DS_DRS_EXTENSIONS_CHANGED, ERROR_DS_DIFFERENT_REPL_EPOCHS, and  ERROR_INVALID_PARAMETER.
	AddEntry(context.Context, *AddEntryRequest, ...dcerpc.CallOption) (*AddEntryResponse, error)

	// The IDL_DRSExecuteKCC method validates the replication interconnections of DCs and
	// updates them if necessary.
	//
	// Return Values: 0 if successful, otherwise a Windows error code.
	//
	// Exceptions Thrown: This method might throw the following exceptions beyond those
	// thrown by the underlying RPC protocol (as specified in [MS-RPCE]): ERROR_INVALID_HANDLE,
	// ERROR_DS_DRS_EXTENSIONS_CHANGED, ERROR_DS_DIFFERENT_REPL_EPOCHS, and ERROR_INVALID_PARAMETER.
	ExecuteKCC(context.Context, *ExecuteKCCRequest, ...dcerpc.CallOption) (*ExecuteKCCResponse, error)

	// The IDL_DRSGetReplInfo method retrieves the replication state of the server.
	//
	// Return Values: 0 if successful, otherwise a Windows error code.
	//
	// Exceptions Thrown: This method might throw the following exceptions beyond those
	// thrown by the underlying RPC protocol (as specified in [MS-RPCE]): ERROR_INVALID_HANDLE,
	// ERROR_DS_DRS_EXTENSIONS_CHANGED, ERROR_DS_DIFFERENT_REPL_EPOCHS, and  ERROR_INVALID_PARAMETER.
	GetReplicationInfo(context.Context, *GetReplicationInfoRequest, ...dcerpc.CallOption) (*GetReplicationInfoResponse, error)

	// The IDL_DRSAddSidHistory method adds one or more SIDs to the sIDHistory attribute
	// of a given object.
	//
	// Return Values: 0 or one of the following Windows error codes: ERROR_DS_MUST_RUN_ON_DST_DC
	// or ERROR_INVALID_PARAMETER.
	//
	// Exceptions Thrown: This method might throw the following exceptions beyond those
	// thrown by the underlying RPC protocol (as specified in [MS-RPCE]): ERROR_INVALID_HANDLE,
	// ERROR_DS_DRS_EXTENSIONS_CHANGED, ERROR_DS_DIFFERENT_REPL_EPOCHS, and ERROR_INVALID_PARAMETER.
	AddSIDHistory(context.Context, *AddSIDHistoryRequest, ...dcerpc.CallOption) (*AddSIDHistoryResponse, error)

	// The IDL_DRSGetMemberships2 method retrieves group memberships for a sequence of objects.
	//
	// Return Values: 0 if successful; otherwise, a Windows error code.
	//
	// Exceptions Thrown: This method might throw the following exceptions beyond those
	// thrown by the underlying RPC protocol (as specified in [MS-RPCE]): ERROR_INVALID_HANDLE,
	// ERROR_DS_DRS_EXTENSIONS_CHANGED, ERROR_DS_DIFFERENT_REPL_EPOCHS, and  ERROR_INVALID_PARAMETER.
	GetMemberships2(context.Context, *GetMemberships2Request, ...dcerpc.CallOption) (*GetMemberships2Response, error)

	// The IDL_DRSReplicaVerifyObjects method verifies the existence of objects in an NC
	// replica by comparing against a replica of the same NC on a reference DC, optionally
	// deleting any objects that do not exist on the reference DC.
	//
	// Return Values: 0 if successful, otherwise a Windows error code.
	//
	// Exceptions Thrown: This method might throw the following exceptions beyond those
	// thrown by the underlying RPC protocol (as specified in [MS-RPCE]): ERROR_INVALID_HANDLE,
	// ERROR_DS_DRS_EXTENSIONS_CHANGED, ERROR_DS_DIFFERENT_REPL_EPOCHS, and  ERROR_INVALID_PARAMETER.
	VerifyObjectsReplica(context.Context, *VerifyObjectsReplicaRequest, ...dcerpc.CallOption) (*VerifyObjectsReplicaResponse, error)

	// The IDL_DRSGetObjectExistence method helps the client check the consistency of object
	// existence between its replica of an NC and the server's replica of the same NC. Checking
	// the consistency of object existence means identifying objects that have replicated
	// to both replicas and that exist in one replica but not in the other. For the purposes
	// of this method, an object exists within a NC replica if it is either an object or
	// a tombstone.
	//
	// See IDL_DRSReplicaVerifyObjects for a use of this method.
	//
	// Return Values: 0 if successful, otherwise a Windows error code.
	//
	// Exceptions Thrown: This method might throw the following exceptions beyond those
	// thrown by the underlying RPC protocol (as specified in [MS-RPCE]): ERROR_INVALID_HANDLE,
	// ERROR_DS_DRS_EXTENSIONS_CHANGED, ERROR_DS_DIFFERENT_REPL_EPOCHS, and  ERROR_INVALID_PARAMETER.
	GetObjectExistence(context.Context, *GetObjectExistenceRequest, ...dcerpc.CallOption) (*GetObjectExistenceResponse, error)

	// The IDL_DRSQuerySitesByCost method determines the communication cost from a "from"
	// site to one or more "to" sites.
	//
	// Return Values: 0 if successful, or a Windows error code if a failure occurs.
	//
	// Exceptions Thrown: This method might throw the following exceptions beyond those
	// thrown by the underlying RPC protocol (as specified in [MS-RPCE]): ERROR_INVALID_HANDLE,
	// ERROR_DS_DRS_EXTENSIONS_CHANGED, ERROR_DS_DIFFERENT_REPL_EPOCHS, and  ERROR_INVALID_PARAMETER.
	QuerySitesByCost(context.Context, *QuerySitesByCostRequest, ...dcerpc.CallOption) (*QuerySitesByCostResponse, error)

	// The IDL_DRSInitDemotion method performs the first phase of the removal of a DC from
	// an AD LDS forest. This method is supported only by AD LDS.
	//
	// Return Values: 0 if successful, otherwise a Windows error code.
	//
	// Exceptions Thrown: This method might throw the following exceptions beyond those
	// thrown by the underlying RPC protocol (as specified in [MS-RPCE]): ERROR_INVALID_HANDLE,
	// ERROR_DS_DRS_EXTENSIONS_CHANGED, ERROR_DS_DIFFERENT_REPL_EPOCHS, and  ERROR_INVALID_PARAMETER.
	InitDemotion(context.Context, *InitDemotionRequest, ...dcerpc.CallOption) (*InitDemotionResponse, error)

	// The IDL_DRSReplicaDemotion method replicates off all changes to the specified NC
	// and moves any FSMOs held to another server.
	//
	// Return Values: 0 if successful, otherwise a Windows error code.
	//
	// Exceptions Thrown: This method might throw the following exceptions beyond those
	// thrown by the underlying RPC protocol (as specified in [MS-RPCE]): ERROR_INVALID_HANDLE,
	// ERROR_DS_DRS_EXTENSIONS_CHANGED, ERROR_DS_DIFFERENT_REPL_EPOCHS, and  ERROR_INVALID_PARAMETER.
	DemotionReplica(context.Context, *DemotionReplicaRequest, ...dcerpc.CallOption) (*DemotionReplicaResponse, error)

	// The IDL_DRSFinishDemotion method either performs one or more steps toward the complete
	// removal of a DC from an AD LDS forest, or it undoes the effects of the first phase
	// of removal (performed by IDL_DRSInitDemotion). This method is supported by AD LDS
	// only.
	//
	// Return Values: 0 if successful, otherwise a Windows error code.
	//
	// Exceptions Thrown: This method might throw the following exceptions beyond those
	// thrown by the underlying RPC protocol (as specified in [MS-RPCE]): ERROR_INVALID_HANDLE,
	// ERROR_DS_DRS_EXTENSIONS_CHANGED, ERROR_DS_DIFFERENT_REPL_EPOCHS, and  ERROR_INVALID_PARAMETER.
	FinishDemotion(context.Context, *FinishDemotionRequest, ...dcerpc.CallOption) (*FinishDemotionResponse, error)

	// The IDL_DRSAddCloneDC method is used to create a new DC object by copying attributes
	// from an existing DC object.
	//
	// Return Values: 0 if successful, otherwise a Windows error code.
	//
	// Exceptions Thrown: This method might throw the following exceptions beyond those
	// thrown by the underlying RPC protocol (as specified in [MS-RPCE]): ERROR_INVALID_HANDLE,
	// ERROR_DS_DRS_EXTENSIONS_CHANGED, and ERROR_INVALID_PARAMETER.
	AddCloneDC(context.Context, *AddCloneDCRequest, ...dcerpc.CallOption) (*AddCloneDCResponse, error)

	// IDL_DRSWriteNgcKey operation.
	WriteNGCKey(context.Context, *WriteNGCKeyRequest, ...dcerpc.CallOption) (*WriteNGCKeyResponse, error)

	// IDL_DRSReadNgcKey operation.
	ReadNGCKey(context.Context, *ReadNGCKeyRequest, ...dcerpc.CallOption) (*ReadNGCKeyResponse, error)

	// AlterContext alters the client context.
	AlterContext(context.Context, ...dcerpc.Option) error

	// Conn returns the client connection (unsafe)
	Conn() dcerpc.Conn
}

// ExtBase represents the DRS_EXT_BASE RPC constant
const ExtBase = 0x00000001

// ExtAsyncReply represents the DRS_EXT_ASYNCREPL RPC constant
const ExtAsyncReply = 0x00000002

// ExtRemoveAPI represents the DRS_EXT_REMOVEAPI RPC constant
const ExtRemoveAPI = 0x00000004

// ExtMoveRequestV2 represents the DRS_EXT_MOVEREQ_V2 RPC constant
const ExtMoveRequestV2 = 0x00000008

// ExtGetNCChangesDeflate represents the DRS_EXT_GETCHG_DEFLATE RPC constant
const ExtGetNCChangesDeflate = 0x00000010

// ExtDCInfoV1 represents the DRS_EXT_DCINFO_V1 RPC constant
const ExtDCInfoV1 = 0x00000020

// ExtRestoreUSNOptimization represents the DRS_EXT_RESTORE_USN_OPTIMIZATION RPC constant
const ExtRestoreUSNOptimization = 0x00000040

// ExtAddEntry represents the DRS_EXT_ADDENTRY RPC constant
const ExtAddEntry = 0x00000080

// ExtKCCExecute represents the DRS_EXT_KCC_EXECUTE RPC constant
const ExtKCCExecute = 0x00000100

// ExtAddEntryV2 represents the DRS_EXT_ADDENTRY_V2 RPC constant
const ExtAddEntryV2 = 0x00000200

// ExtLinkedValueReplication represents the DRS_EXT_LINKED_VALUE_REPLICATION RPC constant
const ExtLinkedValueReplication = 0x00000400

// ExtDCInfoV2 represents the DRS_EXT_DCINFO_V2 RPC constant
const ExtDCInfoV2 = 0x00000800

// ExtInstanceTypeNotRequestOnModify represents the DRS_EXT_INSTANCE_TYPE_NOT_REQ_ON_MOD RPC constant
const ExtInstanceTypeNotRequestOnModify = 0x00001000

// ExtCryptoBind represents the DRS_EXT_CRYPTO_BIND RPC constant
const ExtCryptoBind = 0x00002000

// ExtGetReplicationInfo represents the DRS_EXT_GET_REPL_INFO RPC constant
const ExtGetReplicationInfo = 0x00004000

// ExtStrongEncryption represents the DRS_EXT_STRONG_ENCRYPTION RPC constant
const ExtStrongEncryption = 0x00008000

// ExtDCInfoVQ represents the DRS_EXT_DCINFO_VFFFFFFFF RPC constant
const ExtDCInfoVQ = 0x00010000

// ExtTransitiveMembership represents the DRS_EXT_TRANSITIVE_MEMBERSHIP RPC constant
const ExtTransitiveMembership = 0x00020000

// ExtAddSIDHistory represents the DRS_EXT_ADD_SID_HISTORY RPC constant
const ExtAddSIDHistory = 0x00040000

// ExtPostBeta3 represents the DRS_EXT_POST_BETA3 RPC constant
const ExtPostBeta3 = 0x00080000

// ExtGetNCChangesRequestV5 represents the DRS_EXT_GETCHGREQ_V5 RPC constant
const ExtGetNCChangesRequestV5 = 0x00100000

// ExtGetMemberships2 represents the DRS_EXT_GETMEMBERSHIPS2 RPC constant
const ExtGetMemberships2 = 0x00200000

// ExtGetNCChangesRequestV6 represents the DRS_EXT_GETCHGREQ_V6 RPC constant
const ExtGetNCChangesRequestV6 = 0x00400000

// ExtNonDomainNCs represents the DRS_EXT_NONDOMAIN_NCS RPC constant
const ExtNonDomainNCs = 0x00800000

// ExtGetNCChangesRequestV8 represents the DRS_EXT_GETCHGREQ_V8 RPC constant
const ExtGetNCChangesRequestV8 = 0x01000000

// ExtGetNCChangesReplyV5 represents the DRS_EXT_GETCHGREPLY_V5 RPC constant
const ExtGetNCChangesReplyV5 = 0x02000000

// ExtGetNCChangesReplyV6 represents the DRS_EXT_GETCHGREPLY_V6 RPC constant
const ExtGetNCChangesReplyV6 = 0x04000000

// ExtWhistlerBeta3 represents the DRS_EXT_WHISTLER_BETA3 RPC constant
const ExtWhistlerBeta3 = 0x08000000

// ExtW2K3Deflate represents the DRS_EXT_W2K3_DEFLATE RPC constant
const ExtW2K3Deflate = 0x10000000

// ExtGetNCChangesRequestV10 represents the DRS_EXT_GETCHGREQ_V10 RPC constant
const ExtGetNCChangesRequestV10 = 0x20000000

// ExtReservedForWin2KOrNETPart2 represents the DRS_EXT_RESERVED_FOR_WIN2K_OR_DOTNET_PART2 RPC constant
const ExtReservedForWin2KOrNETPart2 = 0x40000000

// ExtReservedForWin2KOrNETPart3 represents the DRS_EXT_RESERVED_FOR_WIN2K_OR_DOTNET_PART3 RPC constant
const ExtReservedForWin2KOrNETPart3 = 0x80000000

// AsyncOperation represents the DRS_ASYNC_OP RPC constant
const AsyncOperation = 0x00000001

// GetNCChangesCheck represents the DRS_GETCHG_CHECK RPC constant
const GetNCChangesCheck = 0x00000002

// UpdateNotification represents the DRS_UPDATE_NOTIFICATION RPC constant
const UpdateNotification = 0x00000002

// AddReference represents the DRS_ADD_REF RPC constant
const AddReference = 0x00000004

// SyncAll represents the DRS_SYNC_ALL RPC constant
const SyncAll = 0x00000004

// DeleteReference represents the DRS_DEL_REF RPC constant
const DeleteReference = 0x00000008

// WritableReplica represents the DRS_WRITABLE_REPLICA RPC constant
const WritableReplica = 0x00000010

// InitSync represents the DRS_INIT_SYNC RPC constant
const InitSync = 0x00000020

// PeriodicalSync represents the DRS_PERIODICAL_SYNC RPC constant
const PeriodicalSync = 0x00000040

// MailReplication represents the DRS_MAIL_REPLICATION RPC constant
const MailReplication = 0x00000080

// AsyncReplication represents the DRS_ASYNC_REPLICATION RPC constant
const AsyncReplication = 0x00000100

// IgnoreError represents the DRS_IGNORE_ERROR RPC constant
const IgnoreError = 0x00000100

// TwoWaySync represents the DRS_TWO_WAY_SYNC RPC constant
const TwoWaySync = 0x00000200

// CriticalOnly represents the DRS_CRITICAL_ONLY RPC constant
const CriticalOnly = 0x00000400

// GetAncestor represents the DRS_GET_ANCESTOR RPC constant
const GetAncestor = 0x00000800

// GetNCSize represents the DRS_GET_NC_SIZE RPC constant
const GetNCSize = 0x00001000

// LocalOnly represents the DRS_LOCAL_ONLY RPC constant
const LocalOnly = 0x00001000

// NonGCReadOnlyReplica represents the DRS_NON_GC_RO_REPLICA RPC constant
const NonGCReadOnlyReplica = 0x00002000

// SyncByName represents the DRS_SYNC_BY_NAME RPC constant
const SyncByName = 0x00004000

// ReferenceOK represents the DRS_REF_OK RPC constant
const ReferenceOK = 0x00004000

// FullSyncNow represents the DRS_FULL_SYNC_NOW RPC constant
const FullSyncNow = 0x00008000

// NoSource represents the DRS_NO_SOURCE RPC constant
const NoSource = 0x00008000

// FullSyncInProgress represents the DRS_FULL_SYNC_IN_PROGRESS RPC constant
const FullSyncInProgress = 0x00010000

// FullSyncPacket represents the DRS_FULL_SYNC_PACKET RPC constant
const FullSyncPacket = 0x00020000

// SyncRequeue represents the DRS_SYNC_REQUEUE RPC constant
const SyncRequeue = 0x00040000

// SyncUrgent represents the DRS_SYNC_URGENT RPC constant
const SyncUrgent = 0x00080000

// ReferenceGCSPN represents the DRS_REF_GC_SPN RPC constant
const ReferenceGCSPN = 0x00100000

// NoDiscard represents the DRS_NO_DISCARD RPC constant
const NoDiscard = 0x00100000

// NeverSynced represents the DRS_NEVER_SYNCED RPC constant
const NeverSynced = 0x00200000

// SpecialSecretProcessing represents the DRS_SPECIAL_SECRET_PROCESSING RPC constant
const SpecialSecretProcessing = 0x00400000

// InitSyncNow represents the DRS_INIT_SYNC_NOW RPC constant
const InitSyncNow = 0x00800000

// Preempted represents the DRS_PREEMPTED RPC constant
const Preempted = 0x01000000

// SyncForced represents the DRS_SYNC_FORCED RPC constant
const SyncForced = 0x02000000

// DisableAutoSync represents the DRS_DISABLE_AUTO_SYNC RPC constant
const DisableAutoSync = 0x04000000

// DisablePeriodicSync represents the DRS_DISABLE_PERIODIC_SYNC RPC constant
const DisablePeriodicSync = 0x08000000

// UseCompression represents the DRS_USE_COMPRESSION RPC constant
const UseCompression = 0x10000000

// NeverNotify represents the DRS_NEVER_NOTIFY RPC constant
const NeverNotify = 0x20000000

// SyncPartialAttributes represents the DRS_SYNC_PARTIAL_ATTRIBUTES RPC constant
const SyncPartialAttributes = 0x40000000

// GetAllGroupMembership represents the DRS_GET_ALL_GROUP_MEMBERSHIP RPC constant
const GetAllGroupMembership = 0x80000000

// ExtendedOperationFSMORequestRole represents the EXOP_FSMO_REQ_ROLE RPC constant
const ExtendedOperationFSMORequestRole = 0x00000001

// ExtendedOperationFSMORequestRIDAlloc represents the EXOP_FSMO_REQ_RID_ALLOC RPC constant
const ExtendedOperationFSMORequestRIDAlloc = 0x00000002

// ExtendedOperationFSMORIDRequestRole represents the EXOP_FSMO_RID_REQ_ROLE RPC constant
const ExtendedOperationFSMORIDRequestRole = 0x00000003

// ExtendedOperationFSMORequestPDC represents the EXOP_FSMO_REQ_PDC RPC constant
const ExtendedOperationFSMORequestPDC = 0x00000004

// ExtendedOperationFSMOAbandonRole represents the EXOP_FSMO_ABANDON_ROLE RPC constant
const ExtendedOperationFSMOAbandonRole = 0x00000005

// ExtendedOperationReplicationObject represents the EXOP_REPL_OBJ RPC constant
const ExtendedOperationReplicationObject = 0x00000006

// ExtendedOperationReplicationSecrets represents the EXOP_REPL_SECRETS RPC constant
const ExtendedOperationReplicationSecrets = 0x00000007

// Handle structure represents DRS_HANDLE RPC structure.
type Handle dcetypes.ContextHandle

func (o *Handle) ContextHandle() *dcetypes.ContextHandle { return (*dcetypes.ContextHandle)(o) }

func (o *Handle) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *Handle) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Attributes); err != nil {
		return err
	}
	if o.UUID != nil {
		if err := o.UUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *Handle) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Attributes); err != nil {
		return err
	}
	if o.UUID == nil {
		o.UUID = &dtyp.GUID{}
	}
	if err := o.UUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// DSNameError type represents DS_NAME_ERROR RPC enumeration.
type DSNameError uint32

var (
	DSNameErrorNoError                DSNameError = 0
	DSNameErrorResolving              DSNameError = 1
	DSNameErrorNotFound               DSNameError = 2
	DSNameErrorNotUnique              DSNameError = 3
	DSNameErrorNoMapping              DSNameError = 4
	DSNameErrorDomainOnly             DSNameError = 5
	DSNameErrorNoSyntacticalMapping   DSNameError = 6
	DSNameErrorTrustReferral          DSNameError = 7
	DSNameErrorIsSIDHistoryUnknown    DSNameError = 4294967282
	DSNameErrorIsSIDHistoryAlias      DSNameError = 4294967283
	DSNameErrorIsSIDHistoryGroup      DSNameError = 4294967284
	DSNameErrorIsSIDHistoryUser       DSNameError = 4294967285
	DSNameErrorIsSIDUnknown           DSNameError = 4294967286
	DSNameErrorIsSIDAlias             DSNameError = 4294967287
	DSNameErrorIsSIDGroup             DSNameError = 4294967288
	DSNameErrorIsSIDUser              DSNameError = 4294967289
	DSNameErrorSchemaGUIDControlRight DSNameError = 4294967290
	DSNameErrorSchemaGUIDClass        DSNameError = 4294967291
	DSNameErrorSchemaGUIDAttributeSet DSNameError = 4294967292
	DSNameErrorSchemaGUIDAttribute    DSNameError = 4294967293
	DSNameErrorSchemaGUIDNotFound     DSNameError = 4294967294
	DSNameErrorIsFPO                  DSNameError = 4294967295
)

func (o DSNameError) String() string {
	switch o {
	case DSNameErrorNoError:
		return "DSNameErrorNoError"
	case DSNameErrorResolving:
		return "DSNameErrorResolving"
	case DSNameErrorNotFound:
		return "DSNameErrorNotFound"
	case DSNameErrorNotUnique:
		return "DSNameErrorNotUnique"
	case DSNameErrorNoMapping:
		return "DSNameErrorNoMapping"
	case DSNameErrorDomainOnly:
		return "DSNameErrorDomainOnly"
	case DSNameErrorNoSyntacticalMapping:
		return "DSNameErrorNoSyntacticalMapping"
	case DSNameErrorTrustReferral:
		return "DSNameErrorTrustReferral"
	case DSNameErrorIsSIDHistoryUnknown:
		return "DSNameErrorIsSIDHistoryUnknown"
	case DSNameErrorIsSIDHistoryAlias:
		return "DSNameErrorIsSIDHistoryAlias"
	case DSNameErrorIsSIDHistoryGroup:
		return "DSNameErrorIsSIDHistoryGroup"
	case DSNameErrorIsSIDHistoryUser:
		return "DSNameErrorIsSIDHistoryUser"
	case DSNameErrorIsSIDUnknown:
		return "DSNameErrorIsSIDUnknown"
	case DSNameErrorIsSIDAlias:
		return "DSNameErrorIsSIDAlias"
	case DSNameErrorIsSIDGroup:
		return "DSNameErrorIsSIDGroup"
	case DSNameErrorIsSIDUser:
		return "DSNameErrorIsSIDUser"
	case DSNameErrorSchemaGUIDControlRight:
		return "DSNameErrorSchemaGUIDControlRight"
	case DSNameErrorSchemaGUIDClass:
		return "DSNameErrorSchemaGUIDClass"
	case DSNameErrorSchemaGUIDAttributeSet:
		return "DSNameErrorSchemaGUIDAttributeSet"
	case DSNameErrorSchemaGUIDAttribute:
		return "DSNameErrorSchemaGUIDAttribute"
	case DSNameErrorSchemaGUIDNotFound:
		return "DSNameErrorSchemaGUIDNotFound"
	case DSNameErrorIsFPO:
		return "DSNameErrorIsFPO"
	}
	return "Invalid"
}

// DSNameFormat type represents DS_NAME_FORMAT RPC enumeration.
//
// The DS_NAME_FORMAT enumeration describes the format of a name sent to or received
// from the IDL_DRSCrackNames method.
type DSNameFormat uint32

var (
	// DS_UNKNOWN_NAME:  The server looks up the name by using the algorithm specified
	// in the LookupUnknownName procedure.
	DSNameFormatUnknownName DSNameFormat = 0
	// DS_FQDN_1779_NAME:  A distinguished name.
	DSNameFormatFQDN1779Name DSNameFormat = 1
	// DS_NT4_ACCOUNT_NAME:  Windows NT 4.0 operating system (and prior) name format. The
	// account name is in the format domain\user and the domain-only name is in the format
	// domain\.
	DSNameFormatNT4AccountName DSNameFormat = 2
	// DS_DISPLAY_NAME:  A user-friendly display name.
	DSNameFormatDisplayName DSNameFormat = 3
	// DS_UNIQUE_ID_NAME:  Curly braced string representation of an objectGUID. The format
	// of the string representation is specified in [MS-DTYP] section 2.3.4.3.
	DSNameFormatUniqueIDName DSNameFormat = 6
	// DS_CANONICAL_NAME:  A canonical name.
	DSNameFormatCanonicalName DSNameFormat = 7
	// DS_USER_PRINCIPAL_NAME:  User principal name.
	DSNameFormatUserPrincipalName DSNameFormat = 8
	// DS_CANONICAL_NAME_EX:  Same as DS_CANONICAL_NAME except that the rightmost forward
	// slash (/) is replaced with a newline character (\n).
	DSNameFormatCanonicalNameEx DSNameFormat = 9
	// DS_SERVICE_PRINCIPAL_NAME:  Service principal name (SPN).
	DSNameFormatServicePrincipalName DSNameFormat = 10
	// DS_SID_OR_SID_HISTORY_NAME:  String representation of a SID (as specified in [MS-DTYP]
	// section 2.4.2).
	DSNameFormatSIDOrSIDHistoryName DSNameFormat = 11
	// DS_DNS_DOMAIN_NAME:  Not supported.
	DSNameFormatDNSDomainName                     DSNameFormat = 12
	DSNameFormatListSites                         DSNameFormat = 4294967295
	DSNameFormatListServersInSite                 DSNameFormat = 4294967294
	DSNameFormatListDomainsInSite                 DSNameFormat = 4294967293
	DSNameFormatListServersForDomainInSite        DSNameFormat = 4294967292
	DSNameFormatListInfoForServer                 DSNameFormat = 4294967291
	DSNameFormatListRoles                         DSNameFormat = 4294967290
	DSNameFormatNT4AccountNameSANSDomain          DSNameFormat = 4294967289
	DSNameFormatMapSchemaGUID                     DSNameFormat = 4294967288
	DSNameFormatListDomains                       DSNameFormat = 4294967287
	DSNameFormatListNCS                           DSNameFormat = 4294967286
	DSNameFormatLtSecurityIdentitiesName          DSNameFormat = 4294967285
	DSNameFormatStringSIDName                     DSNameFormat = 4294967284
	DSNameFormatListServersWithDCSInSite          DSNameFormat = 4294967283
	DSNameFormatListGlobalCatalogServers          DSNameFormat = 4294967281
	DSNameFormatNT4AccountNameSANSDomainEx        DSNameFormat = 4294967280
	DSNameFormatUserPrincipalNameAndAltSecurityID DSNameFormat = 4294967279
	DSNameFormatUserPrincipalNameForLogon         DSNameFormat = 4294967282
)

func (o DSNameFormat) String() string {
	switch o {
	case DSNameFormatUnknownName:
		return "DSNameFormatUnknownName"
	case DSNameFormatFQDN1779Name:
		return "DSNameFormatFQDN1779Name"
	case DSNameFormatNT4AccountName:
		return "DSNameFormatNT4AccountName"
	case DSNameFormatDisplayName:
		return "DSNameFormatDisplayName"
	case DSNameFormatUniqueIDName:
		return "DSNameFormatUniqueIDName"
	case DSNameFormatCanonicalName:
		return "DSNameFormatCanonicalName"
	case DSNameFormatUserPrincipalName:
		return "DSNameFormatUserPrincipalName"
	case DSNameFormatCanonicalNameEx:
		return "DSNameFormatCanonicalNameEx"
	case DSNameFormatServicePrincipalName:
		return "DSNameFormatServicePrincipalName"
	case DSNameFormatSIDOrSIDHistoryName:
		return "DSNameFormatSIDOrSIDHistoryName"
	case DSNameFormatDNSDomainName:
		return "DSNameFormatDNSDomainName"
	case DSNameFormatListSites:
		return "DSNameFormatListSites"
	case DSNameFormatListServersInSite:
		return "DSNameFormatListServersInSite"
	case DSNameFormatListDomainsInSite:
		return "DSNameFormatListDomainsInSite"
	case DSNameFormatListServersForDomainInSite:
		return "DSNameFormatListServersForDomainInSite"
	case DSNameFormatListInfoForServer:
		return "DSNameFormatListInfoForServer"
	case DSNameFormatListRoles:
		return "DSNameFormatListRoles"
	case DSNameFormatNT4AccountNameSANSDomain:
		return "DSNameFormatNT4AccountNameSANSDomain"
	case DSNameFormatMapSchemaGUID:
		return "DSNameFormatMapSchemaGUID"
	case DSNameFormatListDomains:
		return "DSNameFormatListDomains"
	case DSNameFormatListNCS:
		return "DSNameFormatListNCS"
	case DSNameFormatLtSecurityIdentitiesName:
		return "DSNameFormatLtSecurityIdentitiesName"
	case DSNameFormatStringSIDName:
		return "DSNameFormatStringSIDName"
	case DSNameFormatListServersWithDCSInSite:
		return "DSNameFormatListServersWithDCSInSite"
	case DSNameFormatListGlobalCatalogServers:
		return "DSNameFormatListGlobalCatalogServers"
	case DSNameFormatNT4AccountNameSANSDomainEx:
		return "DSNameFormatNT4AccountNameSANSDomainEx"
	case DSNameFormatUserPrincipalNameAndAltSecurityID:
		return "DSNameFormatUserPrincipalNameAndAltSecurityID"
	case DSNameFormatUserPrincipalNameForLogon:
		return "DSNameFormatUserPrincipalNameForLogon"
	}
	return "Invalid"
}

// EncryptedPayload structure represents ENCRYPTED_PAYLOAD RPC structure.
//
// The ENCRYPTED_PAYLOAD packet is the concrete type for a value of an encrypted attribute.
//
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| Salt (16 bytes)                                                                                                               |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| CheckSum                                                                                                                      |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| EncryptedData (variable)                                                                                                      |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
type EncryptedPayload struct {
	// Salt (16 bytes): A 128-bit randomly generated value.
	Salt []byte `idl:"name:Salt" json:"salt"`
	// CheckSum (4 bytes): A 32-bit CRC32 checksum of the data that is encrypted along with
	// the data.
	CheckSum uint32 `idl:"name:CheckSum" json:"check_sum"`
	// EncryptedData (variable): A variable-length byte array that represents the encrypted
	// value.
	EncryptedData []byte `idl:"name:EncryptedData" json:"encrypted_data"`
}

func (o *EncryptedPayload) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *EncryptedPayload) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	for i1 := range o.Salt {
		i1 := i1
		if uint64(i1) >= 16 {
			break
		}
		if err := w.WriteData(o.Salt[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Salt); uint64(i1) < 16; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.CheckSum); err != nil {
		return err
	}
	for i1 := range o.EncryptedData {
		i1 := i1
		if err := w.WriteData(o.EncryptedData[i1]); err != nil {
			return err
		}
	}
	return nil
}
func (o *EncryptedPayload) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	o.Salt = make([]byte, 16)
	for i1 := range o.Salt {
		i1 := i1
		if err := w.ReadData(&o.Salt[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.CheckSum); err != nil {
		return err
	}
	for i1 := 0; w.Len() > 0; i1++ {
		i1 := i1
		o.EncryptedData = append(o.EncryptedData, uint8(0))
		if err := w.ReadData(&o.EncryptedData[i1]); err != nil {
			return err
		}
	}
	return nil
}

// NT4SID structure represents NT4SID RPC structure.
//
// The NT4SID structure defines a concrete type for a SID.
type NT4SID struct {
	// Data:  Bytes that make up a SID structure, as specified in [MS-DTYP] section 2.4.2,
	// in little-endian byte order.
	Data []byte `idl:"name:Data" json:"data"`
}

func (o *NT4SID) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *NT4SID) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	for i1 := range o.Data {
		i1 := i1
		if uint64(i1) >= 28 {
			break
		}
		if err := w.WriteData(o.Data[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Data); uint64(i1) < 28; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	return nil
}
func (o *NT4SID) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	o.Data = make([]byte, 28)
	for i1 := range o.Data {
		i1 := i1
		if err := w.ReadData(&o.Data[i1]); err != nil {
			return err
		}
	}
	return nil
}

// DSName structure represents DSNAME RPC structure.
//
// DSNAME is a concrete type for representing a DSName, identifying a directory object
// using the values of one or more of its LDAP attributes: objectGUID, objectSid, or
// distinguishedName.
type DSName struct {
	// structLen:  The length, in bytes, of the entire data structure.
	Length uint32 `idl:"name:structLen" json:"length"`
	// SidLen:  The number of bytes in the Sid field used to represent the object's objectSid
	// attribute value. Zero indicates that the DSNAME does not identify the objectSid value
	// of the directory object.
	SIDLength uint32 `idl:"name:SidLen" json:"sid_length"`
	// Guid:  The value of the object's objectGUID attribute specified as a GUID structure,
	// which is defined in [MS-DTYP] section 2.3.4. If the values for all fields in the
	// GUID structure are zero, this indicates that the DSNAME does not identify the objectGUID
	// value of the directory object.
	GUID *dtyp.GUID `idl:"name:Guid" json:"guid"`
	// Sid:  The value of the object's objectSid attribute, its security identifier, specified
	// as a SID structure, which is defined in [MS-DTYP] section 2.4.2. The size of this
	// field is exactly 28 bytes, regardless of the value of SidLen, which specifies how
	// many bytes in this field are used. Note that this is smaller than the theoretical
	// size limit of a SID, which is 68 bytes. While Windows publishes a general SID format,
	// Windows never uses that format in its full generality. 28 bytes is sufficient for
	// a Windows SID.
	SID *NT4SID `idl:"name:Sid" json:"sid"`
	// NameLen:  The number of characters in the StringName field, not including the terminating
	// null character, used to represent the object's distinguishedName attribute value.
	// Zero indicates that the DSNAME does not identify the distinguishedName value of the
	// directory object.
	NameLength uint32 `idl:"name:NameLen" json:"name_length"`
	// StringName:  A null-terminated Unicode value of the object's distinguishedName attribute,
	// as specified in [MS-ADTS] section 3.1.1.1.4. This field always contains at least
	// one character: the terminating null character. Each Unicode value is encoded as 2
	// bytes. The byte ordering is little-endian.<48>
	//
	// The following table shows an alternative representation of this structure.
	//
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
	//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| structLen                                                                                                                     |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| SidLen                                                                                                                        |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| Guid.Data1                                                                                                                    |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| Guid.Data2                                                    | Guid.Data3                                                    |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| Guid.Data4...                                                                                                                 |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| ...Guid.Data4                                                                                                                 |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| Sid...                                                                                                                        |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| ...Sid...                                                                                                                     |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| ...Sid...                                                                                                                     |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| ...Sid...                                                                                                                     |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| ...Sid...                                                                                                                     |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| ...Sid...                                                                                                                     |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| ...Sid                                                                                                                        |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| NameLen                                                                                                                       |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| StringName (Variable Length) ...                                                                                              |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//
	// Note  All fields have little-endian byte ordering.
	StringName string `idl:"name:StringName;size_is:((NameLen+1))" json:"string_name"`
}

func (o *DSName) xxx_PreparePayload(ctx context.Context) error {
	if o.StringName != "" && o.NameLength == 0 {
		o.NameLength = uint32((ndr.UTF16NLen(o.StringName) - 1))
		if ndr.UTF16NLen(o.StringName) < 1 {
			o.NameLength = uint32(0)
		}
	}
	if len(o.StringName) > int(10485761) {
		return fmt.Errorf("StringName is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *DSName) NDRSizeInfo() []uint64 {
	dimSize1 := uint64((o.NameLength + 1))
	return []uint64{
		dimSize1,
	}
}
func (o *DSName) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for sz1 := range sizeInfo {
			if err := w.WriteSize(sizeInfo[sz1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Length); err != nil {
		return err
	}
	if err := w.WriteData(o.SIDLength); err != nil {
		return err
	}
	if o.GUID != nil {
		if err := o.GUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.SID != nil {
		if err := o.SID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&NT4SID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.NameLength); err != nil {
		return err
	}
	_StringName_buf := utf16.Encode([]rune(o.StringName))
	if uint64(len(_StringName_buf)) > sizeInfo[0] {
		_StringName_buf = _StringName_buf[:sizeInfo[0]]
	}
	for i1 := range _StringName_buf {
		i1 := i1
		if uint64(i1) >= sizeInfo[0] {
			break
		}
		if err := w.WriteData(_StringName_buf[i1]); err != nil {
			return err
		}
	}
	for i1 := len(_StringName_buf); uint64(i1) < sizeInfo[0]; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSName) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for i1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[i1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Length); err != nil {
		return err
	}
	if err := w.ReadData(&o.SIDLength); err != nil {
		return err
	}
	if o.GUID == nil {
		o.GUID = &dtyp.GUID{}
	}
	if err := o.GUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.SID == nil {
		o.SID = &NT4SID{}
	}
	if err := o.SID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.NameLength); err != nil {
		return err
	}
	// XXX: for opaque unmarshaling
	if (o.NameLength+1) > 0 && sizeInfo[0] == 0 {
		sizeInfo[0] = uint64((o.NameLength + 1))
	}
	var _StringName_buf []uint16
	if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
		return fmt.Errorf("buffer overflow for size %d of array _StringName_buf", sizeInfo[0])
	}
	_StringName_buf = make([]uint16, sizeInfo[0])
	for i1 := range _StringName_buf {
		i1 := i1
		if err := w.ReadData(&_StringName_buf[i1]); err != nil {
			return err
		}
	}
	o.StringName = strings.TrimRight(string(utf16.Decode(_StringName_buf)), ndr.ZeroString)
	return nil
}

// Vector structure represents USN_VECTOR RPC structure.
//
// The USN_VECTOR structure defines a concrete type for the cookie (section 1.3.2) used
// to pass state between calls to IDL_DRSGetNCChanges.
type Vector struct {
	// usnHighObjUpdate:  A USN.
	HighObjectUpdate int64 `idl:"name:usnHighObjUpdate" json:"high_object_update"`
	// usnReserved:  A USN.
	_ int64 `idl:"name:usnReserved"`
	// usnHighPropUpdate:  A USN.
	//
	// The USN_VECTOR type, as shown, is used in the DRS IDL. However, only the size of
	// USN_VECTOR (24 bytes) and the representation of its null value (24 zero bytes) are
	// standardized for interoperability.
	HighPropertyUpdate int64 `idl:"name:usnHighPropUpdate" json:"high_property_update"`
}

func (o *Vector) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *Vector) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if err := w.WriteData(o.HighObjectUpdate); err != nil {
		return err
	}
	// reserved usnReserved
	if err := w.WriteData(int64(0)); err != nil {
		return err
	}
	if err := w.WriteData(o.HighPropertyUpdate); err != nil {
		return err
	}
	return nil
}
func (o *Vector) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if err := w.ReadData(&o.HighObjectUpdate); err != nil {
		return err
	}
	// reserved usnReserved
	var _usnReserved int64
	if err := w.ReadData(&_usnReserved); err != nil {
		return err
	}
	if err := w.ReadData(&o.HighPropertyUpdate); err != nil {
		return err
	}
	return nil
}

// UpToDateCursorV1 structure represents UPTODATE_CURSOR_V1 RPC structure.
//
// The UPTODATE_CURSOR_V1 structure is a concrete type for the replication state relative
// to a given DC.
type UpToDateCursorV1 struct {
	// uuidDsa:  The invocationId of the DC performing the update.
	DSA *dtyp.UUID `idl:"name:uuidDsa" json:"dsa"`
	// usnHighPropUpdate:  The USN of the update on the updating DC.
	//
	// A cursor c with c.uuidDsa = x and c.usnHighPropUpdate = y indicates a replication
	// state that includes all changes originated by DC x at USN less than or equal to y.
	HighPropertyUpdate int64 `idl:"name:usnHighPropUpdate" json:"high_property_update"`
}

func (o *UpToDateCursorV1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *UpToDateCursorV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if o.DSA != nil {
		if err := o.DSA.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.HighPropertyUpdate); err != nil {
		return err
	}
	return nil
}
func (o *UpToDateCursorV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if o.DSA == nil {
		o.DSA = &dtyp.UUID{}
	}
	if err := o.DSA.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.HighPropertyUpdate); err != nil {
		return err
	}
	return nil
}

// UpToDateVectorV1Ext structure represents UPTODATE_VECTOR_V1_EXT RPC structure.
//
// The UPTODATE_VECTOR_V1_EXT structure defines a concrete type for the replication
// state relative to a set of DCs.
type UpToDateVectorV1Ext struct {
	// dwVersion:  The version of this structure; MUST be 1.
	Version uint32 `idl:"name:dwVersion" json:"version"`
	// dwReserved1:  Unused. MUST be 0 and ignored.
	_ uint32 `idl:"name:dwReserved1"`
	// cNumCursors:  The number of items in the rgCursors array.
	CursorsCount uint32 `idl:"name:cNumCursors" json:"cursors_count"`
	// dwReserved2:  Unused. MUST be 0 and ignored.
	_ uint32 `idl:"name:dwReserved2"`
	// rgCursors:  An array of UPTODATE_CURSOR_V1. The items in this field MUST be sorted
	// in increasing order of the uuidDsa field.
	Cursors []*UpToDateCursorV1 `idl:"name:rgCursors;size_is:(cNumCursors)" json:"cursors"`
}

func (o *UpToDateVectorV1Ext) xxx_PreparePayload(ctx context.Context) error {
	if o.Cursors != nil && o.CursorsCount == 0 {
		o.CursorsCount = uint32(len(o.Cursors))
	}
	if o.CursorsCount > uint32(1048576) {
		return fmt.Errorf("CursorsCount is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *UpToDateVectorV1Ext) NDRSizeInfo() []uint64 {
	dimSize1 := uint64(o.CursorsCount)
	return []uint64{
		dimSize1,
	}
}
func (o *UpToDateVectorV1Ext) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for sz1 := range sizeInfo {
			if err := w.WriteSize(sizeInfo[sz1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if err := w.WriteData(o.Version); err != nil {
		return err
	}
	// reserved dwReserved1
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	if err := w.WriteData(o.CursorsCount); err != nil {
		return err
	}
	// reserved dwReserved2
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	for i1 := range o.Cursors {
		i1 := i1
		if uint64(i1) >= sizeInfo[0] {
			break
		}
		if o.Cursors[i1] != nil {
			if err := o.Cursors[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&UpToDateCursorV1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.Cursors); uint64(i1) < sizeInfo[0]; i1++ {
		if err := (&UpToDateCursorV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *UpToDateVectorV1Ext) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for i1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[i1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if err := w.ReadData(&o.Version); err != nil {
		return err
	}
	// reserved dwReserved1
	var _dwReserved1 uint32
	if err := w.ReadData(&_dwReserved1); err != nil {
		return err
	}
	if err := w.ReadData(&o.CursorsCount); err != nil {
		return err
	}
	// reserved dwReserved2
	var _dwReserved2 uint32
	if err := w.ReadData(&_dwReserved2); err != nil {
		return err
	}
	// XXX: for opaque unmarshaling
	if o.CursorsCount > 0 && sizeInfo[0] == 0 {
		sizeInfo[0] = uint64(o.CursorsCount)
	}
	if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
		return fmt.Errorf("buffer overflow for size %d of array o.Cursors", sizeInfo[0])
	}
	o.Cursors = make([]*UpToDateCursorV1, sizeInfo[0])
	for i1 := range o.Cursors {
		i1 := i1
		if o.Cursors[i1] == nil {
			o.Cursors[i1] = &UpToDateCursorV1{}
		}
		if err := o.Cursors[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// OID structure represents OID_t RPC structure.
//
// The OID_t structure defines a concrete type for an OID or a prefix of an OID; it
// is a component of type PrefixTableEntry.
type OID struct {
	// length:  The size, in bytes, of the elements array.
	Length uint32 `idl:"name:length" json:"length"`
	// elements:  An array of bytes that constitute an OID or a prefix of an OID.
	Elements []byte `idl:"name:elements;size_is:(length)" json:"elements"`
}

func (o *OID) xxx_PreparePayload(ctx context.Context) error {
	if o.Elements != nil && o.Length == 0 {
		o.Length = uint32(len(o.Elements))
	}
	if o.Length > uint32(10000) {
		return fmt.Errorf("Length is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *OID) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.Length); err != nil {
		return err
	}
	if o.Elements != nil || o.Length > 0 {
		_ptr_elements := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.Length)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Elements {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.Elements[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.Elements); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Elements, _ptr_elements); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *OID) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.Length); err != nil {
		return err
	}
	_ptr_elements := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.Length > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.Length)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Elements", sizeInfo[0])
		}
		o.Elements = make([]byte, sizeInfo[0])
		for i1 := range o.Elements {
			i1 := i1
			if err := w.ReadData(&o.Elements[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_elements := func(ptr interface{}) { o.Elements = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.Elements, _s_elements, _ptr_elements); err != nil {
		return err
	}
	return nil
}

// PrefixTableEntry structure represents PrefixTableEntry RPC structure.
//
// The PrefixTableEntry structure defines a concrete type for mapping a range of ATTRTYP
// values to and from OIDs. It is a component of the type SCHEMA_PREFIX_TABLE.
type PrefixTableEntry struct {
	// ndx:  The index assigned to the prefix.
	Index uint32 `idl:"name:ndx" json:"index"`
	// prefix:  An OID or a prefix of an OID.
	Prefix *OID `idl:"name:prefix" json:"prefix"`
}

func (o *PrefixTableEntry) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *PrefixTableEntry) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.Index); err != nil {
		return err
	}
	if o.Prefix != nil {
		if err := o.Prefix.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&OID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *PrefixTableEntry) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.Index); err != nil {
		return err
	}
	if o.Prefix == nil {
		o.Prefix = &OID{}
	}
	if err := o.Prefix.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// SchemaPrefixTable structure represents SCHEMA_PREFIX_TABLE RPC structure.
//
// The SCHEMA_PREFIX_TABLE structure defines the concrete type for a table to map ATTRTYP
// values to and from OIDs.
type SchemaPrefixTable struct {
	// PrefixCount:  The number of items in the pPrefixEntry array.
	PrefixCount uint32 `idl:"name:PrefixCount" json:"prefix_count"`
	// pPrefixEntry:  An array of PrefixTableEntry items in the table.
	PrefixEntry []*PrefixTableEntry `idl:"name:pPrefixEntry;size_is:(PrefixCount)" json:"prefix_entry"`
}

func (o *SchemaPrefixTable) xxx_PreparePayload(ctx context.Context) error {
	if o.PrefixEntry != nil && o.PrefixCount == 0 {
		o.PrefixCount = uint32(len(o.PrefixEntry))
	}
	if o.PrefixCount > uint32(1048576) {
		return fmt.Errorf("PrefixCount is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *SchemaPrefixTable) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.PrefixCount); err != nil {
		return err
	}
	if o.PrefixEntry != nil || o.PrefixCount > 0 {
		_ptr_pPrefixEntry := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.PrefixCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.PrefixEntry {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.PrefixEntry[i1] != nil {
					if err := o.PrefixEntry[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&PrefixTableEntry{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.PrefixEntry); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&PrefixTableEntry{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.PrefixEntry, _ptr_pPrefixEntry); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *SchemaPrefixTable) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.PrefixCount); err != nil {
		return err
	}
	_ptr_pPrefixEntry := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.PrefixCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.PrefixCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.PrefixEntry", sizeInfo[0])
		}
		o.PrefixEntry = make([]*PrefixTableEntry, sizeInfo[0])
		for i1 := range o.PrefixEntry {
			i1 := i1
			if o.PrefixEntry[i1] == nil {
				o.PrefixEntry[i1] = &PrefixTableEntry{}
			}
			if err := o.PrefixEntry[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_pPrefixEntry := func(ptr interface{}) { o.PrefixEntry = *ptr.(*[]*PrefixTableEntry) }
	if err := w.ReadPointer(&o.PrefixEntry, _s_pPrefixEntry, _ptr_pPrefixEntry); err != nil {
		return err
	}
	return nil
}

// PartialAttributeVectorV1Ext structure represents PARTIAL_ATTR_VECTOR_V1_EXT RPC structure.
//
// The PARTIAL_ATTR_VECTOR_V1_EXT structure defines a concrete type for a set of attributes
// to be replicated to a given partial replica.
type PartialAttributeVectorV1Ext struct {
	// dwVersion:  The version of this structure; MUST be 1.
	Version uint32 `idl:"name:dwVersion" json:"version"`
	// dwReserved1:  Unused. MUST be 0 and ignored.
	_ uint32 `idl:"name:dwReserved1"`
	// cAttrs:  The number of attributes in the rgPartialAttr array.
	AttrsCount uint32 `idl:"name:cAttrs" json:"attrs_count"`
	// rgPartialAttr:  The attributes in the set.
	PartialAttribute []uint32 `idl:"name:rgPartialAttr;size_is:(cAttrs)" json:"partial_attribute"`
}

func (o *PartialAttributeVectorV1Ext) xxx_PreparePayload(ctx context.Context) error {
	if o.PartialAttribute != nil && o.AttrsCount == 0 {
		o.AttrsCount = uint32(len(o.PartialAttribute))
	}
	if o.AttrsCount < uint32(1) || o.AttrsCount > uint32(1048576) {
		return fmt.Errorf("AttrsCount is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *PartialAttributeVectorV1Ext) NDRSizeInfo() []uint64 {
	dimSize1 := uint64(o.AttrsCount)
	return []uint64{
		dimSize1,
	}
}
func (o *PartialAttributeVectorV1Ext) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for sz1 := range sizeInfo {
			if err := w.WriteSize(sizeInfo[sz1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Version); err != nil {
		return err
	}
	// reserved dwReserved1
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	if err := w.WriteData(o.AttrsCount); err != nil {
		return err
	}
	for i1 := range o.PartialAttribute {
		i1 := i1
		if uint64(i1) >= sizeInfo[0] {
			break
		}
		if err := w.WriteData(o.PartialAttribute[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.PartialAttribute); uint64(i1) < sizeInfo[0]; i1++ {
		if err := w.WriteData(uint32(0)); err != nil {
			return err
		}
	}
	return nil
}
func (o *PartialAttributeVectorV1Ext) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for i1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[i1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Version); err != nil {
		return err
	}
	// reserved dwReserved1
	var _dwReserved1 uint32
	if err := w.ReadData(&_dwReserved1); err != nil {
		return err
	}
	if err := w.ReadData(&o.AttrsCount); err != nil {
		return err
	}
	// XXX: for opaque unmarshaling
	if o.AttrsCount > 0 && sizeInfo[0] == 0 {
		sizeInfo[0] = uint64(o.AttrsCount)
	}
	if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
		return fmt.Errorf("buffer overflow for size %d of array o.PartialAttribute", sizeInfo[0])
	}
	o.PartialAttribute = make([]uint32, sizeInfo[0])
	for i1 := range o.PartialAttribute {
		i1 := i1
		if err := w.ReadData(&o.PartialAttribute[i1]); err != nil {
			return err
		}
	}
	return nil
}

// MTXAddr structure represents MTX_ADDR RPC structure.
//
// The MTX_ADDR structure defines a concrete type for the network name of a DC.
type MTXAddr struct {
	// mtx_namelen:  A 32-bit, unsigned integer that specifies the number of bytes in mtx_name,
	// including a terminating null character.
	MTXNameLength uint32 `idl:"name:mtx_namelen" json:"mtx_name_length"`
	// mtx_name:  The UTF-8 encoding of a NetworkAddress.
	//
	// The following table shows an alternative representation of this structure.
	//
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
	//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| mtx_namelen                                                                                                                   |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| mtx_name (variable length) ...                                                                                                |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	MTXName []byte `idl:"name:mtx_name;size_is:(mtx_namelen)" json:"mtx_name"`
}

func (o *MTXAddr) xxx_PreparePayload(ctx context.Context) error {
	if o.MTXName != nil && o.MTXNameLength == 0 {
		o.MTXNameLength = uint32(len(o.MTXName))
	}
	if o.MTXNameLength < uint32(1) || o.MTXNameLength > uint32(256) {
		return fmt.Errorf("MTXNameLength is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *MTXAddr) NDRSizeInfo() []uint64 {
	dimSize1 := uint64(o.MTXNameLength)
	return []uint64{
		dimSize1,
	}
}
func (o *MTXAddr) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for sz1 := range sizeInfo {
			if err := w.WriteSize(sizeInfo[sz1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.MTXNameLength); err != nil {
		return err
	}
	for i1 := range o.MTXName {
		i1 := i1
		if uint64(i1) >= sizeInfo[0] {
			break
		}
		if err := w.WriteData(o.MTXName[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.MTXName); uint64(i1) < sizeInfo[0]; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	return nil
}
func (o *MTXAddr) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for i1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[i1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.MTXNameLength); err != nil {
		return err
	}
	// XXX: for opaque unmarshaling
	if o.MTXNameLength > 0 && sizeInfo[0] == 0 {
		sizeInfo[0] = uint64(o.MTXNameLength)
	}
	if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
		return fmt.Errorf("buffer overflow for size %d of array o.MTXName", sizeInfo[0])
	}
	o.MTXName = make([]byte, sizeInfo[0])
	for i1 := range o.MTXName {
		i1 := i1
		if err := w.ReadData(&o.MTXName[i1]); err != nil {
			return err
		}
	}
	return nil
}

// AttributeValue structure represents ATTRVAL RPC structure.
//
// The ATTRVAL structure defines a concrete type for the value of a single attribute.
type AttributeValue struct {
	// valLen:  The size, in bytes, of the pVal array.
	ValueLength uint32 `idl:"name:valLen" json:"value_length"`
	// pVal:  The value of the attribute. The encoding of the attribute varies by syntax,
	// as described in the following sections.
	Value []byte `idl:"name:pVal;size_is:(valLen)" json:"value"`
}

func (o *AttributeValue) xxx_PreparePayload(ctx context.Context) error {
	if o.Value != nil && o.ValueLength == 0 {
		o.ValueLength = uint32(len(o.Value))
	}
	if o.ValueLength > uint32(26214400) {
		return fmt.Errorf("ValueLength is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *AttributeValue) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.ValueLength); err != nil {
		return err
	}
	if o.Value != nil || o.ValueLength > 0 {
		_ptr_pVal := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.ValueLength)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Value {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.Value[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.Value); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Value, _ptr_pVal); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *AttributeValue) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.ValueLength); err != nil {
		return err
	}
	_ptr_pVal := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.ValueLength > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.ValueLength)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Value", sizeInfo[0])
		}
		o.Value = make([]byte, sizeInfo[0])
		for i1 := range o.Value {
			i1 := i1
			if err := w.ReadData(&o.Value[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_pVal := func(ptr interface{}) { o.Value = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.Value, _s_pVal, _ptr_pVal); err != nil {
		return err
	}
	return nil
}

// AttributeValueBlock structure represents ATTRVALBLOCK RPC structure.
//
// The ATTRVALBLOCK structure defines a concrete type for a sequence of attribute values.
type AttributeValueBlock struct {
	// valCount:  The number of items in the pAVal array.
	ValueCount uint32 `idl:"name:valCount" json:"value_count"`
	// pAVal:  The sequence of attribute values.
	Values []*AttributeValue `idl:"name:pAVal;size_is:(valCount)" json:"values"`
}

func (o *AttributeValueBlock) xxx_PreparePayload(ctx context.Context) error {
	if o.Values != nil && o.ValueCount == 0 {
		o.ValueCount = uint32(len(o.Values))
	}
	if o.ValueCount > uint32(10485760) {
		return fmt.Errorf("ValueCount is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *AttributeValueBlock) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.ValueCount); err != nil {
		return err
	}
	if o.Values != nil || o.ValueCount > 0 {
		_ptr_pAVal := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.ValueCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Values {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Values[i1] != nil {
					if err := o.Values[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&AttributeValue{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Values); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&AttributeValue{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Values, _ptr_pAVal); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *AttributeValueBlock) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.ValueCount); err != nil {
		return err
	}
	_ptr_pAVal := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.ValueCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.ValueCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Values", sizeInfo[0])
		}
		o.Values = make([]*AttributeValue, sizeInfo[0])
		for i1 := range o.Values {
			i1 := i1
			if o.Values[i1] == nil {
				o.Values[i1] = &AttributeValue{}
			}
			if err := o.Values[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_pAVal := func(ptr interface{}) { o.Values = *ptr.(*[]*AttributeValue) }
	if err := w.ReadPointer(&o.Values, _s_pAVal, _ptr_pAVal); err != nil {
		return err
	}
	return nil
}

// Attribute structure represents ATTR RPC structure.
//
// The ATTR structure defines a concrete type for the identity and values of an attribute.
type Attribute struct {
	// attrTyp:  An attribute.
	AttributeType uint32 `idl:"name:attrTyp" json:"attribute_type"`
	// AttrVal:  The sequence of values for this attribute.
	AttributeValue *AttributeValueBlock `idl:"name:AttrVal" json:"attribute_value"`
}

func (o *Attribute) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *Attribute) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.AttributeType); err != nil {
		return err
	}
	if o.AttributeValue != nil {
		if err := o.AttributeValue.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&AttributeValueBlock{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *Attribute) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.AttributeType); err != nil {
		return err
	}
	if o.AttributeValue == nil {
		o.AttributeValue = &AttributeValueBlock{}
	}
	if err := o.AttributeValue.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// AttributeBlock structure represents ATTRBLOCK RPC structure.
//
// The ATTRBLOCK structure defines a concrete type for a set of attributes and their
// values.
type AttributeBlock struct {
	// attrCount:  The number of items in the pAttr array.
	AttributeCount uint32 `idl:"name:attrCount" json:"attribute_count"`
	// pAttr:  An array of attributes and their values.
	Attribute []*Attribute `idl:"name:pAttr;size_is:(attrCount)" json:"attribute"`
}

func (o *AttributeBlock) xxx_PreparePayload(ctx context.Context) error {
	if o.Attribute != nil && o.AttributeCount == 0 {
		o.AttributeCount = uint32(len(o.Attribute))
	}
	if o.AttributeCount > uint32(1048576) {
		return fmt.Errorf("AttributeCount is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *AttributeBlock) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.AttributeCount); err != nil {
		return err
	}
	if o.Attribute != nil || o.AttributeCount > 0 {
		_ptr_pAttr := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.AttributeCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Attribute {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Attribute[i1] != nil {
					if err := o.Attribute[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&Attribute{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Attribute); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&Attribute{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Attribute, _ptr_pAttr); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *AttributeBlock) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.AttributeCount); err != nil {
		return err
	}
	_ptr_pAttr := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.AttributeCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.AttributeCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Attribute", sizeInfo[0])
		}
		o.Attribute = make([]*Attribute, sizeInfo[0])
		for i1 := range o.Attribute {
			i1 := i1
			if o.Attribute[i1] == nil {
				o.Attribute[i1] = &Attribute{}
			}
			if err := o.Attribute[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_pAttr := func(ptr interface{}) { o.Attribute = *ptr.(*[]*Attribute) }
	if err := w.ReadPointer(&o.Attribute, _s_pAttr, _ptr_pAttr); err != nil {
		return err
	}
	return nil
}

// EntityInfo structure represents ENTINF RPC structure.
//
// ENTINF is a concrete type for the identity and attributes (some or all) of a given
// object.
type EntityInfo struct {
	// pName:  The identity of the object.
	Name *DSName `idl:"name:pName" json:"name"`
	// ulFlags:  A flags field that supports the following flags, which are presented in
	// little-endian byte order.
	//
	//	+---+---+---+---+---+---+-----+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+-----+---+---+---+---+---+---+---+---+
	//	| 0 | 1 | 2 | 3 | 4 | 5 |  6  | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 |  3  | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
	//	|   |   |   |   |   |   |     |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |     |   |   |   |   |   |   | 0 |   |
	//	+---+---+---+---+---+---+-----+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+-----+---+---+---+---+---+---+---+---+
	//	+---+---+---+---+---+---+-----+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+-----+---+---+---+---+---+---+---+---+
	//	| X | X | X | X | X | X | D O | M | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | R M | X | X | X | X | X | X | X | X |
	//	+---+---+---+---+---+---+-----+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+-----+---+---+---+---+---+---+---+---+
	//
	// X: Unused. MUST be zero and ignored.
	//
	// M (ENTINF_FROM_MASTER, 0x00000001): Retrieved from a full replica.
	//
	// DO (ENTINF_DYNAMIC_OBJECT, 0x00000002): A dynamic object.
	Flags uint32 `idl:"name:ulFlags" json:"flags"`
	// AttrBlock:  Some of all of the attributes for this object, as determined by the particular
	// method. See section 1.3.3 for an overview of methods using type ENTINF.
	AttributeBlock *AttributeBlock `idl:"name:AttrBlock" json:"attribute_block"`
}

func (o *EntityInfo) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *EntityInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.Name != nil {
		_ptr_pName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Name != nil {
				if err := o.Name.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSName{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Name, _ptr_pName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	if o.AttributeBlock != nil {
		if err := o.AttributeBlock.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&AttributeBlock{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *EntityInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_pName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Name == nil {
			o.Name = &DSName{}
		}
		if err := o.Name.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pName := func(ptr interface{}) { o.Name = *ptr.(**DSName) }
	if err := w.ReadPointer(&o.Name, _s_pName, _ptr_pName); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	if o.AttributeBlock == nil {
		o.AttributeBlock = &AttributeBlock{}
	}
	if err := o.AttributeBlock.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// PropertyMetadataExt structure represents PROPERTY_META_DATA_EXT RPC structure.
//
// The PROPERTY_META_DATA_EXT structure defines a concrete type for the stamp of the
// last originating update to an attribute.
type PropertyMetadataExt struct {
	// dwVersion:  The version of the attribute values, starting at 1 and increasing by
	// one with each originating update.
	Version uint32 `idl:"name:dwVersion" json:"version"`
	// timeChanged:  The time at which the originating update was performed.
	TimeChanged int64 `idl:"name:timeChanged" json:"time_changed"`
	// uuidDsaOriginating:  The invocationId of the DC that performed the originating update.
	DSAOriginating *dtyp.UUID `idl:"name:uuidDsaOriginating" json:"dsa_originating"`
	// usnOriginating:  The USN of the DC assigned to the originating update.
	Originating int64 `idl:"name:usnOriginating" json:"originating"`
}

func (o *PropertyMetadataExt) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *PropertyMetadataExt) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if err := w.WriteData(o.Version); err != nil {
		return err
	}
	if err := w.WriteData(o.TimeChanged); err != nil {
		return err
	}
	if o.DSAOriginating != nil {
		if err := o.DSAOriginating.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Originating); err != nil {
		return err
	}
	return nil
}
func (o *PropertyMetadataExt) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if err := w.ReadData(&o.Version); err != nil {
		return err
	}
	if err := w.ReadData(&o.TimeChanged); err != nil {
		return err
	}
	if o.DSAOriginating == nil {
		o.DSAOriginating = &dtyp.UUID{}
	}
	if err := o.DSAOriginating.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.Originating); err != nil {
		return err
	}
	return nil
}

// PropertyMetadataExtVector structure represents PROPERTY_META_DATA_EXT_VECTOR RPC structure.
//
// The PROPERTY_META_DATA_EXT_VECTOR structure defines a concrete type for a sequence
// of attribute stamps.
type PropertyMetadataExtVector struct {
	// cNumProps:  The number of items in the rgMetaData array.
	PropertiesCount uint32 `idl:"name:cNumProps" json:"properties_count"`
	// rgMetaData:  An array of attribute stamps.
	Metadata []*PropertyMetadataExt `idl:"name:rgMetaData;size_is:(cNumProps)" json:"metadata"`
}

func (o *PropertyMetadataExtVector) xxx_PreparePayload(ctx context.Context) error {
	if o.Metadata != nil && o.PropertiesCount == 0 {
		o.PropertiesCount = uint32(len(o.Metadata))
	}
	if o.PropertiesCount > uint32(1048576) {
		return fmt.Errorf("PropertiesCount is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *PropertyMetadataExtVector) NDRSizeInfo() []uint64 {
	dimSize1 := uint64(o.PropertiesCount)
	return []uint64{
		dimSize1,
	}
}
func (o *PropertyMetadataExtVector) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for sz1 := range sizeInfo {
			if err := w.WriteSize(sizeInfo[sz1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if err := w.WriteData(o.PropertiesCount); err != nil {
		return err
	}
	for i1 := range o.Metadata {
		i1 := i1
		if uint64(i1) >= sizeInfo[0] {
			break
		}
		if o.Metadata[i1] != nil {
			if err := o.Metadata[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PropertyMetadataExt{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.Metadata); uint64(i1) < sizeInfo[0]; i1++ {
		if err := (&PropertyMetadataExt{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *PropertyMetadataExtVector) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for i1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[i1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if err := w.ReadData(&o.PropertiesCount); err != nil {
		return err
	}
	// XXX: for opaque unmarshaling
	if o.PropertiesCount > 0 && sizeInfo[0] == 0 {
		sizeInfo[0] = uint64(o.PropertiesCount)
	}
	if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
		return fmt.Errorf("buffer overflow for size %d of array o.Metadata", sizeInfo[0])
	}
	o.Metadata = make([]*PropertyMetadataExt, sizeInfo[0])
	for i1 := range o.Metadata {
		i1 := i1
		if o.Metadata[i1] == nil {
			o.Metadata[i1] = &PropertyMetadataExt{}
		}
		if err := o.Metadata[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// ReplicationEntityInfoList structure represents REPLENTINFLIST RPC structure.
//
// The REPLENTINFLIST structure defines a concrete type for updates to one or more attributes
// of a given object.
type ReplicationEntityInfoList struct {
	// pNextEntInf:  The next REPLENTINFLIST in the sequence, or null.
	NextEntityInfo *ReplicationEntityInfoList `idl:"name:pNextEntInf" json:"next_entity_info"`
	// Entinf:  The object and its updated attributes.
	EntityInfo *EntityInfo `idl:"name:Entinf" json:"entity_info"`
	// fIsNCPrefix:  TRUE only if the object is an NC root.
	IsNCPrefix bool `idl:"name:fIsNCPrefix" json:"is_nc_prefix"`
	// pParentGuid:  The value of the objectGUID attribute of the parent of the object,
	// or null if not known or not specified.
	ParentGUID *dtyp.UUID `idl:"name:pParentGuid" json:"parent_guid"`
	// pMetaDataExt:  The stamps for the attributes specified in Entinf.AttrBlock. Entinf.AttrBlock
	// and pMetaDataExt.rgMetaData are parallel arrays. For a given integer i in [0 .. Entinf.AttrBlock.attrCount],
	// the stamp for the attribute described by Entinf.AttrBlock.pAttr^[i] is pMetaDataExt^.rgMetaData[i].
	MetadataExt *PropertyMetadataExtVector `idl:"name:pMetaDataExt" json:"metadata_ext"`
}

func (o *ReplicationEntityInfoList) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ReplicationEntityInfoList) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.NextEntityInfo != nil {
		_ptr_pNextEntInf := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.NextEntityInfo != nil {
				if err := o.NextEntityInfo.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ReplicationEntityInfoList{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.NextEntityInfo, _ptr_pNextEntInf); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.EntityInfo != nil {
		if err := o.EntityInfo.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&EntityInfo{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if !o.IsNCPrefix {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if o.ParentGUID != nil {
		_ptr_pParentGuid := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ParentGUID != nil {
				if err := o.ParentGUID.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ParentGUID, _ptr_pParentGuid); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.MetadataExt != nil {
		_ptr_pMetaDataExt := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.MetadataExt != nil {
				if err := o.MetadataExt.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&PropertyMetadataExtVector{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.MetadataExt, _ptr_pMetaDataExt); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ReplicationEntityInfoList) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_pNextEntInf := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.NextEntityInfo == nil {
			o.NextEntityInfo = &ReplicationEntityInfoList{}
		}
		if err := o.NextEntityInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pNextEntInf := func(ptr interface{}) { o.NextEntityInfo = *ptr.(**ReplicationEntityInfoList) }
	if err := w.ReadPointer(&o.NextEntityInfo, _s_pNextEntInf, _ptr_pNextEntInf); err != nil {
		return err
	}
	if o.EntityInfo == nil {
		o.EntityInfo = &EntityInfo{}
	}
	if err := o.EntityInfo.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	var _bIsNCPrefix int32
	if err := w.ReadData(&_bIsNCPrefix); err != nil {
		return err
	}
	o.IsNCPrefix = _bIsNCPrefix != 0
	_ptr_pParentGuid := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ParentGUID == nil {
			o.ParentGUID = &dtyp.UUID{}
		}
		if err := o.ParentGUID.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pParentGuid := func(ptr interface{}) { o.ParentGUID = *ptr.(**dtyp.UUID) }
	if err := w.ReadPointer(&o.ParentGUID, _s_pParentGuid, _ptr_pParentGuid); err != nil {
		return err
	}
	_ptr_pMetaDataExt := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.MetadataExt == nil {
			o.MetadataExt = &PropertyMetadataExtVector{}
		}
		if err := o.MetadataExt.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pMetaDataExt := func(ptr interface{}) { o.MetadataExt = *ptr.(**PropertyMetadataExtVector) }
	if err := w.ReadPointer(&o.MetadataExt, _s_pMetaDataExt, _ptr_pMetaDataExt); err != nil {
		return err
	}
	return nil
}

// UpToDateCursorV2 structure represents UPTODATE_CURSOR_V2 RPC structure.
//
// The UPTODATE_CURSOR_V2 structure defines a concrete type for the replication state
// relative to a given DC.
type UpToDateCursorV2 struct {
	// uuidDsa:  The invocationId of the DC performing the update.
	DSA *dtyp.UUID `idl:"name:uuidDsa" json:"dsa"`
	// usnHighPropUpdate:  The USN of the update on the updating DC.
	HighPropertyUpdate int64 `idl:"name:usnHighPropUpdate" json:"high_property_update"`
	// timeLastSyncSuccess:  The time at which the last successful replication occurred
	// from the DC identified by uuidDsa; for replication latency reporting only.
	//
	// A cursor c with c.uuidDsa = x and c.usnHighPropUpdate = y indicates a replication
	// state that includes all changes originated by DC x at USN less than or equal to y.
	TimeLastSyncSuccess int64 `idl:"name:timeLastSyncSuccess" json:"time_last_sync_success"`
}

func (o *UpToDateCursorV2) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *UpToDateCursorV2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if o.DSA != nil {
		if err := o.DSA.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.HighPropertyUpdate); err != nil {
		return err
	}
	if err := w.WriteData(o.TimeLastSyncSuccess); err != nil {
		return err
	}
	return nil
}
func (o *UpToDateCursorV2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if o.DSA == nil {
		o.DSA = &dtyp.UUID{}
	}
	if err := o.DSA.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.HighPropertyUpdate); err != nil {
		return err
	}
	if err := w.ReadData(&o.TimeLastSyncSuccess); err != nil {
		return err
	}
	return nil
}

// UpToDateVectorV2Ext structure represents UPTODATE_VECTOR_V2_EXT RPC structure.
//
// The UPTODATE_VECTOR_V2_EXT structure defines a concrete type for the replication
// state relative to a set of DCs.
type UpToDateVectorV2Ext struct {
	// dwVersion:  The version of this structure; MUST be 2.
	Version uint32 `idl:"name:dwVersion" json:"version"`
	// dwReserved1:  Unused. MUST be 0 and ignored.
	_ uint32 `idl:"name:dwReserved1"`
	// cNumCursors:  The number of items in the rgCursors array.
	CursorsCount uint32 `idl:"name:cNumCursors" json:"cursors_count"`
	// dwReserved2:  Unused. MUST be 0 and ignored.
	_ uint32 `idl:"name:dwReserved2"`
	// rgCursors:  An array of UPTODATE_CURSOR_V2. The items in this field MUST be sorted
	// in increasing order of the uuidDsa field.
	Cursors []*UpToDateCursorV2 `idl:"name:rgCursors;size_is:(cNumCursors)" json:"cursors"`
}

func (o *UpToDateVectorV2Ext) xxx_PreparePayload(ctx context.Context) error {
	if o.Cursors != nil && o.CursorsCount == 0 {
		o.CursorsCount = uint32(len(o.Cursors))
	}
	if o.CursorsCount > uint32(1048576) {
		return fmt.Errorf("CursorsCount is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *UpToDateVectorV2Ext) NDRSizeInfo() []uint64 {
	dimSize1 := uint64(o.CursorsCount)
	return []uint64{
		dimSize1,
	}
}
func (o *UpToDateVectorV2Ext) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for sz1 := range sizeInfo {
			if err := w.WriteSize(sizeInfo[sz1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if err := w.WriteData(o.Version); err != nil {
		return err
	}
	// reserved dwReserved1
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	if err := w.WriteData(o.CursorsCount); err != nil {
		return err
	}
	// reserved dwReserved2
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	for i1 := range o.Cursors {
		i1 := i1
		if uint64(i1) >= sizeInfo[0] {
			break
		}
		if o.Cursors[i1] != nil {
			if err := o.Cursors[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&UpToDateCursorV2{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.Cursors); uint64(i1) < sizeInfo[0]; i1++ {
		if err := (&UpToDateCursorV2{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *UpToDateVectorV2Ext) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for i1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[i1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if err := w.ReadData(&o.Version); err != nil {
		return err
	}
	// reserved dwReserved1
	var _dwReserved1 uint32
	if err := w.ReadData(&_dwReserved1); err != nil {
		return err
	}
	if err := w.ReadData(&o.CursorsCount); err != nil {
		return err
	}
	// reserved dwReserved2
	var _dwReserved2 uint32
	if err := w.ReadData(&_dwReserved2); err != nil {
		return err
	}
	// XXX: for opaque unmarshaling
	if o.CursorsCount > 0 && sizeInfo[0] == 0 {
		sizeInfo[0] = uint64(o.CursorsCount)
	}
	if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
		return fmt.Errorf("buffer overflow for size %d of array o.Cursors", sizeInfo[0])
	}
	o.Cursors = make([]*UpToDateCursorV2, sizeInfo[0])
	for i1 := range o.Cursors {
		i1 := i1
		if o.Cursors[i1] == nil {
			o.Cursors[i1] = &UpToDateCursorV2{}
		}
		if err := o.Cursors[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// ValueMetadataExtV1 structure represents VALUE_META_DATA_EXT_V1 RPC structure.
//
// The VALUE_META_DATA_EXT_V1 structure defines a concrete type for the stamp of a link
// value.
type ValueMetadataExtV1 struct {
	// timeCreated:  The date and time at which the first originating update was made.
	TimeCreated int64 `idl:"name:timeCreated" json:"time_created"`
	// MetaData:  The remainder of the stamp; has the same PROPERTY_META_DATA_EXT type as
	// used for the stamp of an attribute.
	Metadata *PropertyMetadataExt `idl:"name:MetaData" json:"metadata"`
}

func (o *ValueMetadataExtV1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ValueMetadataExtV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if err := w.WriteData(o.TimeCreated); err != nil {
		return err
	}
	if o.Metadata != nil {
		if err := o.Metadata.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&PropertyMetadataExt{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *ValueMetadataExtV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if err := w.ReadData(&o.TimeCreated); err != nil {
		return err
	}
	if o.Metadata == nil {
		o.Metadata = &PropertyMetadataExt{}
	}
	if err := o.Metadata.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// ValueMetadataExtV3 structure represents VALUE_META_DATA_EXT_V3 RPC structure.
type ValueMetadataExtV3 struct {
	TimeCreated int64                `idl:"name:timeCreated" json:"time_created"`
	Metadata    *PropertyMetadataExt `idl:"name:MetaData" json:"metadata"`
	_           uint32               `idl:"name:unused1"`
	_           uint32               `idl:"name:unused2"`
	_           uint32               `idl:"name:unused3"`
	TimeExpired int64                `idl:"name:timeExpired" json:"time_expired"`
}

func (o *ValueMetadataExtV3) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ValueMetadataExtV3) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if err := w.WriteData(o.TimeCreated); err != nil {
		return err
	}
	if o.Metadata != nil {
		if err := o.Metadata.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&PropertyMetadataExt{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// reserved unused1
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved unused2
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved unused3
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	if err := w.WriteData(o.TimeExpired); err != nil {
		return err
	}
	return nil
}
func (o *ValueMetadataExtV3) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if err := w.ReadData(&o.TimeCreated); err != nil {
		return err
	}
	if o.Metadata == nil {
		o.Metadata = &PropertyMetadataExt{}
	}
	if err := o.Metadata.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved unused1
	var _unused1 uint32
	if err := w.ReadData(&_unused1); err != nil {
		return err
	}
	// reserved unused2
	var _unused2 uint32
	if err := w.ReadData(&_unused2); err != nil {
		return err
	}
	// reserved unused3
	var _unused3 uint32
	if err := w.ReadData(&_unused3); err != nil {
		return err
	}
	if err := w.ReadData(&o.TimeExpired); err != nil {
		return err
	}
	return nil
}

// ReplicationValueInfoV1 structure represents REPLVALINF_V1 RPC structure.
type ReplicationValueInfoV1 struct {
	Object        *DSName             `idl:"name:pObject" json:"object"`
	AttributeType uint32              `idl:"name:attrTyp" json:"attribute_type"`
	Aval          *AttributeValue     `idl:"name:Aval" json:"aval"`
	IsPresent     bool                `idl:"name:fIsPresent" json:"is_present"`
	Metadata      *ValueMetadataExtV1 `idl:"name:MetaData" json:"metadata"`
}

func (o *ReplicationValueInfoV1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ReplicationValueInfoV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if o.Object != nil {
		_ptr_pObject := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Object != nil {
				if err := o.Object.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSName{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Object, _ptr_pObject); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.AttributeType); err != nil {
		return err
	}
	if o.Aval != nil {
		if err := o.Aval.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&AttributeValue{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if !o.IsPresent {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if o.Metadata != nil {
		if err := o.Metadata.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ValueMetadataExtV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *ReplicationValueInfoV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	_ptr_pObject := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Object == nil {
			o.Object = &DSName{}
		}
		if err := o.Object.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pObject := func(ptr interface{}) { o.Object = *ptr.(**DSName) }
	if err := w.ReadPointer(&o.Object, _s_pObject, _ptr_pObject); err != nil {
		return err
	}
	if err := w.ReadData(&o.AttributeType); err != nil {
		return err
	}
	if o.Aval == nil {
		o.Aval = &AttributeValue{}
	}
	if err := o.Aval.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	var _bIsPresent int32
	if err := w.ReadData(&_bIsPresent); err != nil {
		return err
	}
	o.IsPresent = _bIsPresent != 0
	if o.Metadata == nil {
		o.Metadata = &ValueMetadataExtV1{}
	}
	if err := o.Metadata.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// ReplicationValueInfoV3 structure represents REPLVALINF_V3 RPC structure.
type ReplicationValueInfoV3 struct {
	Object        *DSName             `idl:"name:pObject" json:"object"`
	AttributeType uint32              `idl:"name:attrTyp" json:"attribute_type"`
	Aval          *AttributeValue     `idl:"name:Aval" json:"aval"`
	IsPresent     bool                `idl:"name:fIsPresent" json:"is_present"`
	Metadata      *ValueMetadataExtV3 `idl:"name:MetaData" json:"metadata"`
}

func (o *ReplicationValueInfoV3) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ReplicationValueInfoV3) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if o.Object != nil {
		_ptr_pObject := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Object != nil {
				if err := o.Object.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSName{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Object, _ptr_pObject); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.AttributeType); err != nil {
		return err
	}
	if o.Aval != nil {
		if err := o.Aval.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&AttributeValue{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if !o.IsPresent {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if o.Metadata != nil {
		if err := o.Metadata.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ValueMetadataExtV3{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *ReplicationValueInfoV3) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	_ptr_pObject := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Object == nil {
			o.Object = &DSName{}
		}
		if err := o.Object.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pObject := func(ptr interface{}) { o.Object = *ptr.(**DSName) }
	if err := w.ReadPointer(&o.Object, _s_pObject, _ptr_pObject); err != nil {
		return err
	}
	if err := w.ReadData(&o.AttributeType); err != nil {
		return err
	}
	if o.Aval == nil {
		o.Aval = &AttributeValue{}
	}
	if err := o.Aval.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	var _bIsPresent int32
	if err := w.ReadData(&_bIsPresent); err != nil {
		return err
	}
	o.IsPresent = _bIsPresent != 0
	if o.Metadata == nil {
		o.Metadata = &ValueMetadataExtV3{}
	}
	if err := o.Metadata.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// ReplicationTimes structure represents REPLTIMES RPC structure.
//
// The REPLTIMES structure defines a concrete type for times at which periodic replication
// occurs.
type ReplicationTimes struct {
	// rgTimes:  A byte array of length 84 that is used to set periodic replication times.
	// Each bit in this byte array represents a 15-minute period for which replication can
	// be scheduled within a one-week period. The replication schedule begins on Sunday
	// 12:00:00 AM UTC. Each byte in the array represents a two-hour period of a week in
	// ascending order, starting Sunday 12:00:00 AM UTC. The most significant bit of a byte
	// represents the earliest 15-minute period in the two-hour period, and the rest of
	// the bits in the byte represent their respective 15-minute periods in this order.
	//
	// The following diagram shows an alternative representation of this structure.
	//
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
	//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| rgTimes...                                                                                                                    |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| ...                                                                                                                           |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| ...rgTimes                                                                                                                    |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	Times []byte `idl:"name:rgTimes" json:"times"`
}

func (o *ReplicationTimes) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ReplicationTimes) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	for i1 := range o.Times {
		i1 := i1
		if uint64(i1) >= 84 {
			break
		}
		if err := w.WriteData(o.Times[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Times); uint64(i1) < 84; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	return nil
}
func (o *ReplicationTimes) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	o.Times = make([]byte, 84)
	for i1 := range o.Times {
		i1 := i1
		if err := w.ReadData(&o.Times[i1]); err != nil {
			return err
		}
	}
	return nil
}

// DSNameResultItem structure represents DS_NAME_RESULT_ITEMW RPC structure.
//
// The DS_NAME_RESULT_ITEMW structure defines the translated name returned by the IDL_DRSCrackNames
// method.
type DSNameResultItem struct {
	// status:  Status of the crack name operation for the corresponding element of the
	// rpNames field in the request. The status is one of the values from the enumeration
	// DS_NAME_ERROR.
	Status uint32 `idl:"name:status" json:"status"`
	// pDomain:  DNS domain name of the domain in which the named object resides.
	Domain string `idl:"name:pDomain;string;pointer:unique" json:"domain"`
	// pName:  Object name in the requested format.
	Name string `idl:"name:pName;string;pointer:unique" json:"name"`
}

func (o *DSNameResultItem) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSNameResultItem) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.Status); err != nil {
		return err
	}
	if o.Domain != "" {
		_ptr_pDomain := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Domain); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Domain, _ptr_pDomain); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.Name != "" {
		_ptr_pName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Name); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Name, _ptr_pName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSNameResultItem) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.Status); err != nil {
		return err
	}
	_ptr_pDomain := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Domain); err != nil {
			return err
		}
		return nil
	})
	_s_pDomain := func(ptr interface{}) { o.Domain = *ptr.(*string) }
	if err := w.ReadPointer(&o.Domain, _s_pDomain, _ptr_pDomain); err != nil {
		return err
	}
	_ptr_pName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Name); err != nil {
			return err
		}
		return nil
	})
	_s_pName := func(ptr interface{}) { o.Name = *ptr.(*string) }
	if err := w.ReadPointer(&o.Name, _s_pName, _ptr_pName); err != nil {
		return err
	}
	return nil
}

// DSNameResult structure represents DS_NAME_RESULTW RPC structure.
//
// The DS_NAME_RESULTW structure defines the translated names returned by the IDL_DRSCrackNames
// method.
type DSNameResult struct {
	// cItems:  The count of items in the rItems array.
	ItemsCount uint32 `idl:"name:cItems" json:"items_count"`
	// rItems:  Translated names that correspond one-to-one with the elements in the rpNames
	// field of the request.
	Items []*DSNameResultItem `idl:"name:rItems;size_is:(cItems)" json:"items"`
}

func (o *DSNameResult) xxx_PreparePayload(ctx context.Context) error {
	if o.Items != nil && o.ItemsCount == 0 {
		o.ItemsCount = uint32(len(o.Items))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSNameResult) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.ItemsCount); err != nil {
		return err
	}
	if o.Items != nil || o.ItemsCount > 0 {
		_ptr_rItems := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.ItemsCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Items {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Items[i1] != nil {
					if err := o.Items[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&DSNameResultItem{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Items); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&DSNameResultItem{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Items, _ptr_rItems); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSNameResult) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.ItemsCount); err != nil {
		return err
	}
	_ptr_rItems := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.ItemsCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.ItemsCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Items", sizeInfo[0])
		}
		o.Items = make([]*DSNameResultItem, sizeInfo[0])
		for i1 := range o.Items {
			i1 := i1
			if o.Items[i1] == nil {
				o.Items[i1] = &DSNameResultItem{}
			}
			if err := o.Items[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_rItems := func(ptr interface{}) { o.Items = *ptr.(*[]*DSNameResultItem) }
	if err := w.ReadPointer(&o.Items, _s_rItems, _ptr_rItems); err != nil {
		return err
	}
	return nil
}

// DSDomainControllerInfoV1 structure represents DS_DOMAIN_CONTROLLER_INFO_1W RPC structure.
//
// The DS_DOMAIN_CONTROLLER_INFO_1W structure defines DC information that is returned
// as a part of the response to an InfoLevel = 1 request. The struct contains information
// about a single DC in the domain.
type DSDomainControllerInfoV1 struct {
	// NetbiosName:  NetBIOS name of the DC.
	NetBIOSName string `idl:"name:NetbiosName;string;pointer:unique" json:"netbios_name"`
	// DnsHostName:  DNS host name of the DC.
	DNSHostName string `idl:"name:DnsHostName;string;pointer:unique" json:"dns_host_name"`
	// SiteName:  RDN of the site object.
	SiteName string `idl:"name:SiteName;string;pointer:unique" json:"site_name"`
	// ComputerObjectName:  DN of the computer object that corresponds to the DC.
	ComputerObjectName string `idl:"name:ComputerObjectName;string;pointer:unique" json:"computer_object_name"`
	// ServerObjectName:  DN of the server object that corresponds to the DC.
	ServerObjectName string `idl:"name:ServerObjectName;string;pointer:unique" json:"server_object_name"`
	// fIsPdc:  True if and only if the DC is the PDC FSMO role owner.
	IsPDC bool `idl:"name:fIsPdc" json:"is_pdc"`
	// fDsEnabled:  A Boolean value that indicates whether or not the machine is a domain
	// controller. This value MUST be TRUE.
	DSEnabled bool `idl:"name:fDsEnabled" json:"ds_enabled"`
}

func (o *DSDomainControllerInfoV1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSDomainControllerInfoV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.NetBIOSName != "" {
		_ptr_NetbiosName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.NetBIOSName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.NetBIOSName, _ptr_NetbiosName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.DNSHostName != "" {
		_ptr_DnsHostName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.DNSHostName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.DNSHostName, _ptr_DnsHostName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.SiteName != "" {
		_ptr_SiteName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.SiteName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.SiteName, _ptr_SiteName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.ComputerObjectName != "" {
		_ptr_ComputerObjectName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.ComputerObjectName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ComputerObjectName, _ptr_ComputerObjectName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.ServerObjectName != "" {
		_ptr_ServerObjectName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.ServerObjectName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerObjectName, _ptr_ServerObjectName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if !o.IsPDC {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if !o.DSEnabled {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSDomainControllerInfoV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_NetbiosName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.NetBIOSName); err != nil {
			return err
		}
		return nil
	})
	_s_NetbiosName := func(ptr interface{}) { o.NetBIOSName = *ptr.(*string) }
	if err := w.ReadPointer(&o.NetBIOSName, _s_NetbiosName, _ptr_NetbiosName); err != nil {
		return err
	}
	_ptr_DnsHostName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.DNSHostName); err != nil {
			return err
		}
		return nil
	})
	_s_DnsHostName := func(ptr interface{}) { o.DNSHostName = *ptr.(*string) }
	if err := w.ReadPointer(&o.DNSHostName, _s_DnsHostName, _ptr_DnsHostName); err != nil {
		return err
	}
	_ptr_SiteName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.SiteName); err != nil {
			return err
		}
		return nil
	})
	_s_SiteName := func(ptr interface{}) { o.SiteName = *ptr.(*string) }
	if err := w.ReadPointer(&o.SiteName, _s_SiteName, _ptr_SiteName); err != nil {
		return err
	}
	_ptr_ComputerObjectName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.ComputerObjectName); err != nil {
			return err
		}
		return nil
	})
	_s_ComputerObjectName := func(ptr interface{}) { o.ComputerObjectName = *ptr.(*string) }
	if err := w.ReadPointer(&o.ComputerObjectName, _s_ComputerObjectName, _ptr_ComputerObjectName); err != nil {
		return err
	}
	_ptr_ServerObjectName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.ServerObjectName); err != nil {
			return err
		}
		return nil
	})
	_s_ServerObjectName := func(ptr interface{}) { o.ServerObjectName = *ptr.(*string) }
	if err := w.ReadPointer(&o.ServerObjectName, _s_ServerObjectName, _ptr_ServerObjectName); err != nil {
		return err
	}
	var _bIsPDC int32
	if err := w.ReadData(&_bIsPDC); err != nil {
		return err
	}
	o.IsPDC = _bIsPDC != 0
	var _bDSEnabled int32
	if err := w.ReadData(&_bDSEnabled); err != nil {
		return err
	}
	o.DSEnabled = _bDSEnabled != 0
	return nil
}

// DSDomainControllerInfoV2 structure represents DS_DOMAIN_CONTROLLER_INFO_2W RPC structure.
//
// The DS_DOMAIN_CONTROLLER_INFO_2W structure defines DC information that is returned
// as a part of the response to an InfoLevel = 2 request. The struct contains information
// about a single DC in the domain.
type DSDomainControllerInfoV2 struct {
	// NetbiosName:  NetBIOS name of the DC.
	NetBIOSName string `idl:"name:NetbiosName;string;pointer:unique" json:"netbios_name"`
	// DnsHostName:  DNS host name of the DC.
	DNSHostName string `idl:"name:DnsHostName;string;pointer:unique" json:"dns_host_name"`
	// SiteName:  RDN of the site object.
	SiteName string `idl:"name:SiteName;string;pointer:unique" json:"site_name"`
	// SiteObjectName:  DN of the site object.
	SiteObjectName string `idl:"name:SiteObjectName;string;pointer:unique" json:"site_object_name"`
	// ComputerObjectName:  DN of the computer object that corresponds to the DC.
	ComputerObjectName string `idl:"name:ComputerObjectName;string;pointer:unique" json:"computer_object_name"`
	// ServerObjectName:  DN of the server object that corresponds to the DC.
	ServerObjectName string `idl:"name:ServerObjectName;string;pointer:unique" json:"server_object_name"`
	// NtdsDsaObjectName:  DN of the nTDSDSA object that corresponds to the DC.
	NTDSDSAObjectName string `idl:"name:NtdsDsaObjectName;string;pointer:unique" json:"ntds_dsa_object_name"`
	// fIsPdc:  True if and only if the DC is the PDC FSMO role owner.
	IsPDC bool `idl:"name:fIsPdc" json:"is_pdc"`
	// fDsEnabled:  A Boolean value that indicates whether or not the machine is a domain
	// controller. This value MUST be TRUE.
	DSEnabled bool `idl:"name:fDsEnabled" json:"ds_enabled"`
	// fIsGc:  True if and only if the DC is also a GC.
	IsGC bool `idl:"name:fIsGc" json:"is_gc"`
	// SiteObjectGuid:  The objectGUID attribute of the site object.
	SiteObjectGUID *dtyp.GUID `idl:"name:SiteObjectGuid" json:"site_object_guid"`
	// ComputerObjectGuid:  The objectGUID attribute of the computer object that corresponds
	// to the DC.
	ComputerObjectGUID *dtyp.GUID `idl:"name:ComputerObjectGuid" json:"computer_object_guid"`
	// ServerObjectGuid:  The objectGUID attribute of the server object that corresponds
	// to the DC.
	ServerObjectGUID *dtyp.GUID `idl:"name:ServerObjectGuid" json:"server_object_guid"`
	// NtdsDsaObjectGuid:  The objectGUID attribute of the nTDSDSA object that corresponds
	// to the DC.
	NTDSDSAObjectGUID *dtyp.GUID `idl:"name:NtdsDsaObjectGuid" json:"ntds_dsa_object_guid"`
}

func (o *DSDomainControllerInfoV2) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSDomainControllerInfoV2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.NetBIOSName != "" {
		_ptr_NetbiosName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.NetBIOSName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.NetBIOSName, _ptr_NetbiosName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.DNSHostName != "" {
		_ptr_DnsHostName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.DNSHostName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.DNSHostName, _ptr_DnsHostName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.SiteName != "" {
		_ptr_SiteName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.SiteName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.SiteName, _ptr_SiteName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.SiteObjectName != "" {
		_ptr_SiteObjectName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.SiteObjectName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.SiteObjectName, _ptr_SiteObjectName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.ComputerObjectName != "" {
		_ptr_ComputerObjectName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.ComputerObjectName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ComputerObjectName, _ptr_ComputerObjectName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.ServerObjectName != "" {
		_ptr_ServerObjectName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.ServerObjectName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerObjectName, _ptr_ServerObjectName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.NTDSDSAObjectName != "" {
		_ptr_NtdsDsaObjectName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.NTDSDSAObjectName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.NTDSDSAObjectName, _ptr_NtdsDsaObjectName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if !o.IsPDC {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if !o.DSEnabled {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if !o.IsGC {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if o.SiteObjectGUID != nil {
		if err := o.SiteObjectGUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.ComputerObjectGUID != nil {
		if err := o.ComputerObjectGUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.ServerObjectGUID != nil {
		if err := o.ServerObjectGUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.NTDSDSAObjectGUID != nil {
		if err := o.NTDSDSAObjectGUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSDomainControllerInfoV2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_NetbiosName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.NetBIOSName); err != nil {
			return err
		}
		return nil
	})
	_s_NetbiosName := func(ptr interface{}) { o.NetBIOSName = *ptr.(*string) }
	if err := w.ReadPointer(&o.NetBIOSName, _s_NetbiosName, _ptr_NetbiosName); err != nil {
		return err
	}
	_ptr_DnsHostName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.DNSHostName); err != nil {
			return err
		}
		return nil
	})
	_s_DnsHostName := func(ptr interface{}) { o.DNSHostName = *ptr.(*string) }
	if err := w.ReadPointer(&o.DNSHostName, _s_DnsHostName, _ptr_DnsHostName); err != nil {
		return err
	}
	_ptr_SiteName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.SiteName); err != nil {
			return err
		}
		return nil
	})
	_s_SiteName := func(ptr interface{}) { o.SiteName = *ptr.(*string) }
	if err := w.ReadPointer(&o.SiteName, _s_SiteName, _ptr_SiteName); err != nil {
		return err
	}
	_ptr_SiteObjectName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.SiteObjectName); err != nil {
			return err
		}
		return nil
	})
	_s_SiteObjectName := func(ptr interface{}) { o.SiteObjectName = *ptr.(*string) }
	if err := w.ReadPointer(&o.SiteObjectName, _s_SiteObjectName, _ptr_SiteObjectName); err != nil {
		return err
	}
	_ptr_ComputerObjectName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.ComputerObjectName); err != nil {
			return err
		}
		return nil
	})
	_s_ComputerObjectName := func(ptr interface{}) { o.ComputerObjectName = *ptr.(*string) }
	if err := w.ReadPointer(&o.ComputerObjectName, _s_ComputerObjectName, _ptr_ComputerObjectName); err != nil {
		return err
	}
	_ptr_ServerObjectName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.ServerObjectName); err != nil {
			return err
		}
		return nil
	})
	_s_ServerObjectName := func(ptr interface{}) { o.ServerObjectName = *ptr.(*string) }
	if err := w.ReadPointer(&o.ServerObjectName, _s_ServerObjectName, _ptr_ServerObjectName); err != nil {
		return err
	}
	_ptr_NtdsDsaObjectName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.NTDSDSAObjectName); err != nil {
			return err
		}
		return nil
	})
	_s_NtdsDsaObjectName := func(ptr interface{}) { o.NTDSDSAObjectName = *ptr.(*string) }
	if err := w.ReadPointer(&o.NTDSDSAObjectName, _s_NtdsDsaObjectName, _ptr_NtdsDsaObjectName); err != nil {
		return err
	}
	var _bIsPDC int32
	if err := w.ReadData(&_bIsPDC); err != nil {
		return err
	}
	o.IsPDC = _bIsPDC != 0
	var _bDSEnabled int32
	if err := w.ReadData(&_bDSEnabled); err != nil {
		return err
	}
	o.DSEnabled = _bDSEnabled != 0
	var _bIsGC int32
	if err := w.ReadData(&_bIsGC); err != nil {
		return err
	}
	o.IsGC = _bIsGC != 0
	if o.SiteObjectGUID == nil {
		o.SiteObjectGUID = &dtyp.GUID{}
	}
	if err := o.SiteObjectGUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.ComputerObjectGUID == nil {
		o.ComputerObjectGUID = &dtyp.GUID{}
	}
	if err := o.ComputerObjectGUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.ServerObjectGUID == nil {
		o.ServerObjectGUID = &dtyp.GUID{}
	}
	if err := o.ServerObjectGUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.NTDSDSAObjectGUID == nil {
		o.NTDSDSAObjectGUID = &dtyp.GUID{}
	}
	if err := o.NTDSDSAObjectGUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// DSDomainControllerInfoV3 structure represents DS_DOMAIN_CONTROLLER_INFO_3W RPC structure.
//
// The DS_DOMAIN_CONTROLLER_INFO_3W structure defines DC information that is returned
// as a part of the response to an InfoLevel = 3 request. The struct contains information
// about a single DC in the domain.
type DSDomainControllerInfoV3 struct {
	// NetbiosName:  NetBIOS name of the DC.
	NetBIOSName string `idl:"name:NetbiosName;string;pointer:unique" json:"netbios_name"`
	// DnsHostName:  DNS host name of the DC.
	DNSHostName string `idl:"name:DnsHostName;string;pointer:unique" json:"dns_host_name"`
	// SiteName:  RDN of the site object.
	SiteName string `idl:"name:SiteName;string;pointer:unique" json:"site_name"`
	// SiteObjectName:  DN of the site object.
	SiteObjectName string `idl:"name:SiteObjectName;string;pointer:unique" json:"site_object_name"`
	// ComputerObjectName:  DN of the computer object that corresponds to the DC.
	ComputerObjectName string `idl:"name:ComputerObjectName;string;pointer:unique" json:"computer_object_name"`
	// ServerObjectName:  DN of the server object that corresponds to the DC.
	ServerObjectName string `idl:"name:ServerObjectName;string;pointer:unique" json:"server_object_name"`
	// NtdsDsaObjectName:  DN of the nTDSDSA object that corresponds to the DC.
	NTDSDSAObjectName string `idl:"name:NtdsDsaObjectName;string;pointer:unique" json:"ntds_dsa_object_name"`
	// fIsPdc:  True if and only if the DC is the PDC FSMO role owner.
	IsPDC bool `idl:"name:fIsPdc" json:"is_pdc"`
	// fDsEnabled:  A Boolean value that indicates whether or not the machine is a domain
	// controller. This value MUST be TRUE.
	DSEnabled bool `idl:"name:fDsEnabled" json:"ds_enabled"`
	// fIsGc:  True if and only if the DC is also a GC.
	IsGC bool `idl:"name:fIsGc" json:"is_gc"`
	// fIsRodc:  True if and only if the DC is an RODC.
	IsReadOnlyDC bool `idl:"name:fIsRodc" json:"is_read_only_dc"`
	// SiteObjectGuid:  objectGUID of the site object.
	SiteObjectGUID *dtyp.GUID `idl:"name:SiteObjectGuid" json:"site_object_guid"`
	// ComputerObjectGuid:  objectGUID of the computer object that corresponds to the DC.
	ComputerObjectGUID *dtyp.GUID `idl:"name:ComputerObjectGuid" json:"computer_object_guid"`
	// ServerObjectGuid:  objectGUID of the server object that corresponds to the DC.
	ServerObjectGUID *dtyp.GUID `idl:"name:ServerObjectGuid" json:"server_object_guid"`
	// NtdsDsaObjectGuid:  objectGUID of the nTDSDSA object that corresponds to the DC.
	NTDSDSAObjectGUID *dtyp.GUID `idl:"name:NtdsDsaObjectGuid" json:"ntds_dsa_object_guid"`
}

func (o *DSDomainControllerInfoV3) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSDomainControllerInfoV3) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.NetBIOSName != "" {
		_ptr_NetbiosName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.NetBIOSName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.NetBIOSName, _ptr_NetbiosName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.DNSHostName != "" {
		_ptr_DnsHostName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.DNSHostName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.DNSHostName, _ptr_DnsHostName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.SiteName != "" {
		_ptr_SiteName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.SiteName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.SiteName, _ptr_SiteName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.SiteObjectName != "" {
		_ptr_SiteObjectName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.SiteObjectName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.SiteObjectName, _ptr_SiteObjectName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.ComputerObjectName != "" {
		_ptr_ComputerObjectName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.ComputerObjectName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ComputerObjectName, _ptr_ComputerObjectName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.ServerObjectName != "" {
		_ptr_ServerObjectName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.ServerObjectName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerObjectName, _ptr_ServerObjectName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.NTDSDSAObjectName != "" {
		_ptr_NtdsDsaObjectName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.NTDSDSAObjectName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.NTDSDSAObjectName, _ptr_NtdsDsaObjectName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if !o.IsPDC {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if !o.DSEnabled {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if !o.IsGC {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if !o.IsReadOnlyDC {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if o.SiteObjectGUID != nil {
		if err := o.SiteObjectGUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.ComputerObjectGUID != nil {
		if err := o.ComputerObjectGUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.ServerObjectGUID != nil {
		if err := o.ServerObjectGUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.NTDSDSAObjectGUID != nil {
		if err := o.NTDSDSAObjectGUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSDomainControllerInfoV3) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_NetbiosName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.NetBIOSName); err != nil {
			return err
		}
		return nil
	})
	_s_NetbiosName := func(ptr interface{}) { o.NetBIOSName = *ptr.(*string) }
	if err := w.ReadPointer(&o.NetBIOSName, _s_NetbiosName, _ptr_NetbiosName); err != nil {
		return err
	}
	_ptr_DnsHostName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.DNSHostName); err != nil {
			return err
		}
		return nil
	})
	_s_DnsHostName := func(ptr interface{}) { o.DNSHostName = *ptr.(*string) }
	if err := w.ReadPointer(&o.DNSHostName, _s_DnsHostName, _ptr_DnsHostName); err != nil {
		return err
	}
	_ptr_SiteName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.SiteName); err != nil {
			return err
		}
		return nil
	})
	_s_SiteName := func(ptr interface{}) { o.SiteName = *ptr.(*string) }
	if err := w.ReadPointer(&o.SiteName, _s_SiteName, _ptr_SiteName); err != nil {
		return err
	}
	_ptr_SiteObjectName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.SiteObjectName); err != nil {
			return err
		}
		return nil
	})
	_s_SiteObjectName := func(ptr interface{}) { o.SiteObjectName = *ptr.(*string) }
	if err := w.ReadPointer(&o.SiteObjectName, _s_SiteObjectName, _ptr_SiteObjectName); err != nil {
		return err
	}
	_ptr_ComputerObjectName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.ComputerObjectName); err != nil {
			return err
		}
		return nil
	})
	_s_ComputerObjectName := func(ptr interface{}) { o.ComputerObjectName = *ptr.(*string) }
	if err := w.ReadPointer(&o.ComputerObjectName, _s_ComputerObjectName, _ptr_ComputerObjectName); err != nil {
		return err
	}
	_ptr_ServerObjectName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.ServerObjectName); err != nil {
			return err
		}
		return nil
	})
	_s_ServerObjectName := func(ptr interface{}) { o.ServerObjectName = *ptr.(*string) }
	if err := w.ReadPointer(&o.ServerObjectName, _s_ServerObjectName, _ptr_ServerObjectName); err != nil {
		return err
	}
	_ptr_NtdsDsaObjectName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.NTDSDSAObjectName); err != nil {
			return err
		}
		return nil
	})
	_s_NtdsDsaObjectName := func(ptr interface{}) { o.NTDSDSAObjectName = *ptr.(*string) }
	if err := w.ReadPointer(&o.NTDSDSAObjectName, _s_NtdsDsaObjectName, _ptr_NtdsDsaObjectName); err != nil {
		return err
	}
	var _bIsPDC int32
	if err := w.ReadData(&_bIsPDC); err != nil {
		return err
	}
	o.IsPDC = _bIsPDC != 0
	var _bDSEnabled int32
	if err := w.ReadData(&_bDSEnabled); err != nil {
		return err
	}
	o.DSEnabled = _bDSEnabled != 0
	var _bIsGC int32
	if err := w.ReadData(&_bIsGC); err != nil {
		return err
	}
	o.IsGC = _bIsGC != 0
	var _bIsReadOnlyDC int32
	if err := w.ReadData(&_bIsReadOnlyDC); err != nil {
		return err
	}
	o.IsReadOnlyDC = _bIsReadOnlyDC != 0
	if o.SiteObjectGUID == nil {
		o.SiteObjectGUID = &dtyp.GUID{}
	}
	if err := o.SiteObjectGUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.ComputerObjectGUID == nil {
		o.ComputerObjectGUID = &dtyp.GUID{}
	}
	if err := o.ComputerObjectGUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.ServerObjectGUID == nil {
		o.ServerObjectGUID = &dtyp.GUID{}
	}
	if err := o.ServerObjectGUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.NTDSDSAObjectGUID == nil {
		o.NTDSDSAObjectGUID = &dtyp.GUID{}
	}
	if err := o.NTDSDSAObjectGUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// DSDomainControllerInfoVQ structure represents DS_DOMAIN_CONTROLLER_INFO_FFFFFFFFW RPC structure.
//
// The DS_DOMAIN_CONTROLLER_INFO_FFFFFFFFW structure defines DC information that is
// returned as a part of the response to an InfoLevel = 0xFFFFFFFF request. The struct
// contains information about a single LDAP connection to the current server.
type DSDomainControllerInfoVQ struct {
	// IPAddress:  The IPv4 address of the client that established the LDAP connection to
	// the server. If the client is connected with IPv6, this field MUST be zero.
	IPAddress uint32 `idl:"name:IPAddress" json:"ip_address"`
	// NotificationCount:  Number of LDAP notifications enabled on the server.
	NotificationCount uint32 `idl:"name:NotificationCount" json:"notification_count"`
	// secTimeConnected:  Total time in number of seconds that the connection is established.
	SecurityTimeConnected uint32 `idl:"name:secTimeConnected" json:"security_time_connected"`
	// Flags:  Zero or more of the bit flags from LDAP_CONN_PROPERTIES indicating the properties
	// of this connection.
	Flags uint32 `idl:"name:Flags" json:"flags"`
	// TotalRequests:  Total number of LDAP requests made on this LDAP connection.
	TotalRequests uint32 `idl:"name:TotalRequests" json:"total_requests"`
	// Reserved1:  Unused. MUST be 0 and ignored.
	_ uint32 `idl:"name:Reserved1"`
	// UserName:  Name of the security principal that established the LDAP connection.
	UserName string `idl:"name:UserName;string;pointer:unique" json:"user_name"`
}

func (o *DSDomainControllerInfoVQ) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSDomainControllerInfoVQ) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.IPAddress); err != nil {
		return err
	}
	if err := w.WriteData(o.NotificationCount); err != nil {
		return err
	}
	if err := w.WriteData(o.SecurityTimeConnected); err != nil {
		return err
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	if err := w.WriteData(o.TotalRequests); err != nil {
		return err
	}
	// reserved Reserved1
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	if o.UserName != "" {
		_ptr_UserName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.UserName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.UserName, _ptr_UserName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSDomainControllerInfoVQ) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.IPAddress); err != nil {
		return err
	}
	if err := w.ReadData(&o.NotificationCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.SecurityTimeConnected); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	if err := w.ReadData(&o.TotalRequests); err != nil {
		return err
	}
	// reserved Reserved1
	var _Reserved1 uint32
	if err := w.ReadData(&_Reserved1); err != nil {
		return err
	}
	_ptr_UserName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.UserName); err != nil {
			return err
		}
		return nil
	})
	_s_UserName := func(ptr interface{}) { o.UserName = *ptr.(*string) }
	if err := w.ReadPointer(&o.UserName, _s_UserName, _ptr_UserName); err != nil {
		return err
	}
	return nil
}

// EntityInfoList structure represents ENTINFLIST RPC structure.
//
// ENTINFLIST is a concrete type for a list of ENTINF entries.
type EntityInfoList struct {
	// pNextEntInf:  The next ENTINFLIST in the sequence, or null.
	NextEntityInfo *EntityInfoList `idl:"name:pNextEntInf" json:"next_entity_info"`
	// Entinf:  An ENTINF entry.
	EntityInfo *EntityInfo `idl:"name:Entinf" json:"entity_info"`
}

func (o *EntityInfoList) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *EntityInfoList) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.NextEntityInfo != nil {
		_ptr_pNextEntInf := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.NextEntityInfo != nil {
				if err := o.NextEntityInfo.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&EntityInfoList{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.NextEntityInfo, _ptr_pNextEntInf); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.EntityInfo != nil {
		if err := o.EntityInfo.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&EntityInfo{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *EntityInfoList) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_pNextEntInf := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.NextEntityInfo == nil {
			o.NextEntityInfo = &EntityInfoList{}
		}
		if err := o.NextEntityInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pNextEntInf := func(ptr interface{}) { o.NextEntityInfo = *ptr.(**EntityInfoList) }
	if err := w.ReadPointer(&o.NextEntityInfo, _s_pNextEntInf, _ptr_pNextEntInf); err != nil {
		return err
	}
	if o.EntityInfo == nil {
		o.EntityInfo = &EntityInfo{}
	}
	if err := o.EntityInfo.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// AttributeProblem structure represents INTFORMPROB_DRS_WIRE_V1 RPC structure.
//
// The INTFORMPROB_DRS_WIRE_V1 structure defines an attribute error.
type AttributeProblem struct {
	// dsid:  The implementation-specific diagnostic code.
	DSID uint32 `idl:"name:dsid" json:"dsid"`
	// extendedErr:  0, STATUS code, or Windows error code.
	ExtendedError uint32 `idl:"name:extendedErr" json:"extended_error"`
	// extendedData:  The implementation-specific diagnostic code.
	ExtendedData uint32 `idl:"name:extendedData" json:"extended_data"`
	// problem:  0 or PROBLEM error code (section 4.1.1.1.26).
	Problem uint16 `idl:"name:problem" json:"problem"`
	// type:  The attribute that was being processed when the error occurred.
	Type uint32 `idl:"name:type" json:"type"`
	// valReturned:  If true, the offending value is returned in the Val member.
	ValueReturned bool `idl:"name:valReturned" json:"value_returned"`
	// Val:  The offending value.
	Value *AttributeValue `idl:"name:Val" json:"value"`
}

func (o *AttributeProblem) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *AttributeProblem) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.DSID); err != nil {
		return err
	}
	if err := w.WriteData(o.ExtendedError); err != nil {
		return err
	}
	if err := w.WriteData(o.ExtendedData); err != nil {
		return err
	}
	if err := w.WriteData(o.Problem); err != nil {
		return err
	}
	if err := w.WriteData(o.Type); err != nil {
		return err
	}
	if !o.ValueReturned {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if o.Value != nil {
		if err := o.Value.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&AttributeValue{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *AttributeProblem) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.DSID); err != nil {
		return err
	}
	if err := w.ReadData(&o.ExtendedError); err != nil {
		return err
	}
	if err := w.ReadData(&o.ExtendedData); err != nil {
		return err
	}
	if err := w.ReadData(&o.Problem); err != nil {
		return err
	}
	if err := w.ReadData(&o.Type); err != nil {
		return err
	}
	var _bValueReturned int32
	if err := w.ReadData(&_bValueReturned); err != nil {
		return err
	}
	o.ValueReturned = _bValueReturned != 0
	if o.Value == nil {
		o.Value = &AttributeValue{}
	}
	if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// ProblemList structure represents PROBLEMLIST_DRS_WIRE_V1 RPC structure.
//
// The PROBLEMLIST_DRS_WIRE_V1 structure defines an attribute error link entry.
type ProblemList struct {
	// pNextProblem:  Null, or a pointer to the next item in the list.
	NextProblem *ProblemList `idl:"name:pNextProblem" json:"next_problem"`
	// intprob:  Attribute error description.
	AttributeProblem *AttributeProblem `idl:"name:intprob" json:"attribute_problem"`
}

func (o *ProblemList) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ProblemList) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.NextProblem != nil {
		_ptr_pNextProblem := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.NextProblem != nil {
				if err := o.NextProblem.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ProblemList{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.NextProblem, _ptr_pNextProblem); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.AttributeProblem != nil {
		if err := o.AttributeProblem.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&AttributeProblem{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *ProblemList) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_pNextProblem := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.NextProblem == nil {
			o.NextProblem = &ProblemList{}
		}
		if err := o.NextProblem.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pNextProblem := func(ptr interface{}) { o.NextProblem = *ptr.(**ProblemList) }
	if err := w.ReadPointer(&o.NextProblem, _s_pNextProblem, _ptr_pNextProblem); err != nil {
		return err
	}
	if o.AttributeProblem == nil {
		o.AttributeProblem = &AttributeProblem{}
	}
	if err := o.AttributeProblem.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// AttributeError structure represents ATRERR_DRS_WIRE_V1 RPC structure.
//
// The ATRERR_DRS_WIRE_V1 structure defines attribute errors.
type AttributeError struct {
	// pObject:  The identity of the object being processed when the error occurred.
	Object *DSName `idl:"name:pObject" json:"object"`
	// count:  The count of items in the FirstProblem linked list.
	Count uint32 `idl:"name:count" json:"count"`
	// FirstProblem:  The first element in the linked list of attribute errors.
	FirstProblem *ProblemList `idl:"name:FirstProblem" json:"first_problem"`
}

func (o *AttributeError) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *AttributeError) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.Object != nil {
		_ptr_pObject := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Object != nil {
				if err := o.Object.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSName{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Object, _ptr_pObject); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Count); err != nil {
		return err
	}
	if o.FirstProblem != nil {
		if err := o.FirstProblem.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ProblemList{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *AttributeError) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_pObject := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Object == nil {
			o.Object = &DSName{}
		}
		if err := o.Object.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pObject := func(ptr interface{}) { o.Object = *ptr.(**DSName) }
	if err := w.ReadPointer(&o.Object, _s_pObject, _ptr_pObject); err != nil {
		return err
	}
	if err := w.ReadData(&o.Count); err != nil {
		return err
	}
	if o.FirstProblem == nil {
		o.FirstProblem = &ProblemList{}
	}
	if err := o.FirstProblem.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// NameError structure represents NAMERR_DRS_WIRE_V1 RPC structure.
//
// The NAMERR_DRS_WIRE_V1 structure defines a name resolution error.
type NameError struct {
	// dsid:  The implementation-specific diagnostic code.
	DSID uint32 `idl:"name:dsid" json:"dsid"`
	// extendedErr:  0, STATUS code, or Windows error code.
	ExtendedError uint32 `idl:"name:extendedErr" json:"extended_error"`
	// extendedData:  The implementation-specific diagnostic code.
	ExtendedData uint32 `idl:"name:extendedData" json:"extended_data"`
	// problem:  0 or PROBLEM error code (section 4.1.1.1.26).
	Problem uint16 `idl:"name:problem" json:"problem"`
	// pMatched:  The best match for the supplied object identity.
	Matched *DSName `idl:"name:pMatched" json:"matched"`
}

func (o *NameError) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *NameError) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.DSID); err != nil {
		return err
	}
	if err := w.WriteData(o.ExtendedError); err != nil {
		return err
	}
	if err := w.WriteData(o.ExtendedData); err != nil {
		return err
	}
	if err := w.WriteData(o.Problem); err != nil {
		return err
	}
	if o.Matched != nil {
		_ptr_pMatched := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Matched != nil {
				if err := o.Matched.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSName{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Matched, _ptr_pMatched); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *NameError) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.DSID); err != nil {
		return err
	}
	if err := w.ReadData(&o.ExtendedError); err != nil {
		return err
	}
	if err := w.ReadData(&o.ExtendedData); err != nil {
		return err
	}
	if err := w.ReadData(&o.Problem); err != nil {
		return err
	}
	_ptr_pMatched := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Matched == nil {
			o.Matched = &DSName{}
		}
		if err := o.Matched.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pMatched := func(ptr interface{}) { o.Matched = *ptr.(**DSName) }
	if err := w.ReadPointer(&o.Matched, _s_pMatched, _ptr_pMatched); err != nil {
		return err
	}
	return nil
}

// NameResolutionOperation structure represents NAMERESOP_DRS_WIRE_V1 RPC structure.
//
// The NAMERESOP_DRS_WIRE_V1 structure defines the state of name resolution.
type NameResolutionOperation struct {
	// nameRes:  MUST be the uppercase ASCII character "S".
	NameResolution uint8 `idl:"name:nameRes" json:"name_resolution"`
	// unusedPad:  Unused. MUST be 0 and ignored.
	_ uint8 `idl:"name:unusedPad"`
	// nextRDN:  Unused. MUST be 0 and ignored.
	NextRDN uint16 `idl:"name:nextRDN" json:"next_rdn"`
}

func (o *NameResolutionOperation) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *NameResolutionOperation) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(2); err != nil {
		return err
	}
	if err := w.WriteData(o.NameResolution); err != nil {
		return err
	}
	// reserved unusedPad
	if err := w.WriteData(uint8(0)); err != nil {
		return err
	}
	if err := w.WriteData(o.NextRDN); err != nil {
		return err
	}
	return nil
}
func (o *NameResolutionOperation) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(2); err != nil {
		return err
	}
	if err := w.ReadData(&o.NameResolution); err != nil {
		return err
	}
	// reserved unusedPad
	var _unusedPad uint8
	if err := w.ReadData(&_unusedPad); err != nil {
		return err
	}
	if err := w.ReadData(&o.NextRDN); err != nil {
		return err
	}
	return nil
}

// AddressList structure represents DSA_ADDRESS_LIST_DRS_WIRE_V1 RPC structure.
//
// The DSA_ADDRESS_LIST_DRS_WIRE_V1 structure defines a linked list entry for a referral
// network name.
type AddressList struct {
	// pNextAddress:  Null, or the next element in the linked list.
	NextAddress *AddressList `idl:"name:pNextAddress" json:"next_address"`
	// pAddress:  Network name of the DC to which the referral is directed.
	Address *dtyp.UnicodeString `idl:"name:pAddress" json:"address"`
}

func (o *AddressList) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *AddressList) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(6); err != nil {
		return err
	}
	if o.NextAddress != nil {
		_ptr_pNextAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.NextAddress != nil {
				if err := o.NextAddress.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&AddressList{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.NextAddress, _ptr_pNextAddress); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.Address != nil {
		_ptr_pAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Address != nil {
				if err := o.Address.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Address, _ptr_pAddress); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *AddressList) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(6); err != nil {
		return err
	}
	_ptr_pNextAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.NextAddress == nil {
			o.NextAddress = &AddressList{}
		}
		if err := o.NextAddress.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pNextAddress := func(ptr interface{}) { o.NextAddress = *ptr.(**AddressList) }
	if err := w.ReadPointer(&o.NextAddress, _s_pNextAddress, _ptr_pNextAddress); err != nil {
		return err
	}
	_ptr_pAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Address == nil {
			o.Address = &dtyp.UnicodeString{}
		}
		if err := o.Address.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pAddress := func(ptr interface{}) { o.Address = *ptr.(**dtyp.UnicodeString) }
	if err := w.ReadPointer(&o.Address, _s_pAddress, _ptr_pAddress); err != nil {
		return err
	}
	return nil
}

// ContinuationReferral structure represents CONTREF_DRS_WIRE_V1 RPC structure.
//
// The CONTREF_DRS_WIRE_V1 structure defines a linked list entry for a continuation
// referral.
type ContinuationReferral struct {
	// pTarget:  The object to which the referral is directed.
	Target *DSName `idl:"name:pTarget" json:"target"`
	// OpState:  The operation state.
	OperationState *NameResolutionOperation `idl:"name:OpState" json:"operation_state"`
	// aliasRDN:  Unused. MUST be 0 and ignored.
	AliasRDN uint16 `idl:"name:aliasRDN" json:"alias_rdn"`
	// RDNsInternal:  Unused. MUST be 0 and ignored.
	RDNsInternal uint16 `idl:"name:RDNsInternal" json:"rdns_internal"`
	// refType:  The type of referral. This field MUST be one of the following values.
	//
	//	+-------------------------------+---------------------------------------------------------------------------------+
	//	|                               |                                                                                 |
	//	|             VALUE             |                                     MEANING                                     |
	//	|                               |                                                                                 |
	//	+-------------------------------+---------------------------------------------------------------------------------+
	//	+-------------------------------+---------------------------------------------------------------------------------+
	//	| CH_REFTYPE_SUPERIOR 0x0000    | A referral to a superior DC.                                                    |
	//	+-------------------------------+---------------------------------------------------------------------------------+
	//	| CH_REFTYPE_SUBORDINATE 0x0001 | A referral to a subordinate DC (for example, to a child domain).                |
	//	+-------------------------------+---------------------------------------------------------------------------------+
	//	| CH_REFTYPE_NSSR 0x0002        | Not in use.                                                                     |
	//	+-------------------------------+---------------------------------------------------------------------------------+
	//	| CH_REFTYPE_CROSS 0x0003       | A referral to an external crossRef object. See [MS-ADTS] section 6.1.1.2.1.1.1. |
	//	+-------------------------------+---------------------------------------------------------------------------------+
	Type uint16 `idl:"name:refType" json:"type"`
	// count:  The count of items in the pDAL linked list.
	Count uint16 `idl:"name:count" json:"count"`
	// pDAL:  A list of network names of the DCs to which the referral is directed.
	AddressList *AddressList `idl:"name:pDAL" json:"address_list"`
	// pNextContRef:  Null, or the next item in the linked list.
	NextContinuationReferral *ContinuationReferral `idl:"name:pNextContRef" json:"next_continuation_referral"`
	// bNewChoice:  True if and only if a new choice is specified.
	NewChoice bool `idl:"name:bNewChoice" json:"new_choice"`
	// choice:  The choice to use in the continuation referral. This field MUST be one of
	// the following values:
	//
	//	+------------------------------+----------------------------------------+
	//	|                              |                                        |
	//	|            VALUE             |                MEANING                 |
	//	|                              |                                        |
	//	+------------------------------+----------------------------------------+
	//	+------------------------------+----------------------------------------+
	//	| SE_CHOICE_BASE_ONLY 0x00     | A base search is to be performed.      |
	//	+------------------------------+----------------------------------------+
	//	| SE_CHOICE_IMMED_CHLDRN 0x01  | A one-level search is to be performed. |
	//	+------------------------------+----------------------------------------+
	//	| SE_CHOICE_WHOLE_SUBTREE 0x02 | A subtree search is to be performed.   |
	//	+------------------------------+----------------------------------------+
	Choice uint8 `idl:"name:choice" json:"choice"`
}

func (o *ContinuationReferral) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ContinuationReferral) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.Target != nil {
		_ptr_pTarget := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Target != nil {
				if err := o.Target.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSName{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Target, _ptr_pTarget); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.OperationState != nil {
		if err := o.OperationState.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&NameResolutionOperation{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.AliasRDN); err != nil {
		return err
	}
	if err := w.WriteData(o.RDNsInternal); err != nil {
		return err
	}
	if err := w.WriteData(o.Type); err != nil {
		return err
	}
	if err := w.WriteData(o.Count); err != nil {
		return err
	}
	if o.AddressList != nil {
		_ptr_pDAL := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.AddressList != nil {
				if err := o.AddressList.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&AddressList{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.AddressList, _ptr_pDAL); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.NextContinuationReferral != nil {
		_ptr_pNextContRef := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.NextContinuationReferral != nil {
				if err := o.NextContinuationReferral.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ContinuationReferral{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.NextContinuationReferral, _ptr_pNextContRef); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if !o.NewChoice {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Choice); err != nil {
		return err
	}
	return nil
}
func (o *ContinuationReferral) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_pTarget := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Target == nil {
			o.Target = &DSName{}
		}
		if err := o.Target.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pTarget := func(ptr interface{}) { o.Target = *ptr.(**DSName) }
	if err := w.ReadPointer(&o.Target, _s_pTarget, _ptr_pTarget); err != nil {
		return err
	}
	if o.OperationState == nil {
		o.OperationState = &NameResolutionOperation{}
	}
	if err := o.OperationState.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.AliasRDN); err != nil {
		return err
	}
	if err := w.ReadData(&o.RDNsInternal); err != nil {
		return err
	}
	if err := w.ReadData(&o.Type); err != nil {
		return err
	}
	if err := w.ReadData(&o.Count); err != nil {
		return err
	}
	_ptr_pDAL := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.AddressList == nil {
			o.AddressList = &AddressList{}
		}
		if err := o.AddressList.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pDAL := func(ptr interface{}) { o.AddressList = *ptr.(**AddressList) }
	if err := w.ReadPointer(&o.AddressList, _s_pDAL, _ptr_pDAL); err != nil {
		return err
	}
	_ptr_pNextContRef := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.NextContinuationReferral == nil {
			o.NextContinuationReferral = &ContinuationReferral{}
		}
		if err := o.NextContinuationReferral.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pNextContRef := func(ptr interface{}) { o.NextContinuationReferral = *ptr.(**ContinuationReferral) }
	if err := w.ReadPointer(&o.NextContinuationReferral, _s_pNextContRef, _ptr_pNextContRef); err != nil {
		return err
	}
	var _bNewChoice int32
	if err := w.ReadData(&_bNewChoice); err != nil {
		return err
	}
	o.NewChoice = _bNewChoice != 0
	if err := w.ReadData(&o.Choice); err != nil {
		return err
	}
	return nil
}

// ReferralError structure represents REFERR_DRS_WIRE_V1 RPC structure.
//
// The REFERR_DRS_WIRE_V1 structure defines a referral to other DCs.
type ReferralError struct {
	// dsid:  The implementation-specific diagnostic code.
	DSID uint32 `idl:"name:dsid" json:"dsid"`
	// extendedErr:  0, STATUS code, or Windows error code.
	ExtendedError uint32 `idl:"name:extendedErr" json:"extended_error"`
	// extendedData:  The implementation-specific diagnostic code.
	ExtendedData uint32 `idl:"name:extendedData" json:"extended_data"`
	// Refer:  The DCs to contact to chase the referral.
	Refer *ContinuationReferral `idl:"name:Refer" json:"refer"`
}

func (o *ReferralError) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ReferralError) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.DSID); err != nil {
		return err
	}
	if err := w.WriteData(o.ExtendedError); err != nil {
		return err
	}
	if err := w.WriteData(o.ExtendedData); err != nil {
		return err
	}
	if o.Refer != nil {
		if err := o.Refer.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ContinuationReferral{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *ReferralError) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.DSID); err != nil {
		return err
	}
	if err := w.ReadData(&o.ExtendedError); err != nil {
		return err
	}
	if err := w.ReadData(&o.ExtendedData); err != nil {
		return err
	}
	if o.Refer == nil {
		o.Refer = &ContinuationReferral{}
	}
	if err := o.Refer.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// SecurityError structure represents SECERR_DRS_WIRE_V1 RPC structure.
//
// The SECERR_DRS_WIRE_V1 structure defines a security error.
type SecurityError struct {
	// dsid:  The implementation-specific diagnostic code.
	DSID uint32 `idl:"name:dsid" json:"dsid"`
	// extendedErr:  0, STATUS code, or Windows error code.
	ExtendedError uint32 `idl:"name:extendedErr" json:"extended_error"`
	// extendedData:  The implementation-specific diagnostic code.
	ExtendedData uint32 `idl:"name:extendedData" json:"extended_data"`
	// problem:  0 or PROBLEM error code (section 4.1.1.1.26).
	Problem uint16 `idl:"name:problem" json:"problem"`
}

func (o *SecurityError) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *SecurityError) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.DSID); err != nil {
		return err
	}
	if err := w.WriteData(o.ExtendedError); err != nil {
		return err
	}
	if err := w.WriteData(o.ExtendedData); err != nil {
		return err
	}
	if err := w.WriteData(o.Problem); err != nil {
		return err
	}
	return nil
}
func (o *SecurityError) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.DSID); err != nil {
		return err
	}
	if err := w.ReadData(&o.ExtendedError); err != nil {
		return err
	}
	if err := w.ReadData(&o.ExtendedData); err != nil {
		return err
	}
	if err := w.ReadData(&o.Problem); err != nil {
		return err
	}
	return nil
}

// ServiceError structure represents SVCERR_DRS_WIRE_V1 RPC structure.
//
// The SVCERR_DRS_WIRE_V1 structure defines a service error.
type ServiceError struct {
	// dsid:  The implementation-specific diagnostic code.
	DSID uint32 `idl:"name:dsid" json:"dsid"`
	// extendedErr:  0, STATUS code, or Windows error code.
	ExtendedError uint32 `idl:"name:extendedErr" json:"extended_error"`
	// extendedData:  The implementation-specific diagnostic code.
	ExtendedData uint32 `idl:"name:extendedData" json:"extended_data"`
	// problem:  0 or PROBLEM error code (section 4.1.1.1.26).
	Problem uint16 `idl:"name:problem" json:"problem"`
}

func (o *ServiceError) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServiceError) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.DSID); err != nil {
		return err
	}
	if err := w.WriteData(o.ExtendedError); err != nil {
		return err
	}
	if err := w.WriteData(o.ExtendedData); err != nil {
		return err
	}
	if err := w.WriteData(o.Problem); err != nil {
		return err
	}
	return nil
}
func (o *ServiceError) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.DSID); err != nil {
		return err
	}
	if err := w.ReadData(&o.ExtendedError); err != nil {
		return err
	}
	if err := w.ReadData(&o.ExtendedData); err != nil {
		return err
	}
	if err := w.ReadData(&o.Problem); err != nil {
		return err
	}
	return nil
}

// UpdateError structure represents UPDERR_DRS_WIRE_V1 RPC structure.
//
// The UPDERR_DRS_WIRE_V1 structure defines an update error.
type UpdateError struct {
	// dsid:  The implementation-specific diagnostic code.
	DSID uint32 `idl:"name:dsid" json:"dsid"`
	// extendedErr:  0, STATUS code, or Windows error code.
	ExtendedError uint32 `idl:"name:extendedErr" json:"extended_error"`
	// extendedData:  The implementation-specific diagnostic code.
	ExtendedData uint32 `idl:"name:extendedData" json:"extended_data"`
	// problem:  0 or PROBLEM error code (section 4.1.1.1.26).
	Problem uint16 `idl:"name:problem" json:"problem"`
}

func (o *UpdateError) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *UpdateError) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.DSID); err != nil {
		return err
	}
	if err := w.WriteData(o.ExtendedError); err != nil {
		return err
	}
	if err := w.WriteData(o.ExtendedData); err != nil {
		return err
	}
	if err := w.WriteData(o.Problem); err != nil {
		return err
	}
	return nil
}
func (o *UpdateError) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.DSID); err != nil {
		return err
	}
	if err := w.ReadData(&o.ExtendedError); err != nil {
		return err
	}
	if err := w.ReadData(&o.ExtendedData); err != nil {
		return err
	}
	if err := w.ReadData(&o.Problem); err != nil {
		return err
	}
	return nil
}

// SystemError structure represents SYSERR_DRS_WIRE_V1 RPC structure.
//
// The SYSERR_DRS_WIRE_V1 structure defines a system error.
type SystemError struct {
	// dsid:  The implementation-specific diagnostic code.
	DSID uint32 `idl:"name:dsid" json:"dsid"`
	// extendedErr:  0, STATUS code, or Windows error code.
	ExtendedError uint32 `idl:"name:extendedErr" json:"extended_error"`
	// extendedData:  The implementation-specific diagnostic code.
	ExtendedData uint32 `idl:"name:extendedData" json:"extended_data"`
	// problem:  0 or PROBLEM error code (section 4.1.1.1.26).
	Problem uint16 `idl:"name:problem" json:"problem"`
}

func (o *SystemError) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *SystemError) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.DSID); err != nil {
		return err
	}
	if err := w.WriteData(o.ExtendedError); err != nil {
		return err
	}
	if err := w.WriteData(o.ExtendedData); err != nil {
		return err
	}
	if err := w.WriteData(o.Problem); err != nil {
		return err
	}
	return nil
}
func (o *SystemError) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.DSID); err != nil {
		return err
	}
	if err := w.ReadData(&o.ExtendedError); err != nil {
		return err
	}
	if err := w.ReadData(&o.ExtendedData); err != nil {
		return err
	}
	if err := w.ReadData(&o.Problem); err != nil {
		return err
	}
	return nil
}

// DirectoryError structure represents DIRERR_DRS_WIRE_V1 RPC union.
//
// The DIRERR_DRS_WIRE_V1 union defines the error that occurred during processing of
// a request sent to the IDL_DRSAddEntry method.
type DirectoryError struct {
	// Types that are assignable to Value
	//
	// *DirectoryError_AttributeError
	// *DirectoryError_NameError
	// *DirectoryError_ReferralError
	// *DirectoryError_SecurityError
	// *DirectoryError_ServiceError
	// *DirectoryError_UpdateError
	// *DirectoryError_SystemError
	Value is_DirectoryError `json:"value"`
}

func (o *DirectoryError) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *DirectoryError_AttributeError:
		if value != nil {
			return value.AttributeError
		}
	case *DirectoryError_NameError:
		if value != nil {
			return value.NameError
		}
	case *DirectoryError_ReferralError:
		if value != nil {
			return value.ReferralError
		}
	case *DirectoryError_SecurityError:
		if value != nil {
			return value.SecurityError
		}
	case *DirectoryError_ServiceError:
		if value != nil {
			return value.ServiceError
		}
	case *DirectoryError_UpdateError:
		if value != nil {
			return value.UpdateError
		}
	case *DirectoryError_SystemError:
		if value != nil {
			return value.SystemError
		}
	}
	return nil
}

type is_DirectoryError interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_DirectoryError()
}

func (o *DirectoryError) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *DirectoryError_AttributeError:
		return uint32(1)
	case *DirectoryError_NameError:
		return uint32(2)
	case *DirectoryError_ReferralError:
		return uint32(3)
	case *DirectoryError_SecurityError:
		return uint32(4)
	case *DirectoryError_ServiceError:
		return uint32(5)
	case *DirectoryError_UpdateError:
		return uint32(6)
	case *DirectoryError_SystemError:
		return uint32(7)
	}
	return uint32(0)
}

func (o *DirectoryError) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*DirectoryError_AttributeError)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DirectoryError_AttributeError{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(2):
		_o, _ := o.Value.(*DirectoryError_NameError)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DirectoryError_NameError{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(3):
		_o, _ := o.Value.(*DirectoryError_ReferralError)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DirectoryError_ReferralError{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(4):
		_o, _ := o.Value.(*DirectoryError_SecurityError)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DirectoryError_SecurityError{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(5):
		_o, _ := o.Value.(*DirectoryError_ServiceError)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DirectoryError_ServiceError{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(6):
		_o, _ := o.Value.(*DirectoryError_UpdateError)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DirectoryError_UpdateError{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(7):
		_o, _ := o.Value.(*DirectoryError_SystemError)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DirectoryError_SystemError{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *DirectoryError) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &DirectoryError_AttributeError{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(2):
		o.Value = &DirectoryError_NameError{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(3):
		o.Value = &DirectoryError_ReferralError{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(4):
		o.Value = &DirectoryError_SecurityError{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(5):
		o.Value = &DirectoryError_ServiceError{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(6):
		o.Value = &DirectoryError_UpdateError{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(7):
		o.Value = &DirectoryError_SystemError{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// DirectoryError_AttributeError structure represents DIRERR_DRS_WIRE_V1 RPC union arm.
//
// It has following labels: 1
type DirectoryError_AttributeError struct {
	// AtrErr:  Attribute errors.
	AttributeError *AttributeError `idl:"name:AtrErr" json:"attribute_error"`
}

func (*DirectoryError_AttributeError) is_DirectoryError() {}

func (o *DirectoryError_AttributeError) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.AttributeError != nil {
		if err := o.AttributeError.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&AttributeError{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *DirectoryError_AttributeError) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.AttributeError == nil {
		o.AttributeError = &AttributeError{}
	}
	if err := o.AttributeError.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// DirectoryError_NameError structure represents DIRERR_DRS_WIRE_V1 RPC union arm.
//
// It has following labels: 2
type DirectoryError_NameError struct {
	// NamErr:  Name resolution error.
	NameError *NameError `idl:"name:NamErr" json:"name_error"`
}

func (*DirectoryError_NameError) is_DirectoryError() {}

func (o *DirectoryError_NameError) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.NameError != nil {
		if err := o.NameError.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&NameError{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *DirectoryError_NameError) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.NameError == nil {
		o.NameError = &NameError{}
	}
	if err := o.NameError.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// DirectoryError_ReferralError structure represents DIRERR_DRS_WIRE_V1 RPC union arm.
//
// It has following labels: 3
type DirectoryError_ReferralError struct {
	// RefErr:  Referral.
	ReferralError *ReferralError `idl:"name:RefErr" json:"referral_error"`
}

func (*DirectoryError_ReferralError) is_DirectoryError() {}

func (o *DirectoryError_ReferralError) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ReferralError != nil {
		if err := o.ReferralError.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ReferralError{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *DirectoryError_ReferralError) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.ReferralError == nil {
		o.ReferralError = &ReferralError{}
	}
	if err := o.ReferralError.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// DirectoryError_SecurityError structure represents DIRERR_DRS_WIRE_V1 RPC union arm.
//
// It has following labels: 4
type DirectoryError_SecurityError struct {
	// SecErr:  Security error.
	SecurityError *SecurityError `idl:"name:SecErr" json:"security_error"`
}

func (*DirectoryError_SecurityError) is_DirectoryError() {}

func (o *DirectoryError_SecurityError) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.SecurityError != nil {
		if err := o.SecurityError.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&SecurityError{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *DirectoryError_SecurityError) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.SecurityError == nil {
		o.SecurityError = &SecurityError{}
	}
	if err := o.SecurityError.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// DirectoryError_ServiceError structure represents DIRERR_DRS_WIRE_V1 RPC union arm.
//
// It has following labels: 5
type DirectoryError_ServiceError struct {
	// SvcErr:  Service error.
	ServiceError *ServiceError `idl:"name:SvcErr" json:"service_error"`
}

func (*DirectoryError_ServiceError) is_DirectoryError() {}

func (o *DirectoryError_ServiceError) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServiceError != nil {
		if err := o.ServiceError.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ServiceError{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *DirectoryError_ServiceError) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.ServiceError == nil {
		o.ServiceError = &ServiceError{}
	}
	if err := o.ServiceError.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// DirectoryError_UpdateError structure represents DIRERR_DRS_WIRE_V1 RPC union arm.
//
// It has following labels: 6
type DirectoryError_UpdateError struct {
	// UpdErr:  Update error.
	UpdateError *UpdateError `idl:"name:UpdErr" json:"update_error"`
}

func (*DirectoryError_UpdateError) is_DirectoryError() {}

func (o *DirectoryError_UpdateError) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.UpdateError != nil {
		if err := o.UpdateError.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&UpdateError{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *DirectoryError_UpdateError) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.UpdateError == nil {
		o.UpdateError = &UpdateError{}
	}
	if err := o.UpdateError.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// DirectoryError_SystemError structure represents DIRERR_DRS_WIRE_V1 RPC union arm.
//
// It has following labels: 7
type DirectoryError_SystemError struct {
	// SysErr:  System error.
	SystemError *SystemError `idl:"name:SysErr" json:"system_error"`
}

func (*DirectoryError_SystemError) is_DirectoryError() {}

func (o *DirectoryError_SystemError) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.SystemError != nil {
		if err := o.SystemError.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&SystemError{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *DirectoryError_SystemError) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.SystemError == nil {
		o.SystemError = &SystemError{}
	}
	if err := o.SystemError.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// DSReplicationNeighbor structure represents DS_REPL_NEIGHBORW RPC structure.
//
// The DS_REPL_NEIGHBORW structure defines a replication neighbor. This structure is
// a concrete representation of a RepsFrom or RepsTo value.
type DSReplicationNeighbor struct {
	// pszNamingContext:  The NC root of the NC replica.
	NamingContext string `idl:"name:pszNamingContext;string" json:"naming_context"`
	// pszSourceDsaDN:  The DN of the server DC nTDSDSA object.
	SourceDSADN string `idl:"name:pszSourceDsaDN;string" json:"source_dsa_dn"`
	// pszSourceDsaAddress:  The NetworkAddress of the server DC.
	SourceDSAAddress string `idl:"name:pszSourceDsaAddress;string" json:"source_dsa_address"`
	// pszAsyncIntersiteTransportDN:  The DN of the interSiteTransport object corresponding
	// to the transport used to communicate with the server DC.
	AsyncIntersiteTransportDN string `idl:"name:pszAsyncIntersiteTransportDN;string" json:"async_intersite_transport_dn"`
	// dwReplicaFlags:  The DRS_OPTIONS flags.
	ReplicaFlags uint32 `idl:"name:dwReplicaFlags" json:"replica_flags"`
	// dwReserved:  Unused. MUST be 0 and ignored.
	_ uint32 `idl:"name:dwReserved"`
	// uuidNamingContextObjGuid:  The objectGUID of the NC root.
	NamingContextObjectGUID *dtyp.UUID `idl:"name:uuidNamingContextObjGuid" json:"naming_context_object_guid"`
	// uuidSourceDsaObjGuid:  The DSA GUID of the server DC.
	SourceDSAObjectGUID *dtyp.UUID `idl:"name:uuidSourceDsaObjGuid" json:"source_dsa_object_guid"`
	// uuidSourceDsaInvocationID:  The invocation ID associated with the server DC.
	SourceDSAInvocationID *dtyp.UUID `idl:"name:uuidSourceDsaInvocationID" json:"source_dsa_invocation_id"`
	// uuidAsyncIntersiteTransportObjGuid:  The objectGUID of the interSiteTransport object
	// corresponding to the transport used to communicate with the server DC.
	AsyncIntersiteTransportObjectGUID *dtyp.UUID `idl:"name:uuidAsyncIntersiteTransportObjGuid" json:"async_intersite_transport_object_guid"`
	// usnLastObjChangeSynced:  An implementation-specific value.
	LastObjectChangeSynced int64 `idl:"name:usnLastObjChangeSynced" json:"last_object_change_synced"`
	// usnAttributeFilter:  An implementation-specific value.
	AttributeFilter int64 `idl:"name:usnAttributeFilter" json:"attribute_filter"`
	// ftimeLastSyncSuccess:  The time of the last successful replication from the server
	// DC.
	LastSyncSuccess *dtyp.Filetime `idl:"name:ftimeLastSyncSuccess" json:"last_sync_success"`
	// ftimeLastSyncAttempt:  The time of the last attempt to replicate from the server
	// DC.
	LastSyncAttempt *dtyp.Filetime `idl:"name:ftimeLastSyncAttempt" json:"last_sync_attempt"`
	// dwLastSyncResult:  0, or the Windows error code, as specified in [MS-ERREF] section
	// 2.2, resulting from the last sync attempt.
	LastSyncResult uint32 `idl:"name:dwLastSyncResult" json:"last_sync_result"`
	// cNumConsecutiveSyncFailures:  The number of consecutive failures to replicate from
	// the server DC.
	ConsecutiveSyncFailuresCount uint32 `idl:"name:cNumConsecutiveSyncFailures" json:"consecutive_sync_failures_count"`
}

func (o *DSReplicationNeighbor) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSReplicationNeighbor) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if o.NamingContext != "" {
		_ptr_pszNamingContext := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.NamingContext); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.NamingContext, _ptr_pszNamingContext); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.SourceDSADN != "" {
		_ptr_pszSourceDsaDN := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.SourceDSADN); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.SourceDSADN, _ptr_pszSourceDsaDN); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.SourceDSAAddress != "" {
		_ptr_pszSourceDsaAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.SourceDSAAddress); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.SourceDSAAddress, _ptr_pszSourceDsaAddress); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.AsyncIntersiteTransportDN != "" {
		_ptr_pszAsyncIntersiteTransportDN := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.AsyncIntersiteTransportDN); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.AsyncIntersiteTransportDN, _ptr_pszAsyncIntersiteTransportDN); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.ReplicaFlags); err != nil {
		return err
	}
	// reserved dwReserved
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	if o.NamingContextObjectGUID != nil {
		if err := o.NamingContextObjectGUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.SourceDSAObjectGUID != nil {
		if err := o.SourceDSAObjectGUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.SourceDSAInvocationID != nil {
		if err := o.SourceDSAInvocationID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.AsyncIntersiteTransportObjectGUID != nil {
		if err := o.AsyncIntersiteTransportObjectGUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.LastObjectChangeSynced); err != nil {
		return err
	}
	if err := w.WriteData(o.AttributeFilter); err != nil {
		return err
	}
	if o.LastSyncSuccess != nil {
		if err := o.LastSyncSuccess.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.Filetime{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.LastSyncAttempt != nil {
		if err := o.LastSyncAttempt.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.Filetime{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.LastSyncResult); err != nil {
		return err
	}
	if err := w.WriteData(o.ConsecutiveSyncFailuresCount); err != nil {
		return err
	}
	return nil
}
func (o *DSReplicationNeighbor) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	_ptr_pszNamingContext := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.NamingContext); err != nil {
			return err
		}
		return nil
	})
	_s_pszNamingContext := func(ptr interface{}) { o.NamingContext = *ptr.(*string) }
	if err := w.ReadPointer(&o.NamingContext, _s_pszNamingContext, _ptr_pszNamingContext); err != nil {
		return err
	}
	_ptr_pszSourceDsaDN := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.SourceDSADN); err != nil {
			return err
		}
		return nil
	})
	_s_pszSourceDsaDN := func(ptr interface{}) { o.SourceDSADN = *ptr.(*string) }
	if err := w.ReadPointer(&o.SourceDSADN, _s_pszSourceDsaDN, _ptr_pszSourceDsaDN); err != nil {
		return err
	}
	_ptr_pszSourceDsaAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.SourceDSAAddress); err != nil {
			return err
		}
		return nil
	})
	_s_pszSourceDsaAddress := func(ptr interface{}) { o.SourceDSAAddress = *ptr.(*string) }
	if err := w.ReadPointer(&o.SourceDSAAddress, _s_pszSourceDsaAddress, _ptr_pszSourceDsaAddress); err != nil {
		return err
	}
	_ptr_pszAsyncIntersiteTransportDN := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.AsyncIntersiteTransportDN); err != nil {
			return err
		}
		return nil
	})
	_s_pszAsyncIntersiteTransportDN := func(ptr interface{}) { o.AsyncIntersiteTransportDN = *ptr.(*string) }
	if err := w.ReadPointer(&o.AsyncIntersiteTransportDN, _s_pszAsyncIntersiteTransportDN, _ptr_pszAsyncIntersiteTransportDN); err != nil {
		return err
	}
	if err := w.ReadData(&o.ReplicaFlags); err != nil {
		return err
	}
	// reserved dwReserved
	var _dwReserved uint32
	if err := w.ReadData(&_dwReserved); err != nil {
		return err
	}
	if o.NamingContextObjectGUID == nil {
		o.NamingContextObjectGUID = &dtyp.UUID{}
	}
	if err := o.NamingContextObjectGUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.SourceDSAObjectGUID == nil {
		o.SourceDSAObjectGUID = &dtyp.UUID{}
	}
	if err := o.SourceDSAObjectGUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.SourceDSAInvocationID == nil {
		o.SourceDSAInvocationID = &dtyp.UUID{}
	}
	if err := o.SourceDSAInvocationID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.AsyncIntersiteTransportObjectGUID == nil {
		o.AsyncIntersiteTransportObjectGUID = &dtyp.UUID{}
	}
	if err := o.AsyncIntersiteTransportObjectGUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.LastObjectChangeSynced); err != nil {
		return err
	}
	if err := w.ReadData(&o.AttributeFilter); err != nil {
		return err
	}
	if o.LastSyncSuccess == nil {
		o.LastSyncSuccess = &dtyp.Filetime{}
	}
	if err := o.LastSyncSuccess.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.LastSyncAttempt == nil {
		o.LastSyncAttempt = &dtyp.Filetime{}
	}
	if err := o.LastSyncAttempt.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.LastSyncResult); err != nil {
		return err
	}
	if err := w.ReadData(&o.ConsecutiveSyncFailuresCount); err != nil {
		return err
	}
	return nil
}

// DSReplicationNeighbors structure represents DS_REPL_NEIGHBORSW RPC structure.
//
// The DS_REPL_NEIGHBORSW structure defines a set of replication neighbors. This structure
// is a concrete representation of a sequence of RepsFrom or RepsTo values.
type DSReplicationNeighbors struct {
	// cNumNeighbors:  The count of items in the rgNeighbor array.
	NeighborsCount uint32 `idl:"name:cNumNeighbors" json:"neighbors_count"`
	// dwReserved:  Unused. MUST be 0 and ignored.
	_ uint32 `idl:"name:dwReserved"`
	// rgNeighbor:  A set of replication neighbors.
	Neighbor []*DSReplicationNeighbor `idl:"name:rgNeighbor;size_is:(cNumNeighbors)" json:"neighbor"`
}

func (o *DSReplicationNeighbors) xxx_PreparePayload(ctx context.Context) error {
	if o.Neighbor != nil && o.NeighborsCount == 0 {
		o.NeighborsCount = uint32(len(o.Neighbor))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *DSReplicationNeighbors) NDRSizeInfo() []uint64 {
	dimSize1 := uint64(o.NeighborsCount)
	return []uint64{
		dimSize1,
	}
}
func (o *DSReplicationNeighbors) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for sz1 := range sizeInfo {
			if err := w.WriteSize(sizeInfo[sz1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if err := w.WriteData(o.NeighborsCount); err != nil {
		return err
	}
	// reserved dwReserved
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	for i1 := range o.Neighbor {
		i1 := i1
		if uint64(i1) >= sizeInfo[0] {
			break
		}
		if o.Neighbor[i1] != nil {
			if err := o.Neighbor[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DSReplicationNeighbor{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.Neighbor); uint64(i1) < sizeInfo[0]; i1++ {
		if err := (&DSReplicationNeighbor{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSReplicationNeighbors) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for i1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[i1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if err := w.ReadData(&o.NeighborsCount); err != nil {
		return err
	}
	// reserved dwReserved
	var _dwReserved uint32
	if err := w.ReadData(&_dwReserved); err != nil {
		return err
	}
	// XXX: for opaque unmarshaling
	if o.NeighborsCount > 0 && sizeInfo[0] == 0 {
		sizeInfo[0] = uint64(o.NeighborsCount)
	}
	if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
		return fmt.Errorf("buffer overflow for size %d of array o.Neighbor", sizeInfo[0])
	}
	o.Neighbor = make([]*DSReplicationNeighbor, sizeInfo[0])
	for i1 := range o.Neighbor {
		i1 := i1
		if o.Neighbor[i1] == nil {
			o.Neighbor[i1] = &DSReplicationNeighbor{}
		}
		if err := o.Neighbor[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// DSReplicationCursor structure represents DS_REPL_CURSOR RPC structure.
//
// The DS_REPL_CURSOR structure defines a replication cursor for a given NC replica.
// This structure is a concrete representation of a ReplUpToDateVector value.
type DSReplicationCursor struct {
	// uuidSourceDsaInvocationID:  The invocation ID of a DC.
	SourceDSAInvocationID *dtyp.UUID `idl:"name:uuidSourceDsaInvocationID" json:"source_dsa_invocation_id"`
	// usnAttributeFilter:  The update sequence number (USN) at which an update was applied
	// on the DC.
	AttributeFilter int64 `idl:"name:usnAttributeFilter" json:"attribute_filter"`
}

func (o *DSReplicationCursor) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSReplicationCursor) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if o.SourceDSAInvocationID != nil {
		if err := o.SourceDSAInvocationID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.AttributeFilter); err != nil {
		return err
	}
	return nil
}
func (o *DSReplicationCursor) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if o.SourceDSAInvocationID == nil {
		o.SourceDSAInvocationID = &dtyp.UUID{}
	}
	if err := o.SourceDSAInvocationID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.AttributeFilter); err != nil {
		return err
	}
	return nil
}

// DSReplicationCursors structure represents DS_REPL_CURSORS RPC structure.
//
// The DS_REPL_CURSORS structure defines a set of replication cursors for a given NC
// replica. This structure is a concrete representation of a sequence of ReplUpToDateVector
// values.
type DSReplicationCursors struct {
	// cNumCursors:  The count of items in the rgCursor array.
	CursorsCount uint32 `idl:"name:cNumCursors" json:"cursors_count"`
	// dwReserved:  Unused. MUST be 0 and ignored.
	_ uint32 `idl:"name:dwReserved"`
	// rgCursor:  A set of replication cursors.
	Cursor []*DSReplicationCursor `idl:"name:rgCursor;size_is:(cNumCursors)" json:"cursor"`
}

func (o *DSReplicationCursors) xxx_PreparePayload(ctx context.Context) error {
	if o.Cursor != nil && o.CursorsCount == 0 {
		o.CursorsCount = uint32(len(o.Cursor))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *DSReplicationCursors) NDRSizeInfo() []uint64 {
	dimSize1 := uint64(o.CursorsCount)
	return []uint64{
		dimSize1,
	}
}
func (o *DSReplicationCursors) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for sz1 := range sizeInfo {
			if err := w.WriteSize(sizeInfo[sz1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if err := w.WriteData(o.CursorsCount); err != nil {
		return err
	}
	// reserved dwReserved
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	for i1 := range o.Cursor {
		i1 := i1
		if uint64(i1) >= sizeInfo[0] {
			break
		}
		if o.Cursor[i1] != nil {
			if err := o.Cursor[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DSReplicationCursor{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.Cursor); uint64(i1) < sizeInfo[0]; i1++ {
		if err := (&DSReplicationCursor{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSReplicationCursors) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for i1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[i1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if err := w.ReadData(&o.CursorsCount); err != nil {
		return err
	}
	// reserved dwReserved
	var _dwReserved uint32
	if err := w.ReadData(&_dwReserved); err != nil {
		return err
	}
	// XXX: for opaque unmarshaling
	if o.CursorsCount > 0 && sizeInfo[0] == 0 {
		sizeInfo[0] = uint64(o.CursorsCount)
	}
	if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
		return fmt.Errorf("buffer overflow for size %d of array o.Cursor", sizeInfo[0])
	}
	o.Cursor = make([]*DSReplicationCursor, sizeInfo[0])
	for i1 := range o.Cursor {
		i1 := i1
		if o.Cursor[i1] == nil {
			o.Cursor[i1] = &DSReplicationCursor{}
		}
		if err := o.Cursor[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// DSReplicationAttributeMetadata structure represents DS_REPL_ATTR_META_DATA RPC structure.
//
// The DS_REPL_ATTR_META_DATA structure defines an attribute stamp for a given object.
// This structure is a concrete representation of an AttributeStamp.
type DSReplicationAttributeMetadata struct {
	// pszAttributeName:  The lDAPDisplayName of the attribute to which the stamp corresponds.
	AttributeName string `idl:"name:pszAttributeName;string" json:"attribute_name"`
	// dwVersion:  The stamp version.
	Version uint32 `idl:"name:dwVersion" json:"version"`
	// ftimeLastOriginatingChange:  The date and time at which the last originating update
	// was made.
	LastOriginatingChange *dtyp.Filetime `idl:"name:ftimeLastOriginatingChange" json:"last_originating_change"`
	// uuidLastOriginatingDsaInvocationID:  The invocation ID of the DC that performed the
	// last originating update.
	LastOriginatingDSAInvocationID *dtyp.UUID `idl:"name:uuidLastOriginatingDsaInvocationID" json:"last_originating_dsa_invocation_id"`
	// usnOriginatingChange:  The USN assigned to the last originating update by the DC
	// that performed it.
	OriginatingChange int64 `idl:"name:usnOriginatingChange" json:"originating_change"`
	// usnLocalChange:  An implementation-specific value.
	LocalChange int64 `idl:"name:usnLocalChange" json:"local_change"`
}

func (o *DSReplicationAttributeMetadata) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSReplicationAttributeMetadata) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if o.AttributeName != "" {
		_ptr_pszAttributeName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.AttributeName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.AttributeName, _ptr_pszAttributeName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Version); err != nil {
		return err
	}
	if o.LastOriginatingChange != nil {
		if err := o.LastOriginatingChange.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.Filetime{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.LastOriginatingDSAInvocationID != nil {
		if err := o.LastOriginatingDSAInvocationID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.OriginatingChange); err != nil {
		return err
	}
	if err := w.WriteData(o.LocalChange); err != nil {
		return err
	}
	return nil
}
func (o *DSReplicationAttributeMetadata) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	_ptr_pszAttributeName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.AttributeName); err != nil {
			return err
		}
		return nil
	})
	_s_pszAttributeName := func(ptr interface{}) { o.AttributeName = *ptr.(*string) }
	if err := w.ReadPointer(&o.AttributeName, _s_pszAttributeName, _ptr_pszAttributeName); err != nil {
		return err
	}
	if err := w.ReadData(&o.Version); err != nil {
		return err
	}
	if o.LastOriginatingChange == nil {
		o.LastOriginatingChange = &dtyp.Filetime{}
	}
	if err := o.LastOriginatingChange.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.LastOriginatingDSAInvocationID == nil {
		o.LastOriginatingDSAInvocationID = &dtyp.UUID{}
	}
	if err := o.LastOriginatingDSAInvocationID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.OriginatingChange); err != nil {
		return err
	}
	if err := w.ReadData(&o.LocalChange); err != nil {
		return err
	}
	return nil
}

// DSReplicationKCCDSAFailure structure represents DS_REPL_KCC_DSA_FAILUREW RPC structure.
//
// The DS_REPL_KCC_DSA_FAILUREW structure defines a DC that is in a replication error
// state. This structure is a concrete representation of a tuple in a KCCFailedConnections
// or KCCFailedLinks sequence.
type DSReplicationKCCDSAFailure struct {
	// pszDsaDN:  The DN of the nTDSDSA object corresponding to the DC.
	DSADN string `idl:"name:pszDsaDN;string" json:"dsa_dn"`
	// uuidDsaObjGuid:  The DSA GUID of the DC.
	DSAObjectGUID *dtyp.UUID `idl:"name:uuidDsaObjGuid" json:"dsa_object_guid"`
	// ftimeFirstFailure:  The date and time at which the DC entered an error state.
	FirstFailure *dtyp.Filetime `idl:"name:ftimeFirstFailure" json:"first_failure"`
	// cNumFailures:  The number of errors that have occurred.
	FailuresCount uint32 `idl:"name:cNumFailures" json:"failures_count"`
	// dwLastResult:  The Windows error code, as specified in [MS-ERREF] section 2.2, for
	// the last error.
	LastResult uint32 `idl:"name:dwLastResult" json:"last_result"`
}

func (o *DSReplicationKCCDSAFailure) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSReplicationKCCDSAFailure) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.DSADN != "" {
		_ptr_pszDsaDN := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.DSADN); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.DSADN, _ptr_pszDsaDN); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.DSAObjectGUID != nil {
		if err := o.DSAObjectGUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.FirstFailure != nil {
		if err := o.FirstFailure.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.Filetime{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.FailuresCount); err != nil {
		return err
	}
	if err := w.WriteData(o.LastResult); err != nil {
		return err
	}
	return nil
}
func (o *DSReplicationKCCDSAFailure) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_pszDsaDN := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.DSADN); err != nil {
			return err
		}
		return nil
	})
	_s_pszDsaDN := func(ptr interface{}) { o.DSADN = *ptr.(*string) }
	if err := w.ReadPointer(&o.DSADN, _s_pszDsaDN, _ptr_pszDsaDN); err != nil {
		return err
	}
	if o.DSAObjectGUID == nil {
		o.DSAObjectGUID = &dtyp.UUID{}
	}
	if err := o.DSAObjectGUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.FirstFailure == nil {
		o.FirstFailure = &dtyp.Filetime{}
	}
	if err := o.FirstFailure.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.FailuresCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.LastResult); err != nil {
		return err
	}
	return nil
}

// DSReplicationKCCDSAFailures structure represents DS_REPL_KCC_DSA_FAILURESW RPC structure.
//
// The DS_REPL_KCC_DSA_FAILURESW structure defines a set of DCs that are in an error
// state with respect to replication. This structure is a concrete representation of
// KCCFailedConnections and KCCFailedLinks.
type DSReplicationKCCDSAFailures struct {
	// cNumEntries:  The count of items in the rgDsaFailure array.
	EntriesCount uint32 `idl:"name:cNumEntries" json:"entries_count"`
	// dwReserved:  Unused. MUST be 0 and ignored.
	_ uint32 `idl:"name:dwReserved"`
	// rgDsaFailure:  An array of DS_REPL_KCC_DSA_FAILUREW structures.
	DSAFailure []*DSReplicationKCCDSAFailure `idl:"name:rgDsaFailure;size_is:(cNumEntries)" json:"dsa_failure"`
}

func (o *DSReplicationKCCDSAFailures) xxx_PreparePayload(ctx context.Context) error {
	if o.DSAFailure != nil && o.EntriesCount == 0 {
		o.EntriesCount = uint32(len(o.DSAFailure))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *DSReplicationKCCDSAFailures) NDRSizeInfo() []uint64 {
	dimSize1 := uint64(o.EntriesCount)
	return []uint64{
		dimSize1,
	}
}
func (o *DSReplicationKCCDSAFailures) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for sz1 := range sizeInfo {
			if err := w.WriteSize(sizeInfo[sz1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.EntriesCount); err != nil {
		return err
	}
	// reserved dwReserved
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	for i1 := range o.DSAFailure {
		i1 := i1
		if uint64(i1) >= sizeInfo[0] {
			break
		}
		if o.DSAFailure[i1] != nil {
			if err := o.DSAFailure[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DSReplicationKCCDSAFailure{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.DSAFailure); uint64(i1) < sizeInfo[0]; i1++ {
		if err := (&DSReplicationKCCDSAFailure{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSReplicationKCCDSAFailures) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for i1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[i1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntriesCount); err != nil {
		return err
	}
	// reserved dwReserved
	var _dwReserved uint32
	if err := w.ReadData(&_dwReserved); err != nil {
		return err
	}
	// XXX: for opaque unmarshaling
	if o.EntriesCount > 0 && sizeInfo[0] == 0 {
		sizeInfo[0] = uint64(o.EntriesCount)
	}
	if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
		return fmt.Errorf("buffer overflow for size %d of array o.DSAFailure", sizeInfo[0])
	}
	o.DSAFailure = make([]*DSReplicationKCCDSAFailure, sizeInfo[0])
	for i1 := range o.DSAFailure {
		i1 := i1
		if o.DSAFailure[i1] == nil {
			o.DSAFailure[i1] = &DSReplicationKCCDSAFailure{}
		}
		if err := o.DSAFailure[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// DSReplicationObjectMetadata structure represents DS_REPL_OBJ_META_DATA RPC structure.
//
// The DS_REPL_OBJ_META_DATA structure defines a set of attribute stamps for a given
// object. This structure is a concrete representation of the sequence of AttributeStamp
// values for all attributes of a given object.
type DSReplicationObjectMetadata struct {
	// cNumEntries:  The count of items in the rgMetaData array.
	EntriesCount uint32 `idl:"name:cNumEntries" json:"entries_count"`
	// dwReserved:  Unused. MUST be 0 and ignored.
	_ uint32 `idl:"name:dwReserved"`
	// rgMetaData:  A set of attribute stamps.
	Metadata []*DSReplicationAttributeMetadata `idl:"name:rgMetaData;size_is:(cNumEntries)" json:"metadata"`
}

func (o *DSReplicationObjectMetadata) xxx_PreparePayload(ctx context.Context) error {
	if o.Metadata != nil && o.EntriesCount == 0 {
		o.EntriesCount = uint32(len(o.Metadata))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *DSReplicationObjectMetadata) NDRSizeInfo() []uint64 {
	dimSize1 := uint64(o.EntriesCount)
	return []uint64{
		dimSize1,
	}
}
func (o *DSReplicationObjectMetadata) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for sz1 := range sizeInfo {
			if err := w.WriteSize(sizeInfo[sz1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if err := w.WriteData(o.EntriesCount); err != nil {
		return err
	}
	// reserved dwReserved
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	for i1 := range o.Metadata {
		i1 := i1
		if uint64(i1) >= sizeInfo[0] {
			break
		}
		if o.Metadata[i1] != nil {
			if err := o.Metadata[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DSReplicationAttributeMetadata{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.Metadata); uint64(i1) < sizeInfo[0]; i1++ {
		if err := (&DSReplicationAttributeMetadata{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSReplicationObjectMetadata) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for i1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[i1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntriesCount); err != nil {
		return err
	}
	// reserved dwReserved
	var _dwReserved uint32
	if err := w.ReadData(&_dwReserved); err != nil {
		return err
	}
	// XXX: for opaque unmarshaling
	if o.EntriesCount > 0 && sizeInfo[0] == 0 {
		sizeInfo[0] = uint64(o.EntriesCount)
	}
	if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
		return fmt.Errorf("buffer overflow for size %d of array o.Metadata", sizeInfo[0])
	}
	o.Metadata = make([]*DSReplicationAttributeMetadata, sizeInfo[0])
	for i1 := range o.Metadata {
		i1 := i1
		if o.Metadata[i1] == nil {
			o.Metadata[i1] = &DSReplicationAttributeMetadata{}
		}
		if err := o.Metadata[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// DSReplicationOperationType type represents DS_REPL_OP_TYPE RPC enumeration.
//
// DS_REPL_OP_TYPE is a concrete type for the replication operation type.
type DSReplicationOperationType uint16

var (
	// DS_REPL_OP_TYPE_SYNC:  Sync NC replica from server DC.
	DSReplicationOperationTypeSync DSReplicationOperationType = 0
	// DS_REPL_OP_TYPE_ADD:  Add NC replica server DC.
	DSReplicationOperationTypeAdd DSReplicationOperationType = 1
	// DS_REPL_OP_TYPE_DELETE:  Remove NC replica server DC.
	DSReplicationOperationTypeDelete DSReplicationOperationType = 2
	// DS_REPL_OP_TYPE_MODIFY:  Modify NC replica server DC.
	DSReplicationOperationTypeModify DSReplicationOperationType = 3
	// DS_REPL_OP_TYPE_UPDATE_REFS:  Update NC replica client DC.
	DSReplicationOperationTypeUpdateReferences DSReplicationOperationType = 4
)

func (o DSReplicationOperationType) String() string {
	switch o {
	case DSReplicationOperationTypeSync:
		return "DSReplicationOperationTypeSync"
	case DSReplicationOperationTypeAdd:
		return "DSReplicationOperationTypeAdd"
	case DSReplicationOperationTypeDelete:
		return "DSReplicationOperationTypeDelete"
	case DSReplicationOperationTypeModify:
		return "DSReplicationOperationTypeModify"
	case DSReplicationOperationTypeUpdateReferences:
		return "DSReplicationOperationTypeUpdateReferences"
	}
	return "Invalid"
}

// DSReplicationOperation structure represents DS_REPL_OPW RPC structure.
//
// The DS_REPL_OPW structure defines a replication operation to be processed by a DC.
// This structure is a concrete representation of a tuple in a ReplicationQueue sequence.
type DSReplicationOperation struct {
	// ftimeEnqueued:  The date and time at which the operation was requested.
	Enqueued *dtyp.Filetime `idl:"name:ftimeEnqueued" json:"enqueued"`
	// ulSerialNumber:  The unique ID associated with the operation.
	SerialNumber uint32 `idl:"name:ulSerialNumber" json:"serial_number"`
	// ulPriority:  A ULONG specifying the priority value of this operation. Tasks with
	// a higher priority value are executed first. The priority is calculated by the server
	// based on the type of operation and its parameters.
	Priority uint32 `idl:"name:ulPriority" json:"priority"`
	// OpType:  An integer that indicates the type of operation, as defined in DS_REPL_OP_TYPE
	// (section 5.46).
	OperationType DSReplicationOperationType `idl:"name:OpType" json:"operation_type"`
	// ulOptions:  The DRS_OPTIONS flags.
	Options uint32 `idl:"name:ulOptions" json:"options"`
	// pszNamingContext:  The NC root of the relevant NC replica.
	NamingContext string `idl:"name:pszNamingContext;string" json:"naming_context"`
	// pszDsaDN:  The DN of the relevant DC's nTDSDSA object.
	DSADN string `idl:"name:pszDsaDN;string" json:"dsa_dn"`
	// pszDsaAddress:  The NetworkAddress of the relevant DC.
	DSAAddress string `idl:"name:pszDsaAddress;string" json:"dsa_address"`
	// uuidNamingContextObjGuid:  The objectGUID of the NC root of the relevant NC replica.
	NamingContextObjectGUID *dtyp.UUID `idl:"name:uuidNamingContextObjGuid" json:"naming_context_object_guid"`
	// uuidDsaObjGuid:  The DSA GUID of the DC.
	DSAObjectGUID *dtyp.UUID `idl:"name:uuidDsaObjGuid" json:"dsa_object_guid"`
}

func (o *DSReplicationOperation) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSReplicationOperation) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.Enqueued != nil {
		if err := o.Enqueued.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.Filetime{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.SerialNumber); err != nil {
		return err
	}
	if err := w.WriteData(o.Priority); err != nil {
		return err
	}
	if err := w.WriteEnum(uint16(o.OperationType)); err != nil {
		return err
	}
	if err := w.WriteData(o.Options); err != nil {
		return err
	}
	if o.NamingContext != "" {
		_ptr_pszNamingContext := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.NamingContext); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.NamingContext, _ptr_pszNamingContext); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.DSADN != "" {
		_ptr_pszDsaDN := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.DSADN); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.DSADN, _ptr_pszDsaDN); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.DSAAddress != "" {
		_ptr_pszDsaAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.DSAAddress); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.DSAAddress, _ptr_pszDsaAddress); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.NamingContextObjectGUID != nil {
		if err := o.NamingContextObjectGUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.DSAObjectGUID != nil {
		if err := o.DSAObjectGUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSReplicationOperation) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if o.Enqueued == nil {
		o.Enqueued = &dtyp.Filetime{}
	}
	if err := o.Enqueued.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.SerialNumber); err != nil {
		return err
	}
	if err := w.ReadData(&o.Priority); err != nil {
		return err
	}
	if err := w.ReadEnum((*uint16)(&o.OperationType)); err != nil {
		return err
	}
	if err := w.ReadData(&o.Options); err != nil {
		return err
	}
	_ptr_pszNamingContext := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.NamingContext); err != nil {
			return err
		}
		return nil
	})
	_s_pszNamingContext := func(ptr interface{}) { o.NamingContext = *ptr.(*string) }
	if err := w.ReadPointer(&o.NamingContext, _s_pszNamingContext, _ptr_pszNamingContext); err != nil {
		return err
	}
	_ptr_pszDsaDN := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.DSADN); err != nil {
			return err
		}
		return nil
	})
	_s_pszDsaDN := func(ptr interface{}) { o.DSADN = *ptr.(*string) }
	if err := w.ReadPointer(&o.DSADN, _s_pszDsaDN, _ptr_pszDsaDN); err != nil {
		return err
	}
	_ptr_pszDsaAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.DSAAddress); err != nil {
			return err
		}
		return nil
	})
	_s_pszDsaAddress := func(ptr interface{}) { o.DSAAddress = *ptr.(*string) }
	if err := w.ReadPointer(&o.DSAAddress, _s_pszDsaAddress, _ptr_pszDsaAddress); err != nil {
		return err
	}
	if o.NamingContextObjectGUID == nil {
		o.NamingContextObjectGUID = &dtyp.UUID{}
	}
	if err := o.NamingContextObjectGUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.DSAObjectGUID == nil {
		o.DSAObjectGUID = &dtyp.UUID{}
	}
	if err := o.DSAObjectGUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// DSReplicationPendingOperations structure represents DS_REPL_PENDING_OPSW RPC structure.
//
// The DS_REPL_PENDING_OPSW structure defines a sequence of replication operations to
// be processed by a DC. This structure is a concrete representation of ReplicationQueue.
type DSReplicationPendingOperations struct {
	// ftimeCurrentOpStarted:  The time when the current operation started.
	CurrentOperationStarted *dtyp.Filetime `idl:"name:ftimeCurrentOpStarted" json:"current_operation_started"`
	// cNumPendingOps:  The number of items in the rgPendingOp array.
	PendingOperationsCount uint32 `idl:"name:cNumPendingOps" json:"pending_operations_count"`
	// rgPendingOp:  The sequence of replication operations to be performed.
	PendingOperation []*DSReplicationOperation `idl:"name:rgPendingOp;size_is:(cNumPendingOps)" json:"pending_operation"`
}

func (o *DSReplicationPendingOperations) xxx_PreparePayload(ctx context.Context) error {
	if o.PendingOperation != nil && o.PendingOperationsCount == 0 {
		o.PendingOperationsCount = uint32(len(o.PendingOperation))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *DSReplicationPendingOperations) NDRSizeInfo() []uint64 {
	dimSize1 := uint64(o.PendingOperationsCount)
	return []uint64{
		dimSize1,
	}
}
func (o *DSReplicationPendingOperations) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for sz1 := range sizeInfo {
			if err := w.WriteSize(sizeInfo[sz1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.CurrentOperationStarted != nil {
		if err := o.CurrentOperationStarted.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.Filetime{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.PendingOperationsCount); err != nil {
		return err
	}
	for i1 := range o.PendingOperation {
		i1 := i1
		if uint64(i1) >= sizeInfo[0] {
			break
		}
		if o.PendingOperation[i1] != nil {
			if err := o.PendingOperation[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DSReplicationOperation{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.PendingOperation); uint64(i1) < sizeInfo[0]; i1++ {
		if err := (&DSReplicationOperation{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSReplicationPendingOperations) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for i1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[i1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if o.CurrentOperationStarted == nil {
		o.CurrentOperationStarted = &dtyp.Filetime{}
	}
	if err := o.CurrentOperationStarted.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.PendingOperationsCount); err != nil {
		return err
	}
	// XXX: for opaque unmarshaling
	if o.PendingOperationsCount > 0 && sizeInfo[0] == 0 {
		sizeInfo[0] = uint64(o.PendingOperationsCount)
	}
	if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
		return fmt.Errorf("buffer overflow for size %d of array o.PendingOperation", sizeInfo[0])
	}
	o.PendingOperation = make([]*DSReplicationOperation, sizeInfo[0])
	for i1 := range o.PendingOperation {
		i1 := i1
		if o.PendingOperation[i1] == nil {
			o.PendingOperation[i1] = &DSReplicationOperation{}
		}
		if err := o.PendingOperation[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// DSReplicationValueMetadata structure represents DS_REPL_VALUE_META_DATA RPC structure.
//
// The DS_REPL_VALUE_META_DATA structure defines a link value stamp. This structure
// is a concrete representation of a LinkValueStamp.
type DSReplicationValueMetadata struct {
	// pszAttributeName:  The lDAPDisplayName of the attribute.
	AttributeName string `idl:"name:pszAttributeName;string" json:"attribute_name"`
	// pszObjectDn:  The DN of the object.
	ObjectDN string `idl:"name:pszObjectDn;string" json:"object_dn"`
	// cbData:  The size, in bytes, of the pbData array.
	DataLength uint32 `idl:"name:cbData" json:"data_length"`
	// pbData:  The binary_value portion of the attribute value if the attribute is of syntax
	// Object(DN-Binary), or the string_value portion of the attribute value if the attribute
	// is of syntax Object(DN-String); null otherwise.
	Data []byte `idl:"name:pbData;size_is:(cbData);pointer:ptr" json:"data"`
	// ftimeDeleted:  The date and time at which the last replicated update was made that
	// deleted the value, or 0 if the value is not currently deleted.
	Deleted *dtyp.Filetime `idl:"name:ftimeDeleted" json:"deleted"`
	// ftimeCreated:  The date and time at which the first originating update was made.
	Created *dtyp.Filetime `idl:"name:ftimeCreated" json:"created"`
	// dwVersion:  The stamp version.
	Version uint32 `idl:"name:dwVersion" json:"version"`
	// ftimeLastOriginatingChange:  The date and time at which the last originating update
	// was made.
	LastOriginatingChange *dtyp.Filetime `idl:"name:ftimeLastOriginatingChange" json:"last_originating_change"`
	// uuidLastOriginatingDsaInvocationID:  The invocation ID of the DC that performed the
	// last originating update.
	LastOriginatingDSAInvocationID *dtyp.UUID `idl:"name:uuidLastOriginatingDsaInvocationID" json:"last_originating_dsa_invocation_id"`
	// usnOriginatingChange:  The USN assigned to the last originating update by the DC
	// that performed the update.
	OriginatingChange int64 `idl:"name:usnOriginatingChange" json:"originating_change"`
	// usnLocalChange:  An implementation-specific value.
	LocalChange int64 `idl:"name:usnLocalChange" json:"local_change"`
}

func (o *DSReplicationValueMetadata) xxx_PreparePayload(ctx context.Context) error {
	if o.Data != nil && o.DataLength == 0 {
		o.DataLength = uint32(len(o.Data))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSReplicationValueMetadata) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if o.AttributeName != "" {
		_ptr_pszAttributeName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.AttributeName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.AttributeName, _ptr_pszAttributeName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.ObjectDN != "" {
		_ptr_pszObjectDn := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.ObjectDN); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ObjectDN, _ptr_pszObjectDn); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.DataLength); err != nil {
		return err
	}
	if o.Data != nil || o.DataLength > 0 {
		_ptr_pbData := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.DataLength)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Data {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.Data[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.Data); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Data, _ptr_pbData); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.Deleted != nil {
		if err := o.Deleted.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.Filetime{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.Created != nil {
		if err := o.Created.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.Filetime{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Version); err != nil {
		return err
	}
	if o.LastOriginatingChange != nil {
		if err := o.LastOriginatingChange.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.Filetime{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.LastOriginatingDSAInvocationID != nil {
		if err := o.LastOriginatingDSAInvocationID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.OriginatingChange); err != nil {
		return err
	}
	if err := w.WriteData(o.LocalChange); err != nil {
		return err
	}
	return nil
}
func (o *DSReplicationValueMetadata) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	_ptr_pszAttributeName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.AttributeName); err != nil {
			return err
		}
		return nil
	})
	_s_pszAttributeName := func(ptr interface{}) { o.AttributeName = *ptr.(*string) }
	if err := w.ReadPointer(&o.AttributeName, _s_pszAttributeName, _ptr_pszAttributeName); err != nil {
		return err
	}
	_ptr_pszObjectDn := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.ObjectDN); err != nil {
			return err
		}
		return nil
	})
	_s_pszObjectDn := func(ptr interface{}) { o.ObjectDN = *ptr.(*string) }
	if err := w.ReadPointer(&o.ObjectDN, _s_pszObjectDn, _ptr_pszObjectDn); err != nil {
		return err
	}
	if err := w.ReadData(&o.DataLength); err != nil {
		return err
	}
	_ptr_pbData := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.DataLength > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.DataLength)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Data", sizeInfo[0])
		}
		o.Data = make([]byte, sizeInfo[0])
		for i1 := range o.Data {
			i1 := i1
			if err := w.ReadData(&o.Data[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_pbData := func(ptr interface{}) { o.Data = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.Data, _s_pbData, _ptr_pbData); err != nil {
		return err
	}
	if o.Deleted == nil {
		o.Deleted = &dtyp.Filetime{}
	}
	if err := o.Deleted.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.Created == nil {
		o.Created = &dtyp.Filetime{}
	}
	if err := o.Created.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.Version); err != nil {
		return err
	}
	if o.LastOriginatingChange == nil {
		o.LastOriginatingChange = &dtyp.Filetime{}
	}
	if err := o.LastOriginatingChange.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.LastOriginatingDSAInvocationID == nil {
		o.LastOriginatingDSAInvocationID = &dtyp.UUID{}
	}
	if err := o.LastOriginatingDSAInvocationID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.OriginatingChange); err != nil {
		return err
	}
	if err := w.ReadData(&o.LocalChange); err != nil {
		return err
	}
	return nil
}

// DSReplicationAttributeValueMetadata structure represents DS_REPL_ATTR_VALUE_META_DATA RPC structure.
//
// The DS_REPL_ATTR_VALUE_META_DATA structure defines a sequence of link value stamps.
// This structure is a concrete representation of a sequence of LinkValueStamp values.
type DSReplicationAttributeValueMetadata struct {
	// cNumEntries:  The number of items in rgMetaData array.
	EntriesCount uint32 `idl:"name:cNumEntries" json:"entries_count"`
	// dwEnumerationContext:  The value a client uses to populate the dwEnumerationContext
	// field of the request on a future call to IDL_DRSGetReplInfo to retrieve additional
	// results.  For an informative description of the sequencing issues associated with
	// this field, see section 1.3.2.
	EnumerationContext uint32 `idl:"name:dwEnumerationContext" json:"enumeration_context"`
	// rgMetaData:  The sequence of link value stamps.
	Metadata []*DSReplicationValueMetadata `idl:"name:rgMetaData;size_is:(cNumEntries)" json:"metadata"`
}

func (o *DSReplicationAttributeValueMetadata) xxx_PreparePayload(ctx context.Context) error {
	if o.Metadata != nil && o.EntriesCount == 0 {
		o.EntriesCount = uint32(len(o.Metadata))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *DSReplicationAttributeValueMetadata) NDRSizeInfo() []uint64 {
	dimSize1 := uint64(o.EntriesCount)
	return []uint64{
		dimSize1,
	}
}
func (o *DSReplicationAttributeValueMetadata) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for sz1 := range sizeInfo {
			if err := w.WriteSize(sizeInfo[sz1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if err := w.WriteData(o.EntriesCount); err != nil {
		return err
	}
	if err := w.WriteData(o.EnumerationContext); err != nil {
		return err
	}
	for i1 := range o.Metadata {
		i1 := i1
		if uint64(i1) >= sizeInfo[0] {
			break
		}
		if o.Metadata[i1] != nil {
			if err := o.Metadata[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DSReplicationValueMetadata{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.Metadata); uint64(i1) < sizeInfo[0]; i1++ {
		if err := (&DSReplicationValueMetadata{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSReplicationAttributeValueMetadata) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for i1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[i1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntriesCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.EnumerationContext); err != nil {
		return err
	}
	// XXX: for opaque unmarshaling
	if o.EntriesCount > 0 && sizeInfo[0] == 0 {
		sizeInfo[0] = uint64(o.EntriesCount)
	}
	if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
		return fmt.Errorf("buffer overflow for size %d of array o.Metadata", sizeInfo[0])
	}
	o.Metadata = make([]*DSReplicationValueMetadata, sizeInfo[0])
	for i1 := range o.Metadata {
		i1 := i1
		if o.Metadata[i1] == nil {
			o.Metadata[i1] = &DSReplicationValueMetadata{}
		}
		if err := o.Metadata[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// DSReplicationCursor2 structure represents DS_REPL_CURSOR_2 RPC structure.
//
// The DS_REPL_CURSOR_2 structure defines a replication cursor for a given NC replica.
// This structure is a concrete representation of a ReplUpToDateVector value; it is
// a superset of DS_REPL_CURSOR.
type DSReplicationCursor2 struct {
	// uuidSourceDsaInvocationID:  The invocation ID of a DC.
	SourceDSAInvocationID *dtyp.UUID `idl:"name:uuidSourceDsaInvocationID" json:"source_dsa_invocation_id"`
	// usnAttributeFilter:  The USN at which an update was applied on the DC.
	AttributeFilter int64 `idl:"name:usnAttributeFilter" json:"attribute_filter"`
	// ftimeLastSyncSuccess:  The time at which the last successful replication occurred
	// from the DC identified by uuidDsa. Used for replication latency reporting only.
	LastSyncSuccess *dtyp.Filetime `idl:"name:ftimeLastSyncSuccess" json:"last_sync_success"`
}

func (o *DSReplicationCursor2) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSReplicationCursor2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if o.SourceDSAInvocationID != nil {
		if err := o.SourceDSAInvocationID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.AttributeFilter); err != nil {
		return err
	}
	if o.LastSyncSuccess != nil {
		if err := o.LastSyncSuccess.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.Filetime{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSReplicationCursor2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if o.SourceDSAInvocationID == nil {
		o.SourceDSAInvocationID = &dtyp.UUID{}
	}
	if err := o.SourceDSAInvocationID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.AttributeFilter); err != nil {
		return err
	}
	if o.LastSyncSuccess == nil {
		o.LastSyncSuccess = &dtyp.Filetime{}
	}
	if err := o.LastSyncSuccess.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// DSReplicationCursors2 structure represents DS_REPL_CURSORS_2 RPC structure.
//
// The DS_REPL_CURSORS_2 structure defines a set of replication cursors for a given
// NC replica. This structure is a concrete representation of a sequence of ReplUpToDateVector
// values; it is a superset of DS_REPL_CURSORS.
type DSReplicationCursors2 struct {
	// cNumCursors:  The count of items in the rgCursor array.
	CursorsCount uint32 `idl:"name:cNumCursors" json:"cursors_count"`
	// dwEnumerationContext:  The value a client uses to populate the dwEnumerationContext
	// field of the request on a future call to IDL_DRSGetReplInfo to retrieve additional
	// results.  For an informative description of the sequencing issues associated with
	// this field, see section 1.3.2.
	EnumerationContext uint32 `idl:"name:dwEnumerationContext" json:"enumeration_context"`
	// rgCursor:  A set of replication cursors.
	Cursor []*DSReplicationCursor2 `idl:"name:rgCursor;size_is:(cNumCursors)" json:"cursor"`
}

func (o *DSReplicationCursors2) xxx_PreparePayload(ctx context.Context) error {
	if o.Cursor != nil && o.CursorsCount == 0 {
		o.CursorsCount = uint32(len(o.Cursor))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *DSReplicationCursors2) NDRSizeInfo() []uint64 {
	dimSize1 := uint64(o.CursorsCount)
	return []uint64{
		dimSize1,
	}
}
func (o *DSReplicationCursors2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for sz1 := range sizeInfo {
			if err := w.WriteSize(sizeInfo[sz1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if err := w.WriteData(o.CursorsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.EnumerationContext); err != nil {
		return err
	}
	for i1 := range o.Cursor {
		i1 := i1
		if uint64(i1) >= sizeInfo[0] {
			break
		}
		if o.Cursor[i1] != nil {
			if err := o.Cursor[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DSReplicationCursor2{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.Cursor); uint64(i1) < sizeInfo[0]; i1++ {
		if err := (&DSReplicationCursor2{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSReplicationCursors2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for i1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[i1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if err := w.ReadData(&o.CursorsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.EnumerationContext); err != nil {
		return err
	}
	// XXX: for opaque unmarshaling
	if o.CursorsCount > 0 && sizeInfo[0] == 0 {
		sizeInfo[0] = uint64(o.CursorsCount)
	}
	if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
		return fmt.Errorf("buffer overflow for size %d of array o.Cursor", sizeInfo[0])
	}
	o.Cursor = make([]*DSReplicationCursor2, sizeInfo[0])
	for i1 := range o.Cursor {
		i1 := i1
		if o.Cursor[i1] == nil {
			o.Cursor[i1] = &DSReplicationCursor2{}
		}
		if err := o.Cursor[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// DSReplicationCursorV3 structure represents DS_REPL_CURSOR_3W RPC structure.
//
// The DS_REPL_CURSOR_3W structure defines a replication cursor for a given NC replica.
// This structure is a concrete representation of a ReplUpToDateVector value; it is
// a superset of DS_REPL_CURSOR_2.
type DSReplicationCursorV3 struct {
	// uuidSourceDsaInvocationID:  The invocation ID of a DC.
	SourceDSAInvocationID *dtyp.UUID `idl:"name:uuidSourceDsaInvocationID" json:"source_dsa_invocation_id"`
	// usnAttributeFilter:  The USN at which an update was applied on the DC.
	AttributeFilter int64 `idl:"name:usnAttributeFilter" json:"attribute_filter"`
	// ftimeLastSyncSuccess:  The time at which the last successful replication occurred
	// from the DC identified by uuidDsa. Used for replication latency reporting only.
	LastSyncSuccess *dtyp.Filetime `idl:"name:ftimeLastSyncSuccess" json:"last_sync_success"`
	// pszSourceDsaDN:  The DN of the nTDSDSA object with an invocationId of uuidSourceDsaInvocationID.
	SourceDSADN string `idl:"name:pszSourceDsaDN;string" json:"source_dsa_dn"`
}

func (o *DSReplicationCursorV3) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSReplicationCursorV3) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if o.SourceDSAInvocationID != nil {
		if err := o.SourceDSAInvocationID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.AttributeFilter); err != nil {
		return err
	}
	if o.LastSyncSuccess != nil {
		if err := o.LastSyncSuccess.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.Filetime{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.SourceDSADN != "" {
		_ptr_pszSourceDsaDN := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.SourceDSADN); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.SourceDSADN, _ptr_pszSourceDsaDN); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSReplicationCursorV3) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if o.SourceDSAInvocationID == nil {
		o.SourceDSAInvocationID = &dtyp.UUID{}
	}
	if err := o.SourceDSAInvocationID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.AttributeFilter); err != nil {
		return err
	}
	if o.LastSyncSuccess == nil {
		o.LastSyncSuccess = &dtyp.Filetime{}
	}
	if err := o.LastSyncSuccess.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_pszSourceDsaDN := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.SourceDSADN); err != nil {
			return err
		}
		return nil
	})
	_s_pszSourceDsaDN := func(ptr interface{}) { o.SourceDSADN = *ptr.(*string) }
	if err := w.ReadPointer(&o.SourceDSADN, _s_pszSourceDsaDN, _ptr_pszSourceDsaDN); err != nil {
		return err
	}
	return nil
}

// DSReplicationCursorsV3 structure represents DS_REPL_CURSORS_3W RPC structure.
//
// The DS_REPL_CURSORS_3W structure defines a replication cursor for a given NC replica.
// This structure is a concrete representation of a sequence of ReplUpToDateVector values;
// it is a superset of DS_REPL_CURSORS_2.
type DSReplicationCursorsV3 struct {
	// cNumCursors:  The count of items in the rgCursor array.
	CursorsCount uint32 `idl:"name:cNumCursors" json:"cursors_count"`
	// dwEnumerationContext:  The value a client uses to populate the dwEnumerationContext
	// field of the request on a future call to IDL_DRSGetReplInfo to retrieve additional
	// results.  For an informative description of the sequencing issues associated with
	// this field, see section 1.3.2.
	EnumerationContext uint32 `idl:"name:dwEnumerationContext" json:"enumeration_context"`
	// rgCursor:  A set of replication cursors.
	Cursor []*DSReplicationCursorV3 `idl:"name:rgCursor;size_is:(cNumCursors)" json:"cursor"`
}

func (o *DSReplicationCursorsV3) xxx_PreparePayload(ctx context.Context) error {
	if o.Cursor != nil && o.CursorsCount == 0 {
		o.CursorsCount = uint32(len(o.Cursor))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *DSReplicationCursorsV3) NDRSizeInfo() []uint64 {
	dimSize1 := uint64(o.CursorsCount)
	return []uint64{
		dimSize1,
	}
}
func (o *DSReplicationCursorsV3) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for sz1 := range sizeInfo {
			if err := w.WriteSize(sizeInfo[sz1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if err := w.WriteData(o.CursorsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.EnumerationContext); err != nil {
		return err
	}
	for i1 := range o.Cursor {
		i1 := i1
		if uint64(i1) >= sizeInfo[0] {
			break
		}
		if o.Cursor[i1] != nil {
			if err := o.Cursor[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DSReplicationCursorV3{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.Cursor); uint64(i1) < sizeInfo[0]; i1++ {
		if err := (&DSReplicationCursorV3{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSReplicationCursorsV3) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for i1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[i1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if err := w.ReadData(&o.CursorsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.EnumerationContext); err != nil {
		return err
	}
	// XXX: for opaque unmarshaling
	if o.CursorsCount > 0 && sizeInfo[0] == 0 {
		sizeInfo[0] = uint64(o.CursorsCount)
	}
	if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
		return fmt.Errorf("buffer overflow for size %d of array o.Cursor", sizeInfo[0])
	}
	o.Cursor = make([]*DSReplicationCursorV3, sizeInfo[0])
	for i1 := range o.Cursor {
		i1 := i1
		if o.Cursor[i1] == nil {
			o.Cursor[i1] = &DSReplicationCursorV3{}
		}
		if err := o.Cursor[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// DSReplicationAttributeMetadata2 structure represents DS_REPL_ATTR_META_DATA_2 RPC structure.
//
// The DS_REPL_ATTR_META_DATA_2 structure defines an attribute stamp for a given object.
// This structure is a concrete representation of an AttributeStamp; it is a superset
// of DS_REPL_ATTR_META_DATA.
type DSReplicationAttributeMetadata2 struct {
	// pszAttributeName:  The lDAPDisplayName of the attribute to which the stamp corresponds.
	AttributeName string `idl:"name:pszAttributeName;string" json:"attribute_name"`
	// dwVersion:  The stamp version.
	Version uint32 `idl:"name:dwVersion" json:"version"`
	// ftimeLastOriginatingChange:  The date and time at which the last originating update
	// was made.
	LastOriginatingChange *dtyp.Filetime `idl:"name:ftimeLastOriginatingChange" json:"last_originating_change"`
	// uuidLastOriginatingDsaInvocationID:  The invocation ID of the DC that performed the
	// last originating update.
	LastOriginatingDSAInvocationID *dtyp.UUID `idl:"name:uuidLastOriginatingDsaInvocationID" json:"last_originating_dsa_invocation_id"`
	// usnOriginatingChange:  The USN assigned to the last originating update by the DC
	// that performed it.
	OriginatingChange int64 `idl:"name:usnOriginatingChange" json:"originating_change"`
	// usnLocalChange:  An implementation-specific value.
	LocalChange int64 `idl:"name:usnLocalChange" json:"local_change"`
	// pszLastOriginatingDsaDN:  The DN of the nTDSDSA object with an invocationId of uuidLastOriginatingDsaInvocationID.
	LastOriginatingDSADN string `idl:"name:pszLastOriginatingDsaDN;string" json:"last_originating_dsa_dn"`
}

func (o *DSReplicationAttributeMetadata2) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSReplicationAttributeMetadata2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if o.AttributeName != "" {
		_ptr_pszAttributeName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.AttributeName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.AttributeName, _ptr_pszAttributeName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Version); err != nil {
		return err
	}
	if o.LastOriginatingChange != nil {
		if err := o.LastOriginatingChange.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.Filetime{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.LastOriginatingDSAInvocationID != nil {
		if err := o.LastOriginatingDSAInvocationID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.OriginatingChange); err != nil {
		return err
	}
	if err := w.WriteData(o.LocalChange); err != nil {
		return err
	}
	if o.LastOriginatingDSADN != "" {
		_ptr_pszLastOriginatingDsaDN := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.LastOriginatingDSADN); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.LastOriginatingDSADN, _ptr_pszLastOriginatingDsaDN); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSReplicationAttributeMetadata2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	_ptr_pszAttributeName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.AttributeName); err != nil {
			return err
		}
		return nil
	})
	_s_pszAttributeName := func(ptr interface{}) { o.AttributeName = *ptr.(*string) }
	if err := w.ReadPointer(&o.AttributeName, _s_pszAttributeName, _ptr_pszAttributeName); err != nil {
		return err
	}
	if err := w.ReadData(&o.Version); err != nil {
		return err
	}
	if o.LastOriginatingChange == nil {
		o.LastOriginatingChange = &dtyp.Filetime{}
	}
	if err := o.LastOriginatingChange.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.LastOriginatingDSAInvocationID == nil {
		o.LastOriginatingDSAInvocationID = &dtyp.UUID{}
	}
	if err := o.LastOriginatingDSAInvocationID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.OriginatingChange); err != nil {
		return err
	}
	if err := w.ReadData(&o.LocalChange); err != nil {
		return err
	}
	_ptr_pszLastOriginatingDsaDN := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.LastOriginatingDSADN); err != nil {
			return err
		}
		return nil
	})
	_s_pszLastOriginatingDsaDN := func(ptr interface{}) { o.LastOriginatingDSADN = *ptr.(*string) }
	if err := w.ReadPointer(&o.LastOriginatingDSADN, _s_pszLastOriginatingDsaDN, _ptr_pszLastOriginatingDsaDN); err != nil {
		return err
	}
	return nil
}

// DSReplicationObjectMetadata2 structure represents DS_REPL_OBJ_META_DATA_2 RPC structure.
//
// The DS_REPL_OBJ_META_DATA_2 structure defines a set of attribute stamps for a given
// object. This structure is a concrete representation of the sequence of AttributeStamp
// values for all attributes of a given object; it is a superset of DS_REPL_OBJ_META_DATA.
type DSReplicationObjectMetadata2 struct {
	// cNumEntries:  The count of items in the rgMetaData array.
	EntriesCount uint32 `idl:"name:cNumEntries" json:"entries_count"`
	// dwReserved:  Unused. MUST be 0 and ignored.
	_ uint32 `idl:"name:dwReserved"`
	// rgMetaData:  A set of attribute stamps.
	Metadata []*DSReplicationAttributeMetadata2 `idl:"name:rgMetaData;size_is:(cNumEntries)" json:"metadata"`
}

func (o *DSReplicationObjectMetadata2) xxx_PreparePayload(ctx context.Context) error {
	if o.Metadata != nil && o.EntriesCount == 0 {
		o.EntriesCount = uint32(len(o.Metadata))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *DSReplicationObjectMetadata2) NDRSizeInfo() []uint64 {
	dimSize1 := uint64(o.EntriesCount)
	return []uint64{
		dimSize1,
	}
}
func (o *DSReplicationObjectMetadata2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for sz1 := range sizeInfo {
			if err := w.WriteSize(sizeInfo[sz1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if err := w.WriteData(o.EntriesCount); err != nil {
		return err
	}
	// reserved dwReserved
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	for i1 := range o.Metadata {
		i1 := i1
		if uint64(i1) >= sizeInfo[0] {
			break
		}
		if o.Metadata[i1] != nil {
			if err := o.Metadata[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DSReplicationAttributeMetadata2{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.Metadata); uint64(i1) < sizeInfo[0]; i1++ {
		if err := (&DSReplicationAttributeMetadata2{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSReplicationObjectMetadata2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for i1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[i1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntriesCount); err != nil {
		return err
	}
	// reserved dwReserved
	var _dwReserved uint32
	if err := w.ReadData(&_dwReserved); err != nil {
		return err
	}
	// XXX: for opaque unmarshaling
	if o.EntriesCount > 0 && sizeInfo[0] == 0 {
		sizeInfo[0] = uint64(o.EntriesCount)
	}
	if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
		return fmt.Errorf("buffer overflow for size %d of array o.Metadata", sizeInfo[0])
	}
	o.Metadata = make([]*DSReplicationAttributeMetadata2, sizeInfo[0])
	for i1 := range o.Metadata {
		i1 := i1
		if o.Metadata[i1] == nil {
			o.Metadata[i1] = &DSReplicationAttributeMetadata2{}
		}
		if err := o.Metadata[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// DSReplicationValueMetadata2 structure represents DS_REPL_VALUE_META_DATA_2 RPC structure.
//
// The DS_REPL_VALUE_META_DATA_2 structure defines a link value stamp. This structure
// is a concrete representation of LinkValueStamp; it is a superset of DS_REPL_VALUE_META_DATA.
type DSReplicationValueMetadata2 struct {
	// pszAttributeName:  The lDAPDisplayName of the attribute.
	AttributeName string `idl:"name:pszAttributeName;string" json:"attribute_name"`
	// pszObjectDn:  The DN of the object.
	ObjectDN string `idl:"name:pszObjectDn;string" json:"object_dn"`
	// cbData:  The size, in bytes, of the pbData array.
	DataLength uint32 `idl:"name:cbData" json:"data_length"`
	// pbData:  The binary_value portion of the attribute value if the attribute is of syntax
	// Object(DN-Binary), or the string_value portion of the attribute value if the attribute
	// is of syntax Object(DN-String); null otherwise.
	Data []byte `idl:"name:pbData;size_is:(cbData);pointer:ptr" json:"data"`
	// ftimeDeleted:  The date and time at which the last replicated update was made that
	// deleted the value, or 0 if the value is not currently deleted.
	Deleted *dtyp.Filetime `idl:"name:ftimeDeleted" json:"deleted"`
	// ftimeCreated:  The date and time at which the first originating update was made.
	Created *dtyp.Filetime `idl:"name:ftimeCreated" json:"created"`
	// dwVersion:  The stamp version.
	Version uint32 `idl:"name:dwVersion" json:"version"`
	// ftimeLastOriginatingChange:  The date and time at which the last originating update
	// was made.
	LastOriginatingChange *dtyp.Filetime `idl:"name:ftimeLastOriginatingChange" json:"last_originating_change"`
	// uuidLastOriginatingDsaInvocationID:  The invocation ID of the DC that performed the
	// last originating update.
	LastOriginatingDSAInvocationID *dtyp.UUID `idl:"name:uuidLastOriginatingDsaInvocationID" json:"last_originating_dsa_invocation_id"`
	// usnOriginatingChange:  The USN assigned to the last originating update by the DC
	// that performed the update.
	OriginatingChange int64 `idl:"name:usnOriginatingChange" json:"originating_change"`
	// usnLocalChange:  An implementation-specific value.
	LocalChange int64 `idl:"name:usnLocalChange" json:"local_change"`
	// pszLastOriginatingDsaDN:  The DN of the nTDSDSA object with an invocationId of uuidLastOriginatingDsaInvocationID.
	LastOriginatingDSADN string `idl:"name:pszLastOriginatingDsaDN;string" json:"last_originating_dsa_dn"`
}

func (o *DSReplicationValueMetadata2) xxx_PreparePayload(ctx context.Context) error {
	if o.Data != nil && o.DataLength == 0 {
		o.DataLength = uint32(len(o.Data))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSReplicationValueMetadata2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if o.AttributeName != "" {
		_ptr_pszAttributeName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.AttributeName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.AttributeName, _ptr_pszAttributeName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.ObjectDN != "" {
		_ptr_pszObjectDn := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.ObjectDN); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ObjectDN, _ptr_pszObjectDn); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.DataLength); err != nil {
		return err
	}
	if o.Data != nil || o.DataLength > 0 {
		_ptr_pbData := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.DataLength)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Data {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.Data[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.Data); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Data, _ptr_pbData); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.Deleted != nil {
		if err := o.Deleted.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.Filetime{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.Created != nil {
		if err := o.Created.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.Filetime{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Version); err != nil {
		return err
	}
	if o.LastOriginatingChange != nil {
		if err := o.LastOriginatingChange.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.Filetime{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.LastOriginatingDSAInvocationID != nil {
		if err := o.LastOriginatingDSAInvocationID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.OriginatingChange); err != nil {
		return err
	}
	if err := w.WriteData(o.LocalChange); err != nil {
		return err
	}
	if o.LastOriginatingDSADN != "" {
		_ptr_pszLastOriginatingDsaDN := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.LastOriginatingDSADN); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.LastOriginatingDSADN, _ptr_pszLastOriginatingDsaDN); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSReplicationValueMetadata2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	_ptr_pszAttributeName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.AttributeName); err != nil {
			return err
		}
		return nil
	})
	_s_pszAttributeName := func(ptr interface{}) { o.AttributeName = *ptr.(*string) }
	if err := w.ReadPointer(&o.AttributeName, _s_pszAttributeName, _ptr_pszAttributeName); err != nil {
		return err
	}
	_ptr_pszObjectDn := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.ObjectDN); err != nil {
			return err
		}
		return nil
	})
	_s_pszObjectDn := func(ptr interface{}) { o.ObjectDN = *ptr.(*string) }
	if err := w.ReadPointer(&o.ObjectDN, _s_pszObjectDn, _ptr_pszObjectDn); err != nil {
		return err
	}
	if err := w.ReadData(&o.DataLength); err != nil {
		return err
	}
	_ptr_pbData := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.DataLength > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.DataLength)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Data", sizeInfo[0])
		}
		o.Data = make([]byte, sizeInfo[0])
		for i1 := range o.Data {
			i1 := i1
			if err := w.ReadData(&o.Data[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_pbData := func(ptr interface{}) { o.Data = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.Data, _s_pbData, _ptr_pbData); err != nil {
		return err
	}
	if o.Deleted == nil {
		o.Deleted = &dtyp.Filetime{}
	}
	if err := o.Deleted.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.Created == nil {
		o.Created = &dtyp.Filetime{}
	}
	if err := o.Created.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.Version); err != nil {
		return err
	}
	if o.LastOriginatingChange == nil {
		o.LastOriginatingChange = &dtyp.Filetime{}
	}
	if err := o.LastOriginatingChange.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.LastOriginatingDSAInvocationID == nil {
		o.LastOriginatingDSAInvocationID = &dtyp.UUID{}
	}
	if err := o.LastOriginatingDSAInvocationID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.OriginatingChange); err != nil {
		return err
	}
	if err := w.ReadData(&o.LocalChange); err != nil {
		return err
	}
	_ptr_pszLastOriginatingDsaDN := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.LastOriginatingDSADN); err != nil {
			return err
		}
		return nil
	})
	_s_pszLastOriginatingDsaDN := func(ptr interface{}) { o.LastOriginatingDSADN = *ptr.(*string) }
	if err := w.ReadPointer(&o.LastOriginatingDSADN, _s_pszLastOriginatingDsaDN, _ptr_pszLastOriginatingDsaDN); err != nil {
		return err
	}
	return nil
}

// DSReplicationAttributeValueMetadata2 structure represents DS_REPL_ATTR_VALUE_META_DATA_2 RPC structure.
//
// The DS_REPL_ATTR_VALUE_META_DATA_2 structure defines a sequence of link value stamps.
// This structure is a concrete representation of a sequence of LinkValueStamp values;
// it is a superset of DS_REPL_ATTR_VALUE_META_DATA.
type DSReplicationAttributeValueMetadata2 struct {
	// cNumEntries:  The number of items in the rgMetaData array.
	EntriesCount uint32 `idl:"name:cNumEntries" json:"entries_count"`
	// dwEnumerationContext:  The value a client uses to populate the dwEnumerationContext
	// field of the request on a future call to IDL_DRSGetReplInfo to retrieve additional
	// results. For an informative description of the sequencing issues associated with
	// this field, see section 1.3.2.
	EnumerationContext uint32 `idl:"name:dwEnumerationContext" json:"enumeration_context"`
	// rgMetaData:  The sequence of link value stamps.
	Metadata []*DSReplicationValueMetadata2 `idl:"name:rgMetaData;size_is:(cNumEntries)" json:"metadata"`
}

func (o *DSReplicationAttributeValueMetadata2) xxx_PreparePayload(ctx context.Context) error {
	if o.Metadata != nil && o.EntriesCount == 0 {
		o.EntriesCount = uint32(len(o.Metadata))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *DSReplicationAttributeValueMetadata2) NDRSizeInfo() []uint64 {
	dimSize1 := uint64(o.EntriesCount)
	return []uint64{
		dimSize1,
	}
}
func (o *DSReplicationAttributeValueMetadata2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for sz1 := range sizeInfo {
			if err := w.WriteSize(sizeInfo[sz1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if err := w.WriteData(o.EntriesCount); err != nil {
		return err
	}
	if err := w.WriteData(o.EnumerationContext); err != nil {
		return err
	}
	for i1 := range o.Metadata {
		i1 := i1
		if uint64(i1) >= sizeInfo[0] {
			break
		}
		if o.Metadata[i1] != nil {
			if err := o.Metadata[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DSReplicationValueMetadata2{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.Metadata); uint64(i1) < sizeInfo[0]; i1++ {
		if err := (&DSReplicationValueMetadata2{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSReplicationAttributeValueMetadata2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for i1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[i1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntriesCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.EnumerationContext); err != nil {
		return err
	}
	// XXX: for opaque unmarshaling
	if o.EntriesCount > 0 && sizeInfo[0] == 0 {
		sizeInfo[0] = uint64(o.EntriesCount)
	}
	if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
		return fmt.Errorf("buffer overflow for size %d of array o.Metadata", sizeInfo[0])
	}
	o.Metadata = make([]*DSReplicationValueMetadata2, sizeInfo[0])
	for i1 := range o.Metadata {
		i1 := i1
		if o.Metadata[i1] == nil {
			o.Metadata[i1] = &DSReplicationValueMetadata2{}
		}
		if err := o.Metadata[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// ExtensionsInt structure represents DRS_EXTENSIONS_INT RPC structure.
//
// The DRS_EXTENSIONS_INT structure is a concrete type for structured capabilities information
// used in version negotiation.
//
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| cb                                                                                                                            |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwFlags                                                                                                                       |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| SiteObjGuid (16 bytes)                                                                                                        |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| Pid                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwReplEpoch                                                                                                                   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwFlagsExt                                                                                                                    |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ConfigObjGUID (16 bytes)                                                                                                      |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwExtCaps                                                                                                                     |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
type ExtensionsInt struct {
	// cb (4 bytes): The count of bytes in the fields dwFlags through dwExtCaps, inclusive.<38><39><40>
	// This field allows the DRS_EXTENSIONS_INT structure to be extended by including new
	// fields at the end of the structure.
	Length uint32 `idl:"name:cb" json:"length"`
	// dwFlags (4 bytes): The dwFlags field contains individual bit flags that describe
	// the capabilities of the DC that produced the DRS_EXTENSIONS_INT structure.<41>
	//
	// The following table lists the bit flags, which are presented in little-endian byte
	// order.
	//
	//	+-----+-----+-----+-----+-----+-----+-----+-------+-----+-------+-----+-------+-------+-------+-------+-----+-------+-------+-------+-------+-------+-----+-----+-------+-----+-----+--------+-------+-------+-------+-------+-------+
	//	|  0  |  1  |  2  |  3  |  4  |  5  |  6  |   7   |  8  |   9   |  1  |   1   |   2   |   3   |   4   |  5  |   6   |   7   |   8   |   9   |   2   |  1  |  2  |   3   |  4  |  5  |   6    |   7   |   8   |   9   |   3   |   1   |
	//	|     |     |     |     |     |     |     |       |     |       |  0  |       |       |       |       |     |       |       |       |       |   0   |     |     |       |     |     |        |       |       |       |   0   |       |
	//	+-----+-----+-----+-----+-----+-----+-----+-------+-----+-------+-----+-------+-------+-------+-------+-----+-------+-------+-------+-------+-------+-----+-----+-------+-----+-----+--------+-------+-------+-------+-------+-------+
	//	+-----+-----+-----+-----+-----+-----+-----+-------+-----+-------+-----+-------+-------+-------+-------+-----+-------+-------+-------+-------+-------+-----+-----+-------+-----+-----+--------+-------+-------+-------+-------+-------+
	//	| A E | U O | D C | D F | M V | R M | A S | B A S | S E | G R I | C B | I N R | D C 2 | L V R | A E 2 | K E | A N C | G C 6 | G M 2 | G C 5 | P B 3 | S H | T M | D C F | R 3 | R 2 | G C 10 | D F 2 | W B 3 | G R 6 | G R 5 | G C 8 |
	//	+-----+-----+-----+-----+-----+-----+-----+-------+-----+-------+-----+-------+-------+-------+-------+-----+-------+-------+-------+-------+-------+-----+-----+-------+-----+-----+--------+-------+-------+-------+-------+-------+
	//
	// BAS (DRS_EXT_BASE, 0x00000001): Unused. SHOULD be 1 and MUST be ignored.
	//
	// AS (DRS_EXT_ASYNCREPL, 0x00000002): If present, signifies that the DC supports DRS_MSG_REPADD_V2.
	//
	// RM (DRS_EXT_REMOVEAPI, 0x00000004): If present, signifies that the DC supports IDL_DRSRemoveDsServer
	// and IDL_DRSRemoveDsDomain.
	//
	// MV (DRS_EXT_MOVEREQ_V2, 0x00000008): If present, signifies that the DC supports DRS_MSG_MOVEREQ_V2.
	//
	// DF (DRS_EXT_GETCHG_DEFLATE, 0x00000010): If present, signifies that the DC supports
	// DRS_MSG_GETCHGREPLY_V2.
	//
	// DC (DRS_EXT_DCINFO_V1, 0x00000020): If present, signifies that the DC supports IDL_DRSDomainControllerInfo.
	//
	// UO (DRS_EXT_RESTORE_USN_OPTIMIZATION, 0x00000040): Unused. SHOULD be 1 and MUST be
	// ignored.
	//
	// AE (DRS_EXT_ADDENTRY, 0x00000080): If present, signifies that the DC supports IDL_DRSAddEntry.
	//
	// KE (DRS_EXT_KCC_EXECUTE, 0x00000100): If present, signifies that the DC supports
	// IDL_DRSExecuteKCC.
	//
	// AE2 (DRS_EXT_ADDENTRY_V2, 0x00000200): If present, signifies that the DC supports
	// DRS_MSG_ADDENTRYREQ_V2.
	//
	// LVR (DRS_EXT_LINKED_VALUE_REPLICATION, 0x00000400): If present, signifies that the
	// DC supports link value replication, and this support is enabled.
	//
	// DC2 (DRS_EXT_DCINFO_V2, 0x00000800): If present, signifies that the DC supports DRS_MSG_DCINFOREPLY_V2.
	//
	// INR (DRS_EXT_INSTANCE_TYPE_NOT_REQ_ON_MOD, 0x00001000): Unused. SHOULD be 1 and MUST
	// be ignored.
	//
	// CB (DRS_EXT_CRYPTO_BIND, 0x00002000): A client-only flag. If present, it indicates
	// that the security provider used for the connection supports session keys through
	// RPC (example, Kerberos connections with mutual authentication enable RPC to expose
	// session keys, but NTLM connections do not enable RPC to expose session keys).
	//
	// GRI (DRS_EXT_GET_REPL_INFO, 0x00004000): If present, signifies that the DC supports
	// IDL_DRSGetReplInfo.
	//
	// SE (DRS_EXT_STRONG_ENCRYPTION, 0x00008000): If present, signifies that the DC supports
	// additional 128-bit encryption for passwords over the wire. DCs MUST NOT replicate
	// passwords to other DCs that do not support this extension.
	//
	// DCF (DRS_EXT_DCINFO_VFFFFFFFF, 0x00010000): If present, signifies that the DC supports
	// DRS_MSG_DCINFOREPLY_VFFFFFFFF.
	//
	// TM (DRS_EXT_TRANSITIVE_MEMBERSHIP, 0x00020000): If present, signifies that the DC
	// supports IDL_DRSGetMemberships.
	//
	// SH (DRS_EXT_ADD_SID_HISTORY, 0x00040000): If present, signifies that the DC supports
	// IDL_DRSAddSidHistory.
	//
	// PB3 (DRS_EXT_POST_BETA3, 0x00080000): Reserved. MUST be set to 1 and ignored.
	//
	// GC5 (DRS_EXT_GETCHGREQ_V5, 0x00100000): If present, signifies that the DC supports
	// DRS_MSG_GETCHGREQ_V5.
	//
	// GM2(DRS_EXT_GETMEMBERSHIPS2, 0x00200000): If present, signifies that the DC supports
	// IDL_DRSGetMemberships2.
	//
	// GC6 (DRS_EXT_GETCHGREQ_V6, 0x00400000): Unused. This bit was used for a pre-release
	// version of Windows. No released version of Windows references it. This bit can be
	// set or unset with no change in behavior.
	//
	// ANC (DRS_EXT_NONDOMAIN_NCS, 0x00800000): If present, signifies that the DC supports
	// application NCs.
	//
	// GC8 (DRS_EXT_GETCHGREQ_V8, 0x01000000): If present, signifies that the DC supports
	// DRS_MSG_GETCHGREQ_V8.
	//
	// GR5 (DRS_EXT_GETCHGREPLY_V5, 0x02000000): Unused. SHOULD be 1 and MUST be ignored.
	//
	// GR6 (DRS_EXT_GETCHGREPLY_V6, 0x04000000): If present, signifies that the DC supports
	// DRS_MSG_GETCHGREPLY_V6.
	//
	// WB3 (DRS_EXT_WHISTLER_BETA3, 0x08000000): If present, signifies that the DC supports
	// DRS_MSG_ADDENTRYREPLY_V3, DRS_MSG_REPVERIFYOBJ, DRS_MSG_GETCHGREPLY_V7, and DRS_MSG_QUERYSITESREQ_V1.
	//
	// DF2 (DRS_EXT_W2K3_DEFLATE, 0x10000000): If present, signifies that the DC supports
	// the W2K3 AD deflation library.
	//
	// GC10 (DRS_EXT_GETCHGREQ_V10, 0x20000000): If present, signifies that the DC supports
	// DRS_MSG_GETCHGREQ_V10.
	//
	// R2 (DRS_EXT_RESERVED_FOR_WIN2K_OR_DOTNET_PART2, 0x40000000): Unused. MUST be 0 and
	// ignored.
	Flags uint32 `idl:"name:dwFlags" json:"flags"`
	// SiteObjGuid (16 bytes): A GUID. The objectGUID of the site object of which the DC's
	// DSA object is a descendant. For non-DC client callers, this field SHOULD be set to
	// zero.
	SiteObjectGUID *dtyp.GUID `idl:"name:SiteObjGuid" json:"site_object_guid"`
	// Pid (4 bytes): A 32-bit, signed integer value that specifies a process identifier.
	// The client sets the Pid field to the current client process, or the server sets the
	// Pid to the current server process. This is for informational and debugging purposes
	// only. The assignment of this field is implementation-specific.<42>
	PID int32 `idl:"name:Pid" json:"pid"`
	// dwReplEpoch (4 bytes): A 32-bit, unsigned integer value that specifies the replication
	// epoch. This value is set to zero by all client callers. The server sets this value
	// by assigning the value of msDS-ReplicationEpoch from its nTDSDSA object. If dwReplEpoch
	// is not included in DRS_EXTENSIONS_INT, the value is considered to be zero.<43>
	ReplicationEpoch uint32 `idl:"name:dwReplEpoch" json:"replication_epoch"`
	// dwFlagsExt (4 bytes): An extension of the dwFlags field that contains individual
	// bit flags. These bit flags determine which extended capabilities are enabled in the
	// DC that produced the DRS_EXTENSIONS_INT structure. For non-DC client callers, no
	// bits SHOULD be set. If dwFlagsExt is not included in DRS_EXTENSIONS_INT, all bit
	// flags are considered unset.
	//
	// The following table lists the bit flags, which are presented in little-endian byte
	// order.<44>
	//
	//	+---+---+---+---+---+-----+-----+-----+---+---+---+---+---+-----+---+-------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 1 | 2 | 3 | 4 |  5  |  6  |  7  | 8 | 9 | 1 | 1 | 2 |  3  | 4 |   5   | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
	//	|   |   |   |   |   |     |     |     |   |   | 0 |   |   |     |   |       |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
	//	+---+---+---+---+---+-----+-----+-----+---+---+---+---+---+-----+---+-------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	+---+---+---+---+---+-----+-----+-----+---+---+---+---+---+-----+---+-------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| X | X | X | X | X | R B | L H | D A | X | X | X | X | X | CID | X | G R 9 | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X |
	//	+---+---+---+---+---+-----+-----+-----+---+---+---+---+---+-----+---+-------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//
	// DA (DRS_EXT_ADAM, 0x00000001): If present, signifies that the DC supports DRS_MSG_REPSYNC_V1,
	// DRS_MSG_UPDREFS_V1, DRS_MSG_INIT_DEMOTIONREQ_V1, DRS_MSG_REPLICA_DEMOTIONREQ_V1,
	// and DRS_MSG_FINISH_DEMOTIONREQ_V1.
	//
	// LH (DRS_EXT_LH_BETA2, 0x00000002): If present, signifies that the DC supports the
	// DRS_SPECIAL_SECRET_PROCESSING and DRS_GET_ALL_GROUP_MEMBERSHIP flags as well as InfoLevel
	// 3 in DRS_MSG_DCINFOREQ_V1.
	//
	// RB (DRS_EXT_RECYCLE_BIN, 0x00000004): If present, signifies that the DC has enabled
	// the Recycle Bin optional feature.
	//
	// GR9 (DRS_EXT_GETCHGREPLY_V9, 0x00000100): If present, signifies that the DC supports
	// DRS_MSG_GETCHGREPLY_V9.
	FlagsExt uint32 `idl:"name:dwFlagsExt" json:"flags_ext"`
	// ConfigObjGUID (16 bytes): A GUID. This field is set to zero by all client callers.
	// The server sets this field by assigning it the value of the objectGUID of the config
	// NC object. If ConfigObjGUID is not included in DRS_EXTENSIONS_INT, the value is considered
	// to be the NULL GUID value.<45>
	ConfigObjectGUID *dtyp.GUID `idl:"name:ConfigObjGUID" json:"config_object_guid"`
	// dwExtCaps (4 bytes): A mask for the dwFlagsExt field that contains individual bit
	// flags. These bit flags describe the potential extended capabilities of the DC that
	// produced the DRS_EXTENSIONS_INT structure. For non-DC client callers, no bits SHOULD
	// be set. If neither dwFlagsExt nor dwExtCaps is included in DRS_EXTENSIONS_INT, all
	// bits in dwExtCaps are considered unset. If dwFlagsExt is included in DRS_EXTENSIONS_INT
	// but dwExtCaps is not, all relevant bits in dwExtCaps (as explained below) are implicitly
	// set.<46>
	//
	// Each bit in dwExtCaps corresponds exactly to each bit in dwFlagsExt. If the DC that
	// produced the DRS_EXTENSIONS_INT structure supports a capability described by a bit
	// in the dwFlagsExt field (that is, the bit either is or could potentially be set),
	// then the corresponding bit in dwExtCaps MUST be set. If a bit in dwExtCaps is not
	// set, it is assumed that the corresponding bit in dwFlagsExt will not and cannot be
	// set.
	ExtCaps uint32 `idl:"name:dwExtCaps" json:"ext_caps"`
}

func (o *ExtensionsInt) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ExtensionsInt) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	if o.SiteObjectGUID != nil {
		if err := o.SiteObjectGUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.PID); err != nil {
		return err
	}
	if err := w.WriteData(o.ReplicationEpoch); err != nil {
		return err
	}
	if err := w.WriteData(o.FlagsExt); err != nil {
		return err
	}
	if o.ConfigObjectGUID != nil {
		if err := o.ConfigObjectGUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.ExtCaps); err != nil {
		return err
	}
	return nil
}
func (o *ExtensionsInt) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	if o.SiteObjectGUID == nil {
		o.SiteObjectGUID = &dtyp.GUID{}
	}
	if err := o.SiteObjectGUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.PID); err != nil {
		return err
	}
	if err := w.ReadData(&o.ReplicationEpoch); err != nil {
		return err
	}
	if err := w.ReadData(&o.FlagsExt); err != nil {
		return err
	}
	if o.ConfigObjectGUID == nil {
		o.ConfigObjectGUID = &dtyp.GUID{}
	}
	if err := o.ConfigObjectGUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.ExtCaps); err != nil {
		return err
	}
	return nil
}

// Extensions structure represents DRS_EXTENSIONS RPC structure.
//
// The DRS_EXTENSIONS structure defines a concrete type for capabilities information
// used in version negotiation.
type Extensions struct {
	// cb:  The size, in bytes, of the rgb array.
	Length uint32 `idl:"name:cb" json:"length"`
	// rgb:  To RPC, this field is a string of cb bytes. It is interpreted by the client
	// and the server as the first cb bytes of a DRS_EXTENSIONS_INT structure that follow
	// the cb field of that structure. The fields of the DRS_EXTENSIONS_INT structure are
	// in little-endian byte order. Since both DRS_EXTENSIONS and DRS_EXTENSIONS_INT begin
	// with a DWORD cb, a field in DRS_EXTENSIONS_INT is at the same offset in DRS_EXTENSIONS
	// as it is in DRS_EXTENSIONS_INT.
	Data []byte `idl:"name:rgb;size_is:(cb)" json:"data"`
}

func (o *Extensions) xxx_PreparePayload(ctx context.Context) error {
	if o.Data != nil && o.Length == 0 {
		o.Length = uint32(len(o.Data))
	}
	if o.Length < uint32(1) || o.Length > uint32(10000) {
		return fmt.Errorf("Length is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *Extensions) NDRSizeInfo() []uint64 {
	dimSize1 := uint64(o.Length)
	return []uint64{
		dimSize1,
	}
}
func (o *Extensions) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for sz1 := range sizeInfo {
			if err := w.WriteSize(sizeInfo[sz1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Length); err != nil {
		return err
	}
	for i1 := range o.Data {
		i1 := i1
		if uint64(i1) >= sizeInfo[0] {
			break
		}
		if err := w.WriteData(o.Data[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Data); uint64(i1) < sizeInfo[0]; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	return nil
}
func (o *Extensions) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for i1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[i1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Length); err != nil {
		return err
	}
	// XXX: for opaque unmarshaling
	if o.Length > 0 && sizeInfo[0] == 0 {
		sizeInfo[0] = uint64(o.Length)
	}
	if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
		return fmt.Errorf("buffer overflow for size %d of array o.Data", sizeInfo[0])
	}
	o.Data = make([]byte, sizeInfo[0])
	for i1 := range o.Data {
		i1 := i1
		if err := w.ReadData(&o.Data[i1]); err != nil {
			return err
		}
	}
	return nil
}

// MessageGetNCChangesRequestV3 structure represents DRS_MSG_GETCHGREQ_V3 RPC structure.
//
// The DRS_MSG_GETCHGREQ_V3 structure defines a portion of the request message that
// is sent to the IDL_DRSGetNCChanges method as part of SMTP replication ([MS-SRPL]).
// This is not a complete request message; it is embedded in DRS_MSG_GETCHGREQ_V4 and
// DRS_MSG_GETCHGREQ_V7.<26>
type MessageGetNCChangesRequestV3 struct {
	// uuidDsaObjDest:  DSA GUID of the client DC.
	DSAObjectDestination *dtyp.UUID `idl:"name:uuidDsaObjDest" json:"dsa_object_destination"`
	// uuidInvocIdSrc:  Invocation ID of the server DC.
	InvocationIDSource *dtyp.UUID `idl:"name:uuidInvocIdSrc" json:"invocation_id_source"`
	// pNC:  NC root of the replica to replicate or the FSMO role object for an extended
	// operation.
	NC *DSName `idl:"name:pNC;pointer:ref" json:"nc"`
	// usnvecFrom:  Data that is used to correlate calls to IDL_DRSGetNCChanges.
	From *Vector `idl:"name:usnvecFrom" json:"from"`
	// pUpToDateVecDestV1:  Stamp filter describing updates that the client has already
	// applied.
	UpToDateVectorDestinationV1 *UpToDateVectorV1Ext `idl:"name:pUpToDateVecDestV1;pointer:unique" json:"up_to_date_vector_destination_v1"`
	// pPartialAttrVecDestV1:  A set of one or more attributes whose values are to be replicated
	// to the client's partial replica.
	PartialAttributeVectorDestinationV1 *PartialAttributeVectorV1Ext `idl:"name:pPartialAttrVecDestV1;pointer:unique" json:"partial_attribute_vector_destination_v1"`
	// PrefixTableDest:  Prefix table with which to convert the ATTRTYP values in pPartialAttrVecDestV1
	// to OIDs.
	PrefixTableDestination *SchemaPrefixTable `idl:"name:PrefixTableDest" json:"prefix_table_destination"`
	// ulFlags:  A DRS_OPTIONS bit field.
	Flags uint32 `idl:"name:ulFlags" json:"flags"`
	// cMaxObjects:  An approximate cap on the number of objects to include in the reply.
	MaxObjectsCount uint32 `idl:"name:cMaxObjects" json:"max_objects_count"`
	// cMaxBytes:  An approximate cap on the number of bytes to include in the reply.
	MaxBytesCount uint32 `idl:"name:cMaxBytes" json:"max_bytes_count"`
	// ulExtendedOp:  0 or an EXOP_REQ code (section 4.1.10.2.22).
	ExtendedOperation uint32 `idl:"name:ulExtendedOp" json:"extended_operation"`
}

func (o *MessageGetNCChangesRequestV3) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetNCChangesRequestV3) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if o.DSAObjectDestination != nil {
		if err := o.DSAObjectDestination.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.InvocationIDSource != nil {
		if err := o.InvocationIDSource.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.NC != nil {
		_ptr_pNC := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.NC != nil {
				if err := o.NC.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSName{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.NC, _ptr_pNC); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.From != nil {
		if err := o.From.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&Vector{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.UpToDateVectorDestinationV1 != nil {
		_ptr_pUpToDateVecDestV1 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.UpToDateVectorDestinationV1 != nil {
				if err := o.UpToDateVectorDestinationV1.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&UpToDateVectorV1Ext{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.UpToDateVectorDestinationV1, _ptr_pUpToDateVecDestV1); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.PartialAttributeVectorDestinationV1 != nil {
		_ptr_pPartialAttrVecDestV1 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.PartialAttributeVectorDestinationV1 != nil {
				if err := o.PartialAttributeVectorDestinationV1.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&PartialAttributeVectorV1Ext{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.PartialAttributeVectorDestinationV1, _ptr_pPartialAttrVecDestV1); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.PrefixTableDestination != nil {
		if err := o.PrefixTableDestination.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&SchemaPrefixTable{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxObjectsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxBytesCount); err != nil {
		return err
	}
	if err := w.WriteData(o.ExtendedOperation); err != nil {
		return err
	}
	return nil
}
func (o *MessageGetNCChangesRequestV3) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if o.DSAObjectDestination == nil {
		o.DSAObjectDestination = &dtyp.UUID{}
	}
	if err := o.DSAObjectDestination.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.InvocationIDSource == nil {
		o.InvocationIDSource = &dtyp.UUID{}
	}
	if err := o.InvocationIDSource.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_pNC := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.NC == nil {
			o.NC = &DSName{}
		}
		if err := o.NC.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pNC := func(ptr interface{}) { o.NC = *ptr.(**DSName) }
	if err := w.ReadPointer(&o.NC, _s_pNC, _ptr_pNC); err != nil {
		return err
	}
	if o.From == nil {
		o.From = &Vector{}
	}
	if err := o.From.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_pUpToDateVecDestV1 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.UpToDateVectorDestinationV1 == nil {
			o.UpToDateVectorDestinationV1 = &UpToDateVectorV1Ext{}
		}
		if err := o.UpToDateVectorDestinationV1.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pUpToDateVecDestV1 := func(ptr interface{}) { o.UpToDateVectorDestinationV1 = *ptr.(**UpToDateVectorV1Ext) }
	if err := w.ReadPointer(&o.UpToDateVectorDestinationV1, _s_pUpToDateVecDestV1, _ptr_pUpToDateVecDestV1); err != nil {
		return err
	}
	_ptr_pPartialAttrVecDestV1 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.PartialAttributeVectorDestinationV1 == nil {
			o.PartialAttributeVectorDestinationV1 = &PartialAttributeVectorV1Ext{}
		}
		if err := o.PartialAttributeVectorDestinationV1.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pPartialAttrVecDestV1 := func(ptr interface{}) { o.PartialAttributeVectorDestinationV1 = *ptr.(**PartialAttributeVectorV1Ext) }
	if err := w.ReadPointer(&o.PartialAttributeVectorDestinationV1, _s_pPartialAttrVecDestV1, _ptr_pPartialAttrVecDestV1); err != nil {
		return err
	}
	if o.PrefixTableDestination == nil {
		o.PrefixTableDestination = &SchemaPrefixTable{}
	}
	if err := o.PrefixTableDestination.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxObjectsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxBytesCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.ExtendedOperation); err != nil {
		return err
	}
	return nil
}

// MessageGetNCChangesRequestV4 structure represents DRS_MSG_GETCHGREQ_V4 RPC structure.
//
// The DRS_MSG_GETCHGREQ_V4 structure defines the request message sent to the IDL_DRSGetNCChanges
// method. This message version is a superset of DRS_MSG_GETCHGREQ_V3.<27>
type MessageGetNCChangesRequestV4 struct {
	// uuidTransportObj:  The objectGUID of the interSiteTransport object that identifies
	// the transport by which to send the reply.
	TransportObject *dtyp.UUID `idl:"name:uuidTransportObj" json:"transport_object"`
	// pmtxReturnAddress:  The transport-specific address to which to send the reply.
	ReturnAddress *MTXAddr `idl:"name:pmtxReturnAddress;pointer:ref" json:"return_address"`
	// V3:  Version 3 request.
	V3 *MessageGetNCChangesRequestV3 `idl:"name:V3" json:"v3"`
}

func (o *MessageGetNCChangesRequestV4) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetNCChangesRequestV4) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if o.TransportObject != nil {
		if err := o.TransportObject.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.ReturnAddress != nil {
		_ptr_pmtxReturnAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ReturnAddress != nil {
				if err := o.ReturnAddress.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&MTXAddr{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ReturnAddress, _ptr_pmtxReturnAddress); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.V3 != nil {
		if err := o.V3.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageGetNCChangesRequestV3{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetNCChangesRequestV4) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if o.TransportObject == nil {
		o.TransportObject = &dtyp.UUID{}
	}
	if err := o.TransportObject.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_pmtxReturnAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ReturnAddress == nil {
			o.ReturnAddress = &MTXAddr{}
		}
		if err := o.ReturnAddress.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pmtxReturnAddress := func(ptr interface{}) { o.ReturnAddress = *ptr.(**MTXAddr) }
	if err := w.ReadPointer(&o.ReturnAddress, _s_pmtxReturnAddress, _ptr_pmtxReturnAddress); err != nil {
		return err
	}
	if o.V3 == nil {
		o.V3 = &MessageGetNCChangesRequestV3{}
	}
	if err := o.V3.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageGetNCChangesRequestV7 structure represents DRS_MSG_GETCHGREQ_V7 RPC structure.
//
// The DRS_MSG_GETCHGREQ_V7 structure defines the request message sent to the IDL_DRSGetNCChanges
// method. This message version is a superset of DRS_MSG_GETCHGREQ_V4.<28>
type MessageGetNCChangesRequestV7 struct {
	// uuidTransportObj:  The objectGUID of the interSiteTransport object that identifies
	// the transport by which to send the reply.
	TransportObject *dtyp.UUID `idl:"name:uuidTransportObj" json:"transport_object"`
	// pmtxReturnAddress:  Transport-specific address to which to send the reply.
	ReturnAddress *MTXAddr `idl:"name:pmtxReturnAddress;pointer:ref" json:"return_address"`
	// V3:  Version 3 request.
	V3 *MessageGetNCChangesRequestV3 `idl:"name:V3" json:"v3"`
	// pPartialAttrSet:  A set of one or more attributes whose values are to be replicated
	// to the client's partial replica, or null if the client has a full replica.
	PartialAttributeSet *PartialAttributeVectorV1Ext `idl:"name:pPartialAttrSet;pointer:unique" json:"partial_attribute_set"`
	// pPartialAttrSetEx:  A set of one or more attributes whose values are to be added
	// to the client's existing partial replica, or null.
	PartialAttributeSetEx *PartialAttributeVectorV1Ext `idl:"name:pPartialAttrSetEx;pointer:unique" json:"partial_attribute_set_ex"`
	// PrefixTableDest:  Prefix table with which to convert the ATTRTYP values in pPartialAttrSet
	// and pPartialAttrSetEx to OIDs.
	PrefixTableDestination *SchemaPrefixTable `idl:"name:PrefixTableDest" json:"prefix_table_destination"`
}

func (o *MessageGetNCChangesRequestV7) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetNCChangesRequestV7) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if o.TransportObject != nil {
		if err := o.TransportObject.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.ReturnAddress != nil {
		_ptr_pmtxReturnAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ReturnAddress != nil {
				if err := o.ReturnAddress.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&MTXAddr{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ReturnAddress, _ptr_pmtxReturnAddress); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.V3 != nil {
		if err := o.V3.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageGetNCChangesRequestV3{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.PartialAttributeSet != nil {
		_ptr_pPartialAttrSet := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.PartialAttributeSet != nil {
				if err := o.PartialAttributeSet.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&PartialAttributeVectorV1Ext{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.PartialAttributeSet, _ptr_pPartialAttrSet); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.PartialAttributeSetEx != nil {
		_ptr_pPartialAttrSetEx := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.PartialAttributeSetEx != nil {
				if err := o.PartialAttributeSetEx.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&PartialAttributeVectorV1Ext{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.PartialAttributeSetEx, _ptr_pPartialAttrSetEx); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.PrefixTableDestination != nil {
		if err := o.PrefixTableDestination.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&SchemaPrefixTable{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetNCChangesRequestV7) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if o.TransportObject == nil {
		o.TransportObject = &dtyp.UUID{}
	}
	if err := o.TransportObject.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_pmtxReturnAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ReturnAddress == nil {
			o.ReturnAddress = &MTXAddr{}
		}
		if err := o.ReturnAddress.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pmtxReturnAddress := func(ptr interface{}) { o.ReturnAddress = *ptr.(**MTXAddr) }
	if err := w.ReadPointer(&o.ReturnAddress, _s_pmtxReturnAddress, _ptr_pmtxReturnAddress); err != nil {
		return err
	}
	if o.V3 == nil {
		o.V3 = &MessageGetNCChangesRequestV3{}
	}
	if err := o.V3.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_pPartialAttrSet := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.PartialAttributeSet == nil {
			o.PartialAttributeSet = &PartialAttributeVectorV1Ext{}
		}
		if err := o.PartialAttributeSet.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pPartialAttrSet := func(ptr interface{}) { o.PartialAttributeSet = *ptr.(**PartialAttributeVectorV1Ext) }
	if err := w.ReadPointer(&o.PartialAttributeSet, _s_pPartialAttrSet, _ptr_pPartialAttrSet); err != nil {
		return err
	}
	_ptr_pPartialAttrSetEx := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.PartialAttributeSetEx == nil {
			o.PartialAttributeSetEx = &PartialAttributeVectorV1Ext{}
		}
		if err := o.PartialAttributeSetEx.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pPartialAttrSetEx := func(ptr interface{}) { o.PartialAttributeSetEx = *ptr.(**PartialAttributeVectorV1Ext) }
	if err := w.ReadPointer(&o.PartialAttributeSetEx, _s_pPartialAttrSetEx, _ptr_pPartialAttrSetEx); err != nil {
		return err
	}
	if o.PrefixTableDestination == nil {
		o.PrefixTableDestination = &SchemaPrefixTable{}
	}
	if err := o.PrefixTableDestination.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageGetNCChangesReplyV1 structure represents DRS_MSG_GETCHGREPLY_V1 RPC structure.
//
// The DRS_MSG_GETCHGREPLY_V1 structure defines the response message received from the
// IDL_DRSGetNCChanges method.
type MessageGetNCChangesReplyV1 struct {
	// uuidDsaObjSrc:  DSA GUID of the server DC.
	DSAObjectSource *dtyp.UUID `idl:"name:uuidDsaObjSrc" json:"dsa_object_source"`
	// uuidInvocIdSrc:  Invocation ID of the server DC.
	InvocationIDSource *dtyp.UUID `idl:"name:uuidInvocIdSrc" json:"invocation_id_source"`
	// pNC:  The NC root of the replica to replicate or the FSMO role object for an extended
	// operation.
	NC *DSName `idl:"name:pNC;pointer:unique" json:"nc"`
	// usnvecFrom:  Data used to correlate calls to IDL_DRSGetNCChanges.
	From *Vector `idl:"name:usnvecFrom" json:"from"`
	// usnvecTo:  Data used to correlate calls to IDL_DRSGetNCChanges.
	To *Vector `idl:"name:usnvecTo" json:"to"`
	// pUpToDateVecSrcV1:  Stamp filter that describes updates the server has already applied.
	UpToDateVectorSourceV1 *UpToDateVectorV1Ext `idl:"name:pUpToDateVecSrcV1;pointer:unique" json:"up_to_date_vector_source_v1"`
	// PrefixTableSrc:  Table for translating ATTRTYP values in the response to OIDs.
	PrefixTableSource *SchemaPrefixTable `idl:"name:PrefixTableSrc" json:"prefix_table_source"`
	// ulExtendedRet:  0 or an EXOP_ERR code (section 4.1.10.2.21).
	ExtendedReturn uint32 `idl:"name:ulExtendedRet" json:"extended_return"`
	// cNumObjects:  Count of items in the pObjects linked list.
	ObjectsCount uint32 `idl:"name:cNumObjects" json:"objects_count"`
	// cNumBytes:  Size in bytes of items in or referenced by elements in the pObjects linked
	// list.
	BytesCount uint32 `idl:"name:cNumBytes" json:"bytes_count"`
	// pObjects:  Linked list of object updates that the client applies to its NC replica.
	Objects *ReplicationEntityInfoList `idl:"name:pObjects;pointer:unique" json:"objects"`
	// fMoreData:  False if and only if this is the last response in a replication cycle.
	MoreData bool `idl:"name:fMoreData" json:"more_data"`
}

func (o *MessageGetNCChangesReplyV1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetNCChangesReplyV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if o.DSAObjectSource != nil {
		if err := o.DSAObjectSource.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.InvocationIDSource != nil {
		if err := o.InvocationIDSource.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.NC != nil {
		_ptr_pNC := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.NC != nil {
				if err := o.NC.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSName{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.NC, _ptr_pNC); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.From != nil {
		if err := o.From.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&Vector{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.To != nil {
		if err := o.To.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&Vector{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.UpToDateVectorSourceV1 != nil {
		_ptr_pUpToDateVecSrcV1 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.UpToDateVectorSourceV1 != nil {
				if err := o.UpToDateVectorSourceV1.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&UpToDateVectorV1Ext{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.UpToDateVectorSourceV1, _ptr_pUpToDateVecSrcV1); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.PrefixTableSource != nil {
		if err := o.PrefixTableSource.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&SchemaPrefixTable{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.ExtendedReturn); err != nil {
		return err
	}
	if err := w.WriteData(o.ObjectsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.BytesCount); err != nil {
		return err
	}
	if o.Objects != nil {
		_ptr_pObjects := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Objects != nil {
				if err := o.Objects.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ReplicationEntityInfoList{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Objects, _ptr_pObjects); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if !o.MoreData {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetNCChangesReplyV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if o.DSAObjectSource == nil {
		o.DSAObjectSource = &dtyp.UUID{}
	}
	if err := o.DSAObjectSource.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.InvocationIDSource == nil {
		o.InvocationIDSource = &dtyp.UUID{}
	}
	if err := o.InvocationIDSource.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_pNC := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.NC == nil {
			o.NC = &DSName{}
		}
		if err := o.NC.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pNC := func(ptr interface{}) { o.NC = *ptr.(**DSName) }
	if err := w.ReadPointer(&o.NC, _s_pNC, _ptr_pNC); err != nil {
		return err
	}
	if o.From == nil {
		o.From = &Vector{}
	}
	if err := o.From.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.To == nil {
		o.To = &Vector{}
	}
	if err := o.To.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_pUpToDateVecSrcV1 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.UpToDateVectorSourceV1 == nil {
			o.UpToDateVectorSourceV1 = &UpToDateVectorV1Ext{}
		}
		if err := o.UpToDateVectorSourceV1.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pUpToDateVecSrcV1 := func(ptr interface{}) { o.UpToDateVectorSourceV1 = *ptr.(**UpToDateVectorV1Ext) }
	if err := w.ReadPointer(&o.UpToDateVectorSourceV1, _s_pUpToDateVecSrcV1, _ptr_pUpToDateVecSrcV1); err != nil {
		return err
	}
	if o.PrefixTableSource == nil {
		o.PrefixTableSource = &SchemaPrefixTable{}
	}
	if err := o.PrefixTableSource.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.ExtendedReturn); err != nil {
		return err
	}
	if err := w.ReadData(&o.ObjectsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.BytesCount); err != nil {
		return err
	}
	_ptr_pObjects := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Objects == nil {
			o.Objects = &ReplicationEntityInfoList{}
		}
		if err := o.Objects.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pObjects := func(ptr interface{}) { o.Objects = *ptr.(**ReplicationEntityInfoList) }
	if err := w.ReadPointer(&o.Objects, _s_pObjects, _ptr_pObjects); err != nil {
		return err
	}
	var _bMoreData int32
	if err := w.ReadData(&_bMoreData); err != nil {
		return err
	}
	o.MoreData = _bMoreData != 0
	return nil
}

// MessageGetNCChangesReplyV6 structure represents DRS_MSG_GETCHGREPLY_V6 RPC structure.
//
// The DRS_MSG_GETCHGREPLY_V6 structure defines the response message received from the
// IDL_DRSGetNCChanges method. This message version is a superset of DRS_MSG_GETCHGREPLY_V1.
type MessageGetNCChangesReplyV6 struct {
	// uuidDsaObjSrc:  DSA GUID of the server DC.
	DSAObjectSource *dtyp.UUID `idl:"name:uuidDsaObjSrc" json:"dsa_object_source"`
	// uuidInvocIdSrc:  Invocation ID of the server DC.
	InvocationIDSource *dtyp.UUID `idl:"name:uuidInvocIdSrc" json:"invocation_id_source"`
	// pNC:  The NC root of the replica to replicate or the FSMO role object for an extended
	// operation.
	NC *DSName `idl:"name:pNC;pointer:unique" json:"nc"`
	// usnvecFrom:  Data used to correlate calls to IDL_DRSGetNCChanges.
	From *Vector `idl:"name:usnvecFrom" json:"from"`
	// usnvecTo:  Data used to correlate calls to IDL_DRSGetNCChanges.
	To *Vector `idl:"name:usnvecTo" json:"to"`
	// pUpToDateVecSrc:  Stamp filter that describes updates the server has already applied.
	UpToDateVectorSource *UpToDateVectorV2Ext `idl:"name:pUpToDateVecSrc;pointer:unique" json:"up_to_date_vector_source"`
	// PrefixTableSrc:  Table for translating ATTRTYP values in the response to OIDs.
	PrefixTableSource *SchemaPrefixTable `idl:"name:PrefixTableSrc" json:"prefix_table_source"`
	// ulExtendedRet:  0 or an extended operation error code (section 4.1.10.2.21).
	ExtendedReturn uint32 `idl:"name:ulExtendedRet" json:"extended_return"`
	// cNumObjects:  Count of items in the pObjects linked list.
	ObjectsCount uint32 `idl:"name:cNumObjects" json:"objects_count"`
	// cNumBytes:  Size in bytes of items in or referenced by elements in the pObjects linked
	// list.
	BytesCount uint32 `idl:"name:cNumBytes" json:"bytes_count"`
	// pObjects:  Linked list of object updates that the client applies to its NC replica.
	Objects *ReplicationEntityInfoList `idl:"name:pObjects;pointer:unique" json:"objects"`
	// fMoreData:  False if and only if this is the last response in a replication cycle.
	MoreData bool `idl:"name:fMoreData" json:"more_data"`
	// cNumNcSizeObjects:  Estimated number of objects in the server's NC replica.
	NCSizeObjectsCount uint32 `idl:"name:cNumNcSizeObjects" json:"nc_size_objects_count"`
	// cNumNcSizeValues:  Estimated number of link values in the server's NC replica.
	NCSizeValuesCount uint32 `idl:"name:cNumNcSizeValues" json:"nc_size_values_count"`
	// cNumValues:  Count of items in the rgValues array.
	ValuesCount uint32 `idl:"name:cNumValues" json:"values_count"`
	// rgValues:  Link value updates for the client to apply to its NC replica.
	Values []*ReplicationValueInfoV1 `idl:"name:rgValues;size_is:(cNumValues)" json:"values"`
	// dwDRSError:  0 if successful, otherwise a Windows error code.
	DRSError uint32 `idl:"name:dwDRSError" json:"drs_error"`
}

func (o *MessageGetNCChangesReplyV6) xxx_PreparePayload(ctx context.Context) error {
	if o.Values != nil && o.ValuesCount == 0 {
		o.ValuesCount = uint32(len(o.Values))
	}
	if o.ValuesCount > uint32(1048576) {
		return fmt.Errorf("ValuesCount is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetNCChangesReplyV6) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if o.DSAObjectSource != nil {
		if err := o.DSAObjectSource.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.InvocationIDSource != nil {
		if err := o.InvocationIDSource.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.NC != nil {
		_ptr_pNC := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.NC != nil {
				if err := o.NC.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSName{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.NC, _ptr_pNC); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.From != nil {
		if err := o.From.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&Vector{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.To != nil {
		if err := o.To.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&Vector{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.UpToDateVectorSource != nil {
		_ptr_pUpToDateVecSrc := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.UpToDateVectorSource != nil {
				if err := o.UpToDateVectorSource.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&UpToDateVectorV2Ext{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.UpToDateVectorSource, _ptr_pUpToDateVecSrc); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.PrefixTableSource != nil {
		if err := o.PrefixTableSource.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&SchemaPrefixTable{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.ExtendedReturn); err != nil {
		return err
	}
	if err := w.WriteData(o.ObjectsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.BytesCount); err != nil {
		return err
	}
	if o.Objects != nil {
		_ptr_pObjects := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Objects != nil {
				if err := o.Objects.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ReplicationEntityInfoList{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Objects, _ptr_pObjects); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if !o.MoreData {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.NCSizeObjectsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.NCSizeValuesCount); err != nil {
		return err
	}
	if err := w.WriteData(o.ValuesCount); err != nil {
		return err
	}
	if o.Values != nil || o.ValuesCount > 0 {
		_ptr_rgValues := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.ValuesCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Values {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Values[i1] != nil {
					if err := o.Values[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&ReplicationValueInfoV1{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Values); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&ReplicationValueInfoV1{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Values, _ptr_rgValues); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.DRSError); err != nil {
		return err
	}
	return nil
}
func (o *MessageGetNCChangesReplyV6) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if o.DSAObjectSource == nil {
		o.DSAObjectSource = &dtyp.UUID{}
	}
	if err := o.DSAObjectSource.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.InvocationIDSource == nil {
		o.InvocationIDSource = &dtyp.UUID{}
	}
	if err := o.InvocationIDSource.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_pNC := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.NC == nil {
			o.NC = &DSName{}
		}
		if err := o.NC.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pNC := func(ptr interface{}) { o.NC = *ptr.(**DSName) }
	if err := w.ReadPointer(&o.NC, _s_pNC, _ptr_pNC); err != nil {
		return err
	}
	if o.From == nil {
		o.From = &Vector{}
	}
	if err := o.From.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.To == nil {
		o.To = &Vector{}
	}
	if err := o.To.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_pUpToDateVecSrc := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.UpToDateVectorSource == nil {
			o.UpToDateVectorSource = &UpToDateVectorV2Ext{}
		}
		if err := o.UpToDateVectorSource.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pUpToDateVecSrc := func(ptr interface{}) { o.UpToDateVectorSource = *ptr.(**UpToDateVectorV2Ext) }
	if err := w.ReadPointer(&o.UpToDateVectorSource, _s_pUpToDateVecSrc, _ptr_pUpToDateVecSrc); err != nil {
		return err
	}
	if o.PrefixTableSource == nil {
		o.PrefixTableSource = &SchemaPrefixTable{}
	}
	if err := o.PrefixTableSource.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.ExtendedReturn); err != nil {
		return err
	}
	if err := w.ReadData(&o.ObjectsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.BytesCount); err != nil {
		return err
	}
	_ptr_pObjects := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Objects == nil {
			o.Objects = &ReplicationEntityInfoList{}
		}
		if err := o.Objects.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pObjects := func(ptr interface{}) { o.Objects = *ptr.(**ReplicationEntityInfoList) }
	if err := w.ReadPointer(&o.Objects, _s_pObjects, _ptr_pObjects); err != nil {
		return err
	}
	var _bMoreData int32
	if err := w.ReadData(&_bMoreData); err != nil {
		return err
	}
	o.MoreData = _bMoreData != 0
	if err := w.ReadData(&o.NCSizeObjectsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.NCSizeValuesCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.ValuesCount); err != nil {
		return err
	}
	_ptr_rgValues := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.ValuesCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.ValuesCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Values", sizeInfo[0])
		}
		o.Values = make([]*ReplicationValueInfoV1, sizeInfo[0])
		for i1 := range o.Values {
			i1 := i1
			if o.Values[i1] == nil {
				o.Values[i1] = &ReplicationValueInfoV1{}
			}
			if err := o.Values[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_rgValues := func(ptr interface{}) { o.Values = *ptr.(*[]*ReplicationValueInfoV1) }
	if err := w.ReadPointer(&o.Values, _s_rgValues, _ptr_rgValues); err != nil {
		return err
	}
	if err := w.ReadData(&o.DRSError); err != nil {
		return err
	}
	return nil
}

// MessageGetNCChangesReplyV9 structure represents DRS_MSG_GETCHGREPLY_V9 RPC structure.
//
// The DRS_MSG_GETCHGREPLY_V9 structure defines the response message received from the
// IDL_DRSGetNCChanges method. This message version contains all the same elements as
// a DRS_MSG_GETCHGREPLY_V6 structure except that the data type of rgValues is changed
// from REPLVALINF_V1* to REPLVALINF_V3*. The data in a REPLVALINF_V3 structure is a
// superset of the data in a REPLVALINF_V1 structure. Therefore, the data in the DRS_MSG_GETCHGREPLY_V9
// structure is a superset of the data in the DRS_MSG_GETCHGREPLY_V6 structure.
type MessageGetNCChangesReplyV9 struct {
	// uuidDsaObjSrc:  DSA GUID of the server DC.
	DSAObjectSource *dtyp.UUID `idl:"name:uuidDsaObjSrc" json:"dsa_object_source"`
	// uuidInvocIdSrc:  Invocation ID of the server DC.
	InvocationIDSource *dtyp.UUID `idl:"name:uuidInvocIdSrc" json:"invocation_id_source"`
	// pNC:  The NC root of the replica to replicate or the FSMO role object for an extended
	// operation.
	NC *DSName `idl:"name:pNC;pointer:unique" json:"nc"`
	// usnvecFrom:  Data used to correlate calls to IDL_DRSGetNCChanges.
	From *Vector `idl:"name:usnvecFrom" json:"from"`
	// usnvecTo:  Data used to correlate calls to IDL_DRSGetNCChanges.
	To *Vector `idl:"name:usnvecTo" json:"to"`
	// pUpToDateVecSrc:  Stamp filter that describes updates the server has already applied.
	UpToDateVectorSource *UpToDateVectorV2Ext `idl:"name:pUpToDateVecSrc;pointer:unique" json:"up_to_date_vector_source"`
	// PrefixTableSrc:  Table for translating ATTRTYP values in the response to OIDs.
	PrefixTableSource *SchemaPrefixTable `idl:"name:PrefixTableSrc" json:"prefix_table_source"`
	// ulExtendedRet:  0 or an extended operation error code (section 4.1.10.2.21).
	ExtendedReturn uint32 `idl:"name:ulExtendedRet" json:"extended_return"`
	// cNumObjects:  Count of items in the pObjects linked list.
	ObjectsCount uint32 `idl:"name:cNumObjects" json:"objects_count"`
	// cNumBytes:  Size in bytes of items in or referenced by elements in the pObjects linked
	// list.
	BytesCount uint32 `idl:"name:cNumBytes" json:"bytes_count"`
	// pObjects:  Linked list of object updates that the client applies to its NC replica.
	Objects *ReplicationEntityInfoList `idl:"name:pObjects;pointer:unique" json:"objects"`
	// fMoreData:  False if and only if this is the last response in a replication cycle.
	MoreData bool `idl:"name:fMoreData" json:"more_data"`
	// cNumNcSizeObjects:  Estimated number of objects in the server's NC replica.
	NCSizeObjectsCount uint32 `idl:"name:cNumNcSizeObjects" json:"nc_size_objects_count"`
	// cNumNcSizeValues:  Estimated number of link values in the server's NC replica.
	NCSizeValuesCount uint32 `idl:"name:cNumNcSizeValues" json:"nc_size_values_count"`
	// cNumValues:  Count of items in the rgValues array.
	ValuesCount uint32 `idl:"name:cNumValues" json:"values_count"`
	// rgValues:  Link value updates for the client to apply to its NC replica.
	Values []*ReplicationValueInfoV3 `idl:"name:rgValues;size_is:(cNumValues)" json:"values"`
	// dwDRSError:  0 if successful, otherwise a Windows error code.
	DRSError uint32 `idl:"name:dwDRSError" json:"drs_error"`
}

func (o *MessageGetNCChangesReplyV9) xxx_PreparePayload(ctx context.Context) error {
	if o.Values != nil && o.ValuesCount == 0 {
		o.ValuesCount = uint32(len(o.Values))
	}
	if o.ValuesCount > uint32(1048576) {
		return fmt.Errorf("ValuesCount is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetNCChangesReplyV9) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if o.DSAObjectSource != nil {
		if err := o.DSAObjectSource.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.InvocationIDSource != nil {
		if err := o.InvocationIDSource.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.NC != nil {
		_ptr_pNC := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.NC != nil {
				if err := o.NC.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSName{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.NC, _ptr_pNC); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.From != nil {
		if err := o.From.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&Vector{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.To != nil {
		if err := o.To.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&Vector{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.UpToDateVectorSource != nil {
		_ptr_pUpToDateVecSrc := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.UpToDateVectorSource != nil {
				if err := o.UpToDateVectorSource.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&UpToDateVectorV2Ext{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.UpToDateVectorSource, _ptr_pUpToDateVecSrc); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.PrefixTableSource != nil {
		if err := o.PrefixTableSource.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&SchemaPrefixTable{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.ExtendedReturn); err != nil {
		return err
	}
	if err := w.WriteData(o.ObjectsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.BytesCount); err != nil {
		return err
	}
	if o.Objects != nil {
		_ptr_pObjects := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Objects != nil {
				if err := o.Objects.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ReplicationEntityInfoList{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Objects, _ptr_pObjects); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if !o.MoreData {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.NCSizeObjectsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.NCSizeValuesCount); err != nil {
		return err
	}
	if err := w.WriteData(o.ValuesCount); err != nil {
		return err
	}
	if o.Values != nil || o.ValuesCount > 0 {
		_ptr_rgValues := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.ValuesCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Values {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Values[i1] != nil {
					if err := o.Values[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&ReplicationValueInfoV3{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Values); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&ReplicationValueInfoV3{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Values, _ptr_rgValues); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.DRSError); err != nil {
		return err
	}
	return nil
}
func (o *MessageGetNCChangesReplyV9) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if o.DSAObjectSource == nil {
		o.DSAObjectSource = &dtyp.UUID{}
	}
	if err := o.DSAObjectSource.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.InvocationIDSource == nil {
		o.InvocationIDSource = &dtyp.UUID{}
	}
	if err := o.InvocationIDSource.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_pNC := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.NC == nil {
			o.NC = &DSName{}
		}
		if err := o.NC.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pNC := func(ptr interface{}) { o.NC = *ptr.(**DSName) }
	if err := w.ReadPointer(&o.NC, _s_pNC, _ptr_pNC); err != nil {
		return err
	}
	if o.From == nil {
		o.From = &Vector{}
	}
	if err := o.From.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.To == nil {
		o.To = &Vector{}
	}
	if err := o.To.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_pUpToDateVecSrc := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.UpToDateVectorSource == nil {
			o.UpToDateVectorSource = &UpToDateVectorV2Ext{}
		}
		if err := o.UpToDateVectorSource.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pUpToDateVecSrc := func(ptr interface{}) { o.UpToDateVectorSource = *ptr.(**UpToDateVectorV2Ext) }
	if err := w.ReadPointer(&o.UpToDateVectorSource, _s_pUpToDateVecSrc, _ptr_pUpToDateVecSrc); err != nil {
		return err
	}
	if o.PrefixTableSource == nil {
		o.PrefixTableSource = &SchemaPrefixTable{}
	}
	if err := o.PrefixTableSource.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.ExtendedReturn); err != nil {
		return err
	}
	if err := w.ReadData(&o.ObjectsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.BytesCount); err != nil {
		return err
	}
	_ptr_pObjects := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Objects == nil {
			o.Objects = &ReplicationEntityInfoList{}
		}
		if err := o.Objects.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pObjects := func(ptr interface{}) { o.Objects = *ptr.(**ReplicationEntityInfoList) }
	if err := w.ReadPointer(&o.Objects, _s_pObjects, _ptr_pObjects); err != nil {
		return err
	}
	var _bMoreData int32
	if err := w.ReadData(&_bMoreData); err != nil {
		return err
	}
	o.MoreData = _bMoreData != 0
	if err := w.ReadData(&o.NCSizeObjectsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.NCSizeValuesCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.ValuesCount); err != nil {
		return err
	}
	_ptr_rgValues := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.ValuesCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.ValuesCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Values", sizeInfo[0])
		}
		o.Values = make([]*ReplicationValueInfoV3, sizeInfo[0])
		for i1 := range o.Values {
			i1 := i1
			if o.Values[i1] == nil {
				o.Values[i1] = &ReplicationValueInfoV3{}
			}
			if err := o.Values[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_rgValues := func(ptr interface{}) { o.Values = *ptr.(*[]*ReplicationValueInfoV3) }
	if err := w.ReadPointer(&o.Values, _s_rgValues, _ptr_rgValues); err != nil {
		return err
	}
	if err := w.ReadData(&o.DRSError); err != nil {
		return err
	}
	return nil
}

// CompressedBlob structure represents DRS_COMPRESSED_BLOB RPC structure.
//
// The DRS_COMPRESSED_BLOB structure defines a concrete type that results from marshaling
// a data structure into a byte stream by using RPC and compressing that byte stream.
type CompressedBlob struct {
	// cbUncompressedSize:  Size in bytes of the uncompressed byte stream.
	UncompressedLength uint32 `idl:"name:cbUncompressedSize" json:"uncompressed_length"`
	// cbCompressedSize:  Size in bytes of the pbCompressedData array.<29>
	CompressedLength uint32 `idl:"name:cbCompressedSize" json:"compressed_length"`
	// pbCompressedData:  Compressed byte stream.
	CompressedData []byte `idl:"name:pbCompressedData;size_is:(cbCompressedSize)" json:"compressed_data"`
}

func (o *CompressedBlob) xxx_PreparePayload(ctx context.Context) error {
	if o.CompressedData != nil && o.CompressedLength == 0 {
		o.CompressedLength = uint32(len(o.CompressedData))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *CompressedBlob) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.UncompressedLength); err != nil {
		return err
	}
	if err := w.WriteData(o.CompressedLength); err != nil {
		return err
	}
	if o.CompressedData != nil || o.CompressedLength > 0 {
		_ptr_pbCompressedData := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.CompressedLength)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.CompressedData {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.CompressedData[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.CompressedData); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.CompressedData, _ptr_pbCompressedData); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *CompressedBlob) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.UncompressedLength); err != nil {
		return err
	}
	if err := w.ReadData(&o.CompressedLength); err != nil {
		return err
	}
	_ptr_pbCompressedData := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.CompressedLength > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.CompressedLength)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.CompressedData", sizeInfo[0])
		}
		o.CompressedData = make([]byte, sizeInfo[0])
		for i1 := range o.CompressedData {
			i1 := i1
			if err := w.ReadData(&o.CompressedData[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_pbCompressedData := func(ptr interface{}) { o.CompressedData = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.CompressedData, _s_pbCompressedData, _ptr_pbCompressedData); err != nil {
		return err
	}
	return nil
}

// MessageGetNCChangesRequestV5 structure represents DRS_MSG_GETCHGREQ_V5 RPC structure.
//
// The DRS_MSG_GETCHGREQ_V5 structure defines the request message sent to the IDL_DRSGetNCChanges
// method.
type MessageGetNCChangesRequestV5 struct {
	// uuidDsaObjDest:  DSA GUID of the client DC.
	DSAObjectDestination *dtyp.UUID `idl:"name:uuidDsaObjDest" json:"dsa_object_destination"`
	// uuidInvocIdSrc:  Invocation ID of the server DC.
	InvocationIDSource *dtyp.UUID `idl:"name:uuidInvocIdSrc" json:"invocation_id_source"`
	// pNC:  NC root of the replica to replicate or the FSMO role object for an extended
	// operation.
	NC *DSName `idl:"name:pNC;pointer:ref" json:"nc"`
	// usnvecFrom:  Data used to correlate calls to IDL_DRSGetNCChanges.
	From *Vector `idl:"name:usnvecFrom" json:"from"`
	// pUpToDateVecDestV1:  Stamp filter that describes updates the client has already applied.
	UpToDateVectorDestinationV1 *UpToDateVectorV1Ext `idl:"name:pUpToDateVecDestV1;pointer:unique" json:"up_to_date_vector_destination_v1"`
	// ulFlags:  DRS_OPTIONS bit field.
	Flags uint32 `idl:"name:ulFlags" json:"flags"`
	// cMaxObjects:  Approximate cap on the number of objects to include in the reply.
	MaxObjectsCount uint32 `idl:"name:cMaxObjects" json:"max_objects_count"`
	// cMaxBytes:  Approximate cap on the number of bytes to include in the reply.
	MaxBytesCount uint32 `idl:"name:cMaxBytes" json:"max_bytes_count"`
	// ulExtendedOp:  0 or an extended operation request code (section 4.1.10.2.22).
	ExtendedOperation uint32 `idl:"name:ulExtendedOp" json:"extended_operation"`
	// liFsmoInfo:  0 or a value specific to the requested extended operation.
	FSMOInfo *dtyp.UlargeInteger `idl:"name:liFsmoInfo" json:"fsmo_info"`
}

func (o *MessageGetNCChangesRequestV5) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetNCChangesRequestV5) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if o.DSAObjectDestination != nil {
		if err := o.DSAObjectDestination.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.InvocationIDSource != nil {
		if err := o.InvocationIDSource.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.NC != nil {
		_ptr_pNC := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.NC != nil {
				if err := o.NC.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSName{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.NC, _ptr_pNC); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.From != nil {
		if err := o.From.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&Vector{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.UpToDateVectorDestinationV1 != nil {
		_ptr_pUpToDateVecDestV1 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.UpToDateVectorDestinationV1 != nil {
				if err := o.UpToDateVectorDestinationV1.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&UpToDateVectorV1Ext{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.UpToDateVectorDestinationV1, _ptr_pUpToDateVecDestV1); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxObjectsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxBytesCount); err != nil {
		return err
	}
	if err := w.WriteData(o.ExtendedOperation); err != nil {
		return err
	}
	if o.FSMOInfo != nil {
		if err := o.FSMOInfo.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UlargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetNCChangesRequestV5) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if o.DSAObjectDestination == nil {
		o.DSAObjectDestination = &dtyp.UUID{}
	}
	if err := o.DSAObjectDestination.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.InvocationIDSource == nil {
		o.InvocationIDSource = &dtyp.UUID{}
	}
	if err := o.InvocationIDSource.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_pNC := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.NC == nil {
			o.NC = &DSName{}
		}
		if err := o.NC.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pNC := func(ptr interface{}) { o.NC = *ptr.(**DSName) }
	if err := w.ReadPointer(&o.NC, _s_pNC, _ptr_pNC); err != nil {
		return err
	}
	if o.From == nil {
		o.From = &Vector{}
	}
	if err := o.From.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_pUpToDateVecDestV1 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.UpToDateVectorDestinationV1 == nil {
			o.UpToDateVectorDestinationV1 = &UpToDateVectorV1Ext{}
		}
		if err := o.UpToDateVectorDestinationV1.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pUpToDateVecDestV1 := func(ptr interface{}) { o.UpToDateVectorDestinationV1 = *ptr.(**UpToDateVectorV1Ext) }
	if err := w.ReadPointer(&o.UpToDateVectorDestinationV1, _s_pUpToDateVecDestV1, _ptr_pUpToDateVecDestV1); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxObjectsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxBytesCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.ExtendedOperation); err != nil {
		return err
	}
	if o.FSMOInfo == nil {
		o.FSMOInfo = &dtyp.UlargeInteger{}
	}
	if err := o.FSMOInfo.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageGetNCChangesRequestV8 structure represents DRS_MSG_GETCHGREQ_V8 RPC structure.
//
// The DRS_MSG_GETCHGREQ_V8 structure defines the request message sent to the IDL_DRSGetNCChanges
// method. This message version is a superset of DRS_MSG_GETCHGREQ_V5.
type MessageGetNCChangesRequestV8 struct {
	// uuidDsaObjDest:  DSA GUID of the client DC.
	DSAObjectDestination *dtyp.UUID `idl:"name:uuidDsaObjDest" json:"dsa_object_destination"`
	// uuidInvocIdSrc:  Invocation ID of the server DC.
	InvocationIDSource *dtyp.UUID `idl:"name:uuidInvocIdSrc" json:"invocation_id_source"`
	// pNC:  NC root of the replica to replicate or the FSMO role object for an extended
	// operation.
	NC *DSName `idl:"name:pNC;pointer:ref" json:"nc"`
	// usnvecFrom:  Data used to correlate calls to IDL_DRSGetNCChanges.
	From *Vector `idl:"name:usnvecFrom" json:"from"`
	// pUpToDateVecDest:  Stamp filter describing updates the client has already applied.
	UpToDateVectorDestination *UpToDateVectorV1Ext `idl:"name:pUpToDateVecDest;pointer:unique" json:"up_to_date_vector_destination"`
	// ulFlags:  A DRS_OPTIONS bit field.
	Flags uint32 `idl:"name:ulFlags" json:"flags"`
	// cMaxObjects:  Approximate cap on the number of objects to include in the reply.
	MaxObjectsCount uint32 `idl:"name:cMaxObjects" json:"max_objects_count"`
	// cMaxBytes:  Approximate cap on the number of bytes to include in the reply.
	MaxBytesCount uint32 `idl:"name:cMaxBytes" json:"max_bytes_count"`
	// ulExtendedOp:  0 or an extended operation request code (section 4.1.10.2.22).
	ExtendedOperation uint32 `idl:"name:ulExtendedOp" json:"extended_operation"`
	// liFsmoInfo:  0 or a value specific to the requested extended operation.
	FSMOInfo *dtyp.UlargeInteger `idl:"name:liFsmoInfo" json:"fsmo_info"`
	// pPartialAttrSet:  A set of one or more attributes whose values are to be replicated
	// to the client's partial replica, or null if the client has a full replica.
	PartialAttributeSet *PartialAttributeVectorV1Ext `idl:"name:pPartialAttrSet;pointer:unique" json:"partial_attribute_set"`
	// pPartialAttrSetEx:  A set of one or more attributes whose values are to be added
	// to the client's existing partial replica, or null.
	PartialAttributeSetEx *PartialAttributeVectorV1Ext `idl:"name:pPartialAttrSetEx;pointer:unique" json:"partial_attribute_set_ex"`
	// PrefixTableDest:  Prefix table with which to convert the ATTRTYP values in pPartialAttrSet
	// and pPartialAttrSetEx to OIDs.
	PrefixTableDestination *SchemaPrefixTable `idl:"name:PrefixTableDest" json:"prefix_table_destination"`
}

func (o *MessageGetNCChangesRequestV8) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetNCChangesRequestV8) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if o.DSAObjectDestination != nil {
		if err := o.DSAObjectDestination.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.InvocationIDSource != nil {
		if err := o.InvocationIDSource.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.NC != nil {
		_ptr_pNC := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.NC != nil {
				if err := o.NC.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSName{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.NC, _ptr_pNC); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.From != nil {
		if err := o.From.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&Vector{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.UpToDateVectorDestination != nil {
		_ptr_pUpToDateVecDest := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.UpToDateVectorDestination != nil {
				if err := o.UpToDateVectorDestination.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&UpToDateVectorV1Ext{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.UpToDateVectorDestination, _ptr_pUpToDateVecDest); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxObjectsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxBytesCount); err != nil {
		return err
	}
	if err := w.WriteData(o.ExtendedOperation); err != nil {
		return err
	}
	if o.FSMOInfo != nil {
		if err := o.FSMOInfo.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UlargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.PartialAttributeSet != nil {
		_ptr_pPartialAttrSet := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.PartialAttributeSet != nil {
				if err := o.PartialAttributeSet.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&PartialAttributeVectorV1Ext{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.PartialAttributeSet, _ptr_pPartialAttrSet); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.PartialAttributeSetEx != nil {
		_ptr_pPartialAttrSetEx := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.PartialAttributeSetEx != nil {
				if err := o.PartialAttributeSetEx.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&PartialAttributeVectorV1Ext{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.PartialAttributeSetEx, _ptr_pPartialAttrSetEx); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.PrefixTableDestination != nil {
		if err := o.PrefixTableDestination.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&SchemaPrefixTable{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetNCChangesRequestV8) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if o.DSAObjectDestination == nil {
		o.DSAObjectDestination = &dtyp.UUID{}
	}
	if err := o.DSAObjectDestination.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.InvocationIDSource == nil {
		o.InvocationIDSource = &dtyp.UUID{}
	}
	if err := o.InvocationIDSource.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_pNC := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.NC == nil {
			o.NC = &DSName{}
		}
		if err := o.NC.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pNC := func(ptr interface{}) { o.NC = *ptr.(**DSName) }
	if err := w.ReadPointer(&o.NC, _s_pNC, _ptr_pNC); err != nil {
		return err
	}
	if o.From == nil {
		o.From = &Vector{}
	}
	if err := o.From.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_pUpToDateVecDest := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.UpToDateVectorDestination == nil {
			o.UpToDateVectorDestination = &UpToDateVectorV1Ext{}
		}
		if err := o.UpToDateVectorDestination.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pUpToDateVecDest := func(ptr interface{}) { o.UpToDateVectorDestination = *ptr.(**UpToDateVectorV1Ext) }
	if err := w.ReadPointer(&o.UpToDateVectorDestination, _s_pUpToDateVecDest, _ptr_pUpToDateVecDest); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxObjectsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxBytesCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.ExtendedOperation); err != nil {
		return err
	}
	if o.FSMOInfo == nil {
		o.FSMOInfo = &dtyp.UlargeInteger{}
	}
	if err := o.FSMOInfo.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_pPartialAttrSet := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.PartialAttributeSet == nil {
			o.PartialAttributeSet = &PartialAttributeVectorV1Ext{}
		}
		if err := o.PartialAttributeSet.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pPartialAttrSet := func(ptr interface{}) { o.PartialAttributeSet = *ptr.(**PartialAttributeVectorV1Ext) }
	if err := w.ReadPointer(&o.PartialAttributeSet, _s_pPartialAttrSet, _ptr_pPartialAttrSet); err != nil {
		return err
	}
	_ptr_pPartialAttrSetEx := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.PartialAttributeSetEx == nil {
			o.PartialAttributeSetEx = &PartialAttributeVectorV1Ext{}
		}
		if err := o.PartialAttributeSetEx.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pPartialAttrSetEx := func(ptr interface{}) { o.PartialAttributeSetEx = *ptr.(**PartialAttributeVectorV1Ext) }
	if err := w.ReadPointer(&o.PartialAttributeSetEx, _s_pPartialAttrSetEx, _ptr_pPartialAttrSetEx); err != nil {
		return err
	}
	if o.PrefixTableDestination == nil {
		o.PrefixTableDestination = &SchemaPrefixTable{}
	}
	if err := o.PrefixTableDestination.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageGetNCChangesRequestV10 structure represents DRS_MSG_GETCHGREQ_V10 RPC structure.
//
// The DRS_MSG_GETCHGREQ_V10 structure defines the request message sent to the IDL_DRSGetNCChanges
// method. This message version is a superset of DRS_MSG_GETCHGREQ_V8.
type MessageGetNCChangesRequestV10 struct {
	// uuidDsaObjDest:  DSA GUID of the client DC.
	DSAObjectDestination *dtyp.UUID `idl:"name:uuidDsaObjDest" json:"dsa_object_destination"`
	// uuidInvocIdSrc:  Invocation ID of the server DC.
	InvocationIDSource *dtyp.UUID `idl:"name:uuidInvocIdSrc" json:"invocation_id_source"`
	// pNC:  NC root of the replica to replicate or the FSMO role object for an extended
	// operation.
	NC *DSName `idl:"name:pNC;pointer:ref" json:"nc"`
	// usnvecFrom:  Data used to correlate calls to IDL_DRSGetNCChanges.
	From *Vector `idl:"name:usnvecFrom" json:"from"`
	// pUpToDateVecDest:  Stamp filter describing updates the client has already applied.
	UpToDateVectorDestination *UpToDateVectorV1Ext `idl:"name:pUpToDateVecDest;pointer:unique" json:"up_to_date_vector_destination"`
	// ulFlags:  A DRS_OPTIONS bit field.
	Flags uint32 `idl:"name:ulFlags" json:"flags"`
	// cMaxObjects:  Approximate cap on the number of objects to include in the reply.
	MaxObjectsCount uint32 `idl:"name:cMaxObjects" json:"max_objects_count"`
	// cMaxBytes:  Approximate cap on the number of bytes to include in the reply.
	MaxBytesCount uint32 `idl:"name:cMaxBytes" json:"max_bytes_count"`
	// ulExtendedOp:  0 or an extended operation request code (section 4.1.10.2.22).
	ExtendedOperation uint32 `idl:"name:ulExtendedOp" json:"extended_operation"`
	// liFsmoInfo:  0 or a value specific to the requested extended operation.
	FSMOInfo *dtyp.UlargeInteger `idl:"name:liFsmoInfo" json:"fsmo_info"`
	// pPartialAttrSet:  A set of one or more attributes whose values are to be replicated
	// to the client's partial replica, or null if the client has a full replica.
	PartialAttributeSet *PartialAttributeVectorV1Ext `idl:"name:pPartialAttrSet;pointer:unique" json:"partial_attribute_set"`
	// pPartialAttrSetEx:  A set of one or more attributes whose values are to be added
	// to the client's existing partial replica, or null.
	PartialAttributeSetEx *PartialAttributeVectorV1Ext `idl:"name:pPartialAttrSetEx;pointer:unique" json:"partial_attribute_set_ex"`
	// PrefixTableDest:  Prefix table with which to convert the ATTRTYP values in pPartialAttrSet
	// and pPartialAttrSetEx to OIDs.
	PrefixTableDestination *SchemaPrefixTable `idl:"name:PrefixTableDest" json:"prefix_table_destination"`
	// ulMoreFlags:  A DRS_MORE_GETCHGREQ_OPTIONS bit field.
	MoreFlags uint32 `idl:"name:ulMoreFlags" json:"more_flags"`
}

func (o *MessageGetNCChangesRequestV10) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetNCChangesRequestV10) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if o.DSAObjectDestination != nil {
		if err := o.DSAObjectDestination.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.InvocationIDSource != nil {
		if err := o.InvocationIDSource.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.NC != nil {
		_ptr_pNC := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.NC != nil {
				if err := o.NC.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSName{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.NC, _ptr_pNC); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.From != nil {
		if err := o.From.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&Vector{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.UpToDateVectorDestination != nil {
		_ptr_pUpToDateVecDest := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.UpToDateVectorDestination != nil {
				if err := o.UpToDateVectorDestination.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&UpToDateVectorV1Ext{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.UpToDateVectorDestination, _ptr_pUpToDateVecDest); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxObjectsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxBytesCount); err != nil {
		return err
	}
	if err := w.WriteData(o.ExtendedOperation); err != nil {
		return err
	}
	if o.FSMOInfo != nil {
		if err := o.FSMOInfo.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UlargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.PartialAttributeSet != nil {
		_ptr_pPartialAttrSet := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.PartialAttributeSet != nil {
				if err := o.PartialAttributeSet.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&PartialAttributeVectorV1Ext{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.PartialAttributeSet, _ptr_pPartialAttrSet); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.PartialAttributeSetEx != nil {
		_ptr_pPartialAttrSetEx := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.PartialAttributeSetEx != nil {
				if err := o.PartialAttributeSetEx.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&PartialAttributeVectorV1Ext{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.PartialAttributeSetEx, _ptr_pPartialAttrSetEx); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.PrefixTableDestination != nil {
		if err := o.PrefixTableDestination.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&SchemaPrefixTable{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.MoreFlags); err != nil {
		return err
	}
	return nil
}
func (o *MessageGetNCChangesRequestV10) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if o.DSAObjectDestination == nil {
		o.DSAObjectDestination = &dtyp.UUID{}
	}
	if err := o.DSAObjectDestination.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.InvocationIDSource == nil {
		o.InvocationIDSource = &dtyp.UUID{}
	}
	if err := o.InvocationIDSource.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_pNC := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.NC == nil {
			o.NC = &DSName{}
		}
		if err := o.NC.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pNC := func(ptr interface{}) { o.NC = *ptr.(**DSName) }
	if err := w.ReadPointer(&o.NC, _s_pNC, _ptr_pNC); err != nil {
		return err
	}
	if o.From == nil {
		o.From = &Vector{}
	}
	if err := o.From.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_pUpToDateVecDest := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.UpToDateVectorDestination == nil {
			o.UpToDateVectorDestination = &UpToDateVectorV1Ext{}
		}
		if err := o.UpToDateVectorDestination.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pUpToDateVecDest := func(ptr interface{}) { o.UpToDateVectorDestination = *ptr.(**UpToDateVectorV1Ext) }
	if err := w.ReadPointer(&o.UpToDateVectorDestination, _s_pUpToDateVecDest, _ptr_pUpToDateVecDest); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxObjectsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxBytesCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.ExtendedOperation); err != nil {
		return err
	}
	if o.FSMOInfo == nil {
		o.FSMOInfo = &dtyp.UlargeInteger{}
	}
	if err := o.FSMOInfo.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_pPartialAttrSet := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.PartialAttributeSet == nil {
			o.PartialAttributeSet = &PartialAttributeVectorV1Ext{}
		}
		if err := o.PartialAttributeSet.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pPartialAttrSet := func(ptr interface{}) { o.PartialAttributeSet = *ptr.(**PartialAttributeVectorV1Ext) }
	if err := w.ReadPointer(&o.PartialAttributeSet, _s_pPartialAttrSet, _ptr_pPartialAttrSet); err != nil {
		return err
	}
	_ptr_pPartialAttrSetEx := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.PartialAttributeSetEx == nil {
			o.PartialAttributeSetEx = &PartialAttributeVectorV1Ext{}
		}
		if err := o.PartialAttributeSetEx.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pPartialAttrSetEx := func(ptr interface{}) { o.PartialAttributeSetEx = *ptr.(**PartialAttributeVectorV1Ext) }
	if err := w.ReadPointer(&o.PartialAttributeSetEx, _s_pPartialAttrSetEx, _ptr_pPartialAttrSetEx); err != nil {
		return err
	}
	if o.PrefixTableDestination == nil {
		o.PrefixTableDestination = &SchemaPrefixTable{}
	}
	if err := o.PrefixTableDestination.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.MoreFlags); err != nil {
		return err
	}
	return nil
}

// VarSizeBufferWithVersion structure represents VAR_SIZE_BUFFER_WITH_VERSION RPC structure.
type VarSizeBufferWithVersion struct {
	Version      uint32 `idl:"name:ulVersion" json:"version"`
	BufferLength uint32 `idl:"name:cbByteBuffer" json:"buffer_length"`
	Padding      uint64 `idl:"name:ullPadding" json:"padding"`
	Buffer       []byte `idl:"name:rgbBuffer;size_is:(cbByteBuffer)" json:"buffer"`
}

func (o *VarSizeBufferWithVersion) xxx_PreparePayload(ctx context.Context) error {
	if o.Buffer != nil && o.BufferLength == 0 {
		o.BufferLength = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *VarSizeBufferWithVersion) NDRSizeInfo() []uint64 {
	dimSize1 := uint64(o.BufferLength)
	return []uint64{
		dimSize1,
	}
}
func (o *VarSizeBufferWithVersion) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for sz1 := range sizeInfo {
			if err := w.WriteSize(sizeInfo[sz1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if err := w.WriteData(o.Version); err != nil {
		return err
	}
	if err := w.WriteData(o.BufferLength); err != nil {
		return err
	}
	if err := w.WriteData(o.Padding); err != nil {
		return err
	}
	for i1 := range o.Buffer {
		i1 := i1
		if uint64(i1) >= sizeInfo[0] {
			break
		}
		if err := w.WriteData(o.Buffer[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	return nil
}
func (o *VarSizeBufferWithVersion) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for i1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[i1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if err := w.ReadData(&o.Version); err != nil {
		return err
	}
	if err := w.ReadData(&o.BufferLength); err != nil {
		return err
	}
	if err := w.ReadData(&o.Padding); err != nil {
		return err
	}
	// XXX: for opaque unmarshaling
	if o.BufferLength > 0 && sizeInfo[0] == 0 {
		sizeInfo[0] = uint64(o.BufferLength)
	}
	if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
		return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
	}
	o.Buffer = make([]byte, sizeInfo[0])
	for i1 := range o.Buffer {
		i1 := i1
		if err := w.ReadData(&o.Buffer[i1]); err != nil {
			return err
		}
	}
	return nil
}

// MessageGetNCChangesRequestV11 structure represents DRS_MSG_GETCHGREQ_V11 RPC structure.
type MessageGetNCChangesRequestV11 struct {
	DSAObjectDestination      *dtyp.UUID                   `idl:"name:uuidDsaObjDest" json:"dsa_object_destination"`
	InvocationIDSource        *dtyp.UUID                   `idl:"name:uuidInvocIdSrc" json:"invocation_id_source"`
	NC                        *DSName                      `idl:"name:pNC;pointer:ref" json:"nc"`
	From                      *Vector                      `idl:"name:usnvecFrom" json:"from"`
	UpToDateVectorDestination *UpToDateVectorV1Ext         `idl:"name:pUpToDateVecDest;pointer:unique" json:"up_to_date_vector_destination"`
	Flags                     uint32                       `idl:"name:ulFlags" json:"flags"`
	MaxObjectsCount           uint32                       `idl:"name:cMaxObjects" json:"max_objects_count"`
	MaxBytesCount             uint32                       `idl:"name:cMaxBytes" json:"max_bytes_count"`
	ExtendedOperation         uint32                       `idl:"name:ulExtendedOp" json:"extended_operation"`
	FSMOInfo                  *dtyp.UlargeInteger          `idl:"name:liFsmoInfo" json:"fsmo_info"`
	PartialAttributeSet       *PartialAttributeVectorV1Ext `idl:"name:pPartialAttrSet;pointer:unique" json:"partial_attribute_set"`
	PartialAttributeSetEx     *PartialAttributeVectorV1Ext `idl:"name:pPartialAttrSetEx;pointer:unique" json:"partial_attribute_set_ex"`
	PrefixTableDestination    *SchemaPrefixTable           `idl:"name:PrefixTableDest" json:"prefix_table_destination"`
	MoreFlags                 uint32                       `idl:"name:ulMoreFlags" json:"more_flags"`
	CorrelationID             *dtyp.GUID                   `idl:"name:correlationID" json:"correlation_id"`
	ReservedBuffer            *VarSizeBufferWithVersion    `idl:"name:pReservedBuffer;pointer:unique" json:"reserved_buffer"`
}

func (o *MessageGetNCChangesRequestV11) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetNCChangesRequestV11) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if o.DSAObjectDestination != nil {
		if err := o.DSAObjectDestination.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.InvocationIDSource != nil {
		if err := o.InvocationIDSource.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.NC != nil {
		_ptr_pNC := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.NC != nil {
				if err := o.NC.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSName{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.NC, _ptr_pNC); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.From != nil {
		if err := o.From.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&Vector{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.UpToDateVectorDestination != nil {
		_ptr_pUpToDateVecDest := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.UpToDateVectorDestination != nil {
				if err := o.UpToDateVectorDestination.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&UpToDateVectorV1Ext{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.UpToDateVectorDestination, _ptr_pUpToDateVecDest); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxObjectsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxBytesCount); err != nil {
		return err
	}
	if err := w.WriteData(o.ExtendedOperation); err != nil {
		return err
	}
	if o.FSMOInfo != nil {
		if err := o.FSMOInfo.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UlargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.PartialAttributeSet != nil {
		_ptr_pPartialAttrSet := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.PartialAttributeSet != nil {
				if err := o.PartialAttributeSet.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&PartialAttributeVectorV1Ext{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.PartialAttributeSet, _ptr_pPartialAttrSet); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.PartialAttributeSetEx != nil {
		_ptr_pPartialAttrSetEx := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.PartialAttributeSetEx != nil {
				if err := o.PartialAttributeSetEx.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&PartialAttributeVectorV1Ext{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.PartialAttributeSetEx, _ptr_pPartialAttrSetEx); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.PrefixTableDestination != nil {
		if err := o.PrefixTableDestination.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&SchemaPrefixTable{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.MoreFlags); err != nil {
		return err
	}
	if o.CorrelationID != nil {
		if err := o.CorrelationID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.ReservedBuffer != nil {
		_ptr_pReservedBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ReservedBuffer != nil {
				if err := o.ReservedBuffer.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&VarSizeBufferWithVersion{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ReservedBuffer, _ptr_pReservedBuffer); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetNCChangesRequestV11) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if o.DSAObjectDestination == nil {
		o.DSAObjectDestination = &dtyp.UUID{}
	}
	if err := o.DSAObjectDestination.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.InvocationIDSource == nil {
		o.InvocationIDSource = &dtyp.UUID{}
	}
	if err := o.InvocationIDSource.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_pNC := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.NC == nil {
			o.NC = &DSName{}
		}
		if err := o.NC.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pNC := func(ptr interface{}) { o.NC = *ptr.(**DSName) }
	if err := w.ReadPointer(&o.NC, _s_pNC, _ptr_pNC); err != nil {
		return err
	}
	if o.From == nil {
		o.From = &Vector{}
	}
	if err := o.From.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_pUpToDateVecDest := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.UpToDateVectorDestination == nil {
			o.UpToDateVectorDestination = &UpToDateVectorV1Ext{}
		}
		if err := o.UpToDateVectorDestination.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pUpToDateVecDest := func(ptr interface{}) { o.UpToDateVectorDestination = *ptr.(**UpToDateVectorV1Ext) }
	if err := w.ReadPointer(&o.UpToDateVectorDestination, _s_pUpToDateVecDest, _ptr_pUpToDateVecDest); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxObjectsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxBytesCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.ExtendedOperation); err != nil {
		return err
	}
	if o.FSMOInfo == nil {
		o.FSMOInfo = &dtyp.UlargeInteger{}
	}
	if err := o.FSMOInfo.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_pPartialAttrSet := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.PartialAttributeSet == nil {
			o.PartialAttributeSet = &PartialAttributeVectorV1Ext{}
		}
		if err := o.PartialAttributeSet.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pPartialAttrSet := func(ptr interface{}) { o.PartialAttributeSet = *ptr.(**PartialAttributeVectorV1Ext) }
	if err := w.ReadPointer(&o.PartialAttributeSet, _s_pPartialAttrSet, _ptr_pPartialAttrSet); err != nil {
		return err
	}
	_ptr_pPartialAttrSetEx := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.PartialAttributeSetEx == nil {
			o.PartialAttributeSetEx = &PartialAttributeVectorV1Ext{}
		}
		if err := o.PartialAttributeSetEx.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pPartialAttrSetEx := func(ptr interface{}) { o.PartialAttributeSetEx = *ptr.(**PartialAttributeVectorV1Ext) }
	if err := w.ReadPointer(&o.PartialAttributeSetEx, _s_pPartialAttrSetEx, _ptr_pPartialAttrSetEx); err != nil {
		return err
	}
	if o.PrefixTableDestination == nil {
		o.PrefixTableDestination = &SchemaPrefixTable{}
	}
	if err := o.PrefixTableDestination.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.MoreFlags); err != nil {
		return err
	}
	if o.CorrelationID == nil {
		o.CorrelationID = &dtyp.GUID{}
	}
	if err := o.CorrelationID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_pReservedBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ReservedBuffer == nil {
			o.ReservedBuffer = &VarSizeBufferWithVersion{}
		}
		if err := o.ReservedBuffer.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pReservedBuffer := func(ptr interface{}) { o.ReservedBuffer = *ptr.(**VarSizeBufferWithVersion) }
	if err := w.ReadPointer(&o.ReservedBuffer, _s_pReservedBuffer, _ptr_pReservedBuffer); err != nil {
		return err
	}
	return nil
}

// MessageGetNCChangesRequest structure represents DRS_MSG_GETCHGREQ RPC union.
//
// The DRS_MSG_GETCHGREQ union defines request messages that are sent to the IDL_DRSGetNCChanges
// method. There are no V1, V2, V3, V6, or V9 messages.
type MessageGetNCChangesRequest struct {
	// Types that are assignable to Value
	//
	// *MessageGetNCChangesRequest_V4
	// *MessageGetNCChangesRequest_V5
	// *MessageGetNCChangesRequest_V7
	// *MessageGetNCChangesRequest_V8
	// *MessageGetNCChangesRequest_V10
	// *MessageGetNCChangesRequest_V11
	Value is_MessageGetNCChangesRequest `json:"value"`
}

func (o *MessageGetNCChangesRequest) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageGetNCChangesRequest_V4:
		if value != nil {
			return value.V4
		}
	case *MessageGetNCChangesRequest_V5:
		if value != nil {
			return value.V5
		}
	case *MessageGetNCChangesRequest_V7:
		if value != nil {
			return value.V7
		}
	case *MessageGetNCChangesRequest_V8:
		if value != nil {
			return value.V8
		}
	case *MessageGetNCChangesRequest_V10:
		if value != nil {
			return value.V10
		}
	case *MessageGetNCChangesRequest_V11:
		if value != nil {
			return value.V11
		}
	}
	return nil
}

type is_MessageGetNCChangesRequest interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageGetNCChangesRequest()
}

func (o *MessageGetNCChangesRequest) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageGetNCChangesRequest_V4:
		return uint32(4)
	case *MessageGetNCChangesRequest_V5:
		return uint32(5)
	case *MessageGetNCChangesRequest_V7:
		return uint32(7)
	case *MessageGetNCChangesRequest_V8:
		return uint32(8)
	case *MessageGetNCChangesRequest_V10:
		return uint32(10)
	case *MessageGetNCChangesRequest_V11:
		return uint32(11)
	}
	return uint32(0)
}

func (o *MessageGetNCChangesRequest) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(8); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(8); err != nil {
		return err
	}
	switch sw {
	case uint32(4):
		_o, _ := o.Value.(*MessageGetNCChangesRequest_V4)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageGetNCChangesRequest_V4{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(5):
		_o, _ := o.Value.(*MessageGetNCChangesRequest_V5)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageGetNCChangesRequest_V5{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(7):
		_o, _ := o.Value.(*MessageGetNCChangesRequest_V7)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageGetNCChangesRequest_V7{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(8):
		_o, _ := o.Value.(*MessageGetNCChangesRequest_V8)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageGetNCChangesRequest_V8{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(10):
		_o, _ := o.Value.(*MessageGetNCChangesRequest_V10)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageGetNCChangesRequest_V10{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(11):
		_o, _ := o.Value.(*MessageGetNCChangesRequest_V11)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageGetNCChangesRequest_V11{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageGetNCChangesRequest) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(8); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(8); err != nil {
		return err
	}
	switch sw {
	case uint32(4):
		o.Value = &MessageGetNCChangesRequest_V4{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(5):
		o.Value = &MessageGetNCChangesRequest_V5{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(7):
		o.Value = &MessageGetNCChangesRequest_V7{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(8):
		o.Value = &MessageGetNCChangesRequest_V8{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(10):
		o.Value = &MessageGetNCChangesRequest_V10{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(11):
		o.Value = &MessageGetNCChangesRequest_V11{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageGetNCChangesRequest_V4 structure represents DRS_MSG_GETCHGREQ RPC union arm.
//
// It has following labels: 4
type MessageGetNCChangesRequest_V4 struct {
	// V4:  Version 4 request (Windows 2000 operating system SMTP replication [MS-SRPL]).
	V4 *MessageGetNCChangesRequestV4 `idl:"name:V4" json:"v4"`
}

func (*MessageGetNCChangesRequest_V4) is_MessageGetNCChangesRequest() {}

func (o *MessageGetNCChangesRequest_V4) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V4 != nil {
		if err := o.V4.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageGetNCChangesRequestV4{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetNCChangesRequest_V4) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V4 == nil {
		o.V4 = &MessageGetNCChangesRequestV4{}
	}
	if err := o.V4.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageGetNCChangesRequest_V5 structure represents DRS_MSG_GETCHGREQ RPC union arm.
//
// It has following labels: 5
type MessageGetNCChangesRequest_V5 struct {
	// V5:  Version 5 request (Windows 2000 RPC replication).
	V5 *MessageGetNCChangesRequestV5 `idl:"name:V5" json:"v5"`
}

func (*MessageGetNCChangesRequest_V5) is_MessageGetNCChangesRequest() {}

func (o *MessageGetNCChangesRequest_V5) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V5 != nil {
		if err := o.V5.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageGetNCChangesRequestV5{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetNCChangesRequest_V5) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V5 == nil {
		o.V5 = &MessageGetNCChangesRequestV5{}
	}
	if err := o.V5.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageGetNCChangesRequest_V7 structure represents DRS_MSG_GETCHGREQ RPC union arm.
//
// It has following labels: 7
type MessageGetNCChangesRequest_V7 struct {
	// V7:  Version 7 request (Windows Server 2003 operating system SMTP replication [MS-SRPL]).
	V7 *MessageGetNCChangesRequestV7 `idl:"name:V7" json:"v7"`
}

func (*MessageGetNCChangesRequest_V7) is_MessageGetNCChangesRequest() {}

func (o *MessageGetNCChangesRequest_V7) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V7 != nil {
		if err := o.V7.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageGetNCChangesRequestV7{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetNCChangesRequest_V7) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V7 == nil {
		o.V7 = &MessageGetNCChangesRequestV7{}
	}
	if err := o.V7.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageGetNCChangesRequest_V8 structure represents DRS_MSG_GETCHGREQ RPC union arm.
//
// It has following labels: 8
type MessageGetNCChangesRequest_V8 struct {
	// V8:  Version 8 request (Windows Server 2003 RPC replication).
	V8 *MessageGetNCChangesRequestV8 `idl:"name:V8" json:"v8"`
}

func (*MessageGetNCChangesRequest_V8) is_MessageGetNCChangesRequest() {}

func (o *MessageGetNCChangesRequest_V8) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V8 != nil {
		if err := o.V8.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageGetNCChangesRequestV8{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetNCChangesRequest_V8) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V8 == nil {
		o.V8 = &MessageGetNCChangesRequestV8{}
	}
	if err := o.V8.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageGetNCChangesRequest_V10 structure represents DRS_MSG_GETCHGREQ RPC union arm.
//
// It has following labels: 10
type MessageGetNCChangesRequest_V10 struct {
	// V10:  Version 10 request (Windows Server 2008 R2 operating system RPC replication).
	V10 *MessageGetNCChangesRequestV10 `idl:"name:V10" json:"v10"`
}

func (*MessageGetNCChangesRequest_V10) is_MessageGetNCChangesRequest() {}

func (o *MessageGetNCChangesRequest_V10) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V10 != nil {
		if err := o.V10.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageGetNCChangesRequestV10{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetNCChangesRequest_V10) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V10 == nil {
		o.V10 = &MessageGetNCChangesRequestV10{}
	}
	if err := o.V10.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageGetNCChangesRequest_V11 structure represents DRS_MSG_GETCHGREQ RPC union arm.
//
// It has following labels: 11
type MessageGetNCChangesRequest_V11 struct {
	// V11:  Version 11 request (Windows Server v1803 operating system RPC replication).
	V11 *MessageGetNCChangesRequestV11 `idl:"name:V11" json:"v11"`
}

func (*MessageGetNCChangesRequest_V11) is_MessageGetNCChangesRequest() {}

func (o *MessageGetNCChangesRequest_V11) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V11 != nil {
		if err := o.V11.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageGetNCChangesRequestV11{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetNCChangesRequest_V11) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V11 == nil {
		o.V11 = &MessageGetNCChangesRequestV11{}
	}
	if err := o.V11.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageGetNCChangesReplyV2 structure represents DRS_MSG_GETCHGREPLY_V2 RPC structure.
//
// The DRS_MSG_GETCHGREPLY_V2 structure defines the compressed DRS_MSG_GETCHGREPLY_V1
// message received from the IDL_DRSGetNCChanges method.
type MessageGetNCChangesReplyV2 struct {
	// CompressedV1:  Compressed DRS_MSG_GETCHGREPLY_V1 response.
	CompressedV1 *CompressedBlob `idl:"name:CompressedV1" json:"compressed_v1"`
}

func (o *MessageGetNCChangesReplyV2) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetNCChangesReplyV2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.CompressedV1 != nil {
		if err := o.CompressedV1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&CompressedBlob{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetNCChangesReplyV2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if o.CompressedV1 == nil {
		o.CompressedV1 = &CompressedBlob{}
	}
	if err := o.CompressedV1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// CompAlgorithmType type represents DRS_COMP_ALG_TYPE RPC enumeration.
//
// The DRS_COMP_ALG_TYPE enumeration is a concrete type for identifying a compression
// algorithm.
type CompAlgorithmType uint16

var (
	// DRS_COMP_ALG_NONE:  No compression.
	CompressionAlgorithmTypeNone CompAlgorithmType = 0
	// DRS_COMP_ALG_UNUSED:  Unused. MUST not be used.
	CompressionAlgorithmTypeUnused CompAlgorithmType = 1
	// DRS_COMP_ALG_MSZIP:  MSZIP algorithm.
	CompressionAlgorithmTypeMSZIP CompAlgorithmType = 2
	// DRS_COMP_ALG_WIN2K3:  Windows Server 2003 operating system compression.
	CompressionAlgorithmTypeWIN2K3 CompAlgorithmType = 3
)

func (o CompAlgorithmType) String() string {
	switch o {
	case CompressionAlgorithmTypeNone:
		return "CompressionAlgorithmTypeNone"
	case CompressionAlgorithmTypeUnused:
		return "CompressionAlgorithmTypeUnused"
	case CompressionAlgorithmTypeMSZIP:
		return "CompressionAlgorithmTypeMSZIP"
	case CompressionAlgorithmTypeWIN2K3:
		return "CompressionAlgorithmTypeWIN2K3"
	}
	return "Invalid"
}

// MessageGetNCChangesReplyV7 structure represents DRS_MSG_GETCHGREPLY_V7 RPC structure.
//
// The DRS_MSG_GETCHGREPLY_V7 structure defines a compressed DRS_MSG_GETCHGREPLY_V6
// or DRS_MSG_GETCHGREPLY_V9 message received from the IDL_DRSGetNCChanges method.
type MessageGetNCChangesReplyV7 struct {
	// dwCompressedVersion:  Version of the response in CompressedAny; MUST be set to 6
	// or 9.
	CompressedVersion uint32 `idl:"name:dwCompressedVersion" json:"compressed_version"`
	// CompressionAlg:  Algorithm used to compress the response.
	CompressionAlgorithm CompAlgorithmType `idl:"name:CompressionAlg" json:"compression_algorithm"`
	// CompressedAny:  Compressed DRS_MSG_GETCHGREPLY_V6 or DRS_MSG_GETCHGREPLY_V9 response.
	CompressedAny *CompressedBlob `idl:"name:CompressedAny" json:"compressed_any"`
}

func (o *MessageGetNCChangesReplyV7) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetNCChangesReplyV7) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.CompressedVersion); err != nil {
		return err
	}
	if err := w.WriteEnum(uint16(o.CompressionAlgorithm)); err != nil {
		return err
	}
	if o.CompressedAny != nil {
		if err := o.CompressedAny.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&CompressedBlob{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetNCChangesReplyV7) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.CompressedVersion); err != nil {
		return err
	}
	if err := w.ReadEnum((*uint16)(&o.CompressionAlgorithm)); err != nil {
		return err
	}
	if o.CompressedAny == nil {
		o.CompressedAny = &CompressedBlob{}
	}
	if err := o.CompressedAny.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageGetNCChangesReply structure represents DRS_MSG_GETCHGREPLY RPC union.
//
// The DRS_MSG_GETCHGREPLY union defines the response messages received from the IDL_DRSGetNCChanges
// method. There are no V3, V4, V5, or V8 messages.
type MessageGetNCChangesReply struct {
	// Types that are assignable to Value
	//
	// *MessageGetNCChangesReply_V1
	// *MessageGetNCChangesReply_V2
	// *MessageGetNCChangesReply_V6
	// *MessageGetNCChangesReply_V7
	// *MessageGetNCChangesReply_V9
	Value is_MessageGetNCChangesReply `json:"value"`
}

func (o *MessageGetNCChangesReply) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageGetNCChangesReply_V1:
		if value != nil {
			return value.V1
		}
	case *MessageGetNCChangesReply_V2:
		if value != nil {
			return value.V2
		}
	case *MessageGetNCChangesReply_V6:
		if value != nil {
			return value.V6
		}
	case *MessageGetNCChangesReply_V7:
		if value != nil {
			return value.V7
		}
	case *MessageGetNCChangesReply_V9:
		if value != nil {
			return value.V9
		}
	}
	return nil
}

type is_MessageGetNCChangesReply interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageGetNCChangesReply()
}

func (o *MessageGetNCChangesReply) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageGetNCChangesReply_V1:
		return uint32(1)
	case *MessageGetNCChangesReply_V2:
		return uint32(2)
	case *MessageGetNCChangesReply_V6:
		return uint32(6)
	case *MessageGetNCChangesReply_V7:
		return uint32(7)
	case *MessageGetNCChangesReply_V9:
		return uint32(9)
	}
	return uint32(0)
}

func (o *MessageGetNCChangesReply) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(8); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(8); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageGetNCChangesReply_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageGetNCChangesReply_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(2):
		_o, _ := o.Value.(*MessageGetNCChangesReply_V2)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageGetNCChangesReply_V2{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(6):
		_o, _ := o.Value.(*MessageGetNCChangesReply_V6)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageGetNCChangesReply_V6{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(7):
		_o, _ := o.Value.(*MessageGetNCChangesReply_V7)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageGetNCChangesReply_V7{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(9):
		_o, _ := o.Value.(*MessageGetNCChangesReply_V9)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageGetNCChangesReply_V9{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageGetNCChangesReply) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(8); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(8); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageGetNCChangesReply_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(2):
		o.Value = &MessageGetNCChangesReply_V2{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(6):
		o.Value = &MessageGetNCChangesReply_V6{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(7):
		o.Value = &MessageGetNCChangesReply_V7{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(9):
		o.Value = &MessageGetNCChangesReply_V9{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageGetNCChangesReply_V1 structure represents DRS_MSG_GETCHGREPLY RPC union arm.
//
// It has following labels: 1
type MessageGetNCChangesReply_V1 struct {
	// V1:  Version 1 response (Windows 2000 operating system).
	V1 *MessageGetNCChangesReplyV1 `idl:"name:V1" json:"v1"`
}

func (*MessageGetNCChangesReply_V1) is_MessageGetNCChangesReply() {}

func (o *MessageGetNCChangesReply_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageGetNCChangesReplyV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetNCChangesReply_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageGetNCChangesReplyV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageGetNCChangesReply_V2 structure represents DRS_MSG_GETCHGREPLY RPC union arm.
//
// It has following labels: 2
type MessageGetNCChangesReply_V2 struct {
	// V2:  Version 2 response (compressed V1).
	V2 *MessageGetNCChangesReplyV2 `idl:"name:V2" json:"v2"`
}

func (*MessageGetNCChangesReply_V2) is_MessageGetNCChangesReply() {}

func (o *MessageGetNCChangesReply_V2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V2 != nil {
		if err := o.V2.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageGetNCChangesReplyV2{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetNCChangesReply_V2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V2 == nil {
		o.V2 = &MessageGetNCChangesReplyV2{}
	}
	if err := o.V2.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageGetNCChangesReply_V6 structure represents DRS_MSG_GETCHGREPLY RPC union arm.
//
// It has following labels: 6
type MessageGetNCChangesReply_V6 struct {
	// V6:  Version 6 response (Windows Server 2003 operating system).
	V6 *MessageGetNCChangesReplyV6 `idl:"name:V6" json:"v6"`
}

func (*MessageGetNCChangesReply_V6) is_MessageGetNCChangesReply() {}

func (o *MessageGetNCChangesReply_V6) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V6 != nil {
		if err := o.V6.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageGetNCChangesReplyV6{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetNCChangesReply_V6) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V6 == nil {
		o.V6 = &MessageGetNCChangesReplyV6{}
	}
	if err := o.V6.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageGetNCChangesReply_V7 structure represents DRS_MSG_GETCHGREPLY RPC union arm.
//
// It has following labels: 7
type MessageGetNCChangesReply_V7 struct {
	// V7:  Version 7 response (compressed V6 or V9).
	V7 *MessageGetNCChangesReplyV7 `idl:"name:V7" json:"v7"`
}

func (*MessageGetNCChangesReply_V7) is_MessageGetNCChangesReply() {}

func (o *MessageGetNCChangesReply_V7) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V7 != nil {
		if err := o.V7.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageGetNCChangesReplyV7{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetNCChangesReply_V7) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V7 == nil {
		o.V7 = &MessageGetNCChangesReplyV7{}
	}
	if err := o.V7.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageGetNCChangesReply_V9 structure represents DRS_MSG_GETCHGREPLY RPC union arm.
//
// It has following labels: 9
type MessageGetNCChangesReply_V9 struct {
	// V9:  Version 9 response (V6 with additional link-value metadata).
	V9 *MessageGetNCChangesReplyV9 `idl:"name:V9" json:"v9"`
}

func (*MessageGetNCChangesReply_V9) is_MessageGetNCChangesReply() {}

func (o *MessageGetNCChangesReply_V9) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V9 != nil {
		if err := o.V9.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageGetNCChangesReplyV9{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetNCChangesReply_V9) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V9 == nil {
		o.V9 = &MessageGetNCChangesReplyV9{}
	}
	if err := o.V9.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageReplicaSyncV1 structure represents DRS_MSG_REPSYNC_V1 RPC structure.
//
// The DRS_MSG_REPSYNC_V1 structure defines a request message sent to the IDL_DRSReplicaSync
// method.
type MessageReplicaSyncV1 struct {
	// pNC:  A pointer to DSName of the root of an NC replica on the server.
	NC *DSName `idl:"name:pNC;pointer:ref" json:"nc"`
	// uuidDsaSrc:  The DSA GUID.
	DSASourceID *dtyp.UUID `idl:"name:uuidDsaSrc" json:"dsa_source_id"`
	// pszDsaSrc:  The transport-specific NetworkAddress of a DC.
	DSASource string `idl:"name:pszDsaSrc;string;pointer:unique" json:"dsa_source"`
	// ulOptions:  The DRS_OPTIONS flags.
	Options uint32 `idl:"name:ulOptions" json:"options"`
}

func (o *MessageReplicaSyncV1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageReplicaSyncV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.NC != nil {
		_ptr_pNC := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.NC != nil {
				if err := o.NC.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSName{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.NC, _ptr_pNC); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.DSASourceID != nil {
		if err := o.DSASourceID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.DSASource != "" {
		_ptr_pszDsaSrc := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteCharNString(ctx, w, o.DSASource); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.DSASource, _ptr_pszDsaSrc); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Options); err != nil {
		return err
	}
	return nil
}
func (o *MessageReplicaSyncV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_pNC := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.NC == nil {
			o.NC = &DSName{}
		}
		if err := o.NC.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pNC := func(ptr interface{}) { o.NC = *ptr.(**DSName) }
	if err := w.ReadPointer(&o.NC, _s_pNC, _ptr_pNC); err != nil {
		return err
	}
	if o.DSASourceID == nil {
		o.DSASourceID = &dtyp.UUID{}
	}
	if err := o.DSASourceID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_pszDsaSrc := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadCharNString(ctx, w, &o.DSASource); err != nil {
			return err
		}
		return nil
	})
	_s_pszDsaSrc := func(ptr interface{}) { o.DSASource = *ptr.(*string) }
	if err := w.ReadPointer(&o.DSASource, _s_pszDsaSrc, _ptr_pszDsaSrc); err != nil {
		return err
	}
	if err := w.ReadData(&o.Options); err != nil {
		return err
	}
	return nil
}

// MessageReplicaSyncV2 structure represents DRS_MSG_REPSYNC_V2 RPC structure.
type MessageReplicaSyncV2 struct {
	NC             *DSName                   `idl:"name:pNC;pointer:ref" json:"nc"`
	DSASourceID    *dtyp.UUID                `idl:"name:uuidDsaSrc" json:"dsa_source_id"`
	DSASource      string                    `idl:"name:pszDsaSrc;string;pointer:unique" json:"dsa_source"`
	Options        uint32                    `idl:"name:ulOptions" json:"options"`
	CorrelationID  *dtyp.GUID                `idl:"name:correlationID" json:"correlation_id"`
	ReservedBuffer *VarSizeBufferWithVersion `idl:"name:pReservedBuffer;pointer:unique" json:"reserved_buffer"`
}

func (o *MessageReplicaSyncV2) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageReplicaSyncV2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.NC != nil {
		_ptr_pNC := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.NC != nil {
				if err := o.NC.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSName{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.NC, _ptr_pNC); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.DSASourceID != nil {
		if err := o.DSASourceID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.DSASource != "" {
		_ptr_pszDsaSrc := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteCharNString(ctx, w, o.DSASource); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.DSASource, _ptr_pszDsaSrc); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Options); err != nil {
		return err
	}
	if o.CorrelationID != nil {
		if err := o.CorrelationID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.ReservedBuffer != nil {
		_ptr_pReservedBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ReservedBuffer != nil {
				if err := o.ReservedBuffer.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&VarSizeBufferWithVersion{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ReservedBuffer, _ptr_pReservedBuffer); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageReplicaSyncV2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_pNC := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.NC == nil {
			o.NC = &DSName{}
		}
		if err := o.NC.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pNC := func(ptr interface{}) { o.NC = *ptr.(**DSName) }
	if err := w.ReadPointer(&o.NC, _s_pNC, _ptr_pNC); err != nil {
		return err
	}
	if o.DSASourceID == nil {
		o.DSASourceID = &dtyp.UUID{}
	}
	if err := o.DSASourceID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_pszDsaSrc := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadCharNString(ctx, w, &o.DSASource); err != nil {
			return err
		}
		return nil
	})
	_s_pszDsaSrc := func(ptr interface{}) { o.DSASource = *ptr.(*string) }
	if err := w.ReadPointer(&o.DSASource, _s_pszDsaSrc, _ptr_pszDsaSrc); err != nil {
		return err
	}
	if err := w.ReadData(&o.Options); err != nil {
		return err
	}
	if o.CorrelationID == nil {
		o.CorrelationID = &dtyp.GUID{}
	}
	if err := o.CorrelationID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_pReservedBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ReservedBuffer == nil {
			o.ReservedBuffer = &VarSizeBufferWithVersion{}
		}
		if err := o.ReservedBuffer.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pReservedBuffer := func(ptr interface{}) { o.ReservedBuffer = *ptr.(**VarSizeBufferWithVersion) }
	if err := w.ReadPointer(&o.ReservedBuffer, _s_pReservedBuffer, _ptr_pReservedBuffer); err != nil {
		return err
	}
	return nil
}

// MessageReplicaSync structure represents DRS_MSG_REPSYNC RPC union.
//
// The DRS_MSG_REPSYNC union defines the request messages sent to the IDL_DRSReplicaSync
// method. Only one version, identified by dwVersion = 1, is currently defined.
type MessageReplicaSync struct {
	// Types that are assignable to Value
	//
	// *MessageReplicaSync_V1
	// *MessageReplicaSync_V2
	Value is_MessageReplicaSync `json:"value"`
}

func (o *MessageReplicaSync) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageReplicaSync_V1:
		if value != nil {
			return value.V1
		}
	case *MessageReplicaSync_V2:
		if value != nil {
			return value.V2
		}
	}
	return nil
}

type is_MessageReplicaSync interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageReplicaSync()
}

func (o *MessageReplicaSync) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageReplicaSync_V1:
		return uint32(1)
	case *MessageReplicaSync_V2:
		return uint32(2)
	}
	return uint32(0)
}

func (o *MessageReplicaSync) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageReplicaSync_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageReplicaSync_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(2):
		_o, _ := o.Value.(*MessageReplicaSync_V2)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageReplicaSync_V2{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageReplicaSync) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageReplicaSync_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(2):
		o.Value = &MessageReplicaSync_V2{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageReplicaSync_V1 structure represents DRS_MSG_REPSYNC RPC union arm.
//
// It has following labels: 1
type MessageReplicaSync_V1 struct {
	// V1:  The version 1 request.
	V1 *MessageReplicaSyncV1 `idl:"name:V1" json:"v1"`
}

func (*MessageReplicaSync_V1) is_MessageReplicaSync() {}

func (o *MessageReplicaSync_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageReplicaSyncV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageReplicaSync_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageReplicaSyncV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageReplicaSync_V2 structure represents DRS_MSG_REPSYNC RPC union arm.
//
// It has following labels: 2
type MessageReplicaSync_V2 struct {
	// V2:  The version 2 request.
	V2 *MessageReplicaSyncV2 `idl:"name:V2" json:"v2"`
}

func (*MessageReplicaSync_V2) is_MessageReplicaSync() {}

func (o *MessageReplicaSync_V2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V2 != nil {
		if err := o.V2.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageReplicaSyncV2{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageReplicaSync_V2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V2 == nil {
		o.V2 = &MessageReplicaSyncV2{}
	}
	if err := o.V2.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageUpdateReferencesV1 structure represents DRS_MSG_UPDREFS_V1 RPC structure.
//
// The DRS_MSG_UPDREFS_V1 structure defines a request message sent to the IDL_DRSUpdateRefs
// method.
type MessageUpdateReferencesV1 struct {
	// pNC:  A pointer to the DSNAME of the root of an NC replica on the server.
	NC *DSName `idl:"name:pNC;pointer:ref" json:"nc"`
	// pszDsaDest:  The transport-specific NetworkAddress of a DC.
	DSADestination string `idl:"name:pszDsaDest;string;pointer:ref" json:"dsa_destination"`
	// uuidDsaObjDest:  The DSA GUID.
	DSAObjectDestination *dtyp.UUID `idl:"name:uuidDsaObjDest" json:"dsa_object_destination"`
	// ulOptions:  The DRS_OPTIONS that control the update.
	Options uint32 `idl:"name:ulOptions" json:"options"`
}

func (o *MessageUpdateReferencesV1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageUpdateReferencesV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.NC != nil {
		_ptr_pNC := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.NC != nil {
				if err := o.NC.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSName{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.NC, _ptr_pNC); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.DSADestination != "" {
		_ptr_pszDsaDest := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteCharNString(ctx, w, o.DSADestination); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.DSADestination, _ptr_pszDsaDest); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.DSAObjectDestination != nil {
		if err := o.DSAObjectDestination.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Options); err != nil {
		return err
	}
	return nil
}
func (o *MessageUpdateReferencesV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_pNC := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.NC == nil {
			o.NC = &DSName{}
		}
		if err := o.NC.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pNC := func(ptr interface{}) { o.NC = *ptr.(**DSName) }
	if err := w.ReadPointer(&o.NC, _s_pNC, _ptr_pNC); err != nil {
		return err
	}
	_ptr_pszDsaDest := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadCharNString(ctx, w, &o.DSADestination); err != nil {
			return err
		}
		return nil
	})
	_s_pszDsaDest := func(ptr interface{}) { o.DSADestination = *ptr.(*string) }
	if err := w.ReadPointer(&o.DSADestination, _s_pszDsaDest, _ptr_pszDsaDest); err != nil {
		return err
	}
	if o.DSAObjectDestination == nil {
		o.DSAObjectDestination = &dtyp.UUID{}
	}
	if err := o.DSAObjectDestination.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.Options); err != nil {
		return err
	}
	return nil
}

// MessageUpdateReferencesV2 structure represents DRS_MSG_UPDREFS_V2 RPC structure.
type MessageUpdateReferencesV2 struct {
	NC                   *DSName                   `idl:"name:pNC;pointer:ref" json:"nc"`
	DSADestination       string                    `idl:"name:pszDsaDest;string;pointer:ref" json:"dsa_destination"`
	DSAObjectDestination *dtyp.UUID                `idl:"name:uuidDsaObjDest" json:"dsa_object_destination"`
	Options              uint32                    `idl:"name:ulOptions" json:"options"`
	CorrelationID        *dtyp.GUID                `idl:"name:correlationID" json:"correlation_id"`
	ReservedBuffer       *VarSizeBufferWithVersion `idl:"name:pReservedBuffer;pointer:unique" json:"reserved_buffer"`
}

func (o *MessageUpdateReferencesV2) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageUpdateReferencesV2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.NC != nil {
		_ptr_pNC := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.NC != nil {
				if err := o.NC.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSName{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.NC, _ptr_pNC); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.DSADestination != "" {
		_ptr_pszDsaDest := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteCharNString(ctx, w, o.DSADestination); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.DSADestination, _ptr_pszDsaDest); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.DSAObjectDestination != nil {
		if err := o.DSAObjectDestination.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Options); err != nil {
		return err
	}
	if o.CorrelationID != nil {
		if err := o.CorrelationID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.ReservedBuffer != nil {
		_ptr_pReservedBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ReservedBuffer != nil {
				if err := o.ReservedBuffer.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&VarSizeBufferWithVersion{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ReservedBuffer, _ptr_pReservedBuffer); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageUpdateReferencesV2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_pNC := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.NC == nil {
			o.NC = &DSName{}
		}
		if err := o.NC.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pNC := func(ptr interface{}) { o.NC = *ptr.(**DSName) }
	if err := w.ReadPointer(&o.NC, _s_pNC, _ptr_pNC); err != nil {
		return err
	}
	_ptr_pszDsaDest := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadCharNString(ctx, w, &o.DSADestination); err != nil {
			return err
		}
		return nil
	})
	_s_pszDsaDest := func(ptr interface{}) { o.DSADestination = *ptr.(*string) }
	if err := w.ReadPointer(&o.DSADestination, _s_pszDsaDest, _ptr_pszDsaDest); err != nil {
		return err
	}
	if o.DSAObjectDestination == nil {
		o.DSAObjectDestination = &dtyp.UUID{}
	}
	if err := o.DSAObjectDestination.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.Options); err != nil {
		return err
	}
	if o.CorrelationID == nil {
		o.CorrelationID = &dtyp.GUID{}
	}
	if err := o.CorrelationID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_pReservedBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ReservedBuffer == nil {
			o.ReservedBuffer = &VarSizeBufferWithVersion{}
		}
		if err := o.ReservedBuffer.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pReservedBuffer := func(ptr interface{}) { o.ReservedBuffer = *ptr.(**VarSizeBufferWithVersion) }
	if err := w.ReadPointer(&o.ReservedBuffer, _s_pReservedBuffer, _ptr_pReservedBuffer); err != nil {
		return err
	}
	return nil
}

// MessageUpdateReferences structure represents DRS_MSG_UPDREFS RPC union.
//
// The DRS_MSG_UPDREFS union defines the request message versions sent to the IDL_DRSUpdateRefs
// method. Only one version, identified by dwVersion = 1, is currently defined.
type MessageUpdateReferences struct {
	// Types that are assignable to Value
	//
	// *MessageUpdateReferences_V1
	// *MessageUpdateReferences_V2
	Value is_MessageUpdateReferences `json:"value"`
}

func (o *MessageUpdateReferences) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageUpdateReferences_V1:
		if value != nil {
			return value.V1
		}
	case *MessageUpdateReferences_V2:
		if value != nil {
			return value.V2
		}
	}
	return nil
}

type is_MessageUpdateReferences interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageUpdateReferences()
}

func (o *MessageUpdateReferences) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageUpdateReferences_V1:
		return uint32(1)
	case *MessageUpdateReferences_V2:
		return uint32(2)
	}
	return uint32(0)
}

func (o *MessageUpdateReferences) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageUpdateReferences_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageUpdateReferences_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(2):
		_o, _ := o.Value.(*MessageUpdateReferences_V2)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageUpdateReferences_V2{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageUpdateReferences) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageUpdateReferences_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(2):
		o.Value = &MessageUpdateReferences_V2{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageUpdateReferences_V1 structure represents DRS_MSG_UPDREFS RPC union arm.
//
// It has following labels: 1
type MessageUpdateReferences_V1 struct {
	// V1:  The version 1 request.
	V1 *MessageUpdateReferencesV1 `idl:"name:V1" json:"v1"`
}

func (*MessageUpdateReferences_V1) is_MessageUpdateReferences() {}

func (o *MessageUpdateReferences_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageUpdateReferencesV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageUpdateReferences_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageUpdateReferencesV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageUpdateReferences_V2 structure represents DRS_MSG_UPDREFS RPC union arm.
//
// It has following labels: 2
type MessageUpdateReferences_V2 struct {
	// V2:  The version 2 request.
	V2 *MessageUpdateReferencesV2 `idl:"name:V2" json:"v2"`
}

func (*MessageUpdateReferences_V2) is_MessageUpdateReferences() {}

func (o *MessageUpdateReferences_V2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V2 != nil {
		if err := o.V2.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageUpdateReferencesV2{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageUpdateReferences_V2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V2 == nil {
		o.V2 = &MessageUpdateReferencesV2{}
	}
	if err := o.V2.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageAddReplicaV1 structure represents DRS_MSG_REPADD_V1 RPC structure.
//
// The DRS_MSG_REPADD_V1 structure defines a request message sent to the IDL_DRSReplicaAdd
// method.
type MessageAddReplicaV1 struct {
	// pNC:  The NC root of the NC to replicate.
	NC *DSName `idl:"name:pNC;pointer:ref" json:"nc"`
	// pszDsaSrc:  The transport-specific NetworkAddress of the DC from which to replicate
	// updates.
	DSASource string `idl:"name:pszDsaSrc;string;pointer:ref" json:"dsa_source"`
	// rtSchedule:  The schedule used to perform periodic replication.
	Schedule *ReplicationTimes `idl:"name:rtSchedule" json:"schedule"`
	// ulOptions:  Zero or more DRS_OPTIONS flags.
	Options uint32 `idl:"name:ulOptions" json:"options"`
}

func (o *MessageAddReplicaV1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageAddReplicaV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.NC != nil {
		_ptr_pNC := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.NC != nil {
				if err := o.NC.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSName{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.NC, _ptr_pNC); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.DSASource != "" {
		_ptr_pszDsaSrc := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteCharNString(ctx, w, o.DSASource); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.DSASource, _ptr_pszDsaSrc); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.Schedule != nil {
		if err := o.Schedule.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ReplicationTimes{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Options); err != nil {
		return err
	}
	return nil
}
func (o *MessageAddReplicaV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_pNC := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.NC == nil {
			o.NC = &DSName{}
		}
		if err := o.NC.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pNC := func(ptr interface{}) { o.NC = *ptr.(**DSName) }
	if err := w.ReadPointer(&o.NC, _s_pNC, _ptr_pNC); err != nil {
		return err
	}
	_ptr_pszDsaSrc := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadCharNString(ctx, w, &o.DSASource); err != nil {
			return err
		}
		return nil
	})
	_s_pszDsaSrc := func(ptr interface{}) { o.DSASource = *ptr.(*string) }
	if err := w.ReadPointer(&o.DSASource, _s_pszDsaSrc, _ptr_pszDsaSrc); err != nil {
		return err
	}
	if o.Schedule == nil {
		o.Schedule = &ReplicationTimes{}
	}
	if err := o.Schedule.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.Options); err != nil {
		return err
	}
	return nil
}

// MessageAddReplicaV2 structure represents DRS_MSG_REPADD_V2 RPC structure.
//
// The DRS_MSG_REPADD_V2 structure defines a request message sent to the IDL_DRSReplicaAdd
// method. This request version is a superset of V1.
type MessageAddReplicaV2 struct {
	// pNC:  The NC root of the NC to replicate.
	NC *DSName `idl:"name:pNC;pointer:ref" json:"nc"`
	// pSourceDsaDN:  The nTDSDSA object for the DC from which to replicate changes.
	SourceDSADN *DSName `idl:"name:pSourceDsaDN;pointer:unique" json:"source_dsa_dn"`
	// pTransportDN:  The interSiteTransport object that identifies the network transport
	// over which replication is to be performed.
	TransportDN *DSName `idl:"name:pTransportDN;pointer:unique" json:"transport_dn"`
	// pszSourceDsaAddress:  The transport-specific NetworkAddress of the DC from which
	// to replicate updates.
	SourceDSAAddress string `idl:"name:pszSourceDsaAddress;string;pointer:ref" json:"source_dsa_address"`
	// rtSchedule:  The schedule used to perform periodic replication.
	Schedule *ReplicationTimes `idl:"name:rtSchedule" json:"schedule"`
	// ulOptions:  Zero or more DRS_OPTIONS flags.
	Options uint32 `idl:"name:ulOptions" json:"options"`
}

func (o *MessageAddReplicaV2) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageAddReplicaV2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.NC != nil {
		_ptr_pNC := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.NC != nil {
				if err := o.NC.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSName{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.NC, _ptr_pNC); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.SourceDSADN != nil {
		_ptr_pSourceDsaDN := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.SourceDSADN != nil {
				if err := o.SourceDSADN.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSName{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.SourceDSADN, _ptr_pSourceDsaDN); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.TransportDN != nil {
		_ptr_pTransportDN := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.TransportDN != nil {
				if err := o.TransportDN.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSName{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.TransportDN, _ptr_pTransportDN); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.SourceDSAAddress != "" {
		_ptr_pszSourceDsaAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteCharNString(ctx, w, o.SourceDSAAddress); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.SourceDSAAddress, _ptr_pszSourceDsaAddress); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.Schedule != nil {
		if err := o.Schedule.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ReplicationTimes{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Options); err != nil {
		return err
	}
	return nil
}
func (o *MessageAddReplicaV2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_pNC := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.NC == nil {
			o.NC = &DSName{}
		}
		if err := o.NC.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pNC := func(ptr interface{}) { o.NC = *ptr.(**DSName) }
	if err := w.ReadPointer(&o.NC, _s_pNC, _ptr_pNC); err != nil {
		return err
	}
	_ptr_pSourceDsaDN := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.SourceDSADN == nil {
			o.SourceDSADN = &DSName{}
		}
		if err := o.SourceDSADN.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pSourceDsaDN := func(ptr interface{}) { o.SourceDSADN = *ptr.(**DSName) }
	if err := w.ReadPointer(&o.SourceDSADN, _s_pSourceDsaDN, _ptr_pSourceDsaDN); err != nil {
		return err
	}
	_ptr_pTransportDN := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.TransportDN == nil {
			o.TransportDN = &DSName{}
		}
		if err := o.TransportDN.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pTransportDN := func(ptr interface{}) { o.TransportDN = *ptr.(**DSName) }
	if err := w.ReadPointer(&o.TransportDN, _s_pTransportDN, _ptr_pTransportDN); err != nil {
		return err
	}
	_ptr_pszSourceDsaAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadCharNString(ctx, w, &o.SourceDSAAddress); err != nil {
			return err
		}
		return nil
	})
	_s_pszSourceDsaAddress := func(ptr interface{}) { o.SourceDSAAddress = *ptr.(*string) }
	if err := w.ReadPointer(&o.SourceDSAAddress, _s_pszSourceDsaAddress, _ptr_pszSourceDsaAddress); err != nil {
		return err
	}
	if o.Schedule == nil {
		o.Schedule = &ReplicationTimes{}
	}
	if err := o.Schedule.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.Options); err != nil {
		return err
	}
	return nil
}

// MessageAddReplicaV3 structure represents DRS_MSG_REPADD_V3 RPC structure.
type MessageAddReplicaV3 struct {
	NC               *DSName                   `idl:"name:pNC;pointer:ref" json:"nc"`
	SourceDSADN      *DSName                   `idl:"name:pSourceDsaDN;pointer:unique" json:"source_dsa_dn"`
	TransportDN      *DSName                   `idl:"name:pTransportDN;pointer:unique" json:"transport_dn"`
	SourceDSAAddress string                    `idl:"name:pszSourceDsaAddress;string;pointer:ref" json:"source_dsa_address"`
	Schedule         *ReplicationTimes         `idl:"name:rtSchedule" json:"schedule"`
	Options          uint32                    `idl:"name:ulOptions" json:"options"`
	CorrelationID    *dtyp.GUID                `idl:"name:correlationID" json:"correlation_id"`
	ReservedBuffer   *VarSizeBufferWithVersion `idl:"name:pReservedBuffer;pointer:unique" json:"reserved_buffer"`
}

func (o *MessageAddReplicaV3) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageAddReplicaV3) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.NC != nil {
		_ptr_pNC := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.NC != nil {
				if err := o.NC.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSName{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.NC, _ptr_pNC); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.SourceDSADN != nil {
		_ptr_pSourceDsaDN := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.SourceDSADN != nil {
				if err := o.SourceDSADN.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSName{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.SourceDSADN, _ptr_pSourceDsaDN); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.TransportDN != nil {
		_ptr_pTransportDN := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.TransportDN != nil {
				if err := o.TransportDN.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSName{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.TransportDN, _ptr_pTransportDN); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.SourceDSAAddress != "" {
		_ptr_pszSourceDsaAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteCharNString(ctx, w, o.SourceDSAAddress); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.SourceDSAAddress, _ptr_pszSourceDsaAddress); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.Schedule != nil {
		if err := o.Schedule.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ReplicationTimes{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Options); err != nil {
		return err
	}
	if o.CorrelationID != nil {
		if err := o.CorrelationID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.ReservedBuffer != nil {
		_ptr_pReservedBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ReservedBuffer != nil {
				if err := o.ReservedBuffer.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&VarSizeBufferWithVersion{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ReservedBuffer, _ptr_pReservedBuffer); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageAddReplicaV3) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_pNC := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.NC == nil {
			o.NC = &DSName{}
		}
		if err := o.NC.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pNC := func(ptr interface{}) { o.NC = *ptr.(**DSName) }
	if err := w.ReadPointer(&o.NC, _s_pNC, _ptr_pNC); err != nil {
		return err
	}
	_ptr_pSourceDsaDN := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.SourceDSADN == nil {
			o.SourceDSADN = &DSName{}
		}
		if err := o.SourceDSADN.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pSourceDsaDN := func(ptr interface{}) { o.SourceDSADN = *ptr.(**DSName) }
	if err := w.ReadPointer(&o.SourceDSADN, _s_pSourceDsaDN, _ptr_pSourceDsaDN); err != nil {
		return err
	}
	_ptr_pTransportDN := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.TransportDN == nil {
			o.TransportDN = &DSName{}
		}
		if err := o.TransportDN.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pTransportDN := func(ptr interface{}) { o.TransportDN = *ptr.(**DSName) }
	if err := w.ReadPointer(&o.TransportDN, _s_pTransportDN, _ptr_pTransportDN); err != nil {
		return err
	}
	_ptr_pszSourceDsaAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadCharNString(ctx, w, &o.SourceDSAAddress); err != nil {
			return err
		}
		return nil
	})
	_s_pszSourceDsaAddress := func(ptr interface{}) { o.SourceDSAAddress = *ptr.(*string) }
	if err := w.ReadPointer(&o.SourceDSAAddress, _s_pszSourceDsaAddress, _ptr_pszSourceDsaAddress); err != nil {
		return err
	}
	if o.Schedule == nil {
		o.Schedule = &ReplicationTimes{}
	}
	if err := o.Schedule.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.Options); err != nil {
		return err
	}
	if o.CorrelationID == nil {
		o.CorrelationID = &dtyp.GUID{}
	}
	if err := o.CorrelationID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_pReservedBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ReservedBuffer == nil {
			o.ReservedBuffer = &VarSizeBufferWithVersion{}
		}
		if err := o.ReservedBuffer.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pReservedBuffer := func(ptr interface{}) { o.ReservedBuffer = *ptr.(**VarSizeBufferWithVersion) }
	if err := w.ReadPointer(&o.ReservedBuffer, _s_pReservedBuffer, _ptr_pReservedBuffer); err != nil {
		return err
	}
	return nil
}

// MessageAddReplica structure represents DRS_MSG_REPADD RPC union.
//
// The DRS_MSG_REPADD union defines request messages that are sent to the IDL_DRSReplicaAdd
// method.
type MessageAddReplica struct {
	// Types that are assignable to Value
	//
	// *MessageAddReplica_V1
	// *MessageAddReplica_V2
	// *MessageAddReplica_V3
	Value is_MessageAddReplica `json:"value"`
}

func (o *MessageAddReplica) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageAddReplica_V1:
		if value != nil {
			return value.V1
		}
	case *MessageAddReplica_V2:
		if value != nil {
			return value.V2
		}
	case *MessageAddReplica_V3:
		if value != nil {
			return value.V3
		}
	}
	return nil
}

type is_MessageAddReplica interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageAddReplica()
}

func (o *MessageAddReplica) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageAddReplica_V1:
		return uint32(1)
	case *MessageAddReplica_V2:
		return uint32(2)
	case *MessageAddReplica_V3:
		return uint32(3)
	}
	return uint32(0)
}

func (o *MessageAddReplica) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageAddReplica_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageAddReplica_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(2):
		_o, _ := o.Value.(*MessageAddReplica_V2)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageAddReplica_V2{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(3):
		_o, _ := o.Value.(*MessageAddReplica_V3)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageAddReplica_V3{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageAddReplica) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageAddReplica_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(2):
		o.Value = &MessageAddReplica_V2{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(3):
		o.Value = &MessageAddReplica_V3{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageAddReplica_V1 structure represents DRS_MSG_REPADD RPC union arm.
//
// It has following labels: 1
type MessageAddReplica_V1 struct {
	// V1:  The version 1 request.
	V1 *MessageAddReplicaV1 `idl:"name:V1" json:"v1"`
}

func (*MessageAddReplica_V1) is_MessageAddReplica() {}

func (o *MessageAddReplica_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageAddReplicaV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageAddReplica_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageAddReplicaV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageAddReplica_V2 structure represents DRS_MSG_REPADD RPC union arm.
//
// It has following labels: 2
type MessageAddReplica_V2 struct {
	// V2:  The version 2 request (a superset of V1).
	V2 *MessageAddReplicaV2 `idl:"name:V2" json:"v2"`
}

func (*MessageAddReplica_V2) is_MessageAddReplica() {}

func (o *MessageAddReplica_V2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V2 != nil {
		if err := o.V2.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageAddReplicaV2{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageAddReplica_V2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V2 == nil {
		o.V2 = &MessageAddReplicaV2{}
	}
	if err := o.V2.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageAddReplica_V3 structure represents DRS_MSG_REPADD RPC union arm.
//
// It has following labels: 3
type MessageAddReplica_V3 struct {
	// V3:  The version 3 request (a superset of V2).
	V3 *MessageAddReplicaV3 `idl:"name:V3" json:"v3"`
}

func (*MessageAddReplica_V3) is_MessageAddReplica() {}

func (o *MessageAddReplica_V3) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V3 != nil {
		if err := o.V3.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageAddReplicaV3{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageAddReplica_V3) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V3 == nil {
		o.V3 = &MessageAddReplicaV3{}
	}
	if err := o.V3.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageDeleteReplicaV1 structure represents DRS_MSG_REPDEL_V1 RPC structure.
//
// The DRS_MSG_REPDEL_V1 structure defines a request message sent to the IDL_DRSReplicaDel
// method.
type MessageDeleteReplicaV1 struct {
	// pNC:  A pointer to DSName of the root of an NC replica on the server.
	NC *DSName `idl:"name:pNC;pointer:ref" json:"nc"`
	// pszDsaSrc:  The transport-specific NetworkAddress of a DC.
	DSASource string `idl:"name:pszDsaSrc;string" json:"dsa_source"`
	// ulOptions:  The DRS_OPTIONS flags.
	Options uint32 `idl:"name:ulOptions" json:"options"`
}

func (o *MessageDeleteReplicaV1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageDeleteReplicaV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.NC != nil {
		_ptr_pNC := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.NC != nil {
				if err := o.NC.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSName{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.NC, _ptr_pNC); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.DSASource != "" {
		_ptr_pszDsaSrc := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteCharNString(ctx, w, o.DSASource); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.DSASource, _ptr_pszDsaSrc); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Options); err != nil {
		return err
	}
	return nil
}
func (o *MessageDeleteReplicaV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_pNC := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.NC == nil {
			o.NC = &DSName{}
		}
		if err := o.NC.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pNC := func(ptr interface{}) { o.NC = *ptr.(**DSName) }
	if err := w.ReadPointer(&o.NC, _s_pNC, _ptr_pNC); err != nil {
		return err
	}
	_ptr_pszDsaSrc := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadCharNString(ctx, w, &o.DSASource); err != nil {
			return err
		}
		return nil
	})
	_s_pszDsaSrc := func(ptr interface{}) { o.DSASource = *ptr.(*string) }
	if err := w.ReadPointer(&o.DSASource, _s_pszDsaSrc, _ptr_pszDsaSrc); err != nil {
		return err
	}
	if err := w.ReadData(&o.Options); err != nil {
		return err
	}
	return nil
}

// MessageDeleteReplica structure represents DRS_MSG_REPDEL RPC union.
//
// The DRS_MSG_REPDEL union defines the request messages sent to the IDL_DRSReplicaDel
// method. Only one version, identified by dwVersion = 1, is currently defined.
type MessageDeleteReplica struct {
	// Types that are assignable to Value
	//
	// *MessageDeleteReplica_V1
	Value is_MessageDeleteReplica `json:"value"`
}

func (o *MessageDeleteReplica) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageDeleteReplica_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_MessageDeleteReplica interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageDeleteReplica()
}

func (o *MessageDeleteReplica) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageDeleteReplica_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *MessageDeleteReplica) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageDeleteReplica_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageDeleteReplica_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageDeleteReplica) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageDeleteReplica_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageDeleteReplica_V1 structure represents DRS_MSG_REPDEL RPC union arm.
//
// It has following labels: 1
type MessageDeleteReplica_V1 struct {
	// V1:  The version 1 request.
	V1 *MessageDeleteReplicaV1 `idl:"name:V1" json:"v1"`
}

func (*MessageDeleteReplica_V1) is_MessageDeleteReplica() {}

func (o *MessageDeleteReplica_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageDeleteReplicaV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageDeleteReplica_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageDeleteReplicaV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageModifyReplicaV1 structure represents DRS_MSG_REPMOD_V1 RPC structure.
//
// The DRS_MSG_REPMOD_V1 structure defines a request message for the IDL_DRSReplicaModify
// method.
type MessageModifyReplicaV1 struct {
	// pNC:  A pointer to the DSName of the root of an NC replica on the server.
	NC *DSName `idl:"name:pNC;pointer:ref" json:"nc"`
	// uuidSourceDRA:  The DSA GUID.
	DRASourceID *dtyp.UUID `idl:"name:uuidSourceDRA" json:"dra_source_id"`
	// pszSourceDRA:  The transport-specific NetworkAddress of a DC.
	SourceDRA string `idl:"name:pszSourceDRA;string;pointer:unique" json:"source_dra"`
	// rtSchedule:  The periodic replication schedule.
	Schedule *ReplicationTimes `idl:"name:rtSchedule" json:"schedule"`
	// ulReplicaFlags:  The DRS_OPTIONS flags for the repsFrom value.
	ReplicaFlags uint32 `idl:"name:ulReplicaFlags" json:"replica_flags"`
	// ulModifyFields:  The fields to update(presented in little-endian byte order).
	//
	//	+---+---+---+---+---+-----+-----+-----+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 1 | 2 | 3 | 4 |  5  |  6  |  7  | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
	//	|   |   |   |   |   |     |     |     |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
	//	+---+---+---+---+---+-----+-----+-----+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	+---+---+---+---+---+-----+-----+-----+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| X | X | X | X | X | U S | U A | U F | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X |
	//	+---+---+---+---+---+-----+-----+-----+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//
	// X: Unused. MUST be zero and ignored.
	//
	// UF (DRS_UPDATE_FLAGS, 0x00000001): Updates the flags associated with the server.
	//
	// UA (DRS_UPDATE_ADDRESS, 0x00000002): Updates the transport-specific address associated
	// with the server.
	ModifyFields uint32 `idl:"name:ulModifyFields" json:"modify_fields"`
	// ulOptions:  The DRS_OPTIONS flags for execution of this method.
	Options uint32 `idl:"name:ulOptions" json:"options"`
}

func (o *MessageModifyReplicaV1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageModifyReplicaV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.NC != nil {
		_ptr_pNC := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.NC != nil {
				if err := o.NC.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSName{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.NC, _ptr_pNC); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.DRASourceID != nil {
		if err := o.DRASourceID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.SourceDRA != "" {
		_ptr_pszSourceDRA := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteCharNString(ctx, w, o.SourceDRA); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.SourceDRA, _ptr_pszSourceDRA); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.Schedule != nil {
		if err := o.Schedule.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ReplicationTimes{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.ReplicaFlags); err != nil {
		return err
	}
	if err := w.WriteData(o.ModifyFields); err != nil {
		return err
	}
	if err := w.WriteData(o.Options); err != nil {
		return err
	}
	return nil
}
func (o *MessageModifyReplicaV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_pNC := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.NC == nil {
			o.NC = &DSName{}
		}
		if err := o.NC.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pNC := func(ptr interface{}) { o.NC = *ptr.(**DSName) }
	if err := w.ReadPointer(&o.NC, _s_pNC, _ptr_pNC); err != nil {
		return err
	}
	if o.DRASourceID == nil {
		o.DRASourceID = &dtyp.UUID{}
	}
	if err := o.DRASourceID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_pszSourceDRA := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadCharNString(ctx, w, &o.SourceDRA); err != nil {
			return err
		}
		return nil
	})
	_s_pszSourceDRA := func(ptr interface{}) { o.SourceDRA = *ptr.(*string) }
	if err := w.ReadPointer(&o.SourceDRA, _s_pszSourceDRA, _ptr_pszSourceDRA); err != nil {
		return err
	}
	if o.Schedule == nil {
		o.Schedule = &ReplicationTimes{}
	}
	if err := o.Schedule.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.ReplicaFlags); err != nil {
		return err
	}
	if err := w.ReadData(&o.ModifyFields); err != nil {
		return err
	}
	if err := w.ReadData(&o.Options); err != nil {
		return err
	}
	return nil
}

// MessageModifyReplica structure represents DRS_MSG_REPMOD RPC union.
//
// The DRS_MSG_REPMOD union defines the request messages for the IDL_DRSReplicaModify
// method. Only one version, identified by dwVersion = 1, is currently defined.
type MessageModifyReplica struct {
	// Types that are assignable to Value
	//
	// *MessageModifyReplica_V1
	Value is_MessageModifyReplica `json:"value"`
}

func (o *MessageModifyReplica) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageModifyReplica_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_MessageModifyReplica interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageModifyReplica()
}

func (o *MessageModifyReplica) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageModifyReplica_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *MessageModifyReplica) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageModifyReplica_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageModifyReplica_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageModifyReplica) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageModifyReplica_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageModifyReplica_V1 structure represents DRS_MSG_REPMOD RPC union arm.
//
// It has following labels: 1
type MessageModifyReplica_V1 struct {
	// V1:  The version 1 request.
	V1 *MessageModifyReplicaV1 `idl:"name:V1" json:"v1"`
}

func (*MessageModifyReplica_V1) is_MessageModifyReplica() {}

func (o *MessageModifyReplica_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageModifyReplicaV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageModifyReplica_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageModifyReplicaV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageVerifyRequestV1 structure represents DRS_MSG_VERIFYREQ_V1 RPC structure.
//
// The DRS_MSG_VERIFYREQ_V1 structure defines a request message sent to the IDL_DRSVerifyNames
// method.
type MessageVerifyRequestV1 struct {
	// dwFlags:  The type of name to be verified; MUST have one of the following values:
	//
	//	+-----------------------------------------+----------------------------------------+
	//	|                                         |                                        |
	//	|                  VALUE                  |                MEANING                 |
	//	|                                         |                                        |
	//	+-----------------------------------------+----------------------------------------+
	//	+-----------------------------------------+----------------------------------------+
	//	| DRS_VERIFY_DSNAMES 0x00000000           | Verify DSName values.                  |
	//	+-----------------------------------------+----------------------------------------+
	//	| DRS_VERIFY_SIDS 0x00000001              | Verify objectSid values.               |
	//	+-----------------------------------------+----------------------------------------+
	//	| DRS_VERIFY_SAM_ACCOUNT_NAMES 0x00000002 | Verify sAMAccountName values.          |
	//	+-----------------------------------------+----------------------------------------+
	//	| DRS_VERIFY_FPOS 0x00000003              | Verify foreign principal object names. |
	//	+-----------------------------------------+----------------------------------------+
	Flags uint32 `idl:"name:dwFlags" json:"flags"`
	// cNames:  The number of items in the rpNames array.
	NamesCount uint32 `idl:"name:cNames" json:"names_count"`
	// rpNames:  An array of pointers to DSNames that need to be verified.
	Names []*DSName `idl:"name:rpNames;size_is:(cNames)" json:"names"`
	// RequiredAttrs:  The list of attributes to be retrieved for each name that is verified.
	RequiredAttrs *AttributeBlock `idl:"name:RequiredAttrs" json:"required_attrs"`
	// PrefixTable:  The prefix table used to translate ATTRTYP values in RequiredAttrs
	// to OID values.
	PrefixTable *SchemaPrefixTable `idl:"name:PrefixTable" json:"prefix_table"`
}

func (o *MessageVerifyRequestV1) xxx_PreparePayload(ctx context.Context) error {
	if o.Names != nil && o.NamesCount == 0 {
		o.NamesCount = uint32(len(o.Names))
	}
	if o.NamesCount < uint32(1) || o.NamesCount > uint32(10000) {
		return fmt.Errorf("NamesCount is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageVerifyRequestV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	if err := w.WriteData(o.NamesCount); err != nil {
		return err
	}
	if o.Names != nil || o.NamesCount > 0 {
		_ptr_rpNames := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.NamesCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Names {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Names[i1] != nil {
					_ptr_rpNames := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
						if o.Names[i1] != nil {
							if err := o.Names[i1].MarshalNDR(ctx, w); err != nil {
								return err
							}
						} else {
							if err := (&DSName{}).MarshalNDR(ctx, w); err != nil {
								return err
							}
						}
						return nil
					})
					if err := w.WritePointer(&o.Names[i1], _ptr_rpNames); err != nil {
						return err
					}
				} else {
					if err := w.WritePointer(nil); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Names); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WritePointer(nil); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Names, _ptr_rpNames); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.RequiredAttrs != nil {
		if err := o.RequiredAttrs.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&AttributeBlock{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.PrefixTable != nil {
		if err := o.PrefixTable.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&SchemaPrefixTable{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageVerifyRequestV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	if err := w.ReadData(&o.NamesCount); err != nil {
		return err
	}
	_ptr_rpNames := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.NamesCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.NamesCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Names", sizeInfo[0])
		}
		o.Names = make([]*DSName, sizeInfo[0])
		for i1 := range o.Names {
			i1 := i1
			_ptr_rpNames := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
				if o.Names[i1] == nil {
					o.Names[i1] = &DSName{}
				}
				if err := o.Names[i1].UnmarshalNDR(ctx, w); err != nil {
					return err
				}
				return nil
			})
			_s_rpNames := func(ptr interface{}) { o.Names[i1] = *ptr.(**DSName) }
			if err := w.ReadPointer(&o.Names[i1], _s_rpNames, _ptr_rpNames); err != nil {
				return err
			}
		}
		return nil
	})
	_s_rpNames := func(ptr interface{}) { o.Names = *ptr.(*[]*DSName) }
	if err := w.ReadPointer(&o.Names, _s_rpNames, _ptr_rpNames); err != nil {
		return err
	}
	if o.RequiredAttrs == nil {
		o.RequiredAttrs = &AttributeBlock{}
	}
	if err := o.RequiredAttrs.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.PrefixTable == nil {
		o.PrefixTable = &SchemaPrefixTable{}
	}
	if err := o.PrefixTable.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageVerifyRequest structure represents DRS_MSG_VERIFYREQ RPC union.
//
// The DRS_MSG_VERIFYREQ union defines the request messages sent to the IDL_DRSVerifyNames
// method. Only one version, identified by dwInVersion = 1, is currently defined.
type MessageVerifyRequest struct {
	// Types that are assignable to Value
	//
	// *MessageVerifyRequest_V1
	Value is_MessageVerifyRequest `json:"value"`
}

func (o *MessageVerifyRequest) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageVerifyRequest_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_MessageVerifyRequest interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageVerifyRequest()
}

func (o *MessageVerifyRequest) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageVerifyRequest_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *MessageVerifyRequest) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageVerifyRequest_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageVerifyRequest_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageVerifyRequest) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageVerifyRequest_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageVerifyRequest_V1 structure represents DRS_MSG_VERIFYREQ RPC union arm.
//
// It has following labels: 1
type MessageVerifyRequest_V1 struct {
	// V1:  The version 1 request.
	V1 *MessageVerifyRequestV1 `idl:"name:V1" json:"v1"`
}

func (*MessageVerifyRequest_V1) is_MessageVerifyRequest() {}

func (o *MessageVerifyRequest_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageVerifyRequestV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageVerifyRequest_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageVerifyRequestV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageVerifyReplyV1 structure represents DRS_MSG_VERIFYREPLY_V1 RPC structure.
//
// The DRS_MSG_VERIFYREPLY_V1 structure defines a response message received from the
// IDL_DRSVerifyNames method.
type MessageVerifyReplyV1 struct {
	// error:  Unused. MUST be 0 and ignored.
	Error uint32 `idl:"name:error" json:"error"`
	// cNames:  The number of items in the rpEntInf array.
	NamesCount uint32 `idl:"name:cNames" json:"names_count"`
	// rpEntInf:  An array of ENTINF structures that contain the attributes requested in
	// the RequiredAttrs field of the input DRS_MSG_VERIFYREQ_V1 structure if the corresponding
	// name is verified.
	EntityInfo []*EntityInfo `idl:"name:rpEntInf;size_is:(cNames)" json:"entity_info"`
	// PrefixTable:  The prefix table used to translate ATTRTYP values in the response to
	// OIDs.
	PrefixTable *SchemaPrefixTable `idl:"name:PrefixTable" json:"prefix_table"`
}

func (o *MessageVerifyReplyV1) xxx_PreparePayload(ctx context.Context) error {
	if o.EntityInfo != nil && o.NamesCount == 0 {
		o.NamesCount = uint32(len(o.EntityInfo))
	}
	if o.NamesCount > uint32(10000) {
		return fmt.Errorf("NamesCount is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageVerifyReplyV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.Error); err != nil {
		return err
	}
	if err := w.WriteData(o.NamesCount); err != nil {
		return err
	}
	if o.EntityInfo != nil || o.NamesCount > 0 {
		_ptr_rpEntInf := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.NamesCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.EntityInfo {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.EntityInfo[i1] != nil {
					if err := o.EntityInfo[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&EntityInfo{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.EntityInfo); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&EntityInfo{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.EntityInfo, _ptr_rpEntInf); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.PrefixTable != nil {
		if err := o.PrefixTable.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&SchemaPrefixTable{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageVerifyReplyV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.Error); err != nil {
		return err
	}
	if err := w.ReadData(&o.NamesCount); err != nil {
		return err
	}
	_ptr_rpEntInf := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.NamesCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.NamesCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.EntityInfo", sizeInfo[0])
		}
		o.EntityInfo = make([]*EntityInfo, sizeInfo[0])
		for i1 := range o.EntityInfo {
			i1 := i1
			if o.EntityInfo[i1] == nil {
				o.EntityInfo[i1] = &EntityInfo{}
			}
			if err := o.EntityInfo[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_rpEntInf := func(ptr interface{}) { o.EntityInfo = *ptr.(*[]*EntityInfo) }
	if err := w.ReadPointer(&o.EntityInfo, _s_rpEntInf, _ptr_rpEntInf); err != nil {
		return err
	}
	if o.PrefixTable == nil {
		o.PrefixTable = &SchemaPrefixTable{}
	}
	if err := o.PrefixTable.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageVerifyReply structure represents DRS_MSG_VERIFYREPLY RPC union.
//
// The DRS_MSG_VERIFYREPLY union defines the response messages received from the IDL_DRSVerifyNames
// method. Only one version, identified by pdwOutVersion^ = 1, is currently defined.
type MessageVerifyReply struct {
	// Types that are assignable to Value
	//
	// *MessageVerifyReply_V1
	Value is_MessageVerifyReply `json:"value"`
}

func (o *MessageVerifyReply) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageVerifyReply_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_MessageVerifyReply interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageVerifyReply()
}

func (o *MessageVerifyReply) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageVerifyReply_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *MessageVerifyReply) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageVerifyReply_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageVerifyReply_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageVerifyReply) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageVerifyReply_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageVerifyReply_V1 structure represents DRS_MSG_VERIFYREPLY RPC union arm.
//
// It has following labels: 1
type MessageVerifyReply_V1 struct {
	// V1:  The version 1 reply.
	V1 *MessageVerifyReplyV1 `idl:"name:V1" json:"v1"`
}

func (*MessageVerifyReply_V1) is_MessageVerifyReply() {}

func (o *MessageVerifyReply_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageVerifyReplyV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageVerifyReply_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageVerifyReplyV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// ReverseMembershipOperationType type represents REVERSE_MEMBERSHIP_OPERATION_TYPE RPC enumeration.
//
// The REVERSE_MEMBERSHIP_OPERATION_TYPE enumeration defines the type of reverse membership
// evaluation.
type ReverseMembershipOperationType uint16

var (
	// RevMembGetGroupsForUser:  Nontransitive membership in groups that are confined to
	// a given domain, excluding built-in groups and domain-local groups. See [MS-ADSC]
	// section 2.14.
	ReverseMembershipOperationTypeGetGroupsForUser ReverseMembershipOperationType = 1
	// RevMembGetAliasMembership:  Nontransitive membership in domain-local groups that
	// are confined to a given domain.
	ReverseMembershipOperationTypeGetAliasMembership ReverseMembershipOperationType = 2
	// RevMembGetAccountGroups:  Transitive membership in all account groups in a given
	// domain, excluding built-in groups.
	ReverseMembershipOperationTypeGetAccountGroups ReverseMembershipOperationType = 3
	// RevMembGetResourceGroups:  Transitive membership in all domain-local groups in a
	// given domain, excluding built-in groups.
	ReverseMembershipOperationTypeGetResourceGroups ReverseMembershipOperationType = 4
	// RevMembGetUniversalGroups:  Transitive membership in all universal groups, excluding
	// built-in groups.
	ReverseMembershipOperationTypeGetUniversalGroups ReverseMembershipOperationType = 5
	// GroupMembersTransitive:  Transitive closure of members of a group based on the information
	// present in the server's NC replicas, including the primary group.
	ReverseMembershipOperationTypeGroupMembersTransitive ReverseMembershipOperationType = 6
	// RevMembGlobalGroupsNonTransitive:  Non-transitive membership in global groups, excluding
	// built-in groups.
	ReverseMembershipOperationTypeGlobalGroupsNonTransitive ReverseMembershipOperationType = 7
)

func (o ReverseMembershipOperationType) String() string {
	switch o {
	case ReverseMembershipOperationTypeGetGroupsForUser:
		return "ReverseMembershipOperationTypeGetGroupsForUser"
	case ReverseMembershipOperationTypeGetAliasMembership:
		return "ReverseMembershipOperationTypeGetAliasMembership"
	case ReverseMembershipOperationTypeGetAccountGroups:
		return "ReverseMembershipOperationTypeGetAccountGroups"
	case ReverseMembershipOperationTypeGetResourceGroups:
		return "ReverseMembershipOperationTypeGetResourceGroups"
	case ReverseMembershipOperationTypeGetUniversalGroups:
		return "ReverseMembershipOperationTypeGetUniversalGroups"
	case ReverseMembershipOperationTypeGroupMembersTransitive:
		return "ReverseMembershipOperationTypeGroupMembersTransitive"
	case ReverseMembershipOperationTypeGlobalGroupsNonTransitive:
		return "ReverseMembershipOperationTypeGlobalGroupsNonTransitive"
	}
	return "Invalid"
}

// MessageReverseMembershipRequestV1 structure represents DRS_MSG_REVMEMB_REQ_V1 RPC structure.
//
// The DRS_MSG_REVMEMB_REQ_V1 structure defines the request message sent to the IDL_DRSGetMemberships
// method.
type MessageReverseMembershipRequestV1 struct {
	// cDsNames:  The count of items in the ppDsNames array.
	DSNamesCount uint32 `idl:"name:cDsNames" json:"ds_names_count"`
	// ppDsNames:  The DSName of the object whose reverse membership is being requested,
	// plus the DSNames of groups of the appropriate type(s) of which it is already known
	// to be a member.
	DSNames []*DSName `idl:"name:ppDsNames;size_is:(cDsNames, )" json:"ds_names"`
	// dwFlags:  Zero or more of the following bit flags, which are presented in little-endian
	// byte order.
	//
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
	//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| X | X | X | X | X | X | X | A | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//
	// X: Unused. MUST be zero and ignored.
	Flags uint32 `idl:"name:dwFlags" json:"flags"`
	// OperationType: The type of group membership evaluation to be performed.
	OperationType ReverseMembershipOperationType `idl:"name:OperationType" json:"operation_type"`
	// pLimitingDomain: Domain filter; resulting objects that are not from this domain are
	// neither returned nor followed transitively.
	LimitingDomain *DSName `idl:"name:pLimitingDomain" json:"limiting_domain"`
}

func (o *MessageReverseMembershipRequestV1) xxx_PreparePayload(ctx context.Context) error {
	if o.DSNames != nil && o.DSNamesCount == 0 {
		o.DSNamesCount = uint32(len(o.DSNames))
	}
	if o.DSNamesCount < uint32(1) || o.DSNamesCount > uint32(10000) {
		return fmt.Errorf("DSNamesCount is out of range")
	}
	if o.OperationType < ReverseMembershipOperationType(1) || o.OperationType > ReverseMembershipOperationType(7) {
		return fmt.Errorf("OperationType is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageReverseMembershipRequestV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.DSNamesCount); err != nil {
		return err
	}
	if o.DSNames != nil || o.DSNamesCount > 0 {
		_ptr_ppDsNames := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.DSNamesCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.DSNames {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.DSNames[i1] != nil {
					_ptr_ppDsNames := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
						if o.DSNames[i1] != nil {
							if err := o.DSNames[i1].MarshalNDR(ctx, w); err != nil {
								return err
							}
						} else {
							if err := (&DSName{}).MarshalNDR(ctx, w); err != nil {
								return err
							}
						}
						return nil
					})
					if err := w.WritePointer(&o.DSNames[i1], _ptr_ppDsNames); err != nil {
						return err
					}
				} else {
					if err := w.WritePointer(nil); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.DSNames); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WritePointer(nil); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.DSNames, _ptr_ppDsNames); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	if err := w.WriteEnum(uint16(o.OperationType)); err != nil {
		return err
	}
	if o.LimitingDomain != nil {
		_ptr_pLimitingDomain := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.LimitingDomain != nil {
				if err := o.LimitingDomain.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSName{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.LimitingDomain, _ptr_pLimitingDomain); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageReverseMembershipRequestV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.DSNamesCount); err != nil {
		return err
	}
	_ptr_ppDsNames := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.DSNamesCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.DSNamesCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.DSNames", sizeInfo[0])
		}
		o.DSNames = make([]*DSName, sizeInfo[0])
		for i1 := range o.DSNames {
			i1 := i1
			_ptr_ppDsNames := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
				if o.DSNames[i1] == nil {
					o.DSNames[i1] = &DSName{}
				}
				if err := o.DSNames[i1].UnmarshalNDR(ctx, w); err != nil {
					return err
				}
				return nil
			})
			_s_ppDsNames := func(ptr interface{}) { o.DSNames[i1] = *ptr.(**DSName) }
			if err := w.ReadPointer(&o.DSNames[i1], _s_ppDsNames, _ptr_ppDsNames); err != nil {
				return err
			}
		}
		return nil
	})
	_s_ppDsNames := func(ptr interface{}) { o.DSNames = *ptr.(*[]*DSName) }
	if err := w.ReadPointer(&o.DSNames, _s_ppDsNames, _ptr_ppDsNames); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	if err := w.ReadEnum((*uint16)(&o.OperationType)); err != nil {
		return err
	}
	_ptr_pLimitingDomain := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.LimitingDomain == nil {
			o.LimitingDomain = &DSName{}
		}
		if err := o.LimitingDomain.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pLimitingDomain := func(ptr interface{}) { o.LimitingDomain = *ptr.(**DSName) }
	if err := w.ReadPointer(&o.LimitingDomain, _s_pLimitingDomain, _ptr_pLimitingDomain); err != nil {
		return err
	}
	return nil
}

// MessageReverseMembershipRequest structure represents DRS_MSG_REVMEMB_REQ RPC union.
//
// The DRS_MSG_REVMEMB_REQ union defines the request messages sent to the IDL_DRSGetMemberships
// method. Only one version, identified by dwInVersion = 1, is currently defined.
type MessageReverseMembershipRequest struct {
	// Types that are assignable to Value
	//
	// *MessageReverseMembershipRequest_V1
	Value is_MessageReverseMembershipRequest `json:"value"`
}

func (o *MessageReverseMembershipRequest) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageReverseMembershipRequest_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_MessageReverseMembershipRequest interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageReverseMembershipRequest()
}

func (o *MessageReverseMembershipRequest) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageReverseMembershipRequest_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *MessageReverseMembershipRequest) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageReverseMembershipRequest_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageReverseMembershipRequest_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageReverseMembershipRequest) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageReverseMembershipRequest_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageReverseMembershipRequest_V1 structure represents DRS_MSG_REVMEMB_REQ RPC union arm.
//
// It has following labels: 1
type MessageReverseMembershipRequest_V1 struct {
	// V1:  Version 1 request. Currently only one version is defined.
	V1 *MessageReverseMembershipRequestV1 `idl:"name:V1" json:"v1"`
}

func (*MessageReverseMembershipRequest_V1) is_MessageReverseMembershipRequest() {}

func (o *MessageReverseMembershipRequest_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageReverseMembershipRequestV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageReverseMembershipRequest_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageReverseMembershipRequestV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageReverseMembershipReplyV1 structure represents DRS_MSG_REVMEMB_REPLY_V1 RPC structure.
//
// The DRS_MSG_REVMEMB_REPLY_V1 structure defines the response message received from
// the IDL_DRSGetMemberships method.
type MessageReverseMembershipReplyV1 struct {
	// errCode:  0 on success. On failure, this can be one of the following.
	//
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                          |                                                                                  |
	//	|                  VALUE                   |                                     MEANING                                      |
	//	|                                          |                                                                                  |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| STATUS_INSUFFICIENT_RESOURCES 0xC000009A | Insufficient system resources exist to complete the request.                     |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| STATUS_TOO_MANY_CONTEXT_IDS 0xC000015A   | The number of groups is greater than the number that can be returned to the      |
	//	|                                          | caller.                                                                          |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	ErrorCode uint32 `idl:"name:errCode" json:"error_code"`
	// cDsNames:  Count of items in the ppDsNames array.
	DSNamesCount uint32 `idl:"name:cDsNames" json:"ds_names_count"`
	// cSidHistory:  Count of items in the ppSidHistory array.
	SIDHistoryCount uint32 `idl:"name:cSidHistory" json:"sid_history_count"`
	// ppDsNames:  The filtered group membership. This list contains the combined membership
	// for all the names specified in ppDsNames field of the input DRS_MSG_REVMEMB_REQ_V1
	// structure.
	DSNames []*DSName `idl:"name:ppDsNames;size_is:(cDsNames, )" json:"ds_names"`
	// pAttributes:  Properties of the returned groups. Values are chosen from SE_GROUP
	// values.
	Attributes []uint32 `idl:"name:pAttributes;size_is:(cDsNames)" json:"attributes"`
	// ppSidHistory:  SID history of the returned groups.
	SIDHistory []*NT4SID `idl:"name:ppSidHistory;size_is:(cSidHistory, )" json:"sid_history"`
}

func (o *MessageReverseMembershipReplyV1) xxx_PreparePayload(ctx context.Context) error {
	if o.DSNames != nil && o.DSNamesCount == 0 {
		o.DSNamesCount = uint32(len(o.DSNames))
	}
	if o.Attributes != nil && o.DSNamesCount == 0 {
		o.DSNamesCount = uint32(len(o.Attributes))
	}
	if o.SIDHistory != nil && o.SIDHistoryCount == 0 {
		o.SIDHistoryCount = uint32(len(o.SIDHistory))
	}
	if o.DSNamesCount > uint32(10000) {
		return fmt.Errorf("DSNamesCount is out of range")
	}
	if o.SIDHistoryCount > uint32(10000) {
		return fmt.Errorf("SIDHistoryCount is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageReverseMembershipReplyV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.ErrorCode); err != nil {
		return err
	}
	if err := w.WriteData(o.DSNamesCount); err != nil {
		return err
	}
	if err := w.WriteData(o.SIDHistoryCount); err != nil {
		return err
	}
	if o.DSNames != nil || o.DSNamesCount > 0 {
		_ptr_ppDsNames := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.DSNamesCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.DSNames {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.DSNames[i1] != nil {
					_ptr_ppDsNames := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
						if o.DSNames[i1] != nil {
							if err := o.DSNames[i1].MarshalNDR(ctx, w); err != nil {
								return err
							}
						} else {
							if err := (&DSName{}).MarshalNDR(ctx, w); err != nil {
								return err
							}
						}
						return nil
					})
					if err := w.WritePointer(&o.DSNames[i1], _ptr_ppDsNames); err != nil {
						return err
					}
				} else {
					if err := w.WritePointer(nil); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.DSNames); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WritePointer(nil); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.DSNames, _ptr_ppDsNames); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.Attributes != nil || o.DSNamesCount > 0 {
		_ptr_pAttributes := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.DSNamesCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Attributes {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.Attributes[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.Attributes); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint32(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Attributes, _ptr_pAttributes); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.SIDHistory != nil || o.SIDHistoryCount > 0 {
		_ptr_ppSidHistory := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.SIDHistoryCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.SIDHistory {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.SIDHistory[i1] != nil {
					_ptr_ppSidHistory := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
						if o.SIDHistory[i1] != nil {
							if err := o.SIDHistory[i1].MarshalNDR(ctx, w); err != nil {
								return err
							}
						} else {
							if err := (&NT4SID{}).MarshalNDR(ctx, w); err != nil {
								return err
							}
						}
						return nil
					})
					if err := w.WritePointer(&o.SIDHistory[i1], _ptr_ppSidHistory); err != nil {
						return err
					}
				} else {
					if err := w.WritePointer(nil); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.SIDHistory); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WritePointer(nil); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.SIDHistory, _ptr_ppSidHistory); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageReverseMembershipReplyV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.ErrorCode); err != nil {
		return err
	}
	if err := w.ReadData(&o.DSNamesCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.SIDHistoryCount); err != nil {
		return err
	}
	_ptr_ppDsNames := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.DSNamesCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.DSNamesCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.DSNames", sizeInfo[0])
		}
		o.DSNames = make([]*DSName, sizeInfo[0])
		for i1 := range o.DSNames {
			i1 := i1
			_ptr_ppDsNames := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
				if o.DSNames[i1] == nil {
					o.DSNames[i1] = &DSName{}
				}
				if err := o.DSNames[i1].UnmarshalNDR(ctx, w); err != nil {
					return err
				}
				return nil
			})
			_s_ppDsNames := func(ptr interface{}) { o.DSNames[i1] = *ptr.(**DSName) }
			if err := w.ReadPointer(&o.DSNames[i1], _s_ppDsNames, _ptr_ppDsNames); err != nil {
				return err
			}
		}
		return nil
	})
	_s_ppDsNames := func(ptr interface{}) { o.DSNames = *ptr.(*[]*DSName) }
	if err := w.ReadPointer(&o.DSNames, _s_ppDsNames, _ptr_ppDsNames); err != nil {
		return err
	}
	_ptr_pAttributes := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.DSNamesCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.DSNamesCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Attributes", sizeInfo[0])
		}
		o.Attributes = make([]uint32, sizeInfo[0])
		for i1 := range o.Attributes {
			i1 := i1
			if err := w.ReadData(&o.Attributes[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_pAttributes := func(ptr interface{}) { o.Attributes = *ptr.(*[]uint32) }
	if err := w.ReadPointer(&o.Attributes, _s_pAttributes, _ptr_pAttributes); err != nil {
		return err
	}
	_ptr_ppSidHistory := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.SIDHistoryCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.SIDHistoryCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.SIDHistory", sizeInfo[0])
		}
		o.SIDHistory = make([]*NT4SID, sizeInfo[0])
		for i1 := range o.SIDHistory {
			i1 := i1
			_ptr_ppSidHistory := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
				if o.SIDHistory[i1] == nil {
					o.SIDHistory[i1] = &NT4SID{}
				}
				if err := o.SIDHistory[i1].UnmarshalNDR(ctx, w); err != nil {
					return err
				}
				return nil
			})
			_s_ppSidHistory := func(ptr interface{}) { o.SIDHistory[i1] = *ptr.(**NT4SID) }
			if err := w.ReadPointer(&o.SIDHistory[i1], _s_ppSidHistory, _ptr_ppSidHistory); err != nil {
				return err
			}
		}
		return nil
	})
	_s_ppSidHistory := func(ptr interface{}) { o.SIDHistory = *ptr.(*[]*NT4SID) }
	if err := w.ReadPointer(&o.SIDHistory, _s_ppSidHistory, _ptr_ppSidHistory); err != nil {
		return err
	}
	return nil
}

// MessageReverseMembershipReply structure represents DRS_MSG_REVMEMB_REPLY RPC union.
//
// The DRS_MSG_REVMEMB_REPLY union defines the response messages received from the IDL_DRSGetMemberships
// method. Only one version, identified by pdwOutVersion^ = 1, is currently defined.
type MessageReverseMembershipReply struct {
	// Types that are assignable to Value
	//
	// *MessageReverseMembershipReply_V1
	Value is_MessageReverseMembershipReply `json:"value"`
}

func (o *MessageReverseMembershipReply) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageReverseMembershipReply_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_MessageReverseMembershipReply interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageReverseMembershipReply()
}

func (o *MessageReverseMembershipReply) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageReverseMembershipReply_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *MessageReverseMembershipReply) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageReverseMembershipReply_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageReverseMembershipReply_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageReverseMembershipReply) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageReverseMembershipReply_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageReverseMembershipReply_V1 structure represents DRS_MSG_REVMEMB_REPLY RPC union arm.
//
// It has following labels: 1
type MessageReverseMembershipReply_V1 struct {
	// V1:  Version 1 reply.
	V1 *MessageReverseMembershipReplyV1 `idl:"name:V1" json:"v1"`
}

func (*MessageReverseMembershipReply_V1) is_MessageReverseMembershipReply() {}

func (o *MessageReverseMembershipReply_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageReverseMembershipReplyV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageReverseMembershipReply_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageReverseMembershipReplyV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageMoveRequestV1 structure represents DRS_MSG_MOVEREQ_V1 RPC structure.
//
// The DRS_MSG_MOVEREQ_V1 structure defines a request message sent to the IDL_DRSInterDomainMove
// method. This request version is obsolete.<34>
type MessageMoveRequestV1 struct {
	// pSourceDSA:  The NetworkAddress of the client DC.
	SourceDSA string `idl:"name:pSourceDSA" json:"source_dsa"`
	// pObject:  The object to be moved.
	Object *EntityInfo `idl:"name:pObject" json:"object"`
	// pParentUUID:  The objectGUID of the new parent object.
	ParentUUID *dtyp.UUID `idl:"name:pParentUUID" json:"parent_uuid"`
	// PrefixTable:  The prefix table with which to translate the ATTRTYP values in pObject
	// to OIDs.
	PrefixTable *SchemaPrefixTable `idl:"name:PrefixTable" json:"prefix_table"`
	// ulFlags:  Unused. MUST be 0 and ignored.
	Flags uint32 `idl:"name:ulFlags" json:"flags"`
}

func (o *MessageMoveRequestV1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageMoveRequestV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.SourceDSA != "" {
		_ptr_pSourceDSA := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteCharString(ctx, w, o.SourceDSA); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.SourceDSA, _ptr_pSourceDSA); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.Object != nil {
		_ptr_pObject := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Object != nil {
				if err := o.Object.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&EntityInfo{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Object, _ptr_pObject); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.ParentUUID != nil {
		_ptr_pParentUUID := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ParentUUID != nil {
				if err := o.ParentUUID.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ParentUUID, _ptr_pParentUUID); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.PrefixTable != nil {
		if err := o.PrefixTable.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&SchemaPrefixTable{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	return nil
}
func (o *MessageMoveRequestV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_pSourceDSA := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadCharString(ctx, w, &o.SourceDSA); err != nil {
			return err
		}
		return nil
	})
	_s_pSourceDSA := func(ptr interface{}) { o.SourceDSA = *ptr.(*string) }
	if err := w.ReadPointer(&o.SourceDSA, _s_pSourceDSA, _ptr_pSourceDSA); err != nil {
		return err
	}
	_ptr_pObject := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Object == nil {
			o.Object = &EntityInfo{}
		}
		if err := o.Object.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pObject := func(ptr interface{}) { o.Object = *ptr.(**EntityInfo) }
	if err := w.ReadPointer(&o.Object, _s_pObject, _ptr_pObject); err != nil {
		return err
	}
	_ptr_pParentUUID := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ParentUUID == nil {
			o.ParentUUID = &dtyp.UUID{}
		}
		if err := o.ParentUUID.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pParentUUID := func(ptr interface{}) { o.ParentUUID = *ptr.(**dtyp.UUID) }
	if err := w.ReadPointer(&o.ParentUUID, _s_pParentUUID, _ptr_pParentUUID); err != nil {
		return err
	}
	if o.PrefixTable == nil {
		o.PrefixTable = &SchemaPrefixTable{}
	}
	if err := o.PrefixTable.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	return nil
}

// SecurityBuffer structure represents DRS_SecBuffer RPC structure.
//
// DRS_SecBuffer is a concrete type for a buffer that contains authentication data.
type SecurityBuffer struct {
	// cbBuffer:  The size, in bytes, of the pvBuffer array.
	BufferLength uint32 `idl:"name:cbBuffer" json:"buffer_length"`
	// BufferType:  A bit field, presented in little-endian byte order, that contains the
	// following values:
	//
	//	+---+---+---+---+---+-------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+-----+---+---+---+---+---+---+---+
	//	| 0 | 1 | 2 | 3 | 4 |   5   | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 |  4  | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
	//	|   |   |   |   |   |       |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |     |   |   |   |   |   | 0 |   |
	//	+---+---+---+---+---+-------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+-----+---+---+---+---+---+---+---+
	//	+---+---+---+---+---+-------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+-----+---+---+---+---+---+---+---+
	//	| X | X | X | X | X | T Y P | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | R O | X | X | X | X | X | X | X |
	//	+---+---+---+---+---+-------+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+-----+---+---+---+---+---+---+---+
	//
	// X: Unused. MUST be zero and ignored.
	//
	// TYP: Can be one of the following values:
	//
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	|                                     |                                                                                  |
	//	|                VALUE                |                                     MEANING                                      |
	//	|                                     |                                                                                  |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| SECBUFFER_EMPTY 0x00000000          | A placeholder in the buffer array. The caller can supply several such entries in |
	//	|                                     | the array, and the security package can return data in them.                     |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| SECBUFFER_DATA 0x00000001           | Used for common data. The security package can read this data and write it, for  |
	//	|                                     | example, to encrypt some or all of it.                                           |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| SECBUFFER_TOKEN 0x00000002          | This buffer is used to indicate the security token portion of the message. This  |
	//	|                                     | is read-only for input parameters or read/write for output parameters.           |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| SECBUFFER_PKG_PARAMS 0x00000003     | These are transport-to-package–specific parameters. For example, the Netware     |
	//	|                                     | redirector can supply the server object identifier, while DCE RPC can supply an  |
	//	|                                     | association UUID, and so on.                                                     |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| SECBUFFER_MISSING 0x00000004        | The security package uses this value to indicate the number of missing bytes in  |
	//	|                                     | a particular message. The pvBuffer member is ignored in this type.               |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| SECBUFFER_EXTRA 0x00000005          | The security package uses this value to indicate the number of extra or          |
	//	|                                     | unprocessed bytes in a message.                                                  |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| SECBUFFER_STREAM_TRAILER 0x00000006 | Indicates a protocol-specific trailer for a particular record.                   |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| SECBUFFER_STREAM_HEADER 0x00000007  | Indicates a protocol-specific header for a particular record.                    |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	BufferType uint32 `idl:"name:BufferType" json:"buffer_type"`
	// pvBuffer:  Authentication data.
	Buffer []byte `idl:"name:pvBuffer;size_is:(cbBuffer)" json:"buffer"`
}

func (o *SecurityBuffer) xxx_PreparePayload(ctx context.Context) error {
	if o.Buffer != nil && o.BufferLength == 0 {
		o.BufferLength = uint32(len(o.Buffer))
	}
	if o.BufferLength > uint32(10000) {
		return fmt.Errorf("BufferLength is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *SecurityBuffer) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.BufferLength); err != nil {
		return err
	}
	if err := w.WriteData(o.BufferType); err != nil {
		return err
	}
	if o.Buffer != nil || o.BufferLength > 0 {
		_ptr_pvBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.BufferLength)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Buffer {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.Buffer[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Buffer, _ptr_pvBuffer); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *SecurityBuffer) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.BufferLength); err != nil {
		return err
	}
	if err := w.ReadData(&o.BufferType); err != nil {
		return err
	}
	_ptr_pvBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.BufferLength > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.BufferLength)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
		}
		o.Buffer = make([]byte, sizeInfo[0])
		for i1 := range o.Buffer {
			i1 := i1
			if err := w.ReadData(&o.Buffer[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_pvBuffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.Buffer, _s_pvBuffer, _ptr_pvBuffer); err != nil {
		return err
	}
	return nil
}

// SecurityBufferDesc structure represents DRS_SecBufferDesc RPC structure.
//
// DRS_SecBufferDesc is a Generic Security Service (GSS) Kerberos authentication token,
// as specified in [RFC1964].
type SecurityBufferDesc struct {
	// ulVersion:  MUST be 0.
	Version uint32 `idl:"name:ulVersion" json:"version"`
	// cBuffers:  The number of items in the Buffers array.
	BuffersCount uint32 `idl:"name:cBuffers" json:"buffers_count"`
	// Buffers:  Buffers that contain authentication data.
	Buffers []*SecurityBuffer `idl:"name:Buffers;size_is:(cBuffers)" json:"buffers"`
}

func (o *SecurityBufferDesc) xxx_PreparePayload(ctx context.Context) error {
	if o.Buffers != nil && o.BuffersCount == 0 {
		o.BuffersCount = uint32(len(o.Buffers))
	}
	if o.BuffersCount > uint32(10000) {
		return fmt.Errorf("BuffersCount is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *SecurityBufferDesc) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.Version); err != nil {
		return err
	}
	if err := w.WriteData(o.BuffersCount); err != nil {
		return err
	}
	if o.Buffers != nil || o.BuffersCount > 0 {
		_ptr_Buffers := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.BuffersCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Buffers {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Buffers[i1] != nil {
					if err := o.Buffers[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&SecurityBuffer{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Buffers); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&SecurityBuffer{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Buffers, _ptr_Buffers); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *SecurityBufferDesc) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.Version); err != nil {
		return err
	}
	if err := w.ReadData(&o.BuffersCount); err != nil {
		return err
	}
	_ptr_Buffers := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.BuffersCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.BuffersCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffers", sizeInfo[0])
		}
		o.Buffers = make([]*SecurityBuffer, sizeInfo[0])
		for i1 := range o.Buffers {
			i1 := i1
			if o.Buffers[i1] == nil {
				o.Buffers[i1] = &SecurityBuffer{}
			}
			if err := o.Buffers[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_Buffers := func(ptr interface{}) { o.Buffers = *ptr.(*[]*SecurityBuffer) }
	if err := w.ReadPointer(&o.Buffers, _s_Buffers, _ptr_Buffers); err != nil {
		return err
	}
	return nil
}

// MessageMoveRequestV2 structure represents DRS_MSG_MOVEREQ_V2 RPC structure.
//
// The DRS_MSG_MOVEREQ_V2 structure defines a request message sent to the IDL_DRSInterDomainMove
// method.
type MessageMoveRequestV2 struct {
	// pSrcDSA:  The client DC nTDSDSA object.
	SourceDSA *DSName `idl:"name:pSrcDSA" json:"source_dsa"`
	// pSrcObject:  The object to be moved.
	SourceObject *EntityInfo `idl:"name:pSrcObject" json:"source_object"`
	// pDstName:  The name the object will have in the destination domain.
	DestinationName *DSName `idl:"name:pDstName" json:"destination_name"`
	// pExpectedTargetNC:  The NC to which pSrcObject is being moved.
	ExpectedTargetNC *DSName `idl:"name:pExpectedTargetNC" json:"expected_target_nc"`
	// pClientCreds:  The credentials of the user initiating the call.
	ClientCreds *SecurityBufferDesc `idl:"name:pClientCreds" json:"client_creds"`
	// PrefixTable:  The prefix table with which to translate the ATTRTYP values in pSrcObject
	// to OIDs.
	PrefixTable *SchemaPrefixTable `idl:"name:PrefixTable" json:"prefix_table"`
	// ulFlags:  Unused. MUST be 0 and ignored.
	Flags uint32 `idl:"name:ulFlags" json:"flags"`
}

func (o *MessageMoveRequestV2) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageMoveRequestV2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.SourceDSA != nil {
		_ptr_pSrcDSA := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.SourceDSA != nil {
				if err := o.SourceDSA.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSName{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.SourceDSA, _ptr_pSrcDSA); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.SourceObject != nil {
		_ptr_pSrcObject := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.SourceObject != nil {
				if err := o.SourceObject.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&EntityInfo{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.SourceObject, _ptr_pSrcObject); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.DestinationName != nil {
		_ptr_pDstName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.DestinationName != nil {
				if err := o.DestinationName.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSName{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.DestinationName, _ptr_pDstName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.ExpectedTargetNC != nil {
		_ptr_pExpectedTargetNC := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ExpectedTargetNC != nil {
				if err := o.ExpectedTargetNC.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSName{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ExpectedTargetNC, _ptr_pExpectedTargetNC); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.ClientCreds != nil {
		_ptr_pClientCreds := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ClientCreds != nil {
				if err := o.ClientCreds.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&SecurityBufferDesc{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ClientCreds, _ptr_pClientCreds); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.PrefixTable != nil {
		if err := o.PrefixTable.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&SchemaPrefixTable{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	return nil
}
func (o *MessageMoveRequestV2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_pSrcDSA := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.SourceDSA == nil {
			o.SourceDSA = &DSName{}
		}
		if err := o.SourceDSA.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pSrcDSA := func(ptr interface{}) { o.SourceDSA = *ptr.(**DSName) }
	if err := w.ReadPointer(&o.SourceDSA, _s_pSrcDSA, _ptr_pSrcDSA); err != nil {
		return err
	}
	_ptr_pSrcObject := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.SourceObject == nil {
			o.SourceObject = &EntityInfo{}
		}
		if err := o.SourceObject.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pSrcObject := func(ptr interface{}) { o.SourceObject = *ptr.(**EntityInfo) }
	if err := w.ReadPointer(&o.SourceObject, _s_pSrcObject, _ptr_pSrcObject); err != nil {
		return err
	}
	_ptr_pDstName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.DestinationName == nil {
			o.DestinationName = &DSName{}
		}
		if err := o.DestinationName.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pDstName := func(ptr interface{}) { o.DestinationName = *ptr.(**DSName) }
	if err := w.ReadPointer(&o.DestinationName, _s_pDstName, _ptr_pDstName); err != nil {
		return err
	}
	_ptr_pExpectedTargetNC := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ExpectedTargetNC == nil {
			o.ExpectedTargetNC = &DSName{}
		}
		if err := o.ExpectedTargetNC.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pExpectedTargetNC := func(ptr interface{}) { o.ExpectedTargetNC = *ptr.(**DSName) }
	if err := w.ReadPointer(&o.ExpectedTargetNC, _s_pExpectedTargetNC, _ptr_pExpectedTargetNC); err != nil {
		return err
	}
	_ptr_pClientCreds := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ClientCreds == nil {
			o.ClientCreds = &SecurityBufferDesc{}
		}
		if err := o.ClientCreds.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pClientCreds := func(ptr interface{}) { o.ClientCreds = *ptr.(**SecurityBufferDesc) }
	if err := w.ReadPointer(&o.ClientCreds, _s_pClientCreds, _ptr_pClientCreds); err != nil {
		return err
	}
	if o.PrefixTable == nil {
		o.PrefixTable = &SchemaPrefixTable{}
	}
	if err := o.PrefixTable.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	return nil
}

// MessageMoveRequest structure represents DRS_MSG_MOVEREQ RPC union.
//
// The DRS_MSG_MOVEREQ union defines the request messages sent to the IDL_DRSInterDomainMove
// method.
type MessageMoveRequest struct {
	// Types that are assignable to Value
	//
	// *MessageMoveRequest_V1
	// *MessageMoveRequest_V2
	Value is_MessageMoveRequest `json:"value"`
}

func (o *MessageMoveRequest) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageMoveRequest_V1:
		if value != nil {
			return value.V1
		}
	case *MessageMoveRequest_V2:
		if value != nil {
			return value.V2
		}
	}
	return nil
}

type is_MessageMoveRequest interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageMoveRequest()
}

func (o *MessageMoveRequest) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageMoveRequest_V1:
		return uint32(1)
	case *MessageMoveRequest_V2:
		return uint32(2)
	}
	return uint32(0)
}

func (o *MessageMoveRequest) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageMoveRequest_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageMoveRequest_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(2):
		_o, _ := o.Value.(*MessageMoveRequest_V2)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageMoveRequest_V2{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageMoveRequest) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageMoveRequest_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(2):
		o.Value = &MessageMoveRequest_V2{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageMoveRequest_V1 structure represents DRS_MSG_MOVEREQ RPC union arm.
//
// It has following labels: 1
type MessageMoveRequest_V1 struct {
	// V1:  The version 1 request (obsolete).
	V1 *MessageMoveRequestV1 `idl:"name:V1" json:"v1"`
}

func (*MessageMoveRequest_V1) is_MessageMoveRequest() {}

func (o *MessageMoveRequest_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageMoveRequestV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageMoveRequest_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageMoveRequestV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageMoveRequest_V2 structure represents DRS_MSG_MOVEREQ RPC union arm.
//
// It has following labels: 2
type MessageMoveRequest_V2 struct {
	// V2:  The version 2 request.
	V2 *MessageMoveRequestV2 `idl:"name:V2" json:"v2"`
}

func (*MessageMoveRequest_V2) is_MessageMoveRequest() {}

func (o *MessageMoveRequest_V2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V2 != nil {
		if err := o.V2.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageMoveRequestV2{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageMoveRequest_V2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V2 == nil {
		o.V2 = &MessageMoveRequestV2{}
	}
	if err := o.V2.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageMoveReplyV1 structure represents DRS_MSG_MOVEREPLY_V1 RPC structure.
//
// The DRS_MSG_MOVEREPLY_V1 structure defines a response message received from the IDL_DRSInterDomainMove
// method. This response version is obsolete.<35>
type MessageMoveReplyV1 struct {
	// ppResult:  The object as it appears following the move operation.
	Result *EntityInfo `idl:"name:ppResult" json:"result"`
	// PrefixTable:  The prefix table with which to translate the ATTRTYP values in ppResult
	// to OIDs.
	PrefixTable *SchemaPrefixTable `idl:"name:PrefixTable" json:"prefix_table"`
	// pError:  0 if successful, or non-zero if a fatal error occurred.
	Error uint32 `idl:"name:pError" json:"error"`
}

func (o *MessageMoveReplyV1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageMoveReplyV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.Result != nil {
		_ptr_ppResult := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Result != nil {
				_ptr_ppResult := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
					if o.Result != nil {
						if err := o.Result.MarshalNDR(ctx, w); err != nil {
							return err
						}
					} else {
						if err := (&EntityInfo{}).MarshalNDR(ctx, w); err != nil {
							return err
						}
					}
					return nil
				})
				if err := w.WritePointer(&o.Result, _ptr_ppResult); err != nil {
					return err
				}
			} else {
				if err := w.WritePointer(nil); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Result, _ptr_ppResult); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.PrefixTable != nil {
		if err := o.PrefixTable.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&SchemaPrefixTable{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	_ptr_pError := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
		if err := w.WriteData(o.Error); err != nil {
			return err
		}
		return nil
	})
	if err := w.WritePointer(&o.Error, _ptr_pError); err != nil {
		return err
	}
	return nil
}
func (o *MessageMoveReplyV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_ppResult := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		_ptr_ppResult := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Result == nil {
				o.Result = &EntityInfo{}
			}
			if err := o.Result.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ppResult := func(ptr interface{}) { o.Result = *ptr.(**EntityInfo) }
		if err := w.ReadPointer(&o.Result, _s_ppResult, _ptr_ppResult); err != nil {
			return err
		}
		return nil
	})
	_s_ppResult := func(ptr interface{}) { o.Result = *ptr.(**EntityInfo) }
	if err := w.ReadPointer(&o.Result, _s_ppResult, _ptr_ppResult); err != nil {
		return err
	}
	if o.PrefixTable == nil {
		o.PrefixTable = &SchemaPrefixTable{}
	}
	if err := o.PrefixTable.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_pError := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := w.ReadData(&o.Error); err != nil {
			return err
		}
		return nil
	})
	_s_pError := func(ptr interface{}) { o.Error = *ptr.(*uint32) }
	if err := w.ReadPointer(&o.Error, _s_pError, _ptr_pError); err != nil {
		return err
	}
	return nil
}

// MessageMoveReplyV2 structure represents DRS_MSG_MOVEREPLY_V2 RPC structure.
//
// The DRS_MSG_MOVEREPLY_V2 structure defines a response message received from the IDL_DRSInterDomainMove
// method.
type MessageMoveReplyV2 struct {
	// win32Error:  0 if successful, or non-zero if a fatal error occurred.
	Win32Error uint32 `idl:"name:win32Error" json:"win32_error"`
	// pAddedName:  The name of the object in its new domain.
	AddedName *DSName `idl:"name:pAddedName;pointer:unique" json:"added_name"`
}

func (o *MessageMoveReplyV2) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageMoveReplyV2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.Win32Error); err != nil {
		return err
	}
	if o.AddedName != nil {
		_ptr_pAddedName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.AddedName != nil {
				if err := o.AddedName.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSName{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.AddedName, _ptr_pAddedName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageMoveReplyV2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.Win32Error); err != nil {
		return err
	}
	_ptr_pAddedName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.AddedName == nil {
			o.AddedName = &DSName{}
		}
		if err := o.AddedName.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pAddedName := func(ptr interface{}) { o.AddedName = *ptr.(**DSName) }
	if err := w.ReadPointer(&o.AddedName, _s_pAddedName, _ptr_pAddedName); err != nil {
		return err
	}
	return nil
}

// MessageMoveReply structure represents DRS_MSG_MOVEREPLY RPC union.
//
// The DRS_MSG_MOVEREPLY union defines the response messages received from the IDL_DRSInterDomainMove
// method.
type MessageMoveReply struct {
	// Types that are assignable to Value
	//
	// *MessageMoveReply_V1
	// *MessageMoveReply_V2
	Value is_MessageMoveReply `json:"value"`
}

func (o *MessageMoveReply) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageMoveReply_V1:
		if value != nil {
			return value.V1
		}
	case *MessageMoveReply_V2:
		if value != nil {
			return value.V2
		}
	}
	return nil
}

type is_MessageMoveReply interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageMoveReply()
}

func (o *MessageMoveReply) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageMoveReply_V1:
		return uint32(1)
	case *MessageMoveReply_V2:
		return uint32(2)
	}
	return uint32(0)
}

func (o *MessageMoveReply) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageMoveReply_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageMoveReply_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(2):
		_o, _ := o.Value.(*MessageMoveReply_V2)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageMoveReply_V2{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageMoveReply) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageMoveReply_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(2):
		o.Value = &MessageMoveReply_V2{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageMoveReply_V1 structure represents DRS_MSG_MOVEREPLY RPC union arm.
//
// It has following labels: 1
type MessageMoveReply_V1 struct {
	// V1:  The version 1 response (obsolete).
	V1 *MessageMoveReplyV1 `idl:"name:V1" json:"v1"`
}

func (*MessageMoveReply_V1) is_MessageMoveReply() {}

func (o *MessageMoveReply_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageMoveReplyV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageMoveReply_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageMoveReplyV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageMoveReply_V2 structure represents DRS_MSG_MOVEREPLY RPC union arm.
//
// It has following labels: 2
type MessageMoveReply_V2 struct {
	// V2:  The version 2 response.
	V2 *MessageMoveReplyV2 `idl:"name:V2" json:"v2"`
}

func (*MessageMoveReply_V2) is_MessageMoveReply() {}

func (o *MessageMoveReply_V2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V2 != nil {
		if err := o.V2.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageMoveReplyV2{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageMoveReply_V2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V2 == nil {
		o.V2 = &MessageMoveReplyV2{}
	}
	if err := o.V2.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageCrackNamesRequestV1 structure represents DRS_MSG_CRACKREQ_V1 RPC structure.
//
// The DRS_MSG_CRACKREQ_V1 structure defines the request message sent to the IDL_DRSCrackNames
// method.
type MessageCrackNamesRequestV1 struct {
	// CodePage:  The character set used by the client. This field SHOULD be ignored by
	// the server.
	CodePage uint32 `idl:"name:CodePage" json:"code_page"`
	// LocaleId:  The locale used by the client. This field SHOULD be ignored by the server.
	LocaleID uint32 `idl:"name:LocaleId" json:"locale_id"`
	// dwFlags:  Zero or more of the following bit flags, which are presented in little-endian
	// byte order.
	//
	//	+---+---+---+---+-----+-----+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+-------+---+---+---+---+---+---+---+
	//	| 0 | 1 | 2 | 3 |  4  |  5  | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 |   4   | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
	//	|   |   |   |   |     |     |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |       |   |   |   |   |   | 0 |   |
	//	+---+---+---+---+-----+-----+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+-------+---+---+---+---+---+---+---+
	//	+---+---+---+---+-----+-----+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+-------+---+---+---+---+---+---+---+
	//	| X | X | X | X | T R | G C | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | F P O | X | X | X | X | X | X | X |
	//	+---+---+---+---+-----+-----+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+-------+---+---+---+---+---+---+---+
	//
	// X: Unused. MUST be zero and ignored.
	//
	// GC (DS_NAME_FLAG_GCVERIFY, 0x00000004): If set, the call fails if the server is not
	// a GC server.
	//
	// TR (DS_NAME_FLAG_TRUST_REFERRAL, 0x00000008): If set and the lookup fails on the
	// server, referrals are returned to trusted forests where the lookup might succeed.
	Flags uint32 `idl:"name:dwFlags" json:"flags"`
	// formatOffered:  The format of the names in rpNames. This can be one of the values
	// from DS_NAME_FORMAT (section 4.1.4.1.3) or one of the following.
	//
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                                |                                                                                  |
	//	|                     VALUE                      |                                     MEANING                                      |
	//	|                                                |                                                                                  |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| DS_LIST_SITES 0xFFFFFFFF                       | Get all sites in the forest.                                                     |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| DS_LIST_SERVERS_IN_SITE 0xFFFFFFFE             | Get all servers in a given site.                                                 |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| DS_LIST_DOMAINS_IN_SITE 0xFFFFFFFD             | Get all domains in a given site.                                                 |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| DS_LIST_SERVERS_FOR_DOMAIN_IN_SITE 0xFFFFFFFC  | Get all DCs of a specified domain in a given site.                               |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| DS_LIST_INFO_FOR_SERVER 0xFFFFFFFB             | Get DNS host name and server reference for a given DC.                           |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| DS_LIST_ROLES 0xFFFFFFFA                       | Get FSMO role owners.                                                            |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| DS_NT4_ACCOUNT_NAME_SANS_DOMAIN 0xFFFFFFF9     | Get value of sAMAccountName attribute.                                           |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| DS_MAP_SCHEMA_GUID 0xFFFFFFF8                  | Get LDAP display name from schema GUID. The given schema GUID must be in the     |
	//	|                                                | curly braced GUID string format as specified in [MS-DTYP] section 2.3.4.3.       |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| DS_LIST_DOMAINS 0xFFFFFFF7                     | Get all domains in the forest.                                                   |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| DS_LIST_NCS 0xFFFFFFF6                         | Get all NCs in the forest.                                                       |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| DS_ALT_SECURITY_IDENTITIES_NAME 0xFFFFFFF5     | Compares input names against the values of the altSecurityIdentities attribute.  |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| DS_STRING_SID_NAME 0xFFFFFFF4                  | String form of SID.                                                              |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| DS_LIST_SERVERS_WITH_DCS_IN_SITE 0xFFFFFFF3    | Get all DCs in a given site.                                                     |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| DS_LIST_GLOBAL_CATALOG_SERVERS 0xFFFFFFF1      | Get all GCs in the forest.                                                       |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| DS_NT4_ACCOUNT_NAME_SANS_DOMAIN_EX 0xFFFFFFF0  | Get value of sAMAccountName attribute; return status DS_NAME_ERROR_NOT_FOUND if  |
	//	|                                                | account is invalid.                                                              |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| DS_USER_PRINCIPAL_NAME_AND_ALTSECID 0xFFFFFFEF | Compares input names against the user principal name and the values of the       |
	//	|                                                | altSecurityIdentities attribute.                                                 |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	FormatOffered uint32 `idl:"name:formatOffered" json:"format_offered"`
	// formatDesired:  Format of the names in the rItems field of the DS_NAME_RESULTW structure,
	// which is returned inside the DRS_MSG_CRACKREPLY message. This can be one of the values
	// from DS_NAME_FORMAT or one of the following.
	//
	//	+---------------------------------------------+-----------------------+
	//	|                                             |                       |
	//	|                    VALUE                    |        MEANING        |
	//	|                                             |                       |
	//	+---------------------------------------------+-----------------------+
	//	+---------------------------------------------+-----------------------+
	//	| DS_STRING_SID_NAME 0xFFFFFFF4               | String form of a SID. |
	//	+---------------------------------------------+-----------------------+
	//	| DS_USER_PRINCIPAL_NAME_FOR_LOGON 0xFFFFFFF2 | User principal name.  |
	//	+---------------------------------------------+-----------------------+
	FormatDesired uint32 `idl:"name:formatDesired" json:"format_desired"`
	// cNames:  Count of items in the rpNames array.
	NamesCount uint32 `idl:"name:cNames" json:"names_count"`
	// rpNames:  Input names to translate.
	Names []string `idl:"name:rpNames;size_is:(cNames);string" json:"names"`
}

func (o *MessageCrackNamesRequestV1) xxx_PreparePayload(ctx context.Context) error {
	if o.Names != nil && o.NamesCount == 0 {
		o.NamesCount = uint32(len(o.Names))
	}
	if o.NamesCount < uint32(1) || o.NamesCount > uint32(10000) {
		return fmt.Errorf("NamesCount is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageCrackNamesRequestV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.CodePage); err != nil {
		return err
	}
	if err := w.WriteData(o.LocaleID); err != nil {
		return err
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	if err := w.WriteData(o.FormatOffered); err != nil {
		return err
	}
	if err := w.WriteData(o.FormatDesired); err != nil {
		return err
	}
	if err := w.WriteData(o.NamesCount); err != nil {
		return err
	}
	if o.Names != nil || o.NamesCount > 0 {
		_ptr_rpNames := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.NamesCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Names {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Names[i1] != "" {
					_ptr_rpNames := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
						if err := ndr.WriteUTF16NString(ctx, w, o.Names[i1]); err != nil {
							return err
						}
						return nil
					})
					if err := w.WritePointer(&o.Names[i1], _ptr_rpNames); err != nil {
						return err
					}
				} else {
					if err := w.WritePointer(nil); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Names); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WritePointer(nil); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Names, _ptr_rpNames); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageCrackNamesRequestV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.CodePage); err != nil {
		return err
	}
	if err := w.ReadData(&o.LocaleID); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	if err := w.ReadData(&o.FormatOffered); err != nil {
		return err
	}
	if err := w.ReadData(&o.FormatDesired); err != nil {
		return err
	}
	if err := w.ReadData(&o.NamesCount); err != nil {
		return err
	}
	_ptr_rpNames := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.NamesCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.NamesCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Names", sizeInfo[0])
		}
		o.Names = make([]string, sizeInfo[0])
		for i1 := range o.Names {
			i1 := i1
			_ptr_rpNames := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
				if err := ndr.ReadUTF16NString(ctx, w, &o.Names[i1]); err != nil {
					return err
				}
				return nil
			})
			_s_rpNames := func(ptr interface{}) { o.Names[i1] = *ptr.(*string) }
			if err := w.ReadPointer(&o.Names[i1], _s_rpNames, _ptr_rpNames); err != nil {
				return err
			}
		}
		return nil
	})
	_s_rpNames := func(ptr interface{}) { o.Names = *ptr.(*[]string) }
	if err := w.ReadPointer(&o.Names, _s_rpNames, _ptr_rpNames); err != nil {
		return err
	}
	return nil
}

// MessageCrackNamesRequest structure represents DRS_MSG_CRACKREQ RPC union.
//
// The DRS_MSG_CRACKREQ union defines the request messages sent to the IDL_DRSCrackNames
// method. Only one version, identified by dwInVersion = 1, is currently defined.
type MessageCrackNamesRequest struct {
	// Types that are assignable to Value
	//
	// *MessageCrackNamesRequest_V1
	Value is_MessageCrackNamesRequest `json:"value"`
}

func (o *MessageCrackNamesRequest) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageCrackNamesRequest_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_MessageCrackNamesRequest interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageCrackNamesRequest()
}

func (o *MessageCrackNamesRequest) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageCrackNamesRequest_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *MessageCrackNamesRequest) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageCrackNamesRequest_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageCrackNamesRequest_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageCrackNamesRequest) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageCrackNamesRequest_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageCrackNamesRequest_V1 structure represents DRS_MSG_CRACKREQ RPC union arm.
//
// It has following labels: 1
type MessageCrackNamesRequest_V1 struct {
	// V1:  Version 1 request.
	V1 *MessageCrackNamesRequestV1 `idl:"name:V1" json:"v1"`
}

func (*MessageCrackNamesRequest_V1) is_MessageCrackNamesRequest() {}

func (o *MessageCrackNamesRequest_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageCrackNamesRequestV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageCrackNamesRequest_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageCrackNamesRequestV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageCrackNamesReplyV1 structure represents DRS_MSG_CRACKREPLY_V1 RPC structure.
//
// The DRS_MSG_CRACKREPLY_V1 structure defines the response message received from the
// IDL_DRSCrackNames method.
type MessageCrackNamesReplyV1 struct {
	// pResult:  Translated form of the names.
	Result *DSNameResult `idl:"name:pResult" json:"result"`
}

func (o *MessageCrackNamesReplyV1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageCrackNamesReplyV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(6); err != nil {
		return err
	}
	if o.Result != nil {
		_ptr_pResult := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Result != nil {
				if err := o.Result.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSNameResult{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Result, _ptr_pResult); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageCrackNamesReplyV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(6); err != nil {
		return err
	}
	_ptr_pResult := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Result == nil {
			o.Result = &DSNameResult{}
		}
		if err := o.Result.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pResult := func(ptr interface{}) { o.Result = *ptr.(**DSNameResult) }
	if err := w.ReadPointer(&o.Result, _s_pResult, _ptr_pResult); err != nil {
		return err
	}
	return nil
}

// MessageCrackNamesReply structure represents DRS_MSG_CRACKREPLY RPC union.
//
// The DRS_MSG_CRACKREPLY union defines the response messages received from the IDL_DRSCrackNames
// method.
type MessageCrackNamesReply struct {
	// Types that are assignable to Value
	//
	// *MessageCrackNamesReply_V1
	Value is_MessageCrackNamesReply `json:"value"`
}

func (o *MessageCrackNamesReply) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageCrackNamesReply_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_MessageCrackNamesReply interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageCrackNamesReply()
}

func (o *MessageCrackNamesReply) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageCrackNamesReply_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *MessageCrackNamesReply) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageCrackNamesReply_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageCrackNamesReply_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageCrackNamesReply) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageCrackNamesReply_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageCrackNamesReply_V1 structure represents DRS_MSG_CRACKREPLY RPC union arm.
//
// It has following labels: 1
type MessageCrackNamesReply_V1 struct {
	// V1:  Version 1 reply.
	V1 *MessageCrackNamesReplyV1 `idl:"name:V1" json:"v1"`
}

func (*MessageCrackNamesReply_V1) is_MessageCrackNamesReply() {}

func (o *MessageCrackNamesReply_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageCrackNamesReplyV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageCrackNamesReply_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageCrackNamesReplyV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageNT4ChangeLogRequestV1 structure represents DRS_MSG_NT4_CHGLOG_REQ_V1 RPC structure.
//
// The DRS_MSG_NT4_CHGLOG_REQ_V1 structure defines the request message sent to the IDL_DRSGetNT4ChangeLog
// method.
type MessageNT4ChangeLogRequestV1 struct {
	// dwFlags:  Zero or more of the following bit flags, which are presented in little-endian
	// byte order:
	//
	//	+---+---+---+---+---+---+-----+-----+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 1 | 2 | 3 | 4 | 5 |  6  |  7  | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
	//	|   |   |   |   |   |   |     |     |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
	//	+---+---+---+---+---+---+-----+-----+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	+---+---+---+---+---+---+-----+-----+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| X | X | X | X | X | X | S N | C L | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X |
	//	+---+---+---+---+---+---+-----+-----+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//
	// X: Unused. MUST be zero and ignored.
	//
	// CL (DRS_NT4_CHGLOG_GET_CHANGE_LOG, 0x00000001): If set, the server returns the PDC
	// change log.
	Flags uint32 `idl:"name:dwFlags" json:"flags"`
	// PreferredMaximumLength:  The maximum size, in bytes, of the change log data that
	// is to be retrieved in a single operation.
	PreferredMaximumLength uint32 `idl:"name:PreferredMaximumLength" json:"preferred_maximum_length"`
	// cbRestart: Zero if pRestart = null. Otherwise, the size, in bytes, of pRestart^.
	RestartLength uint32 `idl:"name:cbRestart" json:"restart_length"`
	// pRestart: Null to request the change log from the beginning. Otherwise, a pointer
	// to an opaque value, returned in some previous call to IDL_DRSGetNT4ChangeLog, identifying
	// the last change log entry returned in that previous call.
	Restart []byte `idl:"name:pRestart;size_is:(cbRestart)" json:"restart"`
}

func (o *MessageNT4ChangeLogRequestV1) xxx_PreparePayload(ctx context.Context) error {
	if o.Restart != nil && o.RestartLength == 0 {
		o.RestartLength = uint32(len(o.Restart))
	}
	if o.RestartLength > uint32(10485760) {
		return fmt.Errorf("RestartLength is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageNT4ChangeLogRequestV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	if err := w.WriteData(o.PreferredMaximumLength); err != nil {
		return err
	}
	if err := w.WriteData(o.RestartLength); err != nil {
		return err
	}
	if o.Restart != nil || o.RestartLength > 0 {
		_ptr_pRestart := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.RestartLength)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Restart {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.Restart[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.Restart); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Restart, _ptr_pRestart); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageNT4ChangeLogRequestV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	if err := w.ReadData(&o.PreferredMaximumLength); err != nil {
		return err
	}
	if err := w.ReadData(&o.RestartLength); err != nil {
		return err
	}
	_ptr_pRestart := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.RestartLength > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.RestartLength)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Restart", sizeInfo[0])
		}
		o.Restart = make([]byte, sizeInfo[0])
		for i1 := range o.Restart {
			i1 := i1
			if err := w.ReadData(&o.Restart[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_pRestart := func(ptr interface{}) { o.Restart = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.Restart, _s_pRestart, _ptr_pRestart); err != nil {
		return err
	}
	return nil
}

// MessageNT4ChangeLogRequest structure represents DRS_MSG_NT4_CHGLOG_REQ RPC union.
//
// The DRS_MSG_NT4_CHGLOG_REQ_V1 structure defines the request message sent to the IDL_DRSGetNT4ChangeLog
// method.
type MessageNT4ChangeLogRequest struct {
	// Types that are assignable to Value
	//
	// *MessageNT4ChangeLogRequest_V1
	Value is_MessageNT4ChangeLogRequest `json:"value"`
}

func (o *MessageNT4ChangeLogRequest) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageNT4ChangeLogRequest_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_MessageNT4ChangeLogRequest interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageNT4ChangeLogRequest()
}

func (o *MessageNT4ChangeLogRequest) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageNT4ChangeLogRequest_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *MessageNT4ChangeLogRequest) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageNT4ChangeLogRequest_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageNT4ChangeLogRequest_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageNT4ChangeLogRequest) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageNT4ChangeLogRequest_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageNT4ChangeLogRequest_V1 structure represents DRS_MSG_NT4_CHGLOG_REQ RPC union arm.
//
// It has following labels: 1
type MessageNT4ChangeLogRequest_V1 struct {
	V1 *MessageNT4ChangeLogRequestV1 `idl:"name:V1" json:"v1"`
}

func (*MessageNT4ChangeLogRequest_V1) is_MessageNT4ChangeLogRequest() {}

func (o *MessageNT4ChangeLogRequest_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageNT4ChangeLogRequestV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageNT4ChangeLogRequest_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageNT4ChangeLogRequestV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// NT4ReplicationState structure represents NT4_REPLICATION_STATE RPC structure.
//
// The NT4_REPLICATION_STATE structure defines the replication state for Windows NT
// 4.0 operating system DCs, whose interpretation is specified in [MS-ADTS] section
// 3.1.1.7.1.
type NT4ReplicationState struct {
	// SamSerialNumber:  The Windows NT 4.0 replication update sequence number for the SAM
	// database.
	SAMSerialNumber *dtyp.LargeInteger `idl:"name:SamSerialNumber" json:"sam_serial_number"`
	// SamCreationTime:  The time at which the Windows NT 4.0 replication update sequence
	// number for the SAM database was set to 1.
	SAMCreationTime *dtyp.LargeInteger `idl:"name:SamCreationTime" json:"sam_creation_time"`
	// BuiltinSerialNumber:  The Windows NT 4.0 replication update sequence number for the
	// built-in database.
	BuiltinSerialNumber *dtyp.LargeInteger `idl:"name:BuiltinSerialNumber" json:"builtin_serial_number"`
	// BuiltinCreationTime:  The time at which the Windows NT 4.0 replication update sequence
	// number for the built-in database was set to 1.
	BuiltinCreationTime *dtyp.LargeInteger `idl:"name:BuiltinCreationTime" json:"builtin_creation_time"`
	// LsaSerialNumber:  The Windows NT 4.0 replication update sequence number for the local
	// security authority (LSA) database.
	LSASerialNumber *dtyp.LargeInteger `idl:"name:LsaSerialNumber" json:"lsa_serial_number"`
	// LsaCreationTime:  The time at which the Windows NT 4.0 replication update sequence
	// number for the LSA database was set to 1.
	LSACreationTime *dtyp.LargeInteger `idl:"name:LsaCreationTime" json:"lsa_creation_time"`
}

func (o *NT4ReplicationState) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *NT4ReplicationState) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if o.SAMSerialNumber != nil {
		if err := o.SAMSerialNumber.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.LargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.SAMCreationTime != nil {
		if err := o.SAMCreationTime.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.LargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.BuiltinSerialNumber != nil {
		if err := o.BuiltinSerialNumber.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.LargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.BuiltinCreationTime != nil {
		if err := o.BuiltinCreationTime.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.LargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.LSASerialNumber != nil {
		if err := o.LSASerialNumber.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.LargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.LSACreationTime != nil {
		if err := o.LSACreationTime.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.LargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *NT4ReplicationState) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if o.SAMSerialNumber == nil {
		o.SAMSerialNumber = &dtyp.LargeInteger{}
	}
	if err := o.SAMSerialNumber.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.SAMCreationTime == nil {
		o.SAMCreationTime = &dtyp.LargeInteger{}
	}
	if err := o.SAMCreationTime.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.BuiltinSerialNumber == nil {
		o.BuiltinSerialNumber = &dtyp.LargeInteger{}
	}
	if err := o.BuiltinSerialNumber.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.BuiltinCreationTime == nil {
		o.BuiltinCreationTime = &dtyp.LargeInteger{}
	}
	if err := o.BuiltinCreationTime.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.LSASerialNumber == nil {
		o.LSASerialNumber = &dtyp.LargeInteger{}
	}
	if err := o.LSASerialNumber.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.LSACreationTime == nil {
		o.LSACreationTime = &dtyp.LargeInteger{}
	}
	if err := o.LSACreationTime.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageNT4ChangeLogReplyV1 structure represents DRS_MSG_NT4_CHGLOG_REPLY_V1 RPC structure.
//
// The DRS_MSG_NT4_CHGLOG_REPLY_V1 structure defines the response message received from
// the IDL_DRSGetNT4ChangeLog method.
type MessageNT4ChangeLogReplyV1 struct {
	// cbRestart:  Zero if pRestart = null. Otherwise, the size, in bytes, of pRestart^.
	RestartLength uint32 `idl:"name:cbRestart" json:"restart_length"`
	// cbLog:  Zero if pRestart = null. Otherwise, the size, in bytes, of pLog^.
	LogLength uint32 `idl:"name:cbLog" json:"log_length"`
	// ReplicationState:  The replication state for Windows NT 4.0 operating system DCs.
	ReplicationState *NT4ReplicationState `idl:"name:ReplicationState" json:"replication_state"`
	// ActualNtStatus:  A STATUS code. See the pseudo-code for interpretation.
	ActualNTStatus uint32 `idl:"name:ActualNtStatus" json:"actual_nt_status"`
	// pRestart:  Null if no entries were returned. Otherwise, a pointer to an opaque value
	// identifying the last entry returned in pLog.
	Restart []byte `idl:"name:pRestart;size_is:(cbRestart)" json:"restart"`
	// pLog:  The buffer containing the next entries from the change log.
	Log []byte `idl:"name:pLog;size_is:(cbLog)" json:"log"`
}

func (o *MessageNT4ChangeLogReplyV1) xxx_PreparePayload(ctx context.Context) error {
	if o.Restart != nil && o.RestartLength == 0 {
		o.RestartLength = uint32(len(o.Restart))
	}
	if o.Log != nil && o.LogLength == 0 {
		o.LogLength = uint32(len(o.Log))
	}
	if o.RestartLength > uint32(10485760) {
		return fmt.Errorf("RestartLength is out of range")
	}
	if o.LogLength > uint32(10485760) {
		return fmt.Errorf("LogLength is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageNT4ChangeLogReplyV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if err := w.WriteData(o.RestartLength); err != nil {
		return err
	}
	if err := w.WriteData(o.LogLength); err != nil {
		return err
	}
	if o.ReplicationState != nil {
		if err := o.ReplicationState.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&NT4ReplicationState{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.ActualNTStatus); err != nil {
		return err
	}
	if o.Restart != nil || o.RestartLength > 0 {
		_ptr_pRestart := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.RestartLength)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Restart {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.Restart[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.Restart); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Restart, _ptr_pRestart); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.Log != nil || o.LogLength > 0 {
		_ptr_pLog := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.LogLength)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Log {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.Log[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.Log); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Log, _ptr_pLog); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageNT4ChangeLogReplyV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if err := w.ReadData(&o.RestartLength); err != nil {
		return err
	}
	if err := w.ReadData(&o.LogLength); err != nil {
		return err
	}
	if o.ReplicationState == nil {
		o.ReplicationState = &NT4ReplicationState{}
	}
	if err := o.ReplicationState.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.ActualNTStatus); err != nil {
		return err
	}
	_ptr_pRestart := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.RestartLength > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.RestartLength)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Restart", sizeInfo[0])
		}
		o.Restart = make([]byte, sizeInfo[0])
		for i1 := range o.Restart {
			i1 := i1
			if err := w.ReadData(&o.Restart[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_pRestart := func(ptr interface{}) { o.Restart = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.Restart, _s_pRestart, _ptr_pRestart); err != nil {
		return err
	}
	_ptr_pLog := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.LogLength > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.LogLength)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Log", sizeInfo[0])
		}
		o.Log = make([]byte, sizeInfo[0])
		for i1 := range o.Log {
			i1 := i1
			if err := w.ReadData(&o.Log[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_pLog := func(ptr interface{}) { o.Log = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.Log, _s_pLog, _ptr_pLog); err != nil {
		return err
	}
	return nil
}

// MessageNT4ChangeLogReply structure represents DRS_MSG_NT4_CHGLOG_REPLY RPC union.
//
// The DRS_MSG_NT4_CHGLOG_REPLY union defines the response messages received from the
// IDL_DRSGetNT4ChangeLog method. Only one version, identified by pdwOutVersion^ = 1,
// is currently defined.
type MessageNT4ChangeLogReply struct {
	// Types that are assignable to Value
	//
	// *MessageNT4ChangeLogReply_V1
	Value is_MessageNT4ChangeLogReply `json:"value"`
}

func (o *MessageNT4ChangeLogReply) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageNT4ChangeLogReply_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_MessageNT4ChangeLogReply interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageNT4ChangeLogReply()
}

func (o *MessageNT4ChangeLogReply) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageNT4ChangeLogReply_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *MessageNT4ChangeLogReply) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(8); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(8); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageNT4ChangeLogReply_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageNT4ChangeLogReply_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageNT4ChangeLogReply) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(8); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(8); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageNT4ChangeLogReply_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageNT4ChangeLogReply_V1 structure represents DRS_MSG_NT4_CHGLOG_REPLY RPC union arm.
//
// It has following labels: 1
type MessageNT4ChangeLogReply_V1 struct {
	// V1:  The version 1 reply.
	V1 *MessageNT4ChangeLogReplyV1 `idl:"name:V1" json:"v1"`
}

func (*MessageNT4ChangeLogReply_V1) is_MessageNT4ChangeLogReply() {}

func (o *MessageNT4ChangeLogReply_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageNT4ChangeLogReplyV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageNT4ChangeLogReply_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageNT4ChangeLogReplyV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageWriteSPNRequestV1 structure represents DRS_MSG_SPNREQ_V1 RPC structure.
//
// The DRS_MSG_SPNREQ_V1 structure defines a request message sent to the IDL_DRSWriteSPN
// method.
type MessageWriteSPNRequestV1 struct {
	// operation:  The SPN operation to perform. MUST be one of the DS_SPN_OPERATION values.
	Operation uint32 `idl:"name:operation" json:"operation"`
	// flags:  Unused. MUST be 0 and ignored.
	Flags uint32 `idl:"name:flags" json:"flags"`
	// pwszAccount:  The DN of the object to modify.
	Account string `idl:"name:pwszAccount;string" json:"account"`
	// cSPN:  The number of items in the rpwszSPN array.
	SPNCount uint32 `idl:"name:cSPN" json:"spn_count"`
	// rpwszSPN:  The SPN values.
	SPN []string `idl:"name:rpwszSPN;size_is:(cSPN);string" json:"spn"`
}

func (o *MessageWriteSPNRequestV1) xxx_PreparePayload(ctx context.Context) error {
	if o.SPN != nil && o.SPNCount == 0 {
		o.SPNCount = uint32(len(o.SPN))
	}
	if o.SPNCount > uint32(10000) {
		return fmt.Errorf("SPNCount is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageWriteSPNRequestV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.Operation); err != nil {
		return err
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	if o.Account != "" {
		_ptr_pwszAccount := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Account); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Account, _ptr_pwszAccount); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.SPNCount); err != nil {
		return err
	}
	if o.SPN != nil || o.SPNCount > 0 {
		_ptr_rpwszSPN := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.SPNCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.SPN {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.SPN[i1] != "" {
					_ptr_rpwszSPN := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
						if err := ndr.WriteUTF16NString(ctx, w, o.SPN[i1]); err != nil {
							return err
						}
						return nil
					})
					if err := w.WritePointer(&o.SPN[i1], _ptr_rpwszSPN); err != nil {
						return err
					}
				} else {
					if err := w.WritePointer(nil); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.SPN); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WritePointer(nil); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.SPN, _ptr_rpwszSPN); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageWriteSPNRequestV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.Operation); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	_ptr_pwszAccount := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Account); err != nil {
			return err
		}
		return nil
	})
	_s_pwszAccount := func(ptr interface{}) { o.Account = *ptr.(*string) }
	if err := w.ReadPointer(&o.Account, _s_pwszAccount, _ptr_pwszAccount); err != nil {
		return err
	}
	if err := w.ReadData(&o.SPNCount); err != nil {
		return err
	}
	_ptr_rpwszSPN := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.SPNCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.SPNCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.SPN", sizeInfo[0])
		}
		o.SPN = make([]string, sizeInfo[0])
		for i1 := range o.SPN {
			i1 := i1
			_ptr_rpwszSPN := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
				if err := ndr.ReadUTF16NString(ctx, w, &o.SPN[i1]); err != nil {
					return err
				}
				return nil
			})
			_s_rpwszSPN := func(ptr interface{}) { o.SPN[i1] = *ptr.(*string) }
			if err := w.ReadPointer(&o.SPN[i1], _s_rpwszSPN, _ptr_rpwszSPN); err != nil {
				return err
			}
		}
		return nil
	})
	_s_rpwszSPN := func(ptr interface{}) { o.SPN = *ptr.(*[]string) }
	if err := w.ReadPointer(&o.SPN, _s_rpwszSPN, _ptr_rpwszSPN); err != nil {
		return err
	}
	return nil
}

// MessageWriteSPNRequest structure represents DRS_MSG_SPNREQ RPC union.
//
// The DRS_MSG_SPNREQ union defines the request messages sent to the IDL_DRSWriteSPN
// method. Only one version, identified by dwInVersion = 1, is currently defined.
type MessageWriteSPNRequest struct {
	// Types that are assignable to Value
	//
	// *MessageWriteSPNRequest_V1
	Value is_MessageWriteSPNRequest `json:"value"`
}

func (o *MessageWriteSPNRequest) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageWriteSPNRequest_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_MessageWriteSPNRequest interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageWriteSPNRequest()
}

func (o *MessageWriteSPNRequest) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageWriteSPNRequest_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *MessageWriteSPNRequest) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageWriteSPNRequest_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageWriteSPNRequest_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageWriteSPNRequest) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageWriteSPNRequest_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageWriteSPNRequest_V1 structure represents DRS_MSG_SPNREQ RPC union arm.
//
// It has following labels: 1
type MessageWriteSPNRequest_V1 struct {
	// V1:  The version 1 request.
	V1 *MessageWriteSPNRequestV1 `idl:"name:V1" json:"v1"`
}

func (*MessageWriteSPNRequest_V1) is_MessageWriteSPNRequest() {}

func (o *MessageWriteSPNRequest_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageWriteSPNRequestV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageWriteSPNRequest_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageWriteSPNRequestV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageWriteSPNReplyV1 structure represents DRS_MSG_SPNREPLY_V1 RPC structure.
//
// The DRS_MSG_SPNREPLY_V1 structure defines a response message received from the IDL_DRSWriteSPN
// method.
type MessageWriteSPNReplyV1 struct {
	// retVal:  0, or a Windows error code.
	ReturnValue uint32 `idl:"name:retVal" json:"return_value"`
}

func (o *MessageWriteSPNReplyV1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageWriteSPNReplyV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.ReturnValue); err != nil {
		return err
	}
	return nil
}
func (o *MessageWriteSPNReplyV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.ReturnValue); err != nil {
		return err
	}
	return nil
}

// MessageWriteSPNReply structure represents DRS_MSG_SPNREPLY RPC union.
//
// The DRS_MSG_SPNREPLY union defines the response messages received from the IDL_DRSWriteSPN
// method. Only one version, identified by pdwOutVersion^ = 1, is currently defined.
type MessageWriteSPNReply struct {
	// Types that are assignable to Value
	//
	// *MessageWriteSPNReply_V1
	Value is_MessageWriteSPNReply `json:"value"`
}

func (o *MessageWriteSPNReply) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageWriteSPNReply_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_MessageWriteSPNReply interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageWriteSPNReply()
}

func (o *MessageWriteSPNReply) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageWriteSPNReply_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *MessageWriteSPNReply) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(4); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(4); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageWriteSPNReply_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageWriteSPNReply_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageWriteSPNReply) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(4); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(4); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageWriteSPNReply_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageWriteSPNReply_V1 structure represents DRS_MSG_SPNREPLY RPC union arm.
//
// It has following labels: 1
type MessageWriteSPNReply_V1 struct {
	// V1:  The version 1 response.
	V1 *MessageWriteSPNReplyV1 `idl:"name:V1" json:"v1"`
}

func (*MessageWriteSPNReply_V1) is_MessageWriteSPNReply() {}

func (o *MessageWriteSPNReply_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageWriteSPNReplyV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageWriteSPNReply_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageWriteSPNReplyV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageRemoveServerRequestV1 structure represents DRS_MSG_RMSVRREQ_V1 RPC structure.
//
// The DRS_MSG_RMSVRREQ_V1 structure defines a request message sent to the IDL_DRSRemoveDsServer
// method.
type MessageRemoveServerRequestV1 struct {
	// ServerDN:  The DN of the server object of the DC to remove.
	ServerDN string `idl:"name:ServerDN;string" json:"server_dn"`
	// DomainDN:  The DN of the NC root of the domain that the DC to be removed belongs
	// to. Can be set to null if the client does not want the server to compute the value
	// of pmsgOut^.V1.fLastDCInDomain.
	DomainDN string `idl:"name:DomainDN;string" json:"domain_dn"`
	// fCommit:  True if the DC's metadata should actually be removed from the directory.
	// False if the metadata should not be removed. (This is used by a client that wants
	// to determine the value of pmsgOut^.V1.fLastDcInDomain without altering the directory.)
	Commit bool `idl:"name:fCommit" json:"commit"`
}

func (o *MessageRemoveServerRequestV1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageRemoveServerRequestV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.ServerDN != "" {
		_ptr_ServerDN := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.ServerDN); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerDN, _ptr_ServerDN); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.DomainDN != "" {
		_ptr_DomainDN := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.DomainDN); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.DomainDN, _ptr_DomainDN); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if !o.Commit {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageRemoveServerRequestV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_ServerDN := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.ServerDN); err != nil {
			return err
		}
		return nil
	})
	_s_ServerDN := func(ptr interface{}) { o.ServerDN = *ptr.(*string) }
	if err := w.ReadPointer(&o.ServerDN, _s_ServerDN, _ptr_ServerDN); err != nil {
		return err
	}
	_ptr_DomainDN := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.DomainDN); err != nil {
			return err
		}
		return nil
	})
	_s_DomainDN := func(ptr interface{}) { o.DomainDN = *ptr.(*string) }
	if err := w.ReadPointer(&o.DomainDN, _s_DomainDN, _ptr_DomainDN); err != nil {
		return err
	}
	var _bCommit int32
	if err := w.ReadData(&_bCommit); err != nil {
		return err
	}
	o.Commit = _bCommit != 0
	return nil
}

// MessageRemoveServerRequest structure represents DRS_MSG_RMSVRREQ RPC union.
//
// The DRS_MSG_RMSVRREQ union defines the request messages sent to the IDL_DRSRemoveDsServer
// method. Only one version, identified by dwInVersion = 1, is currently defined.
type MessageRemoveServerRequest struct {
	// Types that are assignable to Value
	//
	// *MessageRemoveServerRequest_V1
	Value is_MessageRemoveServerRequest `json:"value"`
}

func (o *MessageRemoveServerRequest) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageRemoveServerRequest_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_MessageRemoveServerRequest interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageRemoveServerRequest()
}

func (o *MessageRemoveServerRequest) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageRemoveServerRequest_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *MessageRemoveServerRequest) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageRemoveServerRequest_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageRemoveServerRequest_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageRemoveServerRequest) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageRemoveServerRequest_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageRemoveServerRequest_V1 structure represents DRS_MSG_RMSVRREQ RPC union arm.
//
// It has following labels: 1
type MessageRemoveServerRequest_V1 struct {
	// V1:  The version 1 request.
	V1 *MessageRemoveServerRequestV1 `idl:"name:V1" json:"v1"`
}

func (*MessageRemoveServerRequest_V1) is_MessageRemoveServerRequest() {}

func (o *MessageRemoveServerRequest_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageRemoveServerRequestV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageRemoveServerRequest_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageRemoveServerRequestV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageRemoveServerReplyV1 structure represents DRS_MSG_RMSVRREPLY_V1 RPC structure.
//
// The DRS_MSG_RMSVRREPLY_V1 structure defines a response message received from the
// IDL_DRSRemoveDsServer method. Only one version, identified by pdwOutVersion^ = 1,
// is currently defined.
type MessageRemoveServerReplyV1 struct {
	// fLastDcInDomain:  True if the DC is the last DC in its domain, and pmsgIn^.V1.DomainDN
	// was set to the DN of the NC root of the domain to which the DC belongs. Otherwise,
	// false.
	LastDCInDomain bool `idl:"name:fLastDcInDomain" json:"last_dc_in_domain"`
}

func (o *MessageRemoveServerReplyV1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageRemoveServerReplyV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if !o.LastDCInDomain {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageRemoveServerReplyV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	var _bLastDCInDomain int32
	if err := w.ReadData(&_bLastDCInDomain); err != nil {
		return err
	}
	o.LastDCInDomain = _bLastDCInDomain != 0
	return nil
}

// MessageRemoveServerReply structure represents DRS_MSG_RMSVRREPLY RPC union.
//
// The DRS_MSG_RMSVRREPLY union defines the response messages received from the IDL_DRSRemoveDsServer
// method.
type MessageRemoveServerReply struct {
	// Types that are assignable to Value
	//
	// *MessageRemoveServerReply_V1
	Value is_MessageRemoveServerReply `json:"value"`
}

func (o *MessageRemoveServerReply) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageRemoveServerReply_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_MessageRemoveServerReply interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageRemoveServerReply()
}

func (o *MessageRemoveServerReply) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageRemoveServerReply_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *MessageRemoveServerReply) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(4); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(4); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageRemoveServerReply_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageRemoveServerReply_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageRemoveServerReply) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(4); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(4); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageRemoveServerReply_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageRemoveServerReply_V1 structure represents DRS_MSG_RMSVRREPLY RPC union arm.
//
// It has following labels: 1
type MessageRemoveServerReply_V1 struct {
	// V1:  The version 1 response.
	V1 *MessageRemoveServerReplyV1 `idl:"name:V1" json:"v1"`
}

func (*MessageRemoveServerReply_V1) is_MessageRemoveServerReply() {}

func (o *MessageRemoveServerReply_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageRemoveServerReplyV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageRemoveServerReply_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageRemoveServerReplyV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageRemoveDSDomainRequestV1 structure represents DRS_MSG_RMDMNREQ_V1 RPC structure.
//
// The DRS_MSG_RMDMNREQ_V1 structure defines a request message sent to the IDL_DRSRemoveDsDomain
// method.
type MessageRemoveDSDomainRequestV1 struct {
	// DomainDN:  The DN of the NC root of the domain NC to remove.
	DomainDN string `idl:"name:DomainDN;string" json:"domain_dn"`
}

func (o *MessageRemoveDSDomainRequestV1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageRemoveDSDomainRequestV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(6); err != nil {
		return err
	}
	if o.DomainDN != "" {
		_ptr_DomainDN := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.DomainDN); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.DomainDN, _ptr_DomainDN); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageRemoveDSDomainRequestV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(6); err != nil {
		return err
	}
	_ptr_DomainDN := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.DomainDN); err != nil {
			return err
		}
		return nil
	})
	_s_DomainDN := func(ptr interface{}) { o.DomainDN = *ptr.(*string) }
	if err := w.ReadPointer(&o.DomainDN, _s_DomainDN, _ptr_DomainDN); err != nil {
		return err
	}
	return nil
}

// MessageRemoveDSDomainRequest structure represents DRS_MSG_RMDMNREQ RPC union.
//
// The DRS_MSG_RMDMNREQ union defines the request messages sent to the IDL_DRSRemoveDsDomain
// method. Only one version, identified by dwInVersion = 1, is currently defined.
type MessageRemoveDSDomainRequest struct {
	// Types that are assignable to Value
	//
	// *MessageRemoveDSDomainRequest_V1
	Value is_MessageRemoveDSDomainRequest `json:"value"`
}

func (o *MessageRemoveDSDomainRequest) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageRemoveDSDomainRequest_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_MessageRemoveDSDomainRequest interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageRemoveDSDomainRequest()
}

func (o *MessageRemoveDSDomainRequest) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageRemoveDSDomainRequest_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *MessageRemoveDSDomainRequest) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageRemoveDSDomainRequest_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageRemoveDSDomainRequest_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageRemoveDSDomainRequest) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageRemoveDSDomainRequest_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageRemoveDSDomainRequest_V1 structure represents DRS_MSG_RMDMNREQ RPC union arm.
//
// It has following labels: 1
type MessageRemoveDSDomainRequest_V1 struct {
	// V1:  The version 1 request.
	V1 *MessageRemoveDSDomainRequestV1 `idl:"name:V1" json:"v1"`
}

func (*MessageRemoveDSDomainRequest_V1) is_MessageRemoveDSDomainRequest() {}

func (o *MessageRemoveDSDomainRequest_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageRemoveDSDomainRequestV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageRemoveDSDomainRequest_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageRemoveDSDomainRequestV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageRemoveDSDomainReplyV1 structure represents DRS_MSG_RMDMNREPLY_V1 RPC structure.
//
// The DRS_MSG_RMDMNREPLY_V1 structure defines a response message received from the
// IDL_DRSRemoveDsDomain method.
type MessageRemoveDSDomainReplyV1 struct {
	// Reserved:  Unused. MUST be 0 and ignored.
	_ uint32 `idl:"name:Reserved"`
}

func (o *MessageRemoveDSDomainReplyV1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageRemoveDSDomainReplyV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	// reserved Reserved
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	return nil
}
func (o *MessageRemoveDSDomainReplyV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	// reserved Reserved
	var _Reserved uint32
	if err := w.ReadData(&_Reserved); err != nil {
		return err
	}
	return nil
}

// MessageRemoveDSDomainReply structure represents DRS_MSG_RMDMNREPLY RPC union.
//
// The DRS_MSG_RMDMNREPLY union defines the response messages received from the IDL_DRSRemoveDsDomain
// method. Only one version, identified by pdwOutVersion^ = 1, is currently defined.
type MessageRemoveDSDomainReply struct {
	// Types that are assignable to Value
	//
	// *MessageRemoveDSDomainReply_V1
	Value is_MessageRemoveDSDomainReply `json:"value"`
}

func (o *MessageRemoveDSDomainReply) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageRemoveDSDomainReply_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_MessageRemoveDSDomainReply interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageRemoveDSDomainReply()
}

func (o *MessageRemoveDSDomainReply) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageRemoveDSDomainReply_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *MessageRemoveDSDomainReply) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(4); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(4); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageRemoveDSDomainReply_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageRemoveDSDomainReply_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageRemoveDSDomainReply) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(4); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(4); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageRemoveDSDomainReply_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageRemoveDSDomainReply_V1 structure represents DRS_MSG_RMDMNREPLY RPC union arm.
//
// It has following labels: 1
type MessageRemoveDSDomainReply_V1 struct {
	// V1:  The version 1 response.
	V1 *MessageRemoveDSDomainReplyV1 `idl:"name:V1" json:"v1"`
}

func (*MessageRemoveDSDomainReply_V1) is_MessageRemoveDSDomainReply() {}

func (o *MessageRemoveDSDomainReply_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageRemoveDSDomainReplyV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageRemoveDSDomainReply_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageRemoveDSDomainReplyV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageDCInfoRequestV1 structure represents DRS_MSG_DCINFOREQ_V1 RPC structure.
//
// The DRS_MSG_DCINFOREQ_V1 structure defines the request message sent to the IDL_DRSDomainControllerInfo
// method.
type MessageDCInfoRequestV1 struct {
	// Domain:  The domain for which the client requests information. The domain can be
	// an FQDN (1) or a NetBIOS domain name.
	Domain string `idl:"name:Domain;string" json:"domain"`
	// InfoLevel:  The response version requested by the client: 1, 2, 3, or 0xFFFFFFFF.
	// The responses at InfoLevel 1, 2, and 3 all contain information about DCs in the given
	// domain. The information at InfoLevel 1 is a subset of the information at InfoLevel
	// 2, which is a subset of the information at InfoLevel 3. InfoLevel 3 includes information
	// about the RODCs in the given domain. InfoLevel 0xFFFFFFFF server returns information
	// about the active LDAP connections.
	InfoLevel uint32 `idl:"name:InfoLevel" json:"info_level"`
}

func (o *MessageDCInfoRequestV1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageDCInfoRequestV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.Domain != "" {
		_ptr_Domain := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Domain); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Domain, _ptr_Domain); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.InfoLevel); err != nil {
		return err
	}
	return nil
}
func (o *MessageDCInfoRequestV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_Domain := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Domain); err != nil {
			return err
		}
		return nil
	})
	_s_Domain := func(ptr interface{}) { o.Domain = *ptr.(*string) }
	if err := w.ReadPointer(&o.Domain, _s_Domain, _ptr_Domain); err != nil {
		return err
	}
	if err := w.ReadData(&o.InfoLevel); err != nil {
		return err
	}
	return nil
}

// MessageDCInfoRequest structure represents DRS_MSG_DCINFOREQ RPC union.
//
// The DRS_MSG_DCINFOREQ union defines the request messages sent to the IDL_DRSDomainControllerInfo
// method. Only one version, identified by dwInVersion = 1, is currently defined.
type MessageDCInfoRequest struct {
	// Types that are assignable to Value
	//
	// *MessageDCInfoRequest_V1
	Value is_MessageDCInfoRequest `json:"value"`
}

func (o *MessageDCInfoRequest) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageDCInfoRequest_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_MessageDCInfoRequest interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageDCInfoRequest()
}

func (o *MessageDCInfoRequest) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageDCInfoRequest_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *MessageDCInfoRequest) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageDCInfoRequest_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageDCInfoRequest_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageDCInfoRequest) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageDCInfoRequest_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageDCInfoRequest_V1 structure represents DRS_MSG_DCINFOREQ RPC union arm.
//
// It has following labels: 1
type MessageDCInfoRequest_V1 struct {
	// V1:  Version 1 request.
	V1 *MessageDCInfoRequestV1 `idl:"name:V1" json:"v1"`
}

func (*MessageDCInfoRequest_V1) is_MessageDCInfoRequest() {}

func (o *MessageDCInfoRequest_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageDCInfoRequestV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageDCInfoRequest_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageDCInfoRequestV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageDCInfoReplyV1 structure represents DRS_MSG_DCINFOREPLY_V1 RPC structure.
//
// The DRS_MSG_DCINFOREPLY_V1 structure defines the response message received from the
// IDL_DRSDomainControllerInfo method, when the client has requested InfoLevel = 1.
type MessageDCInfoReplyV1 struct {
	// cItems:  Count of items in the rItems array.
	ItemsCount uint32 `idl:"name:cItems" json:"items_count"`
	// rItems:  DC information.
	Items []*DSDomainControllerInfoV1 `idl:"name:rItems;size_is:(cItems)" json:"items"`
}

func (o *MessageDCInfoReplyV1) xxx_PreparePayload(ctx context.Context) error {
	if o.Items != nil && o.ItemsCount == 0 {
		o.ItemsCount = uint32(len(o.Items))
	}
	if o.ItemsCount > uint32(10000) {
		return fmt.Errorf("ItemsCount is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageDCInfoReplyV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.ItemsCount); err != nil {
		return err
	}
	if o.Items != nil || o.ItemsCount > 0 {
		_ptr_rItems := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.ItemsCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Items {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Items[i1] != nil {
					if err := o.Items[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&DSDomainControllerInfoV1{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Items); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&DSDomainControllerInfoV1{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Items, _ptr_rItems); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageDCInfoReplyV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.ItemsCount); err != nil {
		return err
	}
	_ptr_rItems := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.ItemsCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.ItemsCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Items", sizeInfo[0])
		}
		o.Items = make([]*DSDomainControllerInfoV1, sizeInfo[0])
		for i1 := range o.Items {
			i1 := i1
			if o.Items[i1] == nil {
				o.Items[i1] = &DSDomainControllerInfoV1{}
			}
			if err := o.Items[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_rItems := func(ptr interface{}) { o.Items = *ptr.(*[]*DSDomainControllerInfoV1) }
	if err := w.ReadPointer(&o.Items, _s_rItems, _ptr_rItems); err != nil {
		return err
	}
	return nil
}

// MessageDCInfoReplyV2 structure represents DRS_MSG_DCINFOREPLY_V2 RPC structure.
//
// The DRS_MSG_DCINFOREPLY_V2 structure defines the response message received from the
// IDL_DRSDomainControllerInfo method, when the client has requested InfoLevel = 2.
type MessageDCInfoReplyV2 struct {
	// cItems:  Count of items in the rItems array.
	ItemsCount uint32 `idl:"name:cItems" json:"items_count"`
	// rItems:  DC information.
	Items []*DSDomainControllerInfoV2 `idl:"name:rItems;size_is:(cItems)" json:"items"`
}

func (o *MessageDCInfoReplyV2) xxx_PreparePayload(ctx context.Context) error {
	if o.Items != nil && o.ItemsCount == 0 {
		o.ItemsCount = uint32(len(o.Items))
	}
	if o.ItemsCount > uint32(10000) {
		return fmt.Errorf("ItemsCount is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageDCInfoReplyV2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.ItemsCount); err != nil {
		return err
	}
	if o.Items != nil || o.ItemsCount > 0 {
		_ptr_rItems := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.ItemsCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Items {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Items[i1] != nil {
					if err := o.Items[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&DSDomainControllerInfoV2{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Items); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&DSDomainControllerInfoV2{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Items, _ptr_rItems); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageDCInfoReplyV2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.ItemsCount); err != nil {
		return err
	}
	_ptr_rItems := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.ItemsCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.ItemsCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Items", sizeInfo[0])
		}
		o.Items = make([]*DSDomainControllerInfoV2, sizeInfo[0])
		for i1 := range o.Items {
			i1 := i1
			if o.Items[i1] == nil {
				o.Items[i1] = &DSDomainControllerInfoV2{}
			}
			if err := o.Items[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_rItems := func(ptr interface{}) { o.Items = *ptr.(*[]*DSDomainControllerInfoV2) }
	if err := w.ReadPointer(&o.Items, _s_rItems, _ptr_rItems); err != nil {
		return err
	}
	return nil
}

// MessageDCInfoReplyV3 structure represents DRS_MSG_DCINFOREPLY_V3 RPC structure.
//
// The DRS_MSG_DCINFOREPLY_V3 structure defines the response message received from the
// IDL_DRSDomainControllerInfo method when the client has requested InfoLevel = 3.
type MessageDCInfoReplyV3 struct {
	// cItems:  Count of items in the rItems array.
	ItemsCount uint32 `idl:"name:cItems" json:"items_count"`
	// rItems:  DC information.
	Items []*DSDomainControllerInfoV3 `idl:"name:rItems;size_is:(cItems)" json:"items"`
}

func (o *MessageDCInfoReplyV3) xxx_PreparePayload(ctx context.Context) error {
	if o.Items != nil && o.ItemsCount == 0 {
		o.ItemsCount = uint32(len(o.Items))
	}
	if o.ItemsCount > uint32(10000) {
		return fmt.Errorf("ItemsCount is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageDCInfoReplyV3) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.ItemsCount); err != nil {
		return err
	}
	if o.Items != nil || o.ItemsCount > 0 {
		_ptr_rItems := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.ItemsCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Items {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Items[i1] != nil {
					if err := o.Items[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&DSDomainControllerInfoV3{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Items); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&DSDomainControllerInfoV3{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Items, _ptr_rItems); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageDCInfoReplyV3) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.ItemsCount); err != nil {
		return err
	}
	_ptr_rItems := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.ItemsCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.ItemsCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Items", sizeInfo[0])
		}
		o.Items = make([]*DSDomainControllerInfoV3, sizeInfo[0])
		for i1 := range o.Items {
			i1 := i1
			if o.Items[i1] == nil {
				o.Items[i1] = &DSDomainControllerInfoV3{}
			}
			if err := o.Items[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_rItems := func(ptr interface{}) { o.Items = *ptr.(*[]*DSDomainControllerInfoV3) }
	if err := w.ReadPointer(&o.Items, _s_rItems, _ptr_rItems); err != nil {
		return err
	}
	return nil
}

// MessageDCInfoReplyVQ structure represents DRS_MSG_DCINFOREPLY_VFFFFFFFF RPC structure.
//
// The DRS_MSG_DCINFOREPLY_VFFFFFFFF structure defines the response message received
// from the IDL_DRSDomainControllerInfo method, when the client has requested InfoLevel
// = 0xFFFFFFFF.
type MessageDCInfoReplyVQ struct {
	// cItems:  The count of items in the rItems array.
	ItemsCount uint32 `idl:"name:cItems" json:"items_count"`
	// rItems:  Information about the active LDAP connections.
	Items []*DSDomainControllerInfoVQ `idl:"name:rItems;size_is:(cItems)" json:"items"`
}

func (o *MessageDCInfoReplyVQ) xxx_PreparePayload(ctx context.Context) error {
	if o.Items != nil && o.ItemsCount == 0 {
		o.ItemsCount = uint32(len(o.Items))
	}
	if o.ItemsCount > uint32(10000) {
		return fmt.Errorf("ItemsCount is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageDCInfoReplyVQ) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.ItemsCount); err != nil {
		return err
	}
	if o.Items != nil || o.ItemsCount > 0 {
		_ptr_rItems := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.ItemsCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Items {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Items[i1] != nil {
					if err := o.Items[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&DSDomainControllerInfoVQ{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Items); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&DSDomainControllerInfoVQ{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Items, _ptr_rItems); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageDCInfoReplyVQ) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.ItemsCount); err != nil {
		return err
	}
	_ptr_rItems := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.ItemsCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.ItemsCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Items", sizeInfo[0])
		}
		o.Items = make([]*DSDomainControllerInfoVQ, sizeInfo[0])
		for i1 := range o.Items {
			i1 := i1
			if o.Items[i1] == nil {
				o.Items[i1] = &DSDomainControllerInfoVQ{}
			}
			if err := o.Items[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_rItems := func(ptr interface{}) { o.Items = *ptr.(*[]*DSDomainControllerInfoVQ) }
	if err := w.ReadPointer(&o.Items, _s_rItems, _ptr_rItems); err != nil {
		return err
	}
	return nil
}

// MessageDCInfoReply structure represents DRS_MSG_DCINFOREPLY RPC union.
//
// The DRS_MSG_DCINFOREPLY union defines the response messages received from the IDL_DRSDomainControllerInfo
// method.
type MessageDCInfoReply struct {
	// Types that are assignable to Value
	//
	// *MessageDCInfoReply_V1
	// *MessageDCInfoReply_V2
	// *MessageDCInfoReply_V3
	// *MessageDCInfoReply_VQ
	Value is_MessageDCInfoReply `json:"value"`
}

func (o *MessageDCInfoReply) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageDCInfoReply_V1:
		if value != nil {
			return value.V1
		}
	case *MessageDCInfoReply_V2:
		if value != nil {
			return value.V2
		}
	case *MessageDCInfoReply_V3:
		if value != nil {
			return value.V3
		}
	case *MessageDCInfoReply_VQ:
		if value != nil {
			return value.VQ
		}
	}
	return nil
}

type is_MessageDCInfoReply interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageDCInfoReply()
}

func (o *MessageDCInfoReply) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageDCInfoReply_V1:
		return uint32(1)
	case *MessageDCInfoReply_V2:
		return uint32(2)
	case *MessageDCInfoReply_V3:
		return uint32(3)
	case *MessageDCInfoReply_VQ:
		return uint32(4294967295)
	}
	return uint32(0)
}

func (o *MessageDCInfoReply) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageDCInfoReply_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageDCInfoReply_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(2):
		_o, _ := o.Value.(*MessageDCInfoReply_V2)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageDCInfoReply_V2{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(3):
		_o, _ := o.Value.(*MessageDCInfoReply_V3)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageDCInfoReply_V3{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(4294967295):
		_o, _ := o.Value.(*MessageDCInfoReply_VQ)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageDCInfoReply_VQ{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageDCInfoReply) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageDCInfoReply_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(2):
		o.Value = &MessageDCInfoReply_V2{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(3):
		o.Value = &MessageDCInfoReply_V3{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(4294967295):
		o.Value = &MessageDCInfoReply_VQ{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageDCInfoReply_V1 structure represents DRS_MSG_DCINFOREPLY RPC union arm.
//
// It has following labels: 1
type MessageDCInfoReply_V1 struct {
	// V1:  Version 1 response.
	V1 *MessageDCInfoReplyV1 `idl:"name:V1" json:"v1"`
}

func (*MessageDCInfoReply_V1) is_MessageDCInfoReply() {}

func (o *MessageDCInfoReply_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageDCInfoReplyV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageDCInfoReply_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageDCInfoReplyV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageDCInfoReply_V2 structure represents DRS_MSG_DCINFOREPLY RPC union arm.
//
// It has following labels: 2
type MessageDCInfoReply_V2 struct {
	// V2:  Version 2 response.
	V2 *MessageDCInfoReplyV2 `idl:"name:V2" json:"v2"`
}

func (*MessageDCInfoReply_V2) is_MessageDCInfoReply() {}

func (o *MessageDCInfoReply_V2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V2 != nil {
		if err := o.V2.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageDCInfoReplyV2{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageDCInfoReply_V2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V2 == nil {
		o.V2 = &MessageDCInfoReplyV2{}
	}
	if err := o.V2.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageDCInfoReply_V3 structure represents DRS_MSG_DCINFOREPLY RPC union arm.
//
// It has following labels: 3
type MessageDCInfoReply_V3 struct {
	// V3:  Version 3 response.
	V3 *MessageDCInfoReplyV3 `idl:"name:V3" json:"v3"`
}

func (*MessageDCInfoReply_V3) is_MessageDCInfoReply() {}

func (o *MessageDCInfoReply_V3) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V3 != nil {
		if err := o.V3.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageDCInfoReplyV3{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageDCInfoReply_V3) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V3 == nil {
		o.V3 = &MessageDCInfoReplyV3{}
	}
	if err := o.V3.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageDCInfoReply_VQ structure represents DRS_MSG_DCINFOREPLY RPC union arm.
//
// It has following labels: 4294967295
type MessageDCInfoReply_VQ struct {
	// VFFFFFFFF:  Version 0xFFFFFFFF response.
	VQ *MessageDCInfoReplyVQ `idl:"name:VFFFFFFFF" json:"vq"`
}

func (*MessageDCInfoReply_VQ) is_MessageDCInfoReply() {}

func (o *MessageDCInfoReply_VQ) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.VQ != nil {
		if err := o.VQ.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageDCInfoReplyVQ{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageDCInfoReply_VQ) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.VQ == nil {
		o.VQ = &MessageDCInfoReplyVQ{}
	}
	if err := o.VQ.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageAddEntryRequestV1 structure represents DRS_MSG_ADDENTRYREQ_V1 RPC structure.
//
// The DRS_MSG_ADDENTRYREQ_V1 structure defines the request message sent to the IDL_DRSAddEntry
// method. This request version is obsolete.<6>
type MessageAddEntryRequestV1 struct {
	// pObject:  The identity of the object to add.
	Object *DSName `idl:"name:pObject;pointer:ref" json:"object"`
	// AttrBlock:  The attributes of the object to add.
	AttributeBlock *AttributeBlock `idl:"name:AttrBlock" json:"attribute_block"`
}

func (o *MessageAddEntryRequestV1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageAddEntryRequestV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.Object != nil {
		_ptr_pObject := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Object != nil {
				if err := o.Object.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSName{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Object, _ptr_pObject); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.AttributeBlock != nil {
		if err := o.AttributeBlock.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&AttributeBlock{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageAddEntryRequestV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_pObject := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Object == nil {
			o.Object = &DSName{}
		}
		if err := o.Object.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pObject := func(ptr interface{}) { o.Object = *ptr.(**DSName) }
	if err := w.ReadPointer(&o.Object, _s_pObject, _ptr_pObject); err != nil {
		return err
	}
	if o.AttributeBlock == nil {
		o.AttributeBlock = &AttributeBlock{}
	}
	if err := o.AttributeBlock.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageAddEntryRequestV2 structure represents DRS_MSG_ADDENTRYREQ_V2 RPC structure.
//
// The DRS_MSG_ADDENTRYREQ_V2 structure defines the request message sent to the IDL_DRSAddEntry
// method.
type MessageAddEntryRequestV2 struct {
	// EntInfList:  The objects to be added, as specified in section 5.57.
	EntityInfoList *EntityInfoList `idl:"name:EntInfList" json:"entity_info_list"`
}

func (o *MessageAddEntryRequestV2) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageAddEntryRequestV2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.EntityInfoList != nil {
		if err := o.EntityInfoList.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&EntityInfoList{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageAddEntryRequestV2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if o.EntityInfoList == nil {
		o.EntityInfoList = &EntityInfoList{}
	}
	if err := o.EntityInfoList.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageAddEntryRequestV3 structure represents DRS_MSG_ADDENTRYREQ_V3 RPC structure.
//
// The DRS_MSG_ADDENTRYREQ_V3 structure defines the request message sent to the IDL_DRSAddEntry
// method.
type MessageAddEntryRequestV3 struct {
	// EntInfList:  The objects to be added.
	EntityInfoList *EntityInfoList `idl:"name:EntInfList" json:"entity_info_list"`
	// pClientCreds:  The user credentials to authorize the operation.
	ClientCreds *SecurityBufferDesc `idl:"name:pClientCreds" json:"client_creds"`
}

func (o *MessageAddEntryRequestV3) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageAddEntryRequestV3) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.EntityInfoList != nil {
		if err := o.EntityInfoList.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&EntityInfoList{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.ClientCreds != nil {
		_ptr_pClientCreds := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ClientCreds != nil {
				if err := o.ClientCreds.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&SecurityBufferDesc{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ClientCreds, _ptr_pClientCreds); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageAddEntryRequestV3) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if o.EntityInfoList == nil {
		o.EntityInfoList = &EntityInfoList{}
	}
	if err := o.EntityInfoList.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_pClientCreds := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ClientCreds == nil {
			o.ClientCreds = &SecurityBufferDesc{}
		}
		if err := o.ClientCreds.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pClientCreds := func(ptr interface{}) { o.ClientCreds = *ptr.(**SecurityBufferDesc) }
	if err := w.ReadPointer(&o.ClientCreds, _s_pClientCreds, _ptr_pClientCreds); err != nil {
		return err
	}
	return nil
}

// MessageAddEntryRequest structure represents DRS_MSG_ADDENTRYREQ RPC union.
//
// The DRS_MSG_ADDENTRYREQ union defines the request messages that are sent to the IDL_DRSAddEntry
// method.
type MessageAddEntryRequest struct {
	// Types that are assignable to Value
	//
	// *MessageAddEntryRequest_V1
	// *MessageAddEntryRequest_V2
	// *MessageAddEntryRequest_V3
	Value is_MessageAddEntryRequest `json:"value"`
}

func (o *MessageAddEntryRequest) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageAddEntryRequest_V1:
		if value != nil {
			return value.V1
		}
	case *MessageAddEntryRequest_V2:
		if value != nil {
			return value.V2
		}
	case *MessageAddEntryRequest_V3:
		if value != nil {
			return value.V3
		}
	}
	return nil
}

type is_MessageAddEntryRequest interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageAddEntryRequest()
}

func (o *MessageAddEntryRequest) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageAddEntryRequest_V1:
		return uint32(1)
	case *MessageAddEntryRequest_V2:
		return uint32(2)
	case *MessageAddEntryRequest_V3:
		return uint32(3)
	}
	return uint32(0)
}

func (o *MessageAddEntryRequest) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageAddEntryRequest_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageAddEntryRequest_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(2):
		_o, _ := o.Value.(*MessageAddEntryRequest_V2)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageAddEntryRequest_V2{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(3):
		_o, _ := o.Value.(*MessageAddEntryRequest_V3)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageAddEntryRequest_V3{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageAddEntryRequest) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageAddEntryRequest_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(2):
		o.Value = &MessageAddEntryRequest_V2{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(3):
		o.Value = &MessageAddEntryRequest_V3{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageAddEntryRequest_V1 structure represents DRS_MSG_ADDENTRYREQ RPC union arm.
//
// It has following labels: 1
type MessageAddEntryRequest_V1 struct {
	// V1:  Version 1 request (obsolete).
	V1 *MessageAddEntryRequestV1 `idl:"name:V1" json:"v1"`
}

func (*MessageAddEntryRequest_V1) is_MessageAddEntryRequest() {}

func (o *MessageAddEntryRequest_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageAddEntryRequestV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageAddEntryRequest_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageAddEntryRequestV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageAddEntryRequest_V2 structure represents DRS_MSG_ADDENTRYREQ RPC union arm.
//
// It has following labels: 2
type MessageAddEntryRequest_V2 struct {
	// V2:  Version 2 request.
	V2 *MessageAddEntryRequestV2 `idl:"name:V2" json:"v2"`
}

func (*MessageAddEntryRequest_V2) is_MessageAddEntryRequest() {}

func (o *MessageAddEntryRequest_V2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V2 != nil {
		if err := o.V2.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageAddEntryRequestV2{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageAddEntryRequest_V2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V2 == nil {
		o.V2 = &MessageAddEntryRequestV2{}
	}
	if err := o.V2.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageAddEntryRequest_V3 structure represents DRS_MSG_ADDENTRYREQ RPC union arm.
//
// It has following labels: 3
type MessageAddEntryRequest_V3 struct {
	// V3:  Version 3 request.
	V3 *MessageAddEntryRequestV3 `idl:"name:V3" json:"v3"`
}

func (*MessageAddEntryRequest_V3) is_MessageAddEntryRequest() {}

func (o *MessageAddEntryRequest_V3) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V3 != nil {
		if err := o.V3.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageAddEntryRequestV3{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageAddEntryRequest_V3) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V3 == nil {
		o.V3 = &MessageAddEntryRequestV3{}
	}
	if err := o.V3.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageAddEntryReplyV1 structure represents DRS_MSG_ADDENTRYREPLY_V1 RPC structure.
//
// The DRS_MSG_ADDENTRYREPLY_V1 structure defines the response message received from
// the IDL_DRSAddEntry method. This response version is obsolete.<7>
type MessageAddEntryReplyV1 struct {
	// Guid:   The objectGUID of the added object.
	GUID *dtyp.GUID `idl:"name:Guid" json:"guid"`
	// Sid:   The objectSid of the added object.
	SID *NT4SID `idl:"name:Sid" json:"sid"`
	// errCode:  0 if successful or a DIRERR error code (section 4.1.1.1.25) if a fatal
	// error occurred.
	ErrorCode uint32 `idl:"name:errCode" json:"error_code"`
	// dsid:  The implementation-specific diagnostic code.
	DSID uint32 `idl:"name:dsid" json:"dsid"`
	// extendedErr:  0, STATUS code, or Windows error code.
	ExtendedError uint32 `idl:"name:extendedErr" json:"extended_error"`
	// extendedData:  The implementation-specific diagnostic code.
	ExtendedData uint32 `idl:"name:extendedData" json:"extended_data"`
	// problem:  0 or PROBLEM error code (section 4.1.1.1.26).
	Problem uint16 `idl:"name:problem" json:"problem"`
}

func (o *MessageAddEntryReplyV1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageAddEntryReplyV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if o.GUID != nil {
		if err := o.GUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.SID != nil {
		if err := o.SID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&NT4SID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.ErrorCode); err != nil {
		return err
	}
	if err := w.WriteData(o.DSID); err != nil {
		return err
	}
	if err := w.WriteData(o.ExtendedError); err != nil {
		return err
	}
	if err := w.WriteData(o.ExtendedData); err != nil {
		return err
	}
	if err := w.WriteData(o.Problem); err != nil {
		return err
	}
	return nil
}
func (o *MessageAddEntryReplyV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if o.GUID == nil {
		o.GUID = &dtyp.GUID{}
	}
	if err := o.GUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.SID == nil {
		o.SID = &NT4SID{}
	}
	if err := o.SID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.ErrorCode); err != nil {
		return err
	}
	if err := w.ReadData(&o.DSID); err != nil {
		return err
	}
	if err := w.ReadData(&o.ExtendedError); err != nil {
		return err
	}
	if err := w.ReadData(&o.ExtendedData); err != nil {
		return err
	}
	if err := w.ReadData(&o.Problem); err != nil {
		return err
	}
	return nil
}

// AddEntryReplyInfo structure represents ADDENTRY_REPLY_INFO RPC structure.
//
// The ADDENTRY_REPLY_INFO structure defines the identity of an object added by the
// IDL_DRSAddEntry method.
type AddEntryReplyInfo struct {
	// objGuid:  The objectGUID of the added object.
	ObjectGUID *dtyp.GUID `idl:"name:objGuid" json:"object_guid"`
	// objSid:  The objectSid of the added object.
	ObjectSID *NT4SID `idl:"name:objSid" json:"object_sid"`
}

func (o *AddEntryReplyInfo) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *AddEntryReplyInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if o.ObjectGUID != nil {
		if err := o.ObjectGUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.ObjectSID != nil {
		if err := o.ObjectSID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&NT4SID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *AddEntryReplyInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if o.ObjectGUID == nil {
		o.ObjectGUID = &dtyp.GUID{}
	}
	if err := o.ObjectGUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.ObjectSID == nil {
		o.ObjectSID = &NT4SID{}
	}
	if err := o.ObjectSID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageAddEntryReplyV2 structure represents DRS_MSG_ADDENTRYREPLY_V2 RPC structure.
//
// The DRS_MSG_ADDENTRYREPLY_V2 structure defines the response message received from
// the IDL_DRSAddEntry method.
type MessageAddEntryReplyV2 struct {
	// pErrorObject:  Null, or the identity of the object that was being added when an error
	// occurred.
	ErrorObject *DSName `idl:"name:pErrorObject;pointer:unique" json:"error_object"`
	// errCode:  0 if successful, otherwise a DIRERR error code (section 4.1.1.1.25).
	ErrorCode uint32 `idl:"name:errCode" json:"error_code"`
	// dsid:  The implementation-specific diagnostic code.
	DSID uint32 `idl:"name:dsid" json:"dsid"`
	// extendedErr:  0, STATUS code, or Windows error code.
	ExtendedError uint32 `idl:"name:extendedErr" json:"extended_error"`
	// extendedData:  The implementation-specific diagnostic code.
	ExtendedData uint32 `idl:"name:extendedData" json:"extended_data"`
	// problem:  0 or PROBLEM error code (section 4.1.1.1.26).
	Problem uint16 `idl:"name:problem" json:"problem"`
	// cObjectsAdded:  The count of items in the infoList array.
	ObjectsAddedCount uint32 `idl:"name:cObjectsAdded" json:"objects_added_count"`
	// infoList:  The identities of the added objects. The item order matches the item order
	// of values in the EntInfList field in the request structure.
	InfoList []*AddEntryReplyInfo `idl:"name:infoList;size_is:(cObjectsAdded)" json:"info_list"`
}

func (o *MessageAddEntryReplyV2) xxx_PreparePayload(ctx context.Context) error {
	if o.InfoList != nil && o.ObjectsAddedCount == 0 {
		o.ObjectsAddedCount = uint32(len(o.InfoList))
	}
	if o.ObjectsAddedCount > uint32(10000) {
		return fmt.Errorf("ObjectsAddedCount is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageAddEntryReplyV2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.ErrorObject != nil {
		_ptr_pErrorObject := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ErrorObject != nil {
				if err := o.ErrorObject.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSName{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ErrorObject, _ptr_pErrorObject); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.ErrorCode); err != nil {
		return err
	}
	if err := w.WriteData(o.DSID); err != nil {
		return err
	}
	if err := w.WriteData(o.ExtendedError); err != nil {
		return err
	}
	if err := w.WriteData(o.ExtendedData); err != nil {
		return err
	}
	if err := w.WriteData(o.Problem); err != nil {
		return err
	}
	if err := w.WriteData(o.ObjectsAddedCount); err != nil {
		return err
	}
	if o.InfoList != nil || o.ObjectsAddedCount > 0 {
		_ptr_infoList := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.ObjectsAddedCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.InfoList {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.InfoList[i1] != nil {
					if err := o.InfoList[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&AddEntryReplyInfo{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.InfoList); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&AddEntryReplyInfo{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.InfoList, _ptr_infoList); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageAddEntryReplyV2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_pErrorObject := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ErrorObject == nil {
			o.ErrorObject = &DSName{}
		}
		if err := o.ErrorObject.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pErrorObject := func(ptr interface{}) { o.ErrorObject = *ptr.(**DSName) }
	if err := w.ReadPointer(&o.ErrorObject, _s_pErrorObject, _ptr_pErrorObject); err != nil {
		return err
	}
	if err := w.ReadData(&o.ErrorCode); err != nil {
		return err
	}
	if err := w.ReadData(&o.DSID); err != nil {
		return err
	}
	if err := w.ReadData(&o.ExtendedError); err != nil {
		return err
	}
	if err := w.ReadData(&o.ExtendedData); err != nil {
		return err
	}
	if err := w.ReadData(&o.Problem); err != nil {
		return err
	}
	if err := w.ReadData(&o.ObjectsAddedCount); err != nil {
		return err
	}
	_ptr_infoList := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.ObjectsAddedCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.ObjectsAddedCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.InfoList", sizeInfo[0])
		}
		o.InfoList = make([]*AddEntryReplyInfo, sizeInfo[0])
		for i1 := range o.InfoList {
			i1 := i1
			if o.InfoList[i1] == nil {
				o.InfoList[i1] = &AddEntryReplyInfo{}
			}
			if err := o.InfoList[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_infoList := func(ptr interface{}) { o.InfoList = *ptr.(*[]*AddEntryReplyInfo) }
	if err := w.ReadPointer(&o.InfoList, _s_infoList, _ptr_infoList); err != nil {
		return err
	}
	return nil
}

// ErrorDataV1 structure represents DRS_ERROR_DATA_V1 RPC structure.
//
// The DRS_ERROR_DATA_V1 structure defines the error response received from the IDL_DRSAddEntry
// method.
type ErrorDataV1 struct {
	// dwRepError:  0 or a Windows error code.
	RepError uint32 `idl:"name:dwRepError" json:"rep_error"`
	// errCode:  A DIRERR code (section 4.1.1.1.25) that specifies the error category.
	ErrorCode uint32 `idl:"name:errCode" json:"error_code"`
	// pErrInfo:  Category-specific error information.
	ErrorInfo *DirectoryError `idl:"name:pErrInfo;switch_is:errCode" json:"error_info"`
}

func (o *ErrorDataV1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ErrorDataV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.RepError); err != nil {
		return err
	}
	if err := w.WriteData(o.ErrorCode); err != nil {
		return err
	}
	if o.ErrorInfo != nil {
		_ptr_pErrInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			_swErrorInfo := uint32(o.ErrorCode)
			if o.ErrorInfo != nil {
				if err := o.ErrorInfo.MarshalUnionNDR(ctx, w, _swErrorInfo); err != nil {
					return err
				}
			} else {
				if err := (&DirectoryError{}).MarshalUnionNDR(ctx, w, _swErrorInfo); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ErrorInfo, _ptr_pErrInfo); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ErrorDataV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.RepError); err != nil {
		return err
	}
	if err := w.ReadData(&o.ErrorCode); err != nil {
		return err
	}
	_ptr_pErrInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ErrorInfo == nil {
			o.ErrorInfo = &DirectoryError{}
		}
		_swErrorInfo := uint32(o.ErrorCode)
		if err := o.ErrorInfo.UnmarshalUnionNDR(ctx, w, _swErrorInfo); err != nil {
			return err
		}
		return nil
	})
	_s_pErrInfo := func(ptr interface{}) { o.ErrorInfo = *ptr.(**DirectoryError) }
	if err := w.ReadPointer(&o.ErrorInfo, _s_pErrInfo, _ptr_pErrInfo); err != nil {
		return err
	}
	return nil
}

// ErrorData structure represents DRS_ERROR_DATA RPC union.
//
// The DRS_ERROR_DATA union defines the error responses that are received from the IDL_DRSAddEntry
// method.
type ErrorData struct {
	// Types that are assignable to Value
	//
	// *ErrorData_V1
	Value is_ErrorData `json:"value"`
}

func (o *ErrorData) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *ErrorData_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_ErrorData interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_ErrorData()
}

func (o *ErrorData) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *ErrorData_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *ErrorData) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*ErrorData_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ErrorData_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *ErrorData) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &ErrorData_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// ErrorData_V1 structure represents DRS_ERROR_DATA RPC union arm.
//
// It has following labels: 1
type ErrorData_V1 struct {
	// V1:  Version 1 response.
	V1 *ErrorDataV1 `idl:"name:V1" json:"v1"`
}

func (*ErrorData_V1) is_ErrorData() {}

func (o *ErrorData_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ErrorDataV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *ErrorData_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &ErrorDataV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageAddEntryReplyV3 structure represents DRS_MSG_ADDENTRYREPLY_V3 RPC structure.
//
// The DRS_MSG_ADDENTRYREPLY_V3 structure defines the response message received from
// the IDL_DRSAddEntry method.
type MessageAddEntryReplyV3 struct {
	// pdsErrObject:  Null, or the identity of the object that was being added when an error
	// occurred.
	PdsErrorObject *DSName `idl:"name:pdsErrObject" json:"pds_error_object"`
	// dwErrVer:  MUST be set to 1.
	ErrorVer uint32 `idl:"name:dwErrVer" json:"error_ver"`
	// pErrData:  Null, or an error that occurred while processing the request.
	ErrorData *ErrorData `idl:"name:pErrData;switch_is:dwErrVer" json:"error_data"`
	// cObjectsAdded:  The count of items in the infoList array.
	ObjectsAddedCount uint32 `idl:"name:cObjectsAdded" json:"objects_added_count"`
	// infoList:  The identities of the added objects. The item order matches the item order
	// of values in the EntInfList field in the request structure.
	InfoList []*AddEntryReplyInfo `idl:"name:infoList;size_is:(cObjectsAdded)" json:"info_list"`
}

func (o *MessageAddEntryReplyV3) xxx_PreparePayload(ctx context.Context) error {
	if o.InfoList != nil && o.ObjectsAddedCount == 0 {
		o.ObjectsAddedCount = uint32(len(o.InfoList))
	}
	if o.ObjectsAddedCount > uint32(10000) {
		return fmt.Errorf("ObjectsAddedCount is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageAddEntryReplyV3) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.PdsErrorObject != nil {
		_ptr_pdsErrObject := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.PdsErrorObject != nil {
				if err := o.PdsErrorObject.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSName{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.PdsErrorObject, _ptr_pdsErrObject); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.ErrorVer); err != nil {
		return err
	}
	if o.ErrorData != nil {
		_ptr_pErrData := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			_swErrorData := uint32(o.ErrorVer)
			if o.ErrorData != nil {
				if err := o.ErrorData.MarshalUnionNDR(ctx, w, _swErrorData); err != nil {
					return err
				}
			} else {
				if err := (&ErrorData{}).MarshalUnionNDR(ctx, w, _swErrorData); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ErrorData, _ptr_pErrData); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.ObjectsAddedCount); err != nil {
		return err
	}
	if o.InfoList != nil || o.ObjectsAddedCount > 0 {
		_ptr_infoList := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.ObjectsAddedCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.InfoList {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.InfoList[i1] != nil {
					if err := o.InfoList[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&AddEntryReplyInfo{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.InfoList); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&AddEntryReplyInfo{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.InfoList, _ptr_infoList); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageAddEntryReplyV3) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_pdsErrObject := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.PdsErrorObject == nil {
			o.PdsErrorObject = &DSName{}
		}
		if err := o.PdsErrorObject.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pdsErrObject := func(ptr interface{}) { o.PdsErrorObject = *ptr.(**DSName) }
	if err := w.ReadPointer(&o.PdsErrorObject, _s_pdsErrObject, _ptr_pdsErrObject); err != nil {
		return err
	}
	if err := w.ReadData(&o.ErrorVer); err != nil {
		return err
	}
	_ptr_pErrData := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ErrorData == nil {
			o.ErrorData = &ErrorData{}
		}
		_swErrorData := uint32(o.ErrorVer)
		if err := o.ErrorData.UnmarshalUnionNDR(ctx, w, _swErrorData); err != nil {
			return err
		}
		return nil
	})
	_s_pErrData := func(ptr interface{}) { o.ErrorData = *ptr.(**ErrorData) }
	if err := w.ReadPointer(&o.ErrorData, _s_pErrData, _ptr_pErrData); err != nil {
		return err
	}
	if err := w.ReadData(&o.ObjectsAddedCount); err != nil {
		return err
	}
	_ptr_infoList := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.ObjectsAddedCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.ObjectsAddedCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.InfoList", sizeInfo[0])
		}
		o.InfoList = make([]*AddEntryReplyInfo, sizeInfo[0])
		for i1 := range o.InfoList {
			i1 := i1
			if o.InfoList[i1] == nil {
				o.InfoList[i1] = &AddEntryReplyInfo{}
			}
			if err := o.InfoList[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_infoList := func(ptr interface{}) { o.InfoList = *ptr.(*[]*AddEntryReplyInfo) }
	if err := w.ReadPointer(&o.InfoList, _s_infoList, _ptr_infoList); err != nil {
		return err
	}
	return nil
}

// MessageAddEntryReply structure represents DRS_MSG_ADDENTRYREPLY RPC union.
//
// The DRS_MSG_ADDENTRYREPLY union defines the response messages received from the IDL_DRSAddEntry
// method.
type MessageAddEntryReply struct {
	// Types that are assignable to Value
	//
	// *MessageAddEntryReply_V1
	// *MessageAddEntryReply_V2
	// *MessageAddEntryReply_V3
	Value is_MessageAddEntryReply `json:"value"`
}

func (o *MessageAddEntryReply) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageAddEntryReply_V1:
		if value != nil {
			return value.V1
		}
	case *MessageAddEntryReply_V2:
		if value != nil {
			return value.V2
		}
	case *MessageAddEntryReply_V3:
		if value != nil {
			return value.V3
		}
	}
	return nil
}

type is_MessageAddEntryReply interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageAddEntryReply()
}

func (o *MessageAddEntryReply) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageAddEntryReply_V1:
		return uint32(1)
	case *MessageAddEntryReply_V2:
		return uint32(2)
	case *MessageAddEntryReply_V3:
		return uint32(3)
	}
	return uint32(0)
}

func (o *MessageAddEntryReply) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageAddEntryReply_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageAddEntryReply_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(2):
		_o, _ := o.Value.(*MessageAddEntryReply_V2)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageAddEntryReply_V2{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(3):
		_o, _ := o.Value.(*MessageAddEntryReply_V3)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageAddEntryReply_V3{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageAddEntryReply) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageAddEntryReply_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(2):
		o.Value = &MessageAddEntryReply_V2{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(3):
		o.Value = &MessageAddEntryReply_V3{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageAddEntryReply_V1 structure represents DRS_MSG_ADDENTRYREPLY RPC union arm.
//
// It has following labels: 1
type MessageAddEntryReply_V1 struct {
	// V1:  Version 1 response (obsolete).
	V1 *MessageAddEntryReplyV1 `idl:"name:V1" json:"v1"`
}

func (*MessageAddEntryReply_V1) is_MessageAddEntryReply() {}

func (o *MessageAddEntryReply_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageAddEntryReplyV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageAddEntryReply_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageAddEntryReplyV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageAddEntryReply_V2 structure represents DRS_MSG_ADDENTRYREPLY RPC union arm.
//
// It has following labels: 2
type MessageAddEntryReply_V2 struct {
	// V2:  Version 2 response.
	V2 *MessageAddEntryReplyV2 `idl:"name:V2" json:"v2"`
}

func (*MessageAddEntryReply_V2) is_MessageAddEntryReply() {}

func (o *MessageAddEntryReply_V2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V2 != nil {
		if err := o.V2.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageAddEntryReplyV2{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageAddEntryReply_V2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V2 == nil {
		o.V2 = &MessageAddEntryReplyV2{}
	}
	if err := o.V2.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageAddEntryReply_V3 structure represents DRS_MSG_ADDENTRYREPLY RPC union arm.
//
// It has following labels: 3
type MessageAddEntryReply_V3 struct {
	// V3:  Version 3 response.
	V3 *MessageAddEntryReplyV3 `idl:"name:V3" json:"v3"`
}

func (*MessageAddEntryReply_V3) is_MessageAddEntryReply() {}

func (o *MessageAddEntryReply_V3) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V3 != nil {
		if err := o.V3.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageAddEntryReplyV3{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageAddEntryReply_V3) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V3 == nil {
		o.V3 = &MessageAddEntryReplyV3{}
	}
	if err := o.V3.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageKCCExecuteV1 structure represents DRS_MSG_KCC_EXECUTE_V1 RPC structure.
//
// The DRS_MSG_KCC_EXECUTE_V1 structure defines the request message sent to the IDL_DRSExecuteKCC
// method.
type MessageKCCExecuteV1 struct {
	// dwTaskID:  MUST be 0.
	TaskID uint32 `idl:"name:dwTaskID" json:"task_id"`
	// dwFlags:  Zero or more of the following bit flags, which are presented in little-endian
	// byte order.
	//
	//	+---+---+---+---+---+---+-----+-----+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 1 | 2 | 3 | 4 | 5 |  6  |  7  | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
	//	|   |   |   |   |   |   |     |     |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
	//	+---+---+---+---+---+---+-----+-----+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	+---+---+---+---+---+---+-----+-----+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| X | X | X | X | X | X | D P | A S | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X |
	//	+---+---+---+---+---+---+-----+-----+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//
	// X: Unused. MUST be zero and ignored.
	//
	// AS (DS_KCC_FLAG_ASYNC_OP, 0x00000001): Request the KCC to run, then return immediately.
	Flags uint32 `idl:"name:dwFlags" json:"flags"`
}

func (o *MessageKCCExecuteV1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageKCCExecuteV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.TaskID); err != nil {
		return err
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	return nil
}
func (o *MessageKCCExecuteV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.TaskID); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	return nil
}

// MessageKCCExecute structure represents DRS_MSG_KCC_EXECUTE RPC union.
//
// The DRS_MSG_KCC_EXECUTE union defines the request messages sent to the IDL_DRSExecuteKCC
// method. Only one version, identified by dwInVersion = 1, is currently defined.
type MessageKCCExecute struct {
	// Types that are assignable to Value
	//
	// *MessageKCCExecute_V1
	Value is_MessageKCCExecute `json:"value"`
}

func (o *MessageKCCExecute) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageKCCExecute_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_MessageKCCExecute interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageKCCExecute()
}

func (o *MessageKCCExecute) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageKCCExecute_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *MessageKCCExecute) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(4); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(4); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageKCCExecute_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageKCCExecute_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageKCCExecute) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(4); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(4); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageKCCExecute_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageKCCExecute_V1 structure represents DRS_MSG_KCC_EXECUTE RPC union arm.
//
// It has following labels: 1
type MessageKCCExecute_V1 struct {
	// V1:  Version 1 request.
	V1 *MessageKCCExecuteV1 `idl:"name:V1" json:"v1"`
}

func (*MessageKCCExecute_V1) is_MessageKCCExecute() {}

func (o *MessageKCCExecute_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageKCCExecuteV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageKCCExecute_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageKCCExecuteV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// DSReplicationClientContext structure represents DS_REPL_CLIENT_CONTEXT RPC structure.
//
// The DS_REPL_CLIENT_CONTEXT structure defines an active RPC client connection. This
// structure is a concrete representation of a tuple in an RPCClientContexts sequence.
type DSReplicationClientContext struct {
	// hCtx:  The unique ID of the client context.
	Context uint64 `idl:"name:hCtx" json:"context"`
	// lReferenceCount:  The number of references to the context.
	ReferenceCount int32 `idl:"name:lReferenceCount" json:"reference_count"`
	// fIsBound:  True if and only if the context has not yet been closed by the IDL_DRSUnbind
	// method.
	IsBound bool `idl:"name:fIsBound" json:"is_bound"`
	// uuidClient:  Zeros, or the value pointed to by the puuidClientDsa parameter to IDL_DRSBind.
	Client *dtyp.UUID `idl:"name:uuidClient" json:"client"`
	// timeLastUsed:  The date and time at which this context was last used in an RPC method
	// call.
	TimeLastUsed int64 `idl:"name:timeLastUsed" json:"time_last_used"`
	// IPAddr:  The IPv4 address of the client. If the client is connected with IPv6, this
	// field MUST be 0.
	IPAddr uint32 `idl:"name:IPAddr" json:"ip_addr"`
	// pid:  The process ID specified by the client in the pextClient parameter to IDL_DRSBind.
	PID int32 `idl:"name:pid" json:"pid"`
}

func (o *DSReplicationClientContext) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSReplicationClientContext) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if err := w.WriteData(o.Context); err != nil {
		return err
	}
	if err := w.WriteData(o.ReferenceCount); err != nil {
		return err
	}
	if !o.IsBound {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if o.Client != nil {
		if err := o.Client.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.TimeLastUsed); err != nil {
		return err
	}
	if err := w.WriteData(o.IPAddr); err != nil {
		return err
	}
	if err := w.WriteData(o.PID); err != nil {
		return err
	}
	return nil
}
func (o *DSReplicationClientContext) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if err := w.ReadData(&o.Context); err != nil {
		return err
	}
	if err := w.ReadData(&o.ReferenceCount); err != nil {
		return err
	}
	var _bIsBound int32
	if err := w.ReadData(&_bIsBound); err != nil {
		return err
	}
	o.IsBound = _bIsBound != 0
	if o.Client == nil {
		o.Client = &dtyp.UUID{}
	}
	if err := o.Client.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.TimeLastUsed); err != nil {
		return err
	}
	if err := w.ReadData(&o.IPAddr); err != nil {
		return err
	}
	if err := w.ReadData(&o.PID); err != nil {
		return err
	}
	return nil
}

// DSReplicationClientContexts structure represents DS_REPL_CLIENT_CONTEXTS RPC structure.
//
// The DS_REPL_CLIENT_CONTEXTS structure defines a set of active RPC client connections.
// This structure is a concrete representation of RPCClientContexts.
type DSReplicationClientContexts struct {
	// cNumContexts:  The number of items in the rgContext array.
	ContextsCount uint32 `idl:"name:cNumContexts" json:"contexts_count"`
	// dwReserved:  Unused. MUST be 0 and ignored.
	_ uint32 `idl:"name:dwReserved"`
	// rgContext:  A set of active RPC client connections.
	Context []*DSReplicationClientContext `idl:"name:rgContext;size_is:(cNumContexts)" json:"context"`
}

func (o *DSReplicationClientContexts) xxx_PreparePayload(ctx context.Context) error {
	if o.Context != nil && o.ContextsCount == 0 {
		o.ContextsCount = uint32(len(o.Context))
	}
	if o.ContextsCount > uint32(10000) {
		return fmt.Errorf("ContextsCount is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *DSReplicationClientContexts) NDRSizeInfo() []uint64 {
	dimSize1 := uint64(o.ContextsCount)
	return []uint64{
		dimSize1,
	}
}
func (o *DSReplicationClientContexts) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for sz1 := range sizeInfo {
			if err := w.WriteSize(sizeInfo[sz1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if err := w.WriteData(o.ContextsCount); err != nil {
		return err
	}
	// reserved dwReserved
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	for i1 := range o.Context {
		i1 := i1
		if uint64(i1) >= sizeInfo[0] {
			break
		}
		if o.Context[i1] != nil {
			if err := o.Context[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DSReplicationClientContext{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.Context); uint64(i1) < sizeInfo[0]; i1++ {
		if err := (&DSReplicationClientContext{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSReplicationClientContexts) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for i1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[i1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if err := w.ReadData(&o.ContextsCount); err != nil {
		return err
	}
	// reserved dwReserved
	var _dwReserved uint32
	if err := w.ReadData(&_dwReserved); err != nil {
		return err
	}
	// XXX: for opaque unmarshaling
	if o.ContextsCount > 0 && sizeInfo[0] == 0 {
		sizeInfo[0] = uint64(o.ContextsCount)
	}
	if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
		return fmt.Errorf("buffer overflow for size %d of array o.Context", sizeInfo[0])
	}
	o.Context = make([]*DSReplicationClientContext, sizeInfo[0])
	for i1 := range o.Context {
		i1 := i1
		if o.Context[i1] == nil {
			o.Context[i1] = &DSReplicationClientContext{}
		}
		if err := o.Context[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// DSReplicationServerOutgoingCall structure represents DS_REPL_SERVER_OUTGOING_CALL RPC structure.
//
// The DS_REPL_SERVER_OUTGOING_CALL structure defines an outstanding request from this
// DC to another DC. This structure is a concrete representation of a tuple from an
// RPCOutgoingContexts sequence.
type DSReplicationServerOutgoingCall struct {
	// pszServerName:  The NetworkAddress of the server.
	ServerName string `idl:"name:pszServerName;string" json:"server_name"`
	// fIsHandleBound:  True if and only if the IDL_DRSBind method has completed and the
	// IDL_DRSUnbind method has not yet been called.
	IsHandleBound bool `idl:"name:fIsHandleBound" json:"is_handle_bound"`
	// fIsHandleFromCache:  True if and only if the context handle used was retrieved from
	// the cache.
	IsHandleFromCache bool `idl:"name:fIsHandleFromCache" json:"is_handle_from_cache"`
	// fIsHandleInCache:  True if and only if the context handle is still in the cache.
	IsHandleInCache bool `idl:"name:fIsHandleInCache" json:"is_handle_in_cache"`
	// dwThreadId:  The thread ID of the thread that is using the context.
	ThreadID uint32 `idl:"name:dwThreadId" json:"thread_id"`
	// dwBindingTimeoutMins:  If the context is set to be canceled, the time-out in minutes.
	BindingTimeoutMins uint32 `idl:"name:dwBindingTimeoutMins" json:"binding_timeout_mins"`
	// dstimeCreated:  The date and time when the context was created.
	Created int64 `idl:"name:dstimeCreated" json:"created"`
	// dwCallType:  The call that the client is waiting on. MUST be one of the values in
	// the following table.
	//
	//	+-------+---------------------------+
	//	|       |                           |
	//	| VALUE |          MEANING          |
	//	|       |                           |
	//	+-------+---------------------------+
	//	+-------+---------------------------+
	//	|     2 | IDL_DRSBind               |
	//	+-------+---------------------------+
	//	|     3 | IDL_DRSUnbind             |
	//	+-------+---------------------------+
	//	|     4 | IDL_DRSReplicaSync        |
	//	+-------+---------------------------+
	//	|     5 | IDL_DRSGetNCChanges       |
	//	+-------+---------------------------+
	//	|     6 | IDL_DRSUpdateRefs         |
	//	+-------+---------------------------+
	//	|     7 | IDL_DRSReplicaAdd         |
	//	+-------+---------------------------+
	//	|     8 | IDL_DRSReplicaDel         |
	//	+-------+---------------------------+
	//	|     9 | IDL_DRSVerifyNames        |
	//	+-------+---------------------------+
	//	|    10 | IDL_DRSGetMemberships     |
	//	+-------+---------------------------+
	//	|    11 | IDL_DRSInterDomainMove    |
	//	+-------+---------------------------+
	//	|    12 | IDL_DRSGetNT4ChangeLog    |
	//	+-------+---------------------------+
	//	|    13 | IDL_DRSCrackNames         |
	//	+-------+---------------------------+
	//	|    14 | IDL_DRSAddEntry           |
	//	+-------+---------------------------+
	//	|    15 | IDL_DRSGetMemberships2    |
	//	+-------+---------------------------+
	//	|    16 | IDL_DRSGetObjectExistence |
	//	+-------+---------------------------+
	//	|    17 | IDL_DRSGetReplInfo        |
	//	+-------+---------------------------+
	//	|    18 | IDL_DRSWriteSPN           |
	//	+-------+---------------------------+
	CallType uint32 `idl:"name:dwCallType" json:"call_type"`
}

func (o *DSReplicationServerOutgoingCall) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSReplicationServerOutgoingCall) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if o.ServerName != "" {
		_ptr_pszServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerName, _ptr_pszServerName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if !o.IsHandleBound {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if !o.IsHandleFromCache {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if !o.IsHandleInCache {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.ThreadID); err != nil {
		return err
	}
	if err := w.WriteData(o.BindingTimeoutMins); err != nil {
		return err
	}
	if err := w.WriteData(o.Created); err != nil {
		return err
	}
	if err := w.WriteData(o.CallType); err != nil {
		return err
	}
	return nil
}
func (o *DSReplicationServerOutgoingCall) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	_ptr_pszServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
			return err
		}
		return nil
	})
	_s_pszServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
	if err := w.ReadPointer(&o.ServerName, _s_pszServerName, _ptr_pszServerName); err != nil {
		return err
	}
	var _bIsHandleBound int32
	if err := w.ReadData(&_bIsHandleBound); err != nil {
		return err
	}
	o.IsHandleBound = _bIsHandleBound != 0
	var _bIsHandleFromCache int32
	if err := w.ReadData(&_bIsHandleFromCache); err != nil {
		return err
	}
	o.IsHandleFromCache = _bIsHandleFromCache != 0
	var _bIsHandleInCache int32
	if err := w.ReadData(&_bIsHandleInCache); err != nil {
		return err
	}
	o.IsHandleInCache = _bIsHandleInCache != 0
	if err := w.ReadData(&o.ThreadID); err != nil {
		return err
	}
	if err := w.ReadData(&o.BindingTimeoutMins); err != nil {
		return err
	}
	if err := w.ReadData(&o.Created); err != nil {
		return err
	}
	if err := w.ReadData(&o.CallType); err != nil {
		return err
	}
	return nil
}

// DSReplicationServerOutgoingCalls structure represents DS_REPL_SERVER_OUTGOING_CALLS RPC structure.
//
// The DS_REPL_SERVER_OUTGOING_CALLS structure defines a set of outstanding requests
// from this DC to other DCs. This structure is a concrete representation of RPCOutgoingContexts.
type DSReplicationServerOutgoingCalls struct {
	// cNumCalls:  The number of items in the rgCall array.
	CallsCount uint32 `idl:"name:cNumCalls" json:"calls_count"`
	// dwReserved:  Unused. MUST be 0 and ignored.
	_ uint32 `idl:"name:dwReserved"`
	// rgCall:  A set of outstanding requests from this DC to other DCs.
	Call []*DSReplicationServerOutgoingCall `idl:"name:rgCall;size_is:(cNumCalls)" json:"call"`
}

func (o *DSReplicationServerOutgoingCalls) xxx_PreparePayload(ctx context.Context) error {
	if o.Call != nil && o.CallsCount == 0 {
		o.CallsCount = uint32(len(o.Call))
	}
	if o.CallsCount > uint32(256) {
		return fmt.Errorf("CallsCount is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *DSReplicationServerOutgoingCalls) NDRSizeInfo() []uint64 {
	dimSize1 := uint64(o.CallsCount)
	return []uint64{
		dimSize1,
	}
}
func (o *DSReplicationServerOutgoingCalls) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for sz1 := range sizeInfo {
			if err := w.WriteSize(sizeInfo[sz1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if err := w.WriteData(o.CallsCount); err != nil {
		return err
	}
	// reserved dwReserved
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	for i1 := range o.Call {
		i1 := i1
		if uint64(i1) >= sizeInfo[0] {
			break
		}
		if o.Call[i1] != nil {
			if err := o.Call[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DSReplicationServerOutgoingCall{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.Call); uint64(i1) < sizeInfo[0]; i1++ {
		if err := (&DSReplicationServerOutgoingCall{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSReplicationServerOutgoingCalls) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for i1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[i1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if err := w.ReadData(&o.CallsCount); err != nil {
		return err
	}
	// reserved dwReserved
	var _dwReserved uint32
	if err := w.ReadData(&_dwReserved); err != nil {
		return err
	}
	// XXX: for opaque unmarshaling
	if o.CallsCount > 0 && sizeInfo[0] == 0 {
		sizeInfo[0] = uint64(o.CallsCount)
	}
	if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
		return fmt.Errorf("buffer overflow for size %d of array o.Call", sizeInfo[0])
	}
	o.Call = make([]*DSReplicationServerOutgoingCall, sizeInfo[0])
	for i1 := range o.Call {
		i1 := i1
		if o.Call[i1] == nil {
			o.Call[i1] = &DSReplicationServerOutgoingCall{}
		}
		if err := o.Call[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// MessageGetReplicationInfoRequestV1 structure represents DRS_MSG_GETREPLINFO_REQ_V1 RPC structure.
//
// The DRS_MSG_GETREPLINFO_REQ_V1 structure defines a version 1 request message sent
// to the IDL_DRSGetReplInfo method.
type MessageGetReplicationInfoRequestV1 struct {
	// InfoType:  MUST be a DS_REPL_INFO code.
	InfoType uint32 `idl:"name:InfoType" json:"info_type"`
	// pszObjectDN:  DN of the object on which the operation is to be performed. The meaning
	// of this parameter depends on the value of the InfoType parameter.
	ObjectDN string `idl:"name:pszObjectDN;string" json:"object_dn"`
	// uuidSourceDsaObjGuid:  NULL GUID or the DSA GUID of a DC.
	SourceDSAObjectGUID *dtyp.UUID `idl:"name:uuidSourceDsaObjGuid" json:"source_dsa_object_guid"`
}

func (o *MessageGetReplicationInfoRequestV1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetReplicationInfoRequestV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.InfoType); err != nil {
		return err
	}
	if o.ObjectDN != "" {
		_ptr_pszObjectDN := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.ObjectDN); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ObjectDN, _ptr_pszObjectDN); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.SourceDSAObjectGUID != nil {
		if err := o.SourceDSAObjectGUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetReplicationInfoRequestV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.InfoType); err != nil {
		return err
	}
	_ptr_pszObjectDN := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.ObjectDN); err != nil {
			return err
		}
		return nil
	})
	_s_pszObjectDN := func(ptr interface{}) { o.ObjectDN = *ptr.(*string) }
	if err := w.ReadPointer(&o.ObjectDN, _s_pszObjectDN, _ptr_pszObjectDN); err != nil {
		return err
	}
	if o.SourceDSAObjectGUID == nil {
		o.SourceDSAObjectGUID = &dtyp.UUID{}
	}
	if err := o.SourceDSAObjectGUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageGetReplicationInfoRequestV2 structure represents DRS_MSG_GETREPLINFO_REQ_V2 RPC structure.
//
// The DRS_MSG_GETREPLINFO_REQ_V2 structure defines a version 2 request message sent
// to the IDL_DRSGetReplInfo method. The V2 request structure is a superset of the V1
// request structure.
type MessageGetReplicationInfoRequestV2 struct {
	// InfoType:  MUST be a DS_REPL_INFO code.
	InfoType uint32 `idl:"name:InfoType" json:"info_type"`
	// pszObjectDN:  DN of the object on which the operation is to be performed. The meaning
	// of this parameter depends on the value of the InfoType parameter.
	ObjectDN string `idl:"name:pszObjectDN;string" json:"object_dn"`
	// uuidSourceDsaObjGuid:  NULL GUID or the DSA GUID of a DC.
	SourceDSAObjectGUID *dtyp.UUID `idl:"name:uuidSourceDsaObjGuid" json:"source_dsa_object_guid"`
	// ulFlags:  Zero or more of the following bit flags, which are presented in little-endian
	// byte order.
	//
	//	+---+---+---+---+---+---+---+-----+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 |  7  | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
	//	|   |   |   |   |   |   |   |     |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
	//	+---+---+---+---+---+---+---+-----+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	+---+---+---+---+---+---+---+-----+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| X | X | X | X | X | X | X | M T | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X |
	//	+---+---+---+---+---+---+---+-----+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//
	// X: Unused. MUST be zero and ignored.
	Flags uint32 `idl:"name:ulFlags" json:"flags"`
	// pszAttributeName:  Null, or the lDAPDisplayName of a link attribute.
	AttributeName string `idl:"name:pszAttributeName;string" json:"attribute_name"`
	// pszValueDN:  Null, or the DN of the link value for which to retrieve a stamp.
	ValueDN string `idl:"name:pszValueDN;string" json:"value_dn"`
	// dwEnumerationContext:  Zero, or the value of dwEnumerationContext returned by the
	// server on a previous call to IDL_DRSGetReplInfo. For an informative description of
	// the sequencing issues associated with this field, see section 1.3.2.
	EnumerationContext uint32 `idl:"name:dwEnumerationContext" json:"enumeration_context"`
}

func (o *MessageGetReplicationInfoRequestV2) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetReplicationInfoRequestV2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.InfoType); err != nil {
		return err
	}
	if o.ObjectDN != "" {
		_ptr_pszObjectDN := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.ObjectDN); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ObjectDN, _ptr_pszObjectDN); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.SourceDSAObjectGUID != nil {
		if err := o.SourceDSAObjectGUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	if o.AttributeName != "" {
		_ptr_pszAttributeName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.AttributeName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.AttributeName, _ptr_pszAttributeName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.ValueDN != "" {
		_ptr_pszValueDN := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.ValueDN); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ValueDN, _ptr_pszValueDN); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.EnumerationContext); err != nil {
		return err
	}
	return nil
}
func (o *MessageGetReplicationInfoRequestV2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.InfoType); err != nil {
		return err
	}
	_ptr_pszObjectDN := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.ObjectDN); err != nil {
			return err
		}
		return nil
	})
	_s_pszObjectDN := func(ptr interface{}) { o.ObjectDN = *ptr.(*string) }
	if err := w.ReadPointer(&o.ObjectDN, _s_pszObjectDN, _ptr_pszObjectDN); err != nil {
		return err
	}
	if o.SourceDSAObjectGUID == nil {
		o.SourceDSAObjectGUID = &dtyp.UUID{}
	}
	if err := o.SourceDSAObjectGUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	_ptr_pszAttributeName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.AttributeName); err != nil {
			return err
		}
		return nil
	})
	_s_pszAttributeName := func(ptr interface{}) { o.AttributeName = *ptr.(*string) }
	if err := w.ReadPointer(&o.AttributeName, _s_pszAttributeName, _ptr_pszAttributeName); err != nil {
		return err
	}
	_ptr_pszValueDN := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.ValueDN); err != nil {
			return err
		}
		return nil
	})
	_s_pszValueDN := func(ptr interface{}) { o.ValueDN = *ptr.(*string) }
	if err := w.ReadPointer(&o.ValueDN, _s_pszValueDN, _ptr_pszValueDN); err != nil {
		return err
	}
	if err := w.ReadData(&o.EnumerationContext); err != nil {
		return err
	}
	return nil
}

// MessageGetReplicationInfoRequest structure represents DRS_MSG_GETREPLINFO_REQ RPC union.
//
// The DRS_MSG_GETREPLINFO_REQ union defines the request message versions sent to the
// IDL_DRSGetReplInfo method.
type MessageGetReplicationInfoRequest struct {
	// Types that are assignable to Value
	//
	// *MessageGetReplicationInfoRequest_V1
	// *MessageGetReplicationInfoRequest_V2
	Value is_MessageGetReplicationInfoRequest `json:"value"`
}

func (o *MessageGetReplicationInfoRequest) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageGetReplicationInfoRequest_V1:
		if value != nil {
			return value.V1
		}
	case *MessageGetReplicationInfoRequest_V2:
		if value != nil {
			return value.V2
		}
	}
	return nil
}

type is_MessageGetReplicationInfoRequest interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageGetReplicationInfoRequest()
}

func (o *MessageGetReplicationInfoRequest) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageGetReplicationInfoRequest_V1:
		return uint32(1)
	case *MessageGetReplicationInfoRequest_V2:
		return uint32(2)
	}
	return uint32(0)
}

func (o *MessageGetReplicationInfoRequest) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageGetReplicationInfoRequest_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageGetReplicationInfoRequest_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(2):
		_o, _ := o.Value.(*MessageGetReplicationInfoRequest_V2)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageGetReplicationInfoRequest_V2{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageGetReplicationInfoRequest) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageGetReplicationInfoRequest_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(2):
		o.Value = &MessageGetReplicationInfoRequest_V2{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageGetReplicationInfoRequest_V1 structure represents DRS_MSG_GETREPLINFO_REQ RPC union arm.
//
// It has following labels: 1
type MessageGetReplicationInfoRequest_V1 struct {
	// V1:  Version 1 request.
	V1 *MessageGetReplicationInfoRequestV1 `idl:"name:V1" json:"v1"`
}

func (*MessageGetReplicationInfoRequest_V1) is_MessageGetReplicationInfoRequest() {}

func (o *MessageGetReplicationInfoRequest_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageGetReplicationInfoRequestV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetReplicationInfoRequest_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageGetReplicationInfoRequestV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageGetReplicationInfoRequest_V2 structure represents DRS_MSG_GETREPLINFO_REQ RPC union arm.
//
// It has following labels: 2
type MessageGetReplicationInfoRequest_V2 struct {
	// V2:  Version 2 request. The V2 request structure is a superset of the V1 request
	// structure.
	V2 *MessageGetReplicationInfoRequestV2 `idl:"name:V2" json:"v2"`
}

func (*MessageGetReplicationInfoRequest_V2) is_MessageGetReplicationInfoRequest() {}

func (o *MessageGetReplicationInfoRequest_V2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V2 != nil {
		if err := o.V2.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageGetReplicationInfoRequestV2{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetReplicationInfoRequest_V2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V2 == nil {
		o.V2 = &MessageGetReplicationInfoRequestV2{}
	}
	if err := o.V2.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageGetReplicationInfoReply structure represents DRS_MSG_GETREPLINFO_REPLY RPC union.
//
// The DRS_MSG_GETREPLINFO_REPLY union defines response messages received from the IDL_DRSGetReplInfo
// method.
type MessageGetReplicationInfoReply struct {
	// Types that are assignable to Value
	//
	// *MessageGetReplicationInfoReply_Neighbors
	// *MessageGetReplicationInfoReply_Cursors
	// *MessageGetReplicationInfoReply_ObjectMetadata
	// *MessageGetReplicationInfoReply_ConnectFailures
	// *MessageGetReplicationInfoReply_LinkFailures
	// *MessageGetReplicationInfoReply_PendingOperations
	// *MessageGetReplicationInfoReply_AttributeValueMetadata
	// *MessageGetReplicationInfoReply_Cursors2
	// *MessageGetReplicationInfoReply_Cursors3
	// *MessageGetReplicationInfoReply_ObjectMetaData2
	// *MessageGetReplicationInfoReply_AttributeValueMetaData2
	// *MessageGetReplicationInfoReply_ServerOutgoingCalls
	// *MessageGetReplicationInfoReply_UpToDateVector
	// *MessageGetReplicationInfoReply_ClientContexts
	// *MessageGetReplicationInfoReply_RepsTo
	Value is_MessageGetReplicationInfoReply `json:"value"`
}

func (o *MessageGetReplicationInfoReply) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageGetReplicationInfoReply_Neighbors:
		if value != nil {
			return value.Neighbors
		}
	case *MessageGetReplicationInfoReply_Cursors:
		if value != nil {
			return value.Cursors
		}
	case *MessageGetReplicationInfoReply_ObjectMetadata:
		if value != nil {
			return value.ObjectMetadata
		}
	case *MessageGetReplicationInfoReply_ConnectFailures:
		if value != nil {
			return value.ConnectFailures
		}
	case *MessageGetReplicationInfoReply_LinkFailures:
		if value != nil {
			return value.LinkFailures
		}
	case *MessageGetReplicationInfoReply_PendingOperations:
		if value != nil {
			return value.PendingOperations
		}
	case *MessageGetReplicationInfoReply_AttributeValueMetadata:
		if value != nil {
			return value.AttributeValueMetadata
		}
	case *MessageGetReplicationInfoReply_Cursors2:
		if value != nil {
			return value.Cursors2
		}
	case *MessageGetReplicationInfoReply_Cursors3:
		if value != nil {
			return value.Cursors3
		}
	case *MessageGetReplicationInfoReply_ObjectMetaData2:
		if value != nil {
			return value.ObjectMetaData2
		}
	case *MessageGetReplicationInfoReply_AttributeValueMetaData2:
		if value != nil {
			return value.AttributeValueMetaData2
		}
	case *MessageGetReplicationInfoReply_ServerOutgoingCalls:
		if value != nil {
			return value.ServerOutgoingCalls
		}
	case *MessageGetReplicationInfoReply_UpToDateVector:
		if value != nil {
			return value.UpToDateVector
		}
	case *MessageGetReplicationInfoReply_ClientContexts:
		if value != nil {
			return value.ClientContexts
		}
	case *MessageGetReplicationInfoReply_RepsTo:
		if value != nil {
			return value.RepsTo
		}
	}
	return nil
}

type is_MessageGetReplicationInfoReply interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageGetReplicationInfoReply()
}

func (o *MessageGetReplicationInfoReply) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageGetReplicationInfoReply_Neighbors:
		return uint32(0)
	case *MessageGetReplicationInfoReply_Cursors:
		return uint32(1)
	case *MessageGetReplicationInfoReply_ObjectMetadata:
		return uint32(2)
	case *MessageGetReplicationInfoReply_ConnectFailures:
		return uint32(3)
	case *MessageGetReplicationInfoReply_LinkFailures:
		return uint32(4)
	case *MessageGetReplicationInfoReply_PendingOperations:
		return uint32(5)
	case *MessageGetReplicationInfoReply_AttributeValueMetadata:
		return uint32(6)
	case *MessageGetReplicationInfoReply_Cursors2:
		return uint32(7)
	case *MessageGetReplicationInfoReply_Cursors3:
		return uint32(8)
	case *MessageGetReplicationInfoReply_ObjectMetaData2:
		return uint32(9)
	case *MessageGetReplicationInfoReply_AttributeValueMetaData2:
		return uint32(10)
	case *MessageGetReplicationInfoReply_ServerOutgoingCalls:
		return uint32(4294967290)
	case *MessageGetReplicationInfoReply_UpToDateVector:
		return uint32(4294967291)
	case *MessageGetReplicationInfoReply_ClientContexts:
		return uint32(4294967292)
	case *MessageGetReplicationInfoReply_RepsTo:
		return uint32(4294967294)
	}
	return uint32(0)
}

func (o *MessageGetReplicationInfoReply) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(0):
		_o, _ := o.Value.(*MessageGetReplicationInfoReply_Neighbors)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageGetReplicationInfoReply_Neighbors{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1):
		_o, _ := o.Value.(*MessageGetReplicationInfoReply_Cursors)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageGetReplicationInfoReply_Cursors{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(2):
		_o, _ := o.Value.(*MessageGetReplicationInfoReply_ObjectMetadata)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageGetReplicationInfoReply_ObjectMetadata{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(3):
		_o, _ := o.Value.(*MessageGetReplicationInfoReply_ConnectFailures)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageGetReplicationInfoReply_ConnectFailures{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(4):
		_o, _ := o.Value.(*MessageGetReplicationInfoReply_LinkFailures)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageGetReplicationInfoReply_LinkFailures{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(5):
		_o, _ := o.Value.(*MessageGetReplicationInfoReply_PendingOperations)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageGetReplicationInfoReply_PendingOperations{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(6):
		_o, _ := o.Value.(*MessageGetReplicationInfoReply_AttributeValueMetadata)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageGetReplicationInfoReply_AttributeValueMetadata{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(7):
		_o, _ := o.Value.(*MessageGetReplicationInfoReply_Cursors2)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageGetReplicationInfoReply_Cursors2{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(8):
		_o, _ := o.Value.(*MessageGetReplicationInfoReply_Cursors3)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageGetReplicationInfoReply_Cursors3{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(9):
		_o, _ := o.Value.(*MessageGetReplicationInfoReply_ObjectMetaData2)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageGetReplicationInfoReply_ObjectMetaData2{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(10):
		_o, _ := o.Value.(*MessageGetReplicationInfoReply_AttributeValueMetaData2)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageGetReplicationInfoReply_AttributeValueMetaData2{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(4294967290):
		_o, _ := o.Value.(*MessageGetReplicationInfoReply_ServerOutgoingCalls)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageGetReplicationInfoReply_ServerOutgoingCalls{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(4294967291):
		_o, _ := o.Value.(*MessageGetReplicationInfoReply_UpToDateVector)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageGetReplicationInfoReply_UpToDateVector{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(4294967292):
		_o, _ := o.Value.(*MessageGetReplicationInfoReply_ClientContexts)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageGetReplicationInfoReply_ClientContexts{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(4294967294):
		_o, _ := o.Value.(*MessageGetReplicationInfoReply_RepsTo)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageGetReplicationInfoReply_RepsTo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageGetReplicationInfoReply) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(0):
		o.Value = &MessageGetReplicationInfoReply_Neighbors{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1):
		o.Value = &MessageGetReplicationInfoReply_Cursors{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(2):
		o.Value = &MessageGetReplicationInfoReply_ObjectMetadata{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(3):
		o.Value = &MessageGetReplicationInfoReply_ConnectFailures{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(4):
		o.Value = &MessageGetReplicationInfoReply_LinkFailures{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(5):
		o.Value = &MessageGetReplicationInfoReply_PendingOperations{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(6):
		o.Value = &MessageGetReplicationInfoReply_AttributeValueMetadata{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(7):
		o.Value = &MessageGetReplicationInfoReply_Cursors2{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(8):
		o.Value = &MessageGetReplicationInfoReply_Cursors3{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(9):
		o.Value = &MessageGetReplicationInfoReply_ObjectMetaData2{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(10):
		o.Value = &MessageGetReplicationInfoReply_AttributeValueMetaData2{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(4294967290):
		o.Value = &MessageGetReplicationInfoReply_ServerOutgoingCalls{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(4294967291):
		o.Value = &MessageGetReplicationInfoReply_UpToDateVector{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(4294967292):
		o.Value = &MessageGetReplicationInfoReply_ClientContexts{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(4294967294):
		o.Value = &MessageGetReplicationInfoReply_RepsTo{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageGetReplicationInfoReply_Neighbors structure represents DRS_MSG_GETREPLINFO_REPLY RPC union arm.
//
// It has following labels: 0
type MessageGetReplicationInfoReply_Neighbors struct {
	// pNeighbors:  Neighbor information.
	Neighbors *DSReplicationNeighbors `idl:"name:pNeighbors" json:"neighbors"`
}

func (*MessageGetReplicationInfoReply_Neighbors) is_MessageGetReplicationInfoReply() {}

func (o *MessageGetReplicationInfoReply_Neighbors) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Neighbors != nil {
		_ptr_pNeighbors := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Neighbors != nil {
				if err := o.Neighbors.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSReplicationNeighbors{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Neighbors, _ptr_pNeighbors); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetReplicationInfoReply_Neighbors) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_pNeighbors := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Neighbors == nil {
			o.Neighbors = &DSReplicationNeighbors{}
		}
		if err := o.Neighbors.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pNeighbors := func(ptr interface{}) { o.Neighbors = *ptr.(**DSReplicationNeighbors) }
	if err := w.ReadPointer(&o.Neighbors, _s_pNeighbors, _ptr_pNeighbors); err != nil {
		return err
	}
	return nil
}

// MessageGetReplicationInfoReply_Cursors structure represents DRS_MSG_GETREPLINFO_REPLY RPC union arm.
//
// It has following labels: 1
type MessageGetReplicationInfoReply_Cursors struct {
	// pCursors:  Cursors for an NC replica.
	Cursors *DSReplicationCursors `idl:"name:pCursors" json:"cursors"`
}

func (*MessageGetReplicationInfoReply_Cursors) is_MessageGetReplicationInfoReply() {}

func (o *MessageGetReplicationInfoReply_Cursors) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Cursors != nil {
		_ptr_pCursors := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Cursors != nil {
				if err := o.Cursors.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSReplicationCursors{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Cursors, _ptr_pCursors); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetReplicationInfoReply_Cursors) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_pCursors := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Cursors == nil {
			o.Cursors = &DSReplicationCursors{}
		}
		if err := o.Cursors.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pCursors := func(ptr interface{}) { o.Cursors = *ptr.(**DSReplicationCursors) }
	if err := w.ReadPointer(&o.Cursors, _s_pCursors, _ptr_pCursors); err != nil {
		return err
	}
	return nil
}

// MessageGetReplicationInfoReply_ObjectMetadata structure represents DRS_MSG_GETREPLINFO_REPLY RPC union arm.
//
// It has following labels: 2
type MessageGetReplicationInfoReply_ObjectMetadata struct {
	// pObjMetaData:  Attribute stamps.
	ObjectMetadata *DSReplicationObjectMetadata `idl:"name:pObjMetaData" json:"object_metadata"`
}

func (*MessageGetReplicationInfoReply_ObjectMetadata) is_MessageGetReplicationInfoReply() {}

func (o *MessageGetReplicationInfoReply_ObjectMetadata) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ObjectMetadata != nil {
		_ptr_pObjMetaData := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ObjectMetadata != nil {
				if err := o.ObjectMetadata.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSReplicationObjectMetadata{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ObjectMetadata, _ptr_pObjMetaData); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetReplicationInfoReply_ObjectMetadata) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_pObjMetaData := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ObjectMetadata == nil {
			o.ObjectMetadata = &DSReplicationObjectMetadata{}
		}
		if err := o.ObjectMetadata.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pObjMetaData := func(ptr interface{}) { o.ObjectMetadata = *ptr.(**DSReplicationObjectMetadata) }
	if err := w.ReadPointer(&o.ObjectMetadata, _s_pObjMetaData, _ptr_pObjMetaData); err != nil {
		return err
	}
	return nil
}

// MessageGetReplicationInfoReply_ConnectFailures structure represents DRS_MSG_GETREPLINFO_REPLY RPC union arm.
//
// It has following labels: 3
type MessageGetReplicationInfoReply_ConnectFailures struct {
	// pConnectFailures:  Connection failure data.
	ConnectFailures *DSReplicationKCCDSAFailures `idl:"name:pConnectFailures" json:"connect_failures"`
}

func (*MessageGetReplicationInfoReply_ConnectFailures) is_MessageGetReplicationInfoReply() {}

func (o *MessageGetReplicationInfoReply_ConnectFailures) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ConnectFailures != nil {
		_ptr_pConnectFailures := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ConnectFailures != nil {
				if err := o.ConnectFailures.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSReplicationKCCDSAFailures{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ConnectFailures, _ptr_pConnectFailures); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetReplicationInfoReply_ConnectFailures) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_pConnectFailures := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ConnectFailures == nil {
			o.ConnectFailures = &DSReplicationKCCDSAFailures{}
		}
		if err := o.ConnectFailures.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pConnectFailures := func(ptr interface{}) { o.ConnectFailures = *ptr.(**DSReplicationKCCDSAFailures) }
	if err := w.ReadPointer(&o.ConnectFailures, _s_pConnectFailures, _ptr_pConnectFailures); err != nil {
		return err
	}
	return nil
}

// MessageGetReplicationInfoReply_LinkFailures structure represents DRS_MSG_GETREPLINFO_REPLY RPC union arm.
//
// It has following labels: 4
type MessageGetReplicationInfoReply_LinkFailures struct {
	// pLinkFailures:  Link failure data.
	LinkFailures *DSReplicationKCCDSAFailures `idl:"name:pLinkFailures" json:"link_failures"`
}

func (*MessageGetReplicationInfoReply_LinkFailures) is_MessageGetReplicationInfoReply() {}

func (o *MessageGetReplicationInfoReply_LinkFailures) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.LinkFailures != nil {
		_ptr_pLinkFailures := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.LinkFailures != nil {
				if err := o.LinkFailures.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSReplicationKCCDSAFailures{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.LinkFailures, _ptr_pLinkFailures); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetReplicationInfoReply_LinkFailures) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_pLinkFailures := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.LinkFailures == nil {
			o.LinkFailures = &DSReplicationKCCDSAFailures{}
		}
		if err := o.LinkFailures.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pLinkFailures := func(ptr interface{}) { o.LinkFailures = *ptr.(**DSReplicationKCCDSAFailures) }
	if err := w.ReadPointer(&o.LinkFailures, _s_pLinkFailures, _ptr_pLinkFailures); err != nil {
		return err
	}
	return nil
}

// MessageGetReplicationInfoReply_PendingOperations structure represents DRS_MSG_GETREPLINFO_REPLY RPC union arm.
//
// It has following labels: 5
type MessageGetReplicationInfoReply_PendingOperations struct {
	// pPendingOps:  Pending operations in the replication queue.
	PendingOperations *DSReplicationPendingOperations `idl:"name:pPendingOps" json:"pending_operations"`
}

func (*MessageGetReplicationInfoReply_PendingOperations) is_MessageGetReplicationInfoReply() {}

func (o *MessageGetReplicationInfoReply_PendingOperations) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.PendingOperations != nil {
		_ptr_pPendingOps := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.PendingOperations != nil {
				if err := o.PendingOperations.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSReplicationPendingOperations{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.PendingOperations, _ptr_pPendingOps); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetReplicationInfoReply_PendingOperations) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_pPendingOps := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.PendingOperations == nil {
			o.PendingOperations = &DSReplicationPendingOperations{}
		}
		if err := o.PendingOperations.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pPendingOps := func(ptr interface{}) { o.PendingOperations = *ptr.(**DSReplicationPendingOperations) }
	if err := w.ReadPointer(&o.PendingOperations, _s_pPendingOps, _ptr_pPendingOps); err != nil {
		return err
	}
	return nil
}

// MessageGetReplicationInfoReply_AttributeValueMetadata structure represents DRS_MSG_GETREPLINFO_REPLY RPC union arm.
//
// It has following labels: 6
type MessageGetReplicationInfoReply_AttributeValueMetadata struct {
	// pAttrValueMetaData:  Link value stamps.
	AttributeValueMetadata *DSReplicationAttributeValueMetadata `idl:"name:pAttrValueMetaData" json:"attribute_value_metadata"`
}

func (*MessageGetReplicationInfoReply_AttributeValueMetadata) is_MessageGetReplicationInfoReply() {}

func (o *MessageGetReplicationInfoReply_AttributeValueMetadata) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.AttributeValueMetadata != nil {
		_ptr_pAttrValueMetaData := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.AttributeValueMetadata != nil {
				if err := o.AttributeValueMetadata.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSReplicationAttributeValueMetadata{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.AttributeValueMetadata, _ptr_pAttrValueMetaData); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetReplicationInfoReply_AttributeValueMetadata) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_pAttrValueMetaData := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.AttributeValueMetadata == nil {
			o.AttributeValueMetadata = &DSReplicationAttributeValueMetadata{}
		}
		if err := o.AttributeValueMetadata.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pAttrValueMetaData := func(ptr interface{}) { o.AttributeValueMetadata = *ptr.(**DSReplicationAttributeValueMetadata) }
	if err := w.ReadPointer(&o.AttributeValueMetadata, _s_pAttrValueMetaData, _ptr_pAttrValueMetaData); err != nil {
		return err
	}
	return nil
}

// MessageGetReplicationInfoReply_Cursors2 structure represents DRS_MSG_GETREPLINFO_REPLY RPC union arm.
//
// It has following labels: 7
type MessageGetReplicationInfoReply_Cursors2 struct {
	// pCursors2:  Cursors for an NC replica.
	Cursors2 *DSReplicationCursors2 `idl:"name:pCursors2" json:"cursors2"`
}

func (*MessageGetReplicationInfoReply_Cursors2) is_MessageGetReplicationInfoReply() {}

func (o *MessageGetReplicationInfoReply_Cursors2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Cursors2 != nil {
		_ptr_pCursors2 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Cursors2 != nil {
				if err := o.Cursors2.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSReplicationCursors2{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Cursors2, _ptr_pCursors2); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetReplicationInfoReply_Cursors2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_pCursors2 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Cursors2 == nil {
			o.Cursors2 = &DSReplicationCursors2{}
		}
		if err := o.Cursors2.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pCursors2 := func(ptr interface{}) { o.Cursors2 = *ptr.(**DSReplicationCursors2) }
	if err := w.ReadPointer(&o.Cursors2, _s_pCursors2, _ptr_pCursors2); err != nil {
		return err
	}
	return nil
}

// MessageGetReplicationInfoReply_Cursors3 structure represents DRS_MSG_GETREPLINFO_REPLY RPC union arm.
//
// It has following labels: 8
type MessageGetReplicationInfoReply_Cursors3 struct {
	// pCursors3:  Cursors for an NC replica.
	Cursors3 *DSReplicationCursorsV3 `idl:"name:pCursors3" json:"cursors3"`
}

func (*MessageGetReplicationInfoReply_Cursors3) is_MessageGetReplicationInfoReply() {}

func (o *MessageGetReplicationInfoReply_Cursors3) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Cursors3 != nil {
		_ptr_pCursors3 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Cursors3 != nil {
				if err := o.Cursors3.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSReplicationCursorsV3{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Cursors3, _ptr_pCursors3); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetReplicationInfoReply_Cursors3) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_pCursors3 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Cursors3 == nil {
			o.Cursors3 = &DSReplicationCursorsV3{}
		}
		if err := o.Cursors3.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pCursors3 := func(ptr interface{}) { o.Cursors3 = *ptr.(**DSReplicationCursorsV3) }
	if err := w.ReadPointer(&o.Cursors3, _s_pCursors3, _ptr_pCursors3); err != nil {
		return err
	}
	return nil
}

// MessageGetReplicationInfoReply_ObjectMetaData2 structure represents DRS_MSG_GETREPLINFO_REPLY RPC union arm.
//
// It has following labels: 9
type MessageGetReplicationInfoReply_ObjectMetaData2 struct {
	// pObjMetaData2:  Attribute stamps.
	ObjectMetaData2 *DSReplicationObjectMetadata2 `idl:"name:pObjMetaData2" json:"object_meta_data2"`
}

func (*MessageGetReplicationInfoReply_ObjectMetaData2) is_MessageGetReplicationInfoReply() {}

func (o *MessageGetReplicationInfoReply_ObjectMetaData2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ObjectMetaData2 != nil {
		_ptr_pObjMetaData2 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ObjectMetaData2 != nil {
				if err := o.ObjectMetaData2.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSReplicationObjectMetadata2{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ObjectMetaData2, _ptr_pObjMetaData2); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetReplicationInfoReply_ObjectMetaData2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_pObjMetaData2 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ObjectMetaData2 == nil {
			o.ObjectMetaData2 = &DSReplicationObjectMetadata2{}
		}
		if err := o.ObjectMetaData2.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pObjMetaData2 := func(ptr interface{}) { o.ObjectMetaData2 = *ptr.(**DSReplicationObjectMetadata2) }
	if err := w.ReadPointer(&o.ObjectMetaData2, _s_pObjMetaData2, _ptr_pObjMetaData2); err != nil {
		return err
	}
	return nil
}

// MessageGetReplicationInfoReply_AttributeValueMetaData2 structure represents DRS_MSG_GETREPLINFO_REPLY RPC union arm.
//
// It has following labels: 10
type MessageGetReplicationInfoReply_AttributeValueMetaData2 struct {
	// pAttrValueMetaData2:  Link value stamps.
	AttributeValueMetaData2 *DSReplicationAttributeValueMetadata2 `idl:"name:pAttrValueMetaData2" json:"attribute_value_meta_data2"`
}

func (*MessageGetReplicationInfoReply_AttributeValueMetaData2) is_MessageGetReplicationInfoReply() {}

func (o *MessageGetReplicationInfoReply_AttributeValueMetaData2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.AttributeValueMetaData2 != nil {
		_ptr_pAttrValueMetaData2 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.AttributeValueMetaData2 != nil {
				if err := o.AttributeValueMetaData2.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSReplicationAttributeValueMetadata2{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.AttributeValueMetaData2, _ptr_pAttrValueMetaData2); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetReplicationInfoReply_AttributeValueMetaData2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_pAttrValueMetaData2 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.AttributeValueMetaData2 == nil {
			o.AttributeValueMetaData2 = &DSReplicationAttributeValueMetadata2{}
		}
		if err := o.AttributeValueMetaData2.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pAttrValueMetaData2 := func(ptr interface{}) { o.AttributeValueMetaData2 = *ptr.(**DSReplicationAttributeValueMetadata2) }
	if err := w.ReadPointer(&o.AttributeValueMetaData2, _s_pAttrValueMetaData2, _ptr_pAttrValueMetaData2); err != nil {
		return err
	}
	return nil
}

// MessageGetReplicationInfoReply_ServerOutgoingCalls structure represents DRS_MSG_GETREPLINFO_REPLY RPC union arm.
//
// It has following labels: 4294967290
type MessageGetReplicationInfoReply_ServerOutgoingCalls struct {
	// pServerOutgoingCalls:  Outstanding requests from this DC to other DCs.
	ServerOutgoingCalls *DSReplicationServerOutgoingCalls `idl:"name:pServerOutgoingCalls" json:"server_outgoing_calls"`
}

func (*MessageGetReplicationInfoReply_ServerOutgoingCalls) is_MessageGetReplicationInfoReply() {}

func (o *MessageGetReplicationInfoReply_ServerOutgoingCalls) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerOutgoingCalls != nil {
		_ptr_pServerOutgoingCalls := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ServerOutgoingCalls != nil {
				if err := o.ServerOutgoingCalls.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSReplicationServerOutgoingCalls{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ServerOutgoingCalls, _ptr_pServerOutgoingCalls); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetReplicationInfoReply_ServerOutgoingCalls) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_pServerOutgoingCalls := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ServerOutgoingCalls == nil {
			o.ServerOutgoingCalls = &DSReplicationServerOutgoingCalls{}
		}
		if err := o.ServerOutgoingCalls.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pServerOutgoingCalls := func(ptr interface{}) { o.ServerOutgoingCalls = *ptr.(**DSReplicationServerOutgoingCalls) }
	if err := w.ReadPointer(&o.ServerOutgoingCalls, _s_pServerOutgoingCalls, _ptr_pServerOutgoingCalls); err != nil {
		return err
	}
	return nil
}

// MessageGetReplicationInfoReply_UpToDateVector structure represents DRS_MSG_GETREPLINFO_REPLY RPC union arm.
//
// It has following labels: 4294967291
type MessageGetReplicationInfoReply_UpToDateVector struct {
	// pUpToDateVec:  Cursors for an NC replica.
	UpToDateVector *UpToDateVectorV1Ext `idl:"name:pUpToDateVec" json:"up_to_date_vector"`
}

func (*MessageGetReplicationInfoReply_UpToDateVector) is_MessageGetReplicationInfoReply() {}

func (o *MessageGetReplicationInfoReply_UpToDateVector) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.UpToDateVector != nil {
		_ptr_pUpToDateVec := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.UpToDateVector != nil {
				if err := o.UpToDateVector.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&UpToDateVectorV1Ext{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.UpToDateVector, _ptr_pUpToDateVec); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetReplicationInfoReply_UpToDateVector) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_pUpToDateVec := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.UpToDateVector == nil {
			o.UpToDateVector = &UpToDateVectorV1Ext{}
		}
		if err := o.UpToDateVector.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pUpToDateVec := func(ptr interface{}) { o.UpToDateVector = *ptr.(**UpToDateVectorV1Ext) }
	if err := w.ReadPointer(&o.UpToDateVector, _s_pUpToDateVec, _ptr_pUpToDateVec); err != nil {
		return err
	}
	return nil
}

// MessageGetReplicationInfoReply_ClientContexts structure represents DRS_MSG_GETREPLINFO_REPLY RPC union arm.
//
// It has following labels: 4294967292
type MessageGetReplicationInfoReply_ClientContexts struct {
	// pClientContexts:  Active RPC client connections.
	ClientContexts *DSReplicationClientContexts `idl:"name:pClientContexts" json:"client_contexts"`
}

func (*MessageGetReplicationInfoReply_ClientContexts) is_MessageGetReplicationInfoReply() {}

func (o *MessageGetReplicationInfoReply_ClientContexts) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ClientContexts != nil {
		_ptr_pClientContexts := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ClientContexts != nil {
				if err := o.ClientContexts.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSReplicationClientContexts{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ClientContexts, _ptr_pClientContexts); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetReplicationInfoReply_ClientContexts) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_pClientContexts := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ClientContexts == nil {
			o.ClientContexts = &DSReplicationClientContexts{}
		}
		if err := o.ClientContexts.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pClientContexts := func(ptr interface{}) { o.ClientContexts = *ptr.(**DSReplicationClientContexts) }
	if err := w.ReadPointer(&o.ClientContexts, _s_pClientContexts, _ptr_pClientContexts); err != nil {
		return err
	}
	return nil
}

// MessageGetReplicationInfoReply_RepsTo structure represents DRS_MSG_GETREPLINFO_REPLY RPC union arm.
//
// It has following labels: 4294967294
type MessageGetReplicationInfoReply_RepsTo struct {
	// pRepsTo:  Neighbor information.
	RepsTo *DSReplicationNeighbors `idl:"name:pRepsTo" json:"reps_to"`
}

func (*MessageGetReplicationInfoReply_RepsTo) is_MessageGetReplicationInfoReply() {}

func (o *MessageGetReplicationInfoReply_RepsTo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.RepsTo != nil {
		_ptr_pRepsTo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.RepsTo != nil {
				if err := o.RepsTo.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSReplicationNeighbors{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.RepsTo, _ptr_pRepsTo); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetReplicationInfoReply_RepsTo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_pRepsTo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.RepsTo == nil {
			o.RepsTo = &DSReplicationNeighbors{}
		}
		if err := o.RepsTo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pRepsTo := func(ptr interface{}) { o.RepsTo = *ptr.(**DSReplicationNeighbors) }
	if err := w.ReadPointer(&o.RepsTo, _s_pRepsTo, _ptr_pRepsTo); err != nil {
		return err
	}
	return nil
}

// MessageAddSIDHistoryRequestV1 structure represents DRS_MSG_ADDSIDREQ_V1 RPC structure.
//
// The DRS_MSG_ADDSIDREQ_V1 structure defines the request message sent to the IDL_DRSAddSidHistory
// method.
type MessageAddSIDHistoryRequestV1 struct {
	// Flags:  A set of zero or more DRS_ADDSID_FLAGS bit flags.
	Flags uint32 `idl:"name:Flags" json:"flags"`
	// SrcDomain:  Name of the domain to query for the SID of SrcPrincipal. The domain name
	// can be an FQDN (1) or a NetBIOS name.
	SourceDomain string `idl:"name:SrcDomain;string" json:"source_domain"`
	// SrcPrincipal:  Name of a security principal (user, computer, or group) in the source
	// domain. This is the source security principal, whose SIDs will be added to the destination
	// security principal. If Flags contains DS_ADDSID_FLAG_PRIVATE_CHK_SECURE, this parameter
	// is not used and is not validated. Otherwise, if Flags does not contain DS_ADDSID_FLAG_PRIVATE_DEL_SRC_OBJ,
	// this name is a domain-relative Security Accounts Manager (SAM) name. Otherwise, it
	// is a DN.
	SourcePrincipal string `idl:"name:SrcPrincipal;string" json:"source_principal"`
	// SrcDomainController:  Name of the primary domain controller (PDC) (or PDC role owner)
	// in the source domain. The DC name can be an Internet host name or a NetBIOS name.
	// This parameter is only used when Flags contains neither DS_ADDSID_FLAG_PRIVATE_CHK_SECURE
	// nor DS_ADDSID_FLAG_PRIVATE_DEL_SRC_OBJ. If Flags contains DS_ADDSID_FLAG_PRIVATE_DEL_SRC_OBJ,
	// this parameter is not used, but it is validated.
	SourceDomainController string `idl:"name:SrcDomainController;string;pointer:ptr" json:"source_domain_controller"`
	// SrcCredsUserLength:  Count of characters in the SrcCredsUser array.
	SourceCredsUserLength uint32 `idl:"name:SrcCredsUserLength" json:"source_creds_user_length"`
	// SrcCredsUser:  User name for the credentials to be used in the source domain.
	SourceCredsUser string `idl:"name:SrcCredsUser;size_is:(SrcCredsUserLength)" json:"source_creds_user"`
	// SrcCredsDomainLength:  Count of characters in the SrcCredsDomain array.
	SourceCredsDomainLength uint32 `idl:"name:SrcCredsDomainLength" json:"source_creds_domain_length"`
	// SrcCredsDomain:  Domain name for the credentials to be used in the source domain.
	// The domain name can be an FQDN (1) or a NetBIOS domain name.
	SourceCredsDomain string `idl:"name:SrcCredsDomain;size_is:(SrcCredsDomainLength)" json:"source_creds_domain"`
	// SrcCredsPasswordLength:  Count of characters in the SrcCredsPassword array.
	SourceCredsPasswordLength uint32 `idl:"name:SrcCredsPasswordLength" json:"source_creds_password_length"`
	// SrcCredsPassword:  Password for the credentials to be used in the source domain.
	SourceCredsPassword string `idl:"name:SrcCredsPassword;size_is:(SrcCredsPasswordLength)" json:"source_creds_password"`
	// DstDomain:  Name of the destination domain in which DstPrincipal resides. The domain
	// name can be an FQDN (1) or a NetBIOS name.
	DestinationDomain string `idl:"name:DstDomain;string" json:"destination_domain"`
	// DstPrincipal:  Name of a security principal (user, computer, or group) in the destination
	// domain. This is the destination principal, to which the source principal's SIDs will
	// be added. If Flags contains DS_ADDSID_FLAG_PRIVATE_CHK_SECURE, this parameter is
	// not used and is not validated. Otherwise, if Flags does not contain DS_ADDSID_FLAG_PRIVATE_DEL_SRC_OBJ,
	// this name is a domain-relative SAM name. Otherwise, it is a DN.
	DestinationPrincipal string `idl:"name:DstPrincipal;string" json:"destination_principal"`
}

func (o *MessageAddSIDHistoryRequestV1) xxx_PreparePayload(ctx context.Context) error {
	if o.SourceCredsUser != "" && o.SourceCredsUserLength == 0 {
		o.SourceCredsUserLength = uint32(len(o.SourceCredsUser))
	}
	if o.SourceCredsDomain != "" && o.SourceCredsDomainLength == 0 {
		o.SourceCredsDomainLength = uint32(len(o.SourceCredsDomain))
	}
	if o.SourceCredsPassword != "" && o.SourceCredsPasswordLength == 0 {
		o.SourceCredsPasswordLength = uint32(len(o.SourceCredsPassword))
	}
	if o.SourceCredsUserLength > uint32(256) {
		return fmt.Errorf("SourceCredsUserLength is out of range")
	}
	if o.SourceCredsDomainLength > uint32(256) {
		return fmt.Errorf("SourceCredsDomainLength is out of range")
	}
	if o.SourceCredsPasswordLength > uint32(256) {
		return fmt.Errorf("SourceCredsPasswordLength is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageAddSIDHistoryRequestV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	if o.SourceDomain != "" {
		_ptr_SrcDomain := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.SourceDomain); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.SourceDomain, _ptr_SrcDomain); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.SourcePrincipal != "" {
		_ptr_SrcPrincipal := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.SourcePrincipal); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.SourcePrincipal, _ptr_SrcPrincipal); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.SourceDomainController != "" {
		_ptr_SrcDomainController := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.SourceDomainController); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.SourceDomainController, _ptr_SrcDomainController); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.SourceCredsUserLength); err != nil {
		return err
	}
	if o.SourceCredsUser != "" || o.SourceCredsUserLength > 0 {
		_ptr_SrcCredsUser := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.SourceCredsUserLength)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			_SourceCredsUser_buf := utf16.Encode([]rune(o.SourceCredsUser))
			if uint64(len(_SourceCredsUser_buf)) > sizeInfo[0] {
				_SourceCredsUser_buf = _SourceCredsUser_buf[:sizeInfo[0]]
			}
			for i1 := range _SourceCredsUser_buf {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(_SourceCredsUser_buf[i1]); err != nil {
					return err
				}
			}
			for i1 := len(_SourceCredsUser_buf); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint16(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.SourceCredsUser, _ptr_SrcCredsUser); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.SourceCredsDomainLength); err != nil {
		return err
	}
	if o.SourceCredsDomain != "" || o.SourceCredsDomainLength > 0 {
		_ptr_SrcCredsDomain := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.SourceCredsDomainLength)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			_SourceCredsDomain_buf := utf16.Encode([]rune(o.SourceCredsDomain))
			if uint64(len(_SourceCredsDomain_buf)) > sizeInfo[0] {
				_SourceCredsDomain_buf = _SourceCredsDomain_buf[:sizeInfo[0]]
			}
			for i1 := range _SourceCredsDomain_buf {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(_SourceCredsDomain_buf[i1]); err != nil {
					return err
				}
			}
			for i1 := len(_SourceCredsDomain_buf); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint16(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.SourceCredsDomain, _ptr_SrcCredsDomain); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.SourceCredsPasswordLength); err != nil {
		return err
	}
	if o.SourceCredsPassword != "" || o.SourceCredsPasswordLength > 0 {
		_ptr_SrcCredsPassword := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.SourceCredsPasswordLength)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			_SourceCredsPassword_buf := utf16.Encode([]rune(o.SourceCredsPassword))
			if uint64(len(_SourceCredsPassword_buf)) > sizeInfo[0] {
				_SourceCredsPassword_buf = _SourceCredsPassword_buf[:sizeInfo[0]]
			}
			for i1 := range _SourceCredsPassword_buf {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(_SourceCredsPassword_buf[i1]); err != nil {
					return err
				}
			}
			for i1 := len(_SourceCredsPassword_buf); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint16(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.SourceCredsPassword, _ptr_SrcCredsPassword); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.DestinationDomain != "" {
		_ptr_DstDomain := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.DestinationDomain); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.DestinationDomain, _ptr_DstDomain); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.DestinationPrincipal != "" {
		_ptr_DstPrincipal := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.DestinationPrincipal); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.DestinationPrincipal, _ptr_DstPrincipal); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageAddSIDHistoryRequestV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	_ptr_SrcDomain := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.SourceDomain); err != nil {
			return err
		}
		return nil
	})
	_s_SrcDomain := func(ptr interface{}) { o.SourceDomain = *ptr.(*string) }
	if err := w.ReadPointer(&o.SourceDomain, _s_SrcDomain, _ptr_SrcDomain); err != nil {
		return err
	}
	_ptr_SrcPrincipal := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.SourcePrincipal); err != nil {
			return err
		}
		return nil
	})
	_s_SrcPrincipal := func(ptr interface{}) { o.SourcePrincipal = *ptr.(*string) }
	if err := w.ReadPointer(&o.SourcePrincipal, _s_SrcPrincipal, _ptr_SrcPrincipal); err != nil {
		return err
	}
	_ptr_SrcDomainController := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.SourceDomainController); err != nil {
			return err
		}
		return nil
	})
	_s_SrcDomainController := func(ptr interface{}) { o.SourceDomainController = *ptr.(*string) }
	if err := w.ReadPointer(&o.SourceDomainController, _s_SrcDomainController, _ptr_SrcDomainController); err != nil {
		return err
	}
	if err := w.ReadData(&o.SourceCredsUserLength); err != nil {
		return err
	}
	_ptr_SrcCredsUser := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.SourceCredsUserLength > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.SourceCredsUserLength)
		}
		var _SourceCredsUser_buf []uint16
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array _SourceCredsUser_buf", sizeInfo[0])
		}
		_SourceCredsUser_buf = make([]uint16, sizeInfo[0])
		for i1 := range _SourceCredsUser_buf {
			i1 := i1
			if err := w.ReadData(&_SourceCredsUser_buf[i1]); err != nil {
				return err
			}
		}
		o.SourceCredsUser = strings.TrimRight(string(utf16.Decode(_SourceCredsUser_buf)), ndr.ZeroString)
		return nil
	})
	_s_SrcCredsUser := func(ptr interface{}) { o.SourceCredsUser = *ptr.(*string) }
	if err := w.ReadPointer(&o.SourceCredsUser, _s_SrcCredsUser, _ptr_SrcCredsUser); err != nil {
		return err
	}
	if err := w.ReadData(&o.SourceCredsDomainLength); err != nil {
		return err
	}
	_ptr_SrcCredsDomain := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.SourceCredsDomainLength > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.SourceCredsDomainLength)
		}
		var _SourceCredsDomain_buf []uint16
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array _SourceCredsDomain_buf", sizeInfo[0])
		}
		_SourceCredsDomain_buf = make([]uint16, sizeInfo[0])
		for i1 := range _SourceCredsDomain_buf {
			i1 := i1
			if err := w.ReadData(&_SourceCredsDomain_buf[i1]); err != nil {
				return err
			}
		}
		o.SourceCredsDomain = strings.TrimRight(string(utf16.Decode(_SourceCredsDomain_buf)), ndr.ZeroString)
		return nil
	})
	_s_SrcCredsDomain := func(ptr interface{}) { o.SourceCredsDomain = *ptr.(*string) }
	if err := w.ReadPointer(&o.SourceCredsDomain, _s_SrcCredsDomain, _ptr_SrcCredsDomain); err != nil {
		return err
	}
	if err := w.ReadData(&o.SourceCredsPasswordLength); err != nil {
		return err
	}
	_ptr_SrcCredsPassword := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.SourceCredsPasswordLength > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.SourceCredsPasswordLength)
		}
		var _SourceCredsPassword_buf []uint16
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array _SourceCredsPassword_buf", sizeInfo[0])
		}
		_SourceCredsPassword_buf = make([]uint16, sizeInfo[0])
		for i1 := range _SourceCredsPassword_buf {
			i1 := i1
			if err := w.ReadData(&_SourceCredsPassword_buf[i1]); err != nil {
				return err
			}
		}
		o.SourceCredsPassword = strings.TrimRight(string(utf16.Decode(_SourceCredsPassword_buf)), ndr.ZeroString)
		return nil
	})
	_s_SrcCredsPassword := func(ptr interface{}) { o.SourceCredsPassword = *ptr.(*string) }
	if err := w.ReadPointer(&o.SourceCredsPassword, _s_SrcCredsPassword, _ptr_SrcCredsPassword); err != nil {
		return err
	}
	_ptr_DstDomain := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.DestinationDomain); err != nil {
			return err
		}
		return nil
	})
	_s_DstDomain := func(ptr interface{}) { o.DestinationDomain = *ptr.(*string) }
	if err := w.ReadPointer(&o.DestinationDomain, _s_DstDomain, _ptr_DstDomain); err != nil {
		return err
	}
	_ptr_DstPrincipal := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.DestinationPrincipal); err != nil {
			return err
		}
		return nil
	})
	_s_DstPrincipal := func(ptr interface{}) { o.DestinationPrincipal = *ptr.(*string) }
	if err := w.ReadPointer(&o.DestinationPrincipal, _s_DstPrincipal, _ptr_DstPrincipal); err != nil {
		return err
	}
	return nil
}

// MessageAddSIDHistoryRequest structure represents DRS_MSG_ADDSIDREQ RPC union.
//
// The DRS_MSG_ADDSIDREQ union defines the request messages that are sent to the IDL_DRSAddSidHistory
// method. Only one version, identified by dwInVersion = 1, is currently defined.
type MessageAddSIDHistoryRequest struct {
	// Types that are assignable to Value
	//
	// *MessageAddSIDHistoryRequest_V1
	Value is_MessageAddSIDHistoryRequest `json:"value"`
}

func (o *MessageAddSIDHistoryRequest) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageAddSIDHistoryRequest_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_MessageAddSIDHistoryRequest interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageAddSIDHistoryRequest()
}

func (o *MessageAddSIDHistoryRequest) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageAddSIDHistoryRequest_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *MessageAddSIDHistoryRequest) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageAddSIDHistoryRequest_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageAddSIDHistoryRequest_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageAddSIDHistoryRequest) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageAddSIDHistoryRequest_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageAddSIDHistoryRequest_V1 structure represents DRS_MSG_ADDSIDREQ RPC union arm.
//
// It has following labels: 1
type MessageAddSIDHistoryRequest_V1 struct {
	// V1:  Version 1 request.
	V1 *MessageAddSIDHistoryRequestV1 `idl:"name:V1" json:"v1"`
}

func (*MessageAddSIDHistoryRequest_V1) is_MessageAddSIDHistoryRequest() {}

func (o *MessageAddSIDHistoryRequest_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageAddSIDHistoryRequestV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageAddSIDHistoryRequest_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageAddSIDHistoryRequestV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageAddSIDHistoryReplyV1 structure represents DRS_MSG_ADDSIDREPLY_V1 RPC structure.
//
// The DRS_MSG_ADDSIDREPLY_V1 structure defines the response message received from the
// IDL_DRSAddSidHistory method.
type MessageAddSIDHistoryReplyV1 struct {
	// dwWin32Error:  Zero if successful, otherwise a Windows error code.
	Win32Error uint32 `idl:"name:dwWin32Error" json:"win32_error"`
}

func (o *MessageAddSIDHistoryReplyV1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageAddSIDHistoryReplyV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Win32Error); err != nil {
		return err
	}
	return nil
}
func (o *MessageAddSIDHistoryReplyV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Win32Error); err != nil {
		return err
	}
	return nil
}

// MessageAddSIDHistoryReply structure represents DRS_MSG_ADDSIDREPLY RPC union.
//
// The DRS_MSG_ADDSIDREPLY union defines the response messages received from the IDL_DRSAddSidHistory
// method. Only one version, identified by pdwOutVersion^ = 1, is currently defined.
type MessageAddSIDHistoryReply struct {
	// Types that are assignable to Value
	//
	// *MessageAddSIDHistoryReply_V1
	Value is_MessageAddSIDHistoryReply `json:"value"`
}

func (o *MessageAddSIDHistoryReply) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageAddSIDHistoryReply_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_MessageAddSIDHistoryReply interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageAddSIDHistoryReply()
}

func (o *MessageAddSIDHistoryReply) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageAddSIDHistoryReply_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *MessageAddSIDHistoryReply) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(4); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(4); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageAddSIDHistoryReply_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageAddSIDHistoryReply_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageAddSIDHistoryReply) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(4); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(4); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageAddSIDHistoryReply_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageAddSIDHistoryReply_V1 structure represents DRS_MSG_ADDSIDREPLY RPC union arm.
//
// It has following labels: 1
type MessageAddSIDHistoryReply_V1 struct {
	// V1:  Version 1 of the reply packet structure.
	V1 *MessageAddSIDHistoryReplyV1 `idl:"name:V1" json:"v1"`
}

func (*MessageAddSIDHistoryReply_V1) is_MessageAddSIDHistoryReply() {}

func (o *MessageAddSIDHistoryReply_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageAddSIDHistoryReplyV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageAddSIDHistoryReply_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageAddSIDHistoryReplyV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageGetMemberships2RequestV1 structure represents DRS_MSG_GETMEMBERSHIPS2_REQ_V1 RPC structure.
//
// The DRS_MSG_GETMEMBERSHIPS2_REQ_V1 structure defines the request message sent to
// the IDL_DRSGetMemberships2 method.
type MessageGetMemberships2RequestV1 struct {
	// Count:  Count of items in the Requests array.
	Count uint32 `idl:"name:Count" json:"count"`
	// Requests:  Sequence of reverse membership requests.
	Requests []*MessageReverseMembershipRequestV1 `idl:"name:Requests;size_is:(Count)" json:"requests"`
}

func (o *MessageGetMemberships2RequestV1) xxx_PreparePayload(ctx context.Context) error {
	if o.Requests != nil && o.Count == 0 {
		o.Count = uint32(len(o.Requests))
	}
	if o.Count < uint32(1) || o.Count > uint32(10000) {
		return fmt.Errorf("Count is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetMemberships2RequestV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.Count); err != nil {
		return err
	}
	if o.Requests != nil || o.Count > 0 {
		_ptr_Requests := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.Count)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Requests {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Requests[i1] != nil {
					if err := o.Requests[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&MessageReverseMembershipRequestV1{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Requests); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&MessageReverseMembershipRequestV1{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Requests, _ptr_Requests); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetMemberships2RequestV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.Count); err != nil {
		return err
	}
	_ptr_Requests := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.Count > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.Count)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Requests", sizeInfo[0])
		}
		o.Requests = make([]*MessageReverseMembershipRequestV1, sizeInfo[0])
		for i1 := range o.Requests {
			i1 := i1
			if o.Requests[i1] == nil {
				o.Requests[i1] = &MessageReverseMembershipRequestV1{}
			}
			if err := o.Requests[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_Requests := func(ptr interface{}) { o.Requests = *ptr.(*[]*MessageReverseMembershipRequestV1) }
	if err := w.ReadPointer(&o.Requests, _s_Requests, _ptr_Requests); err != nil {
		return err
	}
	return nil
}

// MessageGetMemberships2Request structure represents DRS_MSG_GETMEMBERSHIPS2_REQ RPC union.
//
// The DRS_MSG_GETMEMBERSHIPS2_REQ union defines request messages sent to the IDL_DRSGetMemberships2
// method. Only one version, identified by dwInVersion = 1, is currently defined.
type MessageGetMemberships2Request struct {
	// Types that are assignable to Value
	//
	// *MessageGetMemberships2Request_V1
	Value is_MessageGetMemberships2Request `json:"value"`
}

func (o *MessageGetMemberships2Request) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageGetMemberships2Request_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_MessageGetMemberships2Request interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageGetMemberships2Request()
}

func (o *MessageGetMemberships2Request) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageGetMemberships2Request_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *MessageGetMemberships2Request) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageGetMemberships2Request_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageGetMemberships2Request_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageGetMemberships2Request) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageGetMemberships2Request_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageGetMemberships2Request_V1 structure represents DRS_MSG_GETMEMBERSHIPS2_REQ RPC union arm.
//
// It has following labels: 1
type MessageGetMemberships2Request_V1 struct {
	// V1:  Version 1 request.
	V1 *MessageGetMemberships2RequestV1 `idl:"name:V1" json:"v1"`
}

func (*MessageGetMemberships2Request_V1) is_MessageGetMemberships2Request() {}

func (o *MessageGetMemberships2Request_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageGetMemberships2RequestV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetMemberships2Request_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageGetMemberships2RequestV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageGetMemberships2ReplyV1 structure represents DRS_MSG_GETMEMBERSHIPS2_REPLY_V1 RPC structure.
//
// The DRS_MSG_GETMEMBERSHIPS2_REPLY_V1 structure defines the response message received
// from the IDL_DRSGetMemberships2 method.
type MessageGetMemberships2ReplyV1 struct {
	// Count:  Count of items in the Replies array.
	Count uint32 `idl:"name:Count" json:"count"`
	// Replies:  Sequence of reverse membership replies, in the same order as the Requests
	// field of the request message.
	Replies []*MessageReverseMembershipReplyV1 `idl:"name:Replies;size_is:(Count)" json:"replies"`
}

func (o *MessageGetMemberships2ReplyV1) xxx_PreparePayload(ctx context.Context) error {
	if o.Replies != nil && o.Count == 0 {
		o.Count = uint32(len(o.Replies))
	}
	if o.Count > uint32(10000) {
		return fmt.Errorf("Count is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetMemberships2ReplyV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.Count); err != nil {
		return err
	}
	if o.Replies != nil || o.Count > 0 {
		_ptr_Replies := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.Count)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Replies {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Replies[i1] != nil {
					if err := o.Replies[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&MessageReverseMembershipReplyV1{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Replies); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&MessageReverseMembershipReplyV1{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Replies, _ptr_Replies); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetMemberships2ReplyV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.Count); err != nil {
		return err
	}
	_ptr_Replies := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.Count > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.Count)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Replies", sizeInfo[0])
		}
		o.Replies = make([]*MessageReverseMembershipReplyV1, sizeInfo[0])
		for i1 := range o.Replies {
			i1 := i1
			if o.Replies[i1] == nil {
				o.Replies[i1] = &MessageReverseMembershipReplyV1{}
			}
			if err := o.Replies[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_Replies := func(ptr interface{}) { o.Replies = *ptr.(*[]*MessageReverseMembershipReplyV1) }
	if err := w.ReadPointer(&o.Replies, _s_Replies, _ptr_Replies); err != nil {
		return err
	}
	return nil
}

// MessageGetMemberships2Reply structure represents DRS_MSG_GETMEMBERSHIPS2_REPLY RPC union.
//
// The DRS_MSG_GETMEMBERSHIPS2_REPLY union defines response messages received from the
// IDL_DRSGetMemberships2 method. Only one version, identified by pdwOutVersion^ = 1,
// is currently defined.
type MessageGetMemberships2Reply struct {
	// Types that are assignable to Value
	//
	// *MessageGetMemberships2Reply_V1
	Value is_MessageGetMemberships2Reply `json:"value"`
}

func (o *MessageGetMemberships2Reply) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageGetMemberships2Reply_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_MessageGetMemberships2Reply interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageGetMemberships2Reply()
}

func (o *MessageGetMemberships2Reply) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageGetMemberships2Reply_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *MessageGetMemberships2Reply) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageGetMemberships2Reply_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageGetMemberships2Reply_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageGetMemberships2Reply) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageGetMemberships2Reply_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageGetMemberships2Reply_V1 structure represents DRS_MSG_GETMEMBERSHIPS2_REPLY RPC union arm.
//
// It has following labels: 1
type MessageGetMemberships2Reply_V1 struct {
	// V1:  Version 1 response.
	V1 *MessageGetMemberships2ReplyV1 `idl:"name:V1" json:"v1"`
}

func (*MessageGetMemberships2Reply_V1) is_MessageGetMemberships2Reply() {}

func (o *MessageGetMemberships2Reply_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageGetMemberships2ReplyV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageGetMemberships2Reply_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageGetMemberships2ReplyV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageVerifyReplyObjectV1 structure represents DRS_MSG_REPVERIFYOBJ_V1 RPC structure.
//
// The DRS_MSG_REPVERIFYOBJ_V1 structure defines a request message sent to the IDL_DRSReplicaVerifyObjects
// method.
type MessageVerifyReplyObjectV1 struct {
	// pNC:  The NC to verify.
	NC *DSName `idl:"name:pNC;pointer:ref" json:"nc"`
	// uuidDsaSrc:  The objectGUID of the nTDSDSA object for the reference DC.
	DSASourceID *dtyp.UUID `idl:"name:uuidDsaSrc" json:"dsa_source_id"`
	// ulOptions:  0 to expunge each object that is not verified, or 1 to log an event that
	// identifies each such object.
	Options uint32 `idl:"name:ulOptions" json:"options"`
}

func (o *MessageVerifyReplyObjectV1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageVerifyReplyObjectV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.NC != nil {
		_ptr_pNC := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.NC != nil {
				if err := o.NC.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSName{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.NC, _ptr_pNC); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.DSASourceID != nil {
		if err := o.DSASourceID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Options); err != nil {
		return err
	}
	return nil
}
func (o *MessageVerifyReplyObjectV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_pNC := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.NC == nil {
			o.NC = &DSName{}
		}
		if err := o.NC.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pNC := func(ptr interface{}) { o.NC = *ptr.(**DSName) }
	if err := w.ReadPointer(&o.NC, _s_pNC, _ptr_pNC); err != nil {
		return err
	}
	if o.DSASourceID == nil {
		o.DSASourceID = &dtyp.UUID{}
	}
	if err := o.DSASourceID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.Options); err != nil {
		return err
	}
	return nil
}

// MessageVerifyReplyObject structure represents DRS_MSG_REPVERIFYOBJ RPC union.
//
// The DRS_MSG_REPVERIFYOBJ union defines the request messages sent to the IDL_DRSReplicaVerifyObjects
// method. Only one version, identified by dwVersion = 1, is currently defined.
type MessageVerifyReplyObject struct {
	// Types that are assignable to Value
	//
	// *MessageVerifyReplyObject_V1
	Value is_MessageVerifyReplyObject `json:"value"`
}

func (o *MessageVerifyReplyObject) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageVerifyReplyObject_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_MessageVerifyReplyObject interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageVerifyReplyObject()
}

func (o *MessageVerifyReplyObject) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageVerifyReplyObject_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *MessageVerifyReplyObject) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageVerifyReplyObject_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageVerifyReplyObject_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageVerifyReplyObject) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageVerifyReplyObject_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageVerifyReplyObject_V1 structure represents DRS_MSG_REPVERIFYOBJ RPC union arm.
//
// It has following labels: 1
type MessageVerifyReplyObject_V1 struct {
	// V1:  The version 1 request.
	V1 *MessageVerifyReplyObjectV1 `idl:"name:V1" json:"v1"`
}

func (*MessageVerifyReplyObject_V1) is_MessageVerifyReplyObject() {}

func (o *MessageVerifyReplyObject_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageVerifyReplyObjectV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageVerifyReplyObject_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageVerifyReplyObjectV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageExistRequestV1 structure represents DRS_MSG_EXISTREQ_V1 RPC structure.
//
// The DRS_MSG_EXISTREQ_V1 structure defines the request message sent to the IDL_DRSGetObjectExistence
// method.
type MessageExistRequestV1 struct {
	// guidStart:  The objectGUID of the first object in the client's object sequence.
	Start *dtyp.UUID `idl:"name:guidStart" json:"start"`
	// cGuids:  The number of objects in the client's object sequence.
	GUIDsCount uint32 `idl:"name:cGuids" json:"guids_count"`
	// pNC:  The NC containing the objects in the sequence.
	NC *DSName `idl:"name:pNC" json:"nc"`
	// pUpToDateVecCommonV1:  The filter excluding objects from the client's object sequence.
	UpToDateVectorCommonV1 *UpToDateVectorV1Ext `idl:"name:pUpToDateVecCommonV1" json:"up_to_date_vector_common_v1"`
	// Md5Digest:  The digest of the objectGUID values of the objects in the client's object
	// sequence.
	MD5Digest []byte `idl:"name:Md5Digest" json:"md5_digest"`
}

func (o *MessageExistRequestV1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageExistRequestV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.Start != nil {
		if err := o.Start.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.GUIDsCount); err != nil {
		return err
	}
	if o.NC != nil {
		_ptr_pNC := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.NC != nil {
				if err := o.NC.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSName{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.NC, _ptr_pNC); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.UpToDateVectorCommonV1 != nil {
		_ptr_pUpToDateVecCommonV1 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.UpToDateVectorCommonV1 != nil {
				if err := o.UpToDateVectorCommonV1.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&UpToDateVectorV1Ext{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.UpToDateVectorCommonV1, _ptr_pUpToDateVecCommonV1); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	for i1 := range o.MD5Digest {
		i1 := i1
		if uint64(i1) >= 16 {
			break
		}
		if err := w.WriteData(o.MD5Digest[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.MD5Digest); uint64(i1) < 16; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageExistRequestV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if o.Start == nil {
		o.Start = &dtyp.UUID{}
	}
	if err := o.Start.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.GUIDsCount); err != nil {
		return err
	}
	_ptr_pNC := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.NC == nil {
			o.NC = &DSName{}
		}
		if err := o.NC.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pNC := func(ptr interface{}) { o.NC = *ptr.(**DSName) }
	if err := w.ReadPointer(&o.NC, _s_pNC, _ptr_pNC); err != nil {
		return err
	}
	_ptr_pUpToDateVecCommonV1 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.UpToDateVectorCommonV1 == nil {
			o.UpToDateVectorCommonV1 = &UpToDateVectorV1Ext{}
		}
		if err := o.UpToDateVectorCommonV1.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pUpToDateVecCommonV1 := func(ptr interface{}) { o.UpToDateVectorCommonV1 = *ptr.(**UpToDateVectorV1Ext) }
	if err := w.ReadPointer(&o.UpToDateVectorCommonV1, _s_pUpToDateVecCommonV1, _ptr_pUpToDateVecCommonV1); err != nil {
		return err
	}
	o.MD5Digest = make([]byte, 16)
	for i1 := range o.MD5Digest {
		i1 := i1
		if err := w.ReadData(&o.MD5Digest[i1]); err != nil {
			return err
		}
	}
	return nil
}

// MessageExistRequest structure represents DRS_MSG_EXISTREQ RPC union.
//
// The DRS_MSG_EXISTREQ union defines request messages sent to the IDL_DRSGetObjectExistence
// method. Only one version, identified by dwInVersion = 1, is currently defined.
type MessageExistRequest struct {
	// Types that are assignable to Value
	//
	// *MessageExistRequest_V1
	Value is_MessageExistRequest `json:"value"`
}

func (o *MessageExistRequest) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageExistRequest_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_MessageExistRequest interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageExistRequest()
}

func (o *MessageExistRequest) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageExistRequest_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *MessageExistRequest) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageExistRequest_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageExistRequest_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageExistRequest) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageExistRequest_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageExistRequest_V1 structure represents DRS_MSG_EXISTREQ RPC union arm.
//
// It has following labels: 1
type MessageExistRequest_V1 struct {
	// V1:  The version 1 request.
	V1 *MessageExistRequestV1 `idl:"name:V1" json:"v1"`
}

func (*MessageExistRequest_V1) is_MessageExistRequest() {}

func (o *MessageExistRequest_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageExistRequestV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageExistRequest_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageExistRequestV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageExistReplyV1 structure represents DRS_MSG_EXISTREPLY_V1 RPC structure.
//
// The DRS_MSG_EXISTREPLY_V1 structure defines the response message received from the
// IDL_DRSGetObjectExistence method.
type MessageExistReplyV1 struct {
	// dwStatusFlags:  1 if the digests of the object sequences on the client and server
	// are the same, 0 if they are different.
	StatusFlags uint32 `idl:"name:dwStatusFlags" json:"status_flags"`
	// cNumGuids:  The number of items in the rgGuids array. Zero if dwStatusFlags = 0.
	GUIDsCount uint32 `idl:"name:cNumGuids" json:"guids_count"`
	// rgGuids:   The objectGUIDs of the objects in the server's object sequence.
	GUIDs []*dtyp.UUID `idl:"name:rgGuids;size_is:(cNumGuids)" json:"guids"`
}

func (o *MessageExistReplyV1) xxx_PreparePayload(ctx context.Context) error {
	if o.GUIDs != nil && o.GUIDsCount == 0 {
		o.GUIDsCount = uint32(len(o.GUIDs))
	}
	if o.GUIDsCount > uint32(10485760) {
		return fmt.Errorf("GUIDsCount is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageExistReplyV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.StatusFlags); err != nil {
		return err
	}
	if err := w.WriteData(o.GUIDsCount); err != nil {
		return err
	}
	if o.GUIDs != nil || o.GUIDsCount > 0 {
		_ptr_rgGuids := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.GUIDsCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.GUIDs {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.GUIDs[i1] != nil {
					if err := o.GUIDs[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.GUIDs); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.GUIDs, _ptr_rgGuids); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageExistReplyV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.StatusFlags); err != nil {
		return err
	}
	if err := w.ReadData(&o.GUIDsCount); err != nil {
		return err
	}
	_ptr_rgGuids := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.GUIDsCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.GUIDsCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.GUIDs", sizeInfo[0])
		}
		o.GUIDs = make([]*dtyp.UUID, sizeInfo[0])
		for i1 := range o.GUIDs {
			i1 := i1
			if o.GUIDs[i1] == nil {
				o.GUIDs[i1] = &dtyp.UUID{}
			}
			if err := o.GUIDs[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_rgGuids := func(ptr interface{}) { o.GUIDs = *ptr.(*[]*dtyp.UUID) }
	if err := w.ReadPointer(&o.GUIDs, _s_rgGuids, _ptr_rgGuids); err != nil {
		return err
	}
	return nil
}

// MessageExistReply structure represents DRS_MSG_EXISTREPLY RPC union.
//
// The DRS_MSG_EXISTREPLY union defines the response message versions received from
// the IDL_DRSGetObjectExistence method. Only one version, identified by pdwOutVersion^
// = 1, is currently defined.
type MessageExistReply struct {
	// Types that are assignable to Value
	//
	// *MessageExistReply_V1
	Value is_MessageExistReply `json:"value"`
}

func (o *MessageExistReply) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageExistReply_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_MessageExistReply interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageExistReply()
}

func (o *MessageExistReply) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageExistReply_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *MessageExistReply) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageExistReply_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageExistReply_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageExistReply) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageExistReply_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageExistReply_V1 structure represents DRS_MSG_EXISTREPLY RPC union arm.
//
// It has following labels: 1
type MessageExistReply_V1 struct {
	// V1:  The version 1 response.
	V1 *MessageExistReplyV1 `idl:"name:V1" json:"v1"`
}

func (*MessageExistReply_V1) is_MessageExistReply() {}

func (o *MessageExistReply_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageExistReplyV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageExistReply_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageExistReplyV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageQuerySitesRequestV1 structure represents DRS_MSG_QUERYSITESREQ_V1 RPC structure.
//
// The DRS_MSG_QUERYSITESREQ_V1 structure defines a request message sent to the IDL_DRSQuerySitesByCost
// method.
type MessageQuerySitesRequestV1 struct {
	// pwszFromSite:  The RDN of the site object of the "from" site.
	FromSite string `idl:"name:pwszFromSite;string" json:"from_site"`
	// cToSites:  The number of items in the rgszToSites array (the count of "to" sites).
	ToSitesCount uint32 `idl:"name:cToSites" json:"to_sites_count"`
	// rgszToSites:  The RDNs of the site objects of the "to" sites.
	ToSites []string `idl:"name:rgszToSites;size_is:(cToSites);string" json:"to_sites"`
	// dwFlags:  Unused. MUST be 0 and ignored.
	Flags uint32 `idl:"name:dwFlags" json:"flags"`
}

func (o *MessageQuerySitesRequestV1) xxx_PreparePayload(ctx context.Context) error {
	if o.ToSites != nil && o.ToSitesCount == 0 {
		o.ToSitesCount = uint32(len(o.ToSites))
	}
	if o.ToSitesCount < uint32(1) || o.ToSitesCount > uint32(10000) {
		return fmt.Errorf("ToSitesCount is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageQuerySitesRequestV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.FromSite != "" {
		_ptr_pwszFromSite := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.FromSite); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.FromSite, _ptr_pwszFromSite); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.ToSitesCount); err != nil {
		return err
	}
	if o.ToSites != nil || o.ToSitesCount > 0 {
		_ptr_rgszToSites := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.ToSitesCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.ToSites {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.ToSites[i1] != "" {
					_ptr_rgszToSites := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
						if err := ndr.WriteUTF16NString(ctx, w, o.ToSites[i1]); err != nil {
							return err
						}
						return nil
					})
					if err := w.WritePointer(&o.ToSites[i1], _ptr_rgszToSites); err != nil {
						return err
					}
				} else {
					if err := w.WritePointer(nil); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.ToSites); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WritePointer(nil); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ToSites, _ptr_rgszToSites); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	return nil
}
func (o *MessageQuerySitesRequestV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_pwszFromSite := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.FromSite); err != nil {
			return err
		}
		return nil
	})
	_s_pwszFromSite := func(ptr interface{}) { o.FromSite = *ptr.(*string) }
	if err := w.ReadPointer(&o.FromSite, _s_pwszFromSite, _ptr_pwszFromSite); err != nil {
		return err
	}
	if err := w.ReadData(&o.ToSitesCount); err != nil {
		return err
	}
	_ptr_rgszToSites := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.ToSitesCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.ToSitesCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.ToSites", sizeInfo[0])
		}
		o.ToSites = make([]string, sizeInfo[0])
		for i1 := range o.ToSites {
			i1 := i1
			_ptr_rgszToSites := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
				if err := ndr.ReadUTF16NString(ctx, w, &o.ToSites[i1]); err != nil {
					return err
				}
				return nil
			})
			_s_rgszToSites := func(ptr interface{}) { o.ToSites[i1] = *ptr.(*string) }
			if err := w.ReadPointer(&o.ToSites[i1], _s_rgszToSites, _ptr_rgszToSites); err != nil {
				return err
			}
		}
		return nil
	})
	_s_rgszToSites := func(ptr interface{}) { o.ToSites = *ptr.(*[]string) }
	if err := w.ReadPointer(&o.ToSites, _s_rgszToSites, _ptr_rgszToSites); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	return nil
}

// MessageQuerySitesRequest structure represents DRS_MSG_QUERYSITESREQ RPC union.
//
// The DRS_MSG_QUERYSITESREQ union defines the request message versions sent to the
// IDL_DRSQuerySitesByCost method. Only one version, identified by dwInVersion = 1,
// is currently defined.
type MessageQuerySitesRequest struct {
	// Types that are assignable to Value
	//
	// *MessageQuerySitesRequest_V1
	Value is_MessageQuerySitesRequest `json:"value"`
}

func (o *MessageQuerySitesRequest) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageQuerySitesRequest_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_MessageQuerySitesRequest interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageQuerySitesRequest()
}

func (o *MessageQuerySitesRequest) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageQuerySitesRequest_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *MessageQuerySitesRequest) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageQuerySitesRequest_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageQuerySitesRequest_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageQuerySitesRequest) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageQuerySitesRequest_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageQuerySitesRequest_V1 structure represents DRS_MSG_QUERYSITESREQ RPC union arm.
//
// It has following labels: 1
type MessageQuerySitesRequest_V1 struct {
	// V1:  The version 1 request.
	V1 *MessageQuerySitesRequestV1 `idl:"name:V1" json:"v1"`
}

func (*MessageQuerySitesRequest_V1) is_MessageQuerySitesRequest() {}

func (o *MessageQuerySitesRequest_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageQuerySitesRequestV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageQuerySitesRequest_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageQuerySitesRequestV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageQuerySitesReplyElementV1 structure represents DRS_MSG_QUERYSITESREPLYELEMENT_V1 RPC structure.
//
// The DRS_MSG_QUERYSITESREPLYELEMENT_V1 structure defines the computed cost of communication
// between two sites.
type MessageQuerySitesReplyElementV1 struct {
	// dwErrorCode:  0 if this "from-to" computation was successful, or ERROR_DS_OBJ_NOT_FOUND
	// if the "to" site does not exist.
	ErrorCode uint32 `idl:"name:dwErrorCode" json:"error_code"`
	// dwCost:  The communication cost between the "from" site and this "to" site, or 0xFFFFFFFF
	// if the sites are not connected.
	Cost uint32 `idl:"name:dwCost" json:"cost"`
}

func (o *MessageQuerySitesReplyElementV1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageQuerySitesReplyElementV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.ErrorCode); err != nil {
		return err
	}
	if err := w.WriteData(o.Cost); err != nil {
		return err
	}
	return nil
}
func (o *MessageQuerySitesReplyElementV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.ErrorCode); err != nil {
		return err
	}
	if err := w.ReadData(&o.Cost); err != nil {
		return err
	}
	return nil
}

// MessageQuerySitesReplyV1 structure represents DRS_MSG_QUERYSITESREPLY_V1 RPC structure.
//
// The DRS_MSG_QUERYSITESREPLY_V1 structure defines a response message received from
// the IDL_DRSQuerySitesByCost method.
type MessageQuerySitesReplyV1 struct {
	// cToSites:  The number of items in the rgCostInfo array.
	ToSitesCount uint32 `idl:"name:cToSites" json:"to_sites_count"`
	// rgCostInfo:  The sequence of computed site costs, in the same order as the rgszToSites
	// field in the request message.
	CostInfo []*MessageQuerySitesReplyElementV1 `idl:"name:rgCostInfo;size_is:(cToSites)" json:"cost_info"`
	// dwFlags:  Unused. MUST be 0 and ignored.
	Flags uint32 `idl:"name:dwFlags" json:"flags"`
}

func (o *MessageQuerySitesReplyV1) xxx_PreparePayload(ctx context.Context) error {
	if o.CostInfo != nil && o.ToSitesCount == 0 {
		o.ToSitesCount = uint32(len(o.CostInfo))
	}
	if o.ToSitesCount > uint32(10000) {
		return fmt.Errorf("ToSitesCount is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageQuerySitesReplyV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.ToSitesCount); err != nil {
		return err
	}
	if o.CostInfo != nil || o.ToSitesCount > 0 {
		_ptr_rgCostInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.ToSitesCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.CostInfo {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.CostInfo[i1] != nil {
					if err := o.CostInfo[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&MessageQuerySitesReplyElementV1{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.CostInfo); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&MessageQuerySitesReplyElementV1{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.CostInfo, _ptr_rgCostInfo); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	return nil
}
func (o *MessageQuerySitesReplyV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.ToSitesCount); err != nil {
		return err
	}
	_ptr_rgCostInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.ToSitesCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.ToSitesCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.CostInfo", sizeInfo[0])
		}
		o.CostInfo = make([]*MessageQuerySitesReplyElementV1, sizeInfo[0])
		for i1 := range o.CostInfo {
			i1 := i1
			if o.CostInfo[i1] == nil {
				o.CostInfo[i1] = &MessageQuerySitesReplyElementV1{}
			}
			if err := o.CostInfo[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_rgCostInfo := func(ptr interface{}) { o.CostInfo = *ptr.(*[]*MessageQuerySitesReplyElementV1) }
	if err := w.ReadPointer(&o.CostInfo, _s_rgCostInfo, _ptr_rgCostInfo); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	return nil
}

// MessageQuerySitesReply structure represents DRS_MSG_QUERYSITESREPLY RPC union.
//
// The DRS_MSG_QUERYSITESREPLY union defines the response messages received from the
// IDL_DRSQuerySitesByCost method.
type MessageQuerySitesReply struct {
	// Types that are assignable to Value
	//
	// *MessageQuerySitesReply_V1
	Value is_MessageQuerySitesReply `json:"value"`
}

func (o *MessageQuerySitesReply) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageQuerySitesReply_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_MessageQuerySitesReply interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageQuerySitesReply()
}

func (o *MessageQuerySitesReply) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageQuerySitesReply_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *MessageQuerySitesReply) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageQuerySitesReply_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageQuerySitesReply_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageQuerySitesReply) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageQuerySitesReply_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageQuerySitesReply_V1 structure represents DRS_MSG_QUERYSITESREPLY RPC union arm.
//
// It has following labels: 1
type MessageQuerySitesReply_V1 struct {
	// V1:  The version 1 response.
	V1 *MessageQuerySitesReplyV1 `idl:"name:V1" json:"v1"`
}

func (*MessageQuerySitesReply_V1) is_MessageQuerySitesReply() {}

func (o *MessageQuerySitesReply_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageQuerySitesReplyV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageQuerySitesReply_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageQuerySitesReplyV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageInitDemotionRequestV1 structure represents DRS_MSG_INIT_DEMOTIONREQ_V1 RPC structure.
//
// The DRS_MSG_INIT_DEMOTIONREQ_V1 structure defines a request message sent to the IDL_DRSInitDemotion
// method.
type MessageInitDemotionRequestV1 struct {
	// dwReserved:  Unused. MUST be 0.
	_ uint32 `idl:"name:dwReserved"`
}

func (o *MessageInitDemotionRequestV1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageInitDemotionRequestV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	// reserved dwReserved
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	return nil
}
func (o *MessageInitDemotionRequestV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	// reserved dwReserved
	var _dwReserved uint32
	if err := w.ReadData(&_dwReserved); err != nil {
		return err
	}
	return nil
}

// MessageInitDemotionRequest structure represents DRS_MSG_INIT_DEMOTIONREQ RPC union.
//
// The DRS_MSG_INIT_DEMOTIONREQ union defines request messages sent to the IDL_DRSInitDemotion
// method. Only one version, identified by dwInVersion = 1, is currently defined.
type MessageInitDemotionRequest struct {
	// Types that are assignable to Value
	//
	// *MessageInitDemotionRequest_V1
	Value is_MessageInitDemotionRequest `json:"value"`
}

func (o *MessageInitDemotionRequest) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageInitDemotionRequest_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_MessageInitDemotionRequest interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageInitDemotionRequest()
}

func (o *MessageInitDemotionRequest) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageInitDemotionRequest_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *MessageInitDemotionRequest) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(4); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(4); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageInitDemotionRequest_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageInitDemotionRequest_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageInitDemotionRequest) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(4); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(4); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageInitDemotionRequest_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageInitDemotionRequest_V1 structure represents DRS_MSG_INIT_DEMOTIONREQ RPC union arm.
//
// It has following labels: 1
type MessageInitDemotionRequest_V1 struct {
	// V1:  Version 1 request. Currently, only one version is defined.
	V1 *MessageInitDemotionRequestV1 `idl:"name:V1" json:"v1"`
}

func (*MessageInitDemotionRequest_V1) is_MessageInitDemotionRequest() {}

func (o *MessageInitDemotionRequest_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageInitDemotionRequestV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageInitDemotionRequest_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageInitDemotionRequestV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageInitDemotionReplyV1 structure represents DRS_MSG_INIT_DEMOTIONREPLY_V1 RPC structure.
//
// The DRS_MSG_INIT_DEMOTIONREPLY_V1 structure defines a response message received from
// the IDL_DRSInitDemotion method.
type MessageInitDemotionReplyV1 struct {
	// dwOpError:  A Win32 error code, as specified in [MS-ERREF] section 2.2.
	OperationError uint32 `idl:"name:dwOpError" json:"operation_error"`
}

func (o *MessageInitDemotionReplyV1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageInitDemotionReplyV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.OperationError); err != nil {
		return err
	}
	return nil
}
func (o *MessageInitDemotionReplyV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.OperationError); err != nil {
		return err
	}
	return nil
}

// MessageInitDemotionReply structure represents DRS_MSG_INIT_DEMOTIONREPLY RPC union.
//
// The DRS_MSG_INIT_DEMOTIONREPLY union defines the response messages received from
// the IDL_DRSInitDemotion method. Only one version, identified by pdwOutVersion^ =
// 1, is currently defined.
type MessageInitDemotionReply struct {
	// Types that are assignable to Value
	//
	// *MessageInitDemotionReply_V1
	Value is_MessageInitDemotionReply `json:"value"`
}

func (o *MessageInitDemotionReply) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageInitDemotionReply_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_MessageInitDemotionReply interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageInitDemotionReply()
}

func (o *MessageInitDemotionReply) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageInitDemotionReply_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *MessageInitDemotionReply) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(4); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(4); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageInitDemotionReply_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageInitDemotionReply_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageInitDemotionReply) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(4); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(4); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageInitDemotionReply_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageInitDemotionReply_V1 structure represents DRS_MSG_INIT_DEMOTIONREPLY RPC union arm.
//
// It has following labels: 1
type MessageInitDemotionReply_V1 struct {
	// V1:  Version 1 reply.
	V1 *MessageInitDemotionReplyV1 `idl:"name:V1" json:"v1"`
}

func (*MessageInitDemotionReply_V1) is_MessageInitDemotionReply() {}

func (o *MessageInitDemotionReply_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageInitDemotionReplyV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageInitDemotionReply_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageInitDemotionReplyV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageReplicaDemotionRequestV1 structure represents DRS_MSG_REPLICA_DEMOTIONREQ_V1 RPC structure.
//
// The DRS_MSG_REPLICA_DEMOTIONREQ_V1 structure defines a request message sent to the
// IDL_DRSReplicaDemotion method.
type MessageReplicaDemotionRequestV1 struct {
	// dwFlags:  Zero or more of the following bit flags, which are presented in little-endian
	// byte order.
	//
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
	//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| X | X | X | X | X | X | X | T | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//
	// X: Unused. MUST be zero.
	Flags uint32 `idl:"name:dwFlags" json:"flags"`
	// uuidHelperDest:  Unused. Must be NULL GUID and ignored.
	HelperDestination *dtyp.UUID `idl:"name:uuidHelperDest" json:"helper_destination"`
	// pNC:  The DSNAME of the NC to replicate off.
	NC *DSName `idl:"name:pNC;pointer:ref" json:"nc"`
}

func (o *MessageReplicaDemotionRequestV1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageReplicaDemotionRequestV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	if o.HelperDestination != nil {
		if err := o.HelperDestination.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.NC != nil {
		_ptr_pNC := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.NC != nil {
				if err := o.NC.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DSName{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.NC, _ptr_pNC); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageReplicaDemotionRequestV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	if o.HelperDestination == nil {
		o.HelperDestination = &dtyp.UUID{}
	}
	if err := o.HelperDestination.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_pNC := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.NC == nil {
			o.NC = &DSName{}
		}
		if err := o.NC.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pNC := func(ptr interface{}) { o.NC = *ptr.(**DSName) }
	if err := w.ReadPointer(&o.NC, _s_pNC, _ptr_pNC); err != nil {
		return err
	}
	return nil
}

// MessageReplicaDemotionRequest structure represents DRS_MSG_REPLICA_DEMOTIONREQ RPC union.
//
// The DRS_MSG_REPLICA_DEMOTIONREQ union defines the request messages sent to the IDL_DRSReplicaDemotion
// method. Only one version, identified by dwInVersion = 1, is currently defined.
type MessageReplicaDemotionRequest struct {
	// Types that are assignable to Value
	//
	// *MessageReplicaDemotionRequest_V1
	Value is_MessageReplicaDemotionRequest `json:"value"`
}

func (o *MessageReplicaDemotionRequest) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageReplicaDemotionRequest_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_MessageReplicaDemotionRequest interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageReplicaDemotionRequest()
}

func (o *MessageReplicaDemotionRequest) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageReplicaDemotionRequest_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *MessageReplicaDemotionRequest) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageReplicaDemotionRequest_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageReplicaDemotionRequest_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageReplicaDemotionRequest) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageReplicaDemotionRequest_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageReplicaDemotionRequest_V1 structure represents DRS_MSG_REPLICA_DEMOTIONREQ RPC union arm.
//
// It has following labels: 1
type MessageReplicaDemotionRequest_V1 struct {
	// V1:  The version 1 request. Only one version is defined.
	V1 *MessageReplicaDemotionRequestV1 `idl:"name:V1" json:"v1"`
}

func (*MessageReplicaDemotionRequest_V1) is_MessageReplicaDemotionRequest() {}

func (o *MessageReplicaDemotionRequest_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageReplicaDemotionRequestV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageReplicaDemotionRequest_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageReplicaDemotionRequestV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageReplicaDemotionReplyV1 structure represents DRS_MSG_REPLICA_DEMOTIONREPLY_V1 RPC structure.
//
// The DRS_MSG_REPLICA_DEMOTIONREPLY_V1 structure defines a response message received
// from the IDL_DRSReplicaDemotion method.
type MessageReplicaDemotionReplyV1 struct {
	// dwOpError:  The Win32 error code, as specified in [MS-ERREF] section 2.2.
	OperationError uint32 `idl:"name:dwOpError" json:"operation_error"`
}

func (o *MessageReplicaDemotionReplyV1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageReplicaDemotionReplyV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.OperationError); err != nil {
		return err
	}
	return nil
}
func (o *MessageReplicaDemotionReplyV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.OperationError); err != nil {
		return err
	}
	return nil
}

// MessageReplicaDemotionReply structure represents DRS_MSG_REPLICA_DEMOTIONREPLY RPC union.
//
// The DRS_MSG_REPLICA_DEMOTIONREPLY union defines the response messages received from
// the IDL_DRSReplicaDemotion method. Only one version, identified by pdwOutVersion^
// = 1, is currently defined.
//
// V1:  The version 1 reply.
type MessageReplicaDemotionReply struct {
	// Types that are assignable to Value
	//
	// *MessageReplicaDemotionReply_V1
	Value is_MessageReplicaDemotionReply `json:"value"`
}

func (o *MessageReplicaDemotionReply) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageReplicaDemotionReply_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_MessageReplicaDemotionReply interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageReplicaDemotionReply()
}

func (o *MessageReplicaDemotionReply) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageReplicaDemotionReply_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *MessageReplicaDemotionReply) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(4); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(4); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageReplicaDemotionReply_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageReplicaDemotionReply_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageReplicaDemotionReply) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(4); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(4); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageReplicaDemotionReply_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageReplicaDemotionReply_V1 structure represents DRS_MSG_REPLICA_DEMOTIONREPLY RPC union arm.
//
// It has following labels: 1
type MessageReplicaDemotionReply_V1 struct {
	V1 *MessageReplicaDemotionReplyV1 `idl:"name:V1" json:"v1"`
}

func (*MessageReplicaDemotionReply_V1) is_MessageReplicaDemotionReply() {}

func (o *MessageReplicaDemotionReply_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageReplicaDemotionReplyV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageReplicaDemotionReply_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageReplicaDemotionReplyV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageFinishDemotionRequestV1 structure represents DRS_MSG_FINISH_DEMOTIONREQ_V1 RPC structure.
//
// The DRS_MSG_FINISH_DEMOTIONREQ_V1 structure defines the request message sent to the
// IDL_DRSFinishDemotion method.
type MessageFinishDemotionRequestV1 struct {
	// dwOperations:  Zero or more of the following bit flags, which are presented in little-endian
	// byte order.
	//
	//	+---+---+---+-----+-----+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 1 | 2 |  3  |  4  | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
	//	|   |   |   |     |     |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
	//	+---+---+---+-----+-----+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	+---+---+---+-----+-----+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| X | X | X | U 2 | U 1 | D | C | R | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | X | F | X | X | X | X | X | X | X |
	//	+---+---+---+-----+-----+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//
	// X: Unused. MUST be zero and ignored.
	//
	// R (DS_DEMOTE_ROLLBACK_DEMOTE, 0x00000001): Undo the effects of IDL_DRSInitDemotion.
	// If present, any other flags present (except for DS_DEMOTE_OPT_FAIL_ON_UNKNOWN) are
	// ignored.
	//
	// C (DS_DEMOTE_COMMIT_DEMOTE, 0x00000002): Discontinue being a DC for the current DC
	// instance by stopping all AD LDS protocols.
	//
	// D (DS_DEMOTE_DELETE_CSMETA, 0x00000004): Delete the nTDSDSA object for this DC; see
	// RemoveADLDSServer (section 4.1.7.2.1).
	//
	// U1 (DS_DEMOTE_UNREGISTER_SCPS, 0x00000008): Delete any serviceConnectionPoint objects
	// for this DC from AD DS; see RemoveADLDSSCP (section 4.1.7.2.2).
	//
	// U2 (DS_DEMOTE_UNREGISTER_SPNS, 0x00000010): Delete any AD LDS SPNs from the object
	// (in the external AD DS domain) that corresponds to the security principal that the
	// AD LDS service is running as; see RemoveADLDSSPNs (section 4.1.7.2.3).
	Operations uint32 `idl:"name:dwOperations" json:"operations"`
	// uuidHelperDest: Unused. Must be NULL GUID and ignored.
	HelperDestination *dtyp.UUID `idl:"name:uuidHelperDest" json:"helper_destination"`
	// szScriptBase: The path name of the folder in which to store SPN unregistration scripts.
	// Required when DS_DEMOTE_UNREGISTER_SPNS is specified in dwOperations.
	ScriptBase string `idl:"name:szScriptBase;string" json:"script_base"`
}

func (o *MessageFinishDemotionRequestV1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageFinishDemotionRequestV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.Operations); err != nil {
		return err
	}
	if o.HelperDestination != nil {
		if err := o.HelperDestination.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.ScriptBase != "" {
		_ptr_szScriptBase := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.ScriptBase); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ScriptBase, _ptr_szScriptBase); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageFinishDemotionRequestV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.Operations); err != nil {
		return err
	}
	if o.HelperDestination == nil {
		o.HelperDestination = &dtyp.UUID{}
	}
	if err := o.HelperDestination.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_szScriptBase := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.ScriptBase); err != nil {
			return err
		}
		return nil
	})
	_s_szScriptBase := func(ptr interface{}) { o.ScriptBase = *ptr.(*string) }
	if err := w.ReadPointer(&o.ScriptBase, _s_szScriptBase, _ptr_szScriptBase); err != nil {
		return err
	}
	return nil
}

// MessageFinishDemotionRequest structure represents DRS_MSG_FINISH_DEMOTIONREQ RPC union.
//
// The DRS_MSG_FINISH_DEMOTIONREQ union defines the request messages sent to the IDL_DRSFinishDemotion
// method. Only one version, identified by dwInVersion = 1, is currently defined.
type MessageFinishDemotionRequest struct {
	// Types that are assignable to Value
	//
	// *MessageFinishDemotionRequest_V1
	Value is_MessageFinishDemotionRequest `json:"value"`
}

func (o *MessageFinishDemotionRequest) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageFinishDemotionRequest_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_MessageFinishDemotionRequest interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageFinishDemotionRequest()
}

func (o *MessageFinishDemotionRequest) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageFinishDemotionRequest_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *MessageFinishDemotionRequest) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageFinishDemotionRequest_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageFinishDemotionRequest_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageFinishDemotionRequest) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageFinishDemotionRequest_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageFinishDemotionRequest_V1 structure represents DRS_MSG_FINISH_DEMOTIONREQ RPC union arm.
//
// It has following labels: 1
type MessageFinishDemotionRequest_V1 struct {
	// V1:  Version 1 request. Currently, only one version is defined.
	V1 *MessageFinishDemotionRequestV1 `idl:"name:V1" json:"v1"`
}

func (*MessageFinishDemotionRequest_V1) is_MessageFinishDemotionRequest() {}

func (o *MessageFinishDemotionRequest_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageFinishDemotionRequestV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageFinishDemotionRequest_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageFinishDemotionRequestV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageFinishDemotionReplyV1 structure represents DRS_MSG_FINISH_DEMOTIONREPLY_V1 RPC structure.
//
// The DRS_MSG_FINISH_DEMOTIONREPLY_V1 structure defines the response message received
// from the IDL_DRSFinishDemotion method.
type MessageFinishDemotionReplyV1 struct {
	// dwOperationsDone:  The set of operations that were successfully performed. This can
	// include the following values: DS_DEMOTE_ROLLBACK_DEMOTE, DS_DEMOTE_COMMIT_DEMOTE,
	// DS_DEMOTE_DELETE_CSMETA, DS_DEMOTE_UNREGISTER_SCPS, DS_DEMOTE_UNREGISTER_SPNS. This
	// MUST include any value from the input element DRS_MSG_FINISH_DEMOTIONREQ_V1.dwOperations
	// whose corresponding operations (see pseudocode in section 4.1.7.3) succeeded.
	OperationsDone uint32 `idl:"name:dwOperationsDone" json:"operations_done"`
	// dwOpFailed:  The set of operations that failed during demotion. This can include
	// the same values as the dwOperationsDone field. This MUST include any value from the
	// input element DRS_MSG_FINISH_DEMOTIONREQ_V1.dwOperations whose corresponding operations
	// (see pseudocode in section 4.1.7.3) failed.
	OperationFailed uint32 `idl:"name:dwOpFailed" json:"operation_failed"`
	// dwOpError:  The Win32 error code (as specified in [MS-ERREF] section 2.2) of the
	// first failed operation (if any), from the following operations: DS_DEMOTE_ROLLBACK_DEMOTE,
	// DS_DEMOTE_COMMIT_DEMOTE, DS_DEMOTE_DELETE_CSMETA, or DS_DEMOTE_UNREGISTER_SCPS.
	OperationError uint32 `idl:"name:dwOpError" json:"operation_error"`
}

func (o *MessageFinishDemotionReplyV1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageFinishDemotionReplyV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.OperationsDone); err != nil {
		return err
	}
	if err := w.WriteData(o.OperationFailed); err != nil {
		return err
	}
	if err := w.WriteData(o.OperationError); err != nil {
		return err
	}
	return nil
}
func (o *MessageFinishDemotionReplyV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.OperationsDone); err != nil {
		return err
	}
	if err := w.ReadData(&o.OperationFailed); err != nil {
		return err
	}
	if err := w.ReadData(&o.OperationError); err != nil {
		return err
	}
	return nil
}

// MessageFinishDemotionReply structure represents DRS_MSG_FINISH_DEMOTIONREPLY RPC union.
//
// The DRS_MSG_FINISH_DEMOTIONREPLY union defines the response messages received from
// the IDL_DRSFinishDemotion method. Only one version, identified by pdwOutVersion^
// = 1, is currently defined.
type MessageFinishDemotionReply struct {
	// Types that are assignable to Value
	//
	// *MessageFinishDemotionReply_V1
	Value is_MessageFinishDemotionReply `json:"value"`
}

func (o *MessageFinishDemotionReply) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageFinishDemotionReply_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_MessageFinishDemotionReply interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageFinishDemotionReply()
}

func (o *MessageFinishDemotionReply) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageFinishDemotionReply_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *MessageFinishDemotionReply) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(4); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(4); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageFinishDemotionReply_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageFinishDemotionReply_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageFinishDemotionReply) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(4); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(4); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageFinishDemotionReply_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageFinishDemotionReply_V1 structure represents DRS_MSG_FINISH_DEMOTIONREPLY RPC union arm.
//
// It has following labels: 1
type MessageFinishDemotionReply_V1 struct {
	// V1:  Version 1 reply.
	V1 *MessageFinishDemotionReplyV1 `idl:"name:V1" json:"v1"`
}

func (*MessageFinishDemotionReply_V1) is_MessageFinishDemotionReply() {}

func (o *MessageFinishDemotionReply_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageFinishDemotionReplyV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageFinishDemotionReply_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageFinishDemotionReplyV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageAddCloneDCRequestV1 structure represents DRS_MSG_ADDCLONEDCREQ_V1 RPC structure.
//
// The DRS_MSG_ADDCLONEDCREQ_V1 structure defines a request message sent to the IDL_DRSAddCloneDC
// method.
type MessageAddCloneDCRequestV1 struct {
	// pwszCloneDCName:  The new DC name.
	CloneDCName string `idl:"name:pwszCloneDCName;string" json:"clone_dc_name"`
	// pwszSite:  The RDN of the site the new DC will be placed into.
	Site string `idl:"name:pwszSite;string" json:"site"`
}

func (o *MessageAddCloneDCRequestV1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageAddCloneDCRequestV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(6); err != nil {
		return err
	}
	if o.CloneDCName != "" {
		_ptr_pwszCloneDCName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.CloneDCName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.CloneDCName, _ptr_pwszCloneDCName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.Site != "" {
		_ptr_pwszSite := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Site); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Site, _ptr_pwszSite); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageAddCloneDCRequestV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(6); err != nil {
		return err
	}
	_ptr_pwszCloneDCName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.CloneDCName); err != nil {
			return err
		}
		return nil
	})
	_s_pwszCloneDCName := func(ptr interface{}) { o.CloneDCName = *ptr.(*string) }
	if err := w.ReadPointer(&o.CloneDCName, _s_pwszCloneDCName, _ptr_pwszCloneDCName); err != nil {
		return err
	}
	_ptr_pwszSite := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Site); err != nil {
			return err
		}
		return nil
	})
	_s_pwszSite := func(ptr interface{}) { o.Site = *ptr.(*string) }
	if err := w.ReadPointer(&o.Site, _s_pwszSite, _ptr_pwszSite); err != nil {
		return err
	}
	return nil
}

// MessageAddCloneDCRequest structure represents DRS_MSG_ADDCLONEDCREQ RPC union.
//
// The DRS_MSG_ADDCLONEDCREQ union defines the request messages sent to the IDL_DRSAddCloneDC
// method.
type MessageAddCloneDCRequest struct {
	// Types that are assignable to Value
	//
	// *MessageAddCloneDCRequest_V1
	Value is_MessageAddCloneDCRequest `json:"value"`
}

func (o *MessageAddCloneDCRequest) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageAddCloneDCRequest_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_MessageAddCloneDCRequest interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageAddCloneDCRequest()
}

func (o *MessageAddCloneDCRequest) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageAddCloneDCRequest_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *MessageAddCloneDCRequest) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageAddCloneDCRequest_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageAddCloneDCRequest_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageAddCloneDCRequest) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageAddCloneDCRequest_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageAddCloneDCRequest_V1 structure represents DRS_MSG_ADDCLONEDCREQ RPC union arm.
//
// It has following labels: 1
type MessageAddCloneDCRequest_V1 struct {
	// V1:  The version 1 request.
	V1 *MessageAddCloneDCRequestV1 `idl:"name:V1" json:"v1"`
}

func (*MessageAddCloneDCRequest_V1) is_MessageAddCloneDCRequest() {}

func (o *MessageAddCloneDCRequest_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageAddCloneDCRequestV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageAddCloneDCRequest_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageAddCloneDCRequestV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageAddCloneDCReplyV1 structure represents DRS_MSG_ADDCLONEDCREPLY_V1 RPC structure.
//
// The DRS_MSG_ADDCLONEDCREPLY_V1 structure defines a response message received from
// the IDL_DRSAddCloneDC method.
type MessageAddCloneDCReplyV1 struct {
	// pwszCloneDCName:  The new DC's name.
	CloneDCName string `idl:"name:pwszCloneDCName;string" json:"clone_dc_name"`
	// pwszSite:  The site containing the new DC.
	Site string `idl:"name:pwszSite;string" json:"site"`
	// cPasswordLength:  The length of the pwsNewDCAccountPassword member.
	PasswordLengthCount uint32 `idl:"name:cPasswordLength" json:"password_length_count"`
	// pwsNewDCAccountPassword:  The password of the new DC account.
	NewDCAccountPassword string `idl:"name:pwsNewDCAccountPassword;size_is:(cPasswordLength)" json:"new_dc_account_password"`
}

func (o *MessageAddCloneDCReplyV1) xxx_PreparePayload(ctx context.Context) error {
	if o.NewDCAccountPassword != "" && o.PasswordLengthCount == 0 {
		o.PasswordLengthCount = uint32(len(o.NewDCAccountPassword))
	}
	if o.PasswordLengthCount > uint32(1024) {
		return fmt.Errorf("PasswordLengthCount is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageAddCloneDCReplyV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.CloneDCName != "" {
		_ptr_pwszCloneDCName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.CloneDCName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.CloneDCName, _ptr_pwszCloneDCName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.Site != "" {
		_ptr_pwszSite := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Site); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Site, _ptr_pwszSite); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.PasswordLengthCount); err != nil {
		return err
	}
	if o.NewDCAccountPassword != "" || o.PasswordLengthCount > 0 {
		_ptr_pwsNewDCAccountPassword := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.PasswordLengthCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			_NewDCAccountPassword_buf := utf16.Encode([]rune(o.NewDCAccountPassword))
			if uint64(len(_NewDCAccountPassword_buf)) > sizeInfo[0] {
				_NewDCAccountPassword_buf = _NewDCAccountPassword_buf[:sizeInfo[0]]
			}
			for i1 := range _NewDCAccountPassword_buf {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(_NewDCAccountPassword_buf[i1]); err != nil {
					return err
				}
			}
			for i1 := len(_NewDCAccountPassword_buf); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint16(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.NewDCAccountPassword, _ptr_pwsNewDCAccountPassword); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageAddCloneDCReplyV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_pwszCloneDCName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.CloneDCName); err != nil {
			return err
		}
		return nil
	})
	_s_pwszCloneDCName := func(ptr interface{}) { o.CloneDCName = *ptr.(*string) }
	if err := w.ReadPointer(&o.CloneDCName, _s_pwszCloneDCName, _ptr_pwszCloneDCName); err != nil {
		return err
	}
	_ptr_pwszSite := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Site); err != nil {
			return err
		}
		return nil
	})
	_s_pwszSite := func(ptr interface{}) { o.Site = *ptr.(*string) }
	if err := w.ReadPointer(&o.Site, _s_pwszSite, _ptr_pwszSite); err != nil {
		return err
	}
	if err := w.ReadData(&o.PasswordLengthCount); err != nil {
		return err
	}
	_ptr_pwsNewDCAccountPassword := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.PasswordLengthCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.PasswordLengthCount)
		}
		var _NewDCAccountPassword_buf []uint16
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array _NewDCAccountPassword_buf", sizeInfo[0])
		}
		_NewDCAccountPassword_buf = make([]uint16, sizeInfo[0])
		for i1 := range _NewDCAccountPassword_buf {
			i1 := i1
			if err := w.ReadData(&_NewDCAccountPassword_buf[i1]); err != nil {
				return err
			}
		}
		o.NewDCAccountPassword = strings.TrimRight(string(utf16.Decode(_NewDCAccountPassword_buf)), ndr.ZeroString)
		return nil
	})
	_s_pwsNewDCAccountPassword := func(ptr interface{}) { o.NewDCAccountPassword = *ptr.(*string) }
	if err := w.ReadPointer(&o.NewDCAccountPassword, _s_pwsNewDCAccountPassword, _ptr_pwsNewDCAccountPassword); err != nil {
		return err
	}
	return nil
}

// MessageAddCloneDCReply structure represents DRS_MSG_ADDCLONEDCREPLY RPC union.
//
// The DRS_MSG_ADDCLONEDCREPLY union defines the response messages received from the
// IDL_DRSAddCloneDC method.
type MessageAddCloneDCReply struct {
	// Types that are assignable to Value
	//
	// *MessageAddCloneDCReply_V1
	Value is_MessageAddCloneDCReply `json:"value"`
}

func (o *MessageAddCloneDCReply) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageAddCloneDCReply_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_MessageAddCloneDCReply interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageAddCloneDCReply()
}

func (o *MessageAddCloneDCReply) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageAddCloneDCReply_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *MessageAddCloneDCReply) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageAddCloneDCReply_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageAddCloneDCReply_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageAddCloneDCReply) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageAddCloneDCReply_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageAddCloneDCReply_V1 structure represents DRS_MSG_ADDCLONEDCREPLY RPC union arm.
//
// It has following labels: 1
type MessageAddCloneDCReply_V1 struct {
	// V1:  The version 1 response.
	V1 *MessageAddCloneDCReplyV1 `idl:"name:V1" json:"v1"`
}

func (*MessageAddCloneDCReply_V1) is_MessageAddCloneDCReply() {}

func (o *MessageAddCloneDCReply_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageAddCloneDCReplyV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageAddCloneDCReply_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageAddCloneDCReplyV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageWriteNGCKeyRequestV1 structure represents DRS_MSG_WRITENGCKEYREQ_V1 RPC structure.
type MessageWriteNGCKeyRequestV1 struct {
	Account     string `idl:"name:pwszAccount;string" json:"account"`
	NGCKeyCount uint32 `idl:"name:cNgcKey" json:"ngc_key_count"`
	NGCKey      []byte `idl:"name:pNgcKey;size_is:(cNgcKey)" json:"ngc_key"`
}

func (o *MessageWriteNGCKeyRequestV1) xxx_PreparePayload(ctx context.Context) error {
	if o.NGCKey != nil && o.NGCKeyCount == 0 {
		o.NGCKeyCount = uint32(len(o.NGCKey))
	}
	if o.NGCKeyCount > uint32(65535) {
		return fmt.Errorf("NGCKeyCount is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageWriteNGCKeyRequestV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.Account != "" {
		_ptr_pwszAccount := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Account); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Account, _ptr_pwszAccount); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.NGCKeyCount); err != nil {
		return err
	}
	if o.NGCKey != nil || o.NGCKeyCount > 0 {
		_ptr_pNgcKey := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.NGCKeyCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.NGCKey {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.NGCKey[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.NGCKey); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.NGCKey, _ptr_pNgcKey); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageWriteNGCKeyRequestV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_pwszAccount := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Account); err != nil {
			return err
		}
		return nil
	})
	_s_pwszAccount := func(ptr interface{}) { o.Account = *ptr.(*string) }
	if err := w.ReadPointer(&o.Account, _s_pwszAccount, _ptr_pwszAccount); err != nil {
		return err
	}
	if err := w.ReadData(&o.NGCKeyCount); err != nil {
		return err
	}
	_ptr_pNgcKey := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.NGCKeyCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.NGCKeyCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.NGCKey", sizeInfo[0])
		}
		o.NGCKey = make([]byte, sizeInfo[0])
		for i1 := range o.NGCKey {
			i1 := i1
			if err := w.ReadData(&o.NGCKey[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_pNgcKey := func(ptr interface{}) { o.NGCKey = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.NGCKey, _s_pNgcKey, _ptr_pNgcKey); err != nil {
		return err
	}
	return nil
}

// MessageWriteNGCKeyRequest structure represents DRS_MSG_WRITENGCKEYREQ RPC union.
type MessageWriteNGCKeyRequest struct {
	// Types that are assignable to Value
	//
	// *MessageWriteNGCKeyRequest_V1
	Value is_MessageWriteNGCKeyRequest `json:"value"`
}

func (o *MessageWriteNGCKeyRequest) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageWriteNGCKeyRequest_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_MessageWriteNGCKeyRequest interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageWriteNGCKeyRequest()
}

func (o *MessageWriteNGCKeyRequest) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageWriteNGCKeyRequest_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *MessageWriteNGCKeyRequest) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageWriteNGCKeyRequest_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageWriteNGCKeyRequest_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageWriteNGCKeyRequest) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageWriteNGCKeyRequest_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageWriteNGCKeyRequest_V1 structure represents DRS_MSG_WRITENGCKEYREQ RPC union arm.
//
// It has following labels: 1
type MessageWriteNGCKeyRequest_V1 struct {
	V1 *MessageWriteNGCKeyRequestV1 `idl:"name:V1" json:"v1"`
}

func (*MessageWriteNGCKeyRequest_V1) is_MessageWriteNGCKeyRequest() {}

func (o *MessageWriteNGCKeyRequest_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageWriteNGCKeyRequestV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageWriteNGCKeyRequest_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageWriteNGCKeyRequestV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageWriteNGCKeyReplyV1 structure represents DRS_MSG_WRITENGCKEYREPLY_V1 RPC structure.
type MessageWriteNGCKeyReplyV1 struct {
	ReturnValue uint32 `idl:"name:retVal" json:"return_value"`
}

func (o *MessageWriteNGCKeyReplyV1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageWriteNGCKeyReplyV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.ReturnValue); err != nil {
		return err
	}
	return nil
}
func (o *MessageWriteNGCKeyReplyV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.ReturnValue); err != nil {
		return err
	}
	return nil
}

// MessageWriteNGCKeyReply structure represents DRS_MSG_WRITENGCKEYREPLY RPC union.
type MessageWriteNGCKeyReply struct {
	// Types that are assignable to Value
	//
	// *MessageWriteNGCKeyReply_V1
	Value is_MessageWriteNGCKeyReply `json:"value"`
}

func (o *MessageWriteNGCKeyReply) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageWriteNGCKeyReply_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_MessageWriteNGCKeyReply interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageWriteNGCKeyReply()
}

func (o *MessageWriteNGCKeyReply) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageWriteNGCKeyReply_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *MessageWriteNGCKeyReply) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(4); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(4); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageWriteNGCKeyReply_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageWriteNGCKeyReply_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageWriteNGCKeyReply) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(4); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(4); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageWriteNGCKeyReply_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageWriteNGCKeyReply_V1 structure represents DRS_MSG_WRITENGCKEYREPLY RPC union arm.
//
// It has following labels: 1
type MessageWriteNGCKeyReply_V1 struct {
	V1 *MessageWriteNGCKeyReplyV1 `idl:"name:V1" json:"v1"`
}

func (*MessageWriteNGCKeyReply_V1) is_MessageWriteNGCKeyReply() {}

func (o *MessageWriteNGCKeyReply_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageWriteNGCKeyReplyV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageWriteNGCKeyReply_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageWriteNGCKeyReplyV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageReadNGCKeyRequestV1 structure represents DRS_MSG_READNGCKEYREQ_V1 RPC structure.
type MessageReadNGCKeyRequestV1 struct {
	Account string `idl:"name:pwszAccount;string" json:"account"`
}

func (o *MessageReadNGCKeyRequestV1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageReadNGCKeyRequestV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(6); err != nil {
		return err
	}
	if o.Account != "" {
		_ptr_pwszAccount := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Account); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Account, _ptr_pwszAccount); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageReadNGCKeyRequestV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(6); err != nil {
		return err
	}
	_ptr_pwszAccount := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Account); err != nil {
			return err
		}
		return nil
	})
	_s_pwszAccount := func(ptr interface{}) { o.Account = *ptr.(*string) }
	if err := w.ReadPointer(&o.Account, _s_pwszAccount, _ptr_pwszAccount); err != nil {
		return err
	}
	return nil
}

// MessageReadNGCKeyRequest structure represents DRS_MSG_READNGCKEYREQ RPC union.
type MessageReadNGCKeyRequest struct {
	// Types that are assignable to Value
	//
	// *MessageReadNGCKeyRequest_V1
	Value is_MessageReadNGCKeyRequest `json:"value"`
}

func (o *MessageReadNGCKeyRequest) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageReadNGCKeyRequest_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_MessageReadNGCKeyRequest interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageReadNGCKeyRequest()
}

func (o *MessageReadNGCKeyRequest) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageReadNGCKeyRequest_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *MessageReadNGCKeyRequest) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageReadNGCKeyRequest_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageReadNGCKeyRequest_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageReadNGCKeyRequest) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageReadNGCKeyRequest_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageReadNGCKeyRequest_V1 structure represents DRS_MSG_READNGCKEYREQ RPC union arm.
//
// It has following labels: 1
type MessageReadNGCKeyRequest_V1 struct {
	V1 *MessageReadNGCKeyRequestV1 `idl:"name:V1" json:"v1"`
}

func (*MessageReadNGCKeyRequest_V1) is_MessageReadNGCKeyRequest() {}

func (o *MessageReadNGCKeyRequest_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageReadNGCKeyRequestV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageReadNGCKeyRequest_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageReadNGCKeyRequestV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageReadNGCKeyReplyV1 structure represents DRS_MSG_READNGCKEYREPLY_V1 RPC structure.
type MessageReadNGCKeyReplyV1 struct {
	ReturnValue uint32 `idl:"name:retVal" json:"return_value"`
	NGCKeyCount uint32 `idl:"name:cNgcKey" json:"ngc_key_count"`
	NGCKey      []byte `idl:"name:pNgcKey;size_is:(cNgcKey)" json:"ngc_key"`
}

func (o *MessageReadNGCKeyReplyV1) xxx_PreparePayload(ctx context.Context) error {
	if o.NGCKey != nil && o.NGCKeyCount == 0 {
		o.NGCKeyCount = uint32(len(o.NGCKey))
	}
	if o.NGCKeyCount > uint32(65535) {
		return fmt.Errorf("NGCKeyCount is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageReadNGCKeyReplyV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.ReturnValue); err != nil {
		return err
	}
	if err := w.WriteData(o.NGCKeyCount); err != nil {
		return err
	}
	if o.NGCKey != nil || o.NGCKeyCount > 0 {
		_ptr_pNgcKey := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.NGCKeyCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.NGCKey {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.NGCKey[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.NGCKey); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.NGCKey, _ptr_pNgcKey); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageReadNGCKeyReplyV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.ReturnValue); err != nil {
		return err
	}
	if err := w.ReadData(&o.NGCKeyCount); err != nil {
		return err
	}
	_ptr_pNgcKey := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.NGCKeyCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.NGCKeyCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.NGCKey", sizeInfo[0])
		}
		o.NGCKey = make([]byte, sizeInfo[0])
		for i1 := range o.NGCKey {
			i1 := i1
			if err := w.ReadData(&o.NGCKey[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_pNgcKey := func(ptr interface{}) { o.NGCKey = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.NGCKey, _s_pNgcKey, _ptr_pNgcKey); err != nil {
		return err
	}
	return nil
}

// MessageReadNGCKeyReply structure represents DRS_MSG_READNGCKEYREPLY RPC union.
type MessageReadNGCKeyReply struct {
	// Types that are assignable to Value
	//
	// *MessageReadNGCKeyReply_V1
	Value is_MessageReadNGCKeyReply `json:"value"`
}

func (o *MessageReadNGCKeyReply) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageReadNGCKeyReply_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_MessageReadNGCKeyReply interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageReadNGCKeyReply()
}

func (o *MessageReadNGCKeyReply) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageReadNGCKeyReply_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *MessageReadNGCKeyReply) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*MessageReadNGCKeyReply_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageReadNGCKeyReply_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageReadNGCKeyReply) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &MessageReadNGCKeyReply_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageReadNGCKeyReply_V1 structure represents DRS_MSG_READNGCKEYREPLY RPC union arm.
//
// It has following labels: 1
type MessageReadNGCKeyReply_V1 struct {
	V1 *MessageReadNGCKeyReplyV1 `idl:"name:V1" json:"v1"`
}

func (*MessageReadNGCKeyReply_V1) is_MessageReadNGCKeyReply() {}

func (o *MessageReadNGCKeyReply_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MessageReadNGCKeyReplyV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageReadNGCKeyReply_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &MessageReadNGCKeyReplyV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

type xxx_DefaultDrsuapiClient struct {
	cc dcerpc.Conn
}

func (o *xxx_DefaultDrsuapiClient) Bind(ctx context.Context, in *BindRequest, opts ...dcerpc.CallOption) (*BindResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &BindResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDrsuapiClient) Unbind(ctx context.Context, in *UnbindRequest, opts ...dcerpc.CallOption) (*UnbindResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &UnbindResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDrsuapiClient) SyncReplica(ctx context.Context, in *SyncReplicaRequest, opts ...dcerpc.CallOption) (*SyncReplicaResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SyncReplicaResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDrsuapiClient) GetNCChanges(ctx context.Context, in *GetNCChangesRequest, opts ...dcerpc.CallOption) (*GetNCChangesResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetNCChangesResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDrsuapiClient) UpdateReferences(ctx context.Context, in *UpdateReferencesRequest, opts ...dcerpc.CallOption) (*UpdateReferencesResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &UpdateReferencesResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDrsuapiClient) AddReplica(ctx context.Context, in *AddReplicaRequest, opts ...dcerpc.CallOption) (*AddReplicaResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddReplicaResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDrsuapiClient) DeleteReplica(ctx context.Context, in *DeleteReplicaRequest, opts ...dcerpc.CallOption) (*DeleteReplicaResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &DeleteReplicaResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDrsuapiClient) ModifyReplica(ctx context.Context, in *ModifyReplicaRequest, opts ...dcerpc.CallOption) (*ModifyReplicaResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ModifyReplicaResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDrsuapiClient) VerifyNames(ctx context.Context, in *VerifyNamesRequest, opts ...dcerpc.CallOption) (*VerifyNamesResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &VerifyNamesResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDrsuapiClient) GetMemberships(ctx context.Context, in *GetMembershipsRequest, opts ...dcerpc.CallOption) (*GetMembershipsResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetMembershipsResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDrsuapiClient) InterdomainMove(ctx context.Context, in *InterdomainMoveRequest, opts ...dcerpc.CallOption) (*InterdomainMoveResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &InterdomainMoveResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDrsuapiClient) GetNT4ChangeLog(ctx context.Context, in *GetNT4ChangeLogRequest, opts ...dcerpc.CallOption) (*GetNT4ChangeLogResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetNT4ChangeLogResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDrsuapiClient) CrackNames(ctx context.Context, in *CrackNamesRequest, opts ...dcerpc.CallOption) (*CrackNamesResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CrackNamesResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDrsuapiClient) WriteSPN(ctx context.Context, in *WriteSPNRequest, opts ...dcerpc.CallOption) (*WriteSPNResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &WriteSPNResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDrsuapiClient) RemoveDSServer(ctx context.Context, in *RemoveDSServerRequest, opts ...dcerpc.CallOption) (*RemoveDSServerResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &RemoveDSServerResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDrsuapiClient) RemoveDSDomain(ctx context.Context, in *RemoveDSDomainRequest, opts ...dcerpc.CallOption) (*RemoveDSDomainResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &RemoveDSDomainResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDrsuapiClient) DomainControllerInfo(ctx context.Context, in *DomainControllerInfoRequest, opts ...dcerpc.CallOption) (*DomainControllerInfoResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &DomainControllerInfoResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDrsuapiClient) AddEntry(ctx context.Context, in *AddEntryRequest, opts ...dcerpc.CallOption) (*AddEntryResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddEntryResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDrsuapiClient) ExecuteKCC(ctx context.Context, in *ExecuteKCCRequest, opts ...dcerpc.CallOption) (*ExecuteKCCResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ExecuteKCCResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDrsuapiClient) GetReplicationInfo(ctx context.Context, in *GetReplicationInfoRequest, opts ...dcerpc.CallOption) (*GetReplicationInfoResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetReplicationInfoResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDrsuapiClient) AddSIDHistory(ctx context.Context, in *AddSIDHistoryRequest, opts ...dcerpc.CallOption) (*AddSIDHistoryResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddSIDHistoryResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDrsuapiClient) GetMemberships2(ctx context.Context, in *GetMemberships2Request, opts ...dcerpc.CallOption) (*GetMemberships2Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetMemberships2Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDrsuapiClient) VerifyObjectsReplica(ctx context.Context, in *VerifyObjectsReplicaRequest, opts ...dcerpc.CallOption) (*VerifyObjectsReplicaResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &VerifyObjectsReplicaResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDrsuapiClient) GetObjectExistence(ctx context.Context, in *GetObjectExistenceRequest, opts ...dcerpc.CallOption) (*GetObjectExistenceResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetObjectExistenceResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDrsuapiClient) QuerySitesByCost(ctx context.Context, in *QuerySitesByCostRequest, opts ...dcerpc.CallOption) (*QuerySitesByCostResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &QuerySitesByCostResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDrsuapiClient) InitDemotion(ctx context.Context, in *InitDemotionRequest, opts ...dcerpc.CallOption) (*InitDemotionResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &InitDemotionResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDrsuapiClient) DemotionReplica(ctx context.Context, in *DemotionReplicaRequest, opts ...dcerpc.CallOption) (*DemotionReplicaResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &DemotionReplicaResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDrsuapiClient) FinishDemotion(ctx context.Context, in *FinishDemotionRequest, opts ...dcerpc.CallOption) (*FinishDemotionResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &FinishDemotionResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDrsuapiClient) AddCloneDC(ctx context.Context, in *AddCloneDCRequest, opts ...dcerpc.CallOption) (*AddCloneDCResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddCloneDCResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDrsuapiClient) WriteNGCKey(ctx context.Context, in *WriteNGCKeyRequest, opts ...dcerpc.CallOption) (*WriteNGCKeyResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &WriteNGCKeyResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDrsuapiClient) ReadNGCKey(ctx context.Context, in *ReadNGCKeyRequest, opts ...dcerpc.CallOption) (*ReadNGCKeyResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ReadNGCKeyResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDrsuapiClient) AlterContext(ctx context.Context, opts ...dcerpc.Option) error {
	return o.cc.AlterContext(ctx, opts...)
}

func (o *xxx_DefaultDrsuapiClient) Conn() dcerpc.Conn {
	return o.cc
}

func NewDrsuapiClient(ctx context.Context, cc dcerpc.Conn, opts ...dcerpc.Option) (DrsuapiClient, error) {
	cc, err := cc.Bind(ctx, append(opts, dcerpc.WithAbstractSyntax(DrsuapiSyntaxV4_0))...)
	if err != nil {
		return nil, err
	}
	return &xxx_DefaultDrsuapiClient{cc: cc}, nil
}

// xxx_BindOperation structure represents the IDL_DRSBind operation
type xxx_BindOperation struct {
	ClientDSA *dtyp.UUID  `idl:"name:puuidClientDsa;pointer:unique" json:"client_dsa"`
	Client    *Extensions `idl:"name:pextClient;pointer:unique" json:"client"`
	Server    *Extensions `idl:"name:ppextServer" json:"server"`
	DRS       *Handle     `idl:"name:phDrs;pointer:ref" json:"drs"`
	Return    uint32      `idl:"name:Return" json:"return"`
}

func (o *xxx_BindOperation) OpNum() int { return 0 }

func (o *xxx_BindOperation) OpName() string { return "/drsuapi/v4/IDL_DRSBind" }

func (o *xxx_BindOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_BindOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// puuidClientDsa {in} (1:{pointer=unique}*(1))(2:{alias=UUID}(struct))
	{
		if o.ClientDSA != nil {
			_ptr_puuidClientDsa := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.ClientDSA != nil {
					if err := o.ClientDSA.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dtyp.UUID{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ClientDSA, _ptr_puuidClientDsa); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// pextClient {in} (1:{pointer=unique}*(1))(2:{alias=DRS_EXTENSIONS}(struct))
	{
		if o.Client != nil {
			_ptr_pextClient := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Client != nil {
					if err := o.Client.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&Extensions{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Client, _ptr_pextClient); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_BindOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// puuidClientDsa {in} (1:{pointer=unique}*(1))(2:{alias=UUID}(struct))
	{
		_ptr_puuidClientDsa := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.ClientDSA == nil {
				o.ClientDSA = &dtyp.UUID{}
			}
			if err := o.ClientDSA.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_puuidClientDsa := func(ptr interface{}) { o.ClientDSA = *ptr.(**dtyp.UUID) }
		if err := w.ReadPointer(&o.ClientDSA, _s_puuidClientDsa, _ptr_puuidClientDsa); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// pextClient {in} (1:{pointer=unique}*(1))(2:{alias=DRS_EXTENSIONS}(struct))
	{
		_ptr_pextClient := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Client == nil {
				o.Client = &Extensions{}
			}
			if err := o.Client.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_pextClient := func(ptr interface{}) { o.Client = *ptr.(**Extensions) }
		if err := w.ReadPointer(&o.Client, _s_pextClient, _ptr_pextClient); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_BindOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_BindOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ppextServer {out} (1:{pointer=ref}*(2)*(1))(2:{alias=DRS_EXTENSIONS}(struct))
	{
		if o.Server != nil {
			_ptr_ppextServer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Server != nil {
					if err := o.Server.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&Extensions{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Server, _ptr_ppextServer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// phDrs {out} (1:{pointer=ref}*(1))(2:{context_handle, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.DRS != nil {
			if err := o.DRS.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_BindOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ppextServer {out} (1:{pointer=ref}*(2)*(1))(2:{alias=DRS_EXTENSIONS}(struct))
	{
		_ptr_ppextServer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Server == nil {
				o.Server = &Extensions{}
			}
			if err := o.Server.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ppextServer := func(ptr interface{}) { o.Server = *ptr.(**Extensions) }
		if err := w.ReadPointer(&o.Server, _s_ppextServer, _ptr_ppextServer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// phDrs {out} (1:{pointer=ref}*(1))(2:{context_handle, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.DRS == nil {
			o.DRS = &Handle{}
		}
		if err := o.DRS.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// BindRequest structure represents the IDL_DRSBind operation request
type BindRequest struct {
	// puuidClientDsa: A pointer to a GUID that identifies the caller.
	ClientDSA *dtyp.UUID `idl:"name:puuidClientDsa;pointer:unique" json:"client_dsa"`
	// pextClient: A pointer to client capabilities, for use in version negotiation.
	Client *Extensions `idl:"name:pextClient;pointer:unique" json:"client"`
}

func (o *BindRequest) xxx_ToOp(ctx context.Context, op *xxx_BindOperation) *xxx_BindOperation {
	if op == nil {
		op = &xxx_BindOperation{}
	}
	if o == nil {
		return op
	}
	o.ClientDSA = op.ClientDSA
	o.Client = op.Client
	return op
}

func (o *BindRequest) xxx_FromOp(ctx context.Context, op *xxx_BindOperation) {
	if o == nil {
		return
	}
	o.ClientDSA = op.ClientDSA
	o.Client = op.Client
}
func (o *BindRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *BindRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_BindOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// BindResponse structure represents the IDL_DRSBind operation response
type BindResponse struct {
	// ppextServer: A pointer to a pointer to server capabilities, for use in version negotiation.
	Server *Extensions `idl:"name:ppextServer" json:"server"`
	// phDrs: A pointer to an RPC context handle (as specified in [C706]), which can be
	// used in calls to other methods in this interface.
	DRS *Handle `idl:"name:phDrs;pointer:ref" json:"drs"`
	// Return: The IDL_DRSBind return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *BindResponse) xxx_ToOp(ctx context.Context, op *xxx_BindOperation) *xxx_BindOperation {
	if op == nil {
		op = &xxx_BindOperation{}
	}
	if o == nil {
		return op
	}
	o.Server = op.Server
	o.DRS = op.DRS
	o.Return = op.Return
	return op
}

func (o *BindResponse) xxx_FromOp(ctx context.Context, op *xxx_BindOperation) {
	if o == nil {
		return
	}
	o.Server = op.Server
	o.DRS = op.DRS
	o.Return = op.Return
}
func (o *BindResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *BindResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_BindOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_UnbindOperation structure represents the IDL_DRSUnbind operation
type xxx_UnbindOperation struct {
	DRS    *Handle `idl:"name:phDrs;pointer:ref" json:"drs"`
	Return uint32  `idl:"name:Return" json:"return"`
}

func (o *xxx_UnbindOperation) OpNum() int { return 1 }

func (o *xxx_UnbindOperation) OpName() string { return "/drsuapi/v4/IDL_DRSUnbind" }

func (o *xxx_UnbindOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UnbindOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// phDrs {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.DRS != nil {
			if err := o.DRS.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_UnbindOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// phDrs {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.DRS == nil {
			o.DRS = &Handle{}
		}
		if err := o.DRS.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UnbindOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UnbindOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// phDrs {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.DRS != nil {
			if err := o.DRS.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UnbindOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// phDrs {in, out} (1:{pointer=ref}*(1))(2:{context_handle, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.DRS == nil {
			o.DRS = &Handle{}
		}
		if err := o.DRS.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// UnbindRequest structure represents the IDL_DRSUnbind operation request
type UnbindRequest struct {
	// phDrs: A pointer to the RPC context handle returned by the IDL_DRSBind method. The
	// value is set to null on return.
	DRS *Handle `idl:"name:phDrs;pointer:ref" json:"drs"`
}

func (o *UnbindRequest) xxx_ToOp(ctx context.Context, op *xxx_UnbindOperation) *xxx_UnbindOperation {
	if op == nil {
		op = &xxx_UnbindOperation{}
	}
	if o == nil {
		return op
	}
	o.DRS = op.DRS
	return op
}

func (o *UnbindRequest) xxx_FromOp(ctx context.Context, op *xxx_UnbindOperation) {
	if o == nil {
		return
	}
	o.DRS = op.DRS
}
func (o *UnbindRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *UnbindRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_UnbindOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// UnbindResponse structure represents the IDL_DRSUnbind operation response
type UnbindResponse struct {
	// phDrs: A pointer to the RPC context handle returned by the IDL_DRSBind method. The
	// value is set to null on return.
	DRS *Handle `idl:"name:phDrs;pointer:ref" json:"drs"`
	// Return: The IDL_DRSUnbind return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *UnbindResponse) xxx_ToOp(ctx context.Context, op *xxx_UnbindOperation) *xxx_UnbindOperation {
	if op == nil {
		op = &xxx_UnbindOperation{}
	}
	if o == nil {
		return op
	}
	o.DRS = op.DRS
	o.Return = op.Return
	return op
}

func (o *UnbindResponse) xxx_FromOp(ctx context.Context, op *xxx_UnbindOperation) {
	if o == nil {
		return
	}
	o.DRS = op.DRS
	o.Return = op.Return
}
func (o *UnbindResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *UnbindResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_UnbindOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SyncReplicaOperation structure represents the IDL_DRSReplicaSync operation
type xxx_SyncReplicaOperation struct {
	Handle  *Handle             `idl:"name:hDrs;pointer:ref" json:"handle"`
	Version uint32              `idl:"name:dwVersion" json:"version"`
	Sync    *MessageReplicaSync `idl:"name:pmsgSync;switch_is:dwVersion;pointer:ref" json:"sync"`
	Return  uint32              `idl:"name:Return" json:"return"`
}

func (o *xxx_SyncReplicaOperation) OpNum() int { return 2 }

func (o *xxx_SyncReplicaOperation) OpName() string { return "/drsuapi/v4/IDL_DRSReplicaSync" }

func (o *xxx_SyncReplicaOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SyncReplicaOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Version); err != nil {
			return err
		}
	}
	// pmsgSync {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_REPSYNC}(union))
	{
		_swSync := uint32(o.Version)
		if o.Sync != nil {
			if err := o.Sync.MarshalUnionNDR(ctx, w, _swSync); err != nil {
				return err
			}
		} else {
			if err := (&MessageReplicaSync{}).MarshalUnionNDR(ctx, w, _swSync); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SyncReplicaOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &Handle{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Version); err != nil {
			return err
		}
	}
	// pmsgSync {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_REPSYNC}(union))
	{
		if o.Sync == nil {
			o.Sync = &MessageReplicaSync{}
		}
		_swSync := uint32(o.Version)
		if err := o.Sync.UnmarshalUnionNDR(ctx, w, _swSync); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SyncReplicaOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SyncReplicaOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SyncReplicaOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SyncReplicaRequest structure represents the IDL_DRSReplicaSync operation request
type SyncReplicaRequest struct {
	// hDrs: The RPC context handle returned by the IDL_DRSBind method.
	Handle *Handle `idl:"name:hDrs;pointer:ref" json:"handle"`
	// dwVersion: The version of the request message.
	Version uint32 `idl:"name:dwVersion" json:"version"`
	// pmsgSync: A pointer to the request message.
	Sync *MessageReplicaSync `idl:"name:pmsgSync;switch_is:dwVersion;pointer:ref" json:"sync"`
}

func (o *SyncReplicaRequest) xxx_ToOp(ctx context.Context, op *xxx_SyncReplicaOperation) *xxx_SyncReplicaOperation {
	if op == nil {
		op = &xxx_SyncReplicaOperation{}
	}
	if o == nil {
		return op
	}
	o.Handle = op.Handle
	o.Version = op.Version
	o.Sync = op.Sync
	return op
}

func (o *SyncReplicaRequest) xxx_FromOp(ctx context.Context, op *xxx_SyncReplicaOperation) {
	if o == nil {
		return
	}
	o.Handle = op.Handle
	o.Version = op.Version
	o.Sync = op.Sync
}
func (o *SyncReplicaRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SyncReplicaRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SyncReplicaOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SyncReplicaResponse structure represents the IDL_DRSReplicaSync operation response
type SyncReplicaResponse struct {
	// Return: The IDL_DRSReplicaSync return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SyncReplicaResponse) xxx_ToOp(ctx context.Context, op *xxx_SyncReplicaOperation) *xxx_SyncReplicaOperation {
	if op == nil {
		op = &xxx_SyncReplicaOperation{}
	}
	if o == nil {
		return op
	}
	o.Return = op.Return
	return op
}

func (o *SyncReplicaResponse) xxx_FromOp(ctx context.Context, op *xxx_SyncReplicaOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SyncReplicaResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SyncReplicaResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SyncReplicaOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetNCChangesOperation structure represents the IDL_DRSGetNCChanges operation
type xxx_GetNCChangesOperation struct {
	Handle     *Handle                     `idl:"name:hDrs;pointer:ref" json:"handle"`
	InVersion  uint32                      `idl:"name:dwInVersion" json:"in_version"`
	In         *MessageGetNCChangesRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
	OutVersion uint32                      `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	Out        *MessageGetNCChangesReply   `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	Return     uint32                      `idl:"name:Return" json:"return"`
}

func (o *xxx_GetNCChangesOperation) OpNum() int { return 3 }

func (o *xxx_GetNCChangesOperation) OpName() string { return "/drsuapi/v4/IDL_DRSGetNCChanges" }

func (o *xxx_GetNCChangesOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNCChangesOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_GETCHGREQ}(union))
	{
		_swIn := uint32(o.InVersion)
		if o.In != nil {
			if err := o.In.MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		} else {
			if err := (&MessageGetNCChangesRequest{}).MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNCChangesOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &Handle{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_GETCHGREQ}(union))
	{
		if o.In == nil {
			o.In = &MessageGetNCChangesRequest{}
		}
		_swIn := uint32(o.InVersion)
		if err := o.In.UnmarshalUnionNDR(ctx, w, _swIn); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNCChangesOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNCChangesOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_GETCHGREPLY}(union))
	{
		_swOut := uint32(o.OutVersion)
		if o.Out != nil {
			if err := o.Out.MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		} else {
			if err := (&MessageGetNCChangesReply{}).MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNCChangesOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_GETCHGREPLY}(union))
	{
		if o.Out == nil {
			o.Out = &MessageGetNCChangesReply{}
		}
		_swOut := uint32(o.OutVersion)
		if err := o.Out.UnmarshalUnionNDR(ctx, w, _swOut); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetNCChangesRequest structure represents the IDL_DRSGetNCChanges operation request
type GetNCChangesRequest struct {
	// hDrs: The RPC context handle returned by the IDL_DRSBind method.
	Handle *Handle `idl:"name:hDrs;pointer:ref" json:"handle"`
	// dwInVersion: Version of the request message.
	InVersion uint32 `idl:"name:dwInVersion" json:"in_version"`
	// pmsgIn: A pointer to the request message.
	In *MessageGetNCChangesRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
}

func (o *GetNCChangesRequest) xxx_ToOp(ctx context.Context, op *xxx_GetNCChangesOperation) *xxx_GetNCChangesOperation {
	if op == nil {
		op = &xxx_GetNCChangesOperation{}
	}
	if o == nil {
		return op
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
	return op
}

func (o *GetNCChangesRequest) xxx_FromOp(ctx context.Context, op *xxx_GetNCChangesOperation) {
	if o == nil {
		return
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
}
func (o *GetNCChangesRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetNCChangesRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetNCChangesOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetNCChangesResponse structure represents the IDL_DRSGetNCChanges operation response
type GetNCChangesResponse struct {
	// pdwOutVersion: A pointer to the version of the response message.
	OutVersion uint32 `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	// pmsgOut: A pointer to the response message.
	Out *MessageGetNCChangesReply `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	// Return: The IDL_DRSGetNCChanges return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetNCChangesResponse) xxx_ToOp(ctx context.Context, op *xxx_GetNCChangesOperation) *xxx_GetNCChangesOperation {
	if op == nil {
		op = &xxx_GetNCChangesOperation{}
	}
	if o == nil {
		return op
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
	return op
}

func (o *GetNCChangesResponse) xxx_FromOp(ctx context.Context, op *xxx_GetNCChangesOperation) {
	if o == nil {
		return
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
}
func (o *GetNCChangesResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetNCChangesResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetNCChangesOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_UpdateReferencesOperation structure represents the IDL_DRSUpdateRefs operation
type xxx_UpdateReferencesOperation struct {
	Handle           *Handle                  `idl:"name:hDrs;pointer:ref" json:"handle"`
	Version          uint32                   `idl:"name:dwVersion" json:"version"`
	UpdateReferences *MessageUpdateReferences `idl:"name:pmsgUpdRefs;switch_is:dwVersion;pointer:ref" json:"update_references"`
	Return           uint32                   `idl:"name:Return" json:"return"`
}

func (o *xxx_UpdateReferencesOperation) OpNum() int { return 4 }

func (o *xxx_UpdateReferencesOperation) OpName() string { return "/drsuapi/v4/IDL_DRSUpdateRefs" }

func (o *xxx_UpdateReferencesOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UpdateReferencesOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Version); err != nil {
			return err
		}
	}
	// pmsgUpdRefs {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_UPDREFS}(union))
	{
		_swUpdateReferences := uint32(o.Version)
		if o.UpdateReferences != nil {
			if err := o.UpdateReferences.MarshalUnionNDR(ctx, w, _swUpdateReferences); err != nil {
				return err
			}
		} else {
			if err := (&MessageUpdateReferences{}).MarshalUnionNDR(ctx, w, _swUpdateReferences); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UpdateReferencesOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &Handle{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Version); err != nil {
			return err
		}
	}
	// pmsgUpdRefs {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_UPDREFS}(union))
	{
		if o.UpdateReferences == nil {
			o.UpdateReferences = &MessageUpdateReferences{}
		}
		_swUpdateReferences := uint32(o.Version)
		if err := o.UpdateReferences.UnmarshalUnionNDR(ctx, w, _swUpdateReferences); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UpdateReferencesOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UpdateReferencesOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UpdateReferencesOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// UpdateReferencesRequest structure represents the IDL_DRSUpdateRefs operation request
type UpdateReferencesRequest struct {
	// hDrs: The RPC context handle returned by the IDL_DRSBind method.
	Handle *Handle `idl:"name:hDrs;pointer:ref" json:"handle"`
	// dwVersion: The version of the request message.
	Version uint32 `idl:"name:dwVersion" json:"version"`
	// pmsgUpdRefs: A pointer to the request message.
	UpdateReferences *MessageUpdateReferences `idl:"name:pmsgUpdRefs;switch_is:dwVersion;pointer:ref" json:"update_references"`
}

func (o *UpdateReferencesRequest) xxx_ToOp(ctx context.Context, op *xxx_UpdateReferencesOperation) *xxx_UpdateReferencesOperation {
	if op == nil {
		op = &xxx_UpdateReferencesOperation{}
	}
	if o == nil {
		return op
	}
	o.Handle = op.Handle
	o.Version = op.Version
	o.UpdateReferences = op.UpdateReferences
	return op
}

func (o *UpdateReferencesRequest) xxx_FromOp(ctx context.Context, op *xxx_UpdateReferencesOperation) {
	if o == nil {
		return
	}
	o.Handle = op.Handle
	o.Version = op.Version
	o.UpdateReferences = op.UpdateReferences
}
func (o *UpdateReferencesRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *UpdateReferencesRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_UpdateReferencesOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// UpdateReferencesResponse structure represents the IDL_DRSUpdateRefs operation response
type UpdateReferencesResponse struct {
	// Return: The IDL_DRSUpdateRefs return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *UpdateReferencesResponse) xxx_ToOp(ctx context.Context, op *xxx_UpdateReferencesOperation) *xxx_UpdateReferencesOperation {
	if op == nil {
		op = &xxx_UpdateReferencesOperation{}
	}
	if o == nil {
		return op
	}
	o.Return = op.Return
	return op
}

func (o *UpdateReferencesResponse) xxx_FromOp(ctx context.Context, op *xxx_UpdateReferencesOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *UpdateReferencesResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *UpdateReferencesResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_UpdateReferencesOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddReplicaOperation structure represents the IDL_DRSReplicaAdd operation
type xxx_AddReplicaOperation struct {
	Handle  *Handle            `idl:"name:hDrs;pointer:ref" json:"handle"`
	Version uint32             `idl:"name:dwVersion" json:"version"`
	Add     *MessageAddReplica `idl:"name:pmsgAdd;switch_is:dwVersion;pointer:ref" json:"add"`
	Return  uint32             `idl:"name:Return" json:"return"`
}

func (o *xxx_AddReplicaOperation) OpNum() int { return 5 }

func (o *xxx_AddReplicaOperation) OpName() string { return "/drsuapi/v4/IDL_DRSReplicaAdd" }

func (o *xxx_AddReplicaOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddReplicaOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Version); err != nil {
			return err
		}
	}
	// pmsgAdd {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_REPADD}(union))
	{
		_swAdd := uint32(o.Version)
		if o.Add != nil {
			if err := o.Add.MarshalUnionNDR(ctx, w, _swAdd); err != nil {
				return err
			}
		} else {
			if err := (&MessageAddReplica{}).MarshalUnionNDR(ctx, w, _swAdd); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddReplicaOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &Handle{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Version); err != nil {
			return err
		}
	}
	// pmsgAdd {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_REPADD}(union))
	{
		if o.Add == nil {
			o.Add = &MessageAddReplica{}
		}
		_swAdd := uint32(o.Version)
		if err := o.Add.UnmarshalUnionNDR(ctx, w, _swAdd); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddReplicaOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddReplicaOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddReplicaOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddReplicaRequest structure represents the IDL_DRSReplicaAdd operation request
type AddReplicaRequest struct {
	// hDrs: The RPC context handle returned by the IDL_DRSBind method.
	Handle *Handle `idl:"name:hDrs;pointer:ref" json:"handle"`
	// dwVersion: The version of the request message.
	Version uint32 `idl:"name:dwVersion" json:"version"`
	// pmsgAdd: A pointer to the request message.
	Add *MessageAddReplica `idl:"name:pmsgAdd;switch_is:dwVersion;pointer:ref" json:"add"`
}

func (o *AddReplicaRequest) xxx_ToOp(ctx context.Context, op *xxx_AddReplicaOperation) *xxx_AddReplicaOperation {
	if op == nil {
		op = &xxx_AddReplicaOperation{}
	}
	if o == nil {
		return op
	}
	o.Handle = op.Handle
	o.Version = op.Version
	o.Add = op.Add
	return op
}

func (o *AddReplicaRequest) xxx_FromOp(ctx context.Context, op *xxx_AddReplicaOperation) {
	if o == nil {
		return
	}
	o.Handle = op.Handle
	o.Version = op.Version
	o.Add = op.Add
}
func (o *AddReplicaRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *AddReplicaRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddReplicaOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddReplicaResponse structure represents the IDL_DRSReplicaAdd operation response
type AddReplicaResponse struct {
	// Return: The IDL_DRSReplicaAdd return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddReplicaResponse) xxx_ToOp(ctx context.Context, op *xxx_AddReplicaOperation) *xxx_AddReplicaOperation {
	if op == nil {
		op = &xxx_AddReplicaOperation{}
	}
	if o == nil {
		return op
	}
	o.Return = op.Return
	return op
}

func (o *AddReplicaResponse) xxx_FromOp(ctx context.Context, op *xxx_AddReplicaOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *AddReplicaResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *AddReplicaResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddReplicaOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_DeleteReplicaOperation structure represents the IDL_DRSReplicaDel operation
type xxx_DeleteReplicaOperation struct {
	Handle  *Handle               `idl:"name:hDrs;pointer:ref" json:"handle"`
	Version uint32                `idl:"name:dwVersion" json:"version"`
	Delete  *MessageDeleteReplica `idl:"name:pmsgDel;switch_is:dwVersion;pointer:ref" json:"delete"`
	Return  uint32                `idl:"name:Return" json:"return"`
}

func (o *xxx_DeleteReplicaOperation) OpNum() int { return 6 }

func (o *xxx_DeleteReplicaOperation) OpName() string { return "/drsuapi/v4/IDL_DRSReplicaDel" }

func (o *xxx_DeleteReplicaOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteReplicaOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Version); err != nil {
			return err
		}
	}
	// pmsgDel {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_REPDEL}(union))
	{
		_swDelete := uint32(o.Version)
		if o.Delete != nil {
			if err := o.Delete.MarshalUnionNDR(ctx, w, _swDelete); err != nil {
				return err
			}
		} else {
			if err := (&MessageDeleteReplica{}).MarshalUnionNDR(ctx, w, _swDelete); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteReplicaOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &Handle{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Version); err != nil {
			return err
		}
	}
	// pmsgDel {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_REPDEL}(union))
	{
		if o.Delete == nil {
			o.Delete = &MessageDeleteReplica{}
		}
		_swDelete := uint32(o.Version)
		if err := o.Delete.UnmarshalUnionNDR(ctx, w, _swDelete); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteReplicaOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteReplicaOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteReplicaOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// DeleteReplicaRequest structure represents the IDL_DRSReplicaDel operation request
type DeleteReplicaRequest struct {
	// hDrs: The RPC context handle returned by IDL_DRSBind.
	Handle *Handle `idl:"name:hDrs;pointer:ref" json:"handle"`
	// dwVersion: The version of the request message.
	Version uint32 `idl:"name:dwVersion" json:"version"`
	// pmsgDel: A pointer to the request message.
	Delete *MessageDeleteReplica `idl:"name:pmsgDel;switch_is:dwVersion;pointer:ref" json:"delete"`
}

func (o *DeleteReplicaRequest) xxx_ToOp(ctx context.Context, op *xxx_DeleteReplicaOperation) *xxx_DeleteReplicaOperation {
	if op == nil {
		op = &xxx_DeleteReplicaOperation{}
	}
	if o == nil {
		return op
	}
	o.Handle = op.Handle
	o.Version = op.Version
	o.Delete = op.Delete
	return op
}

func (o *DeleteReplicaRequest) xxx_FromOp(ctx context.Context, op *xxx_DeleteReplicaOperation) {
	if o == nil {
		return
	}
	o.Handle = op.Handle
	o.Version = op.Version
	o.Delete = op.Delete
}
func (o *DeleteReplicaRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *DeleteReplicaRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteReplicaOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// DeleteReplicaResponse structure represents the IDL_DRSReplicaDel operation response
type DeleteReplicaResponse struct {
	// Return: The IDL_DRSReplicaDel return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *DeleteReplicaResponse) xxx_ToOp(ctx context.Context, op *xxx_DeleteReplicaOperation) *xxx_DeleteReplicaOperation {
	if op == nil {
		op = &xxx_DeleteReplicaOperation{}
	}
	if o == nil {
		return op
	}
	o.Return = op.Return
	return op
}

func (o *DeleteReplicaResponse) xxx_FromOp(ctx context.Context, op *xxx_DeleteReplicaOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *DeleteReplicaResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *DeleteReplicaResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteReplicaOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ModifyReplicaOperation structure represents the IDL_DRSReplicaModify operation
type xxx_ModifyReplicaOperation struct {
	Handle  *Handle               `idl:"name:hDrs;pointer:ref" json:"handle"`
	Version uint32                `idl:"name:dwVersion" json:"version"`
	Modify  *MessageModifyReplica `idl:"name:pmsgMod;switch_is:dwVersion;pointer:ref" json:"modify"`
	Return  uint32                `idl:"name:Return" json:"return"`
}

func (o *xxx_ModifyReplicaOperation) OpNum() int { return 7 }

func (o *xxx_ModifyReplicaOperation) OpName() string { return "/drsuapi/v4/IDL_DRSReplicaModify" }

func (o *xxx_ModifyReplicaOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ModifyReplicaOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Version); err != nil {
			return err
		}
	}
	// pmsgMod {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_REPMOD}(union))
	{
		_swModify := uint32(o.Version)
		if o.Modify != nil {
			if err := o.Modify.MarshalUnionNDR(ctx, w, _swModify); err != nil {
				return err
			}
		} else {
			if err := (&MessageModifyReplica{}).MarshalUnionNDR(ctx, w, _swModify); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ModifyReplicaOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &Handle{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Version); err != nil {
			return err
		}
	}
	// pmsgMod {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_REPMOD}(union))
	{
		if o.Modify == nil {
			o.Modify = &MessageModifyReplica{}
		}
		_swModify := uint32(o.Version)
		if err := o.Modify.UnmarshalUnionNDR(ctx, w, _swModify); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ModifyReplicaOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ModifyReplicaOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ModifyReplicaOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ModifyReplicaRequest structure represents the IDL_DRSReplicaModify operation request
type ModifyReplicaRequest struct {
	// hDrs: The RPC context handle returned by IDL_DRSBind.
	Handle *Handle `idl:"name:hDrs;pointer:ref" json:"handle"`
	// dwVersion: The version of the request message.
	Version uint32 `idl:"name:dwVersion" json:"version"`
	// pmsgMod: A pointer to the request message.
	Modify *MessageModifyReplica `idl:"name:pmsgMod;switch_is:dwVersion;pointer:ref" json:"modify"`
}

func (o *ModifyReplicaRequest) xxx_ToOp(ctx context.Context, op *xxx_ModifyReplicaOperation) *xxx_ModifyReplicaOperation {
	if op == nil {
		op = &xxx_ModifyReplicaOperation{}
	}
	if o == nil {
		return op
	}
	o.Handle = op.Handle
	o.Version = op.Version
	o.Modify = op.Modify
	return op
}

func (o *ModifyReplicaRequest) xxx_FromOp(ctx context.Context, op *xxx_ModifyReplicaOperation) {
	if o == nil {
		return
	}
	o.Handle = op.Handle
	o.Version = op.Version
	o.Modify = op.Modify
}
func (o *ModifyReplicaRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *ModifyReplicaRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ModifyReplicaOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ModifyReplicaResponse structure represents the IDL_DRSReplicaModify operation response
type ModifyReplicaResponse struct {
	// Return: The IDL_DRSReplicaModify return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ModifyReplicaResponse) xxx_ToOp(ctx context.Context, op *xxx_ModifyReplicaOperation) *xxx_ModifyReplicaOperation {
	if op == nil {
		op = &xxx_ModifyReplicaOperation{}
	}
	if o == nil {
		return op
	}
	o.Return = op.Return
	return op
}

func (o *ModifyReplicaResponse) xxx_FromOp(ctx context.Context, op *xxx_ModifyReplicaOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *ModifyReplicaResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *ModifyReplicaResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ModifyReplicaOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_VerifyNamesOperation structure represents the IDL_DRSVerifyNames operation
type xxx_VerifyNamesOperation struct {
	Handle     *Handle               `idl:"name:hDrs;pointer:ref" json:"handle"`
	InVersion  uint32                `idl:"name:dwInVersion" json:"in_version"`
	In         *MessageVerifyRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
	OutVersion uint32                `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	Out        *MessageVerifyReply   `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	Return     uint32                `idl:"name:Return" json:"return"`
}

func (o *xxx_VerifyNamesOperation) OpNum() int { return 8 }

func (o *xxx_VerifyNamesOperation) OpName() string { return "/drsuapi/v4/IDL_DRSVerifyNames" }

func (o *xxx_VerifyNamesOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_VerifyNamesOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_VERIFYREQ}(union))
	{
		_swIn := uint32(o.InVersion)
		if o.In != nil {
			if err := o.In.MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		} else {
			if err := (&MessageVerifyRequest{}).MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_VerifyNamesOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &Handle{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_VERIFYREQ}(union))
	{
		if o.In == nil {
			o.In = &MessageVerifyRequest{}
		}
		_swIn := uint32(o.InVersion)
		if err := o.In.UnmarshalUnionNDR(ctx, w, _swIn); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_VerifyNamesOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_VerifyNamesOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_VERIFYREPLY}(union))
	{
		_swOut := uint32(o.OutVersion)
		if o.Out != nil {
			if err := o.Out.MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		} else {
			if err := (&MessageVerifyReply{}).MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_VerifyNamesOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_VERIFYREPLY}(union))
	{
		if o.Out == nil {
			o.Out = &MessageVerifyReply{}
		}
		_swOut := uint32(o.OutVersion)
		if err := o.Out.UnmarshalUnionNDR(ctx, w, _swOut); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// VerifyNamesRequest structure represents the IDL_DRSVerifyNames operation request
type VerifyNamesRequest struct {
	// hDrs: The RPC context handle returned by the IDL_DRSBind method.
	Handle *Handle `idl:"name:hDrs;pointer:ref" json:"handle"`
	// dwInVersion: The version of the request message.
	InVersion uint32 `idl:"name:dwInVersion" json:"in_version"`
	// pmsgIn: A pointer to the request message.
	In *MessageVerifyRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
}

func (o *VerifyNamesRequest) xxx_ToOp(ctx context.Context, op *xxx_VerifyNamesOperation) *xxx_VerifyNamesOperation {
	if op == nil {
		op = &xxx_VerifyNamesOperation{}
	}
	if o == nil {
		return op
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
	return op
}

func (o *VerifyNamesRequest) xxx_FromOp(ctx context.Context, op *xxx_VerifyNamesOperation) {
	if o == nil {
		return
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
}
func (o *VerifyNamesRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *VerifyNamesRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_VerifyNamesOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// VerifyNamesResponse structure represents the IDL_DRSVerifyNames operation response
type VerifyNamesResponse struct {
	// pdwOutVersion: A pointer to the version of the response message.
	OutVersion uint32 `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	// pmsgOut: A pointer to the response message.
	Out *MessageVerifyReply `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	// Return: The IDL_DRSVerifyNames return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *VerifyNamesResponse) xxx_ToOp(ctx context.Context, op *xxx_VerifyNamesOperation) *xxx_VerifyNamesOperation {
	if op == nil {
		op = &xxx_VerifyNamesOperation{}
	}
	if o == nil {
		return op
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
	return op
}

func (o *VerifyNamesResponse) xxx_FromOp(ctx context.Context, op *xxx_VerifyNamesOperation) {
	if o == nil {
		return
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
}
func (o *VerifyNamesResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *VerifyNamesResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_VerifyNamesOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetMembershipsOperation structure represents the IDL_DRSGetMemberships operation
type xxx_GetMembershipsOperation struct {
	Handle     *Handle                          `idl:"name:hDrs;pointer:ref" json:"handle"`
	InVersion  uint32                           `idl:"name:dwInVersion" json:"in_version"`
	In         *MessageReverseMembershipRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
	OutVersion uint32                           `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	Out        *MessageReverseMembershipReply   `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	Return     uint32                           `idl:"name:Return" json:"return"`
}

func (o *xxx_GetMembershipsOperation) OpNum() int { return 9 }

func (o *xxx_GetMembershipsOperation) OpName() string { return "/drsuapi/v4/IDL_DRSGetMemberships" }

func (o *xxx_GetMembershipsOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMembershipsOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_REVMEMB_REQ}(union))
	{
		_swIn := uint32(o.InVersion)
		if o.In != nil {
			if err := o.In.MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		} else {
			if err := (&MessageReverseMembershipRequest{}).MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMembershipsOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &Handle{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_REVMEMB_REQ}(union))
	{
		if o.In == nil {
			o.In = &MessageReverseMembershipRequest{}
		}
		_swIn := uint32(o.InVersion)
		if err := o.In.UnmarshalUnionNDR(ctx, w, _swIn); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMembershipsOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMembershipsOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_REVMEMB_REPLY}(union))
	{
		_swOut := uint32(o.OutVersion)
		if o.Out != nil {
			if err := o.Out.MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		} else {
			if err := (&MessageReverseMembershipReply{}).MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMembershipsOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_REVMEMB_REPLY}(union))
	{
		if o.Out == nil {
			o.Out = &MessageReverseMembershipReply{}
		}
		_swOut := uint32(o.OutVersion)
		if err := o.Out.UnmarshalUnionNDR(ctx, w, _swOut); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetMembershipsRequest structure represents the IDL_DRSGetMemberships operation request
type GetMembershipsRequest struct {
	// hDrs: RPC context handle returned by the IDL_DRSBind method.
	Handle *Handle `idl:"name:hDrs;pointer:ref" json:"handle"`
	// dwInVersion: Version of the request message.
	InVersion uint32 `idl:"name:dwInVersion" json:"in_version"`
	// pmsgIn: Pointer to the request message.
	In *MessageReverseMembershipRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
}

func (o *GetMembershipsRequest) xxx_ToOp(ctx context.Context, op *xxx_GetMembershipsOperation) *xxx_GetMembershipsOperation {
	if op == nil {
		op = &xxx_GetMembershipsOperation{}
	}
	if o == nil {
		return op
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
	return op
}

func (o *GetMembershipsRequest) xxx_FromOp(ctx context.Context, op *xxx_GetMembershipsOperation) {
	if o == nil {
		return
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
}
func (o *GetMembershipsRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetMembershipsRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetMembershipsOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetMembershipsResponse structure represents the IDL_DRSGetMemberships operation response
type GetMembershipsResponse struct {
	// pdwOutVersion: Pointer to the version of the response message.
	OutVersion uint32 `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	// pmsgOut: Pointer to the response message.
	Out *MessageReverseMembershipReply `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	// Return: The IDL_DRSGetMemberships return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetMembershipsResponse) xxx_ToOp(ctx context.Context, op *xxx_GetMembershipsOperation) *xxx_GetMembershipsOperation {
	if op == nil {
		op = &xxx_GetMembershipsOperation{}
	}
	if o == nil {
		return op
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
	return op
}

func (o *GetMembershipsResponse) xxx_FromOp(ctx context.Context, op *xxx_GetMembershipsOperation) {
	if o == nil {
		return
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
}
func (o *GetMembershipsResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetMembershipsResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetMembershipsOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_InterdomainMoveOperation structure represents the IDL_DRSInterDomainMove operation
type xxx_InterdomainMoveOperation struct {
	Handle     *Handle             `idl:"name:hDrs;pointer:ref" json:"handle"`
	InVersion  uint32              `idl:"name:dwInVersion" json:"in_version"`
	In         *MessageMoveRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
	OutVersion uint32              `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	Out        *MessageMoveReply   `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	Return     uint32              `idl:"name:Return" json:"return"`
}

func (o *xxx_InterdomainMoveOperation) OpNum() int { return 10 }

func (o *xxx_InterdomainMoveOperation) OpName() string { return "/drsuapi/v4/IDL_DRSInterDomainMove" }

func (o *xxx_InterdomainMoveOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_InterdomainMoveOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_MOVEREQ}(union))
	{
		_swIn := uint32(o.InVersion)
		if o.In != nil {
			if err := o.In.MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		} else {
			if err := (&MessageMoveRequest{}).MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_InterdomainMoveOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &Handle{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_MOVEREQ}(union))
	{
		if o.In == nil {
			o.In = &MessageMoveRequest{}
		}
		_swIn := uint32(o.InVersion)
		if err := o.In.UnmarshalUnionNDR(ctx, w, _swIn); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_InterdomainMoveOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_InterdomainMoveOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_MOVEREPLY}(union))
	{
		_swOut := uint32(o.OutVersion)
		if o.Out != nil {
			if err := o.Out.MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		} else {
			if err := (&MessageMoveReply{}).MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_InterdomainMoveOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_MOVEREPLY}(union))
	{
		if o.Out == nil {
			o.Out = &MessageMoveReply{}
		}
		_swOut := uint32(o.OutVersion)
		if err := o.Out.UnmarshalUnionNDR(ctx, w, _swOut); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// InterdomainMoveRequest structure represents the IDL_DRSInterDomainMove operation request
type InterdomainMoveRequest struct {
	// hDrs: The RPC context handle returned by the IDL_DRSBind method.
	Handle *Handle `idl:"name:hDrs;pointer:ref" json:"handle"`
	// dwInVersion: The version of the request message.
	InVersion uint32 `idl:"name:dwInVersion" json:"in_version"`
	// pmsgIn: A pointer to the request message.
	In *MessageMoveRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
}

func (o *InterdomainMoveRequest) xxx_ToOp(ctx context.Context, op *xxx_InterdomainMoveOperation) *xxx_InterdomainMoveOperation {
	if op == nil {
		op = &xxx_InterdomainMoveOperation{}
	}
	if o == nil {
		return op
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
	return op
}

func (o *InterdomainMoveRequest) xxx_FromOp(ctx context.Context, op *xxx_InterdomainMoveOperation) {
	if o == nil {
		return
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
}
func (o *InterdomainMoveRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *InterdomainMoveRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_InterdomainMoveOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// InterdomainMoveResponse structure represents the IDL_DRSInterDomainMove operation response
type InterdomainMoveResponse struct {
	// pdwOutVersion: A pointer to the version of the response message.
	OutVersion uint32 `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	// pmsgOut: A pointer to the response message.
	Out *MessageMoveReply `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	// Return: The IDL_DRSInterDomainMove return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *InterdomainMoveResponse) xxx_ToOp(ctx context.Context, op *xxx_InterdomainMoveOperation) *xxx_InterdomainMoveOperation {
	if op == nil {
		op = &xxx_InterdomainMoveOperation{}
	}
	if o == nil {
		return op
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
	return op
}

func (o *InterdomainMoveResponse) xxx_FromOp(ctx context.Context, op *xxx_InterdomainMoveOperation) {
	if o == nil {
		return
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
}
func (o *InterdomainMoveResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *InterdomainMoveResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_InterdomainMoveOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetNT4ChangeLogOperation structure represents the IDL_DRSGetNT4ChangeLog operation
type xxx_GetNT4ChangeLogOperation struct {
	Handle     *Handle                     `idl:"name:hDrs;pointer:ref" json:"handle"`
	InVersion  uint32                      `idl:"name:dwInVersion" json:"in_version"`
	In         *MessageNT4ChangeLogRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
	OutVersion uint32                      `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	Out        *MessageNT4ChangeLogReply   `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	Return     uint32                      `idl:"name:Return" json:"return"`
}

func (o *xxx_GetNT4ChangeLogOperation) OpNum() int { return 11 }

func (o *xxx_GetNT4ChangeLogOperation) OpName() string { return "/drsuapi/v4/IDL_DRSGetNT4ChangeLog" }

func (o *xxx_GetNT4ChangeLogOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNT4ChangeLogOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_NT4_CHGLOG_REQ}(union))
	{
		_swIn := uint32(o.InVersion)
		if o.In != nil {
			if err := o.In.MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		} else {
			if err := (&MessageNT4ChangeLogRequest{}).MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNT4ChangeLogOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &Handle{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_NT4_CHGLOG_REQ}(union))
	{
		if o.In == nil {
			o.In = &MessageNT4ChangeLogRequest{}
		}
		_swIn := uint32(o.InVersion)
		if err := o.In.UnmarshalUnionNDR(ctx, w, _swIn); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNT4ChangeLogOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNT4ChangeLogOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_NT4_CHGLOG_REPLY}(union))
	{
		_swOut := uint32(o.OutVersion)
		if o.Out != nil {
			if err := o.Out.MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		} else {
			if err := (&MessageNT4ChangeLogReply{}).MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNT4ChangeLogOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_NT4_CHGLOG_REPLY}(union))
	{
		if o.Out == nil {
			o.Out = &MessageNT4ChangeLogReply{}
		}
		_swOut := uint32(o.OutVersion)
		if err := o.Out.UnmarshalUnionNDR(ctx, w, _swOut); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetNT4ChangeLogRequest structure represents the IDL_DRSGetNT4ChangeLog operation request
type GetNT4ChangeLogRequest struct {
	// hDrs: The RPC context handle returned by the IDL_DRSBind method.
	Handle *Handle `idl:"name:hDrs;pointer:ref" json:"handle"`
	// dwInVersion: The version of the request message.
	InVersion uint32 `idl:"name:dwInVersion" json:"in_version"`
	// pmsgIn: A pointer to the request message.
	In *MessageNT4ChangeLogRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
}

func (o *GetNT4ChangeLogRequest) xxx_ToOp(ctx context.Context, op *xxx_GetNT4ChangeLogOperation) *xxx_GetNT4ChangeLogOperation {
	if op == nil {
		op = &xxx_GetNT4ChangeLogOperation{}
	}
	if o == nil {
		return op
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
	return op
}

func (o *GetNT4ChangeLogRequest) xxx_FromOp(ctx context.Context, op *xxx_GetNT4ChangeLogOperation) {
	if o == nil {
		return
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
}
func (o *GetNT4ChangeLogRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetNT4ChangeLogRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetNT4ChangeLogOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetNT4ChangeLogResponse structure represents the IDL_DRSGetNT4ChangeLog operation response
type GetNT4ChangeLogResponse struct {
	// pdwOutVersion: A pointer to the version of the response message.
	OutVersion uint32 `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	// pmsgOut: A pointer to the response message.
	Out *MessageNT4ChangeLogReply `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	// Return: The IDL_DRSGetNT4ChangeLog return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetNT4ChangeLogResponse) xxx_ToOp(ctx context.Context, op *xxx_GetNT4ChangeLogOperation) *xxx_GetNT4ChangeLogOperation {
	if op == nil {
		op = &xxx_GetNT4ChangeLogOperation{}
	}
	if o == nil {
		return op
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
	return op
}

func (o *GetNT4ChangeLogResponse) xxx_FromOp(ctx context.Context, op *xxx_GetNT4ChangeLogOperation) {
	if o == nil {
		return
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
}
func (o *GetNT4ChangeLogResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetNT4ChangeLogResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetNT4ChangeLogOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CrackNamesOperation structure represents the IDL_DRSCrackNames operation
type xxx_CrackNamesOperation struct {
	Handle     *Handle                   `idl:"name:hDrs;pointer:ref" json:"handle"`
	InVersion  uint32                    `idl:"name:dwInVersion" json:"in_version"`
	In         *MessageCrackNamesRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
	OutVersion uint32                    `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	Out        *MessageCrackNamesReply   `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	Return     uint32                    `idl:"name:Return" json:"return"`
}

func (o *xxx_CrackNamesOperation) OpNum() int { return 12 }

func (o *xxx_CrackNamesOperation) OpName() string { return "/drsuapi/v4/IDL_DRSCrackNames" }

func (o *xxx_CrackNamesOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CrackNamesOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_CRACKREQ}(union))
	{
		_swIn := uint32(o.InVersion)
		if o.In != nil {
			if err := o.In.MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		} else {
			if err := (&MessageCrackNamesRequest{}).MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CrackNamesOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &Handle{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_CRACKREQ}(union))
	{
		if o.In == nil {
			o.In = &MessageCrackNamesRequest{}
		}
		_swIn := uint32(o.InVersion)
		if err := o.In.UnmarshalUnionNDR(ctx, w, _swIn); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CrackNamesOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CrackNamesOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_CRACKREPLY}(union))
	{
		_swOut := uint32(o.OutVersion)
		if o.Out != nil {
			if err := o.Out.MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		} else {
			if err := (&MessageCrackNamesReply{}).MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CrackNamesOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_CRACKREPLY}(union))
	{
		if o.Out == nil {
			o.Out = &MessageCrackNamesReply{}
		}
		_swOut := uint32(o.OutVersion)
		if err := o.Out.UnmarshalUnionNDR(ctx, w, _swOut); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CrackNamesRequest structure represents the IDL_DRSCrackNames operation request
type CrackNamesRequest struct {
	// hDrs: RPC context handle returned by the IDL_DRSBind method.
	Handle *Handle `idl:"name:hDrs;pointer:ref" json:"handle"`
	// dwInVersion: Version of the request message.
	InVersion uint32 `idl:"name:dwInVersion" json:"in_version"`
	// pmsgIn: Pointer to the request message.
	In *MessageCrackNamesRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
}

func (o *CrackNamesRequest) xxx_ToOp(ctx context.Context, op *xxx_CrackNamesOperation) *xxx_CrackNamesOperation {
	if op == nil {
		op = &xxx_CrackNamesOperation{}
	}
	if o == nil {
		return op
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
	return op
}

func (o *CrackNamesRequest) xxx_FromOp(ctx context.Context, op *xxx_CrackNamesOperation) {
	if o == nil {
		return
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
}
func (o *CrackNamesRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *CrackNamesRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CrackNamesOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CrackNamesResponse structure represents the IDL_DRSCrackNames operation response
type CrackNamesResponse struct {
	// pdwOutVersion: Pointer to the version of the response message.
	OutVersion uint32 `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	// pmsgOut: Pointer to the response message.
	Out *MessageCrackNamesReply `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	// Return: The IDL_DRSCrackNames return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CrackNamesResponse) xxx_ToOp(ctx context.Context, op *xxx_CrackNamesOperation) *xxx_CrackNamesOperation {
	if op == nil {
		op = &xxx_CrackNamesOperation{}
	}
	if o == nil {
		return op
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
	return op
}

func (o *CrackNamesResponse) xxx_FromOp(ctx context.Context, op *xxx_CrackNamesOperation) {
	if o == nil {
		return
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
}
func (o *CrackNamesResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *CrackNamesResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CrackNamesOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_WriteSPNOperation structure represents the IDL_DRSWriteSPN operation
type xxx_WriteSPNOperation struct {
	Handle     *Handle                 `idl:"name:hDrs;pointer:ref" json:"handle"`
	InVersion  uint32                  `idl:"name:dwInVersion" json:"in_version"`
	In         *MessageWriteSPNRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
	OutVersion uint32                  `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	Out        *MessageWriteSPNReply   `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	Return     uint32                  `idl:"name:Return" json:"return"`
}

func (o *xxx_WriteSPNOperation) OpNum() int { return 13 }

func (o *xxx_WriteSPNOperation) OpName() string { return "/drsuapi/v4/IDL_DRSWriteSPN" }

func (o *xxx_WriteSPNOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_WriteSPNOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_SPNREQ}(union))
	{
		_swIn := uint32(o.InVersion)
		if o.In != nil {
			if err := o.In.MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		} else {
			if err := (&MessageWriteSPNRequest{}).MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_WriteSPNOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &Handle{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_SPNREQ}(union))
	{
		if o.In == nil {
			o.In = &MessageWriteSPNRequest{}
		}
		_swIn := uint32(o.InVersion)
		if err := o.In.UnmarshalUnionNDR(ctx, w, _swIn); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_WriteSPNOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_WriteSPNOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_SPNREPLY}(union))
	{
		_swOut := uint32(o.OutVersion)
		if o.Out != nil {
			if err := o.Out.MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		} else {
			if err := (&MessageWriteSPNReply{}).MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_WriteSPNOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_SPNREPLY}(union))
	{
		if o.Out == nil {
			o.Out = &MessageWriteSPNReply{}
		}
		_swOut := uint32(o.OutVersion)
		if err := o.Out.UnmarshalUnionNDR(ctx, w, _swOut); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// WriteSPNRequest structure represents the IDL_DRSWriteSPN operation request
type WriteSPNRequest struct {
	// hDrs: The RPC context handle returned by the IDL_DRSBind method.
	Handle *Handle `idl:"name:hDrs;pointer:ref" json:"handle"`
	// dwInVersion: The version of the request message. Must be set to 1, because that is
	// the only version supported.
	InVersion uint32 `idl:"name:dwInVersion" json:"in_version"`
	// pmsgIn: A pointer to the request message.
	In *MessageWriteSPNRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
}

func (o *WriteSPNRequest) xxx_ToOp(ctx context.Context, op *xxx_WriteSPNOperation) *xxx_WriteSPNOperation {
	if op == nil {
		op = &xxx_WriteSPNOperation{}
	}
	if o == nil {
		return op
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
	return op
}

func (o *WriteSPNRequest) xxx_FromOp(ctx context.Context, op *xxx_WriteSPNOperation) {
	if o == nil {
		return
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
}
func (o *WriteSPNRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *WriteSPNRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_WriteSPNOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// WriteSPNResponse structure represents the IDL_DRSWriteSPN operation response
type WriteSPNResponse struct {
	// pdwOutVersion: A pointer to the version of the response message. The value must be
	// 1 because that is the only version supported.
	OutVersion uint32 `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	// pmsgOut: A pointer to the response message.
	Out *MessageWriteSPNReply `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	// Return: The IDL_DRSWriteSPN return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *WriteSPNResponse) xxx_ToOp(ctx context.Context, op *xxx_WriteSPNOperation) *xxx_WriteSPNOperation {
	if op == nil {
		op = &xxx_WriteSPNOperation{}
	}
	if o == nil {
		return op
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
	return op
}

func (o *WriteSPNResponse) xxx_FromOp(ctx context.Context, op *xxx_WriteSPNOperation) {
	if o == nil {
		return
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
}
func (o *WriteSPNResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *WriteSPNResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_WriteSPNOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_RemoveDSServerOperation structure represents the IDL_DRSRemoveDsServer operation
type xxx_RemoveDSServerOperation struct {
	Handle     *Handle                     `idl:"name:hDrs;pointer:ref" json:"handle"`
	InVersion  uint32                      `idl:"name:dwInVersion" json:"in_version"`
	In         *MessageRemoveServerRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
	OutVersion uint32                      `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	Out        *MessageRemoveServerReply   `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	Return     uint32                      `idl:"name:Return" json:"return"`
}

func (o *xxx_RemoveDSServerOperation) OpNum() int { return 14 }

func (o *xxx_RemoveDSServerOperation) OpName() string { return "/drsuapi/v4/IDL_DRSRemoveDsServer" }

func (o *xxx_RemoveDSServerOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveDSServerOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_RMSVRREQ}(union))
	{
		_swIn := uint32(o.InVersion)
		if o.In != nil {
			if err := o.In.MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		} else {
			if err := (&MessageRemoveServerRequest{}).MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveDSServerOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &Handle{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_RMSVRREQ}(union))
	{
		if o.In == nil {
			o.In = &MessageRemoveServerRequest{}
		}
		_swIn := uint32(o.InVersion)
		if err := o.In.UnmarshalUnionNDR(ctx, w, _swIn); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveDSServerOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveDSServerOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_RMSVRREPLY}(union))
	{
		_swOut := uint32(o.OutVersion)
		if o.Out != nil {
			if err := o.Out.MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		} else {
			if err := (&MessageRemoveServerReply{}).MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveDSServerOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_RMSVRREPLY}(union))
	{
		if o.Out == nil {
			o.Out = &MessageRemoveServerReply{}
		}
		_swOut := uint32(o.OutVersion)
		if err := o.Out.UnmarshalUnionNDR(ctx, w, _swOut); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// RemoveDSServerRequest structure represents the IDL_DRSRemoveDsServer operation request
type RemoveDSServerRequest struct {
	// hDrs: The RPC context handle returned by the IDL_DRSBind method.
	Handle *Handle `idl:"name:hDrs;pointer:ref" json:"handle"`
	// dwInVersion: The version of the request message. Must be set to 1 because that is
	// the only version supported.
	InVersion uint32 `idl:"name:dwInVersion" json:"in_version"`
	// pmsgIn: A pointer to the request message.
	In *MessageRemoveServerRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
}

func (o *RemoveDSServerRequest) xxx_ToOp(ctx context.Context, op *xxx_RemoveDSServerOperation) *xxx_RemoveDSServerOperation {
	if op == nil {
		op = &xxx_RemoveDSServerOperation{}
	}
	if o == nil {
		return op
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
	return op
}

func (o *RemoveDSServerRequest) xxx_FromOp(ctx context.Context, op *xxx_RemoveDSServerOperation) {
	if o == nil {
		return
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
}
func (o *RemoveDSServerRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *RemoveDSServerRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemoveDSServerOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// RemoveDSServerResponse structure represents the IDL_DRSRemoveDsServer operation response
type RemoveDSServerResponse struct {
	// pdwOutVersion: A pointer to the version of the response message. The value must be
	// 1 because that is the only version supported.
	OutVersion uint32 `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	// pmsgOut: A pointer to the response message.
	Out *MessageRemoveServerReply `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	// Return: The IDL_DRSRemoveDsServer return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *RemoveDSServerResponse) xxx_ToOp(ctx context.Context, op *xxx_RemoveDSServerOperation) *xxx_RemoveDSServerOperation {
	if op == nil {
		op = &xxx_RemoveDSServerOperation{}
	}
	if o == nil {
		return op
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
	return op
}

func (o *RemoveDSServerResponse) xxx_FromOp(ctx context.Context, op *xxx_RemoveDSServerOperation) {
	if o == nil {
		return
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
}
func (o *RemoveDSServerResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *RemoveDSServerResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemoveDSServerOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_RemoveDSDomainOperation structure represents the IDL_DRSRemoveDsDomain operation
type xxx_RemoveDSDomainOperation struct {
	Handle     *Handle                       `idl:"name:hDrs;pointer:ref" json:"handle"`
	InVersion  uint32                        `idl:"name:dwInVersion" json:"in_version"`
	In         *MessageRemoveDSDomainRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
	OutVersion uint32                        `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	Out        *MessageRemoveDSDomainReply   `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	Return     uint32                        `idl:"name:Return" json:"return"`
}

func (o *xxx_RemoveDSDomainOperation) OpNum() int { return 15 }

func (o *xxx_RemoveDSDomainOperation) OpName() string { return "/drsuapi/v4/IDL_DRSRemoveDsDomain" }

func (o *xxx_RemoveDSDomainOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveDSDomainOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_RMDMNREQ}(union))
	{
		_swIn := uint32(o.InVersion)
		if o.In != nil {
			if err := o.In.MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		} else {
			if err := (&MessageRemoveDSDomainRequest{}).MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveDSDomainOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &Handle{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_RMDMNREQ}(union))
	{
		if o.In == nil {
			o.In = &MessageRemoveDSDomainRequest{}
		}
		_swIn := uint32(o.InVersion)
		if err := o.In.UnmarshalUnionNDR(ctx, w, _swIn); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveDSDomainOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveDSDomainOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_RMDMNREPLY}(union))
	{
		_swOut := uint32(o.OutVersion)
		if o.Out != nil {
			if err := o.Out.MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		} else {
			if err := (&MessageRemoveDSDomainReply{}).MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveDSDomainOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_RMDMNREPLY}(union))
	{
		if o.Out == nil {
			o.Out = &MessageRemoveDSDomainReply{}
		}
		_swOut := uint32(o.OutVersion)
		if err := o.Out.UnmarshalUnionNDR(ctx, w, _swOut); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// RemoveDSDomainRequest structure represents the IDL_DRSRemoveDsDomain operation request
type RemoveDSDomainRequest struct {
	// hDrs: The RPC context handle returned by the IDL_DRSBind method.
	Handle *Handle `idl:"name:hDrs;pointer:ref" json:"handle"`
	// dwInVersion: The version of the request message. This must be set to 1, because this
	// is the only version supported.
	InVersion uint32 `idl:"name:dwInVersion" json:"in_version"`
	// pmsgIn: A pointer to the request message.
	In *MessageRemoveDSDomainRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
}

func (o *RemoveDSDomainRequest) xxx_ToOp(ctx context.Context, op *xxx_RemoveDSDomainOperation) *xxx_RemoveDSDomainOperation {
	if op == nil {
		op = &xxx_RemoveDSDomainOperation{}
	}
	if o == nil {
		return op
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
	return op
}

func (o *RemoveDSDomainRequest) xxx_FromOp(ctx context.Context, op *xxx_RemoveDSDomainOperation) {
	if o == nil {
		return
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
}
func (o *RemoveDSDomainRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *RemoveDSDomainRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemoveDSDomainOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// RemoveDSDomainResponse structure represents the IDL_DRSRemoveDsDomain operation response
type RemoveDSDomainResponse struct {
	// pdwOutVersion: A pointer to the version of the response message. The value must be
	// 1 because that is the only version supported.
	OutVersion uint32 `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	// pmsgOut: A pointer to the response message.
	Out *MessageRemoveDSDomainReply `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	// Return: The IDL_DRSRemoveDsDomain return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *RemoveDSDomainResponse) xxx_ToOp(ctx context.Context, op *xxx_RemoveDSDomainOperation) *xxx_RemoveDSDomainOperation {
	if op == nil {
		op = &xxx_RemoveDSDomainOperation{}
	}
	if o == nil {
		return op
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
	return op
}

func (o *RemoveDSDomainResponse) xxx_FromOp(ctx context.Context, op *xxx_RemoveDSDomainOperation) {
	if o == nil {
		return
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
}
func (o *RemoveDSDomainResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *RemoveDSDomainResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemoveDSDomainOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_DomainControllerInfoOperation structure represents the IDL_DRSDomainControllerInfo operation
type xxx_DomainControllerInfoOperation struct {
	Handle     *Handle               `idl:"name:hDrs;pointer:ref" json:"handle"`
	InVersion  uint32                `idl:"name:dwInVersion" json:"in_version"`
	In         *MessageDCInfoRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
	OutVersion uint32                `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	Out        *MessageDCInfoReply   `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	Return     uint32                `idl:"name:Return" json:"return"`
}

func (o *xxx_DomainControllerInfoOperation) OpNum() int { return 16 }

func (o *xxx_DomainControllerInfoOperation) OpName() string {
	return "/drsuapi/v4/IDL_DRSDomainControllerInfo"
}

func (o *xxx_DomainControllerInfoOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DomainControllerInfoOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_DCINFOREQ}(union))
	{
		_swIn := uint32(o.InVersion)
		if o.In != nil {
			if err := o.In.MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		} else {
			if err := (&MessageDCInfoRequest{}).MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DomainControllerInfoOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &Handle{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_DCINFOREQ}(union))
	{
		if o.In == nil {
			o.In = &MessageDCInfoRequest{}
		}
		_swIn := uint32(o.InVersion)
		if err := o.In.UnmarshalUnionNDR(ctx, w, _swIn); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DomainControllerInfoOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DomainControllerInfoOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_DCINFOREPLY}(union))
	{
		_swOut := uint32(o.OutVersion)
		if o.Out != nil {
			if err := o.Out.MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		} else {
			if err := (&MessageDCInfoReply{}).MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DomainControllerInfoOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_DCINFOREPLY}(union))
	{
		if o.Out == nil {
			o.Out = &MessageDCInfoReply{}
		}
		_swOut := uint32(o.OutVersion)
		if err := o.Out.UnmarshalUnionNDR(ctx, w, _swOut); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// DomainControllerInfoRequest structure represents the IDL_DRSDomainControllerInfo operation request
type DomainControllerInfoRequest struct {
	// hDrs: RPC context handle returned by the IDL_DRSBind method.
	Handle *Handle `idl:"name:hDrs;pointer:ref" json:"handle"`
	// dwInVersion: Version of the request message.
	InVersion uint32 `idl:"name:dwInVersion" json:"in_version"`
	// pmsgIn: Pointer to the request message.
	In *MessageDCInfoRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
}

func (o *DomainControllerInfoRequest) xxx_ToOp(ctx context.Context, op *xxx_DomainControllerInfoOperation) *xxx_DomainControllerInfoOperation {
	if op == nil {
		op = &xxx_DomainControllerInfoOperation{}
	}
	if o == nil {
		return op
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
	return op
}

func (o *DomainControllerInfoRequest) xxx_FromOp(ctx context.Context, op *xxx_DomainControllerInfoOperation) {
	if o == nil {
		return
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
}
func (o *DomainControllerInfoRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *DomainControllerInfoRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DomainControllerInfoOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// DomainControllerInfoResponse structure represents the IDL_DRSDomainControllerInfo operation response
type DomainControllerInfoResponse struct {
	// pdwOutVersion: Pointer to the version of the response message.
	OutVersion uint32 `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	// pmsgOut: Pointer to the response message.
	Out *MessageDCInfoReply `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	// Return: The IDL_DRSDomainControllerInfo return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *DomainControllerInfoResponse) xxx_ToOp(ctx context.Context, op *xxx_DomainControllerInfoOperation) *xxx_DomainControllerInfoOperation {
	if op == nil {
		op = &xxx_DomainControllerInfoOperation{}
	}
	if o == nil {
		return op
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
	return op
}

func (o *DomainControllerInfoResponse) xxx_FromOp(ctx context.Context, op *xxx_DomainControllerInfoOperation) {
	if o == nil {
		return
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
}
func (o *DomainControllerInfoResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *DomainControllerInfoResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DomainControllerInfoOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddEntryOperation structure represents the IDL_DRSAddEntry operation
type xxx_AddEntryOperation struct {
	Handle     *Handle                 `idl:"name:hDrs;pointer:ref" json:"handle"`
	InVersion  uint32                  `idl:"name:dwInVersion" json:"in_version"`
	In         *MessageAddEntryRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
	OutVersion uint32                  `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	Out        *MessageAddEntryReply   `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	Return     uint32                  `idl:"name:Return" json:"return"`
}

func (o *xxx_AddEntryOperation) OpNum() int { return 17 }

func (o *xxx_AddEntryOperation) OpName() string { return "/drsuapi/v4/IDL_DRSAddEntry" }

func (o *xxx_AddEntryOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddEntryOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_ADDENTRYREQ}(union))
	{
		_swIn := uint32(o.InVersion)
		if o.In != nil {
			if err := o.In.MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		} else {
			if err := (&MessageAddEntryRequest{}).MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddEntryOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &Handle{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_ADDENTRYREQ}(union))
	{
		if o.In == nil {
			o.In = &MessageAddEntryRequest{}
		}
		_swIn := uint32(o.InVersion)
		if err := o.In.UnmarshalUnionNDR(ctx, w, _swIn); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddEntryOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddEntryOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_ADDENTRYREPLY}(union))
	{
		_swOut := uint32(o.OutVersion)
		if o.Out != nil {
			if err := o.Out.MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		} else {
			if err := (&MessageAddEntryReply{}).MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddEntryOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_ADDENTRYREPLY}(union))
	{
		if o.Out == nil {
			o.Out = &MessageAddEntryReply{}
		}
		_swOut := uint32(o.OutVersion)
		if err := o.Out.UnmarshalUnionNDR(ctx, w, _swOut); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddEntryRequest structure represents the IDL_DRSAddEntry operation request
type AddEntryRequest struct {
	// hDrs: The RPC context handle that is returned by the IDL_DRSBind method.
	Handle *Handle `idl:"name:hDrs;pointer:ref" json:"handle"`
	// dwInVersion: The version of the request message.
	InVersion uint32 `idl:"name:dwInVersion" json:"in_version"`
	// pmsgIn: A pointer to the request message.
	In *MessageAddEntryRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
}

func (o *AddEntryRequest) xxx_ToOp(ctx context.Context, op *xxx_AddEntryOperation) *xxx_AddEntryOperation {
	if op == nil {
		op = &xxx_AddEntryOperation{}
	}
	if o == nil {
		return op
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
	return op
}

func (o *AddEntryRequest) xxx_FromOp(ctx context.Context, op *xxx_AddEntryOperation) {
	if o == nil {
		return
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
}
func (o *AddEntryRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *AddEntryRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddEntryOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddEntryResponse structure represents the IDL_DRSAddEntry operation response
type AddEntryResponse struct {
	// pdwOutVersion: A pointer to the version of the response message.
	OutVersion uint32 `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	// pmsgOut: A pointer to the response message.
	Out *MessageAddEntryReply `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	// Return: The IDL_DRSAddEntry return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddEntryResponse) xxx_ToOp(ctx context.Context, op *xxx_AddEntryOperation) *xxx_AddEntryOperation {
	if op == nil {
		op = &xxx_AddEntryOperation{}
	}
	if o == nil {
		return op
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
	return op
}

func (o *AddEntryResponse) xxx_FromOp(ctx context.Context, op *xxx_AddEntryOperation) {
	if o == nil {
		return
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
}
func (o *AddEntryResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *AddEntryResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddEntryOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ExecuteKCCOperation structure represents the IDL_DRSExecuteKCC operation
type xxx_ExecuteKCCOperation struct {
	Handle    *Handle            `idl:"name:hDrs;pointer:ref" json:"handle"`
	InVersion uint32             `idl:"name:dwInVersion" json:"in_version"`
	In        *MessageKCCExecute `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
	Return    uint32             `idl:"name:Return" json:"return"`
}

func (o *xxx_ExecuteKCCOperation) OpNum() int { return 18 }

func (o *xxx_ExecuteKCCOperation) OpName() string { return "/drsuapi/v4/IDL_DRSExecuteKCC" }

func (o *xxx_ExecuteKCCOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ExecuteKCCOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_KCC_EXECUTE}(union))
	{
		_swIn := uint32(o.InVersion)
		if o.In != nil {
			if err := o.In.MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		} else {
			if err := (&MessageKCCExecute{}).MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_ExecuteKCCOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &Handle{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_KCC_EXECUTE}(union))
	{
		if o.In == nil {
			o.In = &MessageKCCExecute{}
		}
		_swIn := uint32(o.InVersion)
		if err := o.In.UnmarshalUnionNDR(ctx, w, _swIn); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ExecuteKCCOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ExecuteKCCOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ExecuteKCCOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ExecuteKCCRequest structure represents the IDL_DRSExecuteKCC operation request
type ExecuteKCCRequest struct {
	// hDrs: The RPC context handle returned by the IDL_DRSBind method.
	Handle *Handle `idl:"name:hDrs;pointer:ref" json:"handle"`
	// dwInVersion: The version of the request message.
	InVersion uint32 `idl:"name:dwInVersion" json:"in_version"`
	// pmsgIn: A pointer to the request message.
	In *MessageKCCExecute `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
}

func (o *ExecuteKCCRequest) xxx_ToOp(ctx context.Context, op *xxx_ExecuteKCCOperation) *xxx_ExecuteKCCOperation {
	if op == nil {
		op = &xxx_ExecuteKCCOperation{}
	}
	if o == nil {
		return op
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
	return op
}

func (o *ExecuteKCCRequest) xxx_FromOp(ctx context.Context, op *xxx_ExecuteKCCOperation) {
	if o == nil {
		return
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
}
func (o *ExecuteKCCRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *ExecuteKCCRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ExecuteKCCOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ExecuteKCCResponse structure represents the IDL_DRSExecuteKCC operation response
type ExecuteKCCResponse struct {
	// Return: The IDL_DRSExecuteKCC return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ExecuteKCCResponse) xxx_ToOp(ctx context.Context, op *xxx_ExecuteKCCOperation) *xxx_ExecuteKCCOperation {
	if op == nil {
		op = &xxx_ExecuteKCCOperation{}
	}
	if o == nil {
		return op
	}
	o.Return = op.Return
	return op
}

func (o *ExecuteKCCResponse) xxx_FromOp(ctx context.Context, op *xxx_ExecuteKCCOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *ExecuteKCCResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *ExecuteKCCResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ExecuteKCCOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetReplicationInfoOperation structure represents the IDL_DRSGetReplInfo operation
type xxx_GetReplicationInfoOperation struct {
	Handle     *Handle                           `idl:"name:hDrs;pointer:ref" json:"handle"`
	InVersion  uint32                            `idl:"name:dwInVersion" json:"in_version"`
	In         *MessageGetReplicationInfoRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
	OutVersion uint32                            `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	Out        *MessageGetReplicationInfoReply   `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	Return     uint32                            `idl:"name:Return" json:"return"`
}

func (o *xxx_GetReplicationInfoOperation) OpNum() int { return 19 }

func (o *xxx_GetReplicationInfoOperation) OpName() string { return "/drsuapi/v4/IDL_DRSGetReplInfo" }

func (o *xxx_GetReplicationInfoOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetReplicationInfoOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_GETREPLINFO_REQ}(union))
	{
		_swIn := uint32(o.InVersion)
		if o.In != nil {
			if err := o.In.MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		} else {
			if err := (&MessageGetReplicationInfoRequest{}).MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetReplicationInfoOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &Handle{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_GETREPLINFO_REQ}(union))
	{
		if o.In == nil {
			o.In = &MessageGetReplicationInfoRequest{}
		}
		_swIn := uint32(o.InVersion)
		if err := o.In.UnmarshalUnionNDR(ctx, w, _swIn); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetReplicationInfoOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetReplicationInfoOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_GETREPLINFO_REPLY}(union))
	{
		_swOut := uint32(o.OutVersion)
		if o.Out != nil {
			if err := o.Out.MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		} else {
			if err := (&MessageGetReplicationInfoReply{}).MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetReplicationInfoOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_GETREPLINFO_REPLY}(union))
	{
		if o.Out == nil {
			o.Out = &MessageGetReplicationInfoReply{}
		}
		_swOut := uint32(o.OutVersion)
		if err := o.Out.UnmarshalUnionNDR(ctx, w, _swOut); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetReplicationInfoRequest structure represents the IDL_DRSGetReplInfo operation request
type GetReplicationInfoRequest struct {
	// hDrs: The RPC context handle returned by the IDL_DRSBind method.
	Handle *Handle `idl:"name:hDrs;pointer:ref" json:"handle"`
	// dwInVersion: The version of the request message.
	InVersion uint32 `idl:"name:dwInVersion" json:"in_version"`
	// pmsgIn: A pointer to the request message.
	In *MessageGetReplicationInfoRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
}

func (o *GetReplicationInfoRequest) xxx_ToOp(ctx context.Context, op *xxx_GetReplicationInfoOperation) *xxx_GetReplicationInfoOperation {
	if op == nil {
		op = &xxx_GetReplicationInfoOperation{}
	}
	if o == nil {
		return op
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
	return op
}

func (o *GetReplicationInfoRequest) xxx_FromOp(ctx context.Context, op *xxx_GetReplicationInfoOperation) {
	if o == nil {
		return
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
}
func (o *GetReplicationInfoRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetReplicationInfoRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetReplicationInfoOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetReplicationInfoResponse structure represents the IDL_DRSGetReplInfo operation response
type GetReplicationInfoResponse struct {
	// pdwOutVersion: A pointer to the version of the response message.
	OutVersion uint32 `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	// pmsgOut: A pointer to the response message.
	Out *MessageGetReplicationInfoReply `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	// Return: The IDL_DRSGetReplInfo return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetReplicationInfoResponse) xxx_ToOp(ctx context.Context, op *xxx_GetReplicationInfoOperation) *xxx_GetReplicationInfoOperation {
	if op == nil {
		op = &xxx_GetReplicationInfoOperation{}
	}
	if o == nil {
		return op
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
	return op
}

func (o *GetReplicationInfoResponse) xxx_FromOp(ctx context.Context, op *xxx_GetReplicationInfoOperation) {
	if o == nil {
		return
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
}
func (o *GetReplicationInfoResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetReplicationInfoResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetReplicationInfoOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddSIDHistoryOperation structure represents the IDL_DRSAddSidHistory operation
type xxx_AddSIDHistoryOperation struct {
	Handle     *Handle                      `idl:"name:hDrs;pointer:ref" json:"handle"`
	InVersion  uint32                       `idl:"name:dwInVersion" json:"in_version"`
	In         *MessageAddSIDHistoryRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
	OutVersion uint32                       `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	Out        *MessageAddSIDHistoryReply   `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	Return     uint32                       `idl:"name:Return" json:"return"`
}

func (o *xxx_AddSIDHistoryOperation) OpNum() int { return 20 }

func (o *xxx_AddSIDHistoryOperation) OpName() string { return "/drsuapi/v4/IDL_DRSAddSidHistory" }

func (o *xxx_AddSIDHistoryOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddSIDHistoryOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_ADDSIDREQ}(union))
	{
		_swIn := uint32(o.InVersion)
		if o.In != nil {
			if err := o.In.MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		} else {
			if err := (&MessageAddSIDHistoryRequest{}).MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddSIDHistoryOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &Handle{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_ADDSIDREQ}(union))
	{
		if o.In == nil {
			o.In = &MessageAddSIDHistoryRequest{}
		}
		_swIn := uint32(o.InVersion)
		if err := o.In.UnmarshalUnionNDR(ctx, w, _swIn); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddSIDHistoryOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddSIDHistoryOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_ADDSIDREPLY}(union))
	{
		_swOut := uint32(o.OutVersion)
		if o.Out != nil {
			if err := o.Out.MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		} else {
			if err := (&MessageAddSIDHistoryReply{}).MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddSIDHistoryOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_ADDSIDREPLY}(union))
	{
		if o.Out == nil {
			o.Out = &MessageAddSIDHistoryReply{}
		}
		_swOut := uint32(o.OutVersion)
		if err := o.Out.UnmarshalUnionNDR(ctx, w, _swOut); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddSIDHistoryRequest structure represents the IDL_DRSAddSidHistory operation request
type AddSIDHistoryRequest struct {
	// hDrs: RPC context handle returned by the IDL_DRSBind method.
	Handle *Handle `idl:"name:hDrs;pointer:ref" json:"handle"`
	// dwInVersion: Version of the request message. Must be set to 1, because no other version
	// is supported.
	InVersion uint32 `idl:"name:dwInVersion" json:"in_version"`
	// pmsgIn: Pointer to the request message.
	In *MessageAddSIDHistoryRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
}

func (o *AddSIDHistoryRequest) xxx_ToOp(ctx context.Context, op *xxx_AddSIDHistoryOperation) *xxx_AddSIDHistoryOperation {
	if op == nil {
		op = &xxx_AddSIDHistoryOperation{}
	}
	if o == nil {
		return op
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
	return op
}

func (o *AddSIDHistoryRequest) xxx_FromOp(ctx context.Context, op *xxx_AddSIDHistoryOperation) {
	if o == nil {
		return
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
}
func (o *AddSIDHistoryRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *AddSIDHistoryRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddSIDHistoryOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddSIDHistoryResponse structure represents the IDL_DRSAddSidHistory operation response
type AddSIDHistoryResponse struct {
	// pdwOutVersion: Pointer to the version of the response message. The value must be
	// 1, because no other version is supported.
	OutVersion uint32 `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	// pmsgOut: Pointer to the response message.
	Out *MessageAddSIDHistoryReply `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	// Return: The IDL_DRSAddSidHistory return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddSIDHistoryResponse) xxx_ToOp(ctx context.Context, op *xxx_AddSIDHistoryOperation) *xxx_AddSIDHistoryOperation {
	if op == nil {
		op = &xxx_AddSIDHistoryOperation{}
	}
	if o == nil {
		return op
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
	return op
}

func (o *AddSIDHistoryResponse) xxx_FromOp(ctx context.Context, op *xxx_AddSIDHistoryOperation) {
	if o == nil {
		return
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
}
func (o *AddSIDHistoryResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *AddSIDHistoryResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddSIDHistoryOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetMemberships2Operation structure represents the IDL_DRSGetMemberships2 operation
type xxx_GetMemberships2Operation struct {
	Handle     *Handle                        `idl:"name:hDrs;pointer:ref" json:"handle"`
	InVersion  uint32                         `idl:"name:dwInVersion" json:"in_version"`
	In         *MessageGetMemberships2Request `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
	OutVersion uint32                         `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	Out        *MessageGetMemberships2Reply   `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	Return     uint32                         `idl:"name:Return" json:"return"`
}

func (o *xxx_GetMemberships2Operation) OpNum() int { return 21 }

func (o *xxx_GetMemberships2Operation) OpName() string { return "/drsuapi/v4/IDL_DRSGetMemberships2" }

func (o *xxx_GetMemberships2Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMemberships2Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_GETMEMBERSHIPS2_REQ}(union))
	{
		_swIn := uint32(o.InVersion)
		if o.In != nil {
			if err := o.In.MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		} else {
			if err := (&MessageGetMemberships2Request{}).MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMemberships2Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &Handle{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_GETMEMBERSHIPS2_REQ}(union))
	{
		if o.In == nil {
			o.In = &MessageGetMemberships2Request{}
		}
		_swIn := uint32(o.InVersion)
		if err := o.In.UnmarshalUnionNDR(ctx, w, _swIn); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMemberships2Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMemberships2Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_GETMEMBERSHIPS2_REPLY}(union))
	{
		_swOut := uint32(o.OutVersion)
		if o.Out != nil {
			if err := o.Out.MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		} else {
			if err := (&MessageGetMemberships2Reply{}).MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMemberships2Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_GETMEMBERSHIPS2_REPLY}(union))
	{
		if o.Out == nil {
			o.Out = &MessageGetMemberships2Reply{}
		}
		_swOut := uint32(o.OutVersion)
		if err := o.Out.UnmarshalUnionNDR(ctx, w, _swOut); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetMemberships2Request structure represents the IDL_DRSGetMemberships2 operation request
type GetMemberships2Request struct {
	// hDrs: The RPC context handle returned by the IDL_DRSBind method.
	Handle *Handle `idl:"name:hDrs;pointer:ref" json:"handle"`
	// dwInVersion: Version of the request message.
	InVersion uint32 `idl:"name:dwInVersion" json:"in_version"`
	// pmsgIn: Pointer to the request message.
	In *MessageGetMemberships2Request `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
}

func (o *GetMemberships2Request) xxx_ToOp(ctx context.Context, op *xxx_GetMemberships2Operation) *xxx_GetMemberships2Operation {
	if op == nil {
		op = &xxx_GetMemberships2Operation{}
	}
	if o == nil {
		return op
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
	return op
}

func (o *GetMemberships2Request) xxx_FromOp(ctx context.Context, op *xxx_GetMemberships2Operation) {
	if o == nil {
		return
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
}
func (o *GetMemberships2Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetMemberships2Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetMemberships2Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetMemberships2Response structure represents the IDL_DRSGetMemberships2 operation response
type GetMemberships2Response struct {
	// pdwOutVersion: Pointer to the version of the response message.
	OutVersion uint32 `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	// pmsgOut: Pointer to the response message.
	Out *MessageGetMemberships2Reply `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	// Return: The IDL_DRSGetMemberships2 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetMemberships2Response) xxx_ToOp(ctx context.Context, op *xxx_GetMemberships2Operation) *xxx_GetMemberships2Operation {
	if op == nil {
		op = &xxx_GetMemberships2Operation{}
	}
	if o == nil {
		return op
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
	return op
}

func (o *GetMemberships2Response) xxx_FromOp(ctx context.Context, op *xxx_GetMemberships2Operation) {
	if o == nil {
		return
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
}
func (o *GetMemberships2Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetMemberships2Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetMemberships2Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_VerifyObjectsReplicaOperation structure represents the IDL_DRSReplicaVerifyObjects operation
type xxx_VerifyObjectsReplicaOperation struct {
	Handle  *Handle                   `idl:"name:hDrs;pointer:ref" json:"handle"`
	Version uint32                    `idl:"name:dwVersion" json:"version"`
	Verify  *MessageVerifyReplyObject `idl:"name:pmsgVerify;switch_is:dwVersion;pointer:ref" json:"verify"`
	Return  uint32                    `idl:"name:Return" json:"return"`
}

func (o *xxx_VerifyObjectsReplicaOperation) OpNum() int { return 22 }

func (o *xxx_VerifyObjectsReplicaOperation) OpName() string {
	return "/drsuapi/v4/IDL_DRSReplicaVerifyObjects"
}

func (o *xxx_VerifyObjectsReplicaOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_VerifyObjectsReplicaOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Version); err != nil {
			return err
		}
	}
	// pmsgVerify {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_REPVERIFYOBJ}(union))
	{
		_swVerify := uint32(o.Version)
		if o.Verify != nil {
			if err := o.Verify.MarshalUnionNDR(ctx, w, _swVerify); err != nil {
				return err
			}
		} else {
			if err := (&MessageVerifyReplyObject{}).MarshalUnionNDR(ctx, w, _swVerify); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_VerifyObjectsReplicaOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &Handle{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Version); err != nil {
			return err
		}
	}
	// pmsgVerify {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_REPVERIFYOBJ}(union))
	{
		if o.Verify == nil {
			o.Verify = &MessageVerifyReplyObject{}
		}
		_swVerify := uint32(o.Version)
		if err := o.Verify.UnmarshalUnionNDR(ctx, w, _swVerify); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_VerifyObjectsReplicaOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_VerifyObjectsReplicaOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_VerifyObjectsReplicaOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// VerifyObjectsReplicaRequest structure represents the IDL_DRSReplicaVerifyObjects operation request
type VerifyObjectsReplicaRequest struct {
	// hDrs: The RPC context handle returned by the IDL_DRSBind method.
	Handle *Handle `idl:"name:hDrs;pointer:ref" json:"handle"`
	// dwVersion: The version of the request message.
	Version uint32 `idl:"name:dwVersion" json:"version"`
	// pmsgVerify: A pointer to the request message.
	Verify *MessageVerifyReplyObject `idl:"name:pmsgVerify;switch_is:dwVersion;pointer:ref" json:"verify"`
}

func (o *VerifyObjectsReplicaRequest) xxx_ToOp(ctx context.Context, op *xxx_VerifyObjectsReplicaOperation) *xxx_VerifyObjectsReplicaOperation {
	if op == nil {
		op = &xxx_VerifyObjectsReplicaOperation{}
	}
	if o == nil {
		return op
	}
	o.Handle = op.Handle
	o.Version = op.Version
	o.Verify = op.Verify
	return op
}

func (o *VerifyObjectsReplicaRequest) xxx_FromOp(ctx context.Context, op *xxx_VerifyObjectsReplicaOperation) {
	if o == nil {
		return
	}
	o.Handle = op.Handle
	o.Version = op.Version
	o.Verify = op.Verify
}
func (o *VerifyObjectsReplicaRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *VerifyObjectsReplicaRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_VerifyObjectsReplicaOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// VerifyObjectsReplicaResponse structure represents the IDL_DRSReplicaVerifyObjects operation response
type VerifyObjectsReplicaResponse struct {
	// Return: The IDL_DRSReplicaVerifyObjects return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *VerifyObjectsReplicaResponse) xxx_ToOp(ctx context.Context, op *xxx_VerifyObjectsReplicaOperation) *xxx_VerifyObjectsReplicaOperation {
	if op == nil {
		op = &xxx_VerifyObjectsReplicaOperation{}
	}
	if o == nil {
		return op
	}
	o.Return = op.Return
	return op
}

func (o *VerifyObjectsReplicaResponse) xxx_FromOp(ctx context.Context, op *xxx_VerifyObjectsReplicaOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *VerifyObjectsReplicaResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *VerifyObjectsReplicaResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_VerifyObjectsReplicaOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetObjectExistenceOperation structure represents the IDL_DRSGetObjectExistence operation
type xxx_GetObjectExistenceOperation struct {
	Handle     *Handle              `idl:"name:hDrs;pointer:ref" json:"handle"`
	InVersion  uint32               `idl:"name:dwInVersion" json:"in_version"`
	In         *MessageExistRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
	OutVersion uint32               `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	Out        *MessageExistReply   `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	Return     uint32               `idl:"name:Return" json:"return"`
}

func (o *xxx_GetObjectExistenceOperation) OpNum() int { return 23 }

func (o *xxx_GetObjectExistenceOperation) OpName() string {
	return "/drsuapi/v4/IDL_DRSGetObjectExistence"
}

func (o *xxx_GetObjectExistenceOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetObjectExistenceOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_EXISTREQ}(union))
	{
		_swIn := uint32(o.InVersion)
		if o.In != nil {
			if err := o.In.MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		} else {
			if err := (&MessageExistRequest{}).MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetObjectExistenceOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &Handle{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_EXISTREQ}(union))
	{
		if o.In == nil {
			o.In = &MessageExistRequest{}
		}
		_swIn := uint32(o.InVersion)
		if err := o.In.UnmarshalUnionNDR(ctx, w, _swIn); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetObjectExistenceOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetObjectExistenceOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_EXISTREPLY}(union))
	{
		_swOut := uint32(o.OutVersion)
		if o.Out != nil {
			if err := o.Out.MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		} else {
			if err := (&MessageExistReply{}).MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetObjectExistenceOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_EXISTREPLY}(union))
	{
		if o.Out == nil {
			o.Out = &MessageExistReply{}
		}
		_swOut := uint32(o.OutVersion)
		if err := o.Out.UnmarshalUnionNDR(ctx, w, _swOut); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetObjectExistenceRequest structure represents the IDL_DRSGetObjectExistence operation request
type GetObjectExistenceRequest struct {
	// hDrs: The RPC context handle returned by the IDL_DRSBind method.
	Handle *Handle `idl:"name:hDrs;pointer:ref" json:"handle"`
	// dwInVersion: The version of the request message.
	InVersion uint32 `idl:"name:dwInVersion" json:"in_version"`
	// pmsgIn: A pointer to the request message.
	In *MessageExistRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
}

func (o *GetObjectExistenceRequest) xxx_ToOp(ctx context.Context, op *xxx_GetObjectExistenceOperation) *xxx_GetObjectExistenceOperation {
	if op == nil {
		op = &xxx_GetObjectExistenceOperation{}
	}
	if o == nil {
		return op
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
	return op
}

func (o *GetObjectExistenceRequest) xxx_FromOp(ctx context.Context, op *xxx_GetObjectExistenceOperation) {
	if o == nil {
		return
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
}
func (o *GetObjectExistenceRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetObjectExistenceRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetObjectExistenceOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetObjectExistenceResponse structure represents the IDL_DRSGetObjectExistence operation response
type GetObjectExistenceResponse struct {
	// pdwOutVersion: A pointer to the version of the response message.
	OutVersion uint32 `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	// pmsgOut: A pointer to the response message.
	Out *MessageExistReply `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	// Return: The IDL_DRSGetObjectExistence return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetObjectExistenceResponse) xxx_ToOp(ctx context.Context, op *xxx_GetObjectExistenceOperation) *xxx_GetObjectExistenceOperation {
	if op == nil {
		op = &xxx_GetObjectExistenceOperation{}
	}
	if o == nil {
		return op
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
	return op
}

func (o *GetObjectExistenceResponse) xxx_FromOp(ctx context.Context, op *xxx_GetObjectExistenceOperation) {
	if o == nil {
		return
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
}
func (o *GetObjectExistenceResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetObjectExistenceResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetObjectExistenceOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_QuerySitesByCostOperation structure represents the IDL_DRSQuerySitesByCost operation
type xxx_QuerySitesByCostOperation struct {
	Handle     *Handle                   `idl:"name:hDrs;pointer:ref" json:"handle"`
	InVersion  uint32                    `idl:"name:dwInVersion" json:"in_version"`
	In         *MessageQuerySitesRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
	OutVersion uint32                    `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	Out        *MessageQuerySitesReply   `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	Return     uint32                    `idl:"name:Return" json:"return"`
}

func (o *xxx_QuerySitesByCostOperation) OpNum() int { return 24 }

func (o *xxx_QuerySitesByCostOperation) OpName() string { return "/drsuapi/v4/IDL_DRSQuerySitesByCost" }

func (o *xxx_QuerySitesByCostOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QuerySitesByCostOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_QUERYSITESREQ}(union))
	{
		_swIn := uint32(o.InVersion)
		if o.In != nil {
			if err := o.In.MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		} else {
			if err := (&MessageQuerySitesRequest{}).MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QuerySitesByCostOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &Handle{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_QUERYSITESREQ}(union))
	{
		if o.In == nil {
			o.In = &MessageQuerySitesRequest{}
		}
		_swIn := uint32(o.InVersion)
		if err := o.In.UnmarshalUnionNDR(ctx, w, _swIn); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QuerySitesByCostOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QuerySitesByCostOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_QUERYSITESREPLY}(union))
	{
		_swOut := uint32(o.OutVersion)
		if o.Out != nil {
			if err := o.Out.MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		} else {
			if err := (&MessageQuerySitesReply{}).MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QuerySitesByCostOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_QUERYSITESREPLY}(union))
	{
		if o.Out == nil {
			o.Out = &MessageQuerySitesReply{}
		}
		_swOut := uint32(o.OutVersion)
		if err := o.Out.UnmarshalUnionNDR(ctx, w, _swOut); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// QuerySitesByCostRequest structure represents the IDL_DRSQuerySitesByCost operation request
type QuerySitesByCostRequest struct {
	// hDrs: The RPC context handle returned by the IDL_DRSBind method.
	Handle *Handle `idl:"name:hDrs;pointer:ref" json:"handle"`
	// dwInVersion: The version of the request message.
	InVersion uint32 `idl:"name:dwInVersion" json:"in_version"`
	// pmsgIn: A pointer to the request message.
	In *MessageQuerySitesRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
}

func (o *QuerySitesByCostRequest) xxx_ToOp(ctx context.Context, op *xxx_QuerySitesByCostOperation) *xxx_QuerySitesByCostOperation {
	if op == nil {
		op = &xxx_QuerySitesByCostOperation{}
	}
	if o == nil {
		return op
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
	return op
}

func (o *QuerySitesByCostRequest) xxx_FromOp(ctx context.Context, op *xxx_QuerySitesByCostOperation) {
	if o == nil {
		return
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
}
func (o *QuerySitesByCostRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *QuerySitesByCostRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QuerySitesByCostOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// QuerySitesByCostResponse structure represents the IDL_DRSQuerySitesByCost operation response
type QuerySitesByCostResponse struct {
	// pdwOutVersion: A pointer to the version of the response message.
	OutVersion uint32 `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	// pmsgOut: A pointer to the response message.
	Out *MessageQuerySitesReply `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	// Return: The IDL_DRSQuerySitesByCost return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *QuerySitesByCostResponse) xxx_ToOp(ctx context.Context, op *xxx_QuerySitesByCostOperation) *xxx_QuerySitesByCostOperation {
	if op == nil {
		op = &xxx_QuerySitesByCostOperation{}
	}
	if o == nil {
		return op
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
	return op
}

func (o *QuerySitesByCostResponse) xxx_FromOp(ctx context.Context, op *xxx_QuerySitesByCostOperation) {
	if o == nil {
		return
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
}
func (o *QuerySitesByCostResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *QuerySitesByCostResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QuerySitesByCostOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_InitDemotionOperation structure represents the IDL_DRSInitDemotion operation
type xxx_InitDemotionOperation struct {
	Handle     *Handle                     `idl:"name:hDrs;pointer:ref" json:"handle"`
	InVersion  uint32                      `idl:"name:dwInVersion" json:"in_version"`
	In         *MessageInitDemotionRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
	OutVersion uint32                      `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	Out        *MessageInitDemotionReply   `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	Return     uint32                      `idl:"name:Return" json:"return"`
}

func (o *xxx_InitDemotionOperation) OpNum() int { return 25 }

func (o *xxx_InitDemotionOperation) OpName() string { return "/drsuapi/v4/IDL_DRSInitDemotion" }

func (o *xxx_InitDemotionOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_InitDemotionOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_INIT_DEMOTIONREQ}(union))
	{
		_swIn := uint32(o.InVersion)
		if o.In != nil {
			if err := o.In.MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		} else {
			if err := (&MessageInitDemotionRequest{}).MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_InitDemotionOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &Handle{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_INIT_DEMOTIONREQ}(union))
	{
		if o.In == nil {
			o.In = &MessageInitDemotionRequest{}
		}
		_swIn := uint32(o.InVersion)
		if err := o.In.UnmarshalUnionNDR(ctx, w, _swIn); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_InitDemotionOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_InitDemotionOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_INIT_DEMOTIONREPLY}(union))
	{
		_swOut := uint32(o.OutVersion)
		if o.Out != nil {
			if err := o.Out.MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		} else {
			if err := (&MessageInitDemotionReply{}).MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_InitDemotionOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_INIT_DEMOTIONREPLY}(union))
	{
		if o.Out == nil {
			o.Out = &MessageInitDemotionReply{}
		}
		_swOut := uint32(o.OutVersion)
		if err := o.Out.UnmarshalUnionNDR(ctx, w, _swOut); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// InitDemotionRequest structure represents the IDL_DRSInitDemotion operation request
type InitDemotionRequest struct {
	// hDrs: The RPC context handle returned by the IDL_DRSBind method.
	Handle *Handle `idl:"name:hDrs;pointer:ref" json:"handle"`
	// dwInVersion: The version of the request message.
	InVersion uint32 `idl:"name:dwInVersion" json:"in_version"`
	// pmsgIn: A pointer to the request message.
	In *MessageInitDemotionRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
}

func (o *InitDemotionRequest) xxx_ToOp(ctx context.Context, op *xxx_InitDemotionOperation) *xxx_InitDemotionOperation {
	if op == nil {
		op = &xxx_InitDemotionOperation{}
	}
	if o == nil {
		return op
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
	return op
}

func (o *InitDemotionRequest) xxx_FromOp(ctx context.Context, op *xxx_InitDemotionOperation) {
	if o == nil {
		return
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
}
func (o *InitDemotionRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *InitDemotionRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_InitDemotionOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// InitDemotionResponse structure represents the IDL_DRSInitDemotion operation response
type InitDemotionResponse struct {
	// pdwOutVersion: A pointer to the version of the response message.
	OutVersion uint32 `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	// pmsgOut: A pointer to the response message.
	Out *MessageInitDemotionReply `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	// Return: The IDL_DRSInitDemotion return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *InitDemotionResponse) xxx_ToOp(ctx context.Context, op *xxx_InitDemotionOperation) *xxx_InitDemotionOperation {
	if op == nil {
		op = &xxx_InitDemotionOperation{}
	}
	if o == nil {
		return op
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
	return op
}

func (o *InitDemotionResponse) xxx_FromOp(ctx context.Context, op *xxx_InitDemotionOperation) {
	if o == nil {
		return
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
}
func (o *InitDemotionResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *InitDemotionResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_InitDemotionOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_DemotionReplicaOperation structure represents the IDL_DRSReplicaDemotion operation
type xxx_DemotionReplicaOperation struct {
	Handle     *Handle                        `idl:"name:hDrs;pointer:ref" json:"handle"`
	InVersion  uint32                         `idl:"name:dwInVersion" json:"in_version"`
	In         *MessageReplicaDemotionRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
	OutVersion uint32                         `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	Out        *MessageReplicaDemotionReply   `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	Return     uint32                         `idl:"name:Return" json:"return"`
}

func (o *xxx_DemotionReplicaOperation) OpNum() int { return 26 }

func (o *xxx_DemotionReplicaOperation) OpName() string { return "/drsuapi/v4/IDL_DRSReplicaDemotion" }

func (o *xxx_DemotionReplicaOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DemotionReplicaOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_REPLICA_DEMOTIONREQ}(union))
	{
		_swIn := uint32(o.InVersion)
		if o.In != nil {
			if err := o.In.MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		} else {
			if err := (&MessageReplicaDemotionRequest{}).MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DemotionReplicaOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &Handle{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_REPLICA_DEMOTIONREQ}(union))
	{
		if o.In == nil {
			o.In = &MessageReplicaDemotionRequest{}
		}
		_swIn := uint32(o.InVersion)
		if err := o.In.UnmarshalUnionNDR(ctx, w, _swIn); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DemotionReplicaOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DemotionReplicaOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_REPLICA_DEMOTIONREPLY}(union))
	{
		_swOut := uint32(o.OutVersion)
		if o.Out != nil {
			if err := o.Out.MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		} else {
			if err := (&MessageReplicaDemotionReply{}).MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DemotionReplicaOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_REPLICA_DEMOTIONREPLY}(union))
	{
		if o.Out == nil {
			o.Out = &MessageReplicaDemotionReply{}
		}
		_swOut := uint32(o.OutVersion)
		if err := o.Out.UnmarshalUnionNDR(ctx, w, _swOut); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// DemotionReplicaRequest structure represents the IDL_DRSReplicaDemotion operation request
type DemotionReplicaRequest struct {
	// hDrs: The RPC context handle returned by the IDL_DRSBind method.
	Handle *Handle `idl:"name:hDrs;pointer:ref" json:"handle"`
	// dwInVersion: The version of the request message.
	InVersion uint32 `idl:"name:dwInVersion" json:"in_version"`
	// pmsgIn: A pointer to the request message.
	In *MessageReplicaDemotionRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
}

func (o *DemotionReplicaRequest) xxx_ToOp(ctx context.Context, op *xxx_DemotionReplicaOperation) *xxx_DemotionReplicaOperation {
	if op == nil {
		op = &xxx_DemotionReplicaOperation{}
	}
	if o == nil {
		return op
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
	return op
}

func (o *DemotionReplicaRequest) xxx_FromOp(ctx context.Context, op *xxx_DemotionReplicaOperation) {
	if o == nil {
		return
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
}
func (o *DemotionReplicaRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *DemotionReplicaRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DemotionReplicaOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// DemotionReplicaResponse structure represents the IDL_DRSReplicaDemotion operation response
type DemotionReplicaResponse struct {
	// pdwOutVersion: A pointer to the version of the response message.
	OutVersion uint32 `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	// pmsgOut: A pointer to the response message.
	Out *MessageReplicaDemotionReply `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	// Return: The IDL_DRSReplicaDemotion return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *DemotionReplicaResponse) xxx_ToOp(ctx context.Context, op *xxx_DemotionReplicaOperation) *xxx_DemotionReplicaOperation {
	if op == nil {
		op = &xxx_DemotionReplicaOperation{}
	}
	if o == nil {
		return op
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
	return op
}

func (o *DemotionReplicaResponse) xxx_FromOp(ctx context.Context, op *xxx_DemotionReplicaOperation) {
	if o == nil {
		return
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
}
func (o *DemotionReplicaResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *DemotionReplicaResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DemotionReplicaOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_FinishDemotionOperation structure represents the IDL_DRSFinishDemotion operation
type xxx_FinishDemotionOperation struct {
	Handle     *Handle                       `idl:"name:hDrs;pointer:ref" json:"handle"`
	InVersion  uint32                        `idl:"name:dwInVersion" json:"in_version"`
	In         *MessageFinishDemotionRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
	OutVersion uint32                        `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	Out        *MessageFinishDemotionReply   `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	Return     uint32                        `idl:"name:Return" json:"return"`
}

func (o *xxx_FinishDemotionOperation) OpNum() int { return 27 }

func (o *xxx_FinishDemotionOperation) OpName() string { return "/drsuapi/v4/IDL_DRSFinishDemotion" }

func (o *xxx_FinishDemotionOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FinishDemotionOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_FINISH_DEMOTIONREQ}(union))
	{
		_swIn := uint32(o.InVersion)
		if o.In != nil {
			if err := o.In.MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		} else {
			if err := (&MessageFinishDemotionRequest{}).MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FinishDemotionOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &Handle{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_FINISH_DEMOTIONREQ}(union))
	{
		if o.In == nil {
			o.In = &MessageFinishDemotionRequest{}
		}
		_swIn := uint32(o.InVersion)
		if err := o.In.UnmarshalUnionNDR(ctx, w, _swIn); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FinishDemotionOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FinishDemotionOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_FINISH_DEMOTIONREPLY}(union))
	{
		_swOut := uint32(o.OutVersion)
		if o.Out != nil {
			if err := o.Out.MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		} else {
			if err := (&MessageFinishDemotionReply{}).MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FinishDemotionOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_FINISH_DEMOTIONREPLY}(union))
	{
		if o.Out == nil {
			o.Out = &MessageFinishDemotionReply{}
		}
		_swOut := uint32(o.OutVersion)
		if err := o.Out.UnmarshalUnionNDR(ctx, w, _swOut); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// FinishDemotionRequest structure represents the IDL_DRSFinishDemotion operation request
type FinishDemotionRequest struct {
	// hDrs: The RPC context handle returned by the IDL_DRSBind method.
	Handle *Handle `idl:"name:hDrs;pointer:ref" json:"handle"`
	// dwInVersion: The version of the request message.
	InVersion uint32 `idl:"name:dwInVersion" json:"in_version"`
	// pmsgIn: A pointer to the request message.
	In *MessageFinishDemotionRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
}

func (o *FinishDemotionRequest) xxx_ToOp(ctx context.Context, op *xxx_FinishDemotionOperation) *xxx_FinishDemotionOperation {
	if op == nil {
		op = &xxx_FinishDemotionOperation{}
	}
	if o == nil {
		return op
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
	return op
}

func (o *FinishDemotionRequest) xxx_FromOp(ctx context.Context, op *xxx_FinishDemotionOperation) {
	if o == nil {
		return
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
}
func (o *FinishDemotionRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *FinishDemotionRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_FinishDemotionOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// FinishDemotionResponse structure represents the IDL_DRSFinishDemotion operation response
type FinishDemotionResponse struct {
	// pdwOutVersion: A pointer to the version of the response message.
	OutVersion uint32 `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	// pmsgOut: A pointer to the response message.
	Out *MessageFinishDemotionReply `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	// Return: The IDL_DRSFinishDemotion return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *FinishDemotionResponse) xxx_ToOp(ctx context.Context, op *xxx_FinishDemotionOperation) *xxx_FinishDemotionOperation {
	if op == nil {
		op = &xxx_FinishDemotionOperation{}
	}
	if o == nil {
		return op
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
	return op
}

func (o *FinishDemotionResponse) xxx_FromOp(ctx context.Context, op *xxx_FinishDemotionOperation) {
	if o == nil {
		return
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
}
func (o *FinishDemotionResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *FinishDemotionResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_FinishDemotionOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddCloneDCOperation structure represents the IDL_DRSAddCloneDC operation
type xxx_AddCloneDCOperation struct {
	Handle     *Handle                   `idl:"name:hDrs;pointer:ref" json:"handle"`
	InVersion  uint32                    `idl:"name:dwInVersion" json:"in_version"`
	In         *MessageAddCloneDCRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
	OutVersion uint32                    `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	Out        *MessageAddCloneDCReply   `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	Return     uint32                    `idl:"name:Return" json:"return"`
}

func (o *xxx_AddCloneDCOperation) OpNum() int { return 28 }

func (o *xxx_AddCloneDCOperation) OpName() string { return "/drsuapi/v4/IDL_DRSAddCloneDC" }

func (o *xxx_AddCloneDCOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddCloneDCOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_ADDCLONEDCREQ}(union))
	{
		_swIn := uint32(o.InVersion)
		if o.In != nil {
			if err := o.In.MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		} else {
			if err := (&MessageAddCloneDCRequest{}).MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddCloneDCOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &Handle{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_ADDCLONEDCREQ}(union))
	{
		if o.In == nil {
			o.In = &MessageAddCloneDCRequest{}
		}
		_swIn := uint32(o.InVersion)
		if err := o.In.UnmarshalUnionNDR(ctx, w, _swIn); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddCloneDCOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddCloneDCOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_ADDCLONEDCREPLY}(union))
	{
		_swOut := uint32(o.OutVersion)
		if o.Out != nil {
			if err := o.Out.MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		} else {
			if err := (&MessageAddCloneDCReply{}).MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddCloneDCOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_ADDCLONEDCREPLY}(union))
	{
		if o.Out == nil {
			o.Out = &MessageAddCloneDCReply{}
		}
		_swOut := uint32(o.OutVersion)
		if err := o.Out.UnmarshalUnionNDR(ctx, w, _swOut); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddCloneDCRequest structure represents the IDL_DRSAddCloneDC operation request
type AddCloneDCRequest struct {
	// hDrs: The RPC context handle returned by the IDL_DRSBind method.
	Handle *Handle `idl:"name:hDrs;pointer:ref" json:"handle"`
	// dwInVersion: The version of the request message.
	InVersion uint32 `idl:"name:dwInVersion" json:"in_version"`
	// pmsgIn: A pointer to the request message.
	In *MessageAddCloneDCRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
}

func (o *AddCloneDCRequest) xxx_ToOp(ctx context.Context, op *xxx_AddCloneDCOperation) *xxx_AddCloneDCOperation {
	if op == nil {
		op = &xxx_AddCloneDCOperation{}
	}
	if o == nil {
		return op
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
	return op
}

func (o *AddCloneDCRequest) xxx_FromOp(ctx context.Context, op *xxx_AddCloneDCOperation) {
	if o == nil {
		return
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
}
func (o *AddCloneDCRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *AddCloneDCRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddCloneDCOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddCloneDCResponse structure represents the IDL_DRSAddCloneDC operation response
type AddCloneDCResponse struct {
	// pdwOutVersion: A pointer to the version of the response message.
	OutVersion uint32 `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	// pmsgOut: A pointer to the response message.
	Out *MessageAddCloneDCReply `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	// Return: The IDL_DRSAddCloneDC return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddCloneDCResponse) xxx_ToOp(ctx context.Context, op *xxx_AddCloneDCOperation) *xxx_AddCloneDCOperation {
	if op == nil {
		op = &xxx_AddCloneDCOperation{}
	}
	if o == nil {
		return op
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
	return op
}

func (o *AddCloneDCResponse) xxx_FromOp(ctx context.Context, op *xxx_AddCloneDCOperation) {
	if o == nil {
		return
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
}
func (o *AddCloneDCResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *AddCloneDCResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddCloneDCOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_WriteNGCKeyOperation structure represents the IDL_DRSWriteNgcKey operation
type xxx_WriteNGCKeyOperation struct {
	Handle     *Handle                    `idl:"name:hDrs;pointer:ref" json:"handle"`
	InVersion  uint32                     `idl:"name:dwInVersion" json:"in_version"`
	In         *MessageWriteNGCKeyRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
	OutVersion uint32                     `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	Out        *MessageWriteNGCKeyReply   `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	Return     uint32                     `idl:"name:Return" json:"return"`
}

func (o *xxx_WriteNGCKeyOperation) OpNum() int { return 29 }

func (o *xxx_WriteNGCKeyOperation) OpName() string { return "/drsuapi/v4/IDL_DRSWriteNgcKey" }

func (o *xxx_WriteNGCKeyOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_WriteNGCKeyOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_WRITENGCKEYREQ}(union))
	{
		_swIn := uint32(o.InVersion)
		if o.In != nil {
			if err := o.In.MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		} else {
			if err := (&MessageWriteNGCKeyRequest{}).MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_WriteNGCKeyOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &Handle{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_WRITENGCKEYREQ}(union))
	{
		if o.In == nil {
			o.In = &MessageWriteNGCKeyRequest{}
		}
		_swIn := uint32(o.InVersion)
		if err := o.In.UnmarshalUnionNDR(ctx, w, _swIn); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_WriteNGCKeyOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_WriteNGCKeyOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_WRITENGCKEYREPLY}(union))
	{
		_swOut := uint32(o.OutVersion)
		if o.Out != nil {
			if err := o.Out.MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		} else {
			if err := (&MessageWriteNGCKeyReply{}).MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_WriteNGCKeyOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_WRITENGCKEYREPLY}(union))
	{
		if o.Out == nil {
			o.Out = &MessageWriteNGCKeyReply{}
		}
		_swOut := uint32(o.OutVersion)
		if err := o.Out.UnmarshalUnionNDR(ctx, w, _swOut); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// WriteNGCKeyRequest structure represents the IDL_DRSWriteNgcKey operation request
type WriteNGCKeyRequest struct {
	Handle    *Handle                    `idl:"name:hDrs;pointer:ref" json:"handle"`
	InVersion uint32                     `idl:"name:dwInVersion" json:"in_version"`
	In        *MessageWriteNGCKeyRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
}

func (o *WriteNGCKeyRequest) xxx_ToOp(ctx context.Context, op *xxx_WriteNGCKeyOperation) *xxx_WriteNGCKeyOperation {
	if op == nil {
		op = &xxx_WriteNGCKeyOperation{}
	}
	if o == nil {
		return op
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
	return op
}

func (o *WriteNGCKeyRequest) xxx_FromOp(ctx context.Context, op *xxx_WriteNGCKeyOperation) {
	if o == nil {
		return
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
}
func (o *WriteNGCKeyRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *WriteNGCKeyRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_WriteNGCKeyOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// WriteNGCKeyResponse structure represents the IDL_DRSWriteNgcKey operation response
type WriteNGCKeyResponse struct {
	OutVersion uint32                   `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	Out        *MessageWriteNGCKeyReply `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	// Return: The IDL_DRSWriteNgcKey return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *WriteNGCKeyResponse) xxx_ToOp(ctx context.Context, op *xxx_WriteNGCKeyOperation) *xxx_WriteNGCKeyOperation {
	if op == nil {
		op = &xxx_WriteNGCKeyOperation{}
	}
	if o == nil {
		return op
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
	return op
}

func (o *WriteNGCKeyResponse) xxx_FromOp(ctx context.Context, op *xxx_WriteNGCKeyOperation) {
	if o == nil {
		return
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
}
func (o *WriteNGCKeyResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *WriteNGCKeyResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_WriteNGCKeyOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ReadNGCKeyOperation structure represents the IDL_DRSReadNgcKey operation
type xxx_ReadNGCKeyOperation struct {
	Handle     *Handle                   `idl:"name:hDrs;pointer:ref" json:"handle"`
	InVersion  uint32                    `idl:"name:dwInVersion" json:"in_version"`
	In         *MessageReadNGCKeyRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
	OutVersion uint32                    `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	Out        *MessageReadNGCKeyReply   `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	Return     uint32                    `idl:"name:Return" json:"return"`
}

func (o *xxx_ReadNGCKeyOperation) OpNum() int { return 30 }

func (o *xxx_ReadNGCKeyOperation) OpName() string { return "/drsuapi/v4/IDL_DRSReadNgcKey" }

func (o *xxx_ReadNGCKeyOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ReadNGCKeyOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle != nil {
			if err := o.Handle.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_READNGCKEYREQ}(union))
	{
		_swIn := uint32(o.InVersion)
		if o.In != nil {
			if err := o.In.MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		} else {
			if err := (&MessageReadNGCKeyRequest{}).MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ReadNGCKeyOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hDrs {in} (1:{context_handle, pointer=ref, alias=DRS_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.Handle == nil {
			o.Handle = &Handle{}
		}
		if err := o.Handle.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_READNGCKEYREQ}(union))
	{
		if o.In == nil {
			o.In = &MessageReadNGCKeyRequest{}
		}
		_swIn := uint32(o.InVersion)
		if err := o.In.UnmarshalUnionNDR(ctx, w, _swIn); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ReadNGCKeyOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ReadNGCKeyOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_READNGCKEYREPLY}(union))
	{
		_swOut := uint32(o.OutVersion)
		if o.Out != nil {
			if err := o.Out.MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		} else {
			if err := (&MessageReadNGCKeyReply{}).MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ReadNGCKeyOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwOutVersion {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=DRS_MSG_READNGCKEYREPLY}(union))
	{
		if o.Out == nil {
			o.Out = &MessageReadNGCKeyReply{}
		}
		_swOut := uint32(o.OutVersion)
		if err := o.Out.UnmarshalUnionNDR(ctx, w, _swOut); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ReadNGCKeyRequest structure represents the IDL_DRSReadNgcKey operation request
type ReadNGCKeyRequest struct {
	Handle    *Handle                   `idl:"name:hDrs;pointer:ref" json:"handle"`
	InVersion uint32                    `idl:"name:dwInVersion" json:"in_version"`
	In        *MessageReadNGCKeyRequest `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
}

func (o *ReadNGCKeyRequest) xxx_ToOp(ctx context.Context, op *xxx_ReadNGCKeyOperation) *xxx_ReadNGCKeyOperation {
	if op == nil {
		op = &xxx_ReadNGCKeyOperation{}
	}
	if o == nil {
		return op
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
	return op
}

func (o *ReadNGCKeyRequest) xxx_FromOp(ctx context.Context, op *xxx_ReadNGCKeyOperation) {
	if o == nil {
		return
	}
	o.Handle = op.Handle
	o.InVersion = op.InVersion
	o.In = op.In
}
func (o *ReadNGCKeyRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *ReadNGCKeyRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ReadNGCKeyOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ReadNGCKeyResponse structure represents the IDL_DRSReadNgcKey operation response
type ReadNGCKeyResponse struct {
	OutVersion uint32                  `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	Out        *MessageReadNGCKeyReply `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	// Return: The IDL_DRSReadNgcKey return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ReadNGCKeyResponse) xxx_ToOp(ctx context.Context, op *xxx_ReadNGCKeyOperation) *xxx_ReadNGCKeyOperation {
	if op == nil {
		op = &xxx_ReadNGCKeyOperation{}
	}
	if o == nil {
		return op
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
	return op
}

func (o *ReadNGCKeyResponse) xxx_FromOp(ctx context.Context, op *xxx_ReadNGCKeyOperation) {
	if o == nil {
		return
	}
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
}
func (o *ReadNGCKeyResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *ReadNGCKeyResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ReadNGCKeyOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}
