package dhcpsrv2

import (
	"context"
	"fmt"
	"strings"
	"unicode/utf16"

	dcerpc "github.com/oiweiwei/go-msrpc/dcerpc"
	errors "github.com/oiweiwei/go-msrpc/dcerpc/errors"
	uuid "github.com/oiweiwei/go-msrpc/midl/uuid"
	dhcpm "github.com/oiweiwei/go-msrpc/msrpc/dhcpm"
	ndr "github.com/oiweiwei/go-msrpc/ndr"
)

var (
	_ = context.Background
	_ = fmt.Errorf
	_ = utf16.Encode
	_ = strings.TrimPrefix
	_ = ndr.ZeroString
	_ = (*uuid.UUID)(nil)
	_ = (*dcerpc.SyntaxID)(nil)
	_ = (*errors.Error)(nil)
	_ = dhcpm.GoPackage
)

var (
	// import guard
	GoPackage = "dhcpm"
)

var (
	// Syntax UUID
	Dhcpsrv2SyntaxUUID = &uuid.UUID{TimeLow: 0x5b821720, TimeMid: 0xf63b, TimeHiAndVersion: 0x11d0, ClockSeqHiAndReserved: 0xaa, ClockSeqLow: 0xd2, Node: [6]uint8{0x0, 0xc0, 0x4f, 0xc3, 0x24, 0xdb}}
	// Syntax ID
	Dhcpsrv2SyntaxV1_0 = &dcerpc.SyntaxID{IfUUID: Dhcpsrv2SyntaxUUID, IfVersionMajor: 1, IfVersionMinor: 0}
)

// dhcpsrv2 interface.
type Dhcpsrv2Client interface {

	// The R_DhcpEnumSubnetClientsV5 method is used to retrieve all DHCPv4 clients serviced
	// from the specified IPv4 subnet. This method returns DHCPv4 clients from all IPv4
	// subnets if the subnet address specified zero. The caller of this function can free
	// the memory pointed to by the ClientInfo parameter and its Clients member by calling
	// the function midl_user_free (see section 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value of ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+---------------------------------+-------------------------------------------------------------+
	//	|             RETURN              |                                                             |
	//	|           VALUE/CODE            |                         DESCRIPTION                         |
	//	|                                 |                                                             |
	//	+---------------------------------+-------------------------------------------------------------+
	//	+---------------------------------+-------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS        | The call was successful.                                    |
	//	+---------------------------------+-------------------------------------------------------------+
	//	| 0x000000EA ERROR_MORE_DATA      | There are more elements available to enumerate.             |
	//	+---------------------------------+-------------------------------------------------------------+
	//	| 0x00000103 ERROR_NO_MORE_ITEMS  | There are no more elements left to enumerate.               |
	//	+---------------------------------+-------------------------------------------------------------+
	//	| 0x00004E2D ERROR_DHCP_JET_ERROR | An error occurred while accessing the DHCP server database. |
	//	+---------------------------------+-------------------------------------------------------------+
	//
	// The opnum field value for this method is 0.
	//
	// Exceptions Thrown: No exceptions SHOULD be thrown beyond those thrown by the underlying
	// RPC protocol specified in [MS-RPCE].
	EnumSubnetClientsV5(context.Context, *EnumSubnetClientsV5Request, ...dcerpc.CallOption) (*EnumSubnetClientsV5Response, error)

	// The R_DhcpSetMScopeInfo method creates/modifies an IPv4 multicast subnet on the MADCAP
	// server. The behavior of this method is dependent on parameter NewScope.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	|                  RETURN                   |                                                                                  |
	//	|                VALUE/CODE                 |                                   DESCRIPTION                                    |
	//	|                                           |                                                                                  |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                  | The call was successful.                                                         |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E25 ERROR_DHCP_SUBNET_NOT_PRESENT  | The specified IPv4 subnet does not exist.                                        |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E2D ERROR_DHCP_JET_ERROR           | An error occurred while accessing the MADCAP server database.                    |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E4E ERROR_DHCP_SCOPE_NAME_TOO_LONG | The specified scope name is too long. The name is limited to a maximum of 256    |
	//	|                                           | characters.                                                                      |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E24 ERROR_DHCP_SUBNET_EXISTS       | The specified IPv4 multicast subnet already exists.                              |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E55 ERROR_DHCP_MSCOPE_EXISTS       | The multicast scope parameters are incorrect. Either the scope already exists or |
	//	|                                           | its properties are inconsistent with the properties of another existing scope.   |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 1.
	//
	// Exceptions Thrown: No exceptions SHOULD be thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	SetMScopeInfo(context.Context, *SetMScopeInfoRequest, ...dcerpc.CallOption) (*SetMScopeInfoResponse, error)

	// The R_DhcpGetMScopeInfo method retrieves the information of the IPv4 multicast subnet
	// managed by the MADCAP server. The caller of this function can free the memory pointed
	// by MScopeInfo by calling the function midl_user_free (section 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+------------------------------------------+-------------------------------------------+
	//	|                  RETURN                  |                                           |
	//	|                VALUE/CODE                |                DESCRIPTION                |
	//	|                                          |                                           |
	//	+------------------------------------------+-------------------------------------------+
	//	+------------------------------------------+-------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                 | The call was successful.                  |
	//	+------------------------------------------+-------------------------------------------+
	//	| 0x00004E25 ERROR_DHCP_SUBNET_NOT_PRESENT | The specified IPv4 subnet does not exist. |
	//	+------------------------------------------+-------------------------------------------+
	//
	// The opnum field value for this method is 2.
	//
	// Exceptions Thrown: No exceptions SHOULD be thrown beyond those thrown by the underlying
	// RPC protocol specified in [MS-RPCE].
	GetMScopeInfo(context.Context, *GetMScopeInfoRequest, ...dcerpc.CallOption) (*GetMScopeInfoResponse, error)

	// The R_DhcpEnumMScopes method enumerates IPv4 multicast subnet names configured on
	// the MADCAP server. The caller of this function can free the memory pointed to by
	// the MScopeTable parameter by calling the function midl_user_free (section 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value of ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+--------------------------------+-----------------------------------------------+
	//	|             RETURN             |                                               |
	//	|           VALUE/CODE           |                  DESCRIPTION                  |
	//	|                                |                                               |
	//	+--------------------------------+-----------------------------------------------+
	//	+--------------------------------+-----------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS       | The call was successful.                      |
	//	+--------------------------------+-----------------------------------------------+
	//	| 0x00000103 ERROR_NO_MORE_ITEMS | There are no more elements left to enumerate. |
	//	+--------------------------------+-----------------------------------------------+
	//
	// The opnum field value for this method is 3.
	//
	// Exceptions Thrown: No exceptions SHOULD be thrown beyond those thrown by the underlying
	// RPC protocol specified in [MS-RPCE].
	EnumMScopes(context.Context, *EnumMScopesRequest, ...dcerpc.CallOption) (*EnumMScopesResponse, error)

	// The R_DhcpAddMScopeElement method adds an IPv4 multicast subnet element (IPv4 range
	// or IPv4 exclusion range) to the IPv4 multicast subnet in the MADCAP server.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value of ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	|                  RETURN                  |                                                                                  |
	//	|                VALUE/CODE                |                                   DESCRIPTION                                    |
	//	|                                          |                                                                                  |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                 | The call was successful.                                                         |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E25 ERROR_DHCP_SUBNET_NOT_PRESENT | The specified IPv4 subnet does not exist.                                        |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E2D ERROR_DHCP_JET_ERROR          | An error occurred while accessing the MADCAP server database.                    |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E37 ERROR_DHCP_INVALID_RANGE      | The specified multicast range either overlaps an existing range or is not valid. |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E56 ERROR_MSCOPE_RANGE_TOO_SMALL  | The multicast scope range MUST have at least 256 IPv4 addresses.                 |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E35 ERROR_DHCP_IPRANGE_EXITS      | The specified multicast range already exists.                                    |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 4.
	//
	// Exceptions Thrown: No exceptions SHOULD be thrown beyond those thrown by the underlying
	// RPC protocol specified in [MS-RPCE].
	AddMScopeElement(context.Context, *AddMScopeElementRequest, ...dcerpc.CallOption) (*AddMScopeElementResponse, error)

	// The R_DhcpEnumMScopeElements method enumerates the list of specific types of IPv4
	// multicast subnet elements (IPv4 range of IPv4 exclusion) from a specific IPv4 multicast
	// subnet. The caller of this function can free the memory pointed to by EnumElementInfo
	// and its member Elements by calling the function midl_user_free (section 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+------------------------------------------+-------------------------------------------------+
	//	|                  RETURN                  |                                                 |
	//	|                VALUE/CODE                |                   DESCRIPTION                   |
	//	|                                          |                                                 |
	//	+------------------------------------------+-------------------------------------------------+
	//	+------------------------------------------+-------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                 | The call was successful.                        |
	//	+------------------------------------------+-------------------------------------------------+
	//	| 0x000000EA ERROR_MORE_DATA               | There are more elements available to enumerate. |
	//	+------------------------------------------+-------------------------------------------------+
	//	| 0x00000103 ERROR_NO_MORE_ITEMS           | There are no more elements left to enumerate.   |
	//	+------------------------------------------+-------------------------------------------------+
	//	| 0x00004E25 ERROR_DHCP_SUBNET_NOT_PRESENT | The specified IPv4 subnet does not exist.       |
	//	+------------------------------------------+-------------------------------------------------+
	//
	// The opnum field value for this method is 5.
	//
	// Exceptions Thrown: No exceptions SHOULD be thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	EnumMScopeElements(context.Context, *EnumMScopeElementsRequest, ...dcerpc.CallOption) (*EnumMScopeElementsResponse, error)

	// The R_DhcpRemoveMScopeElement method removes an IPv4 multicast subnet element (IPv4
	// multicast range or IPv4 exclusion range) from the IPv4 multicast subnet defined on
	// the MADCAP server.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	|                  RETURN                   |                                                                                  |
	//	|                VALUE/CODE                 |                                   DESCRIPTION                                    |
	//	|                                           |                                                                                  |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                  | The call was successful.                                                         |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E27 ERROR_DHCP_ELEMENT_CANT_REMOVE | The specified IPv4 multicast subnet element cannot be removed because at least   |
	//	|                                           | one multicast IPv4 address has been leased out to a MADCAP client. The starting  |
	//	|                                           | address of the specified Multicast exclusion range is not part of any multicast  |
	//	|                                           | exclusion range configured on the server. There is an error in deleting the      |
	//	|                                           | exclusion range from the database.                                               |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E2D ERROR_DHCP_JET_ERROR           | An error occurred while accessing the MADCAP server database.                    |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E37 ERROR_DHCP_INVALID_RANGE       | The specified IPv4 range either overlaps an existing IPv4 range or is not valid. |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 6.
	//
	// Exceptions Thrown: No exceptions SHOULD be thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	RemoveMScopeElement(context.Context, *RemoveMScopeElementRequest, ...dcerpc.CallOption) (*RemoveMScopeElementResponse, error)

	// The R_DhcpDeleteMScope method deletes the multicast subnet from the MADCAP server.
	// The ForceFlag defines the behavior of the operation when the subnet has served a
	// MADCAP client.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	|                  RETURN                   |                                                                                  |
	//	|                VALUE/CODE                 |                                   DESCRIPTION                                    |
	//	|                                           |                                                                                  |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                  | The call was successful.                                                         |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E25 ERROR_DHCP_SUBNET_NOT_PRESENT  | The specified IPv4 subnet does not exist.                                        |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E27 ERROR_DHCP_ELEMENT_CANT_REMOVE | The specified IPv4 multicast scope cannot be removed because at least one        |
	//	|                                           | multicast IPv4 address has been leased out to some MADCAP client.                |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E2D ERROR_DHCP_JET_ERROR           | An error occurred while accessing the MADCAP server database.                    |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 7.
	//
	// Exceptions Thrown: No exceptions SHOULD be thrown beyond those thrown by the underlying
	// RPC protocol specified in [MS-RPCE].
	DeleteMScope(context.Context, *DeleteMScopeRequest, ...dcerpc.CallOption) (*DeleteMScopeResponse, error)

	// The R_DhcpScanMDatabase method can be used by DHCP servers to enumerate and/or fix
	// inconsistencies between the MADCAP lease records and the bitmask representation in
	// memory (section 3.1.1.4). The caller of this function can free the memory pointed
	// to by ScanList and its member ScanItems by calling the function midl_user_free (section
	// 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+------------------------------------------+---------------------------------------------------------------+
	//	|                  RETURN                  |                                                               |
	//	|                VALUE/CODE                |                          DESCRIPTION                          |
	//	|                                          |                                                               |
	//	+------------------------------------------+---------------------------------------------------------------+
	//	+------------------------------------------+---------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                 | The call was successful.                                      |
	//	+------------------------------------------+---------------------------------------------------------------+
	//	| 0x00004E25 ERROR_DHCP_SUBNET_NOT_PRESENT | The specified IPv4 subnet does not exist.                     |
	//	+------------------------------------------+---------------------------------------------------------------+
	//	| 0x00004E2D ERROR_DHCP_JET_ERROR          | An error occurred while accessing the MADCAP server database. |
	//	+------------------------------------------+---------------------------------------------------------------+
	//
	// The opnum field value for this method is 8.
	//
	// Exceptions Thrown: No exceptions SHOULD be thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	ScanMDatabase(context.Context, *ScanMDatabaseRequest, ...dcerpc.CallOption) (*ScanMDatabaseResponse, error)

	// The R_DhcpCreateMClientInfo method creates a multicast client record on the MADCAP
	// server's database. This also marks the specified client IP address as unavailable
	// (or distributed).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+---------------------------------------+---------------------------------------------------------------------+
	//	|                RETURN                 |                                                                     |
	//	|              VALUE/CODE               |                             DESCRIPTION                             |
	//	|                                       |                                                                     |
	//	+---------------------------------------+---------------------------------------------------------------------+
	//	+---------------------------------------+---------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS              | This call was successful.                                           |
	//	+---------------------------------------+---------------------------------------------------------------------+
	//	| 0x00000078 ERROR_CALL_NOT_IMPLEMENTED | The method is not implemented by this version of the MADCAP server. |
	//	+---------------------------------------+---------------------------------------------------------------------+
	//
	// The opnum field value for this method is 9.
	//
	// Exceptions Thrown: No exceptions SHOULD be thrown beyond those thrown by the underlying
	// RPC protocol specified in [MS-RPCE].
	CreateMClientInfo(context.Context, *CreateMClientInfoRequest, ...dcerpc.CallOption) (*CreateMClientInfoResponse, error)

	// The R_DhcpSetMClientInfo method sets/modifies the specific MADCAP client lease record
	// on the MADCAP server.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+---------------------------------------+---------------------------------------------------------------------+
	//	|                RETURN                 |                                                                     |
	//	|              VALUE/CODE               |                             DESCRIPTION                             |
	//	|                                       |                                                                     |
	//	+---------------------------------------+---------------------------------------------------------------------+
	//	+---------------------------------------+---------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS              | This call was successful.                                           |
	//	+---------------------------------------+---------------------------------------------------------------------+
	//	| 0x00000078 ERROR_CALL_NOT_IMPLEMENTED | The method is not implemented by this version of the MADCAP server. |
	//	+---------------------------------------+---------------------------------------------------------------------+
	//
	// The opnum field value for this method is 10.
	//
	// Exceptions Thrown: No exceptions SHOULD be thrown beyond those thrown by the underlying
	// RPC protocol specified in [MS-RPCE].
	SetMClientInfo(context.Context, *SetMClientInfoRequest, ...dcerpc.CallOption) (*SetMClientInfoResponse, error)

	// The R_DhcpGetMClientInfo method retrieves the specified MADCAP client lease record
	// information from the MADCAP server. The caller of this function can free the memory
	// pointed to by ClientInfo by calling the function midl_user_free (section 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+---------------------------------+---------------------------------------------------------------+
	//	|             RETURN              |                                                               |
	//	|           VALUE/CODE            |                          DESCRIPTION                          |
	//	|                                 |                                                               |
	//	+---------------------------------+---------------------------------------------------------------+
	//	+---------------------------------+---------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS        | The call was successful.                                      |
	//	+---------------------------------+---------------------------------------------------------------+
	//	| 0x00004E2D ERROR_DHCP_JET_ERROR | An error occurred while accessing the MADCAP server database. |
	//	+---------------------------------+---------------------------------------------------------------+
	//
	// The opnum field value for this method is 11.
	//
	// Exceptions Thrown: No exceptions SHOULD be thrown beyond those thrown by the underlying
	// RPC protocol specified in [MS-RPCE].
	GetMClientInfo(context.Context, *GetMClientInfoRequest, ...dcerpc.CallOption) (*GetMClientInfoResponse, error)

	// The R_DhcpDeleteMClientInfo method deletes the specified MADCAP client lease record
	// from the MADCAP server. It also frees up the MADCAP client IPv4 address for redistribution.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+---------------------------------+---------------------------------------------------------------+
	//	|             RETURN              |                                                               |
	//	|           VALUE/CODE            |                          DESCRIPTION                          |
	//	|                                 |                                                               |
	//	+---------------------------------+---------------------------------------------------------------+
	//	+---------------------------------+---------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS        | The call was successful.                                      |
	//	+---------------------------------+---------------------------------------------------------------+
	//	| 0x00004E2D ERROR_DHCP_JET_ERROR | An error occurred while accessing the MADCAP server database. |
	//	+---------------------------------+---------------------------------------------------------------+
	//
	// The opnum field value for this method is 12.
	//
	// Exceptions Thrown: No exceptions SHOULD be thrown beyond those thrown by the underlying
	// RPC protocol specified in [MS-RPCE].
	DeleteMClientInfo(context.Context, *DeleteMClientInfoRequest, ...dcerpc.CallOption) (*DeleteMClientInfoResponse, error)

	// The R_DhcpEnumMScopeClients method enumerates all MADCAP clients serviced from the
	// specified IPv4 multicast subnet. The caller of this function can free the memory
	// pointed to by the ClientInfo parameter and other client parameters by calling the
	// function midl_user_free (section 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value of ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+------------------------------------------+---------------------------------------------------------------+
	//	|                  RETURN                  |                                                               |
	//	|                VALUE/CODE                |                          DESCRIPTION                          |
	//	|                                          |                                                               |
	//	+------------------------------------------+---------------------------------------------------------------+
	//	+------------------------------------------+---------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                 | The call was successful.                                      |
	//	+------------------------------------------+---------------------------------------------------------------+
	//	| 0x000000EA ERROR_MORE_DATA               | There are more elements available to enumerate.               |
	//	+------------------------------------------+---------------------------------------------------------------+
	//	| 0x00000103 ERROR_NO_MORE_ITEMS           | There are no more elements left to enumerate.                 |
	//	+------------------------------------------+---------------------------------------------------------------+
	//	| 0x00004E25 ERROR_DHCP_SUBNET_NOT_PRESENT | The specified IPv4 subnet does not exist.                     |
	//	+------------------------------------------+---------------------------------------------------------------+
	//	| 0x00004E2D ERROR_DHCP_JET_ERROR          | An error occurred while accessing the MADCAP server database. |
	//	+------------------------------------------+---------------------------------------------------------------+
	//
	// The opnum field value for this method is 13.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol specified in [MS-RPCE].
	EnumMScopeClients(context.Context, *EnumMScopeClientsRequest, ...dcerpc.CallOption) (*EnumMScopeClientsResponse, error)

	// The R_DhcpCreateOptionV5 method creates an option definition of a specific option
	// for a specific user class and vendor class at the default option level. The OptionId
	// specifies the identifier of the option. If the user class or vendor class is not
	// defined, the option definition is created for the default user class and vendor class.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+---------------------------------------+-------------------------------------------------------------------------+
	//	|                RETURN                 |                                                                         |
	//	|              VALUE/CODE               |                               DESCRIPTION                               |
	//	|                                       |                                                                         |
	//	+---------------------------------------+-------------------------------------------------------------------------+
	//	+---------------------------------------+-------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS              | The call was successful.                                                |
	//	+---------------------------------------+-------------------------------------------------------------------------+
	//	| 0x00004E29 ERROR_DHCP_OPTION_EXITS    | The specified option definition already exists on DHCP server database. |
	//	+---------------------------------------+-------------------------------------------------------------------------+
	//	| 0x00004E2D ERROR_DHCP_JET_ERROR       | An error occurred while accessing the DHCP server database.             |
	//	+---------------------------------------+-------------------------------------------------------------------------+
	//	| 0x00004E4C ERROR_DHCP_CLASS_NOT_FOUND | The class name being used is unknown or incorrect.                      |
	//	+---------------------------------------+-------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 14.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol specified in [MS-RPCE].
	CreateOptionV5(context.Context, *CreateOptionV5Request, ...dcerpc.CallOption) (*CreateOptionV5Response, error)

	// The R_DhcpSetOptionInfoV5 method modifies the option definition of a specific option
	// for a specific user class and vendor class at the default level. If the user class
	// or vendor class is not defined, the option definition is set or modified for the
	// default user class or vendor class. This is an extension of R_DhcpSetOptionInfo (section
	// 3.1.4.10), which sets the option definition for a default user and vendor class.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+------------------------------------------+-----------------------------------------------------------------------------+
	//	|                  RETURN                  |                                                                             |
	//	|                VALUE/CODE                |                                 DESCRIPTION                                 |
	//	|                                          |                                                                             |
	//	+------------------------------------------+-----------------------------------------------------------------------------+
	//	+------------------------------------------+-----------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                 | The call was successful.                                                    |
	//	+------------------------------------------+-----------------------------------------------------------------------------+
	//	| 0x00004E2A ERROR_DHCP_OPTION_NOT_PRESENT | The specified option definition does not exist on the DHCP server database. |
	//	+------------------------------------------+-----------------------------------------------------------------------------+
	//	| 0x00004E4C ERROR_DHCP_CLASS_NOT_FOUND    | The class name being used is unknown or incorrect.                          |
	//	+------------------------------------------+-----------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 15.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	SetOptionInfoV5(context.Context, *SetOptionInfoV5Request, ...dcerpc.CallOption) (*SetOptionInfoV5Response, error)

	// The R_DhcpGetOptionInfoV5 method retrieves the option definition of a specific option
	// for a specific user class and vendor class at the default option level. If the user
	// class or vendor class is not defined, the option definition is retrieved for the
	// default user class or vendor class. This is an extension method of R_DhcpGetOptionInfo
	// (section 3.1.4.11), which retrieves the option definition of a specific option for
	// the default user and vendor class. The caller of this function can free the memory
	// pointed to by OptionInfo by calling the function midl_user_free (see section 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+------------------------------------------+-------------------------------------------------------------------------+
	//	|                  RETURN                  |                                                                         |
	//	|                VALUE/CODE                |                               DESCRIPTION                               |
	//	|                                          |                                                                         |
	//	+------------------------------------------+-------------------------------------------------------------------------+
	//	+------------------------------------------+-------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                 | The call was successful.                                                |
	//	+------------------------------------------+-------------------------------------------------------------------------+
	//	| 0x00004E2A ERROR_DHCP_OPTION_NOT_PRESENT | The specified option definition does not exist on DHCP server database. |
	//	+------------------------------------------+-------------------------------------------------------------------------+
	//	| 0x00004E4C ERROR_DHCP_CLASS_NOT_FOUND    | The class name being used is unknown or incorrect.                      |
	//	+------------------------------------------+-------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 16.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	GetOptionInfoV5(context.Context, *GetOptionInfoV5Request, ...dcerpc.CallOption) (*GetOptionInfoV5Response, error)

	// The R_DhcpEnumOptionsV5 method enumerates the option definitions for a specific user
	// class and vendor class for the default option level. If the user class or the vendor
	// class is not defined, the option definitions are enumerated for the default user
	// class or vendor class. This method is an extension of the method in R_DhcpEnumOptions
	// (section 3.1.4.24), which enumerates the option definition for a default user and
	// vendor class. The caller of this function can free the memory pointed to by the Options
	// parameter by calling the function midl_user_free (section 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+---------------------------------------+----------------------------------------------------+
	//	|                RETURN                 |                                                    |
	//	|              VALUE/CODE               |                    DESCRIPTION                     |
	//	|                                       |                                                    |
	//	+---------------------------------------+----------------------------------------------------+
	//	+---------------------------------------+----------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS              | The call was successful.                           |
	//	+---------------------------------------+----------------------------------------------------+
	//	| 0x000000EA ERROR_MORE_DATA            | There are more elements available to enumerate.    |
	//	+---------------------------------------+----------------------------------------------------+
	//	| 0x00000103 ERROR_NO_MORE_ITEMS        | There are no more elements left to enumerate.      |
	//	+---------------------------------------+----------------------------------------------------+
	//	| 0x00004E4C ERROR_DHCP_CLASS_NOT_FOUND | The class name being used is unknown or incorrect. |
	//	+---------------------------------------+----------------------------------------------------+
	//
	// The opnum field value for this method is 17.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol specified in [MS-RPCE].
	EnumOptionsV5(context.Context, *EnumOptionsV5Request, ...dcerpc.CallOption) (*EnumOptionsV5Response, error)

	// The R_DhcpRemoveOptionV5 method removes the option definition of a specific option
	// for a specific user class and vendor class at the default option level. If the user
	// class or the vendor class is not specified, the option definition is removed from
	// the default user class or vendor class. The OptionID specifies the identifier of
	// the option definition.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+------------------------------------------+-----------------------------------------------------------------------------+
	//	|                  RETURN                  |                                                                             |
	//	|                VALUE/CODE                |                                 DESCRIPTION                                 |
	//	|                                          |                                                                             |
	//	+------------------------------------------+-----------------------------------------------------------------------------+
	//	+------------------------------------------+-----------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                 | The call was successful.                                                    |
	//	+------------------------------------------+-----------------------------------------------------------------------------+
	//	| 0x00004E2A ERROR_DHCP_OPTION_NOT_PRESENT | The specified option definition does not exist on the DHCP server database. |
	//	+------------------------------------------+-----------------------------------------------------------------------------+
	//	| 0x00004E4C ERROR_DHCP_CLASS_NOT_FOUND    | The class name being used is unknown or incorrect.                          |
	//	+------------------------------------------+-----------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 18.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	RemoveOptionV5(context.Context, *RemoveOptionV5Request, ...dcerpc.CallOption) (*RemoveOptionV5Response, error)

	// The R_DhcpSetOptionValueV5 method creates the option value, when called for the first
	// time. Otherwise, it modifies the option value of a specific option on the DHCPv4
	// server for a specific user class and vendor class. ScopeInfo defines the scope on
	// which this option value is set. If the user class or vendor class is not provided,
	// a default user class or vendor class is taken.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+-------------------------------------------+-----------------------------------------------------------------------------+
	//	|                  RETURN                   |                                                                             |
	//	|                VALUE/CODE                 |                                 DESCRIPTION                                 |
	//	|                                           |                                                                             |
	//	+-------------------------------------------+-----------------------------------------------------------------------------+
	//	+-------------------------------------------+-----------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                  | The call was successful.                                                    |
	//	+-------------------------------------------+-----------------------------------------------------------------------------+
	//	| 0x00004E25 ERROR_DHCP_SUBNET_NOT_PRESENT  | The specified IPv4 subnet does not exist on the DHCP server.                |
	//	+-------------------------------------------+-----------------------------------------------------------------------------+
	//	| 0x00004E2A ERROR_DHCP_OPTION_NOT_PRESENT  | The specified option definition does not exist on the DHCP server database. |
	//	+-------------------------------------------+-----------------------------------------------------------------------------+
	//	| 0x00004E32 ERROR_DHCP_NOT_RESERVED_CLIENT | The specified DHCP client is not a reserved client.                         |
	//	+-------------------------------------------+-----------------------------------------------------------------------------+
	//	| 0x00004E4C ERROR_DHCP_CLASS_NOT_FOUND     | The class name being used is unknown or incorrect.                          |
	//	+-------------------------------------------+-----------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 19.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	SetOptionValueV5(context.Context, *SetOptionValueV5Request, ...dcerpc.CallOption) (*SetOptionValueV5Response, error)

	// The R_DhcpSetOptionValuesV5 method creates the option value when called for the first
	// time, else it modifies it. It creates or modifies one or more options for a specific
	// user class and vendor class. If the user class or the vendor class is not specified,
	// the option values are set or modified for the default user class or vendor class.
	// ScopeInfo defines the scope on which this option value is modified.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+-------------------------------------------+-----------------------------------------------------------------------------+
	//	|                  RETURN                   |                                                                             |
	//	|                VALUE/CODE                 |                                 DESCRIPTION                                 |
	//	|                                           |                                                                             |
	//	+-------------------------------------------+-----------------------------------------------------------------------------+
	//	+-------------------------------------------+-----------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                  | The call was successful.                                                    |
	//	+-------------------------------------------+-----------------------------------------------------------------------------+
	//	| 0x00004E2A ERROR_DHCP_OPTION_NOT_PRESENT  | The specified option definition does not exist on the DHCP server database. |
	//	+-------------------------------------------+-----------------------------------------------------------------------------+
	//	| 0x00004E32 ERROR_DHCP_NOT_RESERVED_CLIENT | The specified DHCP client is not a reserved client.                         |
	//	+-------------------------------------------+-----------------------------------------------------------------------------+
	//	| 0x00004E4C ERROR_DHCP_CLASS_NOT_FOUND     | The class name being used is unknown or incorrect.                          |
	//	+-------------------------------------------+-----------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 20.
	//
	// Exceptions Thrown: No exceptions SHOULD be thrown beyond those thrown by the underlying
	// RPC protocol specified in [MS-RPCE].
	SetOptionValuesV5(context.Context, *SetOptionValuesV5Request, ...dcerpc.CallOption) (*SetOptionValuesV5Response, error)

	// The R_DhcpGetOptionValueV5 method retrieves the option value for a specific option
	// on the DHCPv4 server for a specific user class and vendor class. If the user class
	// or the vendor class is not specified, the option value is retrieved from the default
	// user class or vendor class. ScopeInfo defines the scope from which the option value
	// needs to be retrieved. The caller of this function can free the memory pointed to
	// by OptionValue by calling the function midl_user_free (section 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+-------------------------------------------+-----------------------------------------------------------------------------+
	//	|                  RETURN                   |                                                                             |
	//	|                VALUE/CODE                 |                                 DESCRIPTION                                 |
	//	|                                           |                                                                             |
	//	+-------------------------------------------+-----------------------------------------------------------------------------+
	//	+-------------------------------------------+-----------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                  | The call was successful.                                                    |
	//	+-------------------------------------------+-----------------------------------------------------------------------------+
	//	| 0x00004E25 ERROR_DHCP_SUBNET_NOT_PRESENT  | The specified IPv4 subnet does not exist on the DHCP server.                |
	//	+-------------------------------------------+-----------------------------------------------------------------------------+
	//	| 0x00004E2A ERROR_DHCP_OPTION_NOT_PRESENT  | The specified option definition does not exist on the DHCP server database. |
	//	+-------------------------------------------+-----------------------------------------------------------------------------+
	//	| 0x00004E32 ERROR_DHCP_NOT_RESERVED_CLIENT | The specified DHCP client is not a reserved client.                         |
	//	+-------------------------------------------+-----------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 21.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	GetOptionValueV5(context.Context, *GetOptionValueV5Request, ...dcerpc.CallOption) (*GetOptionValueV5Response, error)

	// The R_DhcpEnumOptionValuesV5 method enumerates all the option values for the specific
	// user class and vendor class at a specified scope defined by ScopeInfo. If the user
	// class or the vendor class is not specified, the option values are retrieved from
	// the default user class or vendor class. The caller of this function can free the
	// memory pointed to by OptionValues and the Values member of OptionValues by calling
	// the function midl_user_free (section 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+-------------------------------------------+--------------------------------------------------------------+
	//	|                  RETURN                   |                                                              |
	//	|                VALUE/CODE                 |                         DESCRIPTION                          |
	//	|                                           |                                                              |
	//	+-------------------------------------------+--------------------------------------------------------------+
	//	+-------------------------------------------+--------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                  | The call was successful.                                     |
	//	+-------------------------------------------+--------------------------------------------------------------+
	//	| 0x000000EA ERROR_MORE_DATA                | There are more elements available to enumerate.              |
	//	+-------------------------------------------+--------------------------------------------------------------+
	//	| 0x00000103 ERROR_NO_MORE_ITEMS            | There are no more elements left to enumerate.                |
	//	+-------------------------------------------+--------------------------------------------------------------+
	//	| 0x00004E25 ERROR_DHCP_SUBNET_NOT_PRESENT  | The specified IPv4 subnet does not exist on the DHCP server. |
	//	+-------------------------------------------+--------------------------------------------------------------+
	//	| 0x00004E32 ERROR_DHCP_NOT_RESERVED_CLIENT | The specified DHCP client is not a reserved client.          |
	//	+-------------------------------------------+--------------------------------------------------------------+
	//	| 0x00004E4C ERROR_DHCP_CLASS_NOT_FOUND     | The class name being used is unknown or incorrect.           |
	//	+-------------------------------------------+--------------------------------------------------------------+
	//
	// The opnum field value for this method is 22.
	EnumOptionValuesV5(context.Context, *EnumOptionValuesV5Request, ...dcerpc.CallOption) (*EnumOptionValuesV5Response, error)

	// The R_DhcpRemoveOptionValueV5 method removes the option value for a specific option
	// on the DHCPv4 server for a specific user class and vendor class. If the user class
	// or the vendor class is not specified, the option value is removed from the default
	// user class or vendor class. ScopeInfo defines the scope on which this option value
	// is removed.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+-------------------------------------------+-----------------------------------------------------------------------------+
	//	|                  RETURN                   |                                                                             |
	//	|                VALUE/CODE                 |                                 DESCRIPTION                                 |
	//	|                                           |                                                                             |
	//	+-------------------------------------------+-----------------------------------------------------------------------------+
	//	+-------------------------------------------+-----------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                  | The call was successful.                                                    |
	//	+-------------------------------------------+-----------------------------------------------------------------------------+
	//	| 0x00004E25 ERROR_DHCP_SUBNET_NOT_PRESENT  | The specified IPv4 subnet does not exist on the DHCP server.                |
	//	+-------------------------------------------+-----------------------------------------------------------------------------+
	//	| 0x00004E2A ERROR_DHCP_OPTION_NOT_PRESENT  | The specified option definition does not exist on the DHCP server database. |
	//	+-------------------------------------------+-----------------------------------------------------------------------------+
	//	| 0x00004E32 ERROR_DHCP_NOT_RESERVED_CLIENT | The specified DHCP client is not a reserved client.                         |
	//	+-------------------------------------------+-----------------------------------------------------------------------------+
	//	| 0x00004E4C ERROR_DHCP_CLASS_NOT_FOUND     | The class name being used is unknown or incorrect.                          |
	//	+-------------------------------------------+-----------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 23.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	RemoveOptionValueV5(context.Context, *RemoveOptionValueV5Request, ...dcerpc.CallOption) (*RemoveOptionValueV5Response, error)

	// The R_DhcpCreateClass method creates a user class or a vendor class definition on
	// the DHCPv4 server.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+--------------------------------------------+------------------------------------------------------------------------------+
	//	|                   RETURN                   |                                                                              |
	//	|                 VALUE/CODE                 |                                 DESCRIPTION                                  |
	//	|                                            |                                                                              |
	//	+--------------------------------------------+------------------------------------------------------------------------------+
	//	+--------------------------------------------+------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                   | The call was successful.                                                     |
	//	+--------------------------------------------+------------------------------------------------------------------------------+
	//	| 0x00004E4D ERROR_DHCP_CLASS_ALREADY_EXISTS | The class name is already in use or the class information is already in use. |
	//	+--------------------------------------------+------------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 24.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol specified in [MS-RPCE].
	CreateClass(context.Context, *CreateClassRequest, ...dcerpc.CallOption) (*CreateClassResponse, error)

	// The R_DhcpModifyClass method modifies the user class or vendor class definition for
	// the DHCP server.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+---------------------------------------+----------------------------------------------------+
	//	|                RETURN                 |                                                    |
	//	|              VALUE/CODE               |                    DESCRIPTION                     |
	//	|                                       |                                                    |
	//	+---------------------------------------+----------------------------------------------------+
	//	+---------------------------------------+----------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS              | The call was successful.                           |
	//	+---------------------------------------+----------------------------------------------------+
	//	| 0x00004E4C ERROR_DHCP_CLASS_NOT_FOUND | The class name being used is unknown or incorrect. |
	//	+---------------------------------------+----------------------------------------------------+
	//
	// The opnum field value for this method is 25.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol specified in [MS-RPCE].
	ModifyClass(context.Context, *ModifyClassRequest, ...dcerpc.CallOption) (*ModifyClassResponse, error)

	// The R_DhcpDeleteClass method deletes the user class or vendor class definition from
	// the DHCP server.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+--------------------------------------------+----------------------------------------------------+
	//	|                   RETURN                   |                                                    |
	//	|                 VALUE/CODE                 |                    DESCRIPTION                     |
	//	|                                            |                                                    |
	//	+--------------------------------------------+----------------------------------------------------+
	//	+--------------------------------------------+----------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                   | The call was successful.                           |
	//	+--------------------------------------------+----------------------------------------------------+
	//	| 0x00004E4C ERROR_DHCP_CLASS_NOT_FOUND      | The class name being used is unknown or incorrect. |
	//	+--------------------------------------------+----------------------------------------------------+
	//	| 0x00004E79 ERROR_DHCP_DELETE_BUILTIN_CLASS | This class cannot be deleted.                      |
	//	+--------------------------------------------+----------------------------------------------------+
	//
	// The opnum field value for this method is 26.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol specified in [MS-RPCE].
	DeleteClass(context.Context, *DeleteClassRequest, ...dcerpc.CallOption) (*DeleteClassResponse, error)

	// The R_DhcpGetClassInfo method retrieves the user class or vendor class information
	// configured for the DHCP server. The caller of this function can free the memory pointed
	// to by FilledClassInfo by calling the function midl_user_free (section 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+---------------------------------------+----------------------------------------------------+
	//	|                RETURN                 |                                                    |
	//	|              VALUE/CODE               |                    DESCRIPTION                     |
	//	|                                       |                                                    |
	//	+---------------------------------------+----------------------------------------------------+
	//	+---------------------------------------+----------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS              | The call was successful.                           |
	//	+---------------------------------------+----------------------------------------------------+
	//	| 0x00004E4C ERROR_DHCP_CLASS_NOT_FOUND | The class name being used is unknown or incorrect. |
	//	+---------------------------------------+----------------------------------------------------+
	//
	// The opnum field value for this method is 27.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	GetClassInfo(context.Context, *GetClassInfoRequest, ...dcerpc.CallOption) (*GetClassInfoResponse, error)

	// The R_DhcpEnumClasses method enumerates user classes or vendor classes configured
	// for the DHCP server. The caller of this function can free the memory pointed to by
	// ClassInfoArray and Classes by calling the function midl_user_free (section 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+--------------------------------+-------------------------------------------------+
	//	|             RETURN             |                                                 |
	//	|           VALUE/CODE           |                   DESCRIPTION                   |
	//	|                                |                                                 |
	//	+--------------------------------+-------------------------------------------------+
	//	+--------------------------------+-------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS       | The call was successful.                        |
	//	+--------------------------------+-------------------------------------------------+
	//	| 0x000000EA ERROR_MORE_DATA     | There are more elements available to enumerate. |
	//	+--------------------------------+-------------------------------------------------+
	//	| 0x00000103 ERROR_NO_MORE_ITEMS | There are no more elements left to enumerate.   |
	//	+--------------------------------+-------------------------------------------------+
	//
	// The opnum field value for this method is 28.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	EnumClasses(context.Context, *EnumClassesRequest, ...dcerpc.CallOption) (*EnumClassesResponse, error)

	// The R_DhcpGetAllOptions method retrieves all default option definitions, as well
	// as specific user class and vendor class option definitions. The caller of this function
	// can free the memory pointed to by OptionStruct, NonVendorOptions and other Options
	// by calling the function midl_user_free (section 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+--------------------------+--------------------------+
	//	|          RETURN          |                          |
	//	|        VALUE/CODE        |       DESCRIPTION        |
	//	|                          |                          |
	//	+--------------------------+--------------------------+
	//	+--------------------------+--------------------------+
	//	| 0x00000000 ERROR_SUCCESS | The call was successful. |
	//	+--------------------------+--------------------------+
	//
	// The opnum field value for this method is 29.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	GetAllOptions(context.Context, *GetAllOptionsRequest, ...dcerpc.CallOption) (*GetAllOptionsResponse, error)

	// The R_DhcpGetAllOptionValues method retrieves the option values for all the options
	// configured at the DHCPv4 server from the specific scope for all user classes and
	// vendor classes. ScopeInfo defines the scope from which this option values are retrieved.
	// The caller of this method can free the memory pointed to by Values, its Options member,
	// and the members of each element in the Options array, by calling the function midl_user_free
	// (section 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+-------------------------------------------+--------------------------------------------------------------+
	//	|                  RETURN                   |                                                              |
	//	|                VALUE/CODE                 |                         DESCRIPTION                          |
	//	|                                           |                                                              |
	//	+-------------------------------------------+--------------------------------------------------------------+
	//	+-------------------------------------------+--------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                  | The call was successful.                                     |
	//	+-------------------------------------------+--------------------------------------------------------------+
	//	| 0x00004E25 ERROR_DHCP_SUBNET_NOT_PRESENT  | The specified IPv4 subnet does not exist on the DHCP server. |
	//	+-------------------------------------------+--------------------------------------------------------------+
	//	| 0x00004E32 ERROR_DHCP_NOT_RESERVED_CLIENT | The specified DHCP client is not a reserved client.          |
	//	+-------------------------------------------+--------------------------------------------------------------+
	//
	// The opnum field value for this method is 30.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	GetAllOptionValues(context.Context, *GetAllOptionValuesRequest, ...dcerpc.CallOption) (*GetAllOptionValuesResponse, error)

	// The R_DhcpGetMCastMibInfo method retrieves the multicast counter values of the MADCAP
	// server. The caller of this function can free the memory pointed to by MibInfo by
	// calling the function midl_user_free (section 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+--------------------------+--------------------------+
	//	|          RETURN          |                          |
	//	|        VALUE/CODE        |       DESCRIPTION        |
	//	|                          |                          |
	//	+--------------------------+--------------------------+
	//	+--------------------------+--------------------------+
	//	| 0x00000000 ERROR_SUCCESS | The call was successful. |
	//	+--------------------------+--------------------------+
	//
	// The opnum field value for this method is 31.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	GetMCastMIBInfo(context.Context, *GetMCastMIBInfoRequest, ...dcerpc.CallOption) (*GetMCastMIBInfoResponse, error)

	// The R_DhcpAuditLogSetParams method sets/modifies the DHCP server setting related
	// to the audit log.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+--------------------------+--------------------------+
	//	|          RETURN          |                          |
	//	|        VALUE/CODE        |       DESCRIPTION        |
	//	|                          |                          |
	//	+--------------------------+--------------------------+
	//	+--------------------------+--------------------------+
	//	| 0x00000000 ERROR_SUCCESS | The call was successful. |
	//	+--------------------------+--------------------------+
	//
	// The opnum field value for this method is 32.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	AuditLogSetParams(context.Context, *AuditLogSetParamsRequest, ...dcerpc.CallOption) (*AuditLogSetParamsResponse, error)

	// The R_DhcpAuditLogGetParams method retrieves all audit log–related settings from
	// the DHCP server.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+---------------------------------+-------------------------------------------------------------+
	//	|             RETURN              |                                                             |
	//	|           VALUE/CODE            |                         DESCRIPTION                         |
	//	|                                 |                                                             |
	//	+---------------------------------+-------------------------------------------------------------+
	//	+---------------------------------+-------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS        | The call was successful.                                    |
	//	+---------------------------------+-------------------------------------------------------------+
	//	| 0x00004E2D ERROR_DHCP_JET_ERROR | An error occurred while accessing the DHCP server database. |
	//	+---------------------------------+-------------------------------------------------------------+
	//
	// The opnum field value for this method is 33.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	AuditLogGetParams(context.Context, *AuditLogGetParamsRequest, ...dcerpc.CallOption) (*AuditLogGetParamsResponse, error)

	// The R_DhcpServerQueryAttribute method retrieves attribute information from the DHCP
	// server. The caller of this function can free the memory pointed to by pDhcpAttrib
	// by calling the function midl_user_free (section 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+---------------------------------+-------------------------------------------------------------+
	//	|             RETURN              |                                                             |
	//	|           VALUE/CODE            |                         DESCRIPTION                         |
	//	|                                 |                                                             |
	//	+---------------------------------+-------------------------------------------------------------+
	//	+---------------------------------+-------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS        | The call was successful.                                    |
	//	+---------------------------------+-------------------------------------------------------------+
	//	| 0x00004E2D ERROR_DHCP_JET_ERROR | An error occurred while accessing the DHCP server database. |
	//	+---------------------------------+-------------------------------------------------------------+
	//
	// The opnum field value for this method is 34.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	ServerQueryAttribute(context.Context, *ServerQueryAttributeRequest, ...dcerpc.CallOption) (*ServerQueryAttributeResponse, error)

	// The R_DhcpServerQueryAttributes method retrieves one or more attributes information
	// from the DHCP server. The caller of this function can free the memory pointed to
	// by pDhcpAttribArr and pDhcpAttribs by calling the function midl_user_free (section
	// 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+--------------------------+--------------------------+
	//	|          RETURN          |                          |
	//	|        VALUE/CODE        |       DESCRIPTION        |
	//	|                          |                          |
	//	+--------------------------+--------------------------+
	//	+--------------------------+--------------------------+
	//	| 0x00000000 ERROR_SUCCESS | The call was successful. |
	//	+--------------------------+--------------------------+
	//
	// The opnum field value for this method is 35.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	ServerQueryAttributes(context.Context, *ServerQueryAttributesRequest, ...dcerpc.CallOption) (*ServerQueryAttributesResponse, error)

	// The R_DhcpServerRedoAuthorization method attempts to determine whether the DHCP server
	// is authorized and restores the leasing operation if the server is not authorized.
	// The rogue detection mechanism is outlined in [MS-DHCPE] (section 3.3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+--------------------------+--------------------------+
	//	|          RETURN          |                          |
	//	|        VALUE/CODE        |       DESCRIPTION        |
	//	|                          |                          |
	//	+--------------------------+--------------------------+
	//	+--------------------------+--------------------------+
	//	| 0x00000000 ERROR_SUCCESS | The call was successful. |
	//	+--------------------------+--------------------------+
	//
	// The opnum field value for this method is 36.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	ServerRedoAuthorization(context.Context, *ServerRedoAuthorizationRequest, ...dcerpc.CallOption) (*ServerRedoAuthorizationResponse, error)

	// The R_DhcpAddSubnetElementV5 method adds an IPv4 subnet element to the specified
	// IPv4 subnet defined on the DHCPv4 server. The subnet elements can be IPv4 reservation
	// for DHCPv4 or BOOTP clients, IPv4 range, or the IPv4 exclusion range for DHCPv4 or
	// BOOTP clients.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+
	//	|                       RETURN                       |                                                                                  |
	//	|                     VALUE/CODE                     |                                   DESCRIPTION                                    |
	//	|                                                    |                                                                                  |
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                           | The call was successful.                                                         |
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E25 ERROR_DHCP_SUBNET_NOT_PRESENT           | The specified IPv4 subnet does not exist on the DHCP server.                     |
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E2D ERROR_DHCP_JET_ERROR                    | An error occurred while accessing the DHCP server database.                      |
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E32 ERROR_DHCP_NOT_RESERVED_CLIENT          | The specified DHCP client is not an IPv4-reserved client.                        |
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E36 ERROR_DHCP_RESERVEDIP_EXITS             | The specified IPv4 address or hardware address is being used by another DHCP     |
	//	|                                                    | client.                                                                          |
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E37 ERROR_DHCP_INVALID_RANGE                | The specified IPv4 range either overlaps an existing range or is not valid.      |
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E51 ERROR_DHCP_IPRANGE_CONV_ILLEGAL         | Conversion of a scope to a DHCP-only scope or to a BOOTP-only scope is not       |
	//	|                                                    | allowed when DHCP and BOOTP clients both exist in the scope. Manually delete     |
	//	|                                                    | either the DHCP or the BOOTP clients from the scope, as appropriate for the type |
	//	|                                                    | of scope being created.                                                          |
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E90 ERROR_SCOPE_RANGE_POLICY_RANGE_CONFLICT | There is an IP range configured for a policy in this scope. This operation on    |
	//	|                                                    | the scope IP address range cannot be performed until the policy IP address range |
	//	|                                                    | is suitably modified.                                                            |
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004EA1 ERROR_DHCP_FO_IPRANGE_TYPE_CONV_ILLEGAL | Conversion of a failover scope to a scope of type BOOTP or BOTH could not be     |
	//	|                                                    | performed. Failover is supported only for DHCP scopes.                           |
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 37.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	AddSubnetElementV5(context.Context, *AddSubnetElementV5Request, ...dcerpc.CallOption) (*AddSubnetElementV5Response, error)

	// The R_DhcpEnumSubnetElementsV5 method enumerates the list of a specific type of IPv4
	// subnet element from the specified IPv4 subnet. The caller of this function can free
	// the memory pointed to by EnumElementInfo and the Elements field of EnumElementInfo
	// by calling the function midl_user_free (section 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+------------------------------------------+--------------------------------------------------------------+
	//	|                  RETURN                  |                                                              |
	//	|                VALUE/CODE                |                         DESCRIPTION                          |
	//	|                                          |                                                              |
	//	+------------------------------------------+--------------------------------------------------------------+
	//	+------------------------------------------+--------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                 | The call was successful.                                     |
	//	+------------------------------------------+--------------------------------------------------------------+
	//	| 0x000000EA ERROR_MORE_DATA               | There are more elements available to enumerate.              |
	//	+------------------------------------------+--------------------------------------------------------------+
	//	| 0x00000103 ERROR_NO_MORE_ITEMS           | There are no more elements left to enumerate.                |
	//	+------------------------------------------+--------------------------------------------------------------+
	//	| 0x00004E25 ERROR_DHCP_SUBNET_NOT_PRESENT | The specified IPv4 subnet does not exist on the DHCP server. |
	//	+------------------------------------------+--------------------------------------------------------------+
	//
	// The opnum field value for this method is 38.
	//
	// Exceptions Thrown: No exceptions SHOULD be thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	EnumSubnetElementsV5(context.Context, *EnumSubnetElementsV5Request, ...dcerpc.CallOption) (*EnumSubnetElementsV5Response, error)

	// The R_DhcpRemoveSubnetElementV5 method removes an IPv4 subnet element from the specified
	// IPv4 subnet defined on the DHCPv4 server. The subnet elements can be IPv4 reservation
	// for DHCPv4 or BOOTP clients, IPv4 range, or IPv4 exclusion range for DHCPv4 or BOOTP
	// clients.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value of ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+
	//	|                       RETURN                       |                                                                                  |
	//	|                     VALUE/CODE                     |                                   DESCRIPTION                                    |
	//	|                                                    |                                                                                  |
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                           | The call was successful.                                                         |
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E25 ERROR_DHCP_SUBNET_NOT_PRESENT           | The specified IPv4 subnet does not exist.                                        |
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E27 ERROR_DHCP_ELEMENT_CANT_REMOVE          | This error can occur for any of the following reasons: The specified IPv4 subnet |
	//	|                                                    | element cannot be removed because at least one IPv4 address has been leased out  |
	//	|                                                    | to a client in the subnet. The starting address of the specified IPv4 exclusion  |
	//	|                                                    | range is not part of any exclusion range configured on the server. There is an   |
	//	|                                                    | error in deleting the exclusion range from the database.                         |
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E2D ERROR_DHCP_JET_ERROR                    | An error occurred while accessing the DHCP server database.                      |
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E37 ERROR_DHCP_INVALID_RANGE                | The specified IPv4 range does not match an existing IPv4 range.                  |
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E90 ERROR_SCOPE_RANGE_POLICY_RANGE_CONFLICT | There is an IP address range configured for a policy in this scope. This         |
	//	|                                                    | operation on the scope IP address range cannot be performed until the policy IP  |
	//	|                                                    | address range is suitably modified.                                              |
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 39.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	RemoveSubnetElementV5(context.Context, *RemoveSubnetElementV5Request, ...dcerpc.CallOption) (*RemoveSubnetElementV5Response, error)

	// The R_DhcpGetServerBindingInfo method retrieves the array of IPv4 interface binding
	// information for the DHCPv4 server. The caller of this function can free the memory
	// pointed by BindElementsInfo by calling the function midl_user_free (section 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+--------------------------+--------------------------+
	//	|          RETURN          |                          |
	//	|        VALUE/CODE        |       DESCRIPTION        |
	//	|                          |                          |
	//	+--------------------------+--------------------------+
	//	+--------------------------+--------------------------+
	//	| 0x00000000 ERROR_SUCCESS | The call was successful. |
	//	+--------------------------+--------------------------+
	//
	// The opnum field value for this method is 40.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	GetServerBindingInfo(context.Context, *GetServerBindingInfoRequest, ...dcerpc.CallOption) (*GetServerBindingInfoResponse, error)

	// The R_DhcpSetServerBindingInfo method sets/modifies the IPv4 interface bindings for
	// the DHCPv4 server.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	|                    RETURN                    |                                                                                  |
	//	|                  VALUE/CODE                  |                                   DESCRIPTION                                    |
	//	|                                              |                                                                                  |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                     | The call was successful.                                                         |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E52 ERROR_DHCP_NETWORK_CHANGED        | The network has changed. Retry this operation after checking for the network     |
	//	|                                              | changes. Network changes can be caused by interfaces that are new or no longer   |
	//	|                                              | valid, or by IPv4 addresses that are new or no longer valid.                     |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E53 ERROR_DHCP_CANNOT_MODIFY_BINDINGS | The bindings to internal IPv4 addresses cannot be modified.                      |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 41.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	SetServerBindingInfo(context.Context, *SetServerBindingInfoRequest, ...dcerpc.CallOption) (*SetServerBindingInfoResponse, error)

	// The R_DhcpQueryDnsRegCredentials method retrieves the currently set Domain Name System
	// (DNS) credentials, which are the user name and domain. These credentials are used
	// by the DHCP server for DNS dynamic registration for DHCP clients.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+--------------------------+--------------------------+
	//	|          RETURN          |                          |
	//	|        VALUE/CODE        |       DESCRIPTION        |
	//	|                          |                          |
	//	+--------------------------+--------------------------+
	//	+--------------------------+--------------------------+
	//	| 0x00000000 ERROR_SUCCESS | The call was successful. |
	//	+--------------------------+--------------------------+
	//
	// The opnum field value for this method is 42.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	QueryDNSRegCredentials(context.Context, *QueryDNSRegCredentialsRequest, ...dcerpc.CallOption) (*QueryDNSRegCredentialsResponse, error)

	// The R_DhcpSetDnsRegCredentials method sets the DNS user name and credentials in the
	// DHCP server which is used for DNS registrations for the DHCP client lease record.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+--------------------------+--------------------------+
	//	|          RETURN          |                          |
	//	|        VALUE/CODE        |       DESCRIPTION        |
	//	|                          |                          |
	//	+--------------------------+--------------------------+
	//	+--------------------------+--------------------------+
	//	| 0x00000000 ERROR_SUCCESS | The call was successful. |
	//	+--------------------------+--------------------------+
	//
	// The opnum field value for this method is 43.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	SetDNSRegCredentials(context.Context, *SetDNSRegCredentialsRequest, ...dcerpc.CallOption) (*SetDNSRegCredentialsResponse, error)

	// The R_DhcpBackupDatabase method takes backup of the configurations, settings, and
	// DHCP client lease record in the specified path.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+---------------------------------+-------------------------------------------------------------+
	//	|             RETURN              |                                                             |
	//	|           VALUE/CODE            |                         DESCRIPTION                         |
	//	|                                 |                                                             |
	//	+---------------------------------+-------------------------------------------------------------+
	//	+---------------------------------+-------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS        | The call was successful.                                    |
	//	+---------------------------------+-------------------------------------------------------------+
	//	| 0x00004E2D ERROR_DHCP_JET_ERROR | An error occurred while accessing the DHCP server database. |
	//	+---------------------------------+-------------------------------------------------------------+
	//
	// The opnum field value for this method is 44.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	BackupDatabase(context.Context, *BackupDatabaseRequest, ...dcerpc.CallOption) (*BackupDatabaseResponse, error)

	// The R_DhcpRestoreDatabase method sets/modifies the restore path. The DHCP server
	// uses this path to restore the configuration, settings, and DHCP client lease record
	// the next time it is restarted.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+---------------------------------+----------------------------------------------------+
	//	|             RETURN              |                                                    |
	//	|           VALUE/CODE            |                    DESCRIPTION                     |
	//	|                                 |                                                    |
	//	+---------------------------------+----------------------------------------------------+
	//	+---------------------------------+----------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS        | The call was successful.                           |
	//	+---------------------------------+----------------------------------------------------+
	//	| 0x00004E2D ERROR_DHCP_JET_ERROR | An error occurred while accessing the DHCP server. |
	//	+---------------------------------+----------------------------------------------------+
	//
	// The opnum field value for this method is 45.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	RestoreDatabase(context.Context, *RestoreDatabaseRequest, ...dcerpc.CallOption) (*RestoreDatabaseResponse, error)

	// The R_DhcpGetServerSpecificStrings method retrieves the names of the default vendor
	// class and user class. The caller of this function can free the memory pointed to
	// by ServerSpecificStrings, DefaultVendorClassName and DefaultUserClassName by calling
	// the function midl_user_free (section 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+---------------------------------+-------------------------------------------------------------+
	//	|             RETURN              |                                                             |
	//	|           VALUE/CODE            |                         DESCRIPTION                         |
	//	|                                 |                                                             |
	//	+---------------------------------+-------------------------------------------------------------+
	//	+---------------------------------+-------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS        | The call was successful.                                    |
	//	+---------------------------------+-------------------------------------------------------------+
	//	| 0x00004E2D ERROR_DHCP_JET_ERROR | An error occurred while accessing the DHCP server database. |
	//	+---------------------------------+-------------------------------------------------------------+
	//
	// The opnum field value for this method is 46.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	GetServerSpecificStrings(context.Context, *GetServerSpecificStringsRequest, ...dcerpc.CallOption) (*GetServerSpecificStringsResponse, error)

	// The R_DhcpCreateOptionV6 method creates an option definition for a specified user
	// class or vendor class at the default option level. The option ID specifies the identifier
	// of the option. If the user class or vendor class is not specified, the option definition
	// is created for the default user class or vendor class.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+--------------------------------------------------+----------------------------------------------------------------------------------+
	//	|                      RETURN                      |                                                                                  |
	//	|                    VALUE/CODE                    |                                   DESCRIPTION                                    |
	//	|                                                  |                                                                                  |
	//	+--------------------------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                         | The call was successful.                                                         |
	//	+--------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E29 ERROR_DHCP_OPTION_EXITS               | The specified option definition already exists in the DHCP server database.      |
	//	+--------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E2D ERROR_DHCP_JET_ERROR                  | An error occurred while accessing the DHCP server database.                      |
	//	+--------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E59 ERROR_DHCP_INVALID_PARAMETER_OPTION32 | The information refresh time option value is invalid, as it is less than the     |
	//	|                                                  | minimum option value.                                                            |
	//	+--------------------------------------------------+----------------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 47.
	CreateOptionV6(context.Context, *CreateOptionV6Request, ...dcerpc.CallOption) (*CreateOptionV6Response, error)

	// The R_DhcpSetOptionInfoV6 method modifies the option definition for the specific
	// user class and vendor class at the default level. If the user class or vendor class
	// is not specified, the default user class or vendor class will be used.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+--------------------------------------------------+----------------------------------------------------------------------------------+
	//	|                      RETURN                      |                                                                                  |
	//	|                    VALUE/CODE                    |                                   DESCRIPTION                                    |
	//	|                                                  |                                                                                  |
	//	+--------------------------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                         | The call was successful.                                                         |
	//	+--------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E2A ERROR_DHCP_OPTION_NOT_PRESENT         | The option to be modified does not exist.                                        |
	//	+--------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E2D ERROR_DHCP_JET_ERROR                  | An error occurred while accessing the DHCP server database.                      |
	//	+--------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E59 ERROR_DHCP_INVALID_PARAMETER_OPTION32 | The information refresh time option value is invalid, as it is less than the     |
	//	|                                                  | minimum option value.                                                            |
	//	+--------------------------------------------------+----------------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 48.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	SetOptionInfoV6(context.Context, *SetOptionInfoV6Request, ...dcerpc.CallOption) (*SetOptionInfoV6Response, error)

	// The R_DhcpGetOptionInfoV6 method retrieves the option definition of a specific option
	// for a specific user class and vendor class at the default option level. If the user
	// class or vendor class is not specified, the default vendor class or user class will
	// be taken. The caller of this function can free the memory pointed to by OptionInfo
	// by calling the function midl_user_free (section 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+------------------------------------------+-------------------------------------------+
	//	|                  RETURN                  |                                           |
	//	|                VALUE/CODE                |                DESCRIPTION                |
	//	|                                          |                                           |
	//	+------------------------------------------+-------------------------------------------+
	//	+------------------------------------------+-------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                 | The call was successful.                  |
	//	+------------------------------------------+-------------------------------------------+
	//	| 0x00004E2A ERROR_DHCP_OPTION_NOT_PRESENT | The option to be modified does not exist. |
	//	+------------------------------------------+-------------------------------------------+
	//
	// The opnum field value for this method is 49.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	GetOptionInfoV6(context.Context, *GetOptionInfoV6Request, ...dcerpc.CallOption) (*GetOptionInfoV6Response, error)

	// The R_DhcpEnumOptionsV6 method enumerates the option definitions for a specific user
	// class and vendor class at the default option level. If the user class or vendor class
	// is not specified, the default user class or vendor class will be used. The caller
	// of this function can free the memory pointed to by Options by calling the function
	// midl_user_free (section 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+--------------------------------+-------------------------------------------------+
	//	|             RETURN             |                                                 |
	//	|           VALUE/CODE           |                   DESCRIPTION                   |
	//	|                                |                                                 |
	//	+--------------------------------+-------------------------------------------------+
	//	+--------------------------------+-------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS       | The call was successful.                        |
	//	+--------------------------------+-------------------------------------------------+
	//	| 0x000000EA ERROR_MORE_DATA     | There are more elements available to enumerate. |
	//	+--------------------------------+-------------------------------------------------+
	//	| 0x00000103 ERROR_NO_MORE_ITEMS | There are no more elements left to enumerate.   |
	//	+--------------------------------+-------------------------------------------------+
	//
	// The opnum field value for this method is 50.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	EnumOptionsV6(context.Context, *EnumOptionsV6Request, ...dcerpc.CallOption) (*EnumOptionsV6Response, error)

	// The R_DhcpRemoveOptionV6 method removes the option definition of a specific option
	// for a specific user class or the vendor class at the default option level. If the
	// user class or the vendor class is not specified, the default user class or vendor
	// class will be used. The option id specifies the identifier of the option definition.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+------------------------------------------+-------------------------------------------+
	//	|                  RETURN                  |                                           |
	//	|                VALUE/CODE                |                DESCRIPTION                |
	//	|                                          |                                           |
	//	+------------------------------------------+-------------------------------------------+
	//	+------------------------------------------+-------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                 | The call was successful.                  |
	//	+------------------------------------------+-------------------------------------------+
	//	| 0x00004E2A ERROR_DHCP_OPTION_NOT_PRESENT | The option to be modified does not exist. |
	//	+------------------------------------------+-------------------------------------------+
	//
	// The opnum field value for this method is 51.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	RemoveOptionV6(context.Context, *RemoveOptionV6Request, ...dcerpc.CallOption) (*RemoveOptionV6Response, error)

	// The R_DhcpSetOptionValueV6 method creates option value when called for the first
	// time, else it modifies the option value of a specific option on the DHCPv6 server
	// for a specific user class and vendor class. ScopeInfo defines the scope on which
	// this option value is set. If the user class and vendor class is not provided, the
	// default user class and vendor class is taken.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+--------------------------------------------------+----------------------------------------------------------------------------------+
	//	|                      RETURN                      |                                                                                  |
	//	|                    VALUE/CODE                    |                                   DESCRIPTION                                    |
	//	|                                                  |                                                                                  |
	//	+--------------------------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                         | The call was successful.                                                         |
	//	+--------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E2A ERROR_DHCP_OPTION_NOT_PRESENT         | The option to be modified does not exist.                                        |
	//	+--------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E59 ERROR_DHCP_INVALID_PARAMETER_OPTION32 | The information refresh time option value is invalid, as it is less than the     |
	//	|                                                  | minimum option value.                                                            |
	//	+--------------------------------------------------+----------------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 52.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	SetOptionValueV6(context.Context, *SetOptionValueV6Request, ...dcerpc.CallOption) (*SetOptionValueV6Response, error)

	// The R_DhcpEnumOptionValuesV6 method enumerates all the option values for the specific
	// user class or vendor class at a specified scope defined by ScopeInfo. If the user
	// class or vendor class is not specified, the default user class or vendor class will
	// be used. The caller of this function can free the memory pointed to by OptionValues
	// and the Values member of OptionValues by calling the function midl_user_free (section
	// 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+--------------------------------+-------------------------------------------------+
	//	|             RETURN             |                                                 |
	//	|           VALUE/CODE           |                   DESCRIPTION                   |
	//	|                                |                                                 |
	//	+--------------------------------+-------------------------------------------------+
	//	+--------------------------------+-------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS       | The call was successful.                        |
	//	+--------------------------------+-------------------------------------------------+
	//	| 0x000000EA ERROR_MORE_DATA     | There are more elements available to enumerate. |
	//	+--------------------------------+-------------------------------------------------+
	//	| 0x00000103 ERROR_NO_MORE_ITEMS | There are no more elements left to enumerate.   |
	//	+--------------------------------+-------------------------------------------------+
	//
	// The opnum field value for this method is 53.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	EnumOptionValuesV6(context.Context, *EnumOptionValuesV6Request, ...dcerpc.CallOption) (*EnumOptionValuesV6Response, error)

	// The R_DhcpRemoveOptionValueV6 method deletes the option value of a specific option
	// on the DHCPv6 server for a specific user and vendor class. ScopeInfo defines the
	// scope from which this option value is removed. If the user class or vendor class
	// is not provided, the default user or vendor class is taken.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+------------------------------------------+--------------------------------------+
	//	|                  RETURN                  |                                      |
	//	|                VALUE/CODE                |             DESCRIPTION              |
	//	|                                          |                                      |
	//	+------------------------------------------+--------------------------------------+
	//	+------------------------------------------+--------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                 | The call was successful.             |
	//	+------------------------------------------+--------------------------------------+
	//	| 0x00004E2A ERROR_DHCP_OPTION_NOT_PRESENT | The specified option does not exist. |
	//	+------------------------------------------+--------------------------------------+
	//
	// The opnum field value for this method is 54.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	RemoveOptionValueV6(context.Context, *RemoveOptionValueV6Request, ...dcerpc.CallOption) (*RemoveOptionValueV6Response, error)

	// The R_DhcpGetAllOptionsV6 method retrieves all default option definitions, as well
	// as specific user class and vendor class option definitions. The caller of this function
	// can free the memory pointed to by OptionStruct, NonVendorOptions and VendorOptions
	// and by calling the function midl_user_free (section 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+--------------------------+--------------------------+
	//	|          RETURN          |                          |
	//	|        VALUE/CODE        |       DESCRIPTION        |
	//	|                          |                          |
	//	+--------------------------+--------------------------+
	//	+--------------------------+--------------------------+
	//	| 0x00000000 ERROR_SUCCESS | The call was successful. |
	//	+--------------------------+--------------------------+
	//
	// The opnum field value for this method is 55.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	GetAllOptionsV6(context.Context, *GetAllOptionsV6Request, ...dcerpc.CallOption) (*GetAllOptionsV6Response, error)

	// The R_DhcpGetAllOptionValuesV6 method returns all option values for all user classes
	// and vendor classes configured at the server, scope, or IPv6 reservation level on
	// the DHCPv6 server. The caller of this function can free the memory pointed to by
	// option Values by calling the function midl_user_free (section 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+--------------------------+--------------------------+
	//	|          RETURN          |                          |
	//	|        VALUE/CODE        |       DESCRIPTION        |
	//	|                          |                          |
	//	+--------------------------+--------------------------+
	//	+--------------------------+--------------------------+
	//	| 0x00000000 ERROR_SUCCESS | The call was successful. |
	//	+--------------------------+--------------------------+
	//
	// The opnum field value for this method is 56.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	GetAllOptionValuesV6(context.Context, *GetAllOptionValuesV6Request, ...dcerpc.CallOption) (*GetAllOptionValuesV6Response, error)

	// The R_DhcpCreateSubnetV6 method creates a new IPv6 prefix on the DHCPv6 server.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+---------------------------------------------+-------------------------------------------------------------+
	//	|                   RETURN                    |                                                             |
	//	|                 VALUE/CODE                  |                         DESCRIPTION                         |
	//	|                                             |                                                             |
	//	+---------------------------------------------+-------------------------------------------------------------+
	//	+---------------------------------------------+-------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                    | The call was successful.                                    |
	//	+---------------------------------------------+-------------------------------------------------------------+
	//	| 0x00004E2D ERROR_DHCP_JET_ERROR             | An error occurred while accessing the DHCP server database. |
	//	+---------------------------------------------+-------------------------------------------------------------+
	//	| 0x00004E7B ERROR_DHCP_INVALID_SUBNET_PREFIX | The subnet prefix is invalid.                               |
	//	+---------------------------------------------+-------------------------------------------------------------+
	//
	// The opnum field value for this method is 57.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	CreateSubnetV6(context.Context, *CreateSubnetV6Request, ...dcerpc.CallOption) (*CreateSubnetV6Response, error)

	// The R_DhcpEnumSubnetsV6 method enumerates all IPv6 prefixes configured on the DHCPv6
	// server. The caller of this function can free the memory pointed to by EnumInfo by
	// calling the function midl_user_free (section 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+--------------------------------+-----------------------------------------------+
	//	|             RETURN             |                                               |
	//	|           VALUE/CODE           |                  DESCRIPTION                  |
	//	|                                |                                               |
	//	+--------------------------------+-----------------------------------------------+
	//	+--------------------------------+-----------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS       | The call was successful.                      |
	//	+--------------------------------+-----------------------------------------------+
	//	| 0x00000103 ERROR_NO_MORE_ITEMS | There are no more elements left to enumerate. |
	//	+--------------------------------+-----------------------------------------------+
	//
	// The opnum field value for this method is 58.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	EnumSubnetsV6(context.Context, *EnumSubnetsV6Request, ...dcerpc.CallOption) (*EnumSubnetsV6Response, error)

	// The R_DhcpAddSubnetElementV6 method adds an IPv6 prefix element (such as IPv6 reservation
	// or IPv6 exclusion range) to the IPv6 prefix in the DHCPv6 server.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	|                 RETURN                 |                                                                                  |
	//	|               VALUE/CODE               |                                   DESCRIPTION                                    |
	//	|                                        |                                                                                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS               | The call was successful.                                                         |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER     | An invalid parameter is specified in the AddElementInfo parameter.               |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000007DE ERROR_DUPLICATE_TAG         | The specified exclusion range conflicts with existing exclusion ranges.          |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E2D ERROR_DHCP_JET_ERROR        | An error occurred while accessing the DHCP server database.                      |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E36 ERROR_DHCP_RESERVEDIP_EXITS | An IPv6 reservation exists for one or both of the following: the specified       |
	//	|                                        | IPv6 address the DHCPv6 client-identifier (section 2.2.1.2.5.3) and interface    |
	//	|                                        | identifier pair specified in reservation information                             |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 59.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	AddSubnetElementV6(context.Context, *AddSubnetElementV6Request, ...dcerpc.CallOption) (*AddSubnetElementV6Response, error)

	// The R_DhcpEnumSubnetElementsV6 method returns an enumerated list of a specific type
	// of IPv6 prefix element for a specific DHCPv6 IPv6 prefix. The caller of this function
	// can free the memory pointed to by EnumElementInfo and other Elements by calling the
	// function midl_user_free (section 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+--------------------------------+-------------------------------------------------+
	//	|             RETURN             |                                                 |
	//	|           VALUE/CODE           |                   DESCRIPTION                   |
	//	|                                |                                                 |
	//	+--------------------------------+-------------------------------------------------+
	//	+--------------------------------+-------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS       | The call was successful.                        |
	//	+--------------------------------+-------------------------------------------------+
	//	| 0x000000EA ERROR_MORE_DATA     | There are more elements available to enumerate. |
	//	+--------------------------------+-------------------------------------------------+
	//	| 0x00000103 ERROR_NO_MORE_ITEMS | There are no more elements left to enumerate.   |
	//	+--------------------------------+-------------------------------------------------+
	//
	// The opnum field value for this method is 60.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	EnumSubnetElementsV6(context.Context, *EnumSubnetElementsV6Request, ...dcerpc.CallOption) (*EnumSubnetElementsV6Response, error)

	// The R_DhcpRemoveSubnetElementV6 method removes an IPv6 prefix element (such as IPv6
	// reservation or IPv6 exclusion range) from an IPv6 prefix defined on the DHCPv6 server.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+---------------------------------+-------------------------------------------------------------+
	//	|             RETURN              |                                                             |
	//	|           VALUE/CODE            |                         DESCRIPTION                         |
	//	|                                 |                                                             |
	//	+---------------------------------+-------------------------------------------------------------+
	//	+---------------------------------+-------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS        | The call was successful.                                    |
	//	+---------------------------------+-------------------------------------------------------------+
	//	| 0x00004E2D ERROR_DHCP_JET_ERROR | An error occurred while accessing the DHCP server database. |
	//	+---------------------------------+-------------------------------------------------------------+
	//
	// The opnum field value for this method is 61.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	RemoveSubnetElementV6(context.Context, *RemoveSubnetElementV6Request, ...dcerpc.CallOption) (*RemoveSubnetElementV6Response, error)

	// The R_DhcpDeleteSubnetV6 method deletes an IPv6 prefix from the DHCPv6 server.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	|                  RETURN                   |                                                                                  |
	//	|                VALUE/CODE                 |                                   DESCRIPTION                                    |
	//	|                                           |                                                                                  |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                  | The call was successful.                                                         |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E2D ERROR_DHCP_JET_ERROR           | An error occurred while accessing the DHCP server database.                      |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E27 ERROR_DHCP_ELEMENT_CANT_REMOVE | The specified subnet cannot be deleted because at least one IPv6 address has     |
	//	|                                           | been leased out to some client from the subnet.                                  |
	//	+-------------------------------------------+----------------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 62.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	DeleteSubnetV6(context.Context, *DeleteSubnetV6Request, ...dcerpc.CallOption) (*DeleteSubnetV6Response, error)

	// The R_DhcpGetSubnetInfoV6 method retrieves the information about a specific IPv6
	// prefix defined on the DHCPv6 server. The caller of this function can free the memory
	// pointed to by SubnetInfo by calling the function midl_user_free (section 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+------------------------------------------+-------------------------------------------+
	//	|                  RETURN                  |                                           |
	//	|                VALUE/CODE                |                DESCRIPTION                |
	//	|                                          |                                           |
	//	+------------------------------------------+-------------------------------------------+
	//	+------------------------------------------+-------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                 | The call was successful.                  |
	//	+------------------------------------------+-------------------------------------------+
	//	| 0x00004E25 ERROR_DHCP_SUBNET_NOT_PRESENT | The specified IPv6 prefix does not exist. |
	//	+------------------------------------------+-------------------------------------------+
	//
	// The opnum field value for this method is 63.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	GetSubnetInfoV6(context.Context, *GetSubnetInfoV6Request, ...dcerpc.CallOption) (*GetSubnetInfoV6Response, error)

	// The R_DhcpEnumSubnetClientsV6 method is used to retrieve all DHCPv6 clients serviced
	// from the specified IPv6 prefix. The caller of this function can free the memory pointed
	// to by ClientInfo and other Elements by calling the function midl_user_free (section
	// 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+---------------------------------+-------------------------------------------------------------+
	//	|             RETURN              |                                                             |
	//	|           VALUE/CODE            |                         DESCRIPTION                         |
	//	|                                 |                                                             |
	//	+---------------------------------+-------------------------------------------------------------+
	//	+---------------------------------+-------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS        | The call was successful.                                    |
	//	+---------------------------------+-------------------------------------------------------------+
	//	| 0x000000EA ERROR_MORE_DATA      | There are more elements available to enumerate.             |
	//	+---------------------------------+-------------------------------------------------------------+
	//	| 0x00000103 ERROR_NO_MORE_ITEMS  | There are no more elements left to enumerate.               |
	//	+---------------------------------+-------------------------------------------------------------+
	//	| 0x00004E2D ERROR_DHCP_JET_ERROR | An error occurred while accessing the DHCP server database. |
	//	+---------------------------------+-------------------------------------------------------------+
	//
	// The opnum field value for this method is 64.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	EnumSubnetClientsV6(context.Context, *EnumSubnetClientsV6Request, ...dcerpc.CallOption) (*EnumSubnetClientsV6Response, error)

	// The R_DhcpServerSetConfigV6 method sets the DHCPv6 server configuration data at the
	// scope level or at the server level.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+---------------------------------+-------------------------------------------------------------+
	//	|             RETURN              |                                                             |
	//	|           VALUE/CODE            |                         DESCRIPTION                         |
	//	|                                 |                                                             |
	//	+---------------------------------+-------------------------------------------------------------+
	//	+---------------------------------+-------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS        | The call was successful.                                    |
	//	+---------------------------------+-------------------------------------------------------------+
	//	| 0x00004E2D ERROR_DHCP_JET_ERROR | An error occurred while accessing the DHCP server database. |
	//	+---------------------------------+-------------------------------------------------------------+
	//
	// The opnum field value for this method is 65.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	ServerSetConfigV6(context.Context, *ServerSetConfigV6Request, ...dcerpc.CallOption) (*ServerSetConfigV6Response, error)

	// The R_DhcpServerGetConfigV6 method retrieves the configuration information about
	// the DHCPv6 server.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+--------------------------+--------------------------+
	//	|          RETURN          |                          |
	//	|        VALUE/CODE        |       DESCRIPTION        |
	//	|                          |                          |
	//	+--------------------------+--------------------------+
	//	+--------------------------+--------------------------+
	//	| 0x00000000 ERROR_SUCCESS | The call was successful. |
	//	+--------------------------+--------------------------+
	//
	// The opnum field value for this method is 66.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	ServerGetConfigV6(context.Context, *ServerGetConfigV6Request, ...dcerpc.CallOption) (*ServerGetConfigV6Response, error)

	// The R_DhcpSetSubnetInfoV6 method sets/modifies the information for an IPv6 prefix
	// defined on the DHCPv6 server.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+------------------------------------------+-------------------------------------------------------------+
	//	|                  RETURN                  |                                                             |
	//	|                VALUE/CODE                |                         DESCRIPTION                         |
	//	|                                          |                                                             |
	//	+------------------------------------------+-------------------------------------------------------------+
	//	+------------------------------------------+-------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                 | The call was successful.                                    |
	//	+------------------------------------------+-------------------------------------------------------------+
	//	| 0x00004E25 ERROR_DHCP_SUBNET_NOT_PRESENT | The specified IPv6 prefix does not exist.                   |
	//	+------------------------------------------+-------------------------------------------------------------+
	//	| 0x00004E2D ERROR_DHCP_JET_ERROR          | An error occurred while accessing the DHCP server database. |
	//	+------------------------------------------+-------------------------------------------------------------+
	//
	// The opnum field value for this method is 67.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	SetSubnetInfoV6(context.Context, *SetSubnetInfoV6Request, ...dcerpc.CallOption) (*SetSubnetInfoV6Response, error)

	// The R_DhcpGetMibInfoV6 method is used to retrieve the IPv6 counter values of the
	// DHCPv6 server. The caller of this function can free the memory pointed to by MibInfo
	// by calling the function midl_user_free (section 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+--------------------------+--------------------------+
	//	|          RETURN          |                          |
	//	|        VALUE/CODE        |       DESCRIPTION        |
	//	|                          |                          |
	//	+--------------------------+--------------------------+
	//	+--------------------------+--------------------------+
	//	| 0x00000000 ERROR_SUCCESS | The call was successful. |
	//	+--------------------------+--------------------------+
	//
	// The opnum field value for this method is 68.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	GetMIBInfoV6(context.Context, *GetMIBInfoV6Request, ...dcerpc.CallOption) (*GetMIBInfoV6Response, error)

	// The R_DhcpGetServerBindingInfoV6 method retrieves the array of IPv6 interface binding
	// information for the DHCPv6 server. The caller of this function can free the memory
	// pointed to by BindElementsInfo by calling the function midl_user_free (section 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+--------------------------+--------------------------+
	//	|          RETURN          |                          |
	//	|        VALUE/CODE        |       DESCRIPTION        |
	//	|                          |                          |
	//	+--------------------------+--------------------------+
	//	+--------------------------+--------------------------+
	//	| 0x00000000 ERROR_SUCCESS | The call was successful. |
	//	+--------------------------+--------------------------+
	//
	// The opnum field value for this method is 69.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	GetServerBindingInfoV6(context.Context, *GetServerBindingInfoV6Request, ...dcerpc.CallOption) (*GetServerBindingInfoV6Response, error)

	// The R_DhcpSetServerBindingInfoV6 method sets/modifies the IPv6 interface bindings
	// for the DHCPv6 server.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//	|                   RETURN                    |                                                                                  |
	//	|                 VALUE/CODE                  |                                   DESCRIPTION                                    |
	//	|                                             |                                                                                  |
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                    | The call was successful.                                                         |
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E52 ERROR_DHCP_NETWORK_CHANGED       | The network has changed. Retry this operation after checking for the network     |
	//	|                                             | changes. Network changes can be caused by interfaces that are new or no longer   |
	//	|                                             | valid or by IPv6 addresses that are new or no longer valid.                      |
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E53 ERROR_DHCP_CANNOT_MODIFY_BINDING | The bindings to internal IPv6 addresses cannot be modified.                      |
	//	+---------------------------------------------+----------------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 70.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	SetServerBindingInfoV6(context.Context, *SetServerBindingInfoV6Request, ...dcerpc.CallOption) (*SetServerBindingInfoV6Response, error)

	// The R_DhcpSetClientInfoV6 method sets/modifies the client reservation record on the
	// DHCPv6 server database. This method is supposed to be called only after the reserved
	// DHCPv6 client is added using the R_DhcpAddSubnetElementV6 (section 3.2.4.60) method.<69>
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value of ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+--------------------------+--------------------------+
	//	|          RETURN          |                          |
	//	|        VALUE/CODE        |       DESCRIPTION        |
	//	|                          |                          |
	//	+--------------------------+--------------------------+
	//	+--------------------------+--------------------------+
	//	| 0x00000000 ERROR_SUCCESS | The call was successful. |
	//	+--------------------------+--------------------------+
	//
	// The opnum field value for this method is 71.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	SetClientInfoV6(context.Context, *SetClientInfoV6Request, ...dcerpc.CallOption) (*SetClientInfoV6Response, error)

	// The R_DhcpGetClientInfoV6 method retrieves IPv6 address lease information of the
	// IPv6 reservation from the DHCPv6 server. The caller of this function can free the
	// memory pointed to by ClientInfo by calling the function midl_user_free (section 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	|             RETURN              |                                                                                  |
	//	|           VALUE/CODE            |                                   DESCRIPTION                                    |
	//	|                                 |                                                                                  |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS        | The call was successful.                                                         |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E2D ERROR_DHCP_JET_ERROR | An error occurred while accessing the DHCP server database or the client entry   |
	//	|                                 | is not present in the database.                                                  |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 72.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	GetClientInfoV6(context.Context, *GetClientInfoV6Request, ...dcerpc.CallOption) (*GetClientInfoV6Response, error)

	// The R_DhcpDeleteClientInfoV6 method deletes the specified DHCPv6 client address lease
	// record from the DHCPv6 server database.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	|                 RETURN                  |                                                                                  |
	//	|               VALUE/CODE                |                                   DESCRIPTION                                    |
	//	|                                         |                                                                                  |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                | The call was successful.                                                         |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E2D ERROR_DHCP_JET_ERROR         | An error occurred while accessing the DHCP server database or the client entry   |
	//	|                                         | is not present in the database.                                                  |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E36 ERROR_DHCP_RESERVEDIP_EXISTS | There exists a reservation for the leased address.                               |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 73.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	DeleteClientInfoV6(context.Context, *DeleteClientInfoV6Request, ...dcerpc.CallOption) (*DeleteClientInfoV6Response, error)

	// The R_DhcpCreateClassV6 method creates an IPv6 user class or a vendor class definition
	// on the DHCPv6 server.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+--------------------------------------------+----------------------------------------------------------------------+
	//	|                   RETURN                   |                                                                      |
	//	|                 VALUE/CODE                 |                             DESCRIPTION                              |
	//	|                                            |                                                                      |
	//	+--------------------------------------------+----------------------------------------------------------------------+
	//	+--------------------------------------------+----------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                   | The call was successful.                                             |
	//	+--------------------------------------------+----------------------------------------------------------------------+
	//	| 0x00004E2D ERROR_DHCP_JET_ERROR            | An error occurred while accessing the DHCP server database.          |
	//	+--------------------------------------------+----------------------------------------------------------------------+
	//	| 0x00004E4D ERROR_DHCP_CLASS_ALREADY_EXISTS | The vendor class or user class that is being created already exists. |
	//	+--------------------------------------------+----------------------------------------------------------------------+
	//
	// The opnum field value for this method is 74.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	CreateClassV6(context.Context, *CreateClassV6Request, ...dcerpc.CallOption) (*CreateClassV6Response, error)

	// The R_DhcpModifyClassV6 method modifies the user class or vendor class definition
	// for the DHCPv6 server.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+---------------------------------+-------------------------------------------------------------+
	//	|             RETURN              |                                                             |
	//	|           VALUE/CODE            |                         DESCRIPTION                         |
	//	|                                 |                                                             |
	//	+---------------------------------+-------------------------------------------------------------+
	//	+---------------------------------+-------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS        | The call was successful.                                    |
	//	+---------------------------------+-------------------------------------------------------------+
	//	| 0x00004E2D ERROR_DHCP_JET_ERROR | An error occurred while accessing the DHCP server database. |
	//	+---------------------------------+-------------------------------------------------------------+
	//
	// The opnum field value for this method is 75.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	ModifyClassV6(context.Context, *ModifyClassV6Request, ...dcerpc.CallOption) (*ModifyClassV6Response, error)

	// The R_DhcpDeleteClassV6 method deletes the specified IPv6 user class or vendor class
	// definition from the DHCPv6 server.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+---------------------------------------+-------------------------------------------------------------+
	//	|                RETURN                 |                                                             |
	//	|              VALUE/CODE               |                         DESCRIPTION                         |
	//	|                                       |                                                             |
	//	+---------------------------------------+-------------------------------------------------------------+
	//	+---------------------------------------+-------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS              | The call was successful.                                    |
	//	+---------------------------------------+-------------------------------------------------------------+
	//	| 0x00004E2D ERROR_DHCP_JET_ERROR       | An error occurred while accessing the DHCP server database. |
	//	+---------------------------------------+-------------------------------------------------------------+
	//	| 0x00004E4C ERROR_DHCP_CLASS_NOT_FOUND | The specified class is not defined in the DHCP server.      |
	//	+---------------------------------------+-------------------------------------------------------------+
	//
	// The opnum field value for this method is 76.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	DeleteClassV6(context.Context, *DeleteClassV6Request, ...dcerpc.CallOption) (*DeleteClassV6Response, error)

	// The R_DhcpEnumClassesV6 method enumerates user or vendor classes configured for the
	// DHCPv6 server. The caller of this function can free the memory pointed to by ClassInfoArray
	// and its Classes member by calling the function midl_user_free (section 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+--------------------------------+-------------------------------------------------+
	//	|             RETURN             |                                                 |
	//	|           VALUE/CODE           |                   DESCRIPTION                   |
	//	|                                |                                                 |
	//	+--------------------------------+-------------------------------------------------+
	//	+--------------------------------+-------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS       | The call was successful.                        |
	//	+--------------------------------+-------------------------------------------------+
	//	| 0x000000EA ERROR_MORE_DATA     | There are more elements available to enumerate. |
	//	+--------------------------------+-------------------------------------------------+
	//	| 0x00000103 ERROR_NO_MORE_ITEMS | There are no more elements left to enumerate.   |
	//	+--------------------------------+-------------------------------------------------+
	//
	// The opnum field value for this method is 77.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	EnumClassesV6(context.Context, *EnumClassesV6Request, ...dcerpc.CallOption) (*EnumClassesV6Response, error)

	// The R_DhcpGetOptionValueV6 method retrieves the option value for a specific option
	// on the DHCPv6 server for specific user and vendor class. ScopeInfo defines the scope
	// from which the option value needs to be retrieved. The caller of this function can
	// free the memory pointed by OptionValue by calling the function midl_user_free (section
	// 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+-------------------------------------------+--------------------------------------------------------------------------------+
	//	|                  RETURN                   |                                                                                |
	//	|                VALUE/CODE                 |                                  DESCRIPTION                                   |
	//	|                                           |                                                                                |
	//	+-------------------------------------------+--------------------------------------------------------------------------------+
	//	+-------------------------------------------+--------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                  | The call was successful.                                                       |
	//	+-------------------------------------------+--------------------------------------------------------------------------------+
	//	| 0x00004E25 ERROR_DHCP_SUBNET_NOT_PRESENT  | The specified subnet is not defined on the DHCP server.                        |
	//	+-------------------------------------------+--------------------------------------------------------------------------------+
	//	| 0x00004E2A ERROR_DHCP_OPTION_NOT_PRESENT  | The specified option is not defined at the specified level in the DHCP server. |
	//	+-------------------------------------------+--------------------------------------------------------------------------------+
	//	| 0x00004E32 ERROR_DHCP_NOT_RESERVED_CLIENT | The reserved IPv6 client is not defined on the DHCP server.                    |
	//	+-------------------------------------------+--------------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 78.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	GetOptionValueV6(context.Context, *GetOptionValueV6Request, ...dcerpc.CallOption) (*GetOptionValueV6Response, error)

	// The R_DhcpSetSubnetDelayOffer method sets/modifies the time delay setting on the
	// DHCPv4 server, which is used in responding to a DHCPDISCOVER message [RFC2131]. This
	// setting is configured for a specific scope.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	|                  RETURN                  |                                                                                  |
	//	|                VALUE/CODE                |                                   DESCRIPTION                                    |
	//	|                                          |                                                                                  |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                 | The call was successful.                                                         |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E25 ERROR_DHCP_SUBNET_NOT_PRESENT | The specified subnet is not defined on the DHCP server.                          |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E7C ERROR_DHCP_INVALID_DELAY      | The specified delay value is invalid, it is greater than the maximum delay of    |
	//	|                                          | 1000 milliseconds.                                                               |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 79.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	SetSubnetDelayOffer(context.Context, *SetSubnetDelayOfferRequest, ...dcerpc.CallOption) (*SetSubnetDelayOfferResponse, error)

	// The R_DhcpGetSubnetDelayOffer method retrieves the time delay setting from the DHCPv4
	// server, which is used in responding to a DHCPDISCOVER message [RFC2131] for a specific
	// scope.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully;
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+------------------------------------------+---------------------------------------------------------+
	//	|                  RETURN                  |                                                         |
	//	|                VALUE/CODE                |                       DESCRIPTION                       |
	//	|                                          |                                                         |
	//	+------------------------------------------+---------------------------------------------------------+
	//	+------------------------------------------+---------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                 | The call was successful.                                |
	//	+------------------------------------------+---------------------------------------------------------+
	//	| 0x00004E25 ERROR_DHCP_SUBNET_NOT_PRESENT | The specified subnet is not defined on the DHCP server. |
	//	+------------------------------------------+---------------------------------------------------------+
	//
	// The opnum field value for this method is 80.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	GetSubnetDelayOffer(context.Context, *GetSubnetDelayOfferRequest, ...dcerpc.CallOption) (*GetSubnetDelayOfferResponse, error)

	// The R_DhcpGetMibInfoV5 method is used to retrieve the statistics of the DHCPv4 server.
	// The caller of this function can free the memory pointed to by MibInfo and its field
	// ScopeInfo by calling the function midl_user_free (see section 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+--------------------------+--------------------------+
	//	|          RETURN          |                          |
	//	|        VALUE/CODE        |       DESCRIPTION        |
	//	|                          |                          |
	//	+--------------------------+--------------------------+
	//	+--------------------------+--------------------------+
	//	| 0x00000000 ERROR_SUCCESS | The call was successful. |
	//	+--------------------------+--------------------------+
	//
	// The opnum field value for this method is 81.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	GetMIBInfoV5(context.Context, *GetMIBInfoV5Request, ...dcerpc.CallOption) (*GetMIBInfoV5Response, error)

	// The R_DhcpAddFilterV4 method is used to add a link-layer address/pattern to allow
	// list or deny list. The DHCPv4 server allows the DHCPv4 clients whose link-layer address
	// is in the allow list to be given leases and blocks DHCPv4 clients whose link-layer
	// address is in the deny list provided the respective lists are enabled using the R_DhcpSetFilterV4
	// (section 3.2.4.85) method. This method is also used to exempt one or more hardware
	// types from filtering. However, hardware type 1 (Ethernet 10 Mb) cannot be exempted.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+------------------------------------------------------------+----------------------------------------------------------------------+
	//	|                           RETURN                           |                                                                      |
	//	|                         VALUE/CODE                         |                             DESCRIPTION                              |
	//	|                                                            |                                                                      |
	//	+------------------------------------------------------------+----------------------------------------------------------------------+
	//	+------------------------------------------------------------+----------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                                   | The call was successful.                                             |
	//	+------------------------------------------------------------+----------------------------------------------------------------------+
	//	| 0x00004E2D ERROR_DHCP_JET_ERROR                            | An error occurred while accessing the DHCP server database.          |
	//	+------------------------------------------------------------+----------------------------------------------------------------------+
	//	| 0x00004E7E ERROR_DHCP_LINKLAYER_ADDRESS_EXISTS             | Address or Address pattern is already contained in one of the lists. |
	//	+------------------------------------------------------------+----------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER                         | Invalid input - address/pattern                                      |
	//	+------------------------------------------------------------+----------------------------------------------------------------------+
	//	| 0x00004E85 ERROR_DHCP_HARDWARE_ADDRESS_TYPE_ALREADY_EXEMPT | Hardware type already exempted from filtering.                       |
	//	+------------------------------------------------------------+----------------------------------------------------------------------+
	//
	// The opnum field value for this method is 82.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	AddFilterV4(context.Context, *AddFilterV4Request, ...dcerpc.CallOption) (*AddFilterV4Response, error)

	// The R_DhcpDeleteFilterV4 method is used to delete a link-layer address/pattern from
	// allow list or deny list. This method is also used to delete an exemption of a hardware
	// type from filtering. However, hardware type 1 (Ethernet 10 Mb) cannot be exempted,
	// and this method cannot be used to delete them.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+--------------------------------------------------------+-----------------------------------------------------------------+
	//	|                         RETURN                         |                                                                 |
	//	|                       VALUE/CODE                       |                           DESCRIPTION                           |
	//	|                                                        |                                                                 |
	//	+--------------------------------------------------------+-----------------------------------------------------------------+
	//	+--------------------------------------------------------+-----------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                               | The call was successful.                                        |
	//	+--------------------------------------------------------+-----------------------------------------------------------------+
	//	| 0x00004E2D ERROR_DHCP_JET_ERROR                        | An error occurred while accessing the DHCP Server Database.     |
	//	+--------------------------------------------------------+-----------------------------------------------------------------+
	//	| 0x00004E7F ERROR_DHCP_LINKLAYER_ADDRESS_DOES_NOT_EXIST | Address or Address pattern is not contained in any of the list. |
	//	+--------------------------------------------------------+-----------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER                     | Invalid input - address/pattern                                 |
	//	+--------------------------------------------------------+-----------------------------------------------------------------+
	//	| 0x00004E86 ERROR_DHCP_UNDEFINED_HARDWARE_ADDRESS_TYPE  | Hardware type not present in the exemption list.                |
	//	+--------------------------------------------------------+-----------------------------------------------------------------+
	//
	// The opnum field value for this method is 83.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	DeleteFilterV4(context.Context, *DeleteFilterV4Request, ...dcerpc.CallOption) (*DeleteFilterV4Response, error)

	// The R_DhcpSetFilterV4 method is used to enable or disable the allow and deny lists.
	// The DHCPv4 server allows the DHCPv4 clients whose link-layer address is in the allow
	// list to be given leases and blocks DHCPv4 clients whose link-layer address is in
	// the deny list, provided the respective lists are enabled using R_DhcpSetFilterV4.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+---------------------------------+-------------------------------------------------------------+
	//	|             RETURN              |                                                             |
	//	|           VALUE/CODE            |                         DESCRIPTION                         |
	//	|                                 |                                                             |
	//	+---------------------------------+-------------------------------------------------------------+
	//	+---------------------------------+-------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS        | The call was successful.                                    |
	//	+---------------------------------+-------------------------------------------------------------+
	//	| 0x00004E2D ERROR_DHCP_JET_ERROR | An error occurred while accessing the DHCP server database. |
	//	+---------------------------------+-------------------------------------------------------------+
	//
	// The opnum field value for this method is 84.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	SetFilterV4(context.Context, *SetFilterV4Request, ...dcerpc.CallOption) (*SetFilterV4Response, error)

	// The R_DhcpGetFilterV4 method is used to retrieve the enable or disable settings for
	// the allow and deny lists.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+---------------------------------+-------------------------------------------------------------+
	//	|             RETURN              |                                                             |
	//	|           VALUE/CODE            |                         DESCRIPTION                         |
	//	|                                 |                                                             |
	//	+---------------------------------+-------------------------------------------------------------+
	//	+---------------------------------+-------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS        | The call was successful.                                    |
	//	+---------------------------------+-------------------------------------------------------------+
	//	| 0x00004E2D ERROR_DHCP_JET_ERROR | An error occurred while accessing the DHCP server database. |
	//	+---------------------------------+-------------------------------------------------------------+
	//
	// The opnum field value for this method is 85.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	GetFilterV4(context.Context, *GetFilterV4Request, ...dcerpc.CallOption) (*GetFilterV4Response, error)

	// The R_DhcpEnumFilterV4 method enumerates all the filter records from either allow
	// list or deny list. It also returns a list of hardware types presently exempted from
	// filtering. These entries are present in the allow list. Exemption entries have a
	// pattern of Length 0 and IsWildCard set to TRUE; both are specified in the AddrPatt
	// field of the DHCP_FILTER_RECORD (section 2.2.1.2.92) structure.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_NO_MORE_ITEMS (0x00000103) indicates that the operation was completed
	// successfully. Otherwise, it contains a Win32 error code, as specified in [MS-ERREF].
	// This error code value can correspond to a DHCP-specific failure, which takes a value
	// between 20000 and 20099, or any generic failure.
	//
	//	+---------------------------------+-------------------------------------------------------------+
	//	|             RETURN              |                                                             |
	//	|           VALUE/CODE            |                         DESCRIPTION                         |
	//	|                                 |                                                             |
	//	+---------------------------------+-------------------------------------------------------------+
	//	+---------------------------------+-------------------------------------------------------------+
	//	| 0x000000EA ERROR_MORE_DATA      | There are more elements available to enumerate.             |
	//	+---------------------------------+-------------------------------------------------------------+
	//	| 0x00000103 ERROR_NO_MORE_ITEMS  | There are no more elements left to enumerate.               |
	//	+---------------------------------+-------------------------------------------------------------+
	//	| 0x00004E2D ERROR_DHCP_JET_ERROR | An error occurred while accessing the DHCP server database. |
	//	+---------------------------------+-------------------------------------------------------------+
	//
	// The opnum field value for this method is 86.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	EnumFilterV4(context.Context, *EnumFilterV4Request, ...dcerpc.CallOption) (*EnumFilterV4Response, error)

	// The R_DhcpSetDnsRegCredentials method sets the DNS user name and credentials in the
	// DHCP server which is used for DNS registrations for DHCP client lease record.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully,
	// else it contains a Win32 error code, as specified in [MS-ERREF]. This error code
	// value can correspond to a DHCP-specific failure, which takes a value between 20000
	// and 20099, or any generic failure.
	//
	//	+--------------------------+--------------------------+
	//	|          RETURN          |                          |
	//	|        VALUE/CODE        |       DESCRIPTION        |
	//	|                          |                          |
	//	+--------------------------+--------------------------+
	//	+--------------------------+--------------------------+
	//	| 0x00000000 ERROR_SUCCESS | The call was successful. |
	//	+--------------------------+--------------------------+
	//
	// The opnum field value for this method is 87.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	SetDNSRegCredentialsV5(context.Context, *SetDNSRegCredentialsV5Request, ...dcerpc.CallOption) (*SetDNSRegCredentialsV5Response, error)

	// The R_DhcpEnumSubnetClientsFilterStatusInfo method is used to retrieve all DHCPv4
	// clients serviced on the specified IPv4 subnet. The information also includes the
	// link-layer filter status info for the DHCPv4 client.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates operation was completed successfully.
	// Otherwise, it contains a Win32 error code, as specified in [MS-ERREF]. This error
	// code value can correspond to a DHCP specific failure, which takes a value between
	// 20000 and 20099, or any generic failure.
	//
	//	+---------------------------------+-------------------------------------------------------------+
	//	|             RETURN              |                                                             |
	//	|           VALUE/CODE            |                         DESCRIPTION                         |
	//	|                                 |                                                             |
	//	+---------------------------------+-------------------------------------------------------------+
	//	+---------------------------------+-------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS        | The call was successful.                                    |
	//	+---------------------------------+-------------------------------------------------------------+
	//	| 0x000000EA ERROR_MORE_DATA      | There are more elements available to enumerate.             |
	//	+---------------------------------+-------------------------------------------------------------+
	//	| 0x00000103 ERROR_NO_MORE_ITEMS  | There are no more elements left to enumerate.               |
	//	+---------------------------------+-------------------------------------------------------------+
	//	| 0x00004E2D ERROR_DHCP_JET_ERROR | An error occurred while accessing the DHCP server database. |
	//	+---------------------------------+-------------------------------------------------------------+
	//
	// The opnum field value for this method is 88.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	EnumSubnetClientsFilterStatusInfo(context.Context, *EnumSubnetClientsFilterStatusInfoRequest, ...dcerpc.CallOption) (*EnumSubnetClientsFilterStatusInfoResponse, error)

	// The R_DhcpV4FailoverCreateRelationship method is used to create a new failover relationship
	// on the DHCPv4 server.
	//
	// Return Values: A 32-bit unsigned integer value that indicates the return status.
	// A return value of ERROR_SUCCESS (0x00000000) indicates that the operation was completed
	// successfully. Otherwise, it contains a Win32 error code, as specified in [MS-ERREF].
	// This error code value can correspond to a DHCP-specific failure, which takes a value
	// between 20000 and 20123, or to any generic failure.
	//
	//	+--------------------------------------------------------+----------------------------------------------------------------------------------+
	//	|                         RETURN                         |                                                                                  |
	//	|                       VALUE/CODE                       |                                   DESCRIPTION                                    |
	//	|                                                        |                                                                                  |
	//	+--------------------------------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                               | The call was successful.                                                         |
	//	+--------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E25 ERROR_DHCP_SUBNET_NOT_PRESENT               | IPv4 scope does not exist on the DHCPv4 server.                                  |
	//	+--------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E90 ERROR_DHCP_FO_SCOPE_ALREADY_IN_RELATIONSHIP | IPv4 is already part of another failover relationship.                           |
	//	+--------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E91 ERROR_DHCP_FO_RELATIONSHIP_EXISTS           | A failover relationship already exists on the DHCPv4 server.                     |
	//	+--------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E9D ERROR_DHCP_FO_RELATIONSHIP_NAME_TOO_LONG    | The failover relationship name in the DHCP_FAILOVER_RELATIONSHIP (section        |
	//	|                                                        | 2.2.1.2.98) structure is too long.                                               |
	//	+--------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004EA0 ERROR_DHCP_FO_MAX_RELATIONSHIPS             | The maximum number of allowed failover relationships configured on the DHCP      |
	//	|                                                        | server has been exceeded.                                                        |
	//	+--------------------------------------------------------+----------------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 89.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol specified in [MS-RPCE].
	FailoverCreateRelationshipV4(context.Context, *FailoverCreateRelationshipV4Request, ...dcerpc.CallOption) (*FailoverCreateRelationshipV4Response, error)

	// The R_DhcpV4FailoverSetRelationship method is used to modify an existing failover
	// relationship on the DHCPv4 server.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. The
	// return value ERROR_SUCCESS (0x00000000) indicates that the operation was completed
	// successfully. Otherwise, it contains a Win32 error code, as specified in [MS-ERREF].
	// This error code value can correspond to a DHCP-specific failure, which takes a value
	// between 20000 and 20123, or any generic failure.
	//
	//	+------------------------------------------------------+------------------------------------------+
	//	|                        RETURN                        |                                          |
	//	|                      VALUE/CODE                      |               DESCRIPTION                |
	//	|                                                      |                                          |
	//	+------------------------------------------------------+------------------------------------------+
	//	+------------------------------------------------------+------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                             | The call was successful.                 |
	//	+------------------------------------------------------+------------------------------------------+
	//	| 0x00004E92 ERROR_DHCP_FO_RELATIONSHIP_DOES_NOT_EXIST | The failover relationship doesn’t exist. |
	//	+------------------------------------------------------+------------------------------------------+
	//
	// The opnum field value for this method is 90.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	FailoverSetRelationshipV4(context.Context, *FailoverSetRelationshipV4Request, ...dcerpc.CallOption) (*FailoverSetRelationshipV4Response, error)

	// The R_DhcpV4FailoverDeleteRelationship method is used to delete an existing failover
	// relationship on the DHCPv4 server.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. The
	// return value ERROR_SUCCESS (0x00000000) indicates that the operation was completed
	// successfully. Otherwise, it contains a Win32 error code, as specified in [MS-ERREF].
	// This error code value can correspond to a DHCP-specific failure, which takes a value
	// between 20000 and 20123, or any generic failure.
	//
	//	+------------------------------------------------------+------------------------------------------+
	//	|                        RETURN                        |                                          |
	//	|                      VALUE/CODE                      |               DESCRIPTION                |
	//	|                                                      |                                          |
	//	+------------------------------------------------------+------------------------------------------+
	//	+------------------------------------------------------+------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                             | The call was successful.                 |
	//	+------------------------------------------------------+------------------------------------------+
	//	| 0x00004E92 ERROR_DHCP_FO_RELATIONSHIP_DOES_NOT_EXIST | The failover relationship doesn't exist. |
	//	+------------------------------------------------------+------------------------------------------+
	//
	// The opnum field value for this method is 91.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	FailoverDeleteRelationshipV4(context.Context, *FailoverDeleteRelationshipV4Request, ...dcerpc.CallOption) (*FailoverDeleteRelationshipV4Response, error)

	// The R_DhcpV4FailoverGetRelationship method retrieves the failover relationship information
	// configured on the DHCPv4 server. The caller of this function can free the memory
	// pointed to by the pRelationship parameter by calling the function midl_user_free
	// (section 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value of ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully.
	// Otherwise, it contains a Win32 error code, as specified in [MS-ERREF]. This error
	// code value can correspond to a DHCP-specific failure, which takes a value between
	// 20000 and 20123, or any generic failure.
	//
	//	+------------------------------------------------------+-------------------------------------------+
	//	|                        RETURN                        |                                           |
	//	|                      VALUE/CODE                      |                DESCRIPTION                |
	//	|                                                      |                                           |
	//	+------------------------------------------------------+-------------------------------------------+
	//	+------------------------------------------------------+-------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                             | The call was successful.                  |
	//	+------------------------------------------------------+-------------------------------------------+
	//	| 0x00004E92 ERROR_DHCP_FO_RELATIONSHIP_DOES_NOT_EXIST | The failover relationship does not exist. |
	//	+------------------------------------------------------+-------------------------------------------+
	//
	// The opnum field value for this method is 92.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	FailoverGetRelationshipV4(context.Context, *FailoverGetRelationshipV4Request, ...dcerpc.CallOption) (*FailoverGetRelationshipV4Response, error)

	// The R_DhcpV4FailoverEnumRelationship method enumerates all the failover relationships
	// on the DHCPv4 server. The caller of this function can free the memory pointed to
	// by the pRelationship parameter by calling the function midl_user_free (section 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value of ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully.
	// Otherwise, it contains a Win32 error code, as specified in [MS-ERREF]. This error
	// code value can correspond to a DHCP-specific failure, which takes a value between
	// 20000 and 20123, or any generic failure.
	//
	//	+--------------------------------+-------------------------------------------------+
	//	|             RETURN             |                                                 |
	//	|           VALUE/CODE           |                   DESCRIPTION                   |
	//	|                                |                                                 |
	//	+--------------------------------+-------------------------------------------------+
	//	+--------------------------------+-------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS       | The call was successful.                        |
	//	+--------------------------------+-------------------------------------------------+
	//	| 0x000000EA ERROR_MORE_DATA     | There are more elements available to enumerate. |
	//	+--------------------------------+-------------------------------------------------+
	//	| 0x00000103 ERROR_NO_MORE_ITEMS | There are no more elements left to enumerate.   |
	//	+--------------------------------+-------------------------------------------------+
	//
	// The opnum field value for this method is 93.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	FailoverEnumRelationshipV4(context.Context, *FailoverEnumRelationshipV4Request, ...dcerpc.CallOption) (*FailoverEnumRelationshipV4Response, error)

	// The R_DhcpV4FailoverAddScopeToRelationship method adds scopes to an existing failover
	// relationship.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value of ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully.
	// Otherwise, it contains a Win32 error code, as specified in [MS-ERREF]. This error
	// code value can correspond to a DHCP-specific failure, which takes a value between
	// 20000 and 20123, or to any generic failure.
	//
	//	+--------------------------------------------------------+--------------------------------------------------------------------------------+
	//	|                         RETURN                         |                                                                                |
	//	|                       VALUE/CODE                       |                                  DESCRIPTION                                   |
	//	|                                                        |                                                                                |
	//	+--------------------------------------------------------+--------------------------------------------------------------------------------+
	//	+--------------------------------------------------------+--------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                               | The call was successful.                                                       |
	//	+--------------------------------------------------------+--------------------------------------------------------------------------------+
	//	| 0x00004E25 ERROR_DHCP_SUBNET_NOT_PRESENT               | IPv4 scope does not exist on the DHCPv4 server.                                |
	//	+--------------------------------------------------------+--------------------------------------------------------------------------------+
	//	| 0x00004E91 ERROR_DHCP_FO_SCOPE_ALREADY_IN_RELATIONSHIP | IPv4 scope is already part of another failover relationship.                   |
	//	+--------------------------------------------------------+--------------------------------------------------------------------------------+
	//	| 0x00004E92 ERROR_DHCP_FO_RELATIONSHIP_DOES_NOT_EXIST   | Failover relationship does not exist.                                          |
	//	+--------------------------------------------------------+--------------------------------------------------------------------------------+
	//	| 0x00004EA5 ERROR_DHCP_FO_SCOPE_SYNC_IN_PROGRESS        | Failover relationship is being re-integrated with the failover partner server. |
	//	+--------------------------------------------------------+--------------------------------------------------------------------------------+
	//	| 0x00004E98 ERROR_DHCP_FO_STATE_NOT_NORMAL              | Failover relationship is not in the NORMAL state.                              |
	//	+--------------------------------------------------------+--------------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 94.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	FailoverAddScopeToRelationshipV4(context.Context, *FailoverAddScopeToRelationshipV4Request, ...dcerpc.CallOption) (*FailoverAddScopeToRelationshipV4Response, error)

	// The R_DhcpV4FailoverDeleteScopeFromRelationship method is used to delete one or more
	// scopes from an existing failover relationship.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value of ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully.
	// Otherwise, it contains a Win32 error code, as specified in [MS-ERREF]. This error
	// code value can correspond to a DHCP-specific failure, which takes a value between
	// 20000 and 20123, or any generic failure.
	//
	//	+------------------------------------------------------+--------------------------------------------------------------------------------+
	//	|                        RETURN                        |                                                                                |
	//	|                      VALUE/CODE                      |                                  DESCRIPTION                                   |
	//	|                                                      |                                                                                |
	//	+------------------------------------------------------+--------------------------------------------------------------------------------+
	//	+------------------------------------------------------+--------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                             | The call was successful.                                                       |
	//	+------------------------------------------------------+--------------------------------------------------------------------------------+
	//	| 0x00004E25 ERROR_DHCP_SUBNET_NOT_PRESENT             | IPv4 scope doesn't exist on the DHCPv4 server.                                 |
	//	+------------------------------------------------------+--------------------------------------------------------------------------------+
	//	| 0x00004E92 ERROR_DHCP_FO_RELATIONSHIP_DOES_NOT_EXIST | Failover relationship doesn't exist.                                           |
	//	+------------------------------------------------------+--------------------------------------------------------------------------------+
	//	| 0x00004E94 ERROR_DHCP_FO_SCOPE_NOT_IN_RELATIONSHIP   | IPv4 subnet is not part of the failover relationship.                          |
	//	+------------------------------------------------------+--------------------------------------------------------------------------------+
	//	| 0x00004EA5 ERROR_DHCP_FO_SCOPE_SYNC_IN_PROGRESS      | Failover relationship is being re-integrated with the failover partner server. |
	//	+------------------------------------------------------+--------------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 95.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	FailoverDeleteScopeFromRelationshipV4(context.Context, *FailoverDeleteScopeFromRelationshipV4Request, ...dcerpc.CallOption) (*FailoverDeleteScopeFromRelationshipV4Response, error)

	// The R_DhcpV4FailoverGetScopeRelationship method retrieves the failover relationship
	// information which is configured for a specific IPv4 subnet address. The caller of
	// this function can free the memory pointed to by the pRelationship parameter by calling
	// the function midl_user_free (section 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value of ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully.
	// Otherwise, it contains a Win32 error code, as specified in [MS-ERREF]. This error
	// code value can correspond to a DHCP-specific failure, which takes a value between
	// 20000 and 20123, or any generic failure.
	//
	//	+----------------------------------------------------+-------------------------------------------------------+
	//	|                       RETURN                       |                                                       |
	//	|                     VALUE/CODE                     |                      DESCRIPTION                      |
	//	|                                                    |                                                       |
	//	+----------------------------------------------------+-------------------------------------------------------+
	//	+----------------------------------------------------+-------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                           | The call was successful.                              |
	//	+----------------------------------------------------+-------------------------------------------------------+
	//	| 0x00004E93 ERROR_DHCP_FO_SCOPE_NOT_IN_RELATIONSHIP | IPv4 subnet is not part of the failover relationship. |
	//	+----------------------------------------------------+-------------------------------------------------------+
	//
	// The opnum field value for this method is 96.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	FailoverGetScopeRelationshipV4(context.Context, *FailoverGetScopeRelationshipV4Request, ...dcerpc.CallOption) (*FailoverGetScopeRelationshipV4Response, error)

	// The R_DhcpV4FailoverGetScopeStatistics method is used to retrieve the statistics
	// of a IPv4 subnet configured for a failover relationship on the DHCPv4 server. The
	// caller of this function can free the memory pointed to by the pStats parameter by
	// calling the function midl_user_free (section 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value of ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully.
	// Otherwise, it contains a Win32 error code, as specified in [MS-ERREF]. This error
	// code value can correspond to a DHCP-specific failure, which takes a value between
	// 20000 and 20123, or any generic failure.
	//
	//	+--------------------------+--------------------------+
	//	|          RETURN          |                          |
	//	|        VALUE/CODE        |       DESCRIPTION        |
	//	|                          |                          |
	//	+--------------------------+--------------------------+
	//	+--------------------------+--------------------------+
	//	| 0x00000000 ERROR_SUCCESS | The call was successful. |
	//	+--------------------------+--------------------------+
	//
	// The opnum field value for this method is 97.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	FailoverGetScopeStatisticsV4(context.Context, *FailoverGetScopeStatisticsV4Request, ...dcerpc.CallOption) (*FailoverGetScopeStatisticsV4Response, error)

	// The R_DhcpV4FailoverGetClientInfo method retrieves DHCPv4 client lease record information
	// from the DHCPv4 server database. The caller of this function can free the memory
	// pointed to by the ClientInfo parameter, by calling the function midl_user_free (section
	// 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value of ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully.
	// Otherwise, it contains a Win32 error code, as specified in [MS-ERREF]. This error
	// code value can correspond to a DHCP-specific failure, which takes a value between
	// 20000 and 20099, or any generic failure.
	//
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	|             RETURN              |                                                                                  |
	//	|           VALUE/CODE            |                                   DESCRIPTION                                    |
	//	|                                 |                                                                                  |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS        | The call was successful.                                                         |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E2D ERROR_DHCP_JET_ERROR | An error occurred while accessing the DHCP server database or the client entry   |
	//	|                                 | is not present in the database.                                                  |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 98.
	//
	// Exceptions Thrown: No exceptions SHOULD be thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	FailoverGetClientInfoV4(context.Context, *FailoverGetClientInfoV4Request, ...dcerpc.CallOption) (*FailoverGetClientInfoV4Response, error)

	// The R_DhcpV4FailoverGetSystemTime method is used to return the current time on the
	// DHCP server.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully.
	// Otherwise, it contains a Win32 error code, as specified in [MS-ERREF]. This error
	// code value can correspond to a DHCP-specific failure, which takes a value between
	// 20000 and 20123, or any generic failure.
	//
	//	+--------------------------+--------------------------+
	//	|          RETURN          |                          |
	//	|        VALUE/CODE        |       DESCRIPTION        |
	//	|                          |                          |
	//	+--------------------------+--------------------------+
	//	+--------------------------+--------------------------+
	//	| 0x00000000 ERROR_SUCCESS | The call was successful. |
	//	+--------------------------+--------------------------+
	//
	// The opnum field value for this method is 99.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol specified in [MS-RPCE].
	FailoverGetSystemTimeV4(context.Context, *FailoverGetSystemTimeV4Request, ...dcerpc.CallOption) (*FailoverGetSystemTimeV4Response, error)

	// The R_DhcpV4FailoverTriggerAddrAllocation method re-distributes the free addresses
	// between the primary server and secondary server.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value of ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully.
	// Otherwise, it contains a Win32 error code, as specified in [MS-ERREF]. This error
	// code value can correspond to a DHCP-specific failure, which takes a value between
	// 20000 and 20123, or any generic failure.
	//
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	|                        RETURN                        |                                                                                  |
	//	|                      VALUE/CODE                      |                                   DESCRIPTION                                    |
	//	|                                                      |                                                                                  |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                             | The call was successful.                                                         |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E92 ERROR_DHCP_FO_RELATIONSHIP_DOES_NOT_EXIST | Failover relationship doesn't exit.                                              |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E94 ERROR_DHCP_FO_RELATION_IS_SECONDARY       | serverType member of failover relationship is SecondaryServer enumeration value. |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 100.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	FailoverTriggerAddrAllocationV4(context.Context, *FailoverTriggerAddrAllocationV4Request, ...dcerpc.CallOption) (*FailoverTriggerAddrAllocationV4Response, error)

	// The R_DhcpV4SetOptionValue method sets the option value for a policy at the specified
	// level (scope or server).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value of ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully.
	// Otherwise, it contains a Win32 error code, as specified in [MS-ERREF]. This error
	// code value can correspond to a DHCP-specific failure, which takes a value between
	// 20000 and 20099, or to any generic failure.
	//
	//	+-------------------------------------------------------+----------------------------------------------------------------------------------+
	//	|                        RETURN                         |                                                                                  |
	//	|                      VALUE/CODE                       |                                   DESCRIPTION                                    |
	//	|                                                       |                                                                                  |
	//	+-------------------------------------------------------+----------------------------------------------------------------------------------+
	//	+-------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                              | The call was successful.                                                         |
	//	+-------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E25 ERROR_DHCP_SUBNET_NOT_PRESENT              | The specified IPv4 subnet does not exist on the DHCP server.                     |
	//	+-------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E2A ERROR_DHCP_OPTION_NOT_PRESENT              | The specified option definition does not exist on the DHCP server database.      |
	//	+-------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E4C ERROR_DHCP_CLASS_NOT_FOUND                 | The class name being used is unknown or incorrect.                               |
	//	+-------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E8FL ERROR_DHCP_POLICY_NOT_FOUND               | The specified policy name does not exist.                                        |
	//	+-------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004EA8L ERROR_DHCP_POLICY_FQDN_OPIION_UNSUPPORTED | The option value cannot be specified because the policy contains an FQDN-based   |
	//	|                                                       | condition.                                                                       |
	//	+-------------------------------------------------------+----------------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 101.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	SetOptionValueV4(context.Context, *SetOptionValueV4Request, ...dcerpc.CallOption) (*SetOptionValueV4Response, error)

	// The R_DhcpV4SetOptionValues method sets the specified option values for a policy
	// at the specified level.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value of ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully.
	// Otherwise, it contains a Win32 error code, as specified in [MS-ERREF]. This error
	// code value can correspond to a DHCP-specific failure, which takes a value between
	// 20000 and 20099, or to any generic failure.
	//
	//	+-------------------------------------------------------+----------------------------------------------------------------------------------+
	//	|                        RETURN                         |                                                                                  |
	//	|                      VALUE/CODE                       |                                   DESCRIPTION                                    |
	//	|                                                       |                                                                                  |
	//	+-------------------------------------------------------+----------------------------------------------------------------------------------+
	//	+-------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                              | The call was successful.                                                         |
	//	+-------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E25 ERROR_DHCP_SUBNET_NOT_PRESENT              | The specified IPv4 subnet does not exist on the DHCP server.                     |
	//	+-------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E2A ERROR_DHCP_OPTION_NOT_PRESENT              | The specified option definition does not exist on the DHCP server database.      |
	//	+-------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E32 ERROR_DHCP_NOT_RESERVED_CLIENT             | The specified DHCP client is not a reserved client.                              |
	//	+-------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E4C ERROR_DHCP_CLASS_NOT_FOUND                 | The class name being used is unknown or incorrect.                               |
	//	+-------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E8FL ERROR_DHCP_POLICY_NOT_PRESENT             | The specified policy name does not exist.                                        |
	//	+-------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004EA8L ERROR_DHCP_POLICY_FQDN_OPTION_UNSUPPORTED | The option value cannot be specified because the policy contains an FQDN-based   |
	//	|                                                       | condition.                                                                       |
	//	+-------------------------------------------------------+----------------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 102.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	SetOptionValuesV4(context.Context, *SetOptionValuesV4Request, ...dcerpc.CallOption) (*SetOptionValuesV4Response, error)

	// The R_DhcpV4GetOptionValue method gets the option value for the specified PolicyName
	// parameter and OptionID parameter. The memory for the OptionValue parameter is allocated
	// by this method and can be freed by the caller by calling the function midl_user_free
	// (section 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value of ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully.
	// Otherwise, it contains a Win32 error code, as specified in [MS-ERREF]. This error
	// code value can correspond to a DHCP-specific failure, which takes a value between
	// 20000 and 20099, or to any generic failure.
	//
	//	+------------------------------------------+-----------------------------------------------------------------------------+
	//	|                  RETURN                  |                                                                             |
	//	|                VALUE/CODE                |                                 DESCRIPTION                                 |
	//	|                                          |                                                                             |
	//	+------------------------------------------+-----------------------------------------------------------------------------+
	//	+------------------------------------------+-----------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                 | The call was successful.                                                    |
	//	+------------------------------------------+-----------------------------------------------------------------------------+
	//	| 0x00004E25 ERROR_DHCP_SUBNET_NOT_PRESENT | The specified IPv4 subnet does not exist on the DHCP server.                |
	//	+------------------------------------------+-----------------------------------------------------------------------------+
	//	| 0x00004E2A ERROR_DHCP_OPTION_NOT_PRESENT | The specified option definition does not exist on the DHCP server database. |
	//	+------------------------------------------+-----------------------------------------------------------------------------+
	//	| 0x00004E4C ERROR_DHCP_CLASS_NOT_FOUND    | The class name being used is unknown or incorrect.                          |
	//	+------------------------------------------+-----------------------------------------------------------------------------+
	//	| 0x00004E8F ERROR_DHCP_POLICY_NOT_PRESENT | The specified policy name does not exist.                                   |
	//	+------------------------------------------+-----------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 103.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	GetOptionValueV4(context.Context, *GetOptionValueV4Request, ...dcerpc.CallOption) (*GetOptionValueV4Response, error)

	// The method R_DhcpV4RemoveOptionValue removes the option value for the specified policy.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value of ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully.
	// Otherwise, it contains a Win32 error code, as specified in [MS-ERREF]. This error
	// code value can correspond to a DHCP-specific failure, which takes a value between
	// 20000 and 20099, or to any generic failure.
	//
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	|                  RETURN                  |                                                                                  |
	//	|                VALUE/CODE                |                                   DESCRIPTION                                    |
	//	|                                          |                                                                                  |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                 | The call was successful.                                                         |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E25 ERROR_DHCP_SUBNET_NOT_PRESENT | The specified IPv4 subnet does not exist on the DHCP server.                     |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E2A ERROR_DHCP_OPTION_NOT_PRESENT | The specified option definition does not exist on the DHCP server database, or   |
	//	|                                          | no value is set for the specified option ID on the specified policy.             |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E4C ERROR_DHCP_CLASS_NOT_FOUND    | The class name being used is unknown or incorrect.                               |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E8F ERROR_DHCP_POLICY_NOT_PRESENT | The specified policy name does not exist.                                        |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 104.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol specified in [MS-RPCE].
	RemoveOptionValueV4(context.Context, *RemoveOptionValueV4Request, ...dcerpc.CallOption) (*RemoveOptionValueV4Response, error)

	// The method R_DhcpV4GetAllOptionValues gets all the server level policy or scope level
	// policy options configured. The memory for the Values parameter is allocated by this
	// method and can be freed by the caller by calling the function midl_user_free (section
	// 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value of ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully.
	// Otherwise, it contains a Win32 error code, as specified in [MS-ERREF]. This error
	// code value can correspond to a DHCP-specific failure, which takes a value between
	// 20000 and 20099, or any generic failure.
	//
	//	+------------------------------------------+--------------------------------------------------------------+
	//	|                  RETURN                  |                                                              |
	//	|                VALUE/CODE                |                         DESCRIPTION                          |
	//	|                                          |                                                              |
	//	+------------------------------------------+--------------------------------------------------------------+
	//	+------------------------------------------+--------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                 | The call was successful.                                     |
	//	+------------------------------------------+--------------------------------------------------------------+
	//	| 0x00004E25 ERROR_DHCP_SUBNET_NOT_PRESENT | The specified IPv4 subnet does not exist on the DHCP server. |
	//	+------------------------------------------+--------------------------------------------------------------+
	//
	// The opnum field value for this method is 105.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	GetAllOptionValuesV4(context.Context, *GetAllOptionValuesV4Request, ...dcerpc.CallOption) (*GetAllOptionValuesV4Response, error)

	// The R_DhcpV4QueryPolicyEnforcement method is used to retrieve the state (enabled/disabled)
	// of policy enforcement on the server or the specified IPv4 subnet.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates operation was completed successfully.
	// Otherwise, it contains a Win32 error code, as specified in [MS-ERREF]. This error
	// code value can correspond to a DHCP specific failure, which takes a value between
	// 20000 and 20099, or any generic failure.
	//
	//	+------------------------------------------+-------------------------------------------+
	//	|                  RETURN                  |                                           |
	//	|                VALUE/CODE                |                DESCRIPTION                |
	//	|                                          |                                           |
	//	+------------------------------------------+-------------------------------------------+
	//	+------------------------------------------+-------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                 | The call was successful.                  |
	//	+------------------------------------------+-------------------------------------------+
	//	| 0x00004E25 ERROR_DHCP_SUBNET_NOT_PRESENT | The specified IPv4 subnet does not exist. |
	//	+------------------------------------------+-------------------------------------------+
	//
	// The opnum field value for this method is 106.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol specified in [MS-RPCE].
	QueryPolicyEnforcementV4(context.Context, *QueryPolicyEnforcementV4Request, ...dcerpc.CallOption) (*QueryPolicyEnforcementV4Response, error)

	// The R_DhcpV4SetPolicyEnforcement method is used to set the state (enable/disable)
	// of policy enforcement of the server or the specified IPv4 subnet.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value of ERROR_SUCCESS (0x00000000) indicates operation was completed successfully.
	// Otherwise, it contains a Win32 error code, as specified in [MS-ERREF]. This error
	// code value can correspond to a DHCP specific failure, which takes a value between
	// 20000 and 20099, or any generic failure.
	//
	//	+------------------------------------------+-------------------------------------------+
	//	|                  RETURN                  |                                           |
	//	|                VALUE/CODE                |                DESCRIPTION                |
	//	|                                          |                                           |
	//	+------------------------------------------+-------------------------------------------+
	//	+------------------------------------------+-------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                 | The call was successful.                  |
	//	+------------------------------------------+-------------------------------------------+
	//	| 0x00004E25 ERROR_DHCP_SUBNET_NOT_PRESENT | The specified IPv4 subnet does not exist. |
	//	+------------------------------------------+-------------------------------------------+
	//
	// The opnum field value for this method is 107.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	SetPolicyEnforcementV4(context.Context, *SetPolicyEnforcementV4Request, ...dcerpc.CallOption) (*SetPolicyEnforcementV4Response, error)

	// The R_DhcpV4CreatePolicy method creates the policy according to the data specified
	// in the policy data structure.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value of ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully.
	// Otherwise, it contains a Win32 error code, as specified in [MS-ERREF]. This error
	// code value can correspond to a DHCP-specific failure, which takes a value between
	// 20000 and 20099, or to any generic failure.
	//
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	|                        RETURN                        |                                                                                  |
	//	|                      VALUE/CODE                      |                                   DESCRIPTION                                    |
	//	|                                                      |                                                                                  |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                             | The call was successful.                                                         |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E25 ERROR_DHCP_SUBNET_NOT_PRESENT             | The specified IPv4 subnet does not exist.                                        |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E8C ERROR_DHCP_RANGE_INVALID_IN_SERVER_POLICY | A policy range has been specified for a server level policy.                     |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E8D ERROR_DHCP_INVALID_POLICY_EXPRESSION      | The specified conditions or expressions of the policy are invalid.               |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E8B ERROR_DHCP_POLICY_RANGE_BAD               | The specified policy IP range is not contained within the IP address range of    |
	//	|                                                      | the scope, or the specified policy IP range is invalid.                          |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E89 ERROR_DHCP_POLICY_EXISTS                  | The specified policy name exists at the specified level (server or scope).       |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E8A ERROR_DHCP_POLICY_RANGE_EXISTS            | The specified policy IP range overlaps the policy IP ranges of an existing       |
	//	|                                                      | policy at the specified scope.                                                   |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E8E ERROR_DHCP_INVALID_PROCESSING_ORDER       | The specified processing order is greater than the maximum processing order of   |
	//	|                                                      | the existing policies at the specified level (server or scope).                  |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E4C ERROR_DHCP_CLASS_NOT_FOUND                | The vendor class or user class reference in the conditions of the policy does    |
	//	|                                                      | not exist.                                                                       |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004EAC ERROR_DHCP_POLICY_FQDN_RANGE_UNSUPPORTED  | Ranges are not allowed to be set on the given policy.                            |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 108.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol specified in [MS-RPCE].
	CreatePolicyV4(context.Context, *CreatePolicyV4Request, ...dcerpc.CallOption) (*CreatePolicyV4Response, error)

	// The R_DhcpV4GetPolicy method returns the specified policy. The memory for the Policy
	// structure is allocated by this method and can be freed by the caller by using the
	// function midl_user_free (section 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value of ERROR_SUCCESS (0x00000000) indicates operation was completed successfully.
	// Otherwise, it contains a Win32 error code, as specified in [MS-ERREF]. This error
	// code value can correspond to a DHCP specific failure, which takes a value between
	// 20000 and 20099, or any generic failure.
	//
	//	+------------------------------------------+-------------------------------------------+
	//	|                  RETURN                  |                                           |
	//	|                VALUE/CODE                |                DESCRIPTION                |
	//	|                                          |                                           |
	//	+------------------------------------------+-------------------------------------------+
	//	+------------------------------------------+-------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                 | The call was successful.                  |
	//	+------------------------------------------+-------------------------------------------+
	//	| 0x00004E25 ERROR_DHCP_SUBNET_NOT_PRESENT | The specified IPv4 subnet does not exist. |
	//	+------------------------------------------+-------------------------------------------+
	//
	// The opnum field value for this method is 109.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol specified in [MS-RPCE].
	GetPolicyV4(context.Context, *GetPolicyV4Request, ...dcerpc.CallOption) (*GetPolicyV4Response, error)

	// The R_DhcpV4SetPolicy method modifies the specified DHCPv4 policy.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value of ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully.
	// Otherwise, it contains a Win32 error code, as specified in [MS-ERREF]. This error
	// code value can correspond to a DHCP-specific failure, which takes a value between
	// 20000 and 20099, or to any generic failure.
	//
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	|                        RETURN                        |                                                                                  |
	//	|                      VALUE/CODE                      |                                   DESCRIPTION                                    |
	//	|                                                      |                                                                                  |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                             | The call was successful.                                                         |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E25 ERROR_DHCP_SUBNET_NOT_PRESENT             | The specified IPv4 subnet does not exist.                                        |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E8C ERROR_DHCP_RANGE_INVALID_IN_SERVER_POLICY | A policy range has been specified for a server level policy.                     |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E8D ERROR_DHCP_INVALID_POLICY_EXPRESSION      | The specified conditions or expressions of the policy are invalid.               |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E8B ERROR_DHCP_POLICY_RANGE_BAD               | The specified policy range is not contained within the IP address range of the   |
	//	|                                                      | scope, or the specified policy range is invalid.                                 |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E89 ERROR_DHCP_POLICY_NOT_FOUND               | The specified policy name does not exist at the specified level (server or       |
	//	|                                                      | scope).                                                                          |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E8A ERROR_DHCP_POLICY_RANGE_EXISTS            | The specified policy range overlaps the policy ranges of an existing policy at   |
	//	|                                                      | the specified scope.                                                             |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E8E ERROR_DHCP_INVALID_PROCESSING_ORDER       | The specified processing order is greater than the maximum processing order of   |
	//	|                                                      | the existing policies at the specified level (server or scope).                  |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E4C ERROR_DHCP_CLASS_NOT_FOUND                | The vendor class or user class reference in the conditions of the policy does    |
	//	|                                                      | not exist.                                                                       |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004EA9 ERROR_DHCP_POLICY_EDIT_FQDN_UNSUPPORTED   | A FQDN-based condition is being added to a policy that has ranges or options     |
	//	|                                                      | configured.                                                                      |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 110.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	SetPolicyV4(context.Context, *SetPolicyV4Request, ...dcerpc.CallOption) (*SetPolicyV4Response, error)

	// The R_DhcpV4DeletePolicy method deletes the specified policy.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value of ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully.
	// Otherwise, it contains a Win32 error code, as specified in [MS-ERREF]. This error
	// code value can correspond to a DHCP-specific failure, which takes a value between
	// 20000 and 20099, or to any generic failure.
	//
	//	+------------------------------------------+-------------------------------------------+
	//	|                  RETURN                  |                                           |
	//	|                VALUE/CODE                |                DESCRIPTION                |
	//	|                                          |                                           |
	//	+------------------------------------------+-------------------------------------------+
	//	+------------------------------------------+-------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                 | The call was successful.                  |
	//	+------------------------------------------+-------------------------------------------+
	//	| 0x00004E25 ERROR_DHCP_SUBNET_NOT_PRESENT | The specified IPv4 subnet does not exist. |
	//	+------------------------------------------+-------------------------------------------+
	//
	// The opnum field value for this method is 111.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	DeletePolicyV4(context.Context, *DeletePolicyV4Request, ...dcerpc.CallOption) (*DeletePolicyV4Response, error)

	// The method R_DhcpV4EnumPolicies returns an enumerated list of all configured server
	// level policies or scope level policies. The caller of this function can free the
	// memory pointed to by the EnumInfo parameter by calling the function midl_user_free
	// (section 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value of ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully.
	// Otherwise, it contains a Win32 error code, as specified in [MS-ERREF]. This error
	// code value can correspond to a DHCP-specific failure, which takes a value between
	// 20000 and 20099, or any generic failure.
	//
	//	+--------------------------------+-------------------------------------------------+
	//	|             RETURN             |                                                 |
	//	|           VALUE/CODE           |                   DESCRIPTION                   |
	//	|                                |                                                 |
	//	+--------------------------------+-------------------------------------------------+
	//	+--------------------------------+-------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS       | The call was successful.                        |
	//	+--------------------------------+-------------------------------------------------+
	//	| 0x000000EA ERROR_MORE_DATA     | There are more elements available to enumerate. |
	//	+--------------------------------+-------------------------------------------------+
	//	| 0x00000103 ERROR_NO_MORE_ITEMS | There are no more elements left to enumerate.   |
	//	+--------------------------------+-------------------------------------------------+
	//
	// The opnum field value for this method is 112.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	EnumPoliciesV4(context.Context, *EnumPoliciesV4Request, ...dcerpc.CallOption) (*EnumPoliciesV4Response, error)

	// The R_DhcpV4AddPolicyRange method adds an IP address range to a policy.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value of ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully.
	// Otherwise, it contains a Win32 error code, as specified in [MS-ERREF]. This error
	// code value can correspond to a DHCP-specific failure, which takes a value between
	// 20000 and 20099, or to any generic failure.
	//
	//	+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	|                       RETURN                        |                                                                                  |
	//	|                     VALUE/CODE                      |                                   DESCRIPTION                                    |
	//	|                                                     |                                                                                  |
	//	+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                            | The call was successful.                                                         |
	//	+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E25 ERROR_DHCP_SUBNET_NOT_PRESENT            | The specified IPv4 subnet does not exist.                                        |
	//	+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E8F ERROR_DHCP_POLICY_NOT_FOUND              | The specified policy does not exist.                                             |
	//	+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E8B ERROR_DHCP_POLICY_RANGE_BAD              | The specified policy IP range is not contained within the IP address range of    |
	//	|                                                     | the scope, or the specified policy IP range is not valid.                        |
	//	+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E8A ERROR_DHCP_POLICY_RANGE_EXISTS           | The specified policy IP range overlaps one of the policy IP address ranges       |
	//	|                                                     | specified.                                                                       |
	//	+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004EA7 ERROR_DHCP_POLICY_FQDN_RANGE_UNSUPPORTED | Ranges are not allowed to be added to the given policy.                          |
	//	+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 113.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	AddPolicyRangeV4(context.Context, *AddPolicyRangeV4Request, ...dcerpc.CallOption) (*AddPolicyRangeV4Response, error)

	// The R_DhcpV4RemovePolicyRange method removes the specified IP address range from
	// the list of IP address ranges of the policy.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value of ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully.
	// Otherwise, it contains a Win32 error code, as specified in [MS-ERREF]. This error
	// code value can correspond to a DHCP-specific failure, which takes a value between
	// 20000 and 20099, or to any generic failure.
	//
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	|                  RETURN                  |                                                                                  |
	//	|                VALUE/CODE                |                                   DESCRIPTION                                    |
	//	|                                          |                                                                                  |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                 | The call was successful.                                                         |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E25 ERROR_DHCP_SUBNET_NOT_PRESENT | The specified IPv4 subnet does not exist.                                        |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E8F ERROR_DHCP_POLICY_NOT_FOUND   | The specified policy does not exist.                                             |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00004E8B ERROR_DHCP_POLICY_RANGE_BAD   | The specified policy range is not contained within the IP address range of the   |
	//	|                                          | scope.                                                                           |
	//	+------------------------------------------+----------------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 114.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	RemovePolicyRangeV4(context.Context, *RemovePolicyRangeV4Request, ...dcerpc.CallOption) (*RemovePolicyRangeV4Response, error)

	// The R_DhcpV4EnumSubnetClients method is used to retrieve all DHCPv4 clients serviced
	// on the specified IPv4 subnet. The information also includes the link-layer filter
	// status info for the DHCPv4 client and the policy, if any, that resulted in the specific
	// IPv4 address assignment.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully.
	// Otherwise, it contains a Win32 error code, as specified in [MS-ERREF]. This error
	// code value can correspond to a DHCP-specific failure, which takes a value between
	// 20000 and 20099, or to any generic failure.
	//
	//	+---------------------------------+-------------------------------------------------------------+
	//	|             RETURN              |                                                             |
	//	|           VALUE/CODE            |                         DESCRIPTION                         |
	//	|                                 |                                                             |
	//	+---------------------------------+-------------------------------------------------------------+
	//	+---------------------------------+-------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS        | The call was successful.                                    |
	//	+---------------------------------+-------------------------------------------------------------+
	//	| 0x000000EA ERROR_MORE_DATA      | More client lease records are available to enumerate.       |
	//	+---------------------------------+-------------------------------------------------------------+
	//	| 0x00000103 ERROR_NO_MORE_ITEMS  | No more client lease records are left to enumerate.         |
	//	+---------------------------------+-------------------------------------------------------------+
	//	| 0x00004E2D ERROR_DHCP_JET_ERROR | An error occurred while accessing the DHCP server database. |
	//	+---------------------------------+-------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	EnumSubnetClientsV4(context.Context, *EnumSubnetClientsV4Request, ...dcerpc.CallOption) (*EnumSubnetClientsV4Response, error)

	// The R_DhcpV6SetStatelessStoreParams method modifies the configuration settings for
	// DHCPv6 stateless client inventory at the server or scope level.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value of ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully.
	// Otherwise, it contains a Win32 error code, as specified in [MS-ERREF]. This error
	// code value can correspond to a DHCP-specific failure, which takes a value between
	// 20000 and 20099, or to any generic failure.
	//
	//	+------------------------------------------+------------------------------------------------------+
	//	|                  RETURN                  |                                                      |
	//	|                VALUE/CODE                |                     DESCRIPTION                      |
	//	|                                          |                                                      |
	//	+------------------------------------------+------------------------------------------------------+
	//	+------------------------------------------+------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                 | The call completed successfully.                     |
	//	+------------------------------------------+------------------------------------------------------+
	//	| 0x00020005 ERROR_DHCP_SUBNET_NOT_PRESENT | The IPv6 subnet does not exist on the DHCPv6 server. |
	//	+------------------------------------------+------------------------------------------------------+
	//
	// The opnum field value for this method is 116.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	SetStatelessStoreParamsV6(context.Context, *SetStatelessStoreParamsV6Request, ...dcerpc.CallOption) (*SetStatelessStoreParamsV6Response, error)

	// The R_DhcpV6GetStatelessStoreParams method retrieves the current DHCPv6 stateless
	// client inventory-related configuration setting at the server or scope level. The
	// caller of this function can free the memory pointed to by the Params parameter by
	// calling the function midl_user_free (section 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value of ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully.
	// Otherwise, it contains a Win32 error code, as specified in [MS-ERREF]. This error
	// code value can correspond to a DHCP-specific failure, which takes a value between
	// 20000 and 20099, or to any generic failure.
	//
	//	+------------------------------------------+------------------------------------------------------+
	//	|                  RETURN                  |                                                      |
	//	|                VALUE/CODE                |                     DESCRIPTION                      |
	//	|                                          |                                                      |
	//	+------------------------------------------+------------------------------------------------------+
	//	+------------------------------------------+------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                 | The call completed successfully.                     |
	//	+------------------------------------------+------------------------------------------------------+
	//	| 0x00020005 ERROR_DHCP_SUBNET_NOT_PRESENT | The IPv6 subnet does not exist on the DHCPv6 server. |
	//	+------------------------------------------+------------------------------------------------------+
	//
	// The opnum field value for this method is 117.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	GetStatelessStoreParamsV6(context.Context, *GetStatelessStoreParamsV6Request, ...dcerpc.CallOption) (*GetStatelessStoreParamsV6Response, error)

	// The R_DhcpV6GetStatelessStatistics method is used to retrieve the statistics of the
	// DHCPv6 stateless server. The caller of this function can free the memory pointed
	// to by the StatelessStats parameter and its ScopeStats member array by calling the
	// function midl_user_free (section 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value of ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully.
	// Otherwise, it contains a Win32 error code, as specified in [MS-ERREF]. This error
	// code value can correspond to a DHCP-specific failure, which takes a value between
	// 20000 and 20099, or to any generic failure.
	//
	//	+--------------------------+----------------------------------+
	//	|          RETURN          |                                  |
	//	|        VALUE/CODE        |           DESCRIPTION            |
	//	|                          |                                  |
	//	+--------------------------+----------------------------------+
	//	+--------------------------+----------------------------------+
	//	| 0x00000000 ERROR_SUCCESS | The call completed successfully. |
	//	+--------------------------+----------------------------------+
	//
	// The opnum field value for this method is 118.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	GetStatelessStatisticsV6(context.Context, *GetStatelessStatisticsV6Request, ...dcerpc.CallOption) (*GetStatelessStatisticsV6Response, error)

	// The R_DhcpV4EnumSubnetReservations method enumerates all the reservation information
	// on the DHCPv4 server for a given IPv4 subnet address. The caller of this function
	// can free the memory pointed to by the EnumElementInfo parameter by calling the function
	// midl_user_free (section 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value of ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully.
	// Otherwise, it contains a Win32 error code, as specified in [MS-ERREF]. This error
	// code value can correspond to a DHCP-specific failure, which takes a value between
	// 20000 and 20123, or any generic failure.
	//
	//	+--------------------------------+--------------------------------------------------+
	//	|             RETURN             |                                                  |
	//	|           VALUE/CODE           |                   DESCRIPTION                    |
	//	|                                |                                                  |
	//	+--------------------------------+--------------------------------------------------+
	//	+--------------------------------+--------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS       | The call was successful.                         |
	//	+--------------------------------+--------------------------------------------------+
	//	| 0x000000EA ERROR_MORE_DATA     | There are more elements available to enumerate.  |
	//	+--------------------------------+--------------------------------------------------+
	//	| 0x00000103 ERROR_NO_MORE_ITEMS | There are no more elements left to enumerate.    |
	//	+--------------------------------+--------------------------------------------------+
	//	| ERROR_DHCP_SUBNET_NOT_PRESENT  | IPv4 subnet does not exist on the DHCPv4 server. |
	//	+--------------------------------+--------------------------------------------------+
	//
	// The opnum field value for this method is 119.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	EnumSubnetReservationsV4(context.Context, *EnumSubnetReservationsV4Request, ...dcerpc.CallOption) (*EnumSubnetReservationsV4Response, error)

	// The R_DhcpV4GetFreeIPAddress method retrieves the list of IPv4 addresses available
	// to be leased out to the clients. The caller of this function can free the memory
	// pointed to by the IPAddrList parameter by calling the function midl_user_free (section
	// 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value of ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully.
	// Otherwise, it contains a Win32 error code, as specified in [MS-ERREF]. This error
	// code value can correspond to a DHCP-specific failure, which takes a value between
	// 20000 and 20123, or any generic failure.
	//
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	|                     RETURN                     |                                                                                  |
	//	|                   VALUE/CODE                   |                                   DESCRIPTION                                    |
	//	|                                                |                                                                                  |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                       | The call completed successfully.                                                 |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000103 ERROR_FILE_NOT_FOUND                | No more elements are left to enumerate.                                          |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00020126 ERROR_DHCP_REACHED_END_OF_SELECTION | The specified DHCP server has reached the end of the selected range while        |
	//	|                                                | finding the free IP addresses.                                                   |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 120.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	GetFreeIPAddressV4(context.Context, *GetFreeIPAddressV4Request, ...dcerpc.CallOption) (*GetFreeIPAddressV4Response, error)

	// The R_DhcpV6GetFreeIPAddress method retrieves the list of IPv6 addresses available
	// to be leased out to the clients. The caller of this function can free the memory
	// pointed to by the IPAddrList parameter by calling the function midl_user_free (section
	// 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value of ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully.
	// Otherwise, it contains a Win32 error code, as specified in [MS-ERREF]. This error
	// code value can correspond to a DHCP-specific failure, which takes a value between
	// 20000 and 20123, or to any generic failure.
	//
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	|                     RETURN                     |                                                                                  |
	//	|                   VALUE/CODE                   |                                   DESCRIPTION                                    |
	//	|                                                |                                                                                  |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                       | The call completed successfully.                                                 |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00020005 ERROR_DHCP_SUBNET_NOT_PRESENT       | The IPv6 subnet does not exist on the DHCPv6 server.                             |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00020126 ERROR_DHCP_REACHED_END_OF_SELECTION | The specified DHCP server has reached the end of the selected range while        |
	//	|                                                | finding the free IP addresses.                                                   |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 121.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol specified in [MS-RPCE].
	GetFreeIPAddressV6(context.Context, *GetFreeIPAddressV6Request, ...dcerpc.CallOption) (*GetFreeIPAddressV6Response, error)

	// The R_DhcpV4CreateClientInfo method creates a DHCPv4 client lease record on the DHCP
	// server.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value of ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully.
	// Otherwise, it contains a Win32 error code, as specified in [MS-ERREF]. This error
	// code value can correspond to a DHCP-specific failure, which takes a value between
	// 20000 and 20099, or to any generic failure.
	//
	//	+------------------------------------------+----------------------------------------------------+
	//	|                  RETURN                  |                                                    |
	//	|                VALUE/CODE                |                    DESCRIPTION                     |
	//	|                                          |                                                    |
	//	+------------------------------------------+----------------------------------------------------+
	//	+------------------------------------------+----------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                 | The call completed successfully.                   |
	//	+------------------------------------------+----------------------------------------------------+
	//	| 0x00004E25 ERROR_DHCP_SUBNET_NOT_PRESENT | The specified subnet does not exist.               |
	//	+------------------------------------------+----------------------------------------------------+
	//	| 0x00004E2E ERROR_DHCP_CLIENT_EXISTS      | The specified client already exists on the server. |
	//	+------------------------------------------+----------------------------------------------------+
	//
	// The opnum field value for this method is 122.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol specified in [MS-RPCE].
	CreateClientInfoV4(context.Context, *CreateClientInfoV4Request, ...dcerpc.CallOption) (*CreateClientInfoV4Response, error)

	// The R_DhcpV4GetClientInfo method retrieves DHCPv4 client lease record information
	// from the DHCPv4 server database. The information also includes the link-layer filter
	// status information for the DHCPv4 client and the policy, if any, that resulted in
	// the specific IPv4 address assignment. The caller of this function can free the memory
	// pointed to by the ClientInfo parameter by calling the function midl_user_free (section
	// 3).
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value of ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully.
	// Otherwise, it contains a Win32 error code, as specified in [MS-ERREF]. This error
	// code value can correspond to a DHCP-specific failure, which takes a value between
	// 20000 and 20099, or to any generic failure.
	//
	//	+--------------------------------------+-----------------------------------------+
	//	|                RETURN                |                                         |
	//	|              VALUE/CODE              |               DESCRIPTION               |
	//	|                                      |                                         |
	//	+--------------------------------------+-----------------------------------------+
	//	+--------------------------------------+-----------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS             | The call completed successfully.        |
	//	+--------------------------------------+-----------------------------------------+
	//	| 0x00004E30 ERROR_DHCP_INVALID_CLIENT | The specified DHCP client is not valid. |
	//	+--------------------------------------+-----------------------------------------+
	//
	// The opnum field value for this method is 123.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	GetClientInfoV4(context.Context, *GetClientInfoV4Request, ...dcerpc.CallOption) (*GetClientInfoV4Response, error)

	// The R_DhcpV6CreateClientInfo method creates a DHCPv6 client lease record on the DHCP
	// server.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value of ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully.
	// Otherwise, it contains a Win32 error code, as specified in [MS-ERREF]. This error
	// code value can correspond to a DHCP-specific failure, which takes a value between
	// 20000 and 20099, or to any generic failure.
	//
	//	+------------------------------------------+----------------------------------------------------+
	//	|                  RETURN                  |                                                    |
	//	|                VALUE/CODE                |                    DESCRIPTION                     |
	//	|                                          |                                                    |
	//	+------------------------------------------+----------------------------------------------------+
	//	+------------------------------------------+----------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                 | The call completed successfully.                   |
	//	+------------------------------------------+----------------------------------------------------+
	//	| 0x00004E25 ERROR_DHCP_SUBNET_NOT_PRESENT | The specified subnet does not exist.               |
	//	+------------------------------------------+----------------------------------------------------+
	//	| 0x00004E2E ERROR_DHCP_CLIENT_EXISTS      | The specified client already exists on the server. |
	//	+------------------------------------------+----------------------------------------------------+
	//
	// The opnum field value for this method is 124.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol specified in [MS-RPCE].
	CreateClientInfoV6(context.Context, *CreateClientInfoV6Request, ...dcerpc.CallOption) (*CreateClientInfoV6Response, error)

	// The R_DhcpV4FailoverGetAddressStatus method queries the current address status for
	// an address belonging to a subnet that is part of a failover relationship on the DHCP
	// server.
	//
	// Return Values: A 32-bit unsigned integer value that indicates return status. A return
	// value of ERROR_SUCCESS (0x00000000) indicates that the operation was completed successfully.
	// Otherwise, it contains a Win32 error code, as specified in [MS-ERREF]. This error
	// code value can correspond to a DHCP-specific failure, which takes a value between
	// 20000 and 20099, or to any generic failure.
	//
	//	+----------------------------------------------------+--------------------------------------------------------------------------------+
	//	|                       RETURN                       |                                                                                |
	//	|                     VALUE/CODE                     |                                  DESCRIPTION                                   |
	//	|                                                    |                                                                                |
	//	+----------------------------------------------------+--------------------------------------------------------------------------------+
	//	+----------------------------------------------------+--------------------------------------------------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS                           | The call completed successfully.                                               |
	//	+----------------------------------------------------+--------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER                 | An invalid parameter is specified in the Address parameter.                    |
	//	+----------------------------------------------------+--------------------------------------------------------------------------------+
	//	| 0x00004E94 ERROR_DHCP_FO_SCOPE_NOT_IN_RELATIONSHIP | The subnet associated with the address is not part of a failover relationship. |
	//	+----------------------------------------------------+--------------------------------------------------------------------------------+
	//
	// The opnum field value for this method is 125.
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol specified in [MS-RPCE].
	FailoverGetAddressStatusV4(context.Context, *FailoverGetAddressStatusV4Request, ...dcerpc.CallOption) (*FailoverGetAddressStatusV4Response, error)

	// The R_DhcpV4CreatePolicyEx method creates the policy according to the data specified
	// in the policy data structure.
	//
	// The R_DhcpV4CreatePolicyEx method is an extension of the R_DhcpV4CreatePolicy (Opnum
	// 108) (section 3.2.4.109) method, where a DHCP_POLICY_EX (section 2.2.1.2.121) structure
	// is specified for the pPolicy parameter, rather than a DHCP_POLICY (section 2.2.1.2.110)
	// structure. The structure contains the members of the policy to be created.
	//
	// Using the extension method, a list of DHCP_PROPERTY (section 2.2.1.2.117) elements
	// can be specified that can be associated with the given policy when creating the policy.
	//
	// Return Values: As specified in R_DhcpV4CreatePolicy (Opnum 108).
	//
	// The opnum field value for this method is 126.
	//
	// The remainder of the processing behavior for this method is as defined for the R_DhcpV4CreatePolicy
	// (Opnum 108) method.
	CreatePolicyExV4(context.Context, *CreatePolicyExV4Request, ...dcerpc.CallOption) (*CreatePolicyExV4Response, error)

	// The R_DhcpV4GetPolicyEx method returns the specified policy. The memory for the Policy
	// structure is allocated by the method and can be freed by the caller by using the
	// midl_user_free function (section 3).
	//
	// The R_DhcpV4GetPolicyEx method is an extension of the R_DhcpV4GetPolicy (Opnum 109)
	// (section 3.2.4.110) method, where a DHCP_POLICY_EX (section 2.2.1.2.121) structure
	// is queried, rather than a DHCP_POLICY (section 2.2.1.2.110) structure. The structure
	// returns a list of DHCP_PROPERTY (section 2.2.1.2.117) elements that can be associated
	// with the given policy.
	//
	// Return Values: As specified in R_DhcpV4CreatePolicy (Opnum 108).
	//
	// The opnum field value for this method is 127.
	//
	// The remainder of the processing behavior for this method is as defined for the R_DhcpV4GetPolicy
	// (Opnum 109) method.
	GetPolicyExV4(context.Context, *GetPolicyExV4Request, ...dcerpc.CallOption) (*GetPolicyExV4Response, error)

	// The R_DhcpV4SetPolicyEx method modifies the specified policy.
	//
	// The method is an extension of the R_DhcpV4SetPolicy (Opnum 110) (section 3.2.4.111)
	// method, where the method specifies a DHCP_POLICY_EX (section 2.2.1.2.121) structure
	// rather than a DHCP_POLICY (section 2.2.1.2.110) structure. The structure contains
	// a list of DHCP_PROPERTY (section 2.2.1.2.117) elements that can be updated for the
	// policy.
	//
	// Return Values: As specified in R_DhcpV4SetPolicy (Opnum 110).
	//
	// The opnum field value for this method is 128.
	//
	// The remainder of the processing behavior for this method is as defined for the R_DhcpV4SetPolicy
	// (Opnum 110) method, except as follows:
	//
	// * The FieldsModified parameter can also be set to the DhcpUpdatePolicyDnsSuffix value
	// of the DHCP_POLICY_FIELDS_TO_UPDATE (section 2.2.1.1.21) ( 49abe631-1c6b-4711-8337-b4b2bdf90b00
	// ) enumeration.
	//
	// * If the FieldsModified parameter is set to DhcpUpdatePolicyDnsSuffix, the *R_DhcpV4SetPolicyEx*
	// method searches for the property with an ID value of DhcpPropIdPolicyDnsSuffix and
	// Type value of DhcpPropTypeString. If such a property is located, the *R_DhcpV4SetPolicyEx*
	// method validates that the string length of the property value does not exceed 255
	// characters. If the length is exceeded, the *R_DhcpV4SetPolicyEx* method returns ERROR_INVALID_PARAMETER.
	//
	// * The *R_DhcpV4SetPolicyEx* method updates the server or scope level <DHCPv4Policy>
	// ADM element retrieved earlier according to the following:
	//
	// In addition to steps 1 through 5 specified in *R_DhcpV4SetPolicy* (Opnum 110), the
	// *R_DhcpV4SetPolicyEx* method adds the following instruction:
	//
	// * If the *DhcpUpdatePolicyDnsSuffix* enumeration value is set in the FieldsModified
	// parameter, update the DNSSuffix of the policy in the <DHCPv4Policy.DnsSuffix> ADM
	// element. If no such property exists in the list of properties with an ID value equal
	// to DhcpPropIdPolicyDnsSuffix and a Type value equal to DhcpPropTypeString, or if
	// the StringValue of the property is NULL or of zero length, then the <DHCPv4Policy.DnsSuffix>
	// ADM element is cleared; otherwise, the ADM element is set to the StringValue of the
	// property.
	//
	// * The FieldsModified parameter is set to any value other than DhcpUpdatePolicyName,
	// DhcpUpdatePolicyOrder, DhcpUpdatePolicyExpr, DhcpUpdatePolicyRanges, DhcpUpdatePolicyDescr,
	// DhcpUpdatePolicyStatus, or DhcpUpdatePolicyDnsSuffix, as defined in *DHCP_POLICY_FIELDS_TO_UPDATE*
	// enumeration.
	//
	// * The *R_DhcpV4SetPolicyEx* method returns ERROR_INVALID_PARAMETER.
	SetPolicyExV4(context.Context, *SetPolicyExV4Request, ...dcerpc.CallOption) (*SetPolicyExV4Response, error)

	// The R_DhcpV4EnumPoliciesEx method returns an enumerated list of all configured server
	// level or scope level policies. The caller of this method can free the memory pointed
	// to by the EnumInfo parameter by calling the midl_user_free function (section 3).
	//
	// The R_DhcpV4EnumPoliciesEx method is an extension of the R_DhcpV4EnumPolicies (Opnum
	// 112) (section 3.2.4.130) method, where an array of DHCP_POLICY_EX (section 2.2.1.2.121)
	// structures is enumerated, rather than an array of DHCP_POLICY (section 2.2.1.2.110)
	// structures. Each DHCP_POLICY_EX structure contains a list of DHCP_PROPERTY (section
	// 2.2.1.2.117) elements that are associated with the given policy.
	//
	// Return Values: As specified in R_DhcpV4EnumPolicies (Opnum 112).
	//
	// The opnum field value for this method is 129.
	//
	// The remainder of the processing behavior for this method is as defined for the R_DhcpV4EnumPolicies
	// method, except as follows:
	//
	// * No filtering is applied to the enumerated list of configured server-level or scope-level
	// policies returned by the *R_DhcpV4EnumPoliciesEx* method.
	EnumPoliciesExV4(context.Context, *EnumPoliciesExV4Request, ...dcerpc.CallOption) (*EnumPoliciesExV4Response, error)

	// The R_DhcpV4EnumSubnetClientsEx method is used to retrieve all DHCPv4 clients serviced
	// on the specified IPv4 subnet. The information retrieved also includes the link-layer
	// filter status for the DHCPv4 client and the policy, if any, that resulted in the
	// specific IPv4 address assignment.
	//
	// The R_DhcpV4EnumSubnetClientsEx method is an extension of the R_DhcpV4EnumSubnetClients
	// (Opnum 115) (section 3.2.4.116) method, where an array of  DHCP_CLIENT_INFO_EX (section
	// 2.2.1.2.119) structures is enumerated, rather than an array of DHCP_CLIENT_INFO_PB
	// (section 2.2.1.2.115) structures. Each DHCP_CLIENT_INFO_EX structure contains a list
	// of DHCP_PROPERTY (section 2.2.1.2.117) elements that are associated with the given
	// subnet client.
	//
	// Return Values: As specified in R_DhcpV4EnumSubnetClients (Opnum 115).
	//
	// The opnum field value for this method is 130.
	//
	// The remainder of the processing behavior for this method is as defined for the R_DhcpV4EnumSubnetClients
	// method.
	EnumSubnetClientsExV4(context.Context, *EnumSubnetClientsExV4Request, ...dcerpc.CallOption) (*EnumSubnetClientsExV4Response, error)

	// The R_DhcpV4CreateClientInfoEx method creates a DHCPv4 client lease record on the
	// DHCP server.
	//
	// The R_DhcpV4CreateClientInfoEx method is an extension of the R_DhcpV4CreateClientInfo
	// (Opnum 122) (section 3.2.4.132) method, where a DHCP_CLIENT_INFO_EX (section 2.2.1.2.119)
	// structure is specified, rather than a DHCP_CLIENT_INFO_PB (section 2.2.1.2.119) structure.
	// The structure contains a list of DHCP_PROPERTY (section 2.2.1.2.117) elements that
	// can be associated with the given DHCPv4 client.
	CreateClientInfoExV4(context.Context, *CreateClientInfoExV4Request, ...dcerpc.CallOption) (*CreateClientInfoExV4Response, error)

	// The R_DhcpV4GetClientInfoEx method retrieves DHCPv4 client lease record information
	// from the DHCPv4 server database. The retrieved information also includes the link-layer
	// filter status information for the DHCPv4 client and the policy, if any, that resulted
	// in the specific IPv4 address assignment. The caller of this method can free the memory
	// pointed to by the ClientInfo parameter by calling the midl_user_free function (section
	// 3).
	//
	// The R_DhcpV4GetClientInfoEx method is an extension of the R_DhcpV4GetClientInfo (Opnum
	// 123) (section 3.2.4.124) method, where a DHCP_CLIENT_INFO_EX (section 2.2.1.2.119)
	// structure is queried, rather than a DHCP_CLIENT_INFO_PB (section 2.2.1.2.115) structure.
	// The structure returns a list of DHCP_PROPERTY (section 2.2.1.2.117) elements that
	// can be associated with the given DHCPv4 client.
	//
	// Return Values: As specified in R_DhcpV4GetClientInfo (Opnum 123).
	//
	// The opnum field value for this method is 132.
	//
	// The remainder of the processing behavior for this method is as defined for the R_DhcpV4GetClientInfo
	// method.
	GetClientInfoExV4(context.Context, *GetClientInfoExV4Request, ...dcerpc.CallOption) (*GetClientInfoExV4Response, error)

	// AlterContext alters the client context.
	AlterContext(context.Context, ...dcerpc.Option) error

	// Conn returns the client connection (unsafe)
	Conn() dcerpc.Conn
}

type xxx_DefaultDhcpsrv2Client struct {
	cc dcerpc.Conn
}

func (o *xxx_DefaultDhcpsrv2Client) EnumSubnetClientsV5(ctx context.Context, in *EnumSubnetClientsV5Request, opts ...dcerpc.CallOption) (*EnumSubnetClientsV5Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumSubnetClientsV5Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) SetMScopeInfo(ctx context.Context, in *SetMScopeInfoRequest, opts ...dcerpc.CallOption) (*SetMScopeInfoResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetMScopeInfoResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) GetMScopeInfo(ctx context.Context, in *GetMScopeInfoRequest, opts ...dcerpc.CallOption) (*GetMScopeInfoResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetMScopeInfoResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) EnumMScopes(ctx context.Context, in *EnumMScopesRequest, opts ...dcerpc.CallOption) (*EnumMScopesResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumMScopesResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) AddMScopeElement(ctx context.Context, in *AddMScopeElementRequest, opts ...dcerpc.CallOption) (*AddMScopeElementResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddMScopeElementResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) EnumMScopeElements(ctx context.Context, in *EnumMScopeElementsRequest, opts ...dcerpc.CallOption) (*EnumMScopeElementsResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumMScopeElementsResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) RemoveMScopeElement(ctx context.Context, in *RemoveMScopeElementRequest, opts ...dcerpc.CallOption) (*RemoveMScopeElementResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &RemoveMScopeElementResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) DeleteMScope(ctx context.Context, in *DeleteMScopeRequest, opts ...dcerpc.CallOption) (*DeleteMScopeResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &DeleteMScopeResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) ScanMDatabase(ctx context.Context, in *ScanMDatabaseRequest, opts ...dcerpc.CallOption) (*ScanMDatabaseResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ScanMDatabaseResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) CreateMClientInfo(ctx context.Context, in *CreateMClientInfoRequest, opts ...dcerpc.CallOption) (*CreateMClientInfoResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CreateMClientInfoResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) SetMClientInfo(ctx context.Context, in *SetMClientInfoRequest, opts ...dcerpc.CallOption) (*SetMClientInfoResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetMClientInfoResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) GetMClientInfo(ctx context.Context, in *GetMClientInfoRequest, opts ...dcerpc.CallOption) (*GetMClientInfoResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetMClientInfoResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) DeleteMClientInfo(ctx context.Context, in *DeleteMClientInfoRequest, opts ...dcerpc.CallOption) (*DeleteMClientInfoResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &DeleteMClientInfoResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) EnumMScopeClients(ctx context.Context, in *EnumMScopeClientsRequest, opts ...dcerpc.CallOption) (*EnumMScopeClientsResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumMScopeClientsResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) CreateOptionV5(ctx context.Context, in *CreateOptionV5Request, opts ...dcerpc.CallOption) (*CreateOptionV5Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CreateOptionV5Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) SetOptionInfoV5(ctx context.Context, in *SetOptionInfoV5Request, opts ...dcerpc.CallOption) (*SetOptionInfoV5Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetOptionInfoV5Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) GetOptionInfoV5(ctx context.Context, in *GetOptionInfoV5Request, opts ...dcerpc.CallOption) (*GetOptionInfoV5Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetOptionInfoV5Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) EnumOptionsV5(ctx context.Context, in *EnumOptionsV5Request, opts ...dcerpc.CallOption) (*EnumOptionsV5Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumOptionsV5Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) RemoveOptionV5(ctx context.Context, in *RemoveOptionV5Request, opts ...dcerpc.CallOption) (*RemoveOptionV5Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &RemoveOptionV5Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) SetOptionValueV5(ctx context.Context, in *SetOptionValueV5Request, opts ...dcerpc.CallOption) (*SetOptionValueV5Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetOptionValueV5Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) SetOptionValuesV5(ctx context.Context, in *SetOptionValuesV5Request, opts ...dcerpc.CallOption) (*SetOptionValuesV5Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetOptionValuesV5Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) GetOptionValueV5(ctx context.Context, in *GetOptionValueV5Request, opts ...dcerpc.CallOption) (*GetOptionValueV5Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetOptionValueV5Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) EnumOptionValuesV5(ctx context.Context, in *EnumOptionValuesV5Request, opts ...dcerpc.CallOption) (*EnumOptionValuesV5Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumOptionValuesV5Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) RemoveOptionValueV5(ctx context.Context, in *RemoveOptionValueV5Request, opts ...dcerpc.CallOption) (*RemoveOptionValueV5Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &RemoveOptionValueV5Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) CreateClass(ctx context.Context, in *CreateClassRequest, opts ...dcerpc.CallOption) (*CreateClassResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CreateClassResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) ModifyClass(ctx context.Context, in *ModifyClassRequest, opts ...dcerpc.CallOption) (*ModifyClassResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ModifyClassResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) DeleteClass(ctx context.Context, in *DeleteClassRequest, opts ...dcerpc.CallOption) (*DeleteClassResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &DeleteClassResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) GetClassInfo(ctx context.Context, in *GetClassInfoRequest, opts ...dcerpc.CallOption) (*GetClassInfoResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetClassInfoResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) EnumClasses(ctx context.Context, in *EnumClassesRequest, opts ...dcerpc.CallOption) (*EnumClassesResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumClassesResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) GetAllOptions(ctx context.Context, in *GetAllOptionsRequest, opts ...dcerpc.CallOption) (*GetAllOptionsResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetAllOptionsResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) GetAllOptionValues(ctx context.Context, in *GetAllOptionValuesRequest, opts ...dcerpc.CallOption) (*GetAllOptionValuesResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetAllOptionValuesResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) GetMCastMIBInfo(ctx context.Context, in *GetMCastMIBInfoRequest, opts ...dcerpc.CallOption) (*GetMCastMIBInfoResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetMCastMIBInfoResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) AuditLogSetParams(ctx context.Context, in *AuditLogSetParamsRequest, opts ...dcerpc.CallOption) (*AuditLogSetParamsResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AuditLogSetParamsResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) AuditLogGetParams(ctx context.Context, in *AuditLogGetParamsRequest, opts ...dcerpc.CallOption) (*AuditLogGetParamsResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AuditLogGetParamsResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) ServerQueryAttribute(ctx context.Context, in *ServerQueryAttributeRequest, opts ...dcerpc.CallOption) (*ServerQueryAttributeResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ServerQueryAttributeResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) ServerQueryAttributes(ctx context.Context, in *ServerQueryAttributesRequest, opts ...dcerpc.CallOption) (*ServerQueryAttributesResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ServerQueryAttributesResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) ServerRedoAuthorization(ctx context.Context, in *ServerRedoAuthorizationRequest, opts ...dcerpc.CallOption) (*ServerRedoAuthorizationResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ServerRedoAuthorizationResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) AddSubnetElementV5(ctx context.Context, in *AddSubnetElementV5Request, opts ...dcerpc.CallOption) (*AddSubnetElementV5Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddSubnetElementV5Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) EnumSubnetElementsV5(ctx context.Context, in *EnumSubnetElementsV5Request, opts ...dcerpc.CallOption) (*EnumSubnetElementsV5Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumSubnetElementsV5Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) RemoveSubnetElementV5(ctx context.Context, in *RemoveSubnetElementV5Request, opts ...dcerpc.CallOption) (*RemoveSubnetElementV5Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &RemoveSubnetElementV5Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) GetServerBindingInfo(ctx context.Context, in *GetServerBindingInfoRequest, opts ...dcerpc.CallOption) (*GetServerBindingInfoResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetServerBindingInfoResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) SetServerBindingInfo(ctx context.Context, in *SetServerBindingInfoRequest, opts ...dcerpc.CallOption) (*SetServerBindingInfoResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetServerBindingInfoResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) QueryDNSRegCredentials(ctx context.Context, in *QueryDNSRegCredentialsRequest, opts ...dcerpc.CallOption) (*QueryDNSRegCredentialsResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &QueryDNSRegCredentialsResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) SetDNSRegCredentials(ctx context.Context, in *SetDNSRegCredentialsRequest, opts ...dcerpc.CallOption) (*SetDNSRegCredentialsResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetDNSRegCredentialsResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) BackupDatabase(ctx context.Context, in *BackupDatabaseRequest, opts ...dcerpc.CallOption) (*BackupDatabaseResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &BackupDatabaseResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) RestoreDatabase(ctx context.Context, in *RestoreDatabaseRequest, opts ...dcerpc.CallOption) (*RestoreDatabaseResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &RestoreDatabaseResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) GetServerSpecificStrings(ctx context.Context, in *GetServerSpecificStringsRequest, opts ...dcerpc.CallOption) (*GetServerSpecificStringsResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetServerSpecificStringsResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) CreateOptionV6(ctx context.Context, in *CreateOptionV6Request, opts ...dcerpc.CallOption) (*CreateOptionV6Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CreateOptionV6Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) SetOptionInfoV6(ctx context.Context, in *SetOptionInfoV6Request, opts ...dcerpc.CallOption) (*SetOptionInfoV6Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetOptionInfoV6Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) GetOptionInfoV6(ctx context.Context, in *GetOptionInfoV6Request, opts ...dcerpc.CallOption) (*GetOptionInfoV6Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetOptionInfoV6Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) EnumOptionsV6(ctx context.Context, in *EnumOptionsV6Request, opts ...dcerpc.CallOption) (*EnumOptionsV6Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumOptionsV6Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) RemoveOptionV6(ctx context.Context, in *RemoveOptionV6Request, opts ...dcerpc.CallOption) (*RemoveOptionV6Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &RemoveOptionV6Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) SetOptionValueV6(ctx context.Context, in *SetOptionValueV6Request, opts ...dcerpc.CallOption) (*SetOptionValueV6Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetOptionValueV6Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) EnumOptionValuesV6(ctx context.Context, in *EnumOptionValuesV6Request, opts ...dcerpc.CallOption) (*EnumOptionValuesV6Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumOptionValuesV6Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) RemoveOptionValueV6(ctx context.Context, in *RemoveOptionValueV6Request, opts ...dcerpc.CallOption) (*RemoveOptionValueV6Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &RemoveOptionValueV6Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) GetAllOptionsV6(ctx context.Context, in *GetAllOptionsV6Request, opts ...dcerpc.CallOption) (*GetAllOptionsV6Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetAllOptionsV6Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) GetAllOptionValuesV6(ctx context.Context, in *GetAllOptionValuesV6Request, opts ...dcerpc.CallOption) (*GetAllOptionValuesV6Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetAllOptionValuesV6Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) CreateSubnetV6(ctx context.Context, in *CreateSubnetV6Request, opts ...dcerpc.CallOption) (*CreateSubnetV6Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CreateSubnetV6Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) EnumSubnetsV6(ctx context.Context, in *EnumSubnetsV6Request, opts ...dcerpc.CallOption) (*EnumSubnetsV6Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumSubnetsV6Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) AddSubnetElementV6(ctx context.Context, in *AddSubnetElementV6Request, opts ...dcerpc.CallOption) (*AddSubnetElementV6Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddSubnetElementV6Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) EnumSubnetElementsV6(ctx context.Context, in *EnumSubnetElementsV6Request, opts ...dcerpc.CallOption) (*EnumSubnetElementsV6Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumSubnetElementsV6Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) RemoveSubnetElementV6(ctx context.Context, in *RemoveSubnetElementV6Request, opts ...dcerpc.CallOption) (*RemoveSubnetElementV6Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &RemoveSubnetElementV6Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) DeleteSubnetV6(ctx context.Context, in *DeleteSubnetV6Request, opts ...dcerpc.CallOption) (*DeleteSubnetV6Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &DeleteSubnetV6Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) GetSubnetInfoV6(ctx context.Context, in *GetSubnetInfoV6Request, opts ...dcerpc.CallOption) (*GetSubnetInfoV6Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetSubnetInfoV6Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) EnumSubnetClientsV6(ctx context.Context, in *EnumSubnetClientsV6Request, opts ...dcerpc.CallOption) (*EnumSubnetClientsV6Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumSubnetClientsV6Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) ServerSetConfigV6(ctx context.Context, in *ServerSetConfigV6Request, opts ...dcerpc.CallOption) (*ServerSetConfigV6Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ServerSetConfigV6Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) ServerGetConfigV6(ctx context.Context, in *ServerGetConfigV6Request, opts ...dcerpc.CallOption) (*ServerGetConfigV6Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ServerGetConfigV6Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) SetSubnetInfoV6(ctx context.Context, in *SetSubnetInfoV6Request, opts ...dcerpc.CallOption) (*SetSubnetInfoV6Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetSubnetInfoV6Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) GetMIBInfoV6(ctx context.Context, in *GetMIBInfoV6Request, opts ...dcerpc.CallOption) (*GetMIBInfoV6Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetMIBInfoV6Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) GetServerBindingInfoV6(ctx context.Context, in *GetServerBindingInfoV6Request, opts ...dcerpc.CallOption) (*GetServerBindingInfoV6Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetServerBindingInfoV6Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) SetServerBindingInfoV6(ctx context.Context, in *SetServerBindingInfoV6Request, opts ...dcerpc.CallOption) (*SetServerBindingInfoV6Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetServerBindingInfoV6Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) SetClientInfoV6(ctx context.Context, in *SetClientInfoV6Request, opts ...dcerpc.CallOption) (*SetClientInfoV6Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetClientInfoV6Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) GetClientInfoV6(ctx context.Context, in *GetClientInfoV6Request, opts ...dcerpc.CallOption) (*GetClientInfoV6Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetClientInfoV6Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) DeleteClientInfoV6(ctx context.Context, in *DeleteClientInfoV6Request, opts ...dcerpc.CallOption) (*DeleteClientInfoV6Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &DeleteClientInfoV6Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) CreateClassV6(ctx context.Context, in *CreateClassV6Request, opts ...dcerpc.CallOption) (*CreateClassV6Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CreateClassV6Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) ModifyClassV6(ctx context.Context, in *ModifyClassV6Request, opts ...dcerpc.CallOption) (*ModifyClassV6Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ModifyClassV6Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) DeleteClassV6(ctx context.Context, in *DeleteClassV6Request, opts ...dcerpc.CallOption) (*DeleteClassV6Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &DeleteClassV6Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) EnumClassesV6(ctx context.Context, in *EnumClassesV6Request, opts ...dcerpc.CallOption) (*EnumClassesV6Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumClassesV6Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) GetOptionValueV6(ctx context.Context, in *GetOptionValueV6Request, opts ...dcerpc.CallOption) (*GetOptionValueV6Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetOptionValueV6Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) SetSubnetDelayOffer(ctx context.Context, in *SetSubnetDelayOfferRequest, opts ...dcerpc.CallOption) (*SetSubnetDelayOfferResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetSubnetDelayOfferResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) GetSubnetDelayOffer(ctx context.Context, in *GetSubnetDelayOfferRequest, opts ...dcerpc.CallOption) (*GetSubnetDelayOfferResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetSubnetDelayOfferResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) GetMIBInfoV5(ctx context.Context, in *GetMIBInfoV5Request, opts ...dcerpc.CallOption) (*GetMIBInfoV5Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetMIBInfoV5Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) AddFilterV4(ctx context.Context, in *AddFilterV4Request, opts ...dcerpc.CallOption) (*AddFilterV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddFilterV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) DeleteFilterV4(ctx context.Context, in *DeleteFilterV4Request, opts ...dcerpc.CallOption) (*DeleteFilterV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &DeleteFilterV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) SetFilterV4(ctx context.Context, in *SetFilterV4Request, opts ...dcerpc.CallOption) (*SetFilterV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetFilterV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) GetFilterV4(ctx context.Context, in *GetFilterV4Request, opts ...dcerpc.CallOption) (*GetFilterV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetFilterV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) EnumFilterV4(ctx context.Context, in *EnumFilterV4Request, opts ...dcerpc.CallOption) (*EnumFilterV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumFilterV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) SetDNSRegCredentialsV5(ctx context.Context, in *SetDNSRegCredentialsV5Request, opts ...dcerpc.CallOption) (*SetDNSRegCredentialsV5Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetDNSRegCredentialsV5Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) EnumSubnetClientsFilterStatusInfo(ctx context.Context, in *EnumSubnetClientsFilterStatusInfoRequest, opts ...dcerpc.CallOption) (*EnumSubnetClientsFilterStatusInfoResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumSubnetClientsFilterStatusInfoResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) FailoverCreateRelationshipV4(ctx context.Context, in *FailoverCreateRelationshipV4Request, opts ...dcerpc.CallOption) (*FailoverCreateRelationshipV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &FailoverCreateRelationshipV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) FailoverSetRelationshipV4(ctx context.Context, in *FailoverSetRelationshipV4Request, opts ...dcerpc.CallOption) (*FailoverSetRelationshipV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &FailoverSetRelationshipV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) FailoverDeleteRelationshipV4(ctx context.Context, in *FailoverDeleteRelationshipV4Request, opts ...dcerpc.CallOption) (*FailoverDeleteRelationshipV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &FailoverDeleteRelationshipV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) FailoverGetRelationshipV4(ctx context.Context, in *FailoverGetRelationshipV4Request, opts ...dcerpc.CallOption) (*FailoverGetRelationshipV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &FailoverGetRelationshipV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) FailoverEnumRelationshipV4(ctx context.Context, in *FailoverEnumRelationshipV4Request, opts ...dcerpc.CallOption) (*FailoverEnumRelationshipV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &FailoverEnumRelationshipV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) FailoverAddScopeToRelationshipV4(ctx context.Context, in *FailoverAddScopeToRelationshipV4Request, opts ...dcerpc.CallOption) (*FailoverAddScopeToRelationshipV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &FailoverAddScopeToRelationshipV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) FailoverDeleteScopeFromRelationshipV4(ctx context.Context, in *FailoverDeleteScopeFromRelationshipV4Request, opts ...dcerpc.CallOption) (*FailoverDeleteScopeFromRelationshipV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &FailoverDeleteScopeFromRelationshipV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) FailoverGetScopeRelationshipV4(ctx context.Context, in *FailoverGetScopeRelationshipV4Request, opts ...dcerpc.CallOption) (*FailoverGetScopeRelationshipV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &FailoverGetScopeRelationshipV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) FailoverGetScopeStatisticsV4(ctx context.Context, in *FailoverGetScopeStatisticsV4Request, opts ...dcerpc.CallOption) (*FailoverGetScopeStatisticsV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &FailoverGetScopeStatisticsV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) FailoverGetClientInfoV4(ctx context.Context, in *FailoverGetClientInfoV4Request, opts ...dcerpc.CallOption) (*FailoverGetClientInfoV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &FailoverGetClientInfoV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) FailoverGetSystemTimeV4(ctx context.Context, in *FailoverGetSystemTimeV4Request, opts ...dcerpc.CallOption) (*FailoverGetSystemTimeV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &FailoverGetSystemTimeV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) FailoverTriggerAddrAllocationV4(ctx context.Context, in *FailoverTriggerAddrAllocationV4Request, opts ...dcerpc.CallOption) (*FailoverTriggerAddrAllocationV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &FailoverTriggerAddrAllocationV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) SetOptionValueV4(ctx context.Context, in *SetOptionValueV4Request, opts ...dcerpc.CallOption) (*SetOptionValueV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetOptionValueV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) SetOptionValuesV4(ctx context.Context, in *SetOptionValuesV4Request, opts ...dcerpc.CallOption) (*SetOptionValuesV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetOptionValuesV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) GetOptionValueV4(ctx context.Context, in *GetOptionValueV4Request, opts ...dcerpc.CallOption) (*GetOptionValueV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetOptionValueV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) RemoveOptionValueV4(ctx context.Context, in *RemoveOptionValueV4Request, opts ...dcerpc.CallOption) (*RemoveOptionValueV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &RemoveOptionValueV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) GetAllOptionValuesV4(ctx context.Context, in *GetAllOptionValuesV4Request, opts ...dcerpc.CallOption) (*GetAllOptionValuesV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetAllOptionValuesV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) QueryPolicyEnforcementV4(ctx context.Context, in *QueryPolicyEnforcementV4Request, opts ...dcerpc.CallOption) (*QueryPolicyEnforcementV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &QueryPolicyEnforcementV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) SetPolicyEnforcementV4(ctx context.Context, in *SetPolicyEnforcementV4Request, opts ...dcerpc.CallOption) (*SetPolicyEnforcementV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetPolicyEnforcementV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) CreatePolicyV4(ctx context.Context, in *CreatePolicyV4Request, opts ...dcerpc.CallOption) (*CreatePolicyV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CreatePolicyV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) GetPolicyV4(ctx context.Context, in *GetPolicyV4Request, opts ...dcerpc.CallOption) (*GetPolicyV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetPolicyV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) SetPolicyV4(ctx context.Context, in *SetPolicyV4Request, opts ...dcerpc.CallOption) (*SetPolicyV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetPolicyV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) DeletePolicyV4(ctx context.Context, in *DeletePolicyV4Request, opts ...dcerpc.CallOption) (*DeletePolicyV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &DeletePolicyV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) EnumPoliciesV4(ctx context.Context, in *EnumPoliciesV4Request, opts ...dcerpc.CallOption) (*EnumPoliciesV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumPoliciesV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) AddPolicyRangeV4(ctx context.Context, in *AddPolicyRangeV4Request, opts ...dcerpc.CallOption) (*AddPolicyRangeV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddPolicyRangeV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) RemovePolicyRangeV4(ctx context.Context, in *RemovePolicyRangeV4Request, opts ...dcerpc.CallOption) (*RemovePolicyRangeV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &RemovePolicyRangeV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) EnumSubnetClientsV4(ctx context.Context, in *EnumSubnetClientsV4Request, opts ...dcerpc.CallOption) (*EnumSubnetClientsV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumSubnetClientsV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) SetStatelessStoreParamsV6(ctx context.Context, in *SetStatelessStoreParamsV6Request, opts ...dcerpc.CallOption) (*SetStatelessStoreParamsV6Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetStatelessStoreParamsV6Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) GetStatelessStoreParamsV6(ctx context.Context, in *GetStatelessStoreParamsV6Request, opts ...dcerpc.CallOption) (*GetStatelessStoreParamsV6Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetStatelessStoreParamsV6Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) GetStatelessStatisticsV6(ctx context.Context, in *GetStatelessStatisticsV6Request, opts ...dcerpc.CallOption) (*GetStatelessStatisticsV6Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetStatelessStatisticsV6Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) EnumSubnetReservationsV4(ctx context.Context, in *EnumSubnetReservationsV4Request, opts ...dcerpc.CallOption) (*EnumSubnetReservationsV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumSubnetReservationsV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) GetFreeIPAddressV4(ctx context.Context, in *GetFreeIPAddressV4Request, opts ...dcerpc.CallOption) (*GetFreeIPAddressV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetFreeIPAddressV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) GetFreeIPAddressV6(ctx context.Context, in *GetFreeIPAddressV6Request, opts ...dcerpc.CallOption) (*GetFreeIPAddressV6Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetFreeIPAddressV6Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) CreateClientInfoV4(ctx context.Context, in *CreateClientInfoV4Request, opts ...dcerpc.CallOption) (*CreateClientInfoV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CreateClientInfoV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) GetClientInfoV4(ctx context.Context, in *GetClientInfoV4Request, opts ...dcerpc.CallOption) (*GetClientInfoV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetClientInfoV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) CreateClientInfoV6(ctx context.Context, in *CreateClientInfoV6Request, opts ...dcerpc.CallOption) (*CreateClientInfoV6Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CreateClientInfoV6Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) FailoverGetAddressStatusV4(ctx context.Context, in *FailoverGetAddressStatusV4Request, opts ...dcerpc.CallOption) (*FailoverGetAddressStatusV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &FailoverGetAddressStatusV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) CreatePolicyExV4(ctx context.Context, in *CreatePolicyExV4Request, opts ...dcerpc.CallOption) (*CreatePolicyExV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CreatePolicyExV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) GetPolicyExV4(ctx context.Context, in *GetPolicyExV4Request, opts ...dcerpc.CallOption) (*GetPolicyExV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetPolicyExV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) SetPolicyExV4(ctx context.Context, in *SetPolicyExV4Request, opts ...dcerpc.CallOption) (*SetPolicyExV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetPolicyExV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) EnumPoliciesExV4(ctx context.Context, in *EnumPoliciesExV4Request, opts ...dcerpc.CallOption) (*EnumPoliciesExV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumPoliciesExV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) EnumSubnetClientsExV4(ctx context.Context, in *EnumSubnetClientsExV4Request, opts ...dcerpc.CallOption) (*EnumSubnetClientsExV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumSubnetClientsExV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) CreateClientInfoExV4(ctx context.Context, in *CreateClientInfoExV4Request, opts ...dcerpc.CallOption) (*CreateClientInfoExV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &CreateClientInfoExV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) GetClientInfoExV4(ctx context.Context, in *GetClientInfoExV4Request, opts ...dcerpc.CallOption) (*GetClientInfoExV4Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetClientInfoExV4Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultDhcpsrv2Client) AlterContext(ctx context.Context, opts ...dcerpc.Option) error {
	return o.cc.AlterContext(ctx, opts...)
}

func (o *xxx_DefaultDhcpsrv2Client) Conn() dcerpc.Conn {
	return o.cc
}

func NewDhcpsrv2Client(ctx context.Context, cc dcerpc.Conn, opts ...dcerpc.Option) (Dhcpsrv2Client, error) {
	cc, err := cc.Bind(ctx, append(opts, dcerpc.WithAbstractSyntax(Dhcpsrv2SyntaxV1_0))...)
	if err != nil {
		return nil, err
	}
	return &xxx_DefaultDhcpsrv2Client{cc: cc}, nil
}

// xxx_EnumSubnetClientsV5Operation structure represents the R_DhcpEnumSubnetClientsV5 operation
type xxx_EnumSubnetClientsV5Operation struct {
	ServerIPAddress  string                   `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	SubnetAddress    uint32                   `idl:"name:SubnetAddress" json:"subnet_address"`
	Resume           uint32                   `idl:"name:ResumeHandle" json:"resume"`
	PreferredMaximum uint32                   `idl:"name:PreferredMaximum" json:"preferred_maximum"`
	ClientInfo       *dhcpm.ClientInfoArrayV5 `idl:"name:ClientInfo" json:"client_info"`
	ClientsRead      uint32                   `idl:"name:ClientsRead" json:"clients_read"`
	ClientsTotal     uint32                   `idl:"name:ClientsTotal" json:"clients_total"`
	Return           uint32                   `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumSubnetClientsV5Operation) OpNum() int { return 0 }

func (o *xxx_EnumSubnetClientsV5Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpEnumSubnetClientsV5"
}

func (o *xxx_EnumSubnetClientsV5Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetClientsV5Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.SubnetAddress); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Resume); err != nil {
			return err
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PreferredMaximum); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetClientsV5Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.SubnetAddress); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Resume); err != nil {
			return err
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PreferredMaximum); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetClientsV5Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetClientsV5Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Resume); err != nil {
			return err
		}
	}
	// ClientInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_CLIENT_INFO_ARRAY_V5}*(1))(3:{alias=DHCP_CLIENT_INFO_ARRAY_V5}(struct))
	{
		if o.ClientInfo != nil {
			_ptr_ClientInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.ClientInfo != nil {
					if err := o.ClientInfo.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.ClientInfoArrayV5{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ClientInfo, _ptr_ClientInfo); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ClientsRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ClientsRead); err != nil {
			return err
		}
	}
	// ClientsTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ClientsTotal); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetClientsV5Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Resume); err != nil {
			return err
		}
	}
	// ClientInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_CLIENT_INFO_ARRAY_V5,pointer=ref}*(1))(3:{alias=DHCP_CLIENT_INFO_ARRAY_V5}(struct))
	{
		_ptr_ClientInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.ClientInfo == nil {
				o.ClientInfo = &dhcpm.ClientInfoArrayV5{}
			}
			if err := o.ClientInfo.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ClientInfo := func(ptr interface{}) { o.ClientInfo = *ptr.(**dhcpm.ClientInfoArrayV5) }
		if err := w.ReadPointer(&o.ClientInfo, _s_ClientInfo, _ptr_ClientInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ClientsRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ClientsRead); err != nil {
			return err
		}
	}
	// ClientsTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ClientsTotal); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumSubnetClientsV5Request structure represents the R_DhcpEnumSubnetClientsV5 operation request
type EnumSubnetClientsV5Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// SubnetAddress: This is of DHCP_IP_ADDRESS (section 2.2.1.2.1), containing the IPv4
	// subnet ID from which DHCPv4 clients are enumerated. If this parameter is set to 0,
	// the DHCPv4 clients from all the IPv4 subnets are returned.
	SubnetAddress uint32 `idl:"name:SubnetAddress" json:"subnet_address"`
	// ResumeHandle: This is a pointer of type DHCP_RESUME_HANDLE (section 2.2.1.2.6) that
	// identifies the enumeration operation. Initially, this value MUST be set to zero,
	// with a successful call returning the handle value used for subsequent enumeration
	// requests. This parameter contains the last IPv4 address retrieved.
	Resume uint32 `idl:"name:ResumeHandle" json:"resume"`
	// PreferredMaximum: This is of type DWORD, specifying the preferred maximum number
	// of bytes to return. The minimum value is 1,024 bytes (1 kilobyte), and the maximum
	// value is 65,536 bytes (64 kilobytes). If the input value is greater or less than
	// this range, it MUST be set to the maximum or minimum value, respectively. To retrieve
	// all the DHCPv4 clients serviced by a specific IPv4 subnet, 0xFFFFFFFF is specified.
	PreferredMaximum uint32 `idl:"name:PreferredMaximum" json:"preferred_maximum"`
}

func (o *EnumSubnetClientsV5Request) xxx_ToOp(ctx context.Context, op *xxx_EnumSubnetClientsV5Operation) *xxx_EnumSubnetClientsV5Operation {
	if op == nil {
		op = &xxx_EnumSubnetClientsV5Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.SubnetAddress = o.SubnetAddress
	op.Resume = o.Resume
	op.PreferredMaximum = o.PreferredMaximum
	return op
}

func (o *EnumSubnetClientsV5Request) xxx_FromOp(ctx context.Context, op *xxx_EnumSubnetClientsV5Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.SubnetAddress = op.SubnetAddress
	o.Resume = op.Resume
	o.PreferredMaximum = op.PreferredMaximum
}
func (o *EnumSubnetClientsV5Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumSubnetClientsV5Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumSubnetClientsV5Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumSubnetClientsV5Response structure represents the R_DhcpEnumSubnetClientsV5 operation response
type EnumSubnetClientsV5Response struct {
	// ResumeHandle: This is a pointer of type DHCP_RESUME_HANDLE (section 2.2.1.2.6) that
	// identifies the enumeration operation. Initially, this value MUST be set to zero,
	// with a successful call returning the handle value used for subsequent enumeration
	// requests. This parameter contains the last IPv4 address retrieved.
	Resume uint32 `idl:"name:ResumeHandle" json:"resume"`
	// ClientInfo: This is a pointer of type LPDHCP_CLIENT_INFO_ARRAY_V5 (section 2.2.1.2.17)
	// that points to the location that contains the DHCPv4 client lease record array.
	ClientInfo *dhcpm.ClientInfoArrayV5 `idl:"name:ClientInfo" json:"client_info"`
	// ClientsRead: This is a pointer to a DWORD that specifies the number of DHCPv4 client
	// lease records read in the ClientInfo parameter. The caller MUST allocate memory for
	// this parameter equal to the size of data type DWORD.
	ClientsRead uint32 `idl:"name:ClientsRead" json:"clients_read"`
	// ClientsTotal: This is a pointer to a DWORD that specifies the number of DHCPv4 client
	// lease records remaining from the current position. For example, if there are 100
	// DHCPv4 lease record clients for an IPv4 subnet, and if 10 DHCPv4 lease records are
	// enumerated per call, for the first time this would have a value of 90.<45> The caller
	// MUST allocate memory for this parameter equal to the size of data type DWORD.
	ClientsTotal uint32 `idl:"name:ClientsTotal" json:"clients_total"`
	// Return: The R_DhcpEnumSubnetClientsV5 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumSubnetClientsV5Response) xxx_ToOp(ctx context.Context, op *xxx_EnumSubnetClientsV5Operation) *xxx_EnumSubnetClientsV5Operation {
	if op == nil {
		op = &xxx_EnumSubnetClientsV5Operation{}
	}
	if o == nil {
		return op
	}
	op.Resume = o.Resume
	op.ClientInfo = o.ClientInfo
	op.ClientsRead = o.ClientsRead
	op.ClientsTotal = o.ClientsTotal
	op.Return = o.Return
	return op
}

func (o *EnumSubnetClientsV5Response) xxx_FromOp(ctx context.Context, op *xxx_EnumSubnetClientsV5Operation) {
	if o == nil {
		return
	}
	o.Resume = op.Resume
	o.ClientInfo = op.ClientInfo
	o.ClientsRead = op.ClientsRead
	o.ClientsTotal = op.ClientsTotal
	o.Return = op.Return
}
func (o *EnumSubnetClientsV5Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumSubnetClientsV5Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumSubnetClientsV5Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetMScopeInfoOperation structure represents the R_DhcpSetMScopeInfo operation
type xxx_SetMScopeInfoOperation struct {
	ServerIPAddress string            `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	MScopeName      string            `idl:"name:MScopeName;string;pointer:ref" json:"mscope_name"`
	MScopeInfo      *dhcpm.MScopeInfo `idl:"name:MScopeInfo;pointer:ref" json:"mscope_info"`
	NewScope        bool              `idl:"name:NewScope" json:"new_scope"`
	Return          uint32            `idl:"name:Return" json:"return"`
}

func (o *xxx_SetMScopeInfoOperation) OpNum() int { return 1 }

func (o *xxx_SetMScopeInfoOperation) OpName() string { return "/dhcpsrv2/v1/R_DhcpSetMScopeInfo" }

func (o *xxx_SetMScopeInfoOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetMScopeInfoOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// MScopeName {in} (1:{string, pointer=ref}*(2))(2:{string, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.MScopeName != "" {
			_ptr_MScopeName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.MScopeName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.MScopeName, _ptr_MScopeName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// MScopeInfo {in} (1:{pointer=ref, alias=LPDHCP_MSCOPE_INFO}*(1))(2:{alias=DHCP_MSCOPE_INFO}(struct))
	{
		if o.MScopeInfo != nil {
			if err := o.MScopeInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.MScopeInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// NewScope {in} (1:{alias=BOOL}(int32))
	{
		if !o.NewScope {
			if err := w.WriteData(int32(0)); err != nil {
				return err
			}
		} else {
			if err := w.WriteData(int32(1)); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_SetMScopeInfoOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// MScopeName {in} (1:{string, pointer=ref}*(2))(2:{string, alias=LPWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		_ptr_MScopeName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.MScopeName); err != nil {
				return err
			}
			return nil
		})
		_s_MScopeName := func(ptr interface{}) { o.MScopeName = *ptr.(*string) }
		if err := w.ReadPointer(&o.MScopeName, _s_MScopeName, _ptr_MScopeName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// MScopeInfo {in} (1:{pointer=ref, alias=LPDHCP_MSCOPE_INFO}*(1))(2:{alias=DHCP_MSCOPE_INFO}(struct))
	{
		if o.MScopeInfo == nil {
			o.MScopeInfo = &dhcpm.MScopeInfo{}
		}
		if err := o.MScopeInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// NewScope {in} (1:{alias=BOOL}(int32))
	{
		var _bNewScope int32
		if err := w.ReadData(&_bNewScope); err != nil {
			return err
		}
		o.NewScope = _bNewScope != 0
	}
	return nil
}

func (o *xxx_SetMScopeInfoOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetMScopeInfoOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetMScopeInfoOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetMScopeInfoRequest structure represents the R_DhcpSetMScopeInfo operation request
type SetMScopeInfoRequest struct {
	// ServerIpAddress: The IP address/host name of the MADCAP server. This parameter is
	// unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// MScopeName: This is a pointer to a Unicode string that contains the name of the IPv4
	// multicast subnet that has to be created or modified. The size of the name is limited
	// to MAX_PATH, including the terminating NULL character. MAX_PATH is defined as 260
	// characters.
	MScopeName string `idl:"name:MScopeName;string;pointer:ref" json:"mscope_name"`
	// MScopeInfo: This is a pointer of type LPDHCP_MSCOPE_INFO (section 2.2.1.2.71), providing
	// the IPv4 multicast subnet information that is to be created or modified.
	MScopeInfo *dhcpm.MScopeInfo `idl:"name:MScopeInfo;pointer:ref" json:"mscope_info"`
	// NewScope: This is of type BOOL. A TRUE value indicates that the IPv4 multicast subnet
	// needs to be created, and a FALSE value indicates that the existing IPv4 multicast
	// subnet needs to be modified.
	NewScope bool `idl:"name:NewScope" json:"new_scope"`
}

func (o *SetMScopeInfoRequest) xxx_ToOp(ctx context.Context, op *xxx_SetMScopeInfoOperation) *xxx_SetMScopeInfoOperation {
	if op == nil {
		op = &xxx_SetMScopeInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.MScopeName = o.MScopeName
	op.MScopeInfo = o.MScopeInfo
	op.NewScope = o.NewScope
	return op
}

func (o *SetMScopeInfoRequest) xxx_FromOp(ctx context.Context, op *xxx_SetMScopeInfoOperation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.MScopeName = op.MScopeName
	o.MScopeInfo = op.MScopeInfo
	o.NewScope = op.NewScope
}
func (o *SetMScopeInfoRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetMScopeInfoRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetMScopeInfoOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetMScopeInfoResponse structure represents the R_DhcpSetMScopeInfo operation response
type SetMScopeInfoResponse struct {
	// Return: The R_DhcpSetMScopeInfo return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetMScopeInfoResponse) xxx_ToOp(ctx context.Context, op *xxx_SetMScopeInfoOperation) *xxx_SetMScopeInfoOperation {
	if op == nil {
		op = &xxx_SetMScopeInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetMScopeInfoResponse) xxx_FromOp(ctx context.Context, op *xxx_SetMScopeInfoOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetMScopeInfoResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetMScopeInfoResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetMScopeInfoOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetMScopeInfoOperation structure represents the R_DhcpGetMScopeInfo operation
type xxx_GetMScopeInfoOperation struct {
	ServerIPAddress string            `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	MScopeName      string            `idl:"name:MScopeName;string;pointer:ref" json:"mscope_name"`
	MScopeInfo      *dhcpm.MScopeInfo `idl:"name:MScopeInfo" json:"mscope_info"`
	Return          uint32            `idl:"name:Return" json:"return"`
}

func (o *xxx_GetMScopeInfoOperation) OpNum() int { return 2 }

func (o *xxx_GetMScopeInfoOperation) OpName() string { return "/dhcpsrv2/v1/R_DhcpGetMScopeInfo" }

func (o *xxx_GetMScopeInfoOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMScopeInfoOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// MScopeName {in} (1:{string, pointer=ref}*(2))(2:{string, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.MScopeName != "" {
			_ptr_MScopeName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.MScopeName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.MScopeName, _ptr_MScopeName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMScopeInfoOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// MScopeName {in} (1:{string, pointer=ref}*(2))(2:{string, alias=LPWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		_ptr_MScopeName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.MScopeName); err != nil {
				return err
			}
			return nil
		})
		_s_MScopeName := func(ptr interface{}) { o.MScopeName = *ptr.(*string) }
		if err := w.ReadPointer(&o.MScopeName, _s_MScopeName, _ptr_MScopeName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMScopeInfoOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMScopeInfoOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// MScopeInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_MSCOPE_INFO}*(1))(3:{alias=DHCP_MSCOPE_INFO}(struct))
	{
		if o.MScopeInfo != nil {
			_ptr_MScopeInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.MScopeInfo != nil {
					if err := o.MScopeInfo.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.MScopeInfo{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.MScopeInfo, _ptr_MScopeInfo); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMScopeInfoOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// MScopeInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_MSCOPE_INFO,pointer=ref}*(1))(3:{alias=DHCP_MSCOPE_INFO}(struct))
	{
		_ptr_MScopeInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.MScopeInfo == nil {
				o.MScopeInfo = &dhcpm.MScopeInfo{}
			}
			if err := o.MScopeInfo.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_MScopeInfo := func(ptr interface{}) { o.MScopeInfo = *ptr.(**dhcpm.MScopeInfo) }
		if err := w.ReadPointer(&o.MScopeInfo, _s_MScopeInfo, _ptr_MScopeInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetMScopeInfoRequest structure represents the R_DhcpGetMScopeInfo operation request
type GetMScopeInfoRequest struct {
	// ServerIpAddress: The IP address/host name of the MADCAP server. This parameter is
	// unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// MScopeName: This is a pointer to a Unicode string that contains the name of the IPv4
	// multicast subnet for which the information is retrieved. There is no restriction
	// on the length of this field.
	MScopeName string `idl:"name:MScopeName;string;pointer:ref" json:"mscope_name"`
}

func (o *GetMScopeInfoRequest) xxx_ToOp(ctx context.Context, op *xxx_GetMScopeInfoOperation) *xxx_GetMScopeInfoOperation {
	if op == nil {
		op = &xxx_GetMScopeInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.MScopeName = o.MScopeName
	return op
}

func (o *GetMScopeInfoRequest) xxx_FromOp(ctx context.Context, op *xxx_GetMScopeInfoOperation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.MScopeName = op.MScopeName
}
func (o *GetMScopeInfoRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetMScopeInfoRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetMScopeInfoOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetMScopeInfoResponse structure represents the R_DhcpGetMScopeInfo operation response
type GetMScopeInfoResponse struct {
	// MScopeInfo: This is a pointer of type LPDHCP_MSCOPE_INFO (section 2.2.1.2.71) in
	// which the information for the IPv4 multicast subnet corresponding to MScopeName is
	// retrieved.
	MScopeInfo *dhcpm.MScopeInfo `idl:"name:MScopeInfo" json:"mscope_info"`
	// Return: The R_DhcpGetMScopeInfo return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetMScopeInfoResponse) xxx_ToOp(ctx context.Context, op *xxx_GetMScopeInfoOperation) *xxx_GetMScopeInfoOperation {
	if op == nil {
		op = &xxx_GetMScopeInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.MScopeInfo = o.MScopeInfo
	op.Return = o.Return
	return op
}

func (o *GetMScopeInfoResponse) xxx_FromOp(ctx context.Context, op *xxx_GetMScopeInfoOperation) {
	if o == nil {
		return
	}
	o.MScopeInfo = op.MScopeInfo
	o.Return = op.Return
}
func (o *GetMScopeInfoResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetMScopeInfoResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetMScopeInfoOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumMScopesOperation structure represents the R_DhcpEnumMScopes operation
type xxx_EnumMScopesOperation struct {
	ServerIPAddress  string             `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Resume           uint32             `idl:"name:ResumeHandle" json:"resume"`
	PreferredMaximum uint32             `idl:"name:PreferredMaximum" json:"preferred_maximum"`
	MScopeTable      *dhcpm.MScopeTable `idl:"name:MScopeTable" json:"mscope_table"`
	ElementsRead     uint32             `idl:"name:ElementsRead" json:"elements_read"`
	ElementsTotal    uint32             `idl:"name:ElementsTotal" json:"elements_total"`
	Return           uint32             `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumMScopesOperation) OpNum() int { return 3 }

func (o *xxx_EnumMScopesOperation) OpName() string { return "/dhcpsrv2/v1/R_DhcpEnumMScopes" }

func (o *xxx_EnumMScopesOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumMScopesOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Resume); err != nil {
			return err
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PreferredMaximum); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumMScopesOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Resume); err != nil {
			return err
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PreferredMaximum); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumMScopesOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumMScopesOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Resume); err != nil {
			return err
		}
	}
	// MScopeTable {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_MSCOPE_TABLE}*(1))(3:{alias=DHCP_MSCOPE_TABLE}(struct))
	{
		if o.MScopeTable != nil {
			_ptr_MScopeTable := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.MScopeTable != nil {
					if err := o.MScopeTable.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.MScopeTable{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.MScopeTable, _ptr_MScopeTable); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ElementsRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ElementsRead); err != nil {
			return err
		}
	}
	// ElementsTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ElementsTotal); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumMScopesOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Resume); err != nil {
			return err
		}
	}
	// MScopeTable {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_MSCOPE_TABLE,pointer=ref}*(1))(3:{alias=DHCP_MSCOPE_TABLE}(struct))
	{
		_ptr_MScopeTable := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.MScopeTable == nil {
				o.MScopeTable = &dhcpm.MScopeTable{}
			}
			if err := o.MScopeTable.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_MScopeTable := func(ptr interface{}) { o.MScopeTable = *ptr.(**dhcpm.MScopeTable) }
		if err := w.ReadPointer(&o.MScopeTable, _s_MScopeTable, _ptr_MScopeTable); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ElementsRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ElementsRead); err != nil {
			return err
		}
	}
	// ElementsTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ElementsTotal); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumMScopesRequest structure represents the R_DhcpEnumMScopes operation request
type EnumMScopesRequest struct {
	// ServerIpAddress: The IP address/host name of the MADCAP server. This parameter is
	// unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// ResumeHandle: This is a pointer of type DHCP_RESUME_HANDLE (section 2.2.1.2.6) that
	// identifies the enumeration operation. Initially, this value MUST be set to zero,
	// with a successful call returning the handle value used for subsequent enumeration
	// requests. For example, if the PreferredMaximum parameter is set to 100, and 200 IPv4
	// multicast subnets are stored on the MADCAP server, the resume handle can be used
	// after the first 100 IPv4 multicast subnets are retrieved to obtain the next 100 on
	// a subsequent call, and so forth.
	Resume uint32 `idl:"name:ResumeHandle" json:"resume"`
	// PreferredMaximum: This is of type DWORD, specifying the preferred maximum number
	// of IPv4 multicast subnet addresses to return. If the number of remaining unenumerated
	// multicast subnets is less than this value, all the IPv4 multicast subnets configured
	// on MADCAP server are returned. To retrieve all the multicast scopes, 0xFFFFFFFF is
	// specified.
	PreferredMaximum uint32 `idl:"name:PreferredMaximum" json:"preferred_maximum"`
}

func (o *EnumMScopesRequest) xxx_ToOp(ctx context.Context, op *xxx_EnumMScopesOperation) *xxx_EnumMScopesOperation {
	if op == nil {
		op = &xxx_EnumMScopesOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Resume = o.Resume
	op.PreferredMaximum = o.PreferredMaximum
	return op
}

func (o *EnumMScopesRequest) xxx_FromOp(ctx context.Context, op *xxx_EnumMScopesOperation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Resume = op.Resume
	o.PreferredMaximum = op.PreferredMaximum
}
func (o *EnumMScopesRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumMScopesRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumMScopesOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumMScopesResponse structure represents the R_DhcpEnumMScopes operation response
type EnumMScopesResponse struct {
	// ResumeHandle: This is a pointer of type DHCP_RESUME_HANDLE (section 2.2.1.2.6) that
	// identifies the enumeration operation. Initially, this value MUST be set to zero,
	// with a successful call returning the handle value used for subsequent enumeration
	// requests. For example, if the PreferredMaximum parameter is set to 100, and 200 IPv4
	// multicast subnets are stored on the MADCAP server, the resume handle can be used
	// after the first 100 IPv4 multicast subnets are retrieved to obtain the next 100 on
	// a subsequent call, and so forth.
	Resume uint32 `idl:"name:ResumeHandle" json:"resume"`
	// MScopeTable: This is a pointer of type LPDHCP_MSCOPE_TABLE (section 2.2.1.2.72) that
	// points to the location in which the IPv4 multicast subnet names configured on the
	// MADCAP server are retrieved.
	MScopeTable *dhcpm.MScopeTable `idl:"name:MScopeTable" json:"mscope_table"`
	// ElementsRead: This is a pointer to a DWORD value that specifies the number of IPv4
	// multicast subnet names returned in MScopeTable. The caller MUST allocate memory for
	// this parameter equal to the size of data type DWORD.
	ElementsRead uint32 `idl:"name:ElementsRead" json:"elements_read"`
	// ElementsTotal: This is a pointer to a DWORD value that specifies the number of IPv4
	// multicast subnets defined on the MADCAP server from the ResumeHandle position. The
	// caller MUST allocate memory for this parameter equal to the size of data type DWORD.
	ElementsTotal uint32 `idl:"name:ElementsTotal" json:"elements_total"`
	// Return: The R_DhcpEnumMScopes return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumMScopesResponse) xxx_ToOp(ctx context.Context, op *xxx_EnumMScopesOperation) *xxx_EnumMScopesOperation {
	if op == nil {
		op = &xxx_EnumMScopesOperation{}
	}
	if o == nil {
		return op
	}
	op.Resume = o.Resume
	op.MScopeTable = o.MScopeTable
	op.ElementsRead = o.ElementsRead
	op.ElementsTotal = o.ElementsTotal
	op.Return = o.Return
	return op
}

func (o *EnumMScopesResponse) xxx_FromOp(ctx context.Context, op *xxx_EnumMScopesOperation) {
	if o == nil {
		return
	}
	o.Resume = op.Resume
	o.MScopeTable = op.MScopeTable
	o.ElementsRead = op.ElementsRead
	o.ElementsTotal = op.ElementsTotal
	o.Return = op.Return
}
func (o *EnumMScopesResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumMScopesResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumMScopesOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddMScopeElementOperation structure represents the R_DhcpAddMScopeElement operation
type xxx_AddMScopeElementOperation struct {
	ServerIPAddress string                     `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	MScopeName      string                     `idl:"name:MScopeName;string;pointer:ref" json:"mscope_name"`
	AddElementInfo  *dhcpm.SubnetElementDataV4 `idl:"name:AddElementInfo;pointer:ref" json:"add_element_info"`
	Return          uint32                     `idl:"name:Return" json:"return"`
}

func (o *xxx_AddMScopeElementOperation) OpNum() int { return 4 }

func (o *xxx_AddMScopeElementOperation) OpName() string { return "/dhcpsrv2/v1/R_DhcpAddMScopeElement" }

func (o *xxx_AddMScopeElementOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddMScopeElementOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// MScopeName {in} (1:{string, pointer=ref}*(2))(2:{string, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.MScopeName != "" {
			_ptr_MScopeName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.MScopeName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.MScopeName, _ptr_MScopeName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// AddElementInfo {in} (1:{pointer=ref, alias=LPDHCP_SUBNET_ELEMENT_DATA_V4}*(1))(2:{alias=DHCP_SUBNET_ELEMENT_DATA_V4}(struct))
	{
		if o.AddElementInfo != nil {
			if err := o.AddElementInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.SubnetElementDataV4{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddMScopeElementOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// MScopeName {in} (1:{string, pointer=ref}*(2))(2:{string, alias=LPWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		_ptr_MScopeName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.MScopeName); err != nil {
				return err
			}
			return nil
		})
		_s_MScopeName := func(ptr interface{}) { o.MScopeName = *ptr.(*string) }
		if err := w.ReadPointer(&o.MScopeName, _s_MScopeName, _ptr_MScopeName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// AddElementInfo {in} (1:{pointer=ref, alias=LPDHCP_SUBNET_ELEMENT_DATA_V4}*(1))(2:{alias=DHCP_SUBNET_ELEMENT_DATA_V4}(struct))
	{
		if o.AddElementInfo == nil {
			o.AddElementInfo = &dhcpm.SubnetElementDataV4{}
		}
		if err := o.AddElementInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddMScopeElementOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddMScopeElementOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddMScopeElementOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddMScopeElementRequest structure represents the R_DhcpAddMScopeElement operation request
type AddMScopeElementRequest struct {
	// ServerIpAddress: The IP address/host name of the MADCAP server. This parameter is
	// unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// MScopeName: This is a pointer to a Unicode string that contains the name of the IPv4
	// multicast subnet in which the element is added. There is no restriction on the length
	// of this parameter.
	MScopeName string `idl:"name:MScopeName;string;pointer:ref" json:"mscope_name"`
	// AddElementInfo: This is a pointer to a DHCP_SUBNET_ELEMENT_DATA_V4 (section 2.2.1.2.35)
	// structure that contains the IPv4 multicast subnet element that needs to be added
	// to the IPv4 multicast subnet.
	AddElementInfo *dhcpm.SubnetElementDataV4 `idl:"name:AddElementInfo;pointer:ref" json:"add_element_info"`
}

func (o *AddMScopeElementRequest) xxx_ToOp(ctx context.Context, op *xxx_AddMScopeElementOperation) *xxx_AddMScopeElementOperation {
	if op == nil {
		op = &xxx_AddMScopeElementOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.MScopeName = o.MScopeName
	op.AddElementInfo = o.AddElementInfo
	return op
}

func (o *AddMScopeElementRequest) xxx_FromOp(ctx context.Context, op *xxx_AddMScopeElementOperation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.MScopeName = op.MScopeName
	o.AddElementInfo = op.AddElementInfo
}
func (o *AddMScopeElementRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *AddMScopeElementRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddMScopeElementOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddMScopeElementResponse structure represents the R_DhcpAddMScopeElement operation response
type AddMScopeElementResponse struct {
	// Return: The R_DhcpAddMScopeElement return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddMScopeElementResponse) xxx_ToOp(ctx context.Context, op *xxx_AddMScopeElementOperation) *xxx_AddMScopeElementOperation {
	if op == nil {
		op = &xxx_AddMScopeElementOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *AddMScopeElementResponse) xxx_FromOp(ctx context.Context, op *xxx_AddMScopeElementOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *AddMScopeElementResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *AddMScopeElementResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddMScopeElementOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumMScopeElementsOperation structure represents the R_DhcpEnumMScopeElements operation
type xxx_EnumMScopeElementsOperation struct {
	ServerIPAddress  string                          `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	MScopeName       string                          `idl:"name:MScopeName;string;pointer:ref" json:"mscope_name"`
	EnumElementType  dhcpm.SubnetElementType         `idl:"name:EnumElementType" json:"enum_element_type"`
	Resume           uint32                          `idl:"name:ResumeHandle" json:"resume"`
	PreferredMaximum uint32                          `idl:"name:PreferredMaximum" json:"preferred_maximum"`
	EnumElementInfo  *dhcpm.SubnetElementInfoArrayV4 `idl:"name:EnumElementInfo" json:"enum_element_info"`
	ElementsRead     uint32                          `idl:"name:ElementsRead" json:"elements_read"`
	ElementsTotal    uint32                          `idl:"name:ElementsTotal" json:"elements_total"`
	Return           uint32                          `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumMScopeElementsOperation) OpNum() int { return 5 }

func (o *xxx_EnumMScopeElementsOperation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpEnumMScopeElements"
}

func (o *xxx_EnumMScopeElementsOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumMScopeElementsOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// MScopeName {in} (1:{string, pointer=ref}*(2))(2:{string, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.MScopeName != "" {
			_ptr_MScopeName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.MScopeName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.MScopeName, _ptr_MScopeName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// EnumElementType {in} (1:{alias=DHCP_SUBNET_ELEMENT_TYPE}(enum))
	{
		if err := w.WriteEnum(uint16(o.EnumElementType)); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Resume); err != nil {
			return err
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PreferredMaximum); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumMScopeElementsOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// MScopeName {in} (1:{string, pointer=ref}*(2))(2:{string, alias=LPWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		_ptr_MScopeName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.MScopeName); err != nil {
				return err
			}
			return nil
		})
		_s_MScopeName := func(ptr interface{}) { o.MScopeName = *ptr.(*string) }
		if err := w.ReadPointer(&o.MScopeName, _s_MScopeName, _ptr_MScopeName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// EnumElementType {in} (1:{alias=DHCP_SUBNET_ELEMENT_TYPE}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.EnumElementType)); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Resume); err != nil {
			return err
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PreferredMaximum); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumMScopeElementsOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumMScopeElementsOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Resume); err != nil {
			return err
		}
	}
	// EnumElementInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4}*(1))(3:{alias=DHCP_SUBNET_ELEMENT_INFO_ARRAY_V4}(struct))
	{
		if o.EnumElementInfo != nil {
			_ptr_EnumElementInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.EnumElementInfo != nil {
					if err := o.EnumElementInfo.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.SubnetElementInfoArrayV4{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.EnumElementInfo, _ptr_EnumElementInfo); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ElementsRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ElementsRead); err != nil {
			return err
		}
	}
	// ElementsTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ElementsTotal); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumMScopeElementsOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Resume); err != nil {
			return err
		}
	}
	// EnumElementInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4,pointer=ref}*(1))(3:{alias=DHCP_SUBNET_ELEMENT_INFO_ARRAY_V4}(struct))
	{
		_ptr_EnumElementInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.EnumElementInfo == nil {
				o.EnumElementInfo = &dhcpm.SubnetElementInfoArrayV4{}
			}
			if err := o.EnumElementInfo.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_EnumElementInfo := func(ptr interface{}) { o.EnumElementInfo = *ptr.(**dhcpm.SubnetElementInfoArrayV4) }
		if err := w.ReadPointer(&o.EnumElementInfo, _s_EnumElementInfo, _ptr_EnumElementInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ElementsRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ElementsRead); err != nil {
			return err
		}
	}
	// ElementsTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ElementsTotal); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumMScopeElementsRequest structure represents the R_DhcpEnumMScopeElements operation request
type EnumMScopeElementsRequest struct {
	// ServerIpAddress: The IP address/host name of the MADCAP server. This parameter is
	// unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// MScopeName: This is a pointer to a Unicode string that contains the name of the multicast
	// subnet from which IPv4 multicast subnet elements are enumerated. There is no restriction
	// on the length of this field.
	MScopeName string `idl:"name:MScopeName;string;pointer:ref" json:"mscope_name"`
	// EnumElementType: This is of type DHCP_SUBNET_ELEMENT_TYPE (section 2.2.1.1.7), indicating
	// the type of IPv4 multicast subnet element to enumerate.
	EnumElementType dhcpm.SubnetElementType `idl:"name:EnumElementType" json:"enum_element_type"`
	// ResumeHandle: This is a pointer of type DHCP_RESUME_HANDLE (section 2.2.1.2.6) that
	// identifies the enumeration operation. Initially, this value MUST be set to zero,
	// with a successful call returning the handle value used for subsequent enumeration
	// requests. For example, if the PreferredMaximum parameter is set to 1,000 bytes, and
	// 2,000 bytes' worth of IPv4 multicast subnet elements are stored on the MADCAP server,
	// the resume handle can be used after the first 1,000 bytes are retrieved to obtain
	// the next 1,000 on a subsequent call, and so forth.
	Resume uint32 `idl:"name:ResumeHandle" json:"resume"`
	// PreferredMaximum: This is of type DWORD, specifying the preferred maximum number
	// of bytes to return. If the number of remaining unenumerated IPv4 multicast subnet
	// element (in bytes) is less than this value, all IPv4 subnet elements for a specific
	// type are returned. To retrieve all the IPv4 subnet elements of a specific type, 0xFFFFFFFF
	// is specified.
	PreferredMaximum uint32 `idl:"name:PreferredMaximum" json:"preferred_maximum"`
}

func (o *EnumMScopeElementsRequest) xxx_ToOp(ctx context.Context, op *xxx_EnumMScopeElementsOperation) *xxx_EnumMScopeElementsOperation {
	if op == nil {
		op = &xxx_EnumMScopeElementsOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.MScopeName = o.MScopeName
	op.EnumElementType = o.EnumElementType
	op.Resume = o.Resume
	op.PreferredMaximum = o.PreferredMaximum
	return op
}

func (o *EnumMScopeElementsRequest) xxx_FromOp(ctx context.Context, op *xxx_EnumMScopeElementsOperation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.MScopeName = op.MScopeName
	o.EnumElementType = op.EnumElementType
	o.Resume = op.Resume
	o.PreferredMaximum = op.PreferredMaximum
}
func (o *EnumMScopeElementsRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumMScopeElementsRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumMScopeElementsOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumMScopeElementsResponse structure represents the R_DhcpEnumMScopeElements operation response
type EnumMScopeElementsResponse struct {
	// ResumeHandle: This is a pointer of type DHCP_RESUME_HANDLE (section 2.2.1.2.6) that
	// identifies the enumeration operation. Initially, this value MUST be set to zero,
	// with a successful call returning the handle value used for subsequent enumeration
	// requests. For example, if the PreferredMaximum parameter is set to 1,000 bytes, and
	// 2,000 bytes' worth of IPv4 multicast subnet elements are stored on the MADCAP server,
	// the resume handle can be used after the first 1,000 bytes are retrieved to obtain
	// the next 1,000 on a subsequent call, and so forth.
	Resume uint32 `idl:"name:ResumeHandle" json:"resume"`
	// EnumElementInfo: This is a pointer of type LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 in
	// which the IPv4 multicast subnet element of type EnumElementType is returned for a
	// specific IPv4 multicast subnet corresponding to MScopeNames. If no IPv4 multicast
	// subnet element of that specific type is available for enumeration, this value is
	// null.
	EnumElementInfo *dhcpm.SubnetElementInfoArrayV4 `idl:"name:EnumElementInfo" json:"enum_element_info"`
	// ElementsRead: This is a pointer to a DWORD value that specifies the number of IPv4
	// multicast subnet elements read in EnumElementInfo for a specific type of IPv4 multicast
	// subnet element. The caller MUST allocate memory for this parameter equal to the size
	// of a DWORD data type.
	ElementsRead uint32 `idl:"name:ElementsRead" json:"elements_read"`
	// ElementsTotal: This is a pointer to a DWORD value that specifies the number of IPv4
	// multicast subnet elements of a specific type from a specific IPv4 multicast subnet
	// and that is not yet enumerated with respect to the resume handle that is returned.
	// The caller MUST allocate memory for this parameter equal to the size of a DWORD data
	// type.
	ElementsTotal uint32 `idl:"name:ElementsTotal" json:"elements_total"`
	// Return: The R_DhcpEnumMScopeElements return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumMScopeElementsResponse) xxx_ToOp(ctx context.Context, op *xxx_EnumMScopeElementsOperation) *xxx_EnumMScopeElementsOperation {
	if op == nil {
		op = &xxx_EnumMScopeElementsOperation{}
	}
	if o == nil {
		return op
	}
	op.Resume = o.Resume
	op.EnumElementInfo = o.EnumElementInfo
	op.ElementsRead = o.ElementsRead
	op.ElementsTotal = o.ElementsTotal
	op.Return = o.Return
	return op
}

func (o *EnumMScopeElementsResponse) xxx_FromOp(ctx context.Context, op *xxx_EnumMScopeElementsOperation) {
	if o == nil {
		return
	}
	o.Resume = op.Resume
	o.EnumElementInfo = op.EnumElementInfo
	o.ElementsRead = op.ElementsRead
	o.ElementsTotal = op.ElementsTotal
	o.Return = op.Return
}
func (o *EnumMScopeElementsResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumMScopeElementsResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumMScopeElementsOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_RemoveMScopeElementOperation structure represents the R_DhcpRemoveMScopeElement operation
type xxx_RemoveMScopeElementOperation struct {
	ServerIPAddress   string                     `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	MScopeName        string                     `idl:"name:MScopeName;string;pointer:ref" json:"mscope_name"`
	RemoveElementInfo *dhcpm.SubnetElementDataV4 `idl:"name:RemoveElementInfo;pointer:ref" json:"remove_element_info"`
	ForceFlag         dhcpm.ForceFlag            `idl:"name:ForceFlag" json:"force_flag"`
	Return            uint32                     `idl:"name:Return" json:"return"`
}

func (o *xxx_RemoveMScopeElementOperation) OpNum() int { return 6 }

func (o *xxx_RemoveMScopeElementOperation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpRemoveMScopeElement"
}

func (o *xxx_RemoveMScopeElementOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveMScopeElementOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// MScopeName {in} (1:{string, pointer=ref}*(2))(2:{string, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.MScopeName != "" {
			_ptr_MScopeName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.MScopeName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.MScopeName, _ptr_MScopeName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// RemoveElementInfo {in} (1:{pointer=ref, alias=LPDHCP_SUBNET_ELEMENT_DATA_V4}*(1))(2:{alias=DHCP_SUBNET_ELEMENT_DATA_V4}(struct))
	{
		if o.RemoveElementInfo != nil {
			if err := o.RemoveElementInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.SubnetElementDataV4{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ForceFlag {in} (1:{alias=DHCP_FORCE_FLAG}(enum))
	{
		if err := w.WriteEnum(uint16(o.ForceFlag)); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveMScopeElementOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// MScopeName {in} (1:{string, pointer=ref}*(2))(2:{string, alias=LPWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		_ptr_MScopeName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.MScopeName); err != nil {
				return err
			}
			return nil
		})
		_s_MScopeName := func(ptr interface{}) { o.MScopeName = *ptr.(*string) }
		if err := w.ReadPointer(&o.MScopeName, _s_MScopeName, _ptr_MScopeName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// RemoveElementInfo {in} (1:{pointer=ref, alias=LPDHCP_SUBNET_ELEMENT_DATA_V4}*(1))(2:{alias=DHCP_SUBNET_ELEMENT_DATA_V4}(struct))
	{
		if o.RemoveElementInfo == nil {
			o.RemoveElementInfo = &dhcpm.SubnetElementDataV4{}
		}
		if err := o.RemoveElementInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ForceFlag {in} (1:{alias=DHCP_FORCE_FLAG}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.ForceFlag)); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveMScopeElementOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveMScopeElementOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveMScopeElementOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// RemoveMScopeElementRequest structure represents the R_DhcpRemoveMScopeElement operation request
type RemoveMScopeElementRequest struct {
	// ServerIpAddress: The IP address/host name of the MADCAP server. This parameter is
	// unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// MScopeName: This is a pointer to a Unicode string that contains the name of the multicast
	// subnet from which the IPv4 multicast subnet element is removed. There is no restriction
	// on the length of this field.
	MScopeName string `idl:"name:MScopeName;string;pointer:ref" json:"mscope_name"`
	// RemoveElementInfo: This is of type DHCP_SUBNET_ELEMENT_DATA_V4 (section 2.2.1.2.35),
	// containing the IPv4 multicast subnet element that needs to be removed from the IPv4
	// multicast subnet.
	RemoveElementInfo *dhcpm.SubnetElementDataV4 `idl:"name:RemoveElementInfo;pointer:ref" json:"remove_element_info"`
	// ForceFlag: This is of type DHCP_FORCE_FLAG (section 2.2.1.1.9) that defines the behavior
	// of this method. If the flag is set to DhcpNoForce and this IPv4 multicast subnet
	// has served the IPv4 address to some MADCAP clients, the IPv4 multicast subnet is
	// not deleted. If the flag is set to DhcpFullForce, the IPv4 multicast subnet is deleted
	// along with the MADCAP client lease record on the MADCAP server.
	ForceFlag dhcpm.ForceFlag `idl:"name:ForceFlag" json:"force_flag"`
}

func (o *RemoveMScopeElementRequest) xxx_ToOp(ctx context.Context, op *xxx_RemoveMScopeElementOperation) *xxx_RemoveMScopeElementOperation {
	if op == nil {
		op = &xxx_RemoveMScopeElementOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.MScopeName = o.MScopeName
	op.RemoveElementInfo = o.RemoveElementInfo
	op.ForceFlag = o.ForceFlag
	return op
}

func (o *RemoveMScopeElementRequest) xxx_FromOp(ctx context.Context, op *xxx_RemoveMScopeElementOperation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.MScopeName = op.MScopeName
	o.RemoveElementInfo = op.RemoveElementInfo
	o.ForceFlag = op.ForceFlag
}
func (o *RemoveMScopeElementRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *RemoveMScopeElementRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemoveMScopeElementOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// RemoveMScopeElementResponse structure represents the R_DhcpRemoveMScopeElement operation response
type RemoveMScopeElementResponse struct {
	// Return: The R_DhcpRemoveMScopeElement return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *RemoveMScopeElementResponse) xxx_ToOp(ctx context.Context, op *xxx_RemoveMScopeElementOperation) *xxx_RemoveMScopeElementOperation {
	if op == nil {
		op = &xxx_RemoveMScopeElementOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *RemoveMScopeElementResponse) xxx_FromOp(ctx context.Context, op *xxx_RemoveMScopeElementOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *RemoveMScopeElementResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *RemoveMScopeElementResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemoveMScopeElementOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_DeleteMScopeOperation structure represents the R_DhcpDeleteMScope operation
type xxx_DeleteMScopeOperation struct {
	ServerIPAddress string          `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	MScopeName      string          `idl:"name:MScopeName;string;pointer:ref" json:"mscope_name"`
	ForceFlag       dhcpm.ForceFlag `idl:"name:ForceFlag" json:"force_flag"`
	Return          uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_DeleteMScopeOperation) OpNum() int { return 7 }

func (o *xxx_DeleteMScopeOperation) OpName() string { return "/dhcpsrv2/v1/R_DhcpDeleteMScope" }

func (o *xxx_DeleteMScopeOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteMScopeOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// MScopeName {in} (1:{string, pointer=ref}*(2))(2:{string, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.MScopeName != "" {
			_ptr_MScopeName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.MScopeName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.MScopeName, _ptr_MScopeName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ForceFlag {in} (1:{alias=DHCP_FORCE_FLAG}(enum))
	{
		if err := w.WriteEnum(uint16(o.ForceFlag)); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteMScopeOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// MScopeName {in} (1:{string, pointer=ref}*(2))(2:{string, alias=LPWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		_ptr_MScopeName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.MScopeName); err != nil {
				return err
			}
			return nil
		})
		_s_MScopeName := func(ptr interface{}) { o.MScopeName = *ptr.(*string) }
		if err := w.ReadPointer(&o.MScopeName, _s_MScopeName, _ptr_MScopeName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ForceFlag {in} (1:{alias=DHCP_FORCE_FLAG}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.ForceFlag)); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteMScopeOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteMScopeOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteMScopeOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// DeleteMScopeRequest structure represents the R_DhcpDeleteMScope operation request
type DeleteMScopeRequest struct {
	// ServerIpAddress: The IP address/host name of the MADCAP server. This parameter is
	// unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// MScopeName: This is a pointer to a Unicode string that contains the name of the multicast
	// subnet that needs to be removed. There is no restriction on the length of this field.
	MScopeName string `idl:"name:MScopeName;string;pointer:ref" json:"mscope_name"`
	// ForceFlag: This is of type DHCP_FORCE_FLAG (section 2.2.1.1.9) that defines the behavior
	// of this method. If the flag is set to DhcpNoForce and this subnet has served the
	// IPv4 address to some MADCAP clients, the IPv4 multicast subnet is not deleted. If
	// the flag is set to DhcpFullForce, the IPv4 multicast subnet is deleted along with
	// the MADCAP client's record on the MADCAP server.
	ForceFlag dhcpm.ForceFlag `idl:"name:ForceFlag" json:"force_flag"`
}

func (o *DeleteMScopeRequest) xxx_ToOp(ctx context.Context, op *xxx_DeleteMScopeOperation) *xxx_DeleteMScopeOperation {
	if op == nil {
		op = &xxx_DeleteMScopeOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.MScopeName = o.MScopeName
	op.ForceFlag = o.ForceFlag
	return op
}

func (o *DeleteMScopeRequest) xxx_FromOp(ctx context.Context, op *xxx_DeleteMScopeOperation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.MScopeName = op.MScopeName
	o.ForceFlag = op.ForceFlag
}
func (o *DeleteMScopeRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *DeleteMScopeRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteMScopeOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// DeleteMScopeResponse structure represents the R_DhcpDeleteMScope operation response
type DeleteMScopeResponse struct {
	// Return: The R_DhcpDeleteMScope return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *DeleteMScopeResponse) xxx_ToOp(ctx context.Context, op *xxx_DeleteMScopeOperation) *xxx_DeleteMScopeOperation {
	if op == nil {
		op = &xxx_DeleteMScopeOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *DeleteMScopeResponse) xxx_FromOp(ctx context.Context, op *xxx_DeleteMScopeOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *DeleteMScopeResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *DeleteMScopeResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteMScopeOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ScanMDatabaseOperation structure represents the R_DhcpScanMDatabase operation
type xxx_ScanMDatabaseOperation struct {
	ServerIPAddress string          `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	MScopeName      string          `idl:"name:MScopeName;string;pointer:ref" json:"mscope_name"`
	FixFlag         uint32          `idl:"name:FixFlag" json:"fix_flag"`
	ScanList        *dhcpm.ScanList `idl:"name:ScanList" json:"scan_list"`
	Return          uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_ScanMDatabaseOperation) OpNum() int { return 8 }

func (o *xxx_ScanMDatabaseOperation) OpName() string { return "/dhcpsrv2/v1/R_DhcpScanMDatabase" }

func (o *xxx_ScanMDatabaseOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ScanMDatabaseOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// MScopeName {in} (1:{string, pointer=ref}*(2))(2:{string, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.MScopeName != "" {
			_ptr_MScopeName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.MScopeName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.MScopeName, _ptr_MScopeName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// FixFlag {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.FixFlag); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ScanMDatabaseOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// MScopeName {in} (1:{string, pointer=ref}*(2))(2:{string, alias=LPWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		_ptr_MScopeName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.MScopeName); err != nil {
				return err
			}
			return nil
		})
		_s_MScopeName := func(ptr interface{}) { o.MScopeName = *ptr.(*string) }
		if err := w.ReadPointer(&o.MScopeName, _s_MScopeName, _ptr_MScopeName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// FixFlag {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.FixFlag); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ScanMDatabaseOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ScanMDatabaseOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ScanList {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_SCAN_LIST}*(1))(3:{alias=DHCP_SCAN_LIST}(struct))
	{
		if o.ScanList != nil {
			_ptr_ScanList := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.ScanList != nil {
					if err := o.ScanList.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.ScanList{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ScanList, _ptr_ScanList); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ScanMDatabaseOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ScanList {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_SCAN_LIST,pointer=ref}*(1))(3:{alias=DHCP_SCAN_LIST}(struct))
	{
		_ptr_ScanList := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.ScanList == nil {
				o.ScanList = &dhcpm.ScanList{}
			}
			if err := o.ScanList.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ScanList := func(ptr interface{}) { o.ScanList = *ptr.(**dhcpm.ScanList) }
		if err := w.ReadPointer(&o.ScanList, _s_ScanList, _ptr_ScanList); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ScanMDatabaseRequest structure represents the R_DhcpScanMDatabase operation request
type ScanMDatabaseRequest struct {
	// ServerIpAddress: The IP address/host name of the MADCAP server. This parameter is
	// unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// MScopeName: This is a pointer to a Unicode string that contains the name of the multicast
	// subnet in which a scan is done for the MADCAP client IPv4 addresses that are not
	// in sync.
	MScopeName string `idl:"name:MScopeName;string;pointer:ref" json:"mscope_name"`
	// FixFlag: This is of type DWORD, defining the behavior of this method. This method
	// enumerates the MADCAP client IPv4 addresses that are not in sync in both the stores,
	// and if the FixFlag parameter is set to TRUE, it fixes those unmatched IPv4 addresses
	// also.
	FixFlag uint32 `idl:"name:FixFlag" json:"fix_flag"`
}

func (o *ScanMDatabaseRequest) xxx_ToOp(ctx context.Context, op *xxx_ScanMDatabaseOperation) *xxx_ScanMDatabaseOperation {
	if op == nil {
		op = &xxx_ScanMDatabaseOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.MScopeName = o.MScopeName
	op.FixFlag = o.FixFlag
	return op
}

func (o *ScanMDatabaseRequest) xxx_FromOp(ctx context.Context, op *xxx_ScanMDatabaseOperation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.MScopeName = op.MScopeName
	o.FixFlag = op.FixFlag
}
func (o *ScanMDatabaseRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *ScanMDatabaseRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ScanMDatabaseOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ScanMDatabaseResponse structure represents the R_DhcpScanMDatabase operation response
type ScanMDatabaseResponse struct {
	// ScanList: This is a pointer of type DHCP_SCAN_LIST (section 2.2.1.2.74) that points
	// to the location that contains the MADCAP client IPv4 addresses that are not in sync
	// in both the stores.
	ScanList *dhcpm.ScanList `idl:"name:ScanList" json:"scan_list"`
	// Return: The R_DhcpScanMDatabase return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ScanMDatabaseResponse) xxx_ToOp(ctx context.Context, op *xxx_ScanMDatabaseOperation) *xxx_ScanMDatabaseOperation {
	if op == nil {
		op = &xxx_ScanMDatabaseOperation{}
	}
	if o == nil {
		return op
	}
	op.ScanList = o.ScanList
	op.Return = o.Return
	return op
}

func (o *ScanMDatabaseResponse) xxx_FromOp(ctx context.Context, op *xxx_ScanMDatabaseOperation) {
	if o == nil {
		return
	}
	o.ScanList = op.ScanList
	o.Return = op.Return
}
func (o *ScanMDatabaseResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *ScanMDatabaseResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ScanMDatabaseOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CreateMClientInfoOperation structure represents the R_DhcpCreateMClientInfo operation
type xxx_CreateMClientInfoOperation struct {
	ServerIPAddress string                  `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	MScopeName      string                  `idl:"name:MScopeName;string;pointer:ref" json:"mscope_name"`
	ClientInfo      *dhcpm.MADCAPClientInfo `idl:"name:ClientInfo;pointer:ref" json:"client_info"`
	Return          uint32                  `idl:"name:Return" json:"return"`
}

func (o *xxx_CreateMClientInfoOperation) OpNum() int { return 9 }

func (o *xxx_CreateMClientInfoOperation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpCreateMClientInfo"
}

func (o *xxx_CreateMClientInfoOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateMClientInfoOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// MScopeName {in} (1:{string, pointer=ref}*(2))(2:{string, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.MScopeName != "" {
			_ptr_MScopeName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.MScopeName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.MScopeName, _ptr_MScopeName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ClientInfo {in} (1:{pointer=ref, alias=LPDHCP_MCLIENT_INFO}*(1))(2:{alias=DHCP_MCLIENT_INFO}(struct))
	{
		if o.ClientInfo != nil {
			if err := o.ClientInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.MADCAPClientInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateMClientInfoOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// MScopeName {in} (1:{string, pointer=ref}*(2))(2:{string, alias=LPWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		_ptr_MScopeName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.MScopeName); err != nil {
				return err
			}
			return nil
		})
		_s_MScopeName := func(ptr interface{}) { o.MScopeName = *ptr.(*string) }
		if err := w.ReadPointer(&o.MScopeName, _s_MScopeName, _ptr_MScopeName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ClientInfo {in} (1:{pointer=ref, alias=LPDHCP_MCLIENT_INFO}*(1))(2:{alias=DHCP_MCLIENT_INFO}(struct))
	{
		if o.ClientInfo == nil {
			o.ClientInfo = &dhcpm.MADCAPClientInfo{}
		}
		if err := o.ClientInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateMClientInfoOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateMClientInfoOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateMClientInfoOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CreateMClientInfoRequest structure represents the R_DhcpCreateMClientInfo operation request
type CreateMClientInfoRequest struct {
	// ServerIpAddress: The IP address/host name of the MADCAP server. This parameter is
	// unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// MScopeName: This is a pointer to a Unicode string that contains the name of the multicast
	// subnet MADCAP client that needs to be created.
	MScopeName string `idl:"name:MScopeName;string;pointer:ref" json:"mscope_name"`
	// ClientInfo: This is a pointer of type LPDHCP_MCLIENT_INFO (section 2.2.1.2.21), containing
	// the complete information of the MADCAP client.
	ClientInfo *dhcpm.MADCAPClientInfo `idl:"name:ClientInfo;pointer:ref" json:"client_info"`
}

func (o *CreateMClientInfoRequest) xxx_ToOp(ctx context.Context, op *xxx_CreateMClientInfoOperation) *xxx_CreateMClientInfoOperation {
	if op == nil {
		op = &xxx_CreateMClientInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.MScopeName = o.MScopeName
	op.ClientInfo = o.ClientInfo
	return op
}

func (o *CreateMClientInfoRequest) xxx_FromOp(ctx context.Context, op *xxx_CreateMClientInfoOperation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.MScopeName = op.MScopeName
	o.ClientInfo = op.ClientInfo
}
func (o *CreateMClientInfoRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *CreateMClientInfoRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateMClientInfoOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CreateMClientInfoResponse structure represents the R_DhcpCreateMClientInfo operation response
type CreateMClientInfoResponse struct {
	// Return: The R_DhcpCreateMClientInfo return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CreateMClientInfoResponse) xxx_ToOp(ctx context.Context, op *xxx_CreateMClientInfoOperation) *xxx_CreateMClientInfoOperation {
	if op == nil {
		op = &xxx_CreateMClientInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *CreateMClientInfoResponse) xxx_FromOp(ctx context.Context, op *xxx_CreateMClientInfoOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *CreateMClientInfoResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *CreateMClientInfoResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateMClientInfoOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetMClientInfoOperation structure represents the R_DhcpSetMClientInfo operation
type xxx_SetMClientInfoOperation struct {
	ServerIPAddress string                  `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	ClientInfo      *dhcpm.MADCAPClientInfo `idl:"name:ClientInfo;pointer:ref" json:"client_info"`
	Return          uint32                  `idl:"name:Return" json:"return"`
}

func (o *xxx_SetMClientInfoOperation) OpNum() int { return 10 }

func (o *xxx_SetMClientInfoOperation) OpName() string { return "/dhcpsrv2/v1/R_DhcpSetMClientInfo" }

func (o *xxx_SetMClientInfoOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetMClientInfoOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ClientInfo {in} (1:{pointer=ref, alias=LPDHCP_MCLIENT_INFO}*(1))(2:{alias=DHCP_MCLIENT_INFO}(struct))
	{
		if o.ClientInfo != nil {
			if err := o.ClientInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.MADCAPClientInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetMClientInfoOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ClientInfo {in} (1:{pointer=ref, alias=LPDHCP_MCLIENT_INFO}*(1))(2:{alias=DHCP_MCLIENT_INFO}(struct))
	{
		if o.ClientInfo == nil {
			o.ClientInfo = &dhcpm.MADCAPClientInfo{}
		}
		if err := o.ClientInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetMClientInfoOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetMClientInfoOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetMClientInfoOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetMClientInfoRequest structure represents the R_DhcpSetMClientInfo operation request
type SetMClientInfoRequest struct {
	// ServerIpAddress: The IP address/host name of the MADCAP server. This parameter is
	// unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// ClientInfo: This is a pointer of type LPDHCP_MCLIENT_INFO (section 2.2.1.2.21), containing
	// the information of the MADCAP client.
	ClientInfo *dhcpm.MADCAPClientInfo `idl:"name:ClientInfo;pointer:ref" json:"client_info"`
}

func (o *SetMClientInfoRequest) xxx_ToOp(ctx context.Context, op *xxx_SetMClientInfoOperation) *xxx_SetMClientInfoOperation {
	if op == nil {
		op = &xxx_SetMClientInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.ClientInfo = o.ClientInfo
	return op
}

func (o *SetMClientInfoRequest) xxx_FromOp(ctx context.Context, op *xxx_SetMClientInfoOperation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.ClientInfo = op.ClientInfo
}
func (o *SetMClientInfoRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetMClientInfoRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetMClientInfoOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetMClientInfoResponse structure represents the R_DhcpSetMClientInfo operation response
type SetMClientInfoResponse struct {
	// Return: The R_DhcpSetMClientInfo return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetMClientInfoResponse) xxx_ToOp(ctx context.Context, op *xxx_SetMClientInfoOperation) *xxx_SetMClientInfoOperation {
	if op == nil {
		op = &xxx_SetMClientInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetMClientInfoResponse) xxx_FromOp(ctx context.Context, op *xxx_SetMClientInfoOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetMClientInfoResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetMClientInfoResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetMClientInfoOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetMClientInfoOperation structure represents the R_DhcpGetMClientInfo operation
type xxx_GetMClientInfoOperation struct {
	ServerIPAddress string                  `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	SearchInfo      *dhcpm.SearchInfo       `idl:"name:SearchInfo;pointer:ref" json:"search_info"`
	ClientInfo      *dhcpm.MADCAPClientInfo `idl:"name:ClientInfo" json:"client_info"`
	Return          uint32                  `idl:"name:Return" json:"return"`
}

func (o *xxx_GetMClientInfoOperation) OpNum() int { return 11 }

func (o *xxx_GetMClientInfoOperation) OpName() string { return "/dhcpsrv2/v1/R_DhcpGetMClientInfo" }

func (o *xxx_GetMClientInfoOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMClientInfoOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// SearchInfo {in} (1:{pointer=ref, alias=LPDHCP_SEARCH_INFO}*(1))(2:{alias=DHCP_SEARCH_INFO}(struct))
	{
		if o.SearchInfo != nil {
			if err := o.SearchInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.SearchInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMClientInfoOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// SearchInfo {in} (1:{pointer=ref, alias=LPDHCP_SEARCH_INFO}*(1))(2:{alias=DHCP_SEARCH_INFO}(struct))
	{
		if o.SearchInfo == nil {
			o.SearchInfo = &dhcpm.SearchInfo{}
		}
		if err := o.SearchInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMClientInfoOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMClientInfoOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ClientInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_MCLIENT_INFO}*(1))(3:{alias=DHCP_MCLIENT_INFO}(struct))
	{
		if o.ClientInfo != nil {
			_ptr_ClientInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.ClientInfo != nil {
					if err := o.ClientInfo.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.MADCAPClientInfo{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ClientInfo, _ptr_ClientInfo); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMClientInfoOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ClientInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_MCLIENT_INFO,pointer=ref}*(1))(3:{alias=DHCP_MCLIENT_INFO}(struct))
	{
		_ptr_ClientInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.ClientInfo == nil {
				o.ClientInfo = &dhcpm.MADCAPClientInfo{}
			}
			if err := o.ClientInfo.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ClientInfo := func(ptr interface{}) { o.ClientInfo = *ptr.(**dhcpm.MADCAPClientInfo) }
		if err := w.ReadPointer(&o.ClientInfo, _s_ClientInfo, _ptr_ClientInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetMClientInfoRequest structure represents the R_DhcpGetMClientInfo operation request
type GetMClientInfoRequest struct {
	// ServerIpAddress: The IP address/host name of the MADCAP server. This parameter is
	// unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// SearchInfo: This is a pointer of type DHCP_SEARCH_INFO (section 2.2.1.2.18) that
	// defines the key to be used to search the MADCAP client lease record on the MADCAP
	// server.
	SearchInfo *dhcpm.SearchInfo `idl:"name:SearchInfo;pointer:ref" json:"search_info"`
}

func (o *GetMClientInfoRequest) xxx_ToOp(ctx context.Context, op *xxx_GetMClientInfoOperation) *xxx_GetMClientInfoOperation {
	if op == nil {
		op = &xxx_GetMClientInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.SearchInfo = o.SearchInfo
	return op
}

func (o *GetMClientInfoRequest) xxx_FromOp(ctx context.Context, op *xxx_GetMClientInfoOperation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.SearchInfo = op.SearchInfo
}
func (o *GetMClientInfoRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetMClientInfoRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetMClientInfoOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetMClientInfoResponse structure represents the R_DhcpGetMClientInfo operation response
type GetMClientInfoResponse struct {
	// ClientInfo: This is a pointer of type LPDHCP_MCLIENT_INFO that points to the location
	// in which specific MADCAP client lease record information is retrieved. The caller
	// can free up this buffer after using this.
	ClientInfo *dhcpm.MADCAPClientInfo `idl:"name:ClientInfo" json:"client_info"`
	// Return: The R_DhcpGetMClientInfo return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetMClientInfoResponse) xxx_ToOp(ctx context.Context, op *xxx_GetMClientInfoOperation) *xxx_GetMClientInfoOperation {
	if op == nil {
		op = &xxx_GetMClientInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.ClientInfo = o.ClientInfo
	op.Return = o.Return
	return op
}

func (o *GetMClientInfoResponse) xxx_FromOp(ctx context.Context, op *xxx_GetMClientInfoOperation) {
	if o == nil {
		return
	}
	o.ClientInfo = op.ClientInfo
	o.Return = op.Return
}
func (o *GetMClientInfoResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetMClientInfoResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetMClientInfoOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_DeleteMClientInfoOperation structure represents the R_DhcpDeleteMClientInfo operation
type xxx_DeleteMClientInfoOperation struct {
	ServerIPAddress string            `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	ClientInfo      *dhcpm.SearchInfo `idl:"name:ClientInfo;pointer:ref" json:"client_info"`
	Return          uint32            `idl:"name:Return" json:"return"`
}

func (o *xxx_DeleteMClientInfoOperation) OpNum() int { return 12 }

func (o *xxx_DeleteMClientInfoOperation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpDeleteMClientInfo"
}

func (o *xxx_DeleteMClientInfoOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteMClientInfoOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ClientInfo {in} (1:{pointer=ref, alias=LPDHCP_SEARCH_INFO}*(1))(2:{alias=DHCP_SEARCH_INFO}(struct))
	{
		if o.ClientInfo != nil {
			if err := o.ClientInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.SearchInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteMClientInfoOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ClientInfo {in} (1:{pointer=ref, alias=LPDHCP_SEARCH_INFO}*(1))(2:{alias=DHCP_SEARCH_INFO}(struct))
	{
		if o.ClientInfo == nil {
			o.ClientInfo = &dhcpm.SearchInfo{}
		}
		if err := o.ClientInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteMClientInfoOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteMClientInfoOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteMClientInfoOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// DeleteMClientInfoRequest structure represents the R_DhcpDeleteMClientInfo operation request
type DeleteMClientInfoRequest struct {
	// ServerIpAddress: The IP address/host name of the MADCAP server. This parameter is
	// unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// ClientInfo: This is a pointer of type DHCP_SEARCH_INFO (section 2.2.1.2.18), defining
	// the key to be used to search the MADCAP client lease record that needs to be deleted
	// from the MADCAP server.
	ClientInfo *dhcpm.SearchInfo `idl:"name:ClientInfo;pointer:ref" json:"client_info"`
}

func (o *DeleteMClientInfoRequest) xxx_ToOp(ctx context.Context, op *xxx_DeleteMClientInfoOperation) *xxx_DeleteMClientInfoOperation {
	if op == nil {
		op = &xxx_DeleteMClientInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.ClientInfo = o.ClientInfo
	return op
}

func (o *DeleteMClientInfoRequest) xxx_FromOp(ctx context.Context, op *xxx_DeleteMClientInfoOperation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.ClientInfo = op.ClientInfo
}
func (o *DeleteMClientInfoRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *DeleteMClientInfoRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteMClientInfoOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// DeleteMClientInfoResponse structure represents the R_DhcpDeleteMClientInfo operation response
type DeleteMClientInfoResponse struct {
	// Return: The R_DhcpDeleteMClientInfo return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *DeleteMClientInfoResponse) xxx_ToOp(ctx context.Context, op *xxx_DeleteMClientInfoOperation) *xxx_DeleteMClientInfoOperation {
	if op == nil {
		op = &xxx_DeleteMClientInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *DeleteMClientInfoResponse) xxx_FromOp(ctx context.Context, op *xxx_DeleteMClientInfoOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *DeleteMClientInfoResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *DeleteMClientInfoResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteMClientInfoOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumMScopeClientsOperation structure represents the R_DhcpEnumMScopeClients operation
type xxx_EnumMScopeClientsOperation struct {
	ServerIPAddress  string                       `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	MScopeName       string                       `idl:"name:MScopeName;string;pointer:ref" json:"mscope_name"`
	Resume           uint32                       `idl:"name:ResumeHandle" json:"resume"`
	PreferredMaximum uint32                       `idl:"name:PreferredMaximum" json:"preferred_maximum"`
	ClientInfo       *dhcpm.MADCAPClientInfoArray `idl:"name:ClientInfo" json:"client_info"`
	ClientsRead      uint32                       `idl:"name:ClientsRead" json:"clients_read"`
	ClientsTotal     uint32                       `idl:"name:ClientsTotal" json:"clients_total"`
	Return           uint32                       `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumMScopeClientsOperation) OpNum() int { return 13 }

func (o *xxx_EnumMScopeClientsOperation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpEnumMScopeClients"
}

func (o *xxx_EnumMScopeClientsOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumMScopeClientsOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// MScopeName {in} (1:{string, pointer=ref}*(2))(2:{string, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.MScopeName != "" {
			_ptr_MScopeName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.MScopeName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.MScopeName, _ptr_MScopeName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Resume); err != nil {
			return err
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PreferredMaximum); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumMScopeClientsOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// MScopeName {in} (1:{string, pointer=ref}*(2))(2:{string, alias=LPWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		_ptr_MScopeName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.MScopeName); err != nil {
				return err
			}
			return nil
		})
		_s_MScopeName := func(ptr interface{}) { o.MScopeName = *ptr.(*string) }
		if err := w.ReadPointer(&o.MScopeName, _s_MScopeName, _ptr_MScopeName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Resume); err != nil {
			return err
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PreferredMaximum); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumMScopeClientsOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumMScopeClientsOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Resume); err != nil {
			return err
		}
	}
	// ClientInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_MCLIENT_INFO_ARRAY}*(1))(3:{alias=DHCP_MCLIENT_INFO_ARRAY}(struct))
	{
		if o.ClientInfo != nil {
			_ptr_ClientInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.ClientInfo != nil {
					if err := o.ClientInfo.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.MADCAPClientInfoArray{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ClientInfo, _ptr_ClientInfo); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ClientsRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ClientsRead); err != nil {
			return err
		}
	}
	// ClientsTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ClientsTotal); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumMScopeClientsOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Resume); err != nil {
			return err
		}
	}
	// ClientInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_MCLIENT_INFO_ARRAY,pointer=ref}*(1))(3:{alias=DHCP_MCLIENT_INFO_ARRAY}(struct))
	{
		_ptr_ClientInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.ClientInfo == nil {
				o.ClientInfo = &dhcpm.MADCAPClientInfoArray{}
			}
			if err := o.ClientInfo.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ClientInfo := func(ptr interface{}) { o.ClientInfo = *ptr.(**dhcpm.MADCAPClientInfoArray) }
		if err := w.ReadPointer(&o.ClientInfo, _s_ClientInfo, _ptr_ClientInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ClientsRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ClientsRead); err != nil {
			return err
		}
	}
	// ClientsTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ClientsTotal); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumMScopeClientsRequest structure represents the R_DhcpEnumMScopeClients operation request
type EnumMScopeClientsRequest struct {
	// ServerIpAddress: The IP address/host name of the MADCAP server. This parameter is
	// unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// MScopeName: This is a pointer to a Unicode string that contains the name of the multicast
	// subnet from which IPv4 multicast subnet elements are enumerated. There is no restriction
	// on the length of this field.
	MScopeName string `idl:"name:MScopeName;string;pointer:ref" json:"mscope_name"`
	// ResumeHandle: This is a pointer of type DHCP_RESUME_HANDLE (section 2.2.1.2.6) that
	// identifies the enumeration operation. Initially, this value MUST be set to zero,
	// with a successful call returning the handle value used for subsequent enumeration
	// requests. This field contains the last IPv4 multicast address retrieved.
	Resume uint32 `idl:"name:ResumeHandle" json:"resume"`
	// PreferredMaximum: This is of type DWORD, specifying the preferred maximum number
	// of bytes to return. The minimum value is 1,024 bytes (1 kilobyte), and the maximum
	// value is 65,536 bytes (64 kilobytes). If the input value is greater or less than
	// this range, it MUST be set to the maximum or minimum value, respectively. To retrieve
	// all the MADCAP clients serviced by a specific multicast scope, 0xFFFFFFFF is specified.
	PreferredMaximum uint32 `idl:"name:PreferredMaximum" json:"preferred_maximum"`
}

func (o *EnumMScopeClientsRequest) xxx_ToOp(ctx context.Context, op *xxx_EnumMScopeClientsOperation) *xxx_EnumMScopeClientsOperation {
	if op == nil {
		op = &xxx_EnumMScopeClientsOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.MScopeName = o.MScopeName
	op.Resume = o.Resume
	op.PreferredMaximum = o.PreferredMaximum
	return op
}

func (o *EnumMScopeClientsRequest) xxx_FromOp(ctx context.Context, op *xxx_EnumMScopeClientsOperation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.MScopeName = op.MScopeName
	o.Resume = op.Resume
	o.PreferredMaximum = op.PreferredMaximum
}
func (o *EnumMScopeClientsRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumMScopeClientsRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumMScopeClientsOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumMScopeClientsResponse structure represents the R_DhcpEnumMScopeClients operation response
type EnumMScopeClientsResponse struct {
	// ResumeHandle: This is a pointer of type DHCP_RESUME_HANDLE (section 2.2.1.2.6) that
	// identifies the enumeration operation. Initially, this value MUST be set to zero,
	// with a successful call returning the handle value used for subsequent enumeration
	// requests. This field contains the last IPv4 multicast address retrieved.
	Resume uint32 `idl:"name:ResumeHandle" json:"resume"`
	// ClientInfo: This is a pointer of type LPDHCP_MCLIENT_INFO_ARRAY that points to the
	// location that contains the MADCAP lease record array.
	ClientInfo *dhcpm.MADCAPClientInfoArray `idl:"name:ClientInfo" json:"client_info"`
	// ClientsRead: This is a pointer to a DWORD that specifies the number of MADCAP client
	// lease records read in ClientInfo. The caller MUST allocate memory for this parameter
	// equal to the size of a DWORD data type.
	ClientsRead uint32 `idl:"name:ClientsRead" json:"clients_read"`
	// ClientsTotal: This is a pointer to a DWORD that specifies the number of MADCAP client
	// lease records remaining from the current position. The caller MUST allocate memory
	// for this parameter equal to the size of a DWORD data type. For example, if there
	// are 100 MADCAP lease record clients for an IPv4 multicast subnet, and if 10 MADCAP
	// lease records are enumerated per call, then for the first time this would have a
	// value of 90.<47>
	ClientsTotal uint32 `idl:"name:ClientsTotal" json:"clients_total"`
	// Return: The R_DhcpEnumMScopeClients return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumMScopeClientsResponse) xxx_ToOp(ctx context.Context, op *xxx_EnumMScopeClientsOperation) *xxx_EnumMScopeClientsOperation {
	if op == nil {
		op = &xxx_EnumMScopeClientsOperation{}
	}
	if o == nil {
		return op
	}
	op.Resume = o.Resume
	op.ClientInfo = o.ClientInfo
	op.ClientsRead = o.ClientsRead
	op.ClientsTotal = o.ClientsTotal
	op.Return = o.Return
	return op
}

func (o *EnumMScopeClientsResponse) xxx_FromOp(ctx context.Context, op *xxx_EnumMScopeClientsOperation) {
	if o == nil {
		return
	}
	o.Resume = op.Resume
	o.ClientInfo = op.ClientInfo
	o.ClientsRead = op.ClientsRead
	o.ClientsTotal = op.ClientsTotal
	o.Return = op.Return
}
func (o *EnumMScopeClientsResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumMScopeClientsResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumMScopeClientsOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CreateOptionV5Operation structure represents the R_DhcpCreateOptionV5 operation
type xxx_CreateOptionV5Operation struct {
	ServerIPAddress string        `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Flags           uint32        `idl:"name:Flags" json:"flags"`
	OptionID        uint32        `idl:"name:OptionId" json:"option_id"`
	ClassName       string        `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
	VendorName      string        `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	OptionInfo      *dhcpm.Option `idl:"name:OptionInfo" json:"option_info"`
	Return          uint32        `idl:"name:Return" json:"return"`
}

func (o *xxx_CreateOptionV5Operation) OpNum() int { return 14 }

func (o *xxx_CreateOptionV5Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpCreateOptionV5" }

func (o *xxx_CreateOptionV5Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateOptionV5Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	// OptionId {in} (1:{alias=DHCP_OPTION_ID, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.OptionID); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.ClassName != "" {
			_ptr_ClassName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ClassName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ClassName, _ptr_ClassName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.VendorName != "" {
			_ptr_VendorName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.VendorName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.VendorName, _ptr_VendorName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// OptionInfo {in} (1:{alias=LPDHCP_OPTION}*(1))(2:{alias=DHCP_OPTION}(struct))
	{
		if o.OptionInfo != nil {
			if err := o.OptionInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.Option{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateOptionV5Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	// OptionId {in} (1:{alias=DHCP_OPTION_ID, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OptionID); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_ClassName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ClassName); err != nil {
				return err
			}
			return nil
		})
		_s_ClassName := func(ptr interface{}) { o.ClassName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ClassName, _s_ClassName, _ptr_ClassName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_VendorName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.VendorName); err != nil {
				return err
			}
			return nil
		})
		_s_VendorName := func(ptr interface{}) { o.VendorName = *ptr.(*string) }
		if err := w.ReadPointer(&o.VendorName, _s_VendorName, _ptr_VendorName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// OptionInfo {in} (1:{alias=LPDHCP_OPTION,pointer=ref}*(1))(2:{alias=DHCP_OPTION}(struct))
	{
		if o.OptionInfo == nil {
			o.OptionInfo = &dhcpm.Option{}
		}
		if err := o.OptionInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateOptionV5Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateOptionV5Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateOptionV5Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CreateOptionV5Request structure represents the R_DhcpCreateOptionV5 operation request
type CreateOptionV5Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// Flags: This is of type DWORD that specifies that the option definition is created
	// for a specific or default vendor class.
	//
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                        |                                                                                  |
	//	|                 VALUE                  |                                     MEANING                                      |
	//	|                                        |                                                                                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_DEFAULT 0x00000000   | Option definition is created for the default vendor class.                       |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_IS_VENDOR 0x00000003 | If a bitwise AND operation with this bitmask yields a nonzero value, it          |
	//	|                                        | indicates that the option definition is created for a specific vendor class.     |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	Flags uint32 `idl:"name:Flags" json:"flags"`
	// OptionId: This is of type DHCP_OPTION_ID (section 2.2.1.2.3), containing the option
	// identifier for the option being created.
	OptionID uint32 `idl:"name:OptionId" json:"option_id"`
	// ClassName: A pointer to a null-terminated Unicode string that contains the name of
	// the user class for which the option definition is created. This parameter is optional.
	// If the ClassName parameter is not specified, the option definition is created for
	// the default user class.
	ClassName string `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
	// VendorName: A pointer to a null-terminated Unicode string that contains the name
	// of the vendor class for which the option definition is created. This parameter is
	// optional, and if the vendor class name is not specified, the option definition is
	// created for the default vendor class.
	VendorName string `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	// OptionInfo: This is a pointer to a DHCP_OPTION (section 2.2.1.2.25) structure that
	// contains the information about the option definition.
	OptionInfo *dhcpm.Option `idl:"name:OptionInfo" json:"option_info"`
}

func (o *CreateOptionV5Request) xxx_ToOp(ctx context.Context, op *xxx_CreateOptionV5Operation) *xxx_CreateOptionV5Operation {
	if op == nil {
		op = &xxx_CreateOptionV5Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Flags = o.Flags
	op.OptionID = o.OptionID
	op.ClassName = o.ClassName
	op.VendorName = o.VendorName
	op.OptionInfo = o.OptionInfo
	return op
}

func (o *CreateOptionV5Request) xxx_FromOp(ctx context.Context, op *xxx_CreateOptionV5Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Flags = op.Flags
	o.OptionID = op.OptionID
	o.ClassName = op.ClassName
	o.VendorName = op.VendorName
	o.OptionInfo = op.OptionInfo
}
func (o *CreateOptionV5Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *CreateOptionV5Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateOptionV5Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CreateOptionV5Response structure represents the R_DhcpCreateOptionV5 operation response
type CreateOptionV5Response struct {
	// Return: The R_DhcpCreateOptionV5 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CreateOptionV5Response) xxx_ToOp(ctx context.Context, op *xxx_CreateOptionV5Operation) *xxx_CreateOptionV5Operation {
	if op == nil {
		op = &xxx_CreateOptionV5Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *CreateOptionV5Response) xxx_FromOp(ctx context.Context, op *xxx_CreateOptionV5Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *CreateOptionV5Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *CreateOptionV5Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateOptionV5Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetOptionInfoV5Operation structure represents the R_DhcpSetOptionInfoV5 operation
type xxx_SetOptionInfoV5Operation struct {
	ServerIPAddress string        `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Flags           uint32        `idl:"name:Flags" json:"flags"`
	OptionID        uint32        `idl:"name:OptionID" json:"option_id"`
	ClassName       string        `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
	VendorName      string        `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	OptionInfo      *dhcpm.Option `idl:"name:OptionInfo" json:"option_info"`
	Return          uint32        `idl:"name:Return" json:"return"`
}

func (o *xxx_SetOptionInfoV5Operation) OpNum() int { return 15 }

func (o *xxx_SetOptionInfoV5Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpSetOptionInfoV5" }

func (o *xxx_SetOptionInfoV5Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOptionInfoV5Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	// OptionID {in} (1:{alias=DHCP_OPTION_ID, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.OptionID); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.ClassName != "" {
			_ptr_ClassName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ClassName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ClassName, _ptr_ClassName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.VendorName != "" {
			_ptr_VendorName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.VendorName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.VendorName, _ptr_VendorName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// OptionInfo {in} (1:{alias=LPDHCP_OPTION}*(1))(2:{alias=DHCP_OPTION}(struct))
	{
		if o.OptionInfo != nil {
			if err := o.OptionInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.Option{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOptionInfoV5Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	// OptionID {in} (1:{alias=DHCP_OPTION_ID, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OptionID); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_ClassName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ClassName); err != nil {
				return err
			}
			return nil
		})
		_s_ClassName := func(ptr interface{}) { o.ClassName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ClassName, _s_ClassName, _ptr_ClassName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_VendorName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.VendorName); err != nil {
				return err
			}
			return nil
		})
		_s_VendorName := func(ptr interface{}) { o.VendorName = *ptr.(*string) }
		if err := w.ReadPointer(&o.VendorName, _s_VendorName, _ptr_VendorName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// OptionInfo {in} (1:{alias=LPDHCP_OPTION,pointer=ref}*(1))(2:{alias=DHCP_OPTION}(struct))
	{
		if o.OptionInfo == nil {
			o.OptionInfo = &dhcpm.Option{}
		}
		if err := o.OptionInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOptionInfoV5Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOptionInfoV5Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOptionInfoV5Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetOptionInfoV5Request structure represents the R_DhcpSetOptionInfoV5 operation request
type SetOptionInfoV5Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// Flags: This is of type DWORD that specifies that the option definition is modified
	// for a specific or default vendor class.
	//
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                        |                                                                                  |
	//	|                 VALUE                  |                                     MEANING                                      |
	//	|                                        |                                                                                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_DEFAULT 0x00000000   | Option definition is modified for a default vendor class.                        |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_IS_VENDOR 0x00000003 | If a bitwise AND operation with this bitmask yields a nonzero value, it          |
	//	|                                        | indicates that the option definition is modified for a specific vendor class.    |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	Flags uint32 `idl:"name:Flags" json:"flags"`
	// OptionID: This is of type DHCP_OPTION_ID (section 2.2.1.2.3), containing the option
	// identifier for the option being modified.
	OptionID uint32 `idl:"name:OptionID" json:"option_id"`
	// ClassName: A pointer to a null-terminated Unicode string that contains the name of
	// the user class to which the option definition is modified. This parameter is optional.
	// If the ClassName parameter is not specified, the option definition is set for the
	// default user class.
	ClassName string `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
	// VendorName: A pointer to a null-terminated Unicode string that contains the name
	// of the vendor class to which the option definition is modified. This parameter is
	// optional, and if the vendor class is not specified, the option definition is set
	// for the default vendor class.
	VendorName string `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	// OptionInfo: This is a pointer of type DHCP_OPTION (section 2.2.1.2.25), containing
	// a new option definition for the option being modified.
	OptionInfo *dhcpm.Option `idl:"name:OptionInfo" json:"option_info"`
}

func (o *SetOptionInfoV5Request) xxx_ToOp(ctx context.Context, op *xxx_SetOptionInfoV5Operation) *xxx_SetOptionInfoV5Operation {
	if op == nil {
		op = &xxx_SetOptionInfoV5Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Flags = o.Flags
	op.OptionID = o.OptionID
	op.ClassName = o.ClassName
	op.VendorName = o.VendorName
	op.OptionInfo = o.OptionInfo
	return op
}

func (o *SetOptionInfoV5Request) xxx_FromOp(ctx context.Context, op *xxx_SetOptionInfoV5Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Flags = op.Flags
	o.OptionID = op.OptionID
	o.ClassName = op.ClassName
	o.VendorName = op.VendorName
	o.OptionInfo = op.OptionInfo
}
func (o *SetOptionInfoV5Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetOptionInfoV5Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetOptionInfoV5Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetOptionInfoV5Response structure represents the R_DhcpSetOptionInfoV5 operation response
type SetOptionInfoV5Response struct {
	// Return: The R_DhcpSetOptionInfoV5 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetOptionInfoV5Response) xxx_ToOp(ctx context.Context, op *xxx_SetOptionInfoV5Operation) *xxx_SetOptionInfoV5Operation {
	if op == nil {
		op = &xxx_SetOptionInfoV5Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetOptionInfoV5Response) xxx_FromOp(ctx context.Context, op *xxx_SetOptionInfoV5Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetOptionInfoV5Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetOptionInfoV5Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetOptionInfoV5Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetOptionInfoV5Operation structure represents the R_DhcpGetOptionInfoV5 operation
type xxx_GetOptionInfoV5Operation struct {
	ServerIPAddress string        `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Flags           uint32        `idl:"name:Flags" json:"flags"`
	OptionID        uint32        `idl:"name:OptionID" json:"option_id"`
	ClassName       string        `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
	VendorName      string        `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	OptionInfo      *dhcpm.Option `idl:"name:OptionInfo" json:"option_info"`
	Return          uint32        `idl:"name:Return" json:"return"`
}

func (o *xxx_GetOptionInfoV5Operation) OpNum() int { return 16 }

func (o *xxx_GetOptionInfoV5Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpGetOptionInfoV5" }

func (o *xxx_GetOptionInfoV5Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetOptionInfoV5Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	// OptionID {in} (1:{alias=DHCP_OPTION_ID, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.OptionID); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.ClassName != "" {
			_ptr_ClassName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ClassName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ClassName, _ptr_ClassName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.VendorName != "" {
			_ptr_VendorName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.VendorName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.VendorName, _ptr_VendorName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetOptionInfoV5Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	// OptionID {in} (1:{alias=DHCP_OPTION_ID, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OptionID); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_ClassName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ClassName); err != nil {
				return err
			}
			return nil
		})
		_s_ClassName := func(ptr interface{}) { o.ClassName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ClassName, _s_ClassName, _ptr_ClassName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_VendorName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.VendorName); err != nil {
				return err
			}
			return nil
		})
		_s_VendorName := func(ptr interface{}) { o.VendorName = *ptr.(*string) }
		if err := w.ReadPointer(&o.VendorName, _s_VendorName, _ptr_VendorName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetOptionInfoV5Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetOptionInfoV5Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// OptionInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_OPTION}*(1))(3:{alias=DHCP_OPTION}(struct))
	{
		if o.OptionInfo != nil {
			_ptr_OptionInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.OptionInfo != nil {
					if err := o.OptionInfo.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.Option{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.OptionInfo, _ptr_OptionInfo); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetOptionInfoV5Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// OptionInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_OPTION,pointer=ref}*(1))(3:{alias=DHCP_OPTION}(struct))
	{
		_ptr_OptionInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.OptionInfo == nil {
				o.OptionInfo = &dhcpm.Option{}
			}
			if err := o.OptionInfo.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_OptionInfo := func(ptr interface{}) { o.OptionInfo = *ptr.(**dhcpm.Option) }
		if err := w.ReadPointer(&o.OptionInfo, _s_OptionInfo, _ptr_OptionInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetOptionInfoV5Request structure represents the R_DhcpGetOptionInfoV5 operation request
type GetOptionInfoV5Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// Flags: This is of type DWORD that specifies that the option definition is retrieved
	// for a specific or default vendor class.
	//
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                        |                                                                                  |
	//	|                 VALUE                  |                                     MEANING                                      |
	//	|                                        |                                                                                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_DEFAULT 0x00000000   | Option definition is modified for a default vendor class.                        |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_IS_VENDOR 0x00000003 | If a bitwise AND operation with this bitmask yields a nonzero value, it          |
	//	|                                        | indicates that the option definition is retrieved for a specific vendor class.   |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	Flags uint32 `idl:"name:Flags" json:"flags"`
	// OptionID: This is of type DHCP_OPTION_ID (section 2.2.1.2.3), containing the option
	// identifier for the option being retrieved.
	OptionID uint32 `idl:"name:OptionID" json:"option_id"`
	// ClassName: A pointer to a null-terminated Unicode string that contains the name of
	// the user class for which the option definition is retrieved. This parameter is optional.
	// If the ClassName parameter is not specified, the option definition is retrieved for
	// the default user class.
	ClassName string `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
	// VendorName: A pointer to a null-terminated Unicode string that contains the name
	// of the vendor class for which the option definition is retrieved. This parameter
	// is optional, and if the vendor class name is not specified, the option definition
	// is retrieved for the default vendor class.
	VendorName string `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
}

func (o *GetOptionInfoV5Request) xxx_ToOp(ctx context.Context, op *xxx_GetOptionInfoV5Operation) *xxx_GetOptionInfoV5Operation {
	if op == nil {
		op = &xxx_GetOptionInfoV5Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Flags = o.Flags
	op.OptionID = o.OptionID
	op.ClassName = o.ClassName
	op.VendorName = o.VendorName
	return op
}

func (o *GetOptionInfoV5Request) xxx_FromOp(ctx context.Context, op *xxx_GetOptionInfoV5Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Flags = op.Flags
	o.OptionID = op.OptionID
	o.ClassName = op.ClassName
	o.VendorName = op.VendorName
}
func (o *GetOptionInfoV5Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetOptionInfoV5Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetOptionInfoV5Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetOptionInfoV5Response structure represents the R_DhcpGetOptionInfoV5 operation response
type GetOptionInfoV5Response struct {
	// OptionInfo: This is a pointer of type DHCP_OPTION (section 2.2.1.2.25) in which the
	// option definition for the option is retrieved.
	OptionInfo *dhcpm.Option `idl:"name:OptionInfo" json:"option_info"`
	// Return: The R_DhcpGetOptionInfoV5 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetOptionInfoV5Response) xxx_ToOp(ctx context.Context, op *xxx_GetOptionInfoV5Operation) *xxx_GetOptionInfoV5Operation {
	if op == nil {
		op = &xxx_GetOptionInfoV5Operation{}
	}
	if o == nil {
		return op
	}
	op.OptionInfo = o.OptionInfo
	op.Return = o.Return
	return op
}

func (o *GetOptionInfoV5Response) xxx_FromOp(ctx context.Context, op *xxx_GetOptionInfoV5Operation) {
	if o == nil {
		return
	}
	o.OptionInfo = op.OptionInfo
	o.Return = op.Return
}
func (o *GetOptionInfoV5Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetOptionInfoV5Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetOptionInfoV5Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumOptionsV5Operation structure represents the R_DhcpEnumOptionsV5 operation
type xxx_EnumOptionsV5Operation struct {
	ServerIPAddress  string             `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Flags            uint32             `idl:"name:Flags" json:"flags"`
	ClassName        string             `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
	VendorName       string             `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	Resume           uint32             `idl:"name:ResumeHandle" json:"resume"`
	PreferredMaximum uint32             `idl:"name:PreferredMaximum" json:"preferred_maximum"`
	Options          *dhcpm.OptionArray `idl:"name:Options" json:"options"`
	OptionsRead      uint32             `idl:"name:OptionsRead" json:"options_read"`
	OptionsTotal     uint32             `idl:"name:OptionsTotal" json:"options_total"`
	Return           uint32             `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumOptionsV5Operation) OpNum() int { return 17 }

func (o *xxx_EnumOptionsV5Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpEnumOptionsV5" }

func (o *xxx_EnumOptionsV5Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumOptionsV5Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.ClassName != "" {
			_ptr_ClassName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ClassName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ClassName, _ptr_ClassName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.VendorName != "" {
			_ptr_VendorName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.VendorName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.VendorName, _ptr_VendorName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Resume); err != nil {
			return err
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PreferredMaximum); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumOptionsV5Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_ClassName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ClassName); err != nil {
				return err
			}
			return nil
		})
		_s_ClassName := func(ptr interface{}) { o.ClassName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ClassName, _s_ClassName, _ptr_ClassName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_VendorName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.VendorName); err != nil {
				return err
			}
			return nil
		})
		_s_VendorName := func(ptr interface{}) { o.VendorName = *ptr.(*string) }
		if err := w.ReadPointer(&o.VendorName, _s_VendorName, _ptr_VendorName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Resume); err != nil {
			return err
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PreferredMaximum); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumOptionsV5Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumOptionsV5Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Resume); err != nil {
			return err
		}
	}
	// Options {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_OPTION_ARRAY}*(1))(3:{alias=DHCP_OPTION_ARRAY}(struct))
	{
		if o.Options != nil {
			_ptr_Options := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Options != nil {
					if err := o.Options.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.OptionArray{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Options, _ptr_Options); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// OptionsRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OptionsRead); err != nil {
			return err
		}
	}
	// OptionsTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OptionsTotal); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumOptionsV5Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Resume); err != nil {
			return err
		}
	}
	// Options {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_OPTION_ARRAY,pointer=ref}*(1))(3:{alias=DHCP_OPTION_ARRAY}(struct))
	{
		_ptr_Options := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Options == nil {
				o.Options = &dhcpm.OptionArray{}
			}
			if err := o.Options.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_Options := func(ptr interface{}) { o.Options = *ptr.(**dhcpm.OptionArray) }
		if err := w.ReadPointer(&o.Options, _s_Options, _ptr_Options); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// OptionsRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OptionsRead); err != nil {
			return err
		}
	}
	// OptionsTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OptionsTotal); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumOptionsV5Request structure represents the R_DhcpEnumOptionsV5 operation request
type EnumOptionsV5Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// Flags: This is of type DWORD that specifies that the option definition is enumerated
	// for a specific or default vendor class.
	//
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                        |                                                                                  |
	//	|                 VALUE                  |                                     MEANING                                      |
	//	|                                        |                                                                                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_DEFAULT 0x00000000   | Option definition is enumerated for a default vendor class.                      |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_IS_VENDOR 0x00000003 | If a bitwise AND operation with this bitmask yields a nonzero value, it          |
	//	|                                        | indicates that the option definition is enumerated for a specific vendor class.  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	Flags uint32 `idl:"name:Flags" json:"flags"`
	// ClassName: A pointer to a null-terminated Unicode string that contains the name of
	// the user class for which the option definition is enumerated. This parameter is optional.
	// If the ClassName parameter is not specified, the option definition is enumerated
	// for the default user class.
	ClassName string `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
	// VendorName: A pointer to a null-terminated Unicode string that contains the name
	// of the vendor class for which the option definition is enumerated. This parameter
	// is optional. If the vendor class name is not specified, the option definition is
	// enumerated for the default vendor class.
	VendorName string `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	// ResumeHandle: This is a pointer of type DHCP_RESUME_HANDLE (section 2.2.1.2.6) that
	// identifies the enumeration operation. Initially, this value MUST be set to zero,
	// with a successful call returning the handle value used for subsequent enumeration
	// requests. For example, if PreferredMaximum is set to 1,000 bytes, and 2,000 bytes'
	// worth of option definition are stored on the DHCPv4 server, the resume handle can
	// be used after the first 1,000 bytes are retrieved to obtain the next 1,000 on a subsequent
	// call, and so forth.
	Resume uint32 `idl:"name:ResumeHandle" json:"resume"`
	// PreferredMaximum:  This is of type DWORD, specifying the preferred maximum number
	// of bytes to return. If the number of remaining unenumerated option definitions (in
	// bytes) is less than this value, all option definitions are returned. To retrieve
	// all the option definitions defined for a specific vendor and user class, 0xFFFFFFFF
	// is specified.
	PreferredMaximum uint32 `idl:"name:PreferredMaximum" json:"preferred_maximum"`
}

func (o *EnumOptionsV5Request) xxx_ToOp(ctx context.Context, op *xxx_EnumOptionsV5Operation) *xxx_EnumOptionsV5Operation {
	if op == nil {
		op = &xxx_EnumOptionsV5Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Flags = o.Flags
	op.ClassName = o.ClassName
	op.VendorName = o.VendorName
	op.Resume = o.Resume
	op.PreferredMaximum = o.PreferredMaximum
	return op
}

func (o *EnumOptionsV5Request) xxx_FromOp(ctx context.Context, op *xxx_EnumOptionsV5Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Flags = op.Flags
	o.ClassName = op.ClassName
	o.VendorName = op.VendorName
	o.Resume = op.Resume
	o.PreferredMaximum = op.PreferredMaximum
}
func (o *EnumOptionsV5Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumOptionsV5Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumOptionsV5Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumOptionsV5Response structure represents the R_DhcpEnumOptionsV5 operation response
type EnumOptionsV5Response struct {
	// ResumeHandle: This is a pointer of type DHCP_RESUME_HANDLE (section 2.2.1.2.6) that
	// identifies the enumeration operation. Initially, this value MUST be set to zero,
	// with a successful call returning the handle value used for subsequent enumeration
	// requests. For example, if PreferredMaximum is set to 1,000 bytes, and 2,000 bytes'
	// worth of option definition are stored on the DHCPv4 server, the resume handle can
	// be used after the first 1,000 bytes are retrieved to obtain the next 1,000 on a subsequent
	// call, and so forth.
	Resume uint32 `idl:"name:ResumeHandle" json:"resume"`
	// Options: This is a pointer of type LPDHCP_OPTION_ARRAY that points to the location
	// where all the option definitions for a specific user and vendor class are retrieved
	// from the DHCPv4 server.
	Options *dhcpm.OptionArray `idl:"name:Options" json:"options"`
	// OptionsRead: This is a pointer to a DWORD value that specifies the number of option
	// definitions read in Options. The caller must allocate memory for this parameter equal
	// to the size of data type DWORD.
	OptionsRead uint32 `idl:"name:OptionsRead" json:"options_read"`
	// OptionsTotal: This is a pointer to a DWORD value that specifies the number of option
	// definitions that have not yet been enumerated. The caller must allocate memory for
	// this parameter that is equal to the size of data type DWORD.
	OptionsTotal uint32 `idl:"name:OptionsTotal" json:"options_total"`
	// Return: The R_DhcpEnumOptionsV5 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumOptionsV5Response) xxx_ToOp(ctx context.Context, op *xxx_EnumOptionsV5Operation) *xxx_EnumOptionsV5Operation {
	if op == nil {
		op = &xxx_EnumOptionsV5Operation{}
	}
	if o == nil {
		return op
	}
	op.Resume = o.Resume
	op.Options = o.Options
	op.OptionsRead = o.OptionsRead
	op.OptionsTotal = o.OptionsTotal
	op.Return = o.Return
	return op
}

func (o *EnumOptionsV5Response) xxx_FromOp(ctx context.Context, op *xxx_EnumOptionsV5Operation) {
	if o == nil {
		return
	}
	o.Resume = op.Resume
	o.Options = op.Options
	o.OptionsRead = op.OptionsRead
	o.OptionsTotal = op.OptionsTotal
	o.Return = op.Return
}
func (o *EnumOptionsV5Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumOptionsV5Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumOptionsV5Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_RemoveOptionV5Operation structure represents the R_DhcpRemoveOptionV5 operation
type xxx_RemoveOptionV5Operation struct {
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Flags           uint32 `idl:"name:Flags" json:"flags"`
	OptionID        uint32 `idl:"name:OptionID" json:"option_id"`
	ClassName       string `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
	VendorName      string `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	Return          uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_RemoveOptionV5Operation) OpNum() int { return 18 }

func (o *xxx_RemoveOptionV5Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpRemoveOptionV5" }

func (o *xxx_RemoveOptionV5Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveOptionV5Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	// OptionID {in} (1:{alias=DHCP_OPTION_ID, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.OptionID); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.ClassName != "" {
			_ptr_ClassName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ClassName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ClassName, _ptr_ClassName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.VendorName != "" {
			_ptr_VendorName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.VendorName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.VendorName, _ptr_VendorName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveOptionV5Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	// OptionID {in} (1:{alias=DHCP_OPTION_ID, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OptionID); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_ClassName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ClassName); err != nil {
				return err
			}
			return nil
		})
		_s_ClassName := func(ptr interface{}) { o.ClassName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ClassName, _s_ClassName, _ptr_ClassName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_VendorName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.VendorName); err != nil {
				return err
			}
			return nil
		})
		_s_VendorName := func(ptr interface{}) { o.VendorName = *ptr.(*string) }
		if err := w.ReadPointer(&o.VendorName, _s_VendorName, _ptr_VendorName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveOptionV5Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveOptionV5Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveOptionV5Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// RemoveOptionV5Request structure represents the R_DhcpRemoveOptionV5 operation request
type RemoveOptionV5Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// Flags: This is of type DWORD that specifies that the option definition is removed
	// for a specific or default vendor class.
	//
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                        |                                                                                  |
	//	|                 VALUE                  |                                     MEANING                                      |
	//	|                                        |                                                                                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_DEFAULT 0x00000000   | Option definition is removed for the default vendor class.                       |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_IS_VENDOR 0x00000003 | If a bitwise AND operation with this bitmask yields a nonzero value, it          |
	//	|                                        | indicates that the option definition is removed for a specific vendor class.     |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	Flags uint32 `idl:"name:Flags" json:"flags"`
	// OptionID: This is of type DHCP_OPTION_ID (section 2.2.1.2.3), containing the option
	// identifier for the option definition being removed.
	OptionID uint32 `idl:"name:OptionID" json:"option_id"`
	// ClassName: A pointer to a null-terminated Unicode string that contains the name of
	// the user class for which the option definition is removed. This parameter is optional.
	// If the ClassName parameter is not specified, the option definition is removed for
	// the default user class.
	ClassName string `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
	// VendorName: A pointer to a null-terminated Unicode string that contains the name
	// of the vendor class for which the option definition is removed. This parameter is
	// optional. If vendor class name is not specified, the option definition is removed
	// for the default vendor class.
	VendorName string `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
}

func (o *RemoveOptionV5Request) xxx_ToOp(ctx context.Context, op *xxx_RemoveOptionV5Operation) *xxx_RemoveOptionV5Operation {
	if op == nil {
		op = &xxx_RemoveOptionV5Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Flags = o.Flags
	op.OptionID = o.OptionID
	op.ClassName = o.ClassName
	op.VendorName = o.VendorName
	return op
}

func (o *RemoveOptionV5Request) xxx_FromOp(ctx context.Context, op *xxx_RemoveOptionV5Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Flags = op.Flags
	o.OptionID = op.OptionID
	o.ClassName = op.ClassName
	o.VendorName = op.VendorName
}
func (o *RemoveOptionV5Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *RemoveOptionV5Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemoveOptionV5Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// RemoveOptionV5Response structure represents the R_DhcpRemoveOptionV5 operation response
type RemoveOptionV5Response struct {
	// Return: The R_DhcpRemoveOptionV5 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *RemoveOptionV5Response) xxx_ToOp(ctx context.Context, op *xxx_RemoveOptionV5Operation) *xxx_RemoveOptionV5Operation {
	if op == nil {
		op = &xxx_RemoveOptionV5Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *RemoveOptionV5Response) xxx_FromOp(ctx context.Context, op *xxx_RemoveOptionV5Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *RemoveOptionV5Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *RemoveOptionV5Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemoveOptionV5Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetOptionValueV5Operation structure represents the R_DhcpSetOptionValueV5 operation
type xxx_SetOptionValueV5Operation struct {
	ServerIPAddress string                 `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Flags           uint32                 `idl:"name:Flags" json:"flags"`
	OptionID        uint32                 `idl:"name:OptionId" json:"option_id"`
	ClassName       string                 `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
	VendorName      string                 `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	ScopeInfo       *dhcpm.OptionScopeInfo `idl:"name:ScopeInfo" json:"scope_info"`
	OptionValue     *dhcpm.OptionData      `idl:"name:OptionValue" json:"option_value"`
	Return          uint32                 `idl:"name:Return" json:"return"`
}

func (o *xxx_SetOptionValueV5Operation) OpNum() int { return 19 }

func (o *xxx_SetOptionValueV5Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpSetOptionValueV5" }

func (o *xxx_SetOptionValueV5Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOptionValueV5Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	// OptionId {in} (1:{alias=DHCP_OPTION_ID, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.OptionID); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.ClassName != "" {
			_ptr_ClassName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ClassName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ClassName, _ptr_ClassName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.VendorName != "" {
			_ptr_VendorName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.VendorName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.VendorName, _ptr_VendorName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ScopeInfo {in} (1:{alias=LPDHCP_OPTION_SCOPE_INFO}*(1))(2:{alias=DHCP_OPTION_SCOPE_INFO}(struct))
	{
		if o.ScopeInfo != nil {
			if err := o.ScopeInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.OptionScopeInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// OptionValue {in} (1:{alias=LPDHCP_OPTION_DATA}*(1))(2:{alias=DHCP_OPTION_DATA}(struct))
	{
		if o.OptionValue != nil {
			if err := o.OptionValue.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.OptionData{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOptionValueV5Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	// OptionId {in} (1:{alias=DHCP_OPTION_ID, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OptionID); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_ClassName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ClassName); err != nil {
				return err
			}
			return nil
		})
		_s_ClassName := func(ptr interface{}) { o.ClassName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ClassName, _s_ClassName, _ptr_ClassName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_VendorName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.VendorName); err != nil {
				return err
			}
			return nil
		})
		_s_VendorName := func(ptr interface{}) { o.VendorName = *ptr.(*string) }
		if err := w.ReadPointer(&o.VendorName, _s_VendorName, _ptr_VendorName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ScopeInfo {in} (1:{alias=LPDHCP_OPTION_SCOPE_INFO,pointer=ref}*(1))(2:{alias=DHCP_OPTION_SCOPE_INFO}(struct))
	{
		if o.ScopeInfo == nil {
			o.ScopeInfo = &dhcpm.OptionScopeInfo{}
		}
		if err := o.ScopeInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// OptionValue {in} (1:{alias=LPDHCP_OPTION_DATA,pointer=ref}*(1))(2:{alias=DHCP_OPTION_DATA}(struct))
	{
		if o.OptionValue == nil {
			o.OptionValue = &dhcpm.OptionData{}
		}
		if err := o.OptionValue.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOptionValueV5Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOptionValueV5Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOptionValueV5Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetOptionValueV5Request structure represents the R_DhcpSetOptionValueV5 operation request
type SetOptionValueV5Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// Flags: This is of type DWORD that specifies that the option value is set for a specific
	// or default vendor class.
	//
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                        |                                                                                  |
	//	|                 VALUE                  |                                     MEANING                                      |
	//	|                                        |                                                                                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_DEFAULT 0x00000000   | Option definition is set for the default vendor class.                           |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_IS_VENDOR 0x00000003 | If a bitwise AND operation with this bitmask yields a nonzero value, it          |
	//	|                                        | indicates that the option definition is set for a specific vendor class.         |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	Flags uint32 `idl:"name:Flags" json:"flags"`
	// OptionId: This is of type DHCP_OPTION_ID (section 2.2.1.2.3), containing the option
	// identifier of the option being set or modified.
	OptionID uint32 `idl:"name:OptionId" json:"option_id"`
	// ClassName: A pointer to a null-terminated Unicode string that contains the name of
	// the user class to which the option value is being set. This parameter is optional.
	// If the ClassName parameter is not specified, the option value is set for the default
	// user class.
	ClassName string `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
	// VendorName: A pointer to a null-terminated Unicode string that contains the name
	// of the vendor class to which the option value is being set. This parameter is optional.
	// If the vendor class is not specified, the option value is set for a default vendor
	// class.
	VendorName string `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	// ScopeInfo: This is a pointer to a DHCP_OPTION_SCOPE_INFO (section 2.2.1.2.41) structure
	// that contains information describing the DHCPv4 scope this option value is set on.
	// This value contains the level (that is, default, server, scope, multicast scope,
	// or IPv4 reservation level) at which the option values are set.
	ScopeInfo *dhcpm.OptionScopeInfo `idl:"name:ScopeInfo" json:"scope_info"`
	// OptionValue: A pointer to DHCP_OPTION_DATA (section 2.2.1.2.24) structure that contains
	// the option value that is set for an option corresponding to the OptionId. For Dynamic
	// DNS update settings, see section 3.3.1.
	//
	// The method does not perform any checks to ensure that the OptionValue passed in is
	// of the same OptionType as that of the option corresponding to the OptionId passed
	// in. It is the responsibility of the caller to ensure that the correct OptionType
	// is used for the OptionValue passed in. In case the OptionType of the OptionValue
	// passed in is different from that of the option corresponding to the OptionId, the
	// behavior is undefined.
	OptionValue *dhcpm.OptionData `idl:"name:OptionValue" json:"option_value"`
}

func (o *SetOptionValueV5Request) xxx_ToOp(ctx context.Context, op *xxx_SetOptionValueV5Operation) *xxx_SetOptionValueV5Operation {
	if op == nil {
		op = &xxx_SetOptionValueV5Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Flags = o.Flags
	op.OptionID = o.OptionID
	op.ClassName = o.ClassName
	op.VendorName = o.VendorName
	op.ScopeInfo = o.ScopeInfo
	op.OptionValue = o.OptionValue
	return op
}

func (o *SetOptionValueV5Request) xxx_FromOp(ctx context.Context, op *xxx_SetOptionValueV5Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Flags = op.Flags
	o.OptionID = op.OptionID
	o.ClassName = op.ClassName
	o.VendorName = op.VendorName
	o.ScopeInfo = op.ScopeInfo
	o.OptionValue = op.OptionValue
}
func (o *SetOptionValueV5Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetOptionValueV5Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetOptionValueV5Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetOptionValueV5Response structure represents the R_DhcpSetOptionValueV5 operation response
type SetOptionValueV5Response struct {
	// Return: The R_DhcpSetOptionValueV5 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetOptionValueV5Response) xxx_ToOp(ctx context.Context, op *xxx_SetOptionValueV5Operation) *xxx_SetOptionValueV5Operation {
	if op == nil {
		op = &xxx_SetOptionValueV5Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetOptionValueV5Response) xxx_FromOp(ctx context.Context, op *xxx_SetOptionValueV5Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetOptionValueV5Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetOptionValueV5Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetOptionValueV5Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetOptionValuesV5Operation structure represents the R_DhcpSetOptionValuesV5 operation
type xxx_SetOptionValuesV5Operation struct {
	ServerIPAddress string                  `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Flags           uint32                  `idl:"name:Flags" json:"flags"`
	ClassName       string                  `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
	VendorName      string                  `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	ScopeInfo       *dhcpm.OptionScopeInfo  `idl:"name:ScopeInfo" json:"scope_info"`
	OptionValues    *dhcpm.OptionValueArray `idl:"name:OptionValues" json:"option_values"`
	Return          uint32                  `idl:"name:Return" json:"return"`
}

func (o *xxx_SetOptionValuesV5Operation) OpNum() int { return 20 }

func (o *xxx_SetOptionValuesV5Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpSetOptionValuesV5"
}

func (o *xxx_SetOptionValuesV5Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOptionValuesV5Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.ClassName != "" {
			_ptr_ClassName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ClassName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ClassName, _ptr_ClassName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.VendorName != "" {
			_ptr_VendorName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.VendorName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.VendorName, _ptr_VendorName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ScopeInfo {in} (1:{alias=LPDHCP_OPTION_SCOPE_INFO}*(1))(2:{alias=DHCP_OPTION_SCOPE_INFO}(struct))
	{
		if o.ScopeInfo != nil {
			if err := o.ScopeInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.OptionScopeInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// OptionValues {in} (1:{alias=LPDHCP_OPTION_VALUE_ARRAY}*(1))(2:{alias=DHCP_OPTION_VALUE_ARRAY}(struct))
	{
		if o.OptionValues != nil {
			if err := o.OptionValues.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.OptionValueArray{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOptionValuesV5Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_ClassName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ClassName); err != nil {
				return err
			}
			return nil
		})
		_s_ClassName := func(ptr interface{}) { o.ClassName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ClassName, _s_ClassName, _ptr_ClassName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_VendorName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.VendorName); err != nil {
				return err
			}
			return nil
		})
		_s_VendorName := func(ptr interface{}) { o.VendorName = *ptr.(*string) }
		if err := w.ReadPointer(&o.VendorName, _s_VendorName, _ptr_VendorName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ScopeInfo {in} (1:{alias=LPDHCP_OPTION_SCOPE_INFO,pointer=ref}*(1))(2:{alias=DHCP_OPTION_SCOPE_INFO}(struct))
	{
		if o.ScopeInfo == nil {
			o.ScopeInfo = &dhcpm.OptionScopeInfo{}
		}
		if err := o.ScopeInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// OptionValues {in} (1:{alias=LPDHCP_OPTION_VALUE_ARRAY,pointer=ref}*(1))(2:{alias=DHCP_OPTION_VALUE_ARRAY}(struct))
	{
		if o.OptionValues == nil {
			o.OptionValues = &dhcpm.OptionValueArray{}
		}
		if err := o.OptionValues.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOptionValuesV5Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOptionValuesV5Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOptionValuesV5Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetOptionValuesV5Request structure represents the R_DhcpSetOptionValuesV5 operation request
type SetOptionValuesV5Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// Flags:  This is of type DWORD that specifies that the option values are set for
	// a specific or default vendor class.
	//
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                        |                                                                                  |
	//	|                 VALUE                  |                                     MEANING                                      |
	//	|                                        |                                                                                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_DEFAULT 0x00000000   | Option definitions are set for the default vendor class.                         |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_IS_VENDOR 0x00000003 | If a bitwise AND operation with this bitmask yields a nonzero value, it          |
	//	|                                        | indicates that the option definitions are set for a specific vendor class.       |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	Flags uint32 `idl:"name:Flags" json:"flags"`
	// ClassName: A pointer to a null-terminated Unicode string that contains the name of
	// the user class to which the option value is being set. This parameter is optional.
	// If the ClassName parameter is not specified, the option values are set for the default
	// user class.
	ClassName string `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
	// VendorName: A pointer to a null-terminated Unicode string that contains the name
	// of the vendor class to which the option value is being set. This parameter is optional.
	// If a vendor class is not specified, the option values are set for a default vendor
	// class.
	VendorName string `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	// ScopeInfo: This is a pointer to a DHCP_OPTION_SCOPE_INFO (section 2.2.1.2.41) structure
	// that contains information describing the DHCPv4 scope this option value is set on.
	// This value contains the level (that is, default, server, scope, multicast scope,
	// or IPv4 reservation level) at which the option values are set.
	ScopeInfo *dhcpm.OptionScopeInfo `idl:"name:ScopeInfo" json:"scope_info"`
	// OptionValues: This is a pointer of type DHCP_OPTION_VALUE_ARRAY (section 2.2.1.2.43)
	// that points to location that contains one or more option identifiers, along with
	// the values.
	OptionValues *dhcpm.OptionValueArray `idl:"name:OptionValues" json:"option_values"`
}

func (o *SetOptionValuesV5Request) xxx_ToOp(ctx context.Context, op *xxx_SetOptionValuesV5Operation) *xxx_SetOptionValuesV5Operation {
	if op == nil {
		op = &xxx_SetOptionValuesV5Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Flags = o.Flags
	op.ClassName = o.ClassName
	op.VendorName = o.VendorName
	op.ScopeInfo = o.ScopeInfo
	op.OptionValues = o.OptionValues
	return op
}

func (o *SetOptionValuesV5Request) xxx_FromOp(ctx context.Context, op *xxx_SetOptionValuesV5Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Flags = op.Flags
	o.ClassName = op.ClassName
	o.VendorName = op.VendorName
	o.ScopeInfo = op.ScopeInfo
	o.OptionValues = op.OptionValues
}
func (o *SetOptionValuesV5Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetOptionValuesV5Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetOptionValuesV5Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetOptionValuesV5Response structure represents the R_DhcpSetOptionValuesV5 operation response
type SetOptionValuesV5Response struct {
	// Return: The R_DhcpSetOptionValuesV5 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetOptionValuesV5Response) xxx_ToOp(ctx context.Context, op *xxx_SetOptionValuesV5Operation) *xxx_SetOptionValuesV5Operation {
	if op == nil {
		op = &xxx_SetOptionValuesV5Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetOptionValuesV5Response) xxx_FromOp(ctx context.Context, op *xxx_SetOptionValuesV5Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetOptionValuesV5Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetOptionValuesV5Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetOptionValuesV5Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetOptionValueV5Operation structure represents the R_DhcpGetOptionValueV5 operation
type xxx_GetOptionValueV5Operation struct {
	ServerIPAddress string                 `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Flags           uint32                 `idl:"name:Flags" json:"flags"`
	OptionID        uint32                 `idl:"name:OptionID" json:"option_id"`
	ClassName       string                 `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
	VendorName      string                 `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	ScopeInfo       *dhcpm.OptionScopeInfo `idl:"name:ScopeInfo" json:"scope_info"`
	OptionValue     *dhcpm.OptionValue     `idl:"name:OptionValue" json:"option_value"`
	Return          uint32                 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetOptionValueV5Operation) OpNum() int { return 21 }

func (o *xxx_GetOptionValueV5Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpGetOptionValueV5" }

func (o *xxx_GetOptionValueV5Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetOptionValueV5Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	// OptionID {in} (1:{alias=DHCP_OPTION_ID, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.OptionID); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.ClassName != "" {
			_ptr_ClassName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ClassName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ClassName, _ptr_ClassName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.VendorName != "" {
			_ptr_VendorName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.VendorName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.VendorName, _ptr_VendorName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ScopeInfo {in} (1:{alias=LPDHCP_OPTION_SCOPE_INFO}*(1))(2:{alias=DHCP_OPTION_SCOPE_INFO}(struct))
	{
		if o.ScopeInfo != nil {
			if err := o.ScopeInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.OptionScopeInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetOptionValueV5Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	// OptionID {in} (1:{alias=DHCP_OPTION_ID, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OptionID); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_ClassName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ClassName); err != nil {
				return err
			}
			return nil
		})
		_s_ClassName := func(ptr interface{}) { o.ClassName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ClassName, _s_ClassName, _ptr_ClassName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_VendorName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.VendorName); err != nil {
				return err
			}
			return nil
		})
		_s_VendorName := func(ptr interface{}) { o.VendorName = *ptr.(*string) }
		if err := w.ReadPointer(&o.VendorName, _s_VendorName, _ptr_VendorName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ScopeInfo {in} (1:{alias=LPDHCP_OPTION_SCOPE_INFO,pointer=ref}*(1))(2:{alias=DHCP_OPTION_SCOPE_INFO}(struct))
	{
		if o.ScopeInfo == nil {
			o.ScopeInfo = &dhcpm.OptionScopeInfo{}
		}
		if err := o.ScopeInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetOptionValueV5Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetOptionValueV5Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// OptionValue {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_OPTION_VALUE}*(1))(3:{alias=DHCP_OPTION_VALUE}(struct))
	{
		if o.OptionValue != nil {
			_ptr_OptionValue := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.OptionValue != nil {
					if err := o.OptionValue.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.OptionValue{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.OptionValue, _ptr_OptionValue); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetOptionValueV5Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// OptionValue {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_OPTION_VALUE,pointer=ref}*(1))(3:{alias=DHCP_OPTION_VALUE}(struct))
	{
		_ptr_OptionValue := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.OptionValue == nil {
				o.OptionValue = &dhcpm.OptionValue{}
			}
			if err := o.OptionValue.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_OptionValue := func(ptr interface{}) { o.OptionValue = *ptr.(**dhcpm.OptionValue) }
		if err := w.ReadPointer(&o.OptionValue, _s_OptionValue, _ptr_OptionValue); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetOptionValueV5Request structure represents the R_DhcpGetOptionValueV5 operation request
type GetOptionValueV5Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// Flags: This is of type DWORD, specifying that the option value is retrieved for a
	// specific or default vendor class.
	//
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                        |                                                                                  |
	//	|                 VALUE                  |                                     MEANING                                      |
	//	|                                        |                                                                                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_DEFAULT 0x00000000   | Option value is retrieved for a default vendor class.                            |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_IS_VENDOR 0x00000003 | If a bitwise AND operation with this bitmask yields a nonzero value, it          |
	//	|                                        | indicates that the option value is retrieved for a specific vendor class. This   |
	//	|                                        | validation MUST pass if a non-NULL parameter is passed in VendorName.            |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	Flags uint32 `idl:"name:Flags" json:"flags"`
	// OptionID: This is of type DHCP_OPTION_ID (section 2.2.1.2.3), containing the option
	// identifier for the option being retrieved.
	OptionID uint32 `idl:"name:OptionID" json:"option_id"`
	// ClassName: A pointer to a null-terminated Unicode string that contains the name of
	// the user class to which the option value is being retrieved. This parameter is optional.
	// If the ClassName is not specified, the option value is retrieved for the default
	// user class. This parameter is ignored if ScopeType is set to DhcpDefaultOptions in
	// the ScopeInfo parameter.
	ClassName string `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
	// VendorName: A pointer to a null-terminated Unicode string that contains the name
	// of the vendor class to which the option value is being retrieved. This parameter
	// is optional. If the vendor class is not specified, the option value is retrieved
	// for the default vendor class.
	VendorName string `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	// ScopeInfo: This is a pointer to a DHCP_OPTION_SCOPE_INFO (section 2.2.1.2.41) structure
	// that contains information describing the DHCPv4 scope from which this option value
	// is retrieved. This value defines that the option is being retrieved from default,
	// server, multicast scope, or scope level or for an IPv4 reservation.
	ScopeInfo *dhcpm.OptionScopeInfo `idl:"name:ScopeInfo" json:"scope_info"`
}

func (o *GetOptionValueV5Request) xxx_ToOp(ctx context.Context, op *xxx_GetOptionValueV5Operation) *xxx_GetOptionValueV5Operation {
	if op == nil {
		op = &xxx_GetOptionValueV5Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Flags = o.Flags
	op.OptionID = o.OptionID
	op.ClassName = o.ClassName
	op.VendorName = o.VendorName
	op.ScopeInfo = o.ScopeInfo
	return op
}

func (o *GetOptionValueV5Request) xxx_FromOp(ctx context.Context, op *xxx_GetOptionValueV5Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Flags = op.Flags
	o.OptionID = op.OptionID
	o.ClassName = op.ClassName
	o.VendorName = op.VendorName
	o.ScopeInfo = op.ScopeInfo
}
func (o *GetOptionValueV5Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetOptionValueV5Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetOptionValueV5Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetOptionValueV5Response structure represents the R_DhcpGetOptionValueV5 operation response
type GetOptionValueV5Response struct {
	// OptionValue: This is a pointer of type LPDHCP_OPTION_VALUE in which the option value
	// is retrieved corresponding to OptionID. For Dynamic DNS update settings, see section
	// 3.3.1.
	OptionValue *dhcpm.OptionValue `idl:"name:OptionValue" json:"option_value"`
	// Return: The R_DhcpGetOptionValueV5 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetOptionValueV5Response) xxx_ToOp(ctx context.Context, op *xxx_GetOptionValueV5Operation) *xxx_GetOptionValueV5Operation {
	if op == nil {
		op = &xxx_GetOptionValueV5Operation{}
	}
	if o == nil {
		return op
	}
	op.OptionValue = o.OptionValue
	op.Return = o.Return
	return op
}

func (o *GetOptionValueV5Response) xxx_FromOp(ctx context.Context, op *xxx_GetOptionValueV5Operation) {
	if o == nil {
		return
	}
	o.OptionValue = op.OptionValue
	o.Return = op.Return
}
func (o *GetOptionValueV5Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetOptionValueV5Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetOptionValueV5Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumOptionValuesV5Operation structure represents the R_DhcpEnumOptionValuesV5 operation
type xxx_EnumOptionValuesV5Operation struct {
	ServerIPAddress  string                  `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Flags            uint32                  `idl:"name:Flags" json:"flags"`
	ClassName        string                  `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
	VendorName       string                  `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	ScopeInfo        *dhcpm.OptionScopeInfo  `idl:"name:ScopeInfo" json:"scope_info"`
	Resume           uint32                  `idl:"name:ResumeHandle" json:"resume"`
	PreferredMaximum uint32                  `idl:"name:PreferredMaximum" json:"preferred_maximum"`
	OptionValues     *dhcpm.OptionValueArray `idl:"name:OptionValues" json:"option_values"`
	OptionsRead      uint32                  `idl:"name:OptionsRead" json:"options_read"`
	OptionsTotal     uint32                  `idl:"name:OptionsTotal" json:"options_total"`
	Return           uint32                  `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumOptionValuesV5Operation) OpNum() int { return 22 }

func (o *xxx_EnumOptionValuesV5Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpEnumOptionValuesV5"
}

func (o *xxx_EnumOptionValuesV5Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumOptionValuesV5Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.ClassName != "" {
			_ptr_ClassName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ClassName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ClassName, _ptr_ClassName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.VendorName != "" {
			_ptr_VendorName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.VendorName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.VendorName, _ptr_VendorName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ScopeInfo {in} (1:{alias=LPDHCP_OPTION_SCOPE_INFO}*(1))(2:{alias=DHCP_OPTION_SCOPE_INFO}(struct))
	{
		if o.ScopeInfo != nil {
			if err := o.ScopeInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.OptionScopeInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Resume); err != nil {
			return err
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PreferredMaximum); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumOptionValuesV5Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_ClassName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ClassName); err != nil {
				return err
			}
			return nil
		})
		_s_ClassName := func(ptr interface{}) { o.ClassName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ClassName, _s_ClassName, _ptr_ClassName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_VendorName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.VendorName); err != nil {
				return err
			}
			return nil
		})
		_s_VendorName := func(ptr interface{}) { o.VendorName = *ptr.(*string) }
		if err := w.ReadPointer(&o.VendorName, _s_VendorName, _ptr_VendorName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ScopeInfo {in} (1:{alias=LPDHCP_OPTION_SCOPE_INFO,pointer=ref}*(1))(2:{alias=DHCP_OPTION_SCOPE_INFO}(struct))
	{
		if o.ScopeInfo == nil {
			o.ScopeInfo = &dhcpm.OptionScopeInfo{}
		}
		if err := o.ScopeInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Resume); err != nil {
			return err
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PreferredMaximum); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumOptionValuesV5Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumOptionValuesV5Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Resume); err != nil {
			return err
		}
	}
	// OptionValues {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_OPTION_VALUE_ARRAY}*(1))(3:{alias=DHCP_OPTION_VALUE_ARRAY}(struct))
	{
		if o.OptionValues != nil {
			_ptr_OptionValues := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.OptionValues != nil {
					if err := o.OptionValues.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.OptionValueArray{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.OptionValues, _ptr_OptionValues); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// OptionsRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OptionsRead); err != nil {
			return err
		}
	}
	// OptionsTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OptionsTotal); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumOptionValuesV5Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Resume); err != nil {
			return err
		}
	}
	// OptionValues {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_OPTION_VALUE_ARRAY,pointer=ref}*(1))(3:{alias=DHCP_OPTION_VALUE_ARRAY}(struct))
	{
		_ptr_OptionValues := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.OptionValues == nil {
				o.OptionValues = &dhcpm.OptionValueArray{}
			}
			if err := o.OptionValues.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_OptionValues := func(ptr interface{}) { o.OptionValues = *ptr.(**dhcpm.OptionValueArray) }
		if err := w.ReadPointer(&o.OptionValues, _s_OptionValues, _ptr_OptionValues); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// OptionsRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OptionsRead); err != nil {
			return err
		}
	}
	// OptionsTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OptionsTotal); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumOptionValuesV5Request structure represents the R_DhcpEnumOptionValuesV5 operation request
type EnumOptionValuesV5Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// Flags: This is of type DWORD that specifies that the option values are enumerated
	// for a specific or default vendor class.
	//
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                        |                                                                                  |
	//	|                 VALUE                  |                                     MEANING                                      |
	//	|                                        |                                                                                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_DEFAULT 0x00000000   | Option values are enumerated for a default vendor class.                         |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_IS_VENDOR 0x00000003 | If a bitwise AND operation with this bitmask yields a nonzero value, it          |
	//	|                                        | indicates that the option values are enumerated for a specific vendor class.     |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	Flags uint32 `idl:"name:Flags" json:"flags"`
	// ClassName: A pointer to a null-terminated Unicode string that contains the name of
	// the user class to which the option values are enumerated. This parameter is optional.
	ClassName string `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
	// VendorName: A pointer to a null-terminated Unicode string that contains the name
	// of the vendor class to which the option values are enumerated. This parameter is
	// optional. If the vendor class is not specified, the option values are enumerated
	// for a default vendor class.
	VendorName string `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	// ScopeInfo: This is a pointer to a DHCP_OPTION_SCOPE_INFO (section 2.2.1.2.41) structure
	// that contains information describing the DHCPv4 scope the option value is enumerated
	// on. This value defines the option values that are being retrieved from the default,
	// server, multicast scope, scope, or IPv4 reservation level.
	ScopeInfo *dhcpm.OptionScopeInfo `idl:"name:ScopeInfo" json:"scope_info"`
	// ResumeHandle: This is a pointer of type DHCP_RESUME_HANDLE (section 2.2.1.2.6) that
	// identifies the enumeration operation. Initially, this value MUST be set to zero,
	// with a successful call returning the handle value used for subsequent enumeration
	// requests. For example, if PreferredMaximum is set to 1,000 bytes, and 2,000 bytes'
	// worth of option values are stored on the DHCPv4 server, the resume handle can be
	// used after the first 1,000 bytes are retrieved to obtain the next 1,000 on a subsequent
	// call, and so forth.
	Resume uint32 `idl:"name:ResumeHandle" json:"resume"`
	// PreferredMaximum: This is of type DWORD, specifying the preferred maximum number
	// of bytes to return. If the number of remaining unenumerated option values (in bytes)
	// is less than this value, all option values are returned. To retrieve all the option
	// values defined for a specific vendor and user class for a specific scope, 0xFFFFFFFF
	// is specified.
	PreferredMaximum uint32 `idl:"name:PreferredMaximum" json:"preferred_maximum"`
}

func (o *EnumOptionValuesV5Request) xxx_ToOp(ctx context.Context, op *xxx_EnumOptionValuesV5Operation) *xxx_EnumOptionValuesV5Operation {
	if op == nil {
		op = &xxx_EnumOptionValuesV5Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Flags = o.Flags
	op.ClassName = o.ClassName
	op.VendorName = o.VendorName
	op.ScopeInfo = o.ScopeInfo
	op.Resume = o.Resume
	op.PreferredMaximum = o.PreferredMaximum
	return op
}

func (o *EnumOptionValuesV5Request) xxx_FromOp(ctx context.Context, op *xxx_EnumOptionValuesV5Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Flags = op.Flags
	o.ClassName = op.ClassName
	o.VendorName = op.VendorName
	o.ScopeInfo = op.ScopeInfo
	o.Resume = op.Resume
	o.PreferredMaximum = op.PreferredMaximum
}
func (o *EnumOptionValuesV5Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumOptionValuesV5Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumOptionValuesV5Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumOptionValuesV5Response structure represents the R_DhcpEnumOptionValuesV5 operation response
type EnumOptionValuesV5Response struct {
	// ResumeHandle: This is a pointer of type DHCP_RESUME_HANDLE (section 2.2.1.2.6) that
	// identifies the enumeration operation. Initially, this value MUST be set to zero,
	// with a successful call returning the handle value used for subsequent enumeration
	// requests. For example, if PreferredMaximum is set to 1,000 bytes, and 2,000 bytes'
	// worth of option values are stored on the DHCPv4 server, the resume handle can be
	// used after the first 1,000 bytes are retrieved to obtain the next 1,000 on a subsequent
	// call, and so forth.
	Resume uint32 `idl:"name:ResumeHandle" json:"resume"`
	// OptionValues: This is a pointer of type LPDHCP_OPTION_VALUE_ARRAY (section 2.2.1.2.43)
	// in which all the options values for a specific user and vendor class are enumerated
	// at a specific DHCPv4 scope corresponding to ScopeInfo.
	OptionValues *dhcpm.OptionValueArray `idl:"name:OptionValues" json:"option_values"`
	// OptionsRead: This is a pointer to a DWORD value that specifies the number of option
	// values read in OptionValues. The caller must allocate memory for this parameter equal
	// to the size of data type DWORD.
	OptionsRead uint32 `idl:"name:OptionsRead" json:"options_read"`
	// OptionsTotal: This is a pointer to a DWORD value that specifies the number of option
	// values that have not been read yet. The caller must allocate memory for this parameter
	// equal to the size of data type DWORD.
	OptionsTotal uint32 `idl:"name:OptionsTotal" json:"options_total"`
	// Return: The R_DhcpEnumOptionValuesV5 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumOptionValuesV5Response) xxx_ToOp(ctx context.Context, op *xxx_EnumOptionValuesV5Operation) *xxx_EnumOptionValuesV5Operation {
	if op == nil {
		op = &xxx_EnumOptionValuesV5Operation{}
	}
	if o == nil {
		return op
	}
	op.Resume = o.Resume
	op.OptionValues = o.OptionValues
	op.OptionsRead = o.OptionsRead
	op.OptionsTotal = o.OptionsTotal
	op.Return = o.Return
	return op
}

func (o *EnumOptionValuesV5Response) xxx_FromOp(ctx context.Context, op *xxx_EnumOptionValuesV5Operation) {
	if o == nil {
		return
	}
	o.Resume = op.Resume
	o.OptionValues = op.OptionValues
	o.OptionsRead = op.OptionsRead
	o.OptionsTotal = op.OptionsTotal
	o.Return = op.Return
}
func (o *EnumOptionValuesV5Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumOptionValuesV5Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumOptionValuesV5Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_RemoveOptionValueV5Operation structure represents the R_DhcpRemoveOptionValueV5 operation
type xxx_RemoveOptionValueV5Operation struct {
	ServerIPAddress string                 `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Flags           uint32                 `idl:"name:Flags" json:"flags"`
	OptionID        uint32                 `idl:"name:OptionID" json:"option_id"`
	ClassName       string                 `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
	VendorName      string                 `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	ScopeInfo       *dhcpm.OptionScopeInfo `idl:"name:ScopeInfo" json:"scope_info"`
	Return          uint32                 `idl:"name:Return" json:"return"`
}

func (o *xxx_RemoveOptionValueV5Operation) OpNum() int { return 23 }

func (o *xxx_RemoveOptionValueV5Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpRemoveOptionValueV5"
}

func (o *xxx_RemoveOptionValueV5Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveOptionValueV5Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	// OptionID {in} (1:{alias=DHCP_OPTION_ID, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.OptionID); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.ClassName != "" {
			_ptr_ClassName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ClassName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ClassName, _ptr_ClassName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.VendorName != "" {
			_ptr_VendorName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.VendorName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.VendorName, _ptr_VendorName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ScopeInfo {in} (1:{alias=LPDHCP_OPTION_SCOPE_INFO}*(1))(2:{alias=DHCP_OPTION_SCOPE_INFO}(struct))
	{
		if o.ScopeInfo != nil {
			if err := o.ScopeInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.OptionScopeInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveOptionValueV5Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	// OptionID {in} (1:{alias=DHCP_OPTION_ID, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OptionID); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_ClassName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ClassName); err != nil {
				return err
			}
			return nil
		})
		_s_ClassName := func(ptr interface{}) { o.ClassName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ClassName, _s_ClassName, _ptr_ClassName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_VendorName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.VendorName); err != nil {
				return err
			}
			return nil
		})
		_s_VendorName := func(ptr interface{}) { o.VendorName = *ptr.(*string) }
		if err := w.ReadPointer(&o.VendorName, _s_VendorName, _ptr_VendorName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ScopeInfo {in} (1:{alias=LPDHCP_OPTION_SCOPE_INFO,pointer=ref}*(1))(2:{alias=DHCP_OPTION_SCOPE_INFO}(struct))
	{
		if o.ScopeInfo == nil {
			o.ScopeInfo = &dhcpm.OptionScopeInfo{}
		}
		if err := o.ScopeInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveOptionValueV5Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveOptionValueV5Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveOptionValueV5Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// RemoveOptionValueV5Request structure represents the R_DhcpRemoveOptionValueV5 operation request
type RemoveOptionValueV5Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// Flags: This is of type DWORD, specifying that the option values are removed for a
	// specific or default vendor class.
	//
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                        |                                                                                  |
	//	|                 VALUE                  |                                     MEANING                                      |
	//	|                                        |                                                                                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_DEFAULT 0x00000000   | Option value is removed for a default vendor class.                              |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_IS_VENDOR 0x00000003 | If a bitwise AND operation with this bitmask yields a nonzero value, it          |
	//	|                                        | indicates that the option value is removed for a specific vendor class.          |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	Flags uint32 `idl:"name:Flags" json:"flags"`
	// OptionID: This is of type DHCP_OPTION_ID (section 2.2.1.2.3), containing the option
	// identifier for the option being removed.
	OptionID uint32 `idl:"name:OptionID" json:"option_id"`
	// ClassName: A pointer to a null-terminated Unicode string that contains the name of
	// the user class from which the option value is being removed. This parameter is optional.
	// If ClassName is not specified, implementations MUST retrieve the option value for
	// the default user class.
	ClassName string `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
	// VendorName: A pointer to a null-terminated Unicode string that contains the name
	// of the vendor class to which the option value is being removed. This parameter is
	// optional, and if a vendor class is not specified, the option value is removed for
	// the default vendor class.
	VendorName string `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	// ScopeInfo: This is a pointer to a DHCP_OPTION_SCOPE_INFO (section 2.2.1.2.41) structure
	// that contains information describing the DHCPv4 scope this option value is removed
	// on. This value defines that option as being removed from the server, multicast scope,
	// or scope level or from an IPv4 reservation.
	ScopeInfo *dhcpm.OptionScopeInfo `idl:"name:ScopeInfo" json:"scope_info"`
}

func (o *RemoveOptionValueV5Request) xxx_ToOp(ctx context.Context, op *xxx_RemoveOptionValueV5Operation) *xxx_RemoveOptionValueV5Operation {
	if op == nil {
		op = &xxx_RemoveOptionValueV5Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Flags = o.Flags
	op.OptionID = o.OptionID
	op.ClassName = o.ClassName
	op.VendorName = o.VendorName
	op.ScopeInfo = o.ScopeInfo
	return op
}

func (o *RemoveOptionValueV5Request) xxx_FromOp(ctx context.Context, op *xxx_RemoveOptionValueV5Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Flags = op.Flags
	o.OptionID = op.OptionID
	o.ClassName = op.ClassName
	o.VendorName = op.VendorName
	o.ScopeInfo = op.ScopeInfo
}
func (o *RemoveOptionValueV5Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *RemoveOptionValueV5Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemoveOptionValueV5Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// RemoveOptionValueV5Response structure represents the R_DhcpRemoveOptionValueV5 operation response
type RemoveOptionValueV5Response struct {
	// Return: The R_DhcpRemoveOptionValueV5 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *RemoveOptionValueV5Response) xxx_ToOp(ctx context.Context, op *xxx_RemoveOptionValueV5Operation) *xxx_RemoveOptionValueV5Operation {
	if op == nil {
		op = &xxx_RemoveOptionValueV5Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *RemoveOptionValueV5Response) xxx_FromOp(ctx context.Context, op *xxx_RemoveOptionValueV5Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *RemoveOptionValueV5Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *RemoveOptionValueV5Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemoveOptionValueV5Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CreateClassOperation structure represents the R_DhcpCreateClass operation
type xxx_CreateClassOperation struct {
	ServerIPAddress string           `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	_               uint32           `idl:"name:ReservedMustBeZero"`
	ClassInfo       *dhcpm.ClassInfo `idl:"name:ClassInfo" json:"class_info"`
	Return          uint32           `idl:"name:Return" json:"return"`
}

func (o *xxx_CreateClassOperation) OpNum() int { return 24 }

func (o *xxx_CreateClassOperation) OpName() string { return "/dhcpsrv2/v1/R_DhcpCreateClass" }

func (o *xxx_CreateClassOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateClassOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ReservedMustBeZero {in} (1:{alias=DWORD}(uint32))
	{
		// reserved ReservedMustBeZero
		if err := w.WriteData(uint32(0)); err != nil {
			return err
		}
	}
	// ClassInfo {in} (1:{alias=LPDHCP_CLASS_INFO}*(1))(2:{alias=DHCP_CLASS_INFO}(struct))
	{
		if o.ClassInfo != nil {
			if err := o.ClassInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.ClassInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateClassOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ReservedMustBeZero {in} (1:{alias=DWORD}(uint32))
	{
		// reserved ReservedMustBeZero
		var _ReservedMustBeZero uint32
		if err := w.ReadData(&_ReservedMustBeZero); err != nil {
			return err
		}
	}
	// ClassInfo {in} (1:{alias=LPDHCP_CLASS_INFO,pointer=ref}*(1))(2:{alias=DHCP_CLASS_INFO}(struct))
	{
		if o.ClassInfo == nil {
			o.ClassInfo = &dhcpm.ClassInfo{}
		}
		if err := o.ClassInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateClassOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateClassOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateClassOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CreateClassRequest structure represents the R_DhcpCreateClass operation request
type CreateClassRequest struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// ClassInfo: This is of type DHCP_CLASS_INFO (section 2.2.1.2.75) structure, containing
	// the information about the class.
	ClassInfo *dhcpm.ClassInfo `idl:"name:ClassInfo" json:"class_info"`
}

func (o *CreateClassRequest) xxx_ToOp(ctx context.Context, op *xxx_CreateClassOperation) *xxx_CreateClassOperation {
	if op == nil {
		op = &xxx_CreateClassOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.ClassInfo = o.ClassInfo
	return op
}

func (o *CreateClassRequest) xxx_FromOp(ctx context.Context, op *xxx_CreateClassOperation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.ClassInfo = op.ClassInfo
}
func (o *CreateClassRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *CreateClassRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateClassOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CreateClassResponse structure represents the R_DhcpCreateClass operation response
type CreateClassResponse struct {
	// Return: The R_DhcpCreateClass return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CreateClassResponse) xxx_ToOp(ctx context.Context, op *xxx_CreateClassOperation) *xxx_CreateClassOperation {
	if op == nil {
		op = &xxx_CreateClassOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *CreateClassResponse) xxx_FromOp(ctx context.Context, op *xxx_CreateClassOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *CreateClassResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *CreateClassResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateClassOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ModifyClassOperation structure represents the R_DhcpModifyClass operation
type xxx_ModifyClassOperation struct {
	ServerIPAddress string           `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	_               uint32           `idl:"name:ReservedMustBeZero"`
	ClassInfo       *dhcpm.ClassInfo `idl:"name:ClassInfo" json:"class_info"`
	Return          uint32           `idl:"name:Return" json:"return"`
}

func (o *xxx_ModifyClassOperation) OpNum() int { return 25 }

func (o *xxx_ModifyClassOperation) OpName() string { return "/dhcpsrv2/v1/R_DhcpModifyClass" }

func (o *xxx_ModifyClassOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ModifyClassOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ReservedMustBeZero {in} (1:{alias=DWORD}(uint32))
	{
		// reserved ReservedMustBeZero
		if err := w.WriteData(uint32(0)); err != nil {
			return err
		}
	}
	// ClassInfo {in} (1:{alias=LPDHCP_CLASS_INFO}*(1))(2:{alias=DHCP_CLASS_INFO}(struct))
	{
		if o.ClassInfo != nil {
			if err := o.ClassInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.ClassInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ModifyClassOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ReservedMustBeZero {in} (1:{alias=DWORD}(uint32))
	{
		// reserved ReservedMustBeZero
		var _ReservedMustBeZero uint32
		if err := w.ReadData(&_ReservedMustBeZero); err != nil {
			return err
		}
	}
	// ClassInfo {in} (1:{alias=LPDHCP_CLASS_INFO,pointer=ref}*(1))(2:{alias=DHCP_CLASS_INFO}(struct))
	{
		if o.ClassInfo == nil {
			o.ClassInfo = &dhcpm.ClassInfo{}
		}
		if err := o.ClassInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ModifyClassOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ModifyClassOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ModifyClassOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ModifyClassRequest structure represents the R_DhcpModifyClass operation request
type ModifyClassRequest struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// ClassInfo: This is of type LPDHCP_CLASS_INFO (section 2.2.1.2.75) structure, containing
	// the information about the class.
	ClassInfo *dhcpm.ClassInfo `idl:"name:ClassInfo" json:"class_info"`
}

func (o *ModifyClassRequest) xxx_ToOp(ctx context.Context, op *xxx_ModifyClassOperation) *xxx_ModifyClassOperation {
	if op == nil {
		op = &xxx_ModifyClassOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.ClassInfo = o.ClassInfo
	return op
}

func (o *ModifyClassRequest) xxx_FromOp(ctx context.Context, op *xxx_ModifyClassOperation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.ClassInfo = op.ClassInfo
}
func (o *ModifyClassRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *ModifyClassRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ModifyClassOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ModifyClassResponse structure represents the R_DhcpModifyClass operation response
type ModifyClassResponse struct {
	// Return: The R_DhcpModifyClass return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ModifyClassResponse) xxx_ToOp(ctx context.Context, op *xxx_ModifyClassOperation) *xxx_ModifyClassOperation {
	if op == nil {
		op = &xxx_ModifyClassOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *ModifyClassResponse) xxx_FromOp(ctx context.Context, op *xxx_ModifyClassOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *ModifyClassResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *ModifyClassResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ModifyClassOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_DeleteClassOperation structure represents the R_DhcpDeleteClass operation
type xxx_DeleteClassOperation struct {
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	_               uint32 `idl:"name:ReservedMustBeZero"`
	ClassName       string `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
	Return          uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_DeleteClassOperation) OpNum() int { return 26 }

func (o *xxx_DeleteClassOperation) OpName() string { return "/dhcpsrv2/v1/R_DhcpDeleteClass" }

func (o *xxx_DeleteClassOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteClassOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ReservedMustBeZero {in} (1:{alias=DWORD}(uint32))
	{
		// reserved ReservedMustBeZero
		if err := w.WriteData(uint32(0)); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.ClassName != "" {
			_ptr_ClassName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ClassName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ClassName, _ptr_ClassName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteClassOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ReservedMustBeZero {in} (1:{alias=DWORD}(uint32))
	{
		// reserved ReservedMustBeZero
		var _ReservedMustBeZero uint32
		if err := w.ReadData(&_ReservedMustBeZero); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_ClassName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ClassName); err != nil {
				return err
			}
			return nil
		})
		_s_ClassName := func(ptr interface{}) { o.ClassName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ClassName, _s_ClassName, _ptr_ClassName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteClassOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteClassOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteClassOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// DeleteClassRequest structure represents the R_DhcpDeleteClass operation request
type DeleteClassRequest struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// ClassName: This is a pointer to WCHAR that contains the name of the class that needs
	// to be deleted.
	ClassName string `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
}

func (o *DeleteClassRequest) xxx_ToOp(ctx context.Context, op *xxx_DeleteClassOperation) *xxx_DeleteClassOperation {
	if op == nil {
		op = &xxx_DeleteClassOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.ClassName = o.ClassName
	return op
}

func (o *DeleteClassRequest) xxx_FromOp(ctx context.Context, op *xxx_DeleteClassOperation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.ClassName = op.ClassName
}
func (o *DeleteClassRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *DeleteClassRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteClassOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// DeleteClassResponse structure represents the R_DhcpDeleteClass operation response
type DeleteClassResponse struct {
	// Return: The R_DhcpDeleteClass return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *DeleteClassResponse) xxx_ToOp(ctx context.Context, op *xxx_DeleteClassOperation) *xxx_DeleteClassOperation {
	if op == nil {
		op = &xxx_DeleteClassOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *DeleteClassResponse) xxx_FromOp(ctx context.Context, op *xxx_DeleteClassOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *DeleteClassResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *DeleteClassResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteClassOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetClassInfoOperation structure represents the R_DhcpGetClassInfo operation
type xxx_GetClassInfoOperation struct {
	ServerIPAddress  string           `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	_                uint32           `idl:"name:ReservedMustBeZero"`
	PartialClassInfo *dhcpm.ClassInfo `idl:"name:PartialClassInfo" json:"partial_class_info"`
	FilledClassInfo  *dhcpm.ClassInfo `idl:"name:FilledClassInfo" json:"filled_class_info"`
	Return           uint32           `idl:"name:Return" json:"return"`
}

func (o *xxx_GetClassInfoOperation) OpNum() int { return 27 }

func (o *xxx_GetClassInfoOperation) OpName() string { return "/dhcpsrv2/v1/R_DhcpGetClassInfo" }

func (o *xxx_GetClassInfoOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetClassInfoOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ReservedMustBeZero {in} (1:{alias=DWORD}(uint32))
	{
		// reserved ReservedMustBeZero
		if err := w.WriteData(uint32(0)); err != nil {
			return err
		}
	}
	// PartialClassInfo {in} (1:{alias=LPDHCP_CLASS_INFO}*(1))(2:{alias=DHCP_CLASS_INFO}(struct))
	{
		if o.PartialClassInfo != nil {
			if err := o.PartialClassInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.ClassInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetClassInfoOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ReservedMustBeZero {in} (1:{alias=DWORD}(uint32))
	{
		// reserved ReservedMustBeZero
		var _ReservedMustBeZero uint32
		if err := w.ReadData(&_ReservedMustBeZero); err != nil {
			return err
		}
	}
	// PartialClassInfo {in} (1:{alias=LPDHCP_CLASS_INFO,pointer=ref}*(1))(2:{alias=DHCP_CLASS_INFO}(struct))
	{
		if o.PartialClassInfo == nil {
			o.PartialClassInfo = &dhcpm.ClassInfo{}
		}
		if err := o.PartialClassInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetClassInfoOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetClassInfoOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// FilledClassInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_CLASS_INFO}*(1))(3:{alias=DHCP_CLASS_INFO}(struct))
	{
		if o.FilledClassInfo != nil {
			_ptr_FilledClassInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.FilledClassInfo != nil {
					if err := o.FilledClassInfo.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.ClassInfo{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.FilledClassInfo, _ptr_FilledClassInfo); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetClassInfoOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// FilledClassInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_CLASS_INFO,pointer=ref}*(1))(3:{alias=DHCP_CLASS_INFO}(struct))
	{
		_ptr_FilledClassInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.FilledClassInfo == nil {
				o.FilledClassInfo = &dhcpm.ClassInfo{}
			}
			if err := o.FilledClassInfo.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_FilledClassInfo := func(ptr interface{}) { o.FilledClassInfo = *ptr.(**dhcpm.ClassInfo) }
		if err := w.ReadPointer(&o.FilledClassInfo, _s_FilledClassInfo, _ptr_FilledClassInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetClassInfoRequest structure represents the R_DhcpGetClassInfo operation request
type GetClassInfoRequest struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// PartialClassInfo: This is of type LPDHCP_CLASS_INFO (section 2.2.1.2.75), containing
	// the partial information of the class for which full information is retrieved in FilledClassInfo.
	// The mandatory fields in this structure are ClassName, ClassData, and ClassDataLength.
	PartialClassInfo *dhcpm.ClassInfo `idl:"name:PartialClassInfo" json:"partial_class_info"`
}

func (o *GetClassInfoRequest) xxx_ToOp(ctx context.Context, op *xxx_GetClassInfoOperation) *xxx_GetClassInfoOperation {
	if op == nil {
		op = &xxx_GetClassInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.PartialClassInfo = o.PartialClassInfo
	return op
}

func (o *GetClassInfoRequest) xxx_FromOp(ctx context.Context, op *xxx_GetClassInfoOperation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.PartialClassInfo = op.PartialClassInfo
}
func (o *GetClassInfoRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetClassInfoRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetClassInfoOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetClassInfoResponse structure represents the R_DhcpGetClassInfo operation response
type GetClassInfoResponse struct {
	// FilledClassInfo: This is a pointer to type LPDHCP_CLASS_INFO (section 2.2.1.2.75)
	// in which the complete information of a class is retrieved based on the PartialClassInfo.
	FilledClassInfo *dhcpm.ClassInfo `idl:"name:FilledClassInfo" json:"filled_class_info"`
	// Return: The R_DhcpGetClassInfo return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetClassInfoResponse) xxx_ToOp(ctx context.Context, op *xxx_GetClassInfoOperation) *xxx_GetClassInfoOperation {
	if op == nil {
		op = &xxx_GetClassInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.FilledClassInfo = o.FilledClassInfo
	op.Return = o.Return
	return op
}

func (o *GetClassInfoResponse) xxx_FromOp(ctx context.Context, op *xxx_GetClassInfoOperation) {
	if o == nil {
		return
	}
	o.FilledClassInfo = op.FilledClassInfo
	o.Return = op.Return
}
func (o *GetClassInfoResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetClassInfoResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetClassInfoOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumClassesOperation structure represents the R_DhcpEnumClasses operation
type xxx_EnumClassesOperation struct {
	ServerIPAddress  string                `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	_                uint32                `idl:"name:ReservedMustBeZero"`
	Resume           uint32                `idl:"name:ResumeHandle" json:"resume"`
	PreferredMaximum uint32                `idl:"name:PreferredMaximum" json:"preferred_maximum"`
	ClassInfoArray   *dhcpm.ClassInfoArray `idl:"name:ClassInfoArray" json:"class_info_array"`
	Read             uint32                `idl:"name:nRead" json:"read"`
	Total            uint32                `idl:"name:nTotal" json:"total"`
	Return           uint32                `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumClassesOperation) OpNum() int { return 28 }

func (o *xxx_EnumClassesOperation) OpName() string { return "/dhcpsrv2/v1/R_DhcpEnumClasses" }

func (o *xxx_EnumClassesOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumClassesOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ReservedMustBeZero {in} (1:{alias=DWORD}(uint32))
	{
		// reserved ReservedMustBeZero
		if err := w.WriteData(uint32(0)); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Resume); err != nil {
			return err
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PreferredMaximum); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumClassesOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ReservedMustBeZero {in} (1:{alias=DWORD}(uint32))
	{
		// reserved ReservedMustBeZero
		var _ReservedMustBeZero uint32
		if err := w.ReadData(&_ReservedMustBeZero); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Resume); err != nil {
			return err
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PreferredMaximum); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumClassesOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumClassesOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Resume); err != nil {
			return err
		}
	}
	// ClassInfoArray {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_CLASS_INFO_ARRAY}*(1))(3:{alias=DHCP_CLASS_INFO_ARRAY}(struct))
	{
		if o.ClassInfoArray != nil {
			_ptr_ClassInfoArray := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.ClassInfoArray != nil {
					if err := o.ClassInfoArray.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.ClassInfoArray{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ClassInfoArray, _ptr_ClassInfoArray); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// nRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Read); err != nil {
			return err
		}
	}
	// nTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Total); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumClassesOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Resume); err != nil {
			return err
		}
	}
	// ClassInfoArray {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_CLASS_INFO_ARRAY,pointer=ref}*(1))(3:{alias=DHCP_CLASS_INFO_ARRAY}(struct))
	{
		_ptr_ClassInfoArray := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.ClassInfoArray == nil {
				o.ClassInfoArray = &dhcpm.ClassInfoArray{}
			}
			if err := o.ClassInfoArray.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ClassInfoArray := func(ptr interface{}) { o.ClassInfoArray = *ptr.(**dhcpm.ClassInfoArray) }
		if err := w.ReadPointer(&o.ClassInfoArray, _s_ClassInfoArray, _ptr_ClassInfoArray); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// nRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Read); err != nil {
			return err
		}
	}
	// nTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Total); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumClassesRequest structure represents the R_DhcpEnumClasses operation request
type EnumClassesRequest struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// ResumeHandle: This is a pointer of type DHCP_RESUME_HANDLE (section 2.2.1.2.6) that
	// identifies the enumeration operation. Initially, this value MUST be set to zero,
	// with a successful call returning the handle value used for subsequent enumeration
	// requests. For example, if PreferredMaximum is set to 100, and 200 classes are stored
	// on the DHCP server, the resume handle can be used after the first 100 classes are
	// retrieved to obtain the next 100 on a subsequent call, and so forth.
	Resume uint32 `idl:"name:ResumeHandle" json:"resume"`
	// PreferredMaximum: This is of type DWORD, specifying the preferred maximum number
	// of bytes to be returned. If the number of bytes required in memory for the remaining
	// unenumerated classes is less than the PreferredMaximum value, then all the classes
	// for the DHCP server are returned. To retrieve all the classes defined on the DHCP
	// server, 0xFFFFFFFF is specified.
	PreferredMaximum uint32 `idl:"name:PreferredMaximum" json:"preferred_maximum"`
}

func (o *EnumClassesRequest) xxx_ToOp(ctx context.Context, op *xxx_EnumClassesOperation) *xxx_EnumClassesOperation {
	if op == nil {
		op = &xxx_EnumClassesOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Resume = o.Resume
	op.PreferredMaximum = o.PreferredMaximum
	return op
}

func (o *EnumClassesRequest) xxx_FromOp(ctx context.Context, op *xxx_EnumClassesOperation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Resume = op.Resume
	o.PreferredMaximum = op.PreferredMaximum
}
func (o *EnumClassesRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumClassesRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumClassesOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumClassesResponse structure represents the R_DhcpEnumClasses operation response
type EnumClassesResponse struct {
	// ResumeHandle: This is a pointer of type DHCP_RESUME_HANDLE (section 2.2.1.2.6) that
	// identifies the enumeration operation. Initially, this value MUST be set to zero,
	// with a successful call returning the handle value used for subsequent enumeration
	// requests. For example, if PreferredMaximum is set to 100, and 200 classes are stored
	// on the DHCP server, the resume handle can be used after the first 100 classes are
	// retrieved to obtain the next 100 on a subsequent call, and so forth.
	Resume uint32 `idl:"name:ResumeHandle" json:"resume"`
	// ClassInfoArray: This is a pointer of type LPDHCP_CLASS_INFO_ARRAY in which information
	// of all the classes defined on the DHCP server is retrieved.
	ClassInfoArray *dhcpm.ClassInfoArray `idl:"name:ClassInfoArray" json:"class_info_array"`
	// nRead: This is a pointer to a DWORD value that specifies the number of classes returned
	// in ClassInfoArray. The caller MUST allocate memory for this parameter equal to the
	// size of data type DWORD.
	Read uint32 `idl:"name:nRead" json:"read"`
	// nTotal: This is a pointer to a DWORD value that specifies the number of classes defined
	// on the DHCP server that have not yet been enumerated. The caller MUST allocate memory
	// for this parameter equal to the size of data type DWORD.
	Total uint32 `idl:"name:nTotal" json:"total"`
	// Return: The R_DhcpEnumClasses return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumClassesResponse) xxx_ToOp(ctx context.Context, op *xxx_EnumClassesOperation) *xxx_EnumClassesOperation {
	if op == nil {
		op = &xxx_EnumClassesOperation{}
	}
	if o == nil {
		return op
	}
	op.Resume = o.Resume
	op.ClassInfoArray = o.ClassInfoArray
	op.Read = o.Read
	op.Total = o.Total
	op.Return = o.Return
	return op
}

func (o *EnumClassesResponse) xxx_FromOp(ctx context.Context, op *xxx_EnumClassesOperation) {
	if o == nil {
		return
	}
	o.Resume = op.Resume
	o.ClassInfoArray = op.ClassInfoArray
	o.Read = op.Read
	o.Total = op.Total
	o.Return = op.Return
}
func (o *EnumClassesResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumClassesResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumClassesOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetAllOptionsOperation structure represents the R_DhcpGetAllOptions operation
type xxx_GetAllOptionsOperation struct {
	ServerIPAddress string            `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Flags           uint32            `idl:"name:Flags" json:"flags"`
	Option          *dhcpm.AllOptions `idl:"name:OptionStruct" json:"option"`
	Return          uint32            `idl:"name:Return" json:"return"`
}

func (o *xxx_GetAllOptionsOperation) OpNum() int { return 29 }

func (o *xxx_GetAllOptionsOperation) OpName() string { return "/dhcpsrv2/v1/R_DhcpGetAllOptions" }

func (o *xxx_GetAllOptionsOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetAllOptionsOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetAllOptionsOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetAllOptionsOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetAllOptionsOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// OptionStruct {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_ALL_OPTIONS}*(1))(3:{alias=DHCP_ALL_OPTIONS}(struct))
	{
		if o.Option != nil {
			_ptr_OptionStruct := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Option != nil {
					if err := o.Option.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.AllOptions{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Option, _ptr_OptionStruct); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetAllOptionsOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// OptionStruct {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_ALL_OPTIONS,pointer=ref}*(1))(3:{alias=DHCP_ALL_OPTIONS}(struct))
	{
		_ptr_OptionStruct := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Option == nil {
				o.Option = &dhcpm.AllOptions{}
			}
			if err := o.Option.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_OptionStruct := func(ptr interface{}) { o.Option = *ptr.(**dhcpm.AllOptions) }
		if err := w.ReadPointer(&o.Option, _s_OptionStruct, _ptr_OptionStruct); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetAllOptionsRequest structure represents the R_DhcpGetAllOptions operation request
type GetAllOptionsRequest struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// Flags: This field MUST be set to zero.
	Flags uint32 `idl:"name:Flags" json:"flags"`
}

func (o *GetAllOptionsRequest) xxx_ToOp(ctx context.Context, op *xxx_GetAllOptionsOperation) *xxx_GetAllOptionsOperation {
	if op == nil {
		op = &xxx_GetAllOptionsOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Flags = o.Flags
	return op
}

func (o *GetAllOptionsRequest) xxx_FromOp(ctx context.Context, op *xxx_GetAllOptionsOperation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Flags = op.Flags
}
func (o *GetAllOptionsRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetAllOptionsRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetAllOptionsOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetAllOptionsResponse structure represents the R_DhcpGetAllOptions operation response
type GetAllOptionsResponse struct {
	// OptionStruct: This is a pointer of type LPDHCP_ALL_OPTIONS (section 2.2.1.2.27) that
	// points to a location that contains all the option definitions defined for a vendor
	// class or default class.
	Option *dhcpm.AllOptions `idl:"name:OptionStruct" json:"option"`
	// Return: The R_DhcpGetAllOptions return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetAllOptionsResponse) xxx_ToOp(ctx context.Context, op *xxx_GetAllOptionsOperation) *xxx_GetAllOptionsOperation {
	if op == nil {
		op = &xxx_GetAllOptionsOperation{}
	}
	if o == nil {
		return op
	}
	op.Option = o.Option
	op.Return = o.Return
	return op
}

func (o *GetAllOptionsResponse) xxx_FromOp(ctx context.Context, op *xxx_GetAllOptionsOperation) {
	if o == nil {
		return
	}
	o.Option = op.Option
	o.Return = op.Return
}
func (o *GetAllOptionsResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetAllOptionsResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetAllOptionsOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetAllOptionValuesOperation structure represents the R_DhcpGetAllOptionValues operation
type xxx_GetAllOptionValuesOperation struct {
	ServerIPAddress string                 `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Flags           uint32                 `idl:"name:Flags" json:"flags"`
	ScopeInfo       *dhcpm.OptionScopeInfo `idl:"name:ScopeInfo" json:"scope_info"`
	Values          *dhcpm.AllOptionValues `idl:"name:Values" json:"values"`
	Return          uint32                 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetAllOptionValuesOperation) OpNum() int { return 30 }

func (o *xxx_GetAllOptionValuesOperation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpGetAllOptionValues"
}

func (o *xxx_GetAllOptionValuesOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetAllOptionValuesOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	// ScopeInfo {in} (1:{alias=LPDHCP_OPTION_SCOPE_INFO}*(1))(2:{alias=DHCP_OPTION_SCOPE_INFO}(struct))
	{
		if o.ScopeInfo != nil {
			if err := o.ScopeInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.OptionScopeInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetAllOptionValuesOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	// ScopeInfo {in} (1:{alias=LPDHCP_OPTION_SCOPE_INFO,pointer=ref}*(1))(2:{alias=DHCP_OPTION_SCOPE_INFO}(struct))
	{
		if o.ScopeInfo == nil {
			o.ScopeInfo = &dhcpm.OptionScopeInfo{}
		}
		if err := o.ScopeInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetAllOptionValuesOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetAllOptionValuesOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Values {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_ALL_OPTION_VALUES}*(1))(3:{alias=DHCP_ALL_OPTION_VALUES}(struct))
	{
		if o.Values != nil {
			_ptr_Values := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Values != nil {
					if err := o.Values.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.AllOptionValues{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Values, _ptr_Values); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetAllOptionValuesOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Values {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_ALL_OPTION_VALUES,pointer=ref}*(1))(3:{alias=DHCP_ALL_OPTION_VALUES}(struct))
	{
		_ptr_Values := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Values == nil {
				o.Values = &dhcpm.AllOptionValues{}
			}
			if err := o.Values.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_Values := func(ptr interface{}) { o.Values = *ptr.(**dhcpm.AllOptionValues) }
		if err := w.ReadPointer(&o.Values, _s_Values, _ptr_Values); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetAllOptionValuesRequest structure represents the R_DhcpGetAllOptionValues operation request
type GetAllOptionValuesRequest struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// Flags: This is of type DWORD and is reserved for future use. Currently it is not
	// used, and any value set to this parameter will not affect the behavior of this method.
	Flags uint32 `idl:"name:Flags" json:"flags"`
	// ScopeInfo: This is a pointer to a DHCP_OPTION_SCOPE_INFO (section 2.2.1.2.41) structure
	// that contains information describing the DHCPv4 scope the option values are retrieved
	// on. This value defines that option values are being retrieved from the default, server,
	// multicast scope, or scope level, or for an IPv4 reservation.
	ScopeInfo *dhcpm.OptionScopeInfo `idl:"name:ScopeInfo" json:"scope_info"`
}

func (o *GetAllOptionValuesRequest) xxx_ToOp(ctx context.Context, op *xxx_GetAllOptionValuesOperation) *xxx_GetAllOptionValuesOperation {
	if op == nil {
		op = &xxx_GetAllOptionValuesOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Flags = o.Flags
	op.ScopeInfo = o.ScopeInfo
	return op
}

func (o *GetAllOptionValuesRequest) xxx_FromOp(ctx context.Context, op *xxx_GetAllOptionValuesOperation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Flags = op.Flags
	o.ScopeInfo = op.ScopeInfo
}
func (o *GetAllOptionValuesRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetAllOptionValuesRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetAllOptionValuesOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetAllOptionValuesResponse structure represents the R_DhcpGetAllOptionValues operation response
type GetAllOptionValuesResponse struct {
	// Values: This is a pointer to type LPDHCP_ALL_OPTION_VALUES in which a list of vendor-specific
	// option values and default option values is retrieved.
	Values *dhcpm.AllOptionValues `idl:"name:Values" json:"values"`
	// Return: The R_DhcpGetAllOptionValues return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetAllOptionValuesResponse) xxx_ToOp(ctx context.Context, op *xxx_GetAllOptionValuesOperation) *xxx_GetAllOptionValuesOperation {
	if op == nil {
		op = &xxx_GetAllOptionValuesOperation{}
	}
	if o == nil {
		return op
	}
	op.Values = o.Values
	op.Return = o.Return
	return op
}

func (o *GetAllOptionValuesResponse) xxx_FromOp(ctx context.Context, op *xxx_GetAllOptionValuesOperation) {
	if o == nil {
		return
	}
	o.Values = op.Values
	o.Return = op.Return
}
func (o *GetAllOptionValuesResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetAllOptionValuesResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetAllOptionValuesOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetMCastMIBInfoOperation structure represents the R_DhcpGetMCastMibInfo operation
type xxx_GetMCastMIBInfoOperation struct {
	ServerIPAddress string              `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	MIBInfo         *dhcpm.MCastMIBInfo `idl:"name:MibInfo" json:"mib_info"`
	Return          uint32              `idl:"name:Return" json:"return"`
}

func (o *xxx_GetMCastMIBInfoOperation) OpNum() int { return 31 }

func (o *xxx_GetMCastMIBInfoOperation) OpName() string { return "/dhcpsrv2/v1/R_DhcpGetMCastMibInfo" }

func (o *xxx_GetMCastMIBInfoOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMCastMIBInfoOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMCastMIBInfoOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMCastMIBInfoOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMCastMIBInfoOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// MibInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_MCAST_MIB_INFO}*(1))(3:{alias=DHCP_MCAST_MIB_INFO}(struct))
	{
		if o.MIBInfo != nil {
			_ptr_MibInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.MIBInfo != nil {
					if err := o.MIBInfo.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.MCastMIBInfo{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.MIBInfo, _ptr_MibInfo); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMCastMIBInfoOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// MibInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_MCAST_MIB_INFO,pointer=ref}*(1))(3:{alias=DHCP_MCAST_MIB_INFO}(struct))
	{
		_ptr_MibInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.MIBInfo == nil {
				o.MIBInfo = &dhcpm.MCastMIBInfo{}
			}
			if err := o.MIBInfo.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_MibInfo := func(ptr interface{}) { o.MIBInfo = *ptr.(**dhcpm.MCastMIBInfo) }
		if err := w.ReadPointer(&o.MIBInfo, _s_MibInfo, _ptr_MibInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetMCastMIBInfoRequest structure represents the R_DhcpGetMCastMibInfo operation request
type GetMCastMIBInfoRequest struct {
	// ServerIpAddress: The IP address/host name of the MADCAP server. This parameter is
	// unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
}

func (o *GetMCastMIBInfoRequest) xxx_ToOp(ctx context.Context, op *xxx_GetMCastMIBInfoOperation) *xxx_GetMCastMIBInfoOperation {
	if op == nil {
		op = &xxx_GetMCastMIBInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	return op
}

func (o *GetMCastMIBInfoRequest) xxx_FromOp(ctx context.Context, op *xxx_GetMCastMIBInfoOperation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
}
func (o *GetMCastMIBInfoRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetMCastMIBInfoRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetMCastMIBInfoOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetMCastMIBInfoResponse structure represents the R_DhcpGetMCastMibInfo operation response
type GetMCastMIBInfoResponse struct {
	// MibInfo: This is of type LPDHCP_MCAST_MIB_INFO, pointing to the location that contains
	// the multicast MIB information of the MADCAP server.
	MIBInfo *dhcpm.MCastMIBInfo `idl:"name:MibInfo" json:"mib_info"`
	// Return: The R_DhcpGetMCastMibInfo return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetMCastMIBInfoResponse) xxx_ToOp(ctx context.Context, op *xxx_GetMCastMIBInfoOperation) *xxx_GetMCastMIBInfoOperation {
	if op == nil {
		op = &xxx_GetMCastMIBInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.MIBInfo = o.MIBInfo
	op.Return = o.Return
	return op
}

func (o *GetMCastMIBInfoResponse) xxx_FromOp(ctx context.Context, op *xxx_GetMCastMIBInfoOperation) {
	if o == nil {
		return
	}
	o.MIBInfo = op.MIBInfo
	o.Return = op.Return
}
func (o *GetMCastMIBInfoResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetMCastMIBInfoResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetMCastMIBInfoOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AuditLogSetParamsOperation structure represents the R_DhcpAuditLogSetParams operation
type xxx_AuditLogSetParamsOperation struct {
	ServerIPAddress   string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Flags             uint32 `idl:"name:Flags" json:"flags"`
	AuditLogDir       string `idl:"name:AuditLogDir;string" json:"audit_log_dir"`
	DiskCheckInterval uint32 `idl:"name:DiskCheckInterval" json:"disk_check_interval"`
	MaxLogFilesSize   uint32 `idl:"name:MaxLogFilesSize" json:"max_log_files_size"`
	MinSpaceOnDisk    uint32 `idl:"name:MinSpaceOnDisk" json:"min_space_on_disk"`
	Return            uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_AuditLogSetParamsOperation) OpNum() int { return 32 }

func (o *xxx_AuditLogSetParamsOperation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpAuditLogSetParams"
}

func (o *xxx_AuditLogSetParamsOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AuditLogSetParamsOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	// AuditLogDir {in} (1:{string, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.AuditLogDir); err != nil {
			return err
		}
	}
	// DiskCheckInterval {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DiskCheckInterval); err != nil {
			return err
		}
	}
	// MaxLogFilesSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.MaxLogFilesSize); err != nil {
			return err
		}
	}
	// MinSpaceOnDisk {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.MinSpaceOnDisk); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AuditLogSetParamsOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	// AuditLogDir {in} (1:{string, alias=LPWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.AuditLogDir); err != nil {
			return err
		}
	}
	// DiskCheckInterval {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DiskCheckInterval); err != nil {
			return err
		}
	}
	// MaxLogFilesSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.MaxLogFilesSize); err != nil {
			return err
		}
	}
	// MinSpaceOnDisk {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.MinSpaceOnDisk); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AuditLogSetParamsOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AuditLogSetParamsOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AuditLogSetParamsOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AuditLogSetParamsRequest structure represents the R_DhcpAuditLogSetParams operation request
type AuditLogSetParamsRequest struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// Flags: This flag is not used and MUST be set to 0.
	Flags uint32 `idl:"name:Flags" json:"flags"`
	// AuditLogDir: A pointer to a null-terminated Unicode string that contains the path
	// where the audit logs are placed.
	AuditLogDir string `idl:"name:AuditLogDir;string" json:"audit_log_dir"`
	// DiskCheckInterval: This is of type DWORD and contains an interval for disk checking
	// that is used to determine how many times the DHCP server writes audit log events
	// to the log file before checking for available disk space on the DHCP server.
	DiskCheckInterval uint32 `idl:"name:DiskCheckInterval" json:"disk_check_interval"`
	// MaxLogFilesSize: This is of type DWORD and contains the maximum size restriction
	// (in megabytes) for the total amount of disk space available for all the audit log
	// files created and stored by the DHCP server.
	MaxLogFilesSize uint32 `idl:"name:MaxLogFilesSize" json:"max_log_files_size"`
	// MinSpaceOnDisk: This is of type DWORD and contains the minimum size requirement (in
	// megabytes) for server disk space that is used during disk checking to determine whether
	// sufficient space exists for the server to continue audit logging.
	MinSpaceOnDisk uint32 `idl:"name:MinSpaceOnDisk" json:"min_space_on_disk"`
}

func (o *AuditLogSetParamsRequest) xxx_ToOp(ctx context.Context, op *xxx_AuditLogSetParamsOperation) *xxx_AuditLogSetParamsOperation {
	if op == nil {
		op = &xxx_AuditLogSetParamsOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Flags = o.Flags
	op.AuditLogDir = o.AuditLogDir
	op.DiskCheckInterval = o.DiskCheckInterval
	op.MaxLogFilesSize = o.MaxLogFilesSize
	op.MinSpaceOnDisk = o.MinSpaceOnDisk
	return op
}

func (o *AuditLogSetParamsRequest) xxx_FromOp(ctx context.Context, op *xxx_AuditLogSetParamsOperation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Flags = op.Flags
	o.AuditLogDir = op.AuditLogDir
	o.DiskCheckInterval = op.DiskCheckInterval
	o.MaxLogFilesSize = op.MaxLogFilesSize
	o.MinSpaceOnDisk = op.MinSpaceOnDisk
}
func (o *AuditLogSetParamsRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *AuditLogSetParamsRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AuditLogSetParamsOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AuditLogSetParamsResponse structure represents the R_DhcpAuditLogSetParams operation response
type AuditLogSetParamsResponse struct {
	// Return: The R_DhcpAuditLogSetParams return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AuditLogSetParamsResponse) xxx_ToOp(ctx context.Context, op *xxx_AuditLogSetParamsOperation) *xxx_AuditLogSetParamsOperation {
	if op == nil {
		op = &xxx_AuditLogSetParamsOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *AuditLogSetParamsResponse) xxx_FromOp(ctx context.Context, op *xxx_AuditLogSetParamsOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *AuditLogSetParamsResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *AuditLogSetParamsResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AuditLogSetParamsOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AuditLogGetParamsOperation structure represents the R_DhcpAuditLogGetParams operation
type xxx_AuditLogGetParamsOperation struct {
	ServerIPAddress   string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Flags             uint32 `idl:"name:Flags" json:"flags"`
	AuditLogDir       string `idl:"name:AuditLogDir" json:"audit_log_dir"`
	DiskCheckInterval uint32 `idl:"name:DiskCheckInterval" json:"disk_check_interval"`
	MaxLogFilesSize   uint32 `idl:"name:MaxLogFilesSize" json:"max_log_files_size"`
	MinSpaceOnDisk    uint32 `idl:"name:MinSpaceOnDisk" json:"min_space_on_disk"`
	Return            uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_AuditLogGetParamsOperation) OpNum() int { return 33 }

func (o *xxx_AuditLogGetParamsOperation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpAuditLogGetParams"
}

func (o *xxx_AuditLogGetParamsOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AuditLogGetParamsOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AuditLogGetParamsOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AuditLogGetParamsOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AuditLogGetParamsOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// AuditLogDir {out} (1:{pointer=ref}*(2))(2:{string, alias=LPWSTR_RPC_STRING, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.AuditLogDir != "" {
			_ptr_AuditLogDir := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.AuditLogDir); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.AuditLogDir, _ptr_AuditLogDir); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// DiskCheckInterval {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DiskCheckInterval); err != nil {
			return err
		}
	}
	// MaxLogFilesSize {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.MaxLogFilesSize); err != nil {
			return err
		}
	}
	// MinSpaceOnDisk {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.MinSpaceOnDisk); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AuditLogGetParamsOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// AuditLogDir {out} (1:{pointer=ref}*(2))(2:{string, alias=LPWSTR_RPC_STRING, names=LPWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		_ptr_AuditLogDir := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.AuditLogDir); err != nil {
				return err
			}
			return nil
		})
		_s_AuditLogDir := func(ptr interface{}) { o.AuditLogDir = *ptr.(*string) }
		if err := w.ReadPointer(&o.AuditLogDir, _s_AuditLogDir, _ptr_AuditLogDir); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// DiskCheckInterval {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DiskCheckInterval); err != nil {
			return err
		}
	}
	// MaxLogFilesSize {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.MaxLogFilesSize); err != nil {
			return err
		}
	}
	// MinSpaceOnDisk {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.MinSpaceOnDisk); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AuditLogGetParamsRequest structure represents the R_DhcpAuditLogGetParams operation request
type AuditLogGetParamsRequest struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// Flags: This flag is not used and MUST be set to 0.
	Flags uint32 `idl:"name:Flags" json:"flags"`
}

func (o *AuditLogGetParamsRequest) xxx_ToOp(ctx context.Context, op *xxx_AuditLogGetParamsOperation) *xxx_AuditLogGetParamsOperation {
	if op == nil {
		op = &xxx_AuditLogGetParamsOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Flags = o.Flags
	return op
}

func (o *AuditLogGetParamsRequest) xxx_FromOp(ctx context.Context, op *xxx_AuditLogGetParamsOperation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Flags = op.Flags
}
func (o *AuditLogGetParamsRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *AuditLogGetParamsRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AuditLogGetParamsOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AuditLogGetParamsResponse structure represents the R_DhcpAuditLogGetParams operation response
type AuditLogGetParamsResponse struct {
	// AuditLogDir: A pointer to a null-terminated Unicode string in which the path where
	// the audit logs are placed is returned.
	AuditLogDir string `idl:"name:AuditLogDir" json:"audit_log_dir"`
	// DiskCheckInterval: This is of type DWORD and will contain the number of times the
	// DHCP server writes audit log events to the log file before checking for available
	// disk space on the DHCP server. The caller must allocate memory for this parameter
	// equal to the size of data type DWORD.
	DiskCheckInterval uint32 `idl:"name:DiskCheckInterval" json:"disk_check_interval"`
	// MaxLogFilesSize: This is of type DWORD and will contain the maximum size restriction
	// (in megabytes) for the total amount of disk space available for all audit log files
	// created and stored by the DHCP server. The caller must allocate memory for this parameter
	// equal to the size of data type DWORD.
	MaxLogFilesSize uint32 `idl:"name:MaxLogFilesSize" json:"max_log_files_size"`
	// MinSpaceOnDisk: This is of type DWORD and will contain the minimum size requirement
	// (in megabytes) for server disk space that is used during disk checking to determine
	// if sufficient space exists for the server to continue audit logging. The caller must
	// allocate memory for this parameter equal to the size of data type DWORD.
	MinSpaceOnDisk uint32 `idl:"name:MinSpaceOnDisk" json:"min_space_on_disk"`
	// Return: The R_DhcpAuditLogGetParams return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AuditLogGetParamsResponse) xxx_ToOp(ctx context.Context, op *xxx_AuditLogGetParamsOperation) *xxx_AuditLogGetParamsOperation {
	if op == nil {
		op = &xxx_AuditLogGetParamsOperation{}
	}
	if o == nil {
		return op
	}
	op.AuditLogDir = o.AuditLogDir
	op.DiskCheckInterval = o.DiskCheckInterval
	op.MaxLogFilesSize = o.MaxLogFilesSize
	op.MinSpaceOnDisk = o.MinSpaceOnDisk
	op.Return = o.Return
	return op
}

func (o *AuditLogGetParamsResponse) xxx_FromOp(ctx context.Context, op *xxx_AuditLogGetParamsOperation) {
	if o == nil {
		return
	}
	o.AuditLogDir = op.AuditLogDir
	o.DiskCheckInterval = op.DiskCheckInterval
	o.MaxLogFilesSize = op.MaxLogFilesSize
	o.MinSpaceOnDisk = op.MinSpaceOnDisk
	o.Return = op.Return
}
func (o *AuditLogGetParamsResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *AuditLogGetParamsResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AuditLogGetParamsOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ServerQueryAttributeOperation structure represents the R_DhcpServerQueryAttribute operation
type xxx_ServerQueryAttributeOperation struct {
	ServerIPAddress string           `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	_               uint32           `idl:"name:dwReserved"`
	AttributeID     uint32           `idl:"name:DhcpAttribId" json:"attribute_id"`
	DHCPAttribute   *dhcpm.Attribute `idl:"name:pDhcpAttrib" json:"dhcp_attribute"`
	Return          uint32           `idl:"name:Return" json:"return"`
}

func (o *xxx_ServerQueryAttributeOperation) OpNum() int { return 34 }

func (o *xxx_ServerQueryAttributeOperation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpServerQueryAttribute"
}

func (o *xxx_ServerQueryAttributeOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ServerQueryAttributeOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// dwReserved {in} (1:{alias=ULONG}(uint32))
	{
		// reserved dwReserved
		if err := w.WriteData(uint32(0)); err != nil {
			return err
		}
	}
	// DhcpAttribId {in} (1:{alias=DHCP_ATTRIB_ID, names=ULONG}(uint32))
	{
		if err := w.WriteData(o.AttributeID); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ServerQueryAttributeOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// dwReserved {in} (1:{alias=ULONG}(uint32))
	{
		// reserved dwReserved
		var _dwReserved uint32
		if err := w.ReadData(&_dwReserved); err != nil {
			return err
		}
	}
	// DhcpAttribId {in} (1:{alias=DHCP_ATTRIB_ID, names=ULONG}(uint32))
	{
		if err := w.ReadData(&o.AttributeID); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ServerQueryAttributeOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ServerQueryAttributeOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pDhcpAttrib {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_ATTRIB}*(1))(3:{alias=DHCP_ATTRIB}(struct))
	{
		if o.DHCPAttribute != nil {
			_ptr_pDhcpAttrib := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.DHCPAttribute != nil {
					if err := o.DHCPAttribute.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.Attribute{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.DHCPAttribute, _ptr_pDhcpAttrib); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ServerQueryAttributeOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pDhcpAttrib {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_ATTRIB,pointer=ref}*(1))(3:{alias=DHCP_ATTRIB}(struct))
	{
		_ptr_pDhcpAttrib := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.DHCPAttribute == nil {
				o.DHCPAttribute = &dhcpm.Attribute{}
			}
			if err := o.DHCPAttribute.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_pDhcpAttrib := func(ptr interface{}) { o.DHCPAttribute = *ptr.(**dhcpm.Attribute) }
		if err := w.ReadPointer(&o.DHCPAttribute, _s_pDhcpAttrib, _ptr_pDhcpAttrib); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ServerQueryAttributeRequest structure represents the R_DhcpServerQueryAttribute operation request
type ServerQueryAttributeRequest struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// DhcpAttribId: This is of type DHCP_ATTRIB_ID (section 2.2.1.1.1), specifying the
	// attribute to be queried.
	AttributeID uint32 `idl:"name:DhcpAttribId" json:"attribute_id"`
}

func (o *ServerQueryAttributeRequest) xxx_ToOp(ctx context.Context, op *xxx_ServerQueryAttributeOperation) *xxx_ServerQueryAttributeOperation {
	if op == nil {
		op = &xxx_ServerQueryAttributeOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.AttributeID = o.AttributeID
	return op
}

func (o *ServerQueryAttributeRequest) xxx_FromOp(ctx context.Context, op *xxx_ServerQueryAttributeOperation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.AttributeID = op.AttributeID
}
func (o *ServerQueryAttributeRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *ServerQueryAttributeRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ServerQueryAttributeOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ServerQueryAttributeResponse structure represents the R_DhcpServerQueryAttribute operation response
type ServerQueryAttributeResponse struct {
	// pDhcpAttrib: This is a pointer to type LPDHCP_ATTRIB (section 2.2.1.2.78) that points
	// to a location that contains the value and the type of the queried attribute.
	DHCPAttribute *dhcpm.Attribute `idl:"name:pDhcpAttrib" json:"dhcp_attribute"`
	// Return: The R_DhcpServerQueryAttribute return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ServerQueryAttributeResponse) xxx_ToOp(ctx context.Context, op *xxx_ServerQueryAttributeOperation) *xxx_ServerQueryAttributeOperation {
	if op == nil {
		op = &xxx_ServerQueryAttributeOperation{}
	}
	if o == nil {
		return op
	}
	op.DHCPAttribute = o.DHCPAttribute
	op.Return = o.Return
	return op
}

func (o *ServerQueryAttributeResponse) xxx_FromOp(ctx context.Context, op *xxx_ServerQueryAttributeOperation) {
	if o == nil {
		return
	}
	o.DHCPAttribute = op.DHCPAttribute
	o.Return = op.Return
}
func (o *ServerQueryAttributeResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *ServerQueryAttributeResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ServerQueryAttributeOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ServerQueryAttributesOperation structure represents the R_DhcpServerQueryAttributes operation
type xxx_ServerQueryAttributesOperation struct {
	ServerIPAddress    string                `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	_                  uint32                `idl:"name:dwReserved"`
	AttributeCount     uint32                `idl:"name:dwAttribCount" json:"attribute_count"`
	DHCPAttributes     []uint32              `idl:"name:pDhcpAttribs;size_is:(dwAttribCount)" json:"dhcp_attributes"`
	DHCPAttributeArray *dhcpm.AttributeArray `idl:"name:pDhcpAttribArr" json:"dhcp_attribute_array"`
	Return             uint32                `idl:"name:Return" json:"return"`
}

func (o *xxx_ServerQueryAttributesOperation) OpNum() int { return 35 }

func (o *xxx_ServerQueryAttributesOperation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpServerQueryAttributes"
}

func (o *xxx_ServerQueryAttributesOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.DHCPAttributes != nil && o.AttributeCount == 0 {
		o.AttributeCount = uint32(len(o.DHCPAttributes))
	}
	if o.AttributeCount > uint32(6) {
		return fmt.Errorf("AttributeCount is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ServerQueryAttributesOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// dwReserved {in} (1:{alias=ULONG}(uint32))
	{
		// reserved dwReserved
		if err := w.WriteData(uint32(0)); err != nil {
			return err
		}
	}
	// dwAttribCount {in} (1:{range=(0,6), alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.AttributeCount); err != nil {
			return err
		}
	}
	// pDhcpAttribs {in} (1:{alias=LPDHCP_ATTRIB_ID}*(1))(2:{alias=DHCP_ATTRIB_ID, names=ULONG}[dim:0,size_is=dwAttribCount](uint32))
	{
		dimSize1 := uint64(o.AttributeCount)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.DHCPAttributes {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.DHCPAttributes[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.DHCPAttributes); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint32(0)); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_ServerQueryAttributesOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// dwReserved {in} (1:{alias=ULONG}(uint32))
	{
		// reserved dwReserved
		var _dwReserved uint32
		if err := w.ReadData(&_dwReserved); err != nil {
			return err
		}
	}
	// dwAttribCount {in} (1:{range=(0,6), alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.AttributeCount); err != nil {
			return err
		}
	}
	// pDhcpAttribs {in} (1:{alias=LPDHCP_ATTRIB_ID,pointer=ref}*(1))(2:{alias=DHCP_ATTRIB_ID, names=ULONG}[dim:0,size_is=dwAttribCount](uint32))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.DHCPAttributes", sizeInfo[0])
		}
		o.DHCPAttributes = make([]uint32, sizeInfo[0])
		for i1 := range o.DHCPAttributes {
			i1 := i1
			if err := w.ReadData(&o.DHCPAttributes[i1]); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_ServerQueryAttributesOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ServerQueryAttributesOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pDhcpAttribArr {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_ATTRIB_ARRAY}*(1))(3:{alias=DHCP_ATTRIB_ARRAY}(struct))
	{
		if o.DHCPAttributeArray != nil {
			_ptr_pDhcpAttribArr := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.DHCPAttributeArray != nil {
					if err := o.DHCPAttributeArray.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.AttributeArray{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.DHCPAttributeArray, _ptr_pDhcpAttribArr); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ServerQueryAttributesOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pDhcpAttribArr {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_ATTRIB_ARRAY,pointer=ref}*(1))(3:{alias=DHCP_ATTRIB_ARRAY}(struct))
	{
		_ptr_pDhcpAttribArr := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.DHCPAttributeArray == nil {
				o.DHCPAttributeArray = &dhcpm.AttributeArray{}
			}
			if err := o.DHCPAttributeArray.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_pDhcpAttribArr := func(ptr interface{}) { o.DHCPAttributeArray = *ptr.(**dhcpm.AttributeArray) }
		if err := w.ReadPointer(&o.DHCPAttributeArray, _s_pDhcpAttribArr, _ptr_pDhcpAttribArr); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ServerQueryAttributesRequest structure represents the R_DhcpServerQueryAttributes operation request
type ServerQueryAttributesRequest struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// dwAttribCount: This is of type ULONG and contains the number of attributes queried.
	AttributeCount uint32 `idl:"name:dwAttribCount" json:"attribute_count"`
	// pDhcpAttribs: This is a pointer to type DHCP_ATTRIB_ID (section 2.2.1.1.1) and points
	// to an array of length dwAttribCount which contains the queried attribute.
	DHCPAttributes []uint32 `idl:"name:pDhcpAttribs;size_is:(dwAttribCount)" json:"dhcp_attributes"`
}

func (o *ServerQueryAttributesRequest) xxx_ToOp(ctx context.Context, op *xxx_ServerQueryAttributesOperation) *xxx_ServerQueryAttributesOperation {
	if op == nil {
		op = &xxx_ServerQueryAttributesOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.AttributeCount = o.AttributeCount
	op.DHCPAttributes = o.DHCPAttributes
	return op
}

func (o *ServerQueryAttributesRequest) xxx_FromOp(ctx context.Context, op *xxx_ServerQueryAttributesOperation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.AttributeCount = op.AttributeCount
	o.DHCPAttributes = op.DHCPAttributes
}
func (o *ServerQueryAttributesRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *ServerQueryAttributesRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ServerQueryAttributesOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ServerQueryAttributesResponse structure represents the R_DhcpServerQueryAttributes operation response
type ServerQueryAttributesResponse struct {
	// pDhcpAttribArr: This is a pointer to type LPDHCP_ATTRIB_ARRAY that points to an array
	// that contains attribute information for all of the valid attributes queried.
	DHCPAttributeArray *dhcpm.AttributeArray `idl:"name:pDhcpAttribArr" json:"dhcp_attribute_array"`
	// Return: The R_DhcpServerQueryAttributes return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ServerQueryAttributesResponse) xxx_ToOp(ctx context.Context, op *xxx_ServerQueryAttributesOperation) *xxx_ServerQueryAttributesOperation {
	if op == nil {
		op = &xxx_ServerQueryAttributesOperation{}
	}
	if o == nil {
		return op
	}
	op.DHCPAttributeArray = o.DHCPAttributeArray
	op.Return = o.Return
	return op
}

func (o *ServerQueryAttributesResponse) xxx_FromOp(ctx context.Context, op *xxx_ServerQueryAttributesOperation) {
	if o == nil {
		return
	}
	o.DHCPAttributeArray = op.DHCPAttributeArray
	o.Return = op.Return
}
func (o *ServerQueryAttributesResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *ServerQueryAttributesResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ServerQueryAttributesOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ServerRedoAuthorizationOperation structure represents the R_DhcpServerRedoAuthorization operation
type xxx_ServerRedoAuthorizationOperation struct {
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	_               uint32 `idl:"name:dwReserved"`
	Return          uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_ServerRedoAuthorizationOperation) OpNum() int { return 36 }

func (o *xxx_ServerRedoAuthorizationOperation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpServerRedoAuthorization"
}

func (o *xxx_ServerRedoAuthorizationOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ServerRedoAuthorizationOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// dwReserved {in} (1:{alias=ULONG}(uint32))
	{
		// reserved dwReserved
		if err := w.WriteData(uint32(0)); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ServerRedoAuthorizationOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// dwReserved {in} (1:{alias=ULONG}(uint32))
	{
		// reserved dwReserved
		var _dwReserved uint32
		if err := w.ReadData(&_dwReserved); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ServerRedoAuthorizationOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ServerRedoAuthorizationOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ServerRedoAuthorizationOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ServerRedoAuthorizationRequest structure represents the R_DhcpServerRedoAuthorization operation request
type ServerRedoAuthorizationRequest struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
}

func (o *ServerRedoAuthorizationRequest) xxx_ToOp(ctx context.Context, op *xxx_ServerRedoAuthorizationOperation) *xxx_ServerRedoAuthorizationOperation {
	if op == nil {
		op = &xxx_ServerRedoAuthorizationOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	return op
}

func (o *ServerRedoAuthorizationRequest) xxx_FromOp(ctx context.Context, op *xxx_ServerRedoAuthorizationOperation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
}
func (o *ServerRedoAuthorizationRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *ServerRedoAuthorizationRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ServerRedoAuthorizationOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ServerRedoAuthorizationResponse structure represents the R_DhcpServerRedoAuthorization operation response
type ServerRedoAuthorizationResponse struct {
	// Return: The R_DhcpServerRedoAuthorization return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ServerRedoAuthorizationResponse) xxx_ToOp(ctx context.Context, op *xxx_ServerRedoAuthorizationOperation) *xxx_ServerRedoAuthorizationOperation {
	if op == nil {
		op = &xxx_ServerRedoAuthorizationOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *ServerRedoAuthorizationResponse) xxx_FromOp(ctx context.Context, op *xxx_ServerRedoAuthorizationOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *ServerRedoAuthorizationResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *ServerRedoAuthorizationResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ServerRedoAuthorizationOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddSubnetElementV5Operation structure represents the R_DhcpAddSubnetElementV5 operation
type xxx_AddSubnetElementV5Operation struct {
	ServerIPAddress string                     `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	SubnetAddress   uint32                     `idl:"name:SubnetAddress" json:"subnet_address"`
	AddElementInfo  *dhcpm.SubnetElementDataV5 `idl:"name:AddElementInfo;pointer:ref" json:"add_element_info"`
	Return          uint32                     `idl:"name:Return" json:"return"`
}

func (o *xxx_AddSubnetElementV5Operation) OpNum() int { return 37 }

func (o *xxx_AddSubnetElementV5Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpAddSubnetElementV5"
}

func (o *xxx_AddSubnetElementV5Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddSubnetElementV5Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.SubnetAddress); err != nil {
			return err
		}
	}
	// AddElementInfo {in} (1:{pointer=ref, alias=LPDHCP_SUBNET_ELEMENT_DATA_V5}*(1))(2:{alias=DHCP_SUBNET_ELEMENT_DATA_V5}(struct))
	{
		if o.AddElementInfo != nil {
			if err := o.AddElementInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.SubnetElementDataV5{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddSubnetElementV5Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.SubnetAddress); err != nil {
			return err
		}
	}
	// AddElementInfo {in} (1:{pointer=ref, alias=LPDHCP_SUBNET_ELEMENT_DATA_V5}*(1))(2:{alias=DHCP_SUBNET_ELEMENT_DATA_V5}(struct))
	{
		if o.AddElementInfo == nil {
			o.AddElementInfo = &dhcpm.SubnetElementDataV5{}
		}
		if err := o.AddElementInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddSubnetElementV5Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddSubnetElementV5Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddSubnetElementV5Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddSubnetElementV5Request structure represents the R_DhcpAddSubnetElementV5 operation request
type AddSubnetElementV5Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// SubnetAddress: This is of type DHCP_IP_ADDRESS (section 2.2.1.2.1) that contains
	// the IPv4 subnet ID to which the IPv4 subnet element is added.
	SubnetAddress uint32 `idl:"name:SubnetAddress" json:"subnet_address"`
	// AddElementInfo: This is a pointer to structure DHCP_SUBNET_ELEMENT_DATA_V5 (section
	// 2.2.1.2.38) that contains the IPv4 subnet element which needs to be added to the
	// IPv4 subnet.
	//
	// For this call with ElementType of DhcpSecondaryHosts (section 2.2.1.1.7), ERROR_CALL_NOT_IMPLEMENTED
	// is returned.
	//
	// For this call with ElementType of DhcpIpUsedClusters, ERROR_INVALID_PARAMETER is
	// returned.
	AddElementInfo *dhcpm.SubnetElementDataV5 `idl:"name:AddElementInfo;pointer:ref" json:"add_element_info"`
}

func (o *AddSubnetElementV5Request) xxx_ToOp(ctx context.Context, op *xxx_AddSubnetElementV5Operation) *xxx_AddSubnetElementV5Operation {
	if op == nil {
		op = &xxx_AddSubnetElementV5Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.SubnetAddress = o.SubnetAddress
	op.AddElementInfo = o.AddElementInfo
	return op
}

func (o *AddSubnetElementV5Request) xxx_FromOp(ctx context.Context, op *xxx_AddSubnetElementV5Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.SubnetAddress = op.SubnetAddress
	o.AddElementInfo = op.AddElementInfo
}
func (o *AddSubnetElementV5Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *AddSubnetElementV5Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddSubnetElementV5Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddSubnetElementV5Response structure represents the R_DhcpAddSubnetElementV5 operation response
type AddSubnetElementV5Response struct {
	// Return: The R_DhcpAddSubnetElementV5 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddSubnetElementV5Response) xxx_ToOp(ctx context.Context, op *xxx_AddSubnetElementV5Operation) *xxx_AddSubnetElementV5Operation {
	if op == nil {
		op = &xxx_AddSubnetElementV5Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *AddSubnetElementV5Response) xxx_FromOp(ctx context.Context, op *xxx_AddSubnetElementV5Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *AddSubnetElementV5Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *AddSubnetElementV5Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddSubnetElementV5Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumSubnetElementsV5Operation structure represents the R_DhcpEnumSubnetElementsV5 operation
type xxx_EnumSubnetElementsV5Operation struct {
	ServerIPAddress  string                          `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	SubnetAddress    uint32                          `idl:"name:SubnetAddress" json:"subnet_address"`
	EnumElementType  dhcpm.SubnetElementType         `idl:"name:EnumElementType" json:"enum_element_type"`
	Resume           uint32                          `idl:"name:ResumeHandle" json:"resume"`
	PreferredMaximum uint32                          `idl:"name:PreferredMaximum" json:"preferred_maximum"`
	EnumElementInfo  *dhcpm.SubnetElementInfoArrayV5 `idl:"name:EnumElementInfo" json:"enum_element_info"`
	ElementsRead     uint32                          `idl:"name:ElementsRead" json:"elements_read"`
	ElementsTotal    uint32                          `idl:"name:ElementsTotal" json:"elements_total"`
	Return           uint32                          `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumSubnetElementsV5Operation) OpNum() int { return 38 }

func (o *xxx_EnumSubnetElementsV5Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpEnumSubnetElementsV5"
}

func (o *xxx_EnumSubnetElementsV5Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetElementsV5Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.SubnetAddress); err != nil {
			return err
		}
	}
	// EnumElementType {in} (1:{alias=DHCP_SUBNET_ELEMENT_TYPE}(enum))
	{
		if err := w.WriteEnum(uint16(o.EnumElementType)); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Resume); err != nil {
			return err
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PreferredMaximum); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetElementsV5Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.SubnetAddress); err != nil {
			return err
		}
	}
	// EnumElementType {in} (1:{alias=DHCP_SUBNET_ELEMENT_TYPE}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.EnumElementType)); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Resume); err != nil {
			return err
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PreferredMaximum); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetElementsV5Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetElementsV5Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Resume); err != nil {
			return err
		}
	}
	// EnumElementInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V5}*(1))(3:{alias=DHCP_SUBNET_ELEMENT_INFO_ARRAY_V5}(struct))
	{
		if o.EnumElementInfo != nil {
			_ptr_EnumElementInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.EnumElementInfo != nil {
					if err := o.EnumElementInfo.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.SubnetElementInfoArrayV5{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.EnumElementInfo, _ptr_EnumElementInfo); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ElementsRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ElementsRead); err != nil {
			return err
		}
	}
	// ElementsTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ElementsTotal); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetElementsV5Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Resume); err != nil {
			return err
		}
	}
	// EnumElementInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V5,pointer=ref}*(1))(3:{alias=DHCP_SUBNET_ELEMENT_INFO_ARRAY_V5}(struct))
	{
		_ptr_EnumElementInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.EnumElementInfo == nil {
				o.EnumElementInfo = &dhcpm.SubnetElementInfoArrayV5{}
			}
			if err := o.EnumElementInfo.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_EnumElementInfo := func(ptr interface{}) { o.EnumElementInfo = *ptr.(**dhcpm.SubnetElementInfoArrayV5) }
		if err := w.ReadPointer(&o.EnumElementInfo, _s_EnumElementInfo, _ptr_EnumElementInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ElementsRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ElementsRead); err != nil {
			return err
		}
	}
	// ElementsTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ElementsTotal); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumSubnetElementsV5Request structure represents the R_DhcpEnumSubnetElementsV5 operation request
type EnumSubnetElementsV5Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// SubnetAddress: This is of type DHCP_IP_ADDRESS (section 2.2.1.2.1) that contains
	// the IPv4 subnet ID from which subnet elements are enumerated.
	SubnetAddress uint32 `idl:"name:SubnetAddress" json:"subnet_address"`
	// EnumElementType: This is of type DHCP_SUBNET_ELEMENT_TYPE (section 2.2.1.1.7) enumeration,
	// a value that indicates the type of IPv4 subnet element to enumerate.
	EnumElementType dhcpm.SubnetElementType `idl:"name:EnumElementType" json:"enum_element_type"`
	// ResumeHandle: This is a pointer of type DHCP_RESUME_HANDLE (section 2.2.1.2.6) that
	// identifies the enumeration operation. Initially, this value MUST be set to zero,
	// with a successful call returning the handle value used for subsequent enumeration
	// requests. For example, if PreferredMaximum is set to 1,000 bytes, and 2,000 bytes'
	// worth of IPv4 subnet elements are stored on the DHCPv4 server, the resume handle
	// can be used after the first 1,000 bytes are retrieved to obtain the next 1,000 on
	// a subsequent call, and so forth.
	Resume uint32 `idl:"name:ResumeHandle" json:"resume"`
	// PreferredMaximum: This is of type DWORD, specifying the preferred maximum number
	// of bytes to return. If the number of remaining unenumerated subnet elements (in bytes)
	// is less than this value, then all IPv4 subnet elements for the specific type are
	// returned. To retrieve all the IPv4 subnet elements of a specific type, 0xFFFFFFFF
	// is specified.
	PreferredMaximum uint32 `idl:"name:PreferredMaximum" json:"preferred_maximum"`
}

func (o *EnumSubnetElementsV5Request) xxx_ToOp(ctx context.Context, op *xxx_EnumSubnetElementsV5Operation) *xxx_EnumSubnetElementsV5Operation {
	if op == nil {
		op = &xxx_EnumSubnetElementsV5Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.SubnetAddress = o.SubnetAddress
	op.EnumElementType = o.EnumElementType
	op.Resume = o.Resume
	op.PreferredMaximum = o.PreferredMaximum
	return op
}

func (o *EnumSubnetElementsV5Request) xxx_FromOp(ctx context.Context, op *xxx_EnumSubnetElementsV5Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.SubnetAddress = op.SubnetAddress
	o.EnumElementType = op.EnumElementType
	o.Resume = op.Resume
	o.PreferredMaximum = op.PreferredMaximum
}
func (o *EnumSubnetElementsV5Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumSubnetElementsV5Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumSubnetElementsV5Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumSubnetElementsV5Response structure represents the R_DhcpEnumSubnetElementsV5 operation response
type EnumSubnetElementsV5Response struct {
	// ResumeHandle: This is a pointer of type DHCP_RESUME_HANDLE (section 2.2.1.2.6) that
	// identifies the enumeration operation. Initially, this value MUST be set to zero,
	// with a successful call returning the handle value used for subsequent enumeration
	// requests. For example, if PreferredMaximum is set to 1,000 bytes, and 2,000 bytes'
	// worth of IPv4 subnet elements are stored on the DHCPv4 server, the resume handle
	// can be used after the first 1,000 bytes are retrieved to obtain the next 1,000 on
	// a subsequent call, and so forth.
	Resume uint32 `idl:"name:ResumeHandle" json:"resume"`
	// EnumElementInfo: This is a pointer of type LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V5 in
	// which IPv4 subnet element of type EnumElementType is returned for a specific IPv4
	// subnet SubnetAddress. If no IPv4 subnet element of a specific type is available for
	// enumeration, this value is null.
	EnumElementInfo *dhcpm.SubnetElementInfoArrayV5 `idl:"name:EnumElementInfo" json:"enum_element_info"`
	// ElementsRead: This is a pointer to a DWORD value that specifies the number of IPv4
	// subnet elements read in EnumElementInfo for a specific type of IPv4 subnet element.
	// The caller must allocate memory for this parameter equal to the size of data type
	// DWORD.
	ElementsRead uint32 `idl:"name:ElementsRead" json:"elements_read"`
	// ElementsTotal: This is a pointer to a DWORD value that specifies the number of IPv4
	// subnet elements of a specific type from a specific IPv4 subnet that are not yet enumerated
	// with respect to the resume handle that is returned. The caller must allocate memory
	// for this parameter equal to the size of data type DWORD.
	ElementsTotal uint32 `idl:"name:ElementsTotal" json:"elements_total"`
	// Return: The R_DhcpEnumSubnetElementsV5 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumSubnetElementsV5Response) xxx_ToOp(ctx context.Context, op *xxx_EnumSubnetElementsV5Operation) *xxx_EnumSubnetElementsV5Operation {
	if op == nil {
		op = &xxx_EnumSubnetElementsV5Operation{}
	}
	if o == nil {
		return op
	}
	op.Resume = o.Resume
	op.EnumElementInfo = o.EnumElementInfo
	op.ElementsRead = o.ElementsRead
	op.ElementsTotal = o.ElementsTotal
	op.Return = o.Return
	return op
}

func (o *EnumSubnetElementsV5Response) xxx_FromOp(ctx context.Context, op *xxx_EnumSubnetElementsV5Operation) {
	if o == nil {
		return
	}
	o.Resume = op.Resume
	o.EnumElementInfo = op.EnumElementInfo
	o.ElementsRead = op.ElementsRead
	o.ElementsTotal = op.ElementsTotal
	o.Return = op.Return
}
func (o *EnumSubnetElementsV5Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumSubnetElementsV5Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumSubnetElementsV5Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_RemoveSubnetElementV5Operation structure represents the R_DhcpRemoveSubnetElementV5 operation
type xxx_RemoveSubnetElementV5Operation struct {
	ServerIPAddress   string                     `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	SubnetAddress     uint32                     `idl:"name:SubnetAddress" json:"subnet_address"`
	RemoveElementInfo *dhcpm.SubnetElementDataV5 `idl:"name:RemoveElementInfo;pointer:ref" json:"remove_element_info"`
	ForceFlag         dhcpm.ForceFlag            `idl:"name:ForceFlag" json:"force_flag"`
	Return            uint32                     `idl:"name:Return" json:"return"`
}

func (o *xxx_RemoveSubnetElementV5Operation) OpNum() int { return 39 }

func (o *xxx_RemoveSubnetElementV5Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpRemoveSubnetElementV5"
}

func (o *xxx_RemoveSubnetElementV5Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveSubnetElementV5Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.SubnetAddress); err != nil {
			return err
		}
	}
	// RemoveElementInfo {in} (1:{pointer=ref, alias=LPDHCP_SUBNET_ELEMENT_DATA_V5}*(1))(2:{alias=DHCP_SUBNET_ELEMENT_DATA_V5}(struct))
	{
		if o.RemoveElementInfo != nil {
			if err := o.RemoveElementInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.SubnetElementDataV5{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ForceFlag {in} (1:{alias=DHCP_FORCE_FLAG}(enum))
	{
		if err := w.WriteEnum(uint16(o.ForceFlag)); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveSubnetElementV5Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.SubnetAddress); err != nil {
			return err
		}
	}
	// RemoveElementInfo {in} (1:{pointer=ref, alias=LPDHCP_SUBNET_ELEMENT_DATA_V5}*(1))(2:{alias=DHCP_SUBNET_ELEMENT_DATA_V5}(struct))
	{
		if o.RemoveElementInfo == nil {
			o.RemoveElementInfo = &dhcpm.SubnetElementDataV5{}
		}
		if err := o.RemoveElementInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ForceFlag {in} (1:{alias=DHCP_FORCE_FLAG}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.ForceFlag)); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveSubnetElementV5Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveSubnetElementV5Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveSubnetElementV5Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// RemoveSubnetElementV5Request structure represents the R_DhcpRemoveSubnetElementV5 operation request
type RemoveSubnetElementV5Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// SubnetAddress: This is of type DHCP_IP_ADDRESS (section 2.2.1.2.1) that contains
	// the IPv4 subnet ID from which the IPv4 subnet element is removed.
	SubnetAddress uint32 `idl:"name:SubnetAddress" json:"subnet_address"`
	// RemoveElementInfo: This is a pointer of type DHCP_SUBNET_ELEMENT_DATA_V5 (section
	// 2.2.1.2.38) that contains the IPv4 subnet element that needs to be removed from the
	// IPv4 subnet.
	RemoveElementInfo *dhcpm.SubnetElementDataV5 `idl:"name:RemoveElementInfo;pointer:ref" json:"remove_element_info"`
	// ForceFlag: This is of type DHCP_FORCE_FLAG (section 2.2.1.1.9) that defines the behavior
	// of this method. If the flag is set to DhcpNoForce and this subnet has served the
	// IPv4 address to some DHCPv4/BOOTP clients, the IPv4 range is not deleted. If the
	// flag is set to DhcpFullForce, the IPv4 range is deleted along with the DHCPv4 client
	// lease record on the DHCPv4 server.
	ForceFlag dhcpm.ForceFlag `idl:"name:ForceFlag" json:"force_flag"`
}

func (o *RemoveSubnetElementV5Request) xxx_ToOp(ctx context.Context, op *xxx_RemoveSubnetElementV5Operation) *xxx_RemoveSubnetElementV5Operation {
	if op == nil {
		op = &xxx_RemoveSubnetElementV5Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.SubnetAddress = o.SubnetAddress
	op.RemoveElementInfo = o.RemoveElementInfo
	op.ForceFlag = o.ForceFlag
	return op
}

func (o *RemoveSubnetElementV5Request) xxx_FromOp(ctx context.Context, op *xxx_RemoveSubnetElementV5Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.SubnetAddress = op.SubnetAddress
	o.RemoveElementInfo = op.RemoveElementInfo
	o.ForceFlag = op.ForceFlag
}
func (o *RemoveSubnetElementV5Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *RemoveSubnetElementV5Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemoveSubnetElementV5Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// RemoveSubnetElementV5Response structure represents the R_DhcpRemoveSubnetElementV5 operation response
type RemoveSubnetElementV5Response struct {
	// Return: The R_DhcpRemoveSubnetElementV5 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *RemoveSubnetElementV5Response) xxx_ToOp(ctx context.Context, op *xxx_RemoveSubnetElementV5Operation) *xxx_RemoveSubnetElementV5Operation {
	if op == nil {
		op = &xxx_RemoveSubnetElementV5Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *RemoveSubnetElementV5Response) xxx_FromOp(ctx context.Context, op *xxx_RemoveSubnetElementV5Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *RemoveSubnetElementV5Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *RemoveSubnetElementV5Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemoveSubnetElementV5Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetServerBindingInfoOperation structure represents the R_DhcpGetServerBindingInfo operation
type xxx_GetServerBindingInfoOperation struct {
	ServerIPAddress  string                  `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Flags            uint32                  `idl:"name:Flags" json:"flags"`
	BindElementsInfo *dhcpm.BindElementArray `idl:"name:BindElementsInfo" json:"bind_elements_info"`
	Return           uint32                  `idl:"name:Return" json:"return"`
}

func (o *xxx_GetServerBindingInfoOperation) OpNum() int { return 40 }

func (o *xxx_GetServerBindingInfoOperation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpGetServerBindingInfo"
}

func (o *xxx_GetServerBindingInfoOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServerBindingInfoOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServerBindingInfoOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServerBindingInfoOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServerBindingInfoOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// BindElementsInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_BIND_ELEMENT_ARRAY}*(1))(3:{alias=DHCP_BIND_ELEMENT_ARRAY}(struct))
	{
		if o.BindElementsInfo != nil {
			_ptr_BindElementsInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.BindElementsInfo != nil {
					if err := o.BindElementsInfo.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.BindElementArray{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.BindElementsInfo, _ptr_BindElementsInfo); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServerBindingInfoOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// BindElementsInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_BIND_ELEMENT_ARRAY,pointer=ref}*(1))(3:{alias=DHCP_BIND_ELEMENT_ARRAY}(struct))
	{
		_ptr_BindElementsInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.BindElementsInfo == nil {
				o.BindElementsInfo = &dhcpm.BindElementArray{}
			}
			if err := o.BindElementsInfo.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_BindElementsInfo := func(ptr interface{}) { o.BindElementsInfo = *ptr.(**dhcpm.BindElementArray) }
		if err := w.ReadPointer(&o.BindElementsInfo, _s_BindElementsInfo, _ptr_BindElementsInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetServerBindingInfoRequest structure represents the R_DhcpGetServerBindingInfo operation request
type GetServerBindingInfoRequest struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// Flags: This flag is not used, and it MUST be set to 0.
	Flags uint32 `idl:"name:Flags" json:"flags"`
}

func (o *GetServerBindingInfoRequest) xxx_ToOp(ctx context.Context, op *xxx_GetServerBindingInfoOperation) *xxx_GetServerBindingInfoOperation {
	if op == nil {
		op = &xxx_GetServerBindingInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Flags = o.Flags
	return op
}

func (o *GetServerBindingInfoRequest) xxx_FromOp(ctx context.Context, op *xxx_GetServerBindingInfoOperation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Flags = op.Flags
}
func (o *GetServerBindingInfoRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetServerBindingInfoRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetServerBindingInfoOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetServerBindingInfoResponse structure represents the R_DhcpGetServerBindingInfo operation response
type GetServerBindingInfoResponse struct {
	// BindElementsInfo: This is a pointer of type LPDHCP_BIND_ELEMENT_ARRAY that points
	// to the location in which the information about the IPv4 interface binding is retrieved.
	BindElementsInfo *dhcpm.BindElementArray `idl:"name:BindElementsInfo" json:"bind_elements_info"`
	// Return: The R_DhcpGetServerBindingInfo return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetServerBindingInfoResponse) xxx_ToOp(ctx context.Context, op *xxx_GetServerBindingInfoOperation) *xxx_GetServerBindingInfoOperation {
	if op == nil {
		op = &xxx_GetServerBindingInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.BindElementsInfo = o.BindElementsInfo
	op.Return = o.Return
	return op
}

func (o *GetServerBindingInfoResponse) xxx_FromOp(ctx context.Context, op *xxx_GetServerBindingInfoOperation) {
	if o == nil {
		return
	}
	o.BindElementsInfo = op.BindElementsInfo
	o.Return = op.Return
}
func (o *GetServerBindingInfoResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetServerBindingInfoResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetServerBindingInfoOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetServerBindingInfoOperation structure represents the R_DhcpSetServerBindingInfo operation
type xxx_SetServerBindingInfoOperation struct {
	ServerIPAddress  string                  `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Flags            uint32                  `idl:"name:Flags" json:"flags"`
	BindElementsInfo *dhcpm.BindElementArray `idl:"name:BindElementsInfo;pointer:ref" json:"bind_elements_info"`
	Return           uint32                  `idl:"name:Return" json:"return"`
}

func (o *xxx_SetServerBindingInfoOperation) OpNum() int { return 41 }

func (o *xxx_SetServerBindingInfoOperation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpSetServerBindingInfo"
}

func (o *xxx_SetServerBindingInfoOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetServerBindingInfoOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	// BindElementsInfo {in} (1:{pointer=ref, alias=LPDHCP_BIND_ELEMENT_ARRAY}*(1))(2:{alias=DHCP_BIND_ELEMENT_ARRAY}(struct))
	{
		if o.BindElementsInfo != nil {
			if err := o.BindElementsInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.BindElementArray{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetServerBindingInfoOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	// BindElementsInfo {in} (1:{pointer=ref, alias=LPDHCP_BIND_ELEMENT_ARRAY}*(1))(2:{alias=DHCP_BIND_ELEMENT_ARRAY}(struct))
	{
		if o.BindElementsInfo == nil {
			o.BindElementsInfo = &dhcpm.BindElementArray{}
		}
		if err := o.BindElementsInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetServerBindingInfoOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetServerBindingInfoOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetServerBindingInfoOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetServerBindingInfoRequest structure represents the R_DhcpSetServerBindingInfo operation request
type SetServerBindingInfoRequest struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// Flags: This flag is not used, and it MUST be set to 0.
	Flags uint32 `idl:"name:Flags" json:"flags"`
	// BindElementsInfo: This is a pointer of type DHCP_BIND_ELEMENT_ARRAY (section 2.2.1.2.81)
	// that points to the location that contains the information about the IPv4 interface
	// binding.
	BindElementsInfo *dhcpm.BindElementArray `idl:"name:BindElementsInfo;pointer:ref" json:"bind_elements_info"`
}

func (o *SetServerBindingInfoRequest) xxx_ToOp(ctx context.Context, op *xxx_SetServerBindingInfoOperation) *xxx_SetServerBindingInfoOperation {
	if op == nil {
		op = &xxx_SetServerBindingInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Flags = o.Flags
	op.BindElementsInfo = o.BindElementsInfo
	return op
}

func (o *SetServerBindingInfoRequest) xxx_FromOp(ctx context.Context, op *xxx_SetServerBindingInfoOperation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Flags = op.Flags
	o.BindElementsInfo = op.BindElementsInfo
}
func (o *SetServerBindingInfoRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetServerBindingInfoRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetServerBindingInfoOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetServerBindingInfoResponse structure represents the R_DhcpSetServerBindingInfo operation response
type SetServerBindingInfoResponse struct {
	// Return: The R_DhcpSetServerBindingInfo return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetServerBindingInfoResponse) xxx_ToOp(ctx context.Context, op *xxx_SetServerBindingInfoOperation) *xxx_SetServerBindingInfoOperation {
	if op == nil {
		op = &xxx_SetServerBindingInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetServerBindingInfoResponse) xxx_FromOp(ctx context.Context, op *xxx_SetServerBindingInfoOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetServerBindingInfoResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetServerBindingInfoResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetServerBindingInfoOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_QueryDNSRegCredentialsOperation structure represents the R_DhcpQueryDnsRegCredentials operation
type xxx_QueryDNSRegCredentialsOperation struct {
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	UserNameSize    uint32 `idl:"name:UnameSize" json:"user_name_size"`
	UserName        string `idl:"name:Uname;size_is:(UnameSize)" json:"user_name"`
	DomainSize      uint32 `idl:"name:DomainSize" json:"domain_size"`
	Domain          string `idl:"name:Domain;size_is:(DomainSize)" json:"domain"`
	Return          uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_QueryDNSRegCredentialsOperation) OpNum() int { return 42 }

func (o *xxx_QueryDNSRegCredentialsOperation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpQueryDnsRegCredentials"
}

func (o *xxx_QueryDNSRegCredentialsOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.UserNameSize > uint32(1024) {
		return fmt.Errorf("UserNameSize is out of range")
	}
	if o.DomainSize > uint32(1024) {
		return fmt.Errorf("DomainSize is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryDNSRegCredentialsOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// UnameSize {in} (1:{range=(0,1024), alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.UserNameSize); err != nil {
			return err
		}
	}
	// DomainSize {in} (1:{range=(0,1024), alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.DomainSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryDNSRegCredentialsOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// UnameSize {in} (1:{range=(0,1024), alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.UserNameSize); err != nil {
			return err
		}
	}
	// DomainSize {in} (1:{range=(0,1024), alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.DomainSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryDNSRegCredentialsOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryDNSRegCredentialsOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Uname {out} (1:{pointer=ref}*(1)[dim:0,size_is=UnameSize,string](wchar))
	{
		dimSize1 := uint64(o.UserNameSize)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		_UserName_buf := utf16.Encode([]rune(o.UserName))
		if uint64(len(_UserName_buf)) > sizeInfo[0] {
			_UserName_buf = _UserName_buf[:sizeInfo[0]]
		}
		for i1 := range _UserName_buf {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(_UserName_buf[i1]); err != nil {
				return err
			}
		}
		for i1 := len(_UserName_buf); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint16(0)); err != nil {
				return err
			}
		}
	}
	// Domain {out} (1:{pointer=ref}*(1)[dim:0,size_is=DomainSize,string](wchar))
	{
		dimSize1 := uint64(o.DomainSize)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		_Domain_buf := utf16.Encode([]rune(o.Domain))
		if uint64(len(_Domain_buf)) > sizeInfo[0] {
			_Domain_buf = _Domain_buf[:sizeInfo[0]]
		}
		for i1 := range _Domain_buf {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(_Domain_buf[i1]); err != nil {
				return err
			}
		}
		for i1 := len(_Domain_buf); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint16(0)); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryDNSRegCredentialsOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Uname {out} (1:{pointer=ref}*(1)[dim:0,size_is=UnameSize,string](wchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		var _UserName_buf []uint16
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array _UserName_buf", sizeInfo[0])
		}
		_UserName_buf = make([]uint16, sizeInfo[0])
		for i1 := range _UserName_buf {
			i1 := i1
			if err := w.ReadData(&_UserName_buf[i1]); err != nil {
				return err
			}
		}
		o.UserName = strings.TrimRight(string(utf16.Decode(_UserName_buf)), ndr.ZeroString)
	}
	// Domain {out} (1:{pointer=ref}*(1)[dim:0,size_is=DomainSize,string](wchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		var _Domain_buf []uint16
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array _Domain_buf", sizeInfo[0])
		}
		_Domain_buf = make([]uint16, sizeInfo[0])
		for i1 := range _Domain_buf {
			i1 := i1
			if err := w.ReadData(&_Domain_buf[i1]); err != nil {
				return err
			}
		}
		o.Domain = strings.TrimRight(string(utf16.Decode(_Domain_buf)), ndr.ZeroString)
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// QueryDNSRegCredentialsRequest structure represents the R_DhcpQueryDnsRegCredentials operation request
type QueryDNSRegCredentialsRequest struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// UnameSize: This is of type ULONG, containing the length of the buffer pointed to
	// by Uname. The buffer length is defined at the RPC client and passed as an argument
	// to the RPC server.
	UserNameSize uint32 `idl:"name:UnameSize" json:"user_name_size"`
	// DomainSize: This is of type ULONG, containing the length of the buffer pointed to
	// by Domain. The buffer length is defined at the RPC client and passed as an argument
	// to the RPC server.
	DomainSize uint32 `idl:"name:DomainSize" json:"domain_size"`
}

func (o *QueryDNSRegCredentialsRequest) xxx_ToOp(ctx context.Context, op *xxx_QueryDNSRegCredentialsOperation) *xxx_QueryDNSRegCredentialsOperation {
	if op == nil {
		op = &xxx_QueryDNSRegCredentialsOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.UserNameSize = o.UserNameSize
	op.DomainSize = o.DomainSize
	return op
}

func (o *QueryDNSRegCredentialsRequest) xxx_FromOp(ctx context.Context, op *xxx_QueryDNSRegCredentialsOperation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.UserNameSize = op.UserNameSize
	o.DomainSize = op.DomainSize
}
func (o *QueryDNSRegCredentialsRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *QueryDNSRegCredentialsRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryDNSRegCredentialsOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// QueryDNSRegCredentialsResponse structure represents the R_DhcpQueryDnsRegCredentials operation response
type QueryDNSRegCredentialsResponse struct {
	// XXX: UnameSize is an implicit input depedency for output parameters
	UserNameSize uint32 `idl:"name:UnameSize" json:"user_name_size"`
	// XXX: DomainSize is an implicit input depedency for output parameters
	DomainSize uint32 `idl:"name:DomainSize" json:"domain_size"`

	// Uname:  A pointer to a null-terminated Unicode string in which the DHCP server returns
	// the user name for the DNS. The memory is allocated at the RPC client and passed to
	// the RPC server.
	UserName string `idl:"name:Uname;size_is:(UnameSize)" json:"user_name"`
	// Domain:  A pointer to a null-terminated Unicode string in which the DHCP server
	// returns the domain name for the DNS. The memory is allocated at the RPC client and
	// passed to the RPC server.
	Domain string `idl:"name:Domain;size_is:(DomainSize)" json:"domain"`
	// Return: The R_DhcpQueryDnsRegCredentials return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *QueryDNSRegCredentialsResponse) xxx_ToOp(ctx context.Context, op *xxx_QueryDNSRegCredentialsOperation) *xxx_QueryDNSRegCredentialsOperation {
	if op == nil {
		op = &xxx_QueryDNSRegCredentialsOperation{}
	}
	if o == nil {
		return op
	}
	// XXX: implicit input dependencies for output parameters
	if op.UserNameSize == uint32(0) {
		op.UserNameSize = o.UserNameSize
	}
	if op.DomainSize == uint32(0) {
		op.DomainSize = o.DomainSize
	}

	op.UserName = o.UserName
	op.Domain = o.Domain
	op.Return = o.Return
	return op
}

func (o *QueryDNSRegCredentialsResponse) xxx_FromOp(ctx context.Context, op *xxx_QueryDNSRegCredentialsOperation) {
	if o == nil {
		return
	}
	// XXX: implicit input dependencies for output parameters
	o.UserNameSize = op.UserNameSize
	o.DomainSize = op.DomainSize

	o.UserName = op.UserName
	o.Domain = op.Domain
	o.Return = op.Return
}
func (o *QueryDNSRegCredentialsResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *QueryDNSRegCredentialsResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryDNSRegCredentialsOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetDNSRegCredentialsOperation structure represents the R_DhcpSetDnsRegCredentials operation
type xxx_SetDNSRegCredentialsOperation struct {
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	UserName        string `idl:"name:Uname;string;pointer:unique" json:"user_name"`
	Domain          string `idl:"name:Domain;string;pointer:unique" json:"domain"`
	Password        string `idl:"name:Passwd;string;pointer:unique" json:"password"`
	Return          uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_SetDNSRegCredentialsOperation) OpNum() int { return 43 }

func (o *xxx_SetDNSRegCredentialsOperation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpSetDnsRegCredentials"
}

func (o *xxx_SetDNSRegCredentialsOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetDNSRegCredentialsOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Uname {in} (1:{string, pointer=unique, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.UserName != "" {
			_ptr_Uname := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.UserName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.UserName, _ptr_Uname); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Domain {in} (1:{string, pointer=unique, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.Domain != "" {
			_ptr_Domain := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.Domain); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.Domain, _ptr_Domain); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Passwd {in} (1:{string, pointer=unique, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.Password != "" {
			_ptr_Passwd := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.Password); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.Password, _ptr_Passwd); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetDNSRegCredentialsOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Uname {in} (1:{string, pointer=unique, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_Uname := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.UserName); err != nil {
				return err
			}
			return nil
		})
		_s_Uname := func(ptr interface{}) { o.UserName = *ptr.(*string) }
		if err := w.ReadPointer(&o.UserName, _s_Uname, _ptr_Uname); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Domain {in} (1:{string, pointer=unique, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_Domain := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.Domain); err != nil {
				return err
			}
			return nil
		})
		_s_Domain := func(ptr interface{}) { o.Domain = *ptr.(*string) }
		if err := w.ReadPointer(&o.Domain, _s_Domain, _ptr_Domain); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Passwd {in} (1:{string, pointer=unique, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_Passwd := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.Password); err != nil {
				return err
			}
			return nil
		})
		_s_Passwd := func(ptr interface{}) { o.Password = *ptr.(*string) }
		if err := w.ReadPointer(&o.Password, _s_Passwd, _ptr_Passwd); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetDNSRegCredentialsOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetDNSRegCredentialsOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetDNSRegCredentialsOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetDNSRegCredentialsRequest structure represents the R_DhcpSetDnsRegCredentials operation request
type SetDNSRegCredentialsRequest struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// Uname: A pointer to a null-terminated Unicode string that contains the user name
	// for the DNS credentials.
	UserName string `idl:"name:Uname;string;pointer:unique" json:"user_name"`
	// Domain: A pointer to a null-terminated Unicode string that contains the domain name
	// for the DNS credentials.
	Domain string `idl:"name:Domain;string;pointer:unique" json:"domain"`
	// Passwd: A pointer to a run-encoded, null-terminated Unicode string that contains
	// the password for the DNS user name.<53>
	Password string `idl:"name:Passwd;string;pointer:unique" json:"password"`
}

func (o *SetDNSRegCredentialsRequest) xxx_ToOp(ctx context.Context, op *xxx_SetDNSRegCredentialsOperation) *xxx_SetDNSRegCredentialsOperation {
	if op == nil {
		op = &xxx_SetDNSRegCredentialsOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.UserName = o.UserName
	op.Domain = o.Domain
	op.Password = o.Password
	return op
}

func (o *SetDNSRegCredentialsRequest) xxx_FromOp(ctx context.Context, op *xxx_SetDNSRegCredentialsOperation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.UserName = op.UserName
	o.Domain = op.Domain
	o.Password = op.Password
}
func (o *SetDNSRegCredentialsRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetDNSRegCredentialsRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetDNSRegCredentialsOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetDNSRegCredentialsResponse structure represents the R_DhcpSetDnsRegCredentials operation response
type SetDNSRegCredentialsResponse struct {
	// Return: The R_DhcpSetDnsRegCredentials return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetDNSRegCredentialsResponse) xxx_ToOp(ctx context.Context, op *xxx_SetDNSRegCredentialsOperation) *xxx_SetDNSRegCredentialsOperation {
	if op == nil {
		op = &xxx_SetDNSRegCredentialsOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetDNSRegCredentialsResponse) xxx_FromOp(ctx context.Context, op *xxx_SetDNSRegCredentialsOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetDNSRegCredentialsResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetDNSRegCredentialsResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetDNSRegCredentialsOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_BackupDatabaseOperation structure represents the R_DhcpBackupDatabase operation
type xxx_BackupDatabaseOperation struct {
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Path            string `idl:"name:Path;string" json:"path"`
	Return          uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_BackupDatabaseOperation) OpNum() int { return 44 }

func (o *xxx_BackupDatabaseOperation) OpName() string { return "/dhcpsrv2/v1/R_DhcpBackupDatabase" }

func (o *xxx_BackupDatabaseOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_BackupDatabaseOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Path {in} (1:{string, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.Path); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_BackupDatabaseOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Path {in} (1:{string, alias=LPWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.Path); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_BackupDatabaseOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_BackupDatabaseOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_BackupDatabaseOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// BackupDatabaseRequest structure represents the R_DhcpBackupDatabase operation request
type BackupDatabaseRequest struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// Path: A pointer to a null-terminated Unicode string that contains the path name where
	// the backup for the configurations, settings, and DHCP client lease record is taken.
	Path string `idl:"name:Path;string" json:"path"`
}

func (o *BackupDatabaseRequest) xxx_ToOp(ctx context.Context, op *xxx_BackupDatabaseOperation) *xxx_BackupDatabaseOperation {
	if op == nil {
		op = &xxx_BackupDatabaseOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Path = o.Path
	return op
}

func (o *BackupDatabaseRequest) xxx_FromOp(ctx context.Context, op *xxx_BackupDatabaseOperation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Path = op.Path
}
func (o *BackupDatabaseRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *BackupDatabaseRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_BackupDatabaseOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// BackupDatabaseResponse structure represents the R_DhcpBackupDatabase operation response
type BackupDatabaseResponse struct {
	// Return: The R_DhcpBackupDatabase return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *BackupDatabaseResponse) xxx_ToOp(ctx context.Context, op *xxx_BackupDatabaseOperation) *xxx_BackupDatabaseOperation {
	if op == nil {
		op = &xxx_BackupDatabaseOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *BackupDatabaseResponse) xxx_FromOp(ctx context.Context, op *xxx_BackupDatabaseOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *BackupDatabaseResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *BackupDatabaseResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_BackupDatabaseOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_RestoreDatabaseOperation structure represents the R_DhcpRestoreDatabase operation
type xxx_RestoreDatabaseOperation struct {
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Path            string `idl:"name:Path;string" json:"path"`
	Return          uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_RestoreDatabaseOperation) OpNum() int { return 45 }

func (o *xxx_RestoreDatabaseOperation) OpName() string { return "/dhcpsrv2/v1/R_DhcpRestoreDatabase" }

func (o *xxx_RestoreDatabaseOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RestoreDatabaseOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Path {in} (1:{string, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.Path); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RestoreDatabaseOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Path {in} (1:{string, alias=LPWSTR,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.Path); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RestoreDatabaseOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RestoreDatabaseOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RestoreDatabaseOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// RestoreDatabaseRequest structure represents the R_DhcpRestoreDatabase operation request
type RestoreDatabaseRequest struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// Path: A pointer to a null-terminated Unicode string that contains the name of the
	// new restore path where the registry configuration and the DHCP database are restored.
	Path string `idl:"name:Path;string" json:"path"`
}

func (o *RestoreDatabaseRequest) xxx_ToOp(ctx context.Context, op *xxx_RestoreDatabaseOperation) *xxx_RestoreDatabaseOperation {
	if op == nil {
		op = &xxx_RestoreDatabaseOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Path = o.Path
	return op
}

func (o *RestoreDatabaseRequest) xxx_FromOp(ctx context.Context, op *xxx_RestoreDatabaseOperation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Path = op.Path
}
func (o *RestoreDatabaseRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *RestoreDatabaseRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RestoreDatabaseOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// RestoreDatabaseResponse structure represents the R_DhcpRestoreDatabase operation response
type RestoreDatabaseResponse struct {
	// Return: The R_DhcpRestoreDatabase return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *RestoreDatabaseResponse) xxx_ToOp(ctx context.Context, op *xxx_RestoreDatabaseOperation) *xxx_RestoreDatabaseOperation {
	if op == nil {
		op = &xxx_RestoreDatabaseOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *RestoreDatabaseResponse) xxx_FromOp(ctx context.Context, op *xxx_RestoreDatabaseOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *RestoreDatabaseResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *RestoreDatabaseResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RestoreDatabaseOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetServerSpecificStringsOperation structure represents the R_DhcpGetServerSpecificStrings operation
type xxx_GetServerSpecificStringsOperation struct {
	ServerIPAddress       string                       `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	ServerSpecificStrings *dhcpm.ServerSpecificStrings `idl:"name:ServerSpecificStrings" json:"server_specific_strings"`
	Return                uint32                       `idl:"name:Return" json:"return"`
}

func (o *xxx_GetServerSpecificStringsOperation) OpNum() int { return 46 }

func (o *xxx_GetServerSpecificStringsOperation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpGetServerSpecificStrings"
}

func (o *xxx_GetServerSpecificStringsOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServerSpecificStringsOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServerSpecificStringsOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServerSpecificStringsOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServerSpecificStringsOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ServerSpecificStrings {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_SERVER_SPECIFIC_STRINGS}*(1))(3:{alias=DHCP_SERVER_SPECIFIC_STRINGS}(struct))
	{
		if o.ServerSpecificStrings != nil {
			_ptr_ServerSpecificStrings := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.ServerSpecificStrings != nil {
					if err := o.ServerSpecificStrings.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.ServerSpecificStrings{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerSpecificStrings, _ptr_ServerSpecificStrings); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServerSpecificStringsOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ServerSpecificStrings {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_SERVER_SPECIFIC_STRINGS,pointer=ref}*(1))(3:{alias=DHCP_SERVER_SPECIFIC_STRINGS}(struct))
	{
		_ptr_ServerSpecificStrings := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.ServerSpecificStrings == nil {
				o.ServerSpecificStrings = &dhcpm.ServerSpecificStrings{}
			}
			if err := o.ServerSpecificStrings.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ServerSpecificStrings := func(ptr interface{}) { o.ServerSpecificStrings = *ptr.(**dhcpm.ServerSpecificStrings) }
		if err := w.ReadPointer(&o.ServerSpecificStrings, _s_ServerSpecificStrings, _ptr_ServerSpecificStrings); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetServerSpecificStringsRequest structure represents the R_DhcpGetServerSpecificStrings operation request
type GetServerSpecificStringsRequest struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
}

func (o *GetServerSpecificStringsRequest) xxx_ToOp(ctx context.Context, op *xxx_GetServerSpecificStringsOperation) *xxx_GetServerSpecificStringsOperation {
	if op == nil {
		op = &xxx_GetServerSpecificStringsOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	return op
}

func (o *GetServerSpecificStringsRequest) xxx_FromOp(ctx context.Context, op *xxx_GetServerSpecificStringsOperation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
}
func (o *GetServerSpecificStringsRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetServerSpecificStringsRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetServerSpecificStringsOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetServerSpecificStringsResponse structure represents the R_DhcpGetServerSpecificStrings operation response
type GetServerSpecificStringsResponse struct {
	// ServerSpecificStrings: This is a pointer of type LPDHCP_SERVER_SPECIFIC_STRINGS (section
	// 2.2.1.2.77) that points to a location that contains information regarding the default
	// vendor class and user class.
	ServerSpecificStrings *dhcpm.ServerSpecificStrings `idl:"name:ServerSpecificStrings" json:"server_specific_strings"`
	// Return: The R_DhcpGetServerSpecificStrings return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetServerSpecificStringsResponse) xxx_ToOp(ctx context.Context, op *xxx_GetServerSpecificStringsOperation) *xxx_GetServerSpecificStringsOperation {
	if op == nil {
		op = &xxx_GetServerSpecificStringsOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerSpecificStrings = o.ServerSpecificStrings
	op.Return = o.Return
	return op
}

func (o *GetServerSpecificStringsResponse) xxx_FromOp(ctx context.Context, op *xxx_GetServerSpecificStringsOperation) {
	if o == nil {
		return
	}
	o.ServerSpecificStrings = op.ServerSpecificStrings
	o.Return = op.Return
}
func (o *GetServerSpecificStringsResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetServerSpecificStringsResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetServerSpecificStringsOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CreateOptionV6Operation structure represents the R_DhcpCreateOptionV6 operation
type xxx_CreateOptionV6Operation struct {
	ServerIPAddress string        `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Flags           uint32        `idl:"name:Flags" json:"flags"`
	OptionID        uint32        `idl:"name:OptionId" json:"option_id"`
	ClassName       string        `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
	VendorName      string        `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	OptionInfo      *dhcpm.Option `idl:"name:OptionInfo" json:"option_info"`
	Return          uint32        `idl:"name:Return" json:"return"`
}

func (o *xxx_CreateOptionV6Operation) OpNum() int { return 47 }

func (o *xxx_CreateOptionV6Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpCreateOptionV6" }

func (o *xxx_CreateOptionV6Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateOptionV6Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	// OptionId {in} (1:{alias=DHCP_OPTION_ID, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.OptionID); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.ClassName != "" {
			_ptr_ClassName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ClassName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ClassName, _ptr_ClassName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.VendorName != "" {
			_ptr_VendorName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.VendorName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.VendorName, _ptr_VendorName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// OptionInfo {in} (1:{alias=LPDHCP_OPTION}*(1))(2:{alias=DHCP_OPTION}(struct))
	{
		if o.OptionInfo != nil {
			if err := o.OptionInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.Option{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateOptionV6Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	// OptionId {in} (1:{alias=DHCP_OPTION_ID, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OptionID); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_ClassName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ClassName); err != nil {
				return err
			}
			return nil
		})
		_s_ClassName := func(ptr interface{}) { o.ClassName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ClassName, _s_ClassName, _ptr_ClassName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_VendorName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.VendorName); err != nil {
				return err
			}
			return nil
		})
		_s_VendorName := func(ptr interface{}) { o.VendorName = *ptr.(*string) }
		if err := w.ReadPointer(&o.VendorName, _s_VendorName, _ptr_VendorName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// OptionInfo {in} (1:{alias=LPDHCP_OPTION,pointer=ref}*(1))(2:{alias=DHCP_OPTION}(struct))
	{
		if o.OptionInfo == nil {
			o.OptionInfo = &dhcpm.Option{}
		}
		if err := o.OptionInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateOptionV6Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateOptionV6Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateOptionV6Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CreateOptionV6Request structure represents the R_DhcpCreateOptionV6 operation request
type CreateOptionV6Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// Flags: This is of type DWORD, specifying that the option definition is created for
	// a specific or default vendor class.
	//
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                        |                                                                                  |
	//	|                 VALUE                  |                                     MEANING                                      |
	//	|                                        |                                                                                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_DEFAULT 0x00000000   | Option definition is created for the default vendor class.                       |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_IS_VENDOR 0x00000003 | If a bitwise AND operation with this bitmask yields a nonzero value, it          |
	//	|                                        | indicates that the option definition is created for a specific vendor class.     |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	Flags uint32 `idl:"name:Flags" json:"flags"`
	// OptionId: This is of type DHCP_OPTION_ID (section 2.2.1.2.3), containing the option
	// identifier for the option being created.
	OptionID uint32 `idl:"name:OptionId" json:"option_id"`
	// ClassName: A pointer to a null-terminated Unicode string that contains the name of
	// the user class for which the option definition is created. This parameter is optional.
	ClassName string `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
	// VendorName: A pointer to a null-terminated Unicode string that contains the name
	// of the vendor class for which the option definition is created. This parameter is
	// optional. If vendor class name is not specified, then the option definition is created
	// for the default vendor class.
	VendorName string `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	// OptionInfo: This is a pointer to a DHCP_OPTION (section 2.2.1.2.25) structure that
	// contains the information about the option definition.
	OptionInfo *dhcpm.Option `idl:"name:OptionInfo" json:"option_info"`
}

func (o *CreateOptionV6Request) xxx_ToOp(ctx context.Context, op *xxx_CreateOptionV6Operation) *xxx_CreateOptionV6Operation {
	if op == nil {
		op = &xxx_CreateOptionV6Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Flags = o.Flags
	op.OptionID = o.OptionID
	op.ClassName = o.ClassName
	op.VendorName = o.VendorName
	op.OptionInfo = o.OptionInfo
	return op
}

func (o *CreateOptionV6Request) xxx_FromOp(ctx context.Context, op *xxx_CreateOptionV6Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Flags = op.Flags
	o.OptionID = op.OptionID
	o.ClassName = op.ClassName
	o.VendorName = op.VendorName
	o.OptionInfo = op.OptionInfo
}
func (o *CreateOptionV6Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *CreateOptionV6Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateOptionV6Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CreateOptionV6Response structure represents the R_DhcpCreateOptionV6 operation response
type CreateOptionV6Response struct {
	// Return: The R_DhcpCreateOptionV6 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CreateOptionV6Response) xxx_ToOp(ctx context.Context, op *xxx_CreateOptionV6Operation) *xxx_CreateOptionV6Operation {
	if op == nil {
		op = &xxx_CreateOptionV6Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *CreateOptionV6Response) xxx_FromOp(ctx context.Context, op *xxx_CreateOptionV6Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *CreateOptionV6Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *CreateOptionV6Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateOptionV6Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetOptionInfoV6Operation structure represents the R_DhcpSetOptionInfoV6 operation
type xxx_SetOptionInfoV6Operation struct {
	ServerIPAddress string        `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Flags           uint32        `idl:"name:Flags" json:"flags"`
	OptionID        uint32        `idl:"name:OptionID" json:"option_id"`
	ClassName       string        `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
	VendorName      string        `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	OptionInfo      *dhcpm.Option `idl:"name:OptionInfo" json:"option_info"`
	Return          uint32        `idl:"name:Return" json:"return"`
}

func (o *xxx_SetOptionInfoV6Operation) OpNum() int { return 48 }

func (o *xxx_SetOptionInfoV6Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpSetOptionInfoV6" }

func (o *xxx_SetOptionInfoV6Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOptionInfoV6Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	// OptionID {in} (1:{alias=DHCP_OPTION_ID, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.OptionID); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.ClassName != "" {
			_ptr_ClassName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ClassName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ClassName, _ptr_ClassName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.VendorName != "" {
			_ptr_VendorName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.VendorName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.VendorName, _ptr_VendorName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// OptionInfo {in} (1:{alias=LPDHCP_OPTION}*(1))(2:{alias=DHCP_OPTION}(struct))
	{
		if o.OptionInfo != nil {
			if err := o.OptionInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.Option{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOptionInfoV6Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	// OptionID {in} (1:{alias=DHCP_OPTION_ID, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OptionID); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_ClassName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ClassName); err != nil {
				return err
			}
			return nil
		})
		_s_ClassName := func(ptr interface{}) { o.ClassName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ClassName, _s_ClassName, _ptr_ClassName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_VendorName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.VendorName); err != nil {
				return err
			}
			return nil
		})
		_s_VendorName := func(ptr interface{}) { o.VendorName = *ptr.(*string) }
		if err := w.ReadPointer(&o.VendorName, _s_VendorName, _ptr_VendorName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// OptionInfo {in} (1:{alias=LPDHCP_OPTION,pointer=ref}*(1))(2:{alias=DHCP_OPTION}(struct))
	{
		if o.OptionInfo == nil {
			o.OptionInfo = &dhcpm.Option{}
		}
		if err := o.OptionInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOptionInfoV6Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOptionInfoV6Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOptionInfoV6Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetOptionInfoV6Request structure represents the R_DhcpSetOptionInfoV6 operation request
type SetOptionInfoV6Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// Flags: This is of type DWORD that specifies that the option definition is modified
	// for a specific or default vendor class.
	//
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                        |                                                                                  |
	//	|                 VALUE                  |                                     MEANING                                      |
	//	|                                        |                                                                                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_DEFAULT 0x00000000   | Option is modified for a default vendor class.                                   |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_IS_VENDOR 0x00000003 | If a bitwise AND operation with this bitmask yields a nonzero value, it          |
	//	|                                        | indicates that the option is modified for a specific vendor class.               |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	Flags uint32 `idl:"name:Flags" json:"flags"`
	// OptionID: This is of type DHCP_OPTION_ID (section 2.2.1.2.3), containing the option
	// identifier for the option definition being modified.
	OptionID uint32 `idl:"name:OptionID" json:"option_id"`
	// ClassName: A pointer to a null-terminated Unicode string that contains the name of
	// the user class to which the option definition is modified. This parameter is optional.
	ClassName string `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
	// VendorName: A pointer to a null-terminated Unicode string that contains the name
	// of the vendor class to which the option definition is modified. This parameter is
	// optional, and if vendor class is not specified, the option definition is created
	// for the default vendor class.
	VendorName string `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	// OptionInfo: This is a pointer of type DHCP_OPTION (section 2.2.1.2.25) that contains
	// the new option definition for the option being modified.
	OptionInfo *dhcpm.Option `idl:"name:OptionInfo" json:"option_info"`
}

func (o *SetOptionInfoV6Request) xxx_ToOp(ctx context.Context, op *xxx_SetOptionInfoV6Operation) *xxx_SetOptionInfoV6Operation {
	if op == nil {
		op = &xxx_SetOptionInfoV6Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Flags = o.Flags
	op.OptionID = o.OptionID
	op.ClassName = o.ClassName
	op.VendorName = o.VendorName
	op.OptionInfo = o.OptionInfo
	return op
}

func (o *SetOptionInfoV6Request) xxx_FromOp(ctx context.Context, op *xxx_SetOptionInfoV6Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Flags = op.Flags
	o.OptionID = op.OptionID
	o.ClassName = op.ClassName
	o.VendorName = op.VendorName
	o.OptionInfo = op.OptionInfo
}
func (o *SetOptionInfoV6Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetOptionInfoV6Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetOptionInfoV6Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetOptionInfoV6Response structure represents the R_DhcpSetOptionInfoV6 operation response
type SetOptionInfoV6Response struct {
	// Return: The R_DhcpSetOptionInfoV6 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetOptionInfoV6Response) xxx_ToOp(ctx context.Context, op *xxx_SetOptionInfoV6Operation) *xxx_SetOptionInfoV6Operation {
	if op == nil {
		op = &xxx_SetOptionInfoV6Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetOptionInfoV6Response) xxx_FromOp(ctx context.Context, op *xxx_SetOptionInfoV6Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetOptionInfoV6Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetOptionInfoV6Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetOptionInfoV6Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetOptionInfoV6Operation structure represents the R_DhcpGetOptionInfoV6 operation
type xxx_GetOptionInfoV6Operation struct {
	ServerIPAddress string        `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Flags           uint32        `idl:"name:Flags" json:"flags"`
	OptionID        uint32        `idl:"name:OptionID" json:"option_id"`
	ClassName       string        `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
	VendorName      string        `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	OptionInfo      *dhcpm.Option `idl:"name:OptionInfo" json:"option_info"`
	Return          uint32        `idl:"name:Return" json:"return"`
}

func (o *xxx_GetOptionInfoV6Operation) OpNum() int { return 49 }

func (o *xxx_GetOptionInfoV6Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpGetOptionInfoV6" }

func (o *xxx_GetOptionInfoV6Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetOptionInfoV6Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	// OptionID {in} (1:{alias=DHCP_OPTION_ID, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.OptionID); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.ClassName != "" {
			_ptr_ClassName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ClassName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ClassName, _ptr_ClassName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.VendorName != "" {
			_ptr_VendorName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.VendorName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.VendorName, _ptr_VendorName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetOptionInfoV6Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	// OptionID {in} (1:{alias=DHCP_OPTION_ID, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OptionID); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_ClassName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ClassName); err != nil {
				return err
			}
			return nil
		})
		_s_ClassName := func(ptr interface{}) { o.ClassName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ClassName, _s_ClassName, _ptr_ClassName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_VendorName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.VendorName); err != nil {
				return err
			}
			return nil
		})
		_s_VendorName := func(ptr interface{}) { o.VendorName = *ptr.(*string) }
		if err := w.ReadPointer(&o.VendorName, _s_VendorName, _ptr_VendorName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetOptionInfoV6Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetOptionInfoV6Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// OptionInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_OPTION}*(1))(3:{alias=DHCP_OPTION}(struct))
	{
		if o.OptionInfo != nil {
			_ptr_OptionInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.OptionInfo != nil {
					if err := o.OptionInfo.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.Option{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.OptionInfo, _ptr_OptionInfo); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetOptionInfoV6Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// OptionInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_OPTION,pointer=ref}*(1))(3:{alias=DHCP_OPTION}(struct))
	{
		_ptr_OptionInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.OptionInfo == nil {
				o.OptionInfo = &dhcpm.Option{}
			}
			if err := o.OptionInfo.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_OptionInfo := func(ptr interface{}) { o.OptionInfo = *ptr.(**dhcpm.Option) }
		if err := w.ReadPointer(&o.OptionInfo, _s_OptionInfo, _ptr_OptionInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetOptionInfoV6Request structure represents the R_DhcpGetOptionInfoV6 operation request
type GetOptionInfoV6Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// Flags: This is of type DWORD that specifies that the option definition is retrieved
	// for a specific or default vendor class.
	//
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                        |                                                                                  |
	//	|                 VALUE                  |                                     MEANING                                      |
	//	|                                        |                                                                                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_DEFAULT 0x00000000   | Option definition is retrieved for the default vendor class.                     |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_IS_VENDOR 0x00000003 | If a bitwise AND operation with this bitmask yields a nonzero value, it          |
	//	|                                        | indicates that the option definition is retrieved for a specific vendor class.   |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	Flags uint32 `idl:"name:Flags" json:"flags"`
	// OptionID: This is of type DHCP_OPTION_ID (section 2.2.1.2.3), containing the option
	// identifier for the option definition being retrieved.
	OptionID uint32 `idl:"name:OptionID" json:"option_id"`
	// ClassName: A pointer to a null-terminated Unicode string that contains the name of
	// the user class for which the option definition is retrieved. This parameter is optional.
	ClassName string `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
	// VendorName: A pointer to a null-terminated Unicode string that contains the name
	// of the vendor class for which the option definition is retrieved. This parameter
	// is optional. If the vendor class name is not specified, the option definition is
	// retrieved for the default vendor class.
	VendorName string `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
}

func (o *GetOptionInfoV6Request) xxx_ToOp(ctx context.Context, op *xxx_GetOptionInfoV6Operation) *xxx_GetOptionInfoV6Operation {
	if op == nil {
		op = &xxx_GetOptionInfoV6Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Flags = o.Flags
	op.OptionID = o.OptionID
	op.ClassName = o.ClassName
	op.VendorName = o.VendorName
	return op
}

func (o *GetOptionInfoV6Request) xxx_FromOp(ctx context.Context, op *xxx_GetOptionInfoV6Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Flags = op.Flags
	o.OptionID = op.OptionID
	o.ClassName = op.ClassName
	o.VendorName = op.VendorName
}
func (o *GetOptionInfoV6Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetOptionInfoV6Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetOptionInfoV6Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetOptionInfoV6Response structure represents the R_DhcpGetOptionInfoV6 operation response
type GetOptionInfoV6Response struct {
	// OptionInfo: This is a pointer of type LPDHCP_OPTION (section 2.2.1.2.25) in which
	// the option definition for the option is retrieved.
	OptionInfo *dhcpm.Option `idl:"name:OptionInfo" json:"option_info"`
	// Return: The R_DhcpGetOptionInfoV6 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetOptionInfoV6Response) xxx_ToOp(ctx context.Context, op *xxx_GetOptionInfoV6Operation) *xxx_GetOptionInfoV6Operation {
	if op == nil {
		op = &xxx_GetOptionInfoV6Operation{}
	}
	if o == nil {
		return op
	}
	op.OptionInfo = o.OptionInfo
	op.Return = o.Return
	return op
}

func (o *GetOptionInfoV6Response) xxx_FromOp(ctx context.Context, op *xxx_GetOptionInfoV6Operation) {
	if o == nil {
		return
	}
	o.OptionInfo = op.OptionInfo
	o.Return = op.Return
}
func (o *GetOptionInfoV6Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetOptionInfoV6Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetOptionInfoV6Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumOptionsV6Operation structure represents the R_DhcpEnumOptionsV6 operation
type xxx_EnumOptionsV6Operation struct {
	ServerIPAddress  string             `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Flags            uint32             `idl:"name:Flags" json:"flags"`
	ClassName        string             `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
	VendorName       string             `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	Resume           uint32             `idl:"name:ResumeHandle" json:"resume"`
	PreferredMaximum uint32             `idl:"name:PreferredMaximum" json:"preferred_maximum"`
	Options          *dhcpm.OptionArray `idl:"name:Options" json:"options"`
	OptionsRead      uint32             `idl:"name:OptionsRead" json:"options_read"`
	OptionsTotal     uint32             `idl:"name:OptionsTotal" json:"options_total"`
	Return           uint32             `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumOptionsV6Operation) OpNum() int { return 50 }

func (o *xxx_EnumOptionsV6Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpEnumOptionsV6" }

func (o *xxx_EnumOptionsV6Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumOptionsV6Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.ClassName != "" {
			_ptr_ClassName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ClassName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ClassName, _ptr_ClassName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.VendorName != "" {
			_ptr_VendorName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.VendorName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.VendorName, _ptr_VendorName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Resume); err != nil {
			return err
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PreferredMaximum); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumOptionsV6Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_ClassName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ClassName); err != nil {
				return err
			}
			return nil
		})
		_s_ClassName := func(ptr interface{}) { o.ClassName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ClassName, _s_ClassName, _ptr_ClassName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_VendorName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.VendorName); err != nil {
				return err
			}
			return nil
		})
		_s_VendorName := func(ptr interface{}) { o.VendorName = *ptr.(*string) }
		if err := w.ReadPointer(&o.VendorName, _s_VendorName, _ptr_VendorName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Resume); err != nil {
			return err
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PreferredMaximum); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumOptionsV6Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumOptionsV6Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Resume); err != nil {
			return err
		}
	}
	// Options {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_OPTION_ARRAY}*(1))(3:{alias=DHCP_OPTION_ARRAY}(struct))
	{
		if o.Options != nil {
			_ptr_Options := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Options != nil {
					if err := o.Options.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.OptionArray{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Options, _ptr_Options); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// OptionsRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OptionsRead); err != nil {
			return err
		}
	}
	// OptionsTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OptionsTotal); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumOptionsV6Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Resume); err != nil {
			return err
		}
	}
	// Options {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_OPTION_ARRAY,pointer=ref}*(1))(3:{alias=DHCP_OPTION_ARRAY}(struct))
	{
		_ptr_Options := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Options == nil {
				o.Options = &dhcpm.OptionArray{}
			}
			if err := o.Options.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_Options := func(ptr interface{}) { o.Options = *ptr.(**dhcpm.OptionArray) }
		if err := w.ReadPointer(&o.Options, _s_Options, _ptr_Options); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// OptionsRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OptionsRead); err != nil {
			return err
		}
	}
	// OptionsTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OptionsTotal); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumOptionsV6Request structure represents the R_DhcpEnumOptionsV6 operation request
type EnumOptionsV6Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// Flags: This is of type DWORD, specifying that the option definition is enumerated
	// for a specific or default vendor class.
	//
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                        |                                                                                  |
	//	|                 VALUE                  |                                     MEANING                                      |
	//	|                                        |                                                                                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_DEFAULT 0x00000000   | Option definition is enumerated for a default vendor class.                      |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_IS_VENDOR 0x00000003 | If a bitwise AND operation with this bitmask yields a nonzero value, it          |
	//	|                                        | indicates that the option definition is enumerated for a specific vendor class.  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	Flags uint32 `idl:"name:Flags" json:"flags"`
	// ClassName: A pointer to a null-terminated Unicode string that contains the name of
	// the user class for which the option definition is enumerated. This parameter is optional.
	ClassName string `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
	// VendorName: A pointer to a null-terminated Unicode string that contains the name
	// of the vendor class for which the option definition is enumerated. This parameter
	// is optional. If the vendor class name is not specified, the option definition is
	// enumerated for the default vendor class.
	VendorName string `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	// ResumeHandle: This is a pointer of type DHCP_RESUME_HANDLE (section 2.2.1.2.6) that
	// identifies the enumeration operation. Initially, this value MUST be set to zero,
	// with a successful call returning the handle value used for subsequent enumeration
	// requests. For example, if PreferredMaximum is set to 1,000 bytes, and 2,000 bytes'
	// worth of option definitions are stored on the DHCPv6 server, the resume handle can
	// be used after the first 1,000 bytes are retrieved to obtain the next 1,000 on a subsequent
	// call, and so forth.
	Resume uint32 `idl:"name:ResumeHandle" json:"resume"`
	// PreferredMaximum: This is of type DWORD, specifying the preferred maximum number
	// of bytes to return. If the number of remaining unenumerated option definitions (in
	// bytes) is less than this value, all option definitions are returned. To retrieve
	// option definitions for a specific user and vendor class, 0xFFFFFFFF is specified.
	PreferredMaximum uint32 `idl:"name:PreferredMaximum" json:"preferred_maximum"`
}

func (o *EnumOptionsV6Request) xxx_ToOp(ctx context.Context, op *xxx_EnumOptionsV6Operation) *xxx_EnumOptionsV6Operation {
	if op == nil {
		op = &xxx_EnumOptionsV6Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Flags = o.Flags
	op.ClassName = o.ClassName
	op.VendorName = o.VendorName
	op.Resume = o.Resume
	op.PreferredMaximum = o.PreferredMaximum
	return op
}

func (o *EnumOptionsV6Request) xxx_FromOp(ctx context.Context, op *xxx_EnumOptionsV6Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Flags = op.Flags
	o.ClassName = op.ClassName
	o.VendorName = op.VendorName
	o.Resume = op.Resume
	o.PreferredMaximum = op.PreferredMaximum
}
func (o *EnumOptionsV6Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumOptionsV6Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumOptionsV6Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumOptionsV6Response structure represents the R_DhcpEnumOptionsV6 operation response
type EnumOptionsV6Response struct {
	// ResumeHandle: This is a pointer of type DHCP_RESUME_HANDLE (section 2.2.1.2.6) that
	// identifies the enumeration operation. Initially, this value MUST be set to zero,
	// with a successful call returning the handle value used for subsequent enumeration
	// requests. For example, if PreferredMaximum is set to 1,000 bytes, and 2,000 bytes'
	// worth of option definitions are stored on the DHCPv6 server, the resume handle can
	// be used after the first 1,000 bytes are retrieved to obtain the next 1,000 on a subsequent
	// call, and so forth.
	Resume uint32 `idl:"name:ResumeHandle" json:"resume"`
	// Options: This is a pointer of type LPDHCP_OPTION_ARRAY that points to the location
	// where all the option definitions for a specific user and vendor class are retrieved
	// from the DHCPv6 server.
	Options *dhcpm.OptionArray `idl:"name:Options" json:"options"`
	// OptionsRead: This is a pointer to a DWORD value that specifies the number of option
	// definitions read in Options. The caller MUST allocate memory for this parameter equal
	// to the size of data type DWORD.
	OptionsRead uint32 `idl:"name:OptionsRead" json:"options_read"`
	// OptionsTotal: This is a pointer to a DWORD value that specifies the number of option
	// definitions that have not yet been enumerated. The caller MUST allocate memory for
	// this parameter that is equal to the size of data type DWORD.
	OptionsTotal uint32 `idl:"name:OptionsTotal" json:"options_total"`
	// Return: The R_DhcpEnumOptionsV6 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumOptionsV6Response) xxx_ToOp(ctx context.Context, op *xxx_EnumOptionsV6Operation) *xxx_EnumOptionsV6Operation {
	if op == nil {
		op = &xxx_EnumOptionsV6Operation{}
	}
	if o == nil {
		return op
	}
	op.Resume = o.Resume
	op.Options = o.Options
	op.OptionsRead = o.OptionsRead
	op.OptionsTotal = o.OptionsTotal
	op.Return = o.Return
	return op
}

func (o *EnumOptionsV6Response) xxx_FromOp(ctx context.Context, op *xxx_EnumOptionsV6Operation) {
	if o == nil {
		return
	}
	o.Resume = op.Resume
	o.Options = op.Options
	o.OptionsRead = op.OptionsRead
	o.OptionsTotal = op.OptionsTotal
	o.Return = op.Return
}
func (o *EnumOptionsV6Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumOptionsV6Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumOptionsV6Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_RemoveOptionV6Operation structure represents the R_DhcpRemoveOptionV6 operation
type xxx_RemoveOptionV6Operation struct {
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Flags           uint32 `idl:"name:Flags" json:"flags"`
	OptionID        uint32 `idl:"name:OptionID" json:"option_id"`
	ClassName       string `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
	VendorName      string `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	Return          uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_RemoveOptionV6Operation) OpNum() int { return 51 }

func (o *xxx_RemoveOptionV6Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpRemoveOptionV6" }

func (o *xxx_RemoveOptionV6Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveOptionV6Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	// OptionID {in} (1:{alias=DHCP_OPTION_ID, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.OptionID); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.ClassName != "" {
			_ptr_ClassName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ClassName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ClassName, _ptr_ClassName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.VendorName != "" {
			_ptr_VendorName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.VendorName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.VendorName, _ptr_VendorName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveOptionV6Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	// OptionID {in} (1:{alias=DHCP_OPTION_ID, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OptionID); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_ClassName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ClassName); err != nil {
				return err
			}
			return nil
		})
		_s_ClassName := func(ptr interface{}) { o.ClassName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ClassName, _s_ClassName, _ptr_ClassName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_VendorName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.VendorName); err != nil {
				return err
			}
			return nil
		})
		_s_VendorName := func(ptr interface{}) { o.VendorName = *ptr.(*string) }
		if err := w.ReadPointer(&o.VendorName, _s_VendorName, _ptr_VendorName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveOptionV6Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveOptionV6Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveOptionV6Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// RemoveOptionV6Request structure represents the R_DhcpRemoveOptionV6 operation request
type RemoveOptionV6Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// Flags: This is of type DWORD, specifying that the option definition is removed for
	// a specific or default vendor class.
	//
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                        |                                                                                  |
	//	|                 VALUE                  |                                     MEANING                                      |
	//	|                                        |                                                                                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_DEFAULT 0x00000000   | Option definition is removed for a default vendor class.                         |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_IS_VENDOR 0x00000003 | If a bitwise AND operation with this bitmask yields a nonzero value, it          |
	//	|                                        | indicates that the option definition is removed for a specific vendor class.     |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	Flags uint32 `idl:"name:Flags" json:"flags"`
	// OptionID: This is of type DHCP_OPTION_ID (section 2.2.1.2.3), containing the option
	// identifier of the option definition which is being deleted.
	OptionID uint32 `idl:"name:OptionID" json:"option_id"`
	// ClassName: A pointer to a null-terminated Unicode string that contains the name of
	// the user class for which the option definition is removed. This parameter is optional.
	ClassName string `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
	// VendorName: A pointer to a null-terminated Unicode string that contains the name
	// of the vendor class for which the option definition is removed. This parameter is
	// optional, and if the vendor class name is not specified, the option definition is
	// removed for the default vendor class.
	VendorName string `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
}

func (o *RemoveOptionV6Request) xxx_ToOp(ctx context.Context, op *xxx_RemoveOptionV6Operation) *xxx_RemoveOptionV6Operation {
	if op == nil {
		op = &xxx_RemoveOptionV6Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Flags = o.Flags
	op.OptionID = o.OptionID
	op.ClassName = o.ClassName
	op.VendorName = o.VendorName
	return op
}

func (o *RemoveOptionV6Request) xxx_FromOp(ctx context.Context, op *xxx_RemoveOptionV6Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Flags = op.Flags
	o.OptionID = op.OptionID
	o.ClassName = op.ClassName
	o.VendorName = op.VendorName
}
func (o *RemoveOptionV6Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *RemoveOptionV6Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemoveOptionV6Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// RemoveOptionV6Response structure represents the R_DhcpRemoveOptionV6 operation response
type RemoveOptionV6Response struct {
	// Return: The R_DhcpRemoveOptionV6 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *RemoveOptionV6Response) xxx_ToOp(ctx context.Context, op *xxx_RemoveOptionV6Operation) *xxx_RemoveOptionV6Operation {
	if op == nil {
		op = &xxx_RemoveOptionV6Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *RemoveOptionV6Response) xxx_FromOp(ctx context.Context, op *xxx_RemoveOptionV6Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *RemoveOptionV6Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *RemoveOptionV6Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemoveOptionV6Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetOptionValueV6Operation structure represents the R_DhcpSetOptionValueV6 operation
type xxx_SetOptionValueV6Operation struct {
	ServerIPAddress string                  `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Flags           uint32                  `idl:"name:Flags" json:"flags"`
	OptionID        uint32                  `idl:"name:OptionId" json:"option_id"`
	ClassName       string                  `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
	VendorName      string                  `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	ScopeInfo       *dhcpm.OptionScopeInfo6 `idl:"name:ScopeInfo" json:"scope_info"`
	OptionValue     *dhcpm.OptionData       `idl:"name:OptionValue" json:"option_value"`
	Return          uint32                  `idl:"name:Return" json:"return"`
}

func (o *xxx_SetOptionValueV6Operation) OpNum() int { return 52 }

func (o *xxx_SetOptionValueV6Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpSetOptionValueV6" }

func (o *xxx_SetOptionValueV6Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOptionValueV6Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	// OptionId {in} (1:{alias=DHCP_OPTION_ID, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.OptionID); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.ClassName != "" {
			_ptr_ClassName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ClassName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ClassName, _ptr_ClassName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.VendorName != "" {
			_ptr_VendorName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.VendorName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.VendorName, _ptr_VendorName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ScopeInfo {in} (1:{alias=LPDHCP_OPTION_SCOPE_INFO6}*(1))(2:{alias=DHCP_OPTION_SCOPE_INFO6}(struct))
	{
		if o.ScopeInfo != nil {
			if err := o.ScopeInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.OptionScopeInfo6{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// OptionValue {in} (1:{alias=LPDHCP_OPTION_DATA}*(1))(2:{alias=DHCP_OPTION_DATA}(struct))
	{
		if o.OptionValue != nil {
			if err := o.OptionValue.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.OptionData{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOptionValueV6Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	// OptionId {in} (1:{alias=DHCP_OPTION_ID, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OptionID); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_ClassName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ClassName); err != nil {
				return err
			}
			return nil
		})
		_s_ClassName := func(ptr interface{}) { o.ClassName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ClassName, _s_ClassName, _ptr_ClassName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_VendorName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.VendorName); err != nil {
				return err
			}
			return nil
		})
		_s_VendorName := func(ptr interface{}) { o.VendorName = *ptr.(*string) }
		if err := w.ReadPointer(&o.VendorName, _s_VendorName, _ptr_VendorName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ScopeInfo {in} (1:{alias=LPDHCP_OPTION_SCOPE_INFO6,pointer=ref}*(1))(2:{alias=DHCP_OPTION_SCOPE_INFO6}(struct))
	{
		if o.ScopeInfo == nil {
			o.ScopeInfo = &dhcpm.OptionScopeInfo6{}
		}
		if err := o.ScopeInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// OptionValue {in} (1:{alias=LPDHCP_OPTION_DATA,pointer=ref}*(1))(2:{alias=DHCP_OPTION_DATA}(struct))
	{
		if o.OptionValue == nil {
			o.OptionValue = &dhcpm.OptionData{}
		}
		if err := o.OptionValue.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOptionValueV6Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOptionValueV6Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOptionValueV6Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetOptionValueV6Request structure represents the R_DhcpSetOptionValueV6 operation request
type SetOptionValueV6Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// Flags: This is of type DWORD, specifying that the option value is set for a specific
	// or default vendor class.
	//
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                        |                                                                                  |
	//	|                 VALUE                  |                                     MEANING                                      |
	//	|                                        |                                                                                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_DEFAULT 0x00000000   | Option definition is set/modified for a default vendor class.                    |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_IS_VENDOR 0x00000003 | If a bitwise AND operation with this bitmask yields a nonzero value, it          |
	//	|                                        | indicates that the option definition is set/modified for a specific vendor       |
	//	|                                        | class.                                                                           |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	Flags    uint32 `idl:"name:Flags" json:"flags"`
	OptionID uint32 `idl:"name:OptionId" json:"option_id"`
	// ClassName: A pointer to a null-terminated Unicode string that contains the name of
	// the user class to which the option value is being set. This parameter is optional.
	ClassName string `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
	// VendorName: A pointer to a null-terminated Unicode string that contains the name
	// of the vendor class to which the option value is being set. This parameter is optional.
	// If a vendor class is not specified, the option value is set for the default vendor
	// class.
	VendorName string `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	// ScopeInfo: This is a pointer to a DHCP_OPTION_SCOPE_INFO6 (section 2.2.1.2.30) structure
	// that contains information describing the DHCPv6 scope this option value is set on.
	// This value defines that option value is being set at the default, server, or scope
	// level or for an IPv6 reservation.
	ScopeInfo *dhcpm.OptionScopeInfo6 `idl:"name:ScopeInfo" json:"scope_info"`
	// OptionValue: A pointer to DHCP_OPTION_DATA (section 2.2.1.2.24) structure that contains
	// the option value that is set for an option corresponding to the OptionID. For Dynamic
	// DNS update settings, see section 3.3.2.
	OptionValue *dhcpm.OptionData `idl:"name:OptionValue" json:"option_value"`
}

func (o *SetOptionValueV6Request) xxx_ToOp(ctx context.Context, op *xxx_SetOptionValueV6Operation) *xxx_SetOptionValueV6Operation {
	if op == nil {
		op = &xxx_SetOptionValueV6Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Flags = o.Flags
	op.OptionID = o.OptionID
	op.ClassName = o.ClassName
	op.VendorName = o.VendorName
	op.ScopeInfo = o.ScopeInfo
	op.OptionValue = o.OptionValue
	return op
}

func (o *SetOptionValueV6Request) xxx_FromOp(ctx context.Context, op *xxx_SetOptionValueV6Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Flags = op.Flags
	o.OptionID = op.OptionID
	o.ClassName = op.ClassName
	o.VendorName = op.VendorName
	o.ScopeInfo = op.ScopeInfo
	o.OptionValue = op.OptionValue
}
func (o *SetOptionValueV6Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetOptionValueV6Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetOptionValueV6Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetOptionValueV6Response structure represents the R_DhcpSetOptionValueV6 operation response
type SetOptionValueV6Response struct {
	// Return: The R_DhcpSetOptionValueV6 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetOptionValueV6Response) xxx_ToOp(ctx context.Context, op *xxx_SetOptionValueV6Operation) *xxx_SetOptionValueV6Operation {
	if op == nil {
		op = &xxx_SetOptionValueV6Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetOptionValueV6Response) xxx_FromOp(ctx context.Context, op *xxx_SetOptionValueV6Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetOptionValueV6Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetOptionValueV6Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetOptionValueV6Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumOptionValuesV6Operation structure represents the R_DhcpEnumOptionValuesV6 operation
type xxx_EnumOptionValuesV6Operation struct {
	ServerIPAddress  string                  `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Flags            uint32                  `idl:"name:Flags" json:"flags"`
	ClassName        string                  `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
	VendorName       string                  `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	ScopeInfo        *dhcpm.OptionScopeInfo6 `idl:"name:ScopeInfo" json:"scope_info"`
	Resume           uint32                  `idl:"name:ResumeHandle" json:"resume"`
	PreferredMaximum uint32                  `idl:"name:PreferredMaximum" json:"preferred_maximum"`
	OptionValues     *dhcpm.OptionValueArray `idl:"name:OptionValues" json:"option_values"`
	OptionsRead      uint32                  `idl:"name:OptionsRead" json:"options_read"`
	OptionsTotal     uint32                  `idl:"name:OptionsTotal" json:"options_total"`
	Return           uint32                  `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumOptionValuesV6Operation) OpNum() int { return 53 }

func (o *xxx_EnumOptionValuesV6Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpEnumOptionValuesV6"
}

func (o *xxx_EnumOptionValuesV6Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumOptionValuesV6Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.ClassName != "" {
			_ptr_ClassName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ClassName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ClassName, _ptr_ClassName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.VendorName != "" {
			_ptr_VendorName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.VendorName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.VendorName, _ptr_VendorName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ScopeInfo {in} (1:{alias=LPDHCP_OPTION_SCOPE_INFO6}*(1))(2:{alias=DHCP_OPTION_SCOPE_INFO6}(struct))
	{
		if o.ScopeInfo != nil {
			if err := o.ScopeInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.OptionScopeInfo6{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Resume); err != nil {
			return err
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PreferredMaximum); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumOptionValuesV6Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_ClassName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ClassName); err != nil {
				return err
			}
			return nil
		})
		_s_ClassName := func(ptr interface{}) { o.ClassName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ClassName, _s_ClassName, _ptr_ClassName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_VendorName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.VendorName); err != nil {
				return err
			}
			return nil
		})
		_s_VendorName := func(ptr interface{}) { o.VendorName = *ptr.(*string) }
		if err := w.ReadPointer(&o.VendorName, _s_VendorName, _ptr_VendorName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ScopeInfo {in} (1:{alias=LPDHCP_OPTION_SCOPE_INFO6,pointer=ref}*(1))(2:{alias=DHCP_OPTION_SCOPE_INFO6}(struct))
	{
		if o.ScopeInfo == nil {
			o.ScopeInfo = &dhcpm.OptionScopeInfo6{}
		}
		if err := o.ScopeInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Resume); err != nil {
			return err
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PreferredMaximum); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumOptionValuesV6Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumOptionValuesV6Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Resume); err != nil {
			return err
		}
	}
	// OptionValues {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_OPTION_VALUE_ARRAY}*(1))(3:{alias=DHCP_OPTION_VALUE_ARRAY}(struct))
	{
		if o.OptionValues != nil {
			_ptr_OptionValues := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.OptionValues != nil {
					if err := o.OptionValues.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.OptionValueArray{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.OptionValues, _ptr_OptionValues); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// OptionsRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OptionsRead); err != nil {
			return err
		}
	}
	// OptionsTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OptionsTotal); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumOptionValuesV6Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Resume); err != nil {
			return err
		}
	}
	// OptionValues {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_OPTION_VALUE_ARRAY,pointer=ref}*(1))(3:{alias=DHCP_OPTION_VALUE_ARRAY}(struct))
	{
		_ptr_OptionValues := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.OptionValues == nil {
				o.OptionValues = &dhcpm.OptionValueArray{}
			}
			if err := o.OptionValues.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_OptionValues := func(ptr interface{}) { o.OptionValues = *ptr.(**dhcpm.OptionValueArray) }
		if err := w.ReadPointer(&o.OptionValues, _s_OptionValues, _ptr_OptionValues); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// OptionsRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OptionsRead); err != nil {
			return err
		}
	}
	// OptionsTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OptionsTotal); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumOptionValuesV6Request structure represents the R_DhcpEnumOptionValuesV6 operation request
type EnumOptionValuesV6Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// Flags: This is of type DWORD that specifies that the option values are enumerated
	// for a specific or default vendor class.
	//
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                        |                                                                                  |
	//	|                 VALUE                  |                                     MEANING                                      |
	//	|                                        |                                                                                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_DEFAULT 0x00000000   | Option definition is enumerated for the default vendor class.                    |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_IS_VENDOR 0x00000003 | If a bitwise AND operation with this bitmask yields a nonzero value, it          |
	//	|                                        | indicates that the option definition is enumerated for a specific vendor class.  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	Flags uint32 `idl:"name:Flags" json:"flags"`
	// ClassName: A pointer to a null-terminated Unicode string that contains the name of
	// the user class to which the option values are enumerated. This parameter is optional.
	ClassName string `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
	// VendorName: A pointer to a null-terminated Unicode string that contains the name
	// of the vendor class to which the option values are enumerated. This parameter is
	// optional. If a vendor class is not specified, the option values are enumerated for
	// the default vendor class.
	VendorName string `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	// ScopeInfo: This is a pointer to a DHCP_OPTION_SCOPE_INFO6 (section 2.2.1.2.30) structure
	// that contains information describing the DHCPv6 scope this option value is enumerated
	// on. This value defines that option values are being enumerated from the default,
	// server, or scope level or for an IPv6 reservation.
	ScopeInfo *dhcpm.OptionScopeInfo6 `idl:"name:ScopeInfo" json:"scope_info"`
	// ResumeHandle: This is a pointer of type DHCP_RESUME_HANDLE (section 2.2.1.2.6) which
	// identifies the enumeration operation. Initially, this value MUST be set to zero,
	// with a successful call returning the handle value used for subsequent enumeration
	// requests. For example, if PreferredMaximum is set to 1,000 bytes, and 2,000 bytes'
	// worth of option values are stored on the DHCPv6 server, the resume handle can be
	// used after the first 1,000 bytes are retrieved to obtain the next 1,000 on a subsequent
	// call, and so forth.
	Resume uint32 `idl:"name:ResumeHandle" json:"resume"`
	// PreferredMaximum: This is of type DWORD, specifying the preferred maximum number
	// of bytes to return. If the number of remaining unenumerated option values (in bytes)
	// is less than this value, all option values are returned. To retrieve option values
	// for a specific vendor and user class for a specific scope, 0xFFFFFFFF is specified.
	PreferredMaximum uint32 `idl:"name:PreferredMaximum" json:"preferred_maximum"`
}

func (o *EnumOptionValuesV6Request) xxx_ToOp(ctx context.Context, op *xxx_EnumOptionValuesV6Operation) *xxx_EnumOptionValuesV6Operation {
	if op == nil {
		op = &xxx_EnumOptionValuesV6Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Flags = o.Flags
	op.ClassName = o.ClassName
	op.VendorName = o.VendorName
	op.ScopeInfo = o.ScopeInfo
	op.Resume = o.Resume
	op.PreferredMaximum = o.PreferredMaximum
	return op
}

func (o *EnumOptionValuesV6Request) xxx_FromOp(ctx context.Context, op *xxx_EnumOptionValuesV6Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Flags = op.Flags
	o.ClassName = op.ClassName
	o.VendorName = op.VendorName
	o.ScopeInfo = op.ScopeInfo
	o.Resume = op.Resume
	o.PreferredMaximum = op.PreferredMaximum
}
func (o *EnumOptionValuesV6Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumOptionValuesV6Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumOptionValuesV6Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumOptionValuesV6Response structure represents the R_DhcpEnumOptionValuesV6 operation response
type EnumOptionValuesV6Response struct {
	// ResumeHandle: This is a pointer of type DHCP_RESUME_HANDLE (section 2.2.1.2.6) which
	// identifies the enumeration operation. Initially, this value MUST be set to zero,
	// with a successful call returning the handle value used for subsequent enumeration
	// requests. For example, if PreferredMaximum is set to 1,000 bytes, and 2,000 bytes'
	// worth of option values are stored on the DHCPv6 server, the resume handle can be
	// used after the first 1,000 bytes are retrieved to obtain the next 1,000 on a subsequent
	// call, and so forth.
	Resume uint32 `idl:"name:ResumeHandle" json:"resume"`
	// OptionValues: This is a pointer of type LPDHCP_OPTION_VALUE_ARRAY in which all the
	// option values for a specific user and vendor class are enumerated at a specific DHCPv6
	// scope corresponding to ScopeInfo.
	OptionValues *dhcpm.OptionValueArray `idl:"name:OptionValues" json:"option_values"`
	// OptionsRead: This is a pointer to a DWORD value that specifies the number of option
	// values read in OptionValues. The caller MUST allocate memory for this parameter equal
	// to the size of data type DWORD.
	OptionsRead uint32 `idl:"name:OptionsRead" json:"options_read"`
	// OptionsTotal: This is a pointer to a DWORD value that specifies the number of option
	// values that have not yet been read. The caller MUST allocate memory for this parameter
	// equal to the size of data type DWORD.
	OptionsTotal uint32 `idl:"name:OptionsTotal" json:"options_total"`
	// Return: The R_DhcpEnumOptionValuesV6 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumOptionValuesV6Response) xxx_ToOp(ctx context.Context, op *xxx_EnumOptionValuesV6Operation) *xxx_EnumOptionValuesV6Operation {
	if op == nil {
		op = &xxx_EnumOptionValuesV6Operation{}
	}
	if o == nil {
		return op
	}
	op.Resume = o.Resume
	op.OptionValues = o.OptionValues
	op.OptionsRead = o.OptionsRead
	op.OptionsTotal = o.OptionsTotal
	op.Return = o.Return
	return op
}

func (o *EnumOptionValuesV6Response) xxx_FromOp(ctx context.Context, op *xxx_EnumOptionValuesV6Operation) {
	if o == nil {
		return
	}
	o.Resume = op.Resume
	o.OptionValues = op.OptionValues
	o.OptionsRead = op.OptionsRead
	o.OptionsTotal = op.OptionsTotal
	o.Return = op.Return
}
func (o *EnumOptionValuesV6Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumOptionValuesV6Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumOptionValuesV6Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_RemoveOptionValueV6Operation structure represents the R_DhcpRemoveOptionValueV6 operation
type xxx_RemoveOptionValueV6Operation struct {
	ServerIPAddress string                  `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Flags           uint32                  `idl:"name:Flags" json:"flags"`
	OptionID        uint32                  `idl:"name:OptionID" json:"option_id"`
	ClassName       string                  `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
	VendorName      string                  `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	ScopeInfo       *dhcpm.OptionScopeInfo6 `idl:"name:ScopeInfo" json:"scope_info"`
	Return          uint32                  `idl:"name:Return" json:"return"`
}

func (o *xxx_RemoveOptionValueV6Operation) OpNum() int { return 54 }

func (o *xxx_RemoveOptionValueV6Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpRemoveOptionValueV6"
}

func (o *xxx_RemoveOptionValueV6Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveOptionValueV6Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	// OptionID {in} (1:{alias=DHCP_OPTION_ID, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.OptionID); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.ClassName != "" {
			_ptr_ClassName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ClassName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ClassName, _ptr_ClassName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.VendorName != "" {
			_ptr_VendorName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.VendorName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.VendorName, _ptr_VendorName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ScopeInfo {in} (1:{alias=LPDHCP_OPTION_SCOPE_INFO6}*(1))(2:{alias=DHCP_OPTION_SCOPE_INFO6}(struct))
	{
		if o.ScopeInfo != nil {
			if err := o.ScopeInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.OptionScopeInfo6{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_RemoveOptionValueV6Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	// OptionID {in} (1:{alias=DHCP_OPTION_ID, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OptionID); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_ClassName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ClassName); err != nil {
				return err
			}
			return nil
		})
		_s_ClassName := func(ptr interface{}) { o.ClassName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ClassName, _s_ClassName, _ptr_ClassName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_VendorName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.VendorName); err != nil {
				return err
			}
			return nil
		})
		_s_VendorName := func(ptr interface{}) { o.VendorName = *ptr.(*string) }
		if err := w.ReadPointer(&o.VendorName, _s_VendorName, _ptr_VendorName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ScopeInfo {in} (1:{alias=LPDHCP_OPTION_SCOPE_INFO6,pointer=ref}*(1))(2:{alias=DHCP_OPTION_SCOPE_INFO6}(struct))
	{
		if o.ScopeInfo == nil {
			o.ScopeInfo = &dhcpm.OptionScopeInfo6{}
		}
		if err := o.ScopeInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveOptionValueV6Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveOptionValueV6Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveOptionValueV6Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// RemoveOptionValueV6Request structure represents the R_DhcpRemoveOptionValueV6 operation request
type RemoveOptionValueV6Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// Flags: This is of type DWORD, specifying that the option values are removed for a
	// specific or default vendor class.
	//
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                        |                                                                                  |
	//	|                 VALUE                  |                                     MEANING                                      |
	//	|                                        |                                                                                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_DEFAULT 0x00000000   | Option definition is removed for the default vendor class.                       |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_IS_VENDOR 0x00000003 | If a bitwise AND operation with this bitmask yields a nonzero value, it          |
	//	|                                        | indicates that the option definition is removed for a specific vendor class.     |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	Flags uint32 `idl:"name:Flags" json:"flags"`
	// OptionID:  This is of type DHCP_OPTION_ID (section 2.2.1.2.3), containing the option
	// identifier for the option being removed.
	OptionID uint32 `idl:"name:OptionID" json:"option_id"`
	// ClassName: A pointer to a null-terminated Unicode string that contains the name of
	// the user class from which the option value is being deleted.
	ClassName string `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
	// VendorName: A pointer to a null-terminated Unicode string that contains the name
	// of the vendor class from which the option value is being deleted.
	VendorName string `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	// ScopeInfo: This is a pointer to a DHCP_OPTION_SCOPE_INFO6 (section 2.2.1.2.30) structure
	// that contains information describing the DHCPv6 scope this option value deleted on.
	// This value defines that option values are being retrieved from the default level,
	// server level, scope level or for an IPv6 reservation.<58>
	ScopeInfo *dhcpm.OptionScopeInfo6 `idl:"name:ScopeInfo" json:"scope_info"`
}

func (o *RemoveOptionValueV6Request) xxx_ToOp(ctx context.Context, op *xxx_RemoveOptionValueV6Operation) *xxx_RemoveOptionValueV6Operation {
	if op == nil {
		op = &xxx_RemoveOptionValueV6Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Flags = o.Flags
	op.OptionID = o.OptionID
	op.ClassName = o.ClassName
	op.VendorName = o.VendorName
	op.ScopeInfo = o.ScopeInfo
	return op
}

func (o *RemoveOptionValueV6Request) xxx_FromOp(ctx context.Context, op *xxx_RemoveOptionValueV6Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Flags = op.Flags
	o.OptionID = op.OptionID
	o.ClassName = op.ClassName
	o.VendorName = op.VendorName
	o.ScopeInfo = op.ScopeInfo
}
func (o *RemoveOptionValueV6Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *RemoveOptionValueV6Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemoveOptionValueV6Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// RemoveOptionValueV6Response structure represents the R_DhcpRemoveOptionValueV6 operation response
type RemoveOptionValueV6Response struct {
	// Return: The R_DhcpRemoveOptionValueV6 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *RemoveOptionValueV6Response) xxx_ToOp(ctx context.Context, op *xxx_RemoveOptionValueV6Operation) *xxx_RemoveOptionValueV6Operation {
	if op == nil {
		op = &xxx_RemoveOptionValueV6Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *RemoveOptionValueV6Response) xxx_FromOp(ctx context.Context, op *xxx_RemoveOptionValueV6Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *RemoveOptionValueV6Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *RemoveOptionValueV6Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemoveOptionValueV6Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetAllOptionsV6Operation structure represents the R_DhcpGetAllOptionsV6 operation
type xxx_GetAllOptionsV6Operation struct {
	ServerIPAddress string            `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Flags           uint32            `idl:"name:Flags" json:"flags"`
	Option          *dhcpm.AllOptions `idl:"name:OptionStruct" json:"option"`
	Return          uint32            `idl:"name:Return" json:"return"`
}

func (o *xxx_GetAllOptionsV6Operation) OpNum() int { return 55 }

func (o *xxx_GetAllOptionsV6Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpGetAllOptionsV6" }

func (o *xxx_GetAllOptionsV6Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetAllOptionsV6Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetAllOptionsV6Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetAllOptionsV6Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetAllOptionsV6Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// OptionStruct {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_ALL_OPTIONS}*(1))(3:{alias=DHCP_ALL_OPTIONS}(struct))
	{
		if o.Option != nil {
			_ptr_OptionStruct := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Option != nil {
					if err := o.Option.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.AllOptions{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Option, _ptr_OptionStruct); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetAllOptionsV6Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// OptionStruct {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_ALL_OPTIONS,pointer=ref}*(1))(3:{alias=DHCP_ALL_OPTIONS}(struct))
	{
		_ptr_OptionStruct := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Option == nil {
				o.Option = &dhcpm.AllOptions{}
			}
			if err := o.Option.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_OptionStruct := func(ptr interface{}) { o.Option = *ptr.(**dhcpm.AllOptions) }
		if err := w.ReadPointer(&o.Option, _s_OptionStruct, _ptr_OptionStruct); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetAllOptionsV6Request structure represents the R_DhcpGetAllOptionsV6 operation request
type GetAllOptionsV6Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// Flags: This field MUST be set to zero.
	Flags uint32 `idl:"name:Flags" json:"flags"`
}

func (o *GetAllOptionsV6Request) xxx_ToOp(ctx context.Context, op *xxx_GetAllOptionsV6Operation) *xxx_GetAllOptionsV6Operation {
	if op == nil {
		op = &xxx_GetAllOptionsV6Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Flags = o.Flags
	return op
}

func (o *GetAllOptionsV6Request) xxx_FromOp(ctx context.Context, op *xxx_GetAllOptionsV6Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Flags = op.Flags
}
func (o *GetAllOptionsV6Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetAllOptionsV6Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetAllOptionsV6Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetAllOptionsV6Response structure represents the R_DhcpGetAllOptionsV6 operation response
type GetAllOptionsV6Response struct {
	// OptionStruct: This is a pointer of type LPDHCP_ALL_OPTIONS that points to the location
	// that contains all vendor-specific option definitions as well as default option definitions.
	Option *dhcpm.AllOptions `idl:"name:OptionStruct" json:"option"`
	// Return: The R_DhcpGetAllOptionsV6 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetAllOptionsV6Response) xxx_ToOp(ctx context.Context, op *xxx_GetAllOptionsV6Operation) *xxx_GetAllOptionsV6Operation {
	if op == nil {
		op = &xxx_GetAllOptionsV6Operation{}
	}
	if o == nil {
		return op
	}
	op.Option = o.Option
	op.Return = o.Return
	return op
}

func (o *GetAllOptionsV6Response) xxx_FromOp(ctx context.Context, op *xxx_GetAllOptionsV6Operation) {
	if o == nil {
		return
	}
	o.Option = op.Option
	o.Return = op.Return
}
func (o *GetAllOptionsV6Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetAllOptionsV6Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetAllOptionsV6Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetAllOptionValuesV6Operation structure represents the R_DhcpGetAllOptionValuesV6 operation
type xxx_GetAllOptionValuesV6Operation struct {
	ServerIPAddress string                  `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Flags           uint32                  `idl:"name:Flags" json:"flags"`
	ScopeInfo       *dhcpm.OptionScopeInfo6 `idl:"name:ScopeInfo" json:"scope_info"`
	Values          *dhcpm.AllOptionValues  `idl:"name:Values" json:"values"`
	Return          uint32                  `idl:"name:Return" json:"return"`
}

func (o *xxx_GetAllOptionValuesV6Operation) OpNum() int { return 56 }

func (o *xxx_GetAllOptionValuesV6Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpGetAllOptionValuesV6"
}

func (o *xxx_GetAllOptionValuesV6Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetAllOptionValuesV6Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	// ScopeInfo {in} (1:{alias=LPDHCP_OPTION_SCOPE_INFO6}*(1))(2:{alias=DHCP_OPTION_SCOPE_INFO6}(struct))
	{
		if o.ScopeInfo != nil {
			if err := o.ScopeInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.OptionScopeInfo6{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_GetAllOptionValuesV6Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	// ScopeInfo {in} (1:{alias=LPDHCP_OPTION_SCOPE_INFO6,pointer=ref}*(1))(2:{alias=DHCP_OPTION_SCOPE_INFO6}(struct))
	{
		if o.ScopeInfo == nil {
			o.ScopeInfo = &dhcpm.OptionScopeInfo6{}
		}
		if err := o.ScopeInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetAllOptionValuesV6Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetAllOptionValuesV6Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Values {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_ALL_OPTION_VALUES}*(1))(3:{alias=DHCP_ALL_OPTION_VALUES}(struct))
	{
		if o.Values != nil {
			_ptr_Values := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Values != nil {
					if err := o.Values.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.AllOptionValues{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Values, _ptr_Values); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetAllOptionValuesV6Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Values {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_ALL_OPTION_VALUES,pointer=ref}*(1))(3:{alias=DHCP_ALL_OPTION_VALUES}(struct))
	{
		_ptr_Values := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Values == nil {
				o.Values = &dhcpm.AllOptionValues{}
			}
			if err := o.Values.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_Values := func(ptr interface{}) { o.Values = *ptr.(**dhcpm.AllOptionValues) }
		if err := w.ReadPointer(&o.Values, _s_Values, _ptr_Values); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetAllOptionValuesV6Request structure represents the R_DhcpGetAllOptionValuesV6 operation request
type GetAllOptionValuesV6Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// Flags:  This field MUST be set to zero. Currently it is not used, and any value
	// set to this parameter will not affect the behavior of this method.
	Flags uint32 `idl:"name:Flags" json:"flags"`
	// ScopeInfo: This is a pointer to a DHCP_OPTION_SCOPE_INFO6 (section 2.2.1.2.30) structure
	// that contains information describing the DHCPv6 scope for which the option values
	// are retrieved. If this value is DhcpDefaultOptions6 the option values are retrieved
	// at the server level, if this value is DhcpScopeOptions6 the option values are retrieved
	// at the scope level, while if this value is DhcpReservedOptions6 the option values
	// are retrieved at the reservations level.
	ScopeInfo *dhcpm.OptionScopeInfo6 `idl:"name:ScopeInfo" json:"scope_info"`
}

func (o *GetAllOptionValuesV6Request) xxx_ToOp(ctx context.Context, op *xxx_GetAllOptionValuesV6Operation) *xxx_GetAllOptionValuesV6Operation {
	if op == nil {
		op = &xxx_GetAllOptionValuesV6Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Flags = o.Flags
	op.ScopeInfo = o.ScopeInfo
	return op
}

func (o *GetAllOptionValuesV6Request) xxx_FromOp(ctx context.Context, op *xxx_GetAllOptionValuesV6Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Flags = op.Flags
	o.ScopeInfo = op.ScopeInfo
}
func (o *GetAllOptionValuesV6Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetAllOptionValuesV6Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetAllOptionValuesV6Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetAllOptionValuesV6Response structure represents the R_DhcpGetAllOptionValuesV6 operation response
type GetAllOptionValuesV6Response struct {
	// Values: This is a pointer of type LPDHCP_ALL_OPTION_VALUES that points to the location
	// that contains all the option values retrieved from the DHCPv6 server at the server,
	// scope, or IPv6 reservation level, depending on the ScopeType defined in ScopeInfo.
	Values *dhcpm.AllOptionValues `idl:"name:Values" json:"values"`
	// Return: The R_DhcpGetAllOptionValuesV6 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetAllOptionValuesV6Response) xxx_ToOp(ctx context.Context, op *xxx_GetAllOptionValuesV6Operation) *xxx_GetAllOptionValuesV6Operation {
	if op == nil {
		op = &xxx_GetAllOptionValuesV6Operation{}
	}
	if o == nil {
		return op
	}
	op.Values = o.Values
	op.Return = o.Return
	return op
}

func (o *GetAllOptionValuesV6Response) xxx_FromOp(ctx context.Context, op *xxx_GetAllOptionValuesV6Operation) {
	if o == nil {
		return
	}
	o.Values = op.Values
	o.Return = op.Return
}
func (o *GetAllOptionValuesV6Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetAllOptionValuesV6Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetAllOptionValuesV6Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CreateSubnetV6Operation structure represents the R_DhcpCreateSubnetV6 operation
type xxx_CreateSubnetV6Operation struct {
	ServerIPAddress string              `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	SubnetAddress   *dhcpm.IPv6Address  `idl:"name:SubnetAddress" json:"subnet_address"`
	SubnetInfo      *dhcpm.SubnetInfoV6 `idl:"name:SubnetInfo;pointer:ref" json:"subnet_info"`
	Return          uint32              `idl:"name:Return" json:"return"`
}

func (o *xxx_CreateSubnetV6Operation) OpNum() int { return 57 }

func (o *xxx_CreateSubnetV6Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpCreateSubnetV6" }

func (o *xxx_CreateSubnetV6Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateSubnetV6Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IPV6_ADDRESS}(struct))
	{
		if o.SubnetAddress != nil {
			if err := o.SubnetAddress.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.IPv6Address{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// SubnetInfo {in} (1:{pointer=ref, alias=LPDHCP_SUBNET_INFO_V6}*(1))(2:{alias=DHCP_SUBNET_INFO_V6}(struct))
	{
		if o.SubnetInfo != nil {
			if err := o.SubnetInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.SubnetInfoV6{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateSubnetV6Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IPV6_ADDRESS}(struct))
	{
		if o.SubnetAddress == nil {
			o.SubnetAddress = &dhcpm.IPv6Address{}
		}
		if err := o.SubnetAddress.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// SubnetInfo {in} (1:{pointer=ref, alias=LPDHCP_SUBNET_INFO_V6}*(1))(2:{alias=DHCP_SUBNET_INFO_V6}(struct))
	{
		if o.SubnetInfo == nil {
			o.SubnetInfo = &dhcpm.SubnetInfoV6{}
		}
		if err := o.SubnetInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateSubnetV6Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateSubnetV6Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateSubnetV6Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CreateSubnetV6Request structure represents the R_DhcpCreateSubnetV6 operation request
type CreateSubnetV6Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// SubnetAddress: A pointer of type DHCP_IPV6_ADDRESS (section 2.2.1.2.28) that contains
	// the IPv6 address of the subnet.
	SubnetAddress *dhcpm.IPv6Address `idl:"name:SubnetAddress" json:"subnet_address"`
	// SubnetInfo: A pointer to a structure of type DHCP_SUBNET_INFO_V6 (section 2.2.1.2.56)
	// that contains information about the IPv6 prefix to be added to the DHCPv6 server.
	// The Prefix field is not stored in the database; any value specified for this field
	// does not alter the behavior of this method.
	SubnetInfo *dhcpm.SubnetInfoV6 `idl:"name:SubnetInfo;pointer:ref" json:"subnet_info"`
}

func (o *CreateSubnetV6Request) xxx_ToOp(ctx context.Context, op *xxx_CreateSubnetV6Operation) *xxx_CreateSubnetV6Operation {
	if op == nil {
		op = &xxx_CreateSubnetV6Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.SubnetAddress = o.SubnetAddress
	op.SubnetInfo = o.SubnetInfo
	return op
}

func (o *CreateSubnetV6Request) xxx_FromOp(ctx context.Context, op *xxx_CreateSubnetV6Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.SubnetAddress = op.SubnetAddress
	o.SubnetInfo = op.SubnetInfo
}
func (o *CreateSubnetV6Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *CreateSubnetV6Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateSubnetV6Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CreateSubnetV6Response structure represents the R_DhcpCreateSubnetV6 operation response
type CreateSubnetV6Response struct {
	// Return: The R_DhcpCreateSubnetV6 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CreateSubnetV6Response) xxx_ToOp(ctx context.Context, op *xxx_CreateSubnetV6Operation) *xxx_CreateSubnetV6Operation {
	if op == nil {
		op = &xxx_CreateSubnetV6Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *CreateSubnetV6Response) xxx_FromOp(ctx context.Context, op *xxx_CreateSubnetV6Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *CreateSubnetV6Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *CreateSubnetV6Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateSubnetV6Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumSubnetsV6Operation structure represents the R_DhcpEnumSubnetsV6 operation
type xxx_EnumSubnetsV6Operation struct {
	ServerIPAddress  string           `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Resume           uint32           `idl:"name:ResumeHandle" json:"resume"`
	PreferredMaximum uint32           `idl:"name:PreferredMaximum" json:"preferred_maximum"`
	EnumInfo         *dhcpm.IPArrayV6 `idl:"name:EnumInfo" json:"enum_info"`
	ElementsRead     uint32           `idl:"name:ElementsRead" json:"elements_read"`
	ElementsTotal    uint32           `idl:"name:ElementsTotal" json:"elements_total"`
	Return           uint32           `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumSubnetsV6Operation) OpNum() int { return 58 }

func (o *xxx_EnumSubnetsV6Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpEnumSubnetsV6" }

func (o *xxx_EnumSubnetsV6Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetsV6Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Resume); err != nil {
			return err
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PreferredMaximum); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetsV6Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Resume); err != nil {
			return err
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PreferredMaximum); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetsV6Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetsV6Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Resume); err != nil {
			return err
		}
	}
	// EnumInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCPV6_IP_ARRAY}*(1))(3:{alias=DHCPV6_IP_ARRAY}(struct))
	{
		if o.EnumInfo != nil {
			_ptr_EnumInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.EnumInfo != nil {
					if err := o.EnumInfo.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.IPArrayV6{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.EnumInfo, _ptr_EnumInfo); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ElementsRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ElementsRead); err != nil {
			return err
		}
	}
	// ElementsTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ElementsTotal); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetsV6Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Resume); err != nil {
			return err
		}
	}
	// EnumInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCPV6_IP_ARRAY,pointer=ref}*(1))(3:{alias=DHCPV6_IP_ARRAY}(struct))
	{
		_ptr_EnumInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.EnumInfo == nil {
				o.EnumInfo = &dhcpm.IPArrayV6{}
			}
			if err := o.EnumInfo.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_EnumInfo := func(ptr interface{}) { o.EnumInfo = *ptr.(**dhcpm.IPArrayV6) }
		if err := w.ReadPointer(&o.EnumInfo, _s_EnumInfo, _ptr_EnumInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ElementsRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ElementsRead); err != nil {
			return err
		}
	}
	// ElementsTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ElementsTotal); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumSubnetsV6Request structure represents the R_DhcpEnumSubnetsV6 operation request
type EnumSubnetsV6Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// ResumeHandle: This is a pointer of type DHCP_RESUME_HANDLE (section 2.2.1.2.6) that
	// identifies the enumeration operation. Initially, this value MUST be set to zero,
	// with a successful call returning the handle value used for subsequent enumeration
	// requests. For example, if PreferredMaximum is set to 100, and 200 IPv6 prefix addresses
	// are stored on the DHCPv6 server, the resume handle can be used after the first 100
	// IPv6 prefixes are retrieved to obtain the next 100 on a subsequent call, and so forth.
	Resume uint32 `idl:"name:ResumeHandle" json:"resume"`
	// PreferredMaximum: This is of type DWORD, specifying the preferred maximum number
	// of IPv6 prefix addresses to return. If the number of remaining unenumerated options
	// is less than this value, all the IPv6 prefixes are returned. To retrieve all the
	// IPv6 prefixes, 0xFFFFFFFF is specified.
	PreferredMaximum uint32 `idl:"name:PreferredMaximum" json:"preferred_maximum"`
}

func (o *EnumSubnetsV6Request) xxx_ToOp(ctx context.Context, op *xxx_EnumSubnetsV6Operation) *xxx_EnumSubnetsV6Operation {
	if op == nil {
		op = &xxx_EnumSubnetsV6Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Resume = o.Resume
	op.PreferredMaximum = o.PreferredMaximum
	return op
}

func (o *EnumSubnetsV6Request) xxx_FromOp(ctx context.Context, op *xxx_EnumSubnetsV6Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Resume = op.Resume
	o.PreferredMaximum = op.PreferredMaximum
}
func (o *EnumSubnetsV6Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumSubnetsV6Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumSubnetsV6Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumSubnetsV6Response structure represents the R_DhcpEnumSubnetsV6 operation response
type EnumSubnetsV6Response struct {
	// ResumeHandle: This is a pointer of type DHCP_RESUME_HANDLE (section 2.2.1.2.6) that
	// identifies the enumeration operation. Initially, this value MUST be set to zero,
	// with a successful call returning the handle value used for subsequent enumeration
	// requests. For example, if PreferredMaximum is set to 100, and 200 IPv6 prefix addresses
	// are stored on the DHCPv6 server, the resume handle can be used after the first 100
	// IPv6 prefixes are retrieved to obtain the next 100 on a subsequent call, and so forth.
	Resume uint32 `idl:"name:ResumeHandle" json:"resume"`
	// EnumInfo: This is a pointer of type LPDHCPV6_IP_ARRAY in which the IPv6 prefix configured
	// on the DHCPv6 server is returned.
	EnumInfo *dhcpm.IPArrayV6 `idl:"name:EnumInfo" json:"enum_info"`
	// ElementsRead: This is a pointer to a DWORD value that specifies the number of IPv6
	// prefix addresses returned in EnumInfo. The caller MUST allocate memory for this parameter
	// equal to the size of data type DWORD.
	ElementsRead uint32 `idl:"name:ElementsRead" json:"elements_read"`
	// ElementsTotal: This is a pointer to a DWORD value that specifies the number of IPv6
	// prefixes defined on the DHCPv6 server that have not yet been enumerated with respect
	// to the resume handle that is returned. The caller MUST allocate memory for this parameter
	// equal to the size of data type DWORD.
	ElementsTotal uint32 `idl:"name:ElementsTotal" json:"elements_total"`
	// Return: The R_DhcpEnumSubnetsV6 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumSubnetsV6Response) xxx_ToOp(ctx context.Context, op *xxx_EnumSubnetsV6Operation) *xxx_EnumSubnetsV6Operation {
	if op == nil {
		op = &xxx_EnumSubnetsV6Operation{}
	}
	if o == nil {
		return op
	}
	op.Resume = o.Resume
	op.EnumInfo = o.EnumInfo
	op.ElementsRead = o.ElementsRead
	op.ElementsTotal = o.ElementsTotal
	op.Return = o.Return
	return op
}

func (o *EnumSubnetsV6Response) xxx_FromOp(ctx context.Context, op *xxx_EnumSubnetsV6Operation) {
	if o == nil {
		return
	}
	o.Resume = op.Resume
	o.EnumInfo = op.EnumInfo
	o.ElementsRead = op.ElementsRead
	o.ElementsTotal = op.ElementsTotal
	o.Return = op.Return
}
func (o *EnumSubnetsV6Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumSubnetsV6Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumSubnetsV6Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddSubnetElementV6Operation structure represents the R_DhcpAddSubnetElementV6 operation
type xxx_AddSubnetElementV6Operation struct {
	ServerIPAddress string                     `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	SubnetAddress   *dhcpm.IPv6Address         `idl:"name:SubnetAddress" json:"subnet_address"`
	AddElementInfo  *dhcpm.SubnetElementDataV6 `idl:"name:AddElementInfo;pointer:ref" json:"add_element_info"`
	Return          uint32                     `idl:"name:Return" json:"return"`
}

func (o *xxx_AddSubnetElementV6Operation) OpNum() int { return 59 }

func (o *xxx_AddSubnetElementV6Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpAddSubnetElementV6"
}

func (o *xxx_AddSubnetElementV6Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddSubnetElementV6Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IPV6_ADDRESS}(struct))
	{
		if o.SubnetAddress != nil {
			if err := o.SubnetAddress.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.IPv6Address{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// AddElementInfo {in} (1:{pointer=ref, alias=LPDHCP_SUBNET_ELEMENT_DATA_V6}*(1))(2:{alias=DHCP_SUBNET_ELEMENT_DATA_V6}(struct))
	{
		if o.AddElementInfo != nil {
			if err := o.AddElementInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.SubnetElementDataV6{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddSubnetElementV6Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IPV6_ADDRESS}(struct))
	{
		if o.SubnetAddress == nil {
			o.SubnetAddress = &dhcpm.IPv6Address{}
		}
		if err := o.SubnetAddress.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// AddElementInfo {in} (1:{pointer=ref, alias=LPDHCP_SUBNET_ELEMENT_DATA_V6}*(1))(2:{alias=DHCP_SUBNET_ELEMENT_DATA_V6}(struct))
	{
		if o.AddElementInfo == nil {
			o.AddElementInfo = &dhcpm.SubnetElementDataV6{}
		}
		if err := o.AddElementInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddSubnetElementV6Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddSubnetElementV6Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddSubnetElementV6Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddSubnetElementV6Request structure represents the R_DhcpAddSubnetElementV6 operation request
type AddSubnetElementV6Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// SubnetAddress: This is of type DHCP_IPV6_ADDRESS (section 2.2.1.2.28) that contains
	// the IPv6 address of the subnet for which the IPv6 prefix element is added.
	SubnetAddress *dhcpm.IPv6Address `idl:"name:SubnetAddress" json:"subnet_address"`
	// AddElementInfo: This is a pointer to structure DHCP_SUBNET_ELEMENT_DATA_V6 (section
	// 2.2.1.2.60) that contains the IPv6 prefix element that needs to be added to the IPv6
	// prefix.
	AddElementInfo *dhcpm.SubnetElementDataV6 `idl:"name:AddElementInfo;pointer:ref" json:"add_element_info"`
}

func (o *AddSubnetElementV6Request) xxx_ToOp(ctx context.Context, op *xxx_AddSubnetElementV6Operation) *xxx_AddSubnetElementV6Operation {
	if op == nil {
		op = &xxx_AddSubnetElementV6Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.SubnetAddress = o.SubnetAddress
	op.AddElementInfo = o.AddElementInfo
	return op
}

func (o *AddSubnetElementV6Request) xxx_FromOp(ctx context.Context, op *xxx_AddSubnetElementV6Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.SubnetAddress = op.SubnetAddress
	o.AddElementInfo = op.AddElementInfo
}
func (o *AddSubnetElementV6Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *AddSubnetElementV6Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddSubnetElementV6Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddSubnetElementV6Response structure represents the R_DhcpAddSubnetElementV6 operation response
type AddSubnetElementV6Response struct {
	// Return: The R_DhcpAddSubnetElementV6 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddSubnetElementV6Response) xxx_ToOp(ctx context.Context, op *xxx_AddSubnetElementV6Operation) *xxx_AddSubnetElementV6Operation {
	if op == nil {
		op = &xxx_AddSubnetElementV6Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *AddSubnetElementV6Response) xxx_FromOp(ctx context.Context, op *xxx_AddSubnetElementV6Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *AddSubnetElementV6Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *AddSubnetElementV6Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddSubnetElementV6Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumSubnetElementsV6Operation structure represents the R_DhcpEnumSubnetElementsV6 operation
type xxx_EnumSubnetElementsV6Operation struct {
	ServerIPAddress  string                          `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	SubnetAddress    *dhcpm.IPv6Address              `idl:"name:SubnetAddress" json:"subnet_address"`
	EnumElementType  dhcpm.SubnetElementTypeV6       `idl:"name:EnumElementType" json:"enum_element_type"`
	Resume           uint32                          `idl:"name:ResumeHandle" json:"resume"`
	PreferredMaximum uint32                          `idl:"name:PreferredMaximum" json:"preferred_maximum"`
	EnumElementInfo  *dhcpm.SubnetElementInfoArrayV6 `idl:"name:EnumElementInfo" json:"enum_element_info"`
	ElementsRead     uint32                          `idl:"name:ElementsRead" json:"elements_read"`
	ElementsTotal    uint32                          `idl:"name:ElementsTotal" json:"elements_total"`
	Return           uint32                          `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumSubnetElementsV6Operation) OpNum() int { return 60 }

func (o *xxx_EnumSubnetElementsV6Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpEnumSubnetElementsV6"
}

func (o *xxx_EnumSubnetElementsV6Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetElementsV6Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IPV6_ADDRESS}(struct))
	{
		if o.SubnetAddress != nil {
			if err := o.SubnetAddress.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.IPv6Address{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// EnumElementType {in} (1:{alias=DHCP_SUBNET_ELEMENT_TYPE_V6}(enum))
	{
		if err := w.WriteEnum(uint16(o.EnumElementType)); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Resume); err != nil {
			return err
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PreferredMaximum); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetElementsV6Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IPV6_ADDRESS}(struct))
	{
		if o.SubnetAddress == nil {
			o.SubnetAddress = &dhcpm.IPv6Address{}
		}
		if err := o.SubnetAddress.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// EnumElementType {in} (1:{alias=DHCP_SUBNET_ELEMENT_TYPE_V6}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.EnumElementType)); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Resume); err != nil {
			return err
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PreferredMaximum); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetElementsV6Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetElementsV6Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Resume); err != nil {
			return err
		}
	}
	// EnumElementInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V6}*(1))(3:{alias=DHCP_SUBNET_ELEMENT_INFO_ARRAY_V6}(struct))
	{
		if o.EnumElementInfo != nil {
			_ptr_EnumElementInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.EnumElementInfo != nil {
					if err := o.EnumElementInfo.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.SubnetElementInfoArrayV6{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.EnumElementInfo, _ptr_EnumElementInfo); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ElementsRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ElementsRead); err != nil {
			return err
		}
	}
	// ElementsTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ElementsTotal); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetElementsV6Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Resume); err != nil {
			return err
		}
	}
	// EnumElementInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V6,pointer=ref}*(1))(3:{alias=DHCP_SUBNET_ELEMENT_INFO_ARRAY_V6}(struct))
	{
		_ptr_EnumElementInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.EnumElementInfo == nil {
				o.EnumElementInfo = &dhcpm.SubnetElementInfoArrayV6{}
			}
			if err := o.EnumElementInfo.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_EnumElementInfo := func(ptr interface{}) { o.EnumElementInfo = *ptr.(**dhcpm.SubnetElementInfoArrayV6) }
		if err := w.ReadPointer(&o.EnumElementInfo, _s_EnumElementInfo, _ptr_EnumElementInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ElementsRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ElementsRead); err != nil {
			return err
		}
	}
	// ElementsTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ElementsTotal); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumSubnetElementsV6Request structure represents the R_DhcpEnumSubnetElementsV6 operation request
type EnumSubnetElementsV6Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// SubnetAddress: This is of type DHCP_IPV6_ADDRESS (section 2.2.1.2.28), containing
	// the IPv6 address of the subnet from which subnet elements are enumerated.
	SubnetAddress *dhcpm.IPv6Address `idl:"name:SubnetAddress" json:"subnet_address"`
	// EnumElementType: This is of type DHCP_SUBNET_ELEMENT_TYPE_V6 (section 2.2.1.1.8)
	// value, indicating the type of IPv6 prefix element to enumerate.
	EnumElementType dhcpm.SubnetElementTypeV6 `idl:"name:EnumElementType" json:"enum_element_type"`
	// ResumeHandle: This is a pointer of type DHCP_RESUME_HANDLE (section 2.2.1.2.6) that
	// identifies the enumeration operation. Initially, this value MUST be set to zero,
	// with a successful call returning the handle value used for subsequent enumeration
	// requests. For example, if PreferredMaximum is set to 1,000 bytes, and 2,000 bytes'
	// worth of IPv6 prefix elements are stored on the DHCPv6 server, the resume handle
	// can be used after the first 1,000 bytes are retrieved to obtain the next 1,000 on
	// a subsequent call, and so forth.
	Resume uint32 `idl:"name:ResumeHandle" json:"resume"`
	// PreferredMaximum: This is of type DWORD, specifying the preferred maximum number
	// of bytes to return. If the number of remaining unenumerated subnet element (in bytes)
	// is less than this value, all IPv6 prefix elements for specific type are returned.
	// To retrieve all the IPv6 prefix elements of a specific type, 0xFFFFFFFF is specified.
	PreferredMaximum uint32 `idl:"name:PreferredMaximum" json:"preferred_maximum"`
}

func (o *EnumSubnetElementsV6Request) xxx_ToOp(ctx context.Context, op *xxx_EnumSubnetElementsV6Operation) *xxx_EnumSubnetElementsV6Operation {
	if op == nil {
		op = &xxx_EnumSubnetElementsV6Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.SubnetAddress = o.SubnetAddress
	op.EnumElementType = o.EnumElementType
	op.Resume = o.Resume
	op.PreferredMaximum = o.PreferredMaximum
	return op
}

func (o *EnumSubnetElementsV6Request) xxx_FromOp(ctx context.Context, op *xxx_EnumSubnetElementsV6Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.SubnetAddress = op.SubnetAddress
	o.EnumElementType = op.EnumElementType
	o.Resume = op.Resume
	o.PreferredMaximum = op.PreferredMaximum
}
func (o *EnumSubnetElementsV6Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumSubnetElementsV6Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumSubnetElementsV6Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumSubnetElementsV6Response structure represents the R_DhcpEnumSubnetElementsV6 operation response
type EnumSubnetElementsV6Response struct {
	// ResumeHandle: This is a pointer of type DHCP_RESUME_HANDLE (section 2.2.1.2.6) that
	// identifies the enumeration operation. Initially, this value MUST be set to zero,
	// with a successful call returning the handle value used for subsequent enumeration
	// requests. For example, if PreferredMaximum is set to 1,000 bytes, and 2,000 bytes'
	// worth of IPv6 prefix elements are stored on the DHCPv6 server, the resume handle
	// can be used after the first 1,000 bytes are retrieved to obtain the next 1,000 on
	// a subsequent call, and so forth.
	Resume uint32 `idl:"name:ResumeHandle" json:"resume"`
	// EnumElementInfo: This is a pointer of type LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V6 in
	// which an IPv4 subnet element of type EnumElementType is returned for a specific IPv6
	// prefix SubnetAddress. If no IPv6 prefix elements are available for enumeration, this
	// value is null.
	EnumElementInfo *dhcpm.SubnetElementInfoArrayV6 `idl:"name:EnumElementInfo" json:"enum_element_info"`
	// ElementsRead: This is a pointer to a DWORD value that specifies the number of IPv6
	// prefix elements read in EnumElementInfo for a specific type of IPv6 prefix element.
	// The caller MUST allocate memory for this parameter equal to the size of data type
	// DWORD.
	ElementsRead uint32 `idl:"name:ElementsRead" json:"elements_read"`
	// ElementsTotal: This is a pointer to a DWORD value that specifies the number of IPv6
	// prefix elements of a specific type for a specific IPv6 prefix that are not yet enumerated
	// with respect to the resume handle that is returned. The caller MUST allocate memory
	// for this parameter equal to the size of data type DWORD.
	ElementsTotal uint32 `idl:"name:ElementsTotal" json:"elements_total"`
	// Return: The R_DhcpEnumSubnetElementsV6 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumSubnetElementsV6Response) xxx_ToOp(ctx context.Context, op *xxx_EnumSubnetElementsV6Operation) *xxx_EnumSubnetElementsV6Operation {
	if op == nil {
		op = &xxx_EnumSubnetElementsV6Operation{}
	}
	if o == nil {
		return op
	}
	op.Resume = o.Resume
	op.EnumElementInfo = o.EnumElementInfo
	op.ElementsRead = o.ElementsRead
	op.ElementsTotal = o.ElementsTotal
	op.Return = o.Return
	return op
}

func (o *EnumSubnetElementsV6Response) xxx_FromOp(ctx context.Context, op *xxx_EnumSubnetElementsV6Operation) {
	if o == nil {
		return
	}
	o.Resume = op.Resume
	o.EnumElementInfo = op.EnumElementInfo
	o.ElementsRead = op.ElementsRead
	o.ElementsTotal = op.ElementsTotal
	o.Return = op.Return
}
func (o *EnumSubnetElementsV6Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumSubnetElementsV6Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumSubnetElementsV6Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_RemoveSubnetElementV6Operation structure represents the R_DhcpRemoveSubnetElementV6 operation
type xxx_RemoveSubnetElementV6Operation struct {
	ServerIPAddress   string                     `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	SubnetAddress     *dhcpm.IPv6Address         `idl:"name:SubnetAddress" json:"subnet_address"`
	RemoveElementInfo *dhcpm.SubnetElementDataV6 `idl:"name:RemoveElementInfo;pointer:ref" json:"remove_element_info"`
	ForceFlag         dhcpm.ForceFlag            `idl:"name:ForceFlag" json:"force_flag"`
	Return            uint32                     `idl:"name:Return" json:"return"`
}

func (o *xxx_RemoveSubnetElementV6Operation) OpNum() int { return 61 }

func (o *xxx_RemoveSubnetElementV6Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpRemoveSubnetElementV6"
}

func (o *xxx_RemoveSubnetElementV6Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveSubnetElementV6Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IPV6_ADDRESS}(struct))
	{
		if o.SubnetAddress != nil {
			if err := o.SubnetAddress.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.IPv6Address{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// RemoveElementInfo {in} (1:{pointer=ref, alias=LPDHCP_SUBNET_ELEMENT_DATA_V6}*(1))(2:{alias=DHCP_SUBNET_ELEMENT_DATA_V6}(struct))
	{
		if o.RemoveElementInfo != nil {
			if err := o.RemoveElementInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.SubnetElementDataV6{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ForceFlag {in} (1:{alias=DHCP_FORCE_FLAG}(enum))
	{
		if err := w.WriteEnum(uint16(o.ForceFlag)); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveSubnetElementV6Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IPV6_ADDRESS}(struct))
	{
		if o.SubnetAddress == nil {
			o.SubnetAddress = &dhcpm.IPv6Address{}
		}
		if err := o.SubnetAddress.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// RemoveElementInfo {in} (1:{pointer=ref, alias=LPDHCP_SUBNET_ELEMENT_DATA_V6}*(1))(2:{alias=DHCP_SUBNET_ELEMENT_DATA_V6}(struct))
	{
		if o.RemoveElementInfo == nil {
			o.RemoveElementInfo = &dhcpm.SubnetElementDataV6{}
		}
		if err := o.RemoveElementInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ForceFlag {in} (1:{alias=DHCP_FORCE_FLAG}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.ForceFlag)); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveSubnetElementV6Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveSubnetElementV6Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveSubnetElementV6Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// RemoveSubnetElementV6Request structure represents the R_DhcpRemoveSubnetElementV6 operation request
type RemoveSubnetElementV6Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// SubnetAddress: This is of type DHCP_IPV6_ADDRESS (section 2.2.1.2.28), containing
	// the IPv6 address of the subnet for which the IPv6 prefix element is removed.
	SubnetAddress *dhcpm.IPv6Address `idl:"name:SubnetAddress" json:"subnet_address"`
	// RemoveElementInfo: This is a pointer of type DHCP_SUBNET_ELEMENT_DATA_V6 (section
	// 2.2.1.2.60), containing the IPv6 prefix element that needs to be removed from the
	// IPv6 prefix.
	RemoveElementInfo *dhcpm.SubnetElementDataV6 `idl:"name:RemoveElementInfo;pointer:ref" json:"remove_element_info"`
	// ForceFlag: This is of type DHCP_FORCE_FLAG (section 2.2.1.1.9) enumeration. Currently
	// it is not used, and any value set to this parameter will not affect the behavior
	// of this method.
	ForceFlag dhcpm.ForceFlag `idl:"name:ForceFlag" json:"force_flag"`
}

func (o *RemoveSubnetElementV6Request) xxx_ToOp(ctx context.Context, op *xxx_RemoveSubnetElementV6Operation) *xxx_RemoveSubnetElementV6Operation {
	if op == nil {
		op = &xxx_RemoveSubnetElementV6Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.SubnetAddress = o.SubnetAddress
	op.RemoveElementInfo = o.RemoveElementInfo
	op.ForceFlag = o.ForceFlag
	return op
}

func (o *RemoveSubnetElementV6Request) xxx_FromOp(ctx context.Context, op *xxx_RemoveSubnetElementV6Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.SubnetAddress = op.SubnetAddress
	o.RemoveElementInfo = op.RemoveElementInfo
	o.ForceFlag = op.ForceFlag
}
func (o *RemoveSubnetElementV6Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *RemoveSubnetElementV6Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemoveSubnetElementV6Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// RemoveSubnetElementV6Response structure represents the R_DhcpRemoveSubnetElementV6 operation response
type RemoveSubnetElementV6Response struct {
	// Return: The R_DhcpRemoveSubnetElementV6 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *RemoveSubnetElementV6Response) xxx_ToOp(ctx context.Context, op *xxx_RemoveSubnetElementV6Operation) *xxx_RemoveSubnetElementV6Operation {
	if op == nil {
		op = &xxx_RemoveSubnetElementV6Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *RemoveSubnetElementV6Response) xxx_FromOp(ctx context.Context, op *xxx_RemoveSubnetElementV6Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *RemoveSubnetElementV6Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *RemoveSubnetElementV6Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemoveSubnetElementV6Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_DeleteSubnetV6Operation structure represents the R_DhcpDeleteSubnetV6 operation
type xxx_DeleteSubnetV6Operation struct {
	ServerIPAddress string             `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	SubnetAddress   *dhcpm.IPv6Address `idl:"name:SubnetAddress" json:"subnet_address"`
	ForceFlag       dhcpm.ForceFlag    `idl:"name:ForceFlag" json:"force_flag"`
	Return          uint32             `idl:"name:Return" json:"return"`
}

func (o *xxx_DeleteSubnetV6Operation) OpNum() int { return 62 }

func (o *xxx_DeleteSubnetV6Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpDeleteSubnetV6" }

func (o *xxx_DeleteSubnetV6Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteSubnetV6Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IPV6_ADDRESS}(struct))
	{
		if o.SubnetAddress != nil {
			if err := o.SubnetAddress.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.IPv6Address{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// ForceFlag {in} (1:{alias=DHCP_FORCE_FLAG}(enum))
	{
		if err := w.WriteEnum(uint16(o.ForceFlag)); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteSubnetV6Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IPV6_ADDRESS}(struct))
	{
		if o.SubnetAddress == nil {
			o.SubnetAddress = &dhcpm.IPv6Address{}
		}
		if err := o.SubnetAddress.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// ForceFlag {in} (1:{alias=DHCP_FORCE_FLAG}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.ForceFlag)); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteSubnetV6Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteSubnetV6Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteSubnetV6Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// DeleteSubnetV6Request structure represents the R_DhcpDeleteSubnetV6 operation request
type DeleteSubnetV6Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// SubnetAddress: This is of type DHCP_IPV6_ADDRESS (section 2.2.1.2.28) that contains
	// the IPv6 address of the subnet that needs to be removed from the DHCPv6 server.
	SubnetAddress *dhcpm.IPv6Address `idl:"name:SubnetAddress" json:"subnet_address"`
	// ForceFlag: This is of type DHCP_FORCE_FLAG (section 2.2.1.1.9) enumeration.
	ForceFlag dhcpm.ForceFlag `idl:"name:ForceFlag" json:"force_flag"`
}

func (o *DeleteSubnetV6Request) xxx_ToOp(ctx context.Context, op *xxx_DeleteSubnetV6Operation) *xxx_DeleteSubnetV6Operation {
	if op == nil {
		op = &xxx_DeleteSubnetV6Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.SubnetAddress = o.SubnetAddress
	op.ForceFlag = o.ForceFlag
	return op
}

func (o *DeleteSubnetV6Request) xxx_FromOp(ctx context.Context, op *xxx_DeleteSubnetV6Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.SubnetAddress = op.SubnetAddress
	o.ForceFlag = op.ForceFlag
}
func (o *DeleteSubnetV6Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *DeleteSubnetV6Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteSubnetV6Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// DeleteSubnetV6Response structure represents the R_DhcpDeleteSubnetV6 operation response
type DeleteSubnetV6Response struct {
	// Return: The R_DhcpDeleteSubnetV6 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *DeleteSubnetV6Response) xxx_ToOp(ctx context.Context, op *xxx_DeleteSubnetV6Operation) *xxx_DeleteSubnetV6Operation {
	if op == nil {
		op = &xxx_DeleteSubnetV6Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *DeleteSubnetV6Response) xxx_FromOp(ctx context.Context, op *xxx_DeleteSubnetV6Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *DeleteSubnetV6Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *DeleteSubnetV6Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteSubnetV6Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetSubnetInfoV6Operation structure represents the R_DhcpGetSubnetInfoV6 operation
type xxx_GetSubnetInfoV6Operation struct {
	ServerIPAddress string              `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	SubnetAddress   *dhcpm.IPv6Address  `idl:"name:SubnetAddress" json:"subnet_address"`
	SubnetInfo      *dhcpm.SubnetInfoV6 `idl:"name:SubnetInfo" json:"subnet_info"`
	Return          uint32              `idl:"name:Return" json:"return"`
}

func (o *xxx_GetSubnetInfoV6Operation) OpNum() int { return 63 }

func (o *xxx_GetSubnetInfoV6Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpGetSubnetInfoV6" }

func (o *xxx_GetSubnetInfoV6Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetSubnetInfoV6Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IPV6_ADDRESS}(struct))
	{
		if o.SubnetAddress != nil {
			if err := o.SubnetAddress.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.IPv6Address{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_GetSubnetInfoV6Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IPV6_ADDRESS}(struct))
	{
		if o.SubnetAddress == nil {
			o.SubnetAddress = &dhcpm.IPv6Address{}
		}
		if err := o.SubnetAddress.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetSubnetInfoV6Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetSubnetInfoV6Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// SubnetInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_SUBNET_INFO_V6}*(1))(3:{alias=DHCP_SUBNET_INFO_V6}(struct))
	{
		if o.SubnetInfo != nil {
			_ptr_SubnetInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.SubnetInfo != nil {
					if err := o.SubnetInfo.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.SubnetInfoV6{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.SubnetInfo, _ptr_SubnetInfo); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetSubnetInfoV6Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// SubnetInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_SUBNET_INFO_V6,pointer=ref}*(1))(3:{alias=DHCP_SUBNET_INFO_V6}(struct))
	{
		_ptr_SubnetInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.SubnetInfo == nil {
				o.SubnetInfo = &dhcpm.SubnetInfoV6{}
			}
			if err := o.SubnetInfo.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_SubnetInfo := func(ptr interface{}) { o.SubnetInfo = *ptr.(**dhcpm.SubnetInfoV6) }
		if err := w.ReadPointer(&o.SubnetInfo, _s_SubnetInfo, _ptr_SubnetInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetSubnetInfoV6Request structure represents the R_DhcpGetSubnetInfoV6 operation request
type GetSubnetInfoV6Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// SubnetAddress: This is of type DHCP_IPV6_ADDRESS (section 2.2.1.2.28) that contains
	// the IPv6 prefix ID for which the information is retrieved.
	SubnetAddress *dhcpm.IPv6Address `idl:"name:SubnetAddress" json:"subnet_address"`
}

func (o *GetSubnetInfoV6Request) xxx_ToOp(ctx context.Context, op *xxx_GetSubnetInfoV6Operation) *xxx_GetSubnetInfoV6Operation {
	if op == nil {
		op = &xxx_GetSubnetInfoV6Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.SubnetAddress = o.SubnetAddress
	return op
}

func (o *GetSubnetInfoV6Request) xxx_FromOp(ctx context.Context, op *xxx_GetSubnetInfoV6Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.SubnetAddress = op.SubnetAddress
}
func (o *GetSubnetInfoV6Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetSubnetInfoV6Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetSubnetInfoV6Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetSubnetInfoV6Response structure represents the R_DhcpGetSubnetInfoV6 operation response
type GetSubnetInfoV6Response struct {
	// SubnetInfo: This is a pointer of type LPDHCP_SUBNET_INFO_V6 in which the information
	// for the subnet matching the ID specified by SubnetAddress is retrieved.
	SubnetInfo *dhcpm.SubnetInfoV6 `idl:"name:SubnetInfo" json:"subnet_info"`
	// Return: The R_DhcpGetSubnetInfoV6 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetSubnetInfoV6Response) xxx_ToOp(ctx context.Context, op *xxx_GetSubnetInfoV6Operation) *xxx_GetSubnetInfoV6Operation {
	if op == nil {
		op = &xxx_GetSubnetInfoV6Operation{}
	}
	if o == nil {
		return op
	}
	op.SubnetInfo = o.SubnetInfo
	op.Return = o.Return
	return op
}

func (o *GetSubnetInfoV6Response) xxx_FromOp(ctx context.Context, op *xxx_GetSubnetInfoV6Operation) {
	if o == nil {
		return
	}
	o.SubnetInfo = op.SubnetInfo
	o.Return = op.Return
}
func (o *GetSubnetInfoV6Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetSubnetInfoV6Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetSubnetInfoV6Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumSubnetClientsV6Operation structure represents the R_DhcpEnumSubnetClientsV6 operation
type xxx_EnumSubnetClientsV6Operation struct {
	ServerIPAddress  string                   `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	SubnetAddress    *dhcpm.IPv6Address       `idl:"name:SubnetAddress" json:"subnet_address"`
	Resume           *dhcpm.ResumeIPv6Handle  `idl:"name:ResumeHandle" json:"resume"`
	PreferredMaximum uint32                   `idl:"name:PreferredMaximum" json:"preferred_maximum"`
	ClientInfo       *dhcpm.ClientInfoArrayV6 `idl:"name:ClientInfo" json:"client_info"`
	ClientsRead      uint32                   `idl:"name:ClientsRead" json:"clients_read"`
	ClientsTotal     uint32                   `idl:"name:ClientsTotal" json:"clients_total"`
	Return           uint32                   `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumSubnetClientsV6Operation) OpNum() int { return 64 }

func (o *xxx_EnumSubnetClientsV6Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpEnumSubnetClientsV6"
}

func (o *xxx_EnumSubnetClientsV6Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetClientsV6Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IPV6_ADDRESS}(struct))
	{
		if o.SubnetAddress != nil {
			if err := o.SubnetAddress.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.IPv6Address{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_IPV6_HANDLE, names=DHCP_IPV6_ADDRESS}(struct))
	{
		if o.Resume != nil {
			if err := o.Resume.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.ResumeIPv6Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PreferredMaximum); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetClientsV6Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IPV6_ADDRESS}(struct))
	{
		if o.SubnetAddress == nil {
			o.SubnetAddress = &dhcpm.IPv6Address{}
		}
		if err := o.SubnetAddress.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_IPV6_HANDLE, names=DHCP_IPV6_ADDRESS}(struct))
	{
		if o.Resume == nil {
			o.Resume = &dhcpm.ResumeIPv6Handle{}
		}
		if err := o.Resume.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PreferredMaximum); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetClientsV6Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetClientsV6Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_IPV6_HANDLE, names=DHCP_IPV6_ADDRESS}(struct))
	{
		if o.Resume != nil {
			if err := o.Resume.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.ResumeIPv6Handle{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// ClientInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_CLIENT_INFO_ARRAY_V6}*(1))(3:{alias=DHCP_CLIENT_INFO_ARRAY_V6}(struct))
	{
		if o.ClientInfo != nil {
			_ptr_ClientInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.ClientInfo != nil {
					if err := o.ClientInfo.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.ClientInfoArrayV6{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ClientInfo, _ptr_ClientInfo); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ClientsRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ClientsRead); err != nil {
			return err
		}
	}
	// ClientsTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ClientsTotal); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetClientsV6Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_IPV6_HANDLE, names=DHCP_IPV6_ADDRESS}(struct))
	{
		if o.Resume == nil {
			o.Resume = &dhcpm.ResumeIPv6Handle{}
		}
		if err := o.Resume.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// ClientInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_CLIENT_INFO_ARRAY_V6,pointer=ref}*(1))(3:{alias=DHCP_CLIENT_INFO_ARRAY_V6}(struct))
	{
		_ptr_ClientInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.ClientInfo == nil {
				o.ClientInfo = &dhcpm.ClientInfoArrayV6{}
			}
			if err := o.ClientInfo.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ClientInfo := func(ptr interface{}) { o.ClientInfo = *ptr.(**dhcpm.ClientInfoArrayV6) }
		if err := w.ReadPointer(&o.ClientInfo, _s_ClientInfo, _ptr_ClientInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ClientsRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ClientsRead); err != nil {
			return err
		}
	}
	// ClientsTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ClientsTotal); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumSubnetClientsV6Request structure represents the R_DhcpEnumSubnetClientsV6 operation request
type EnumSubnetClientsV6Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// SubnetAddress: This is of type DHCP_IPV6_ADDRESS (section 2.2.1.2.28), containing
	// the IPv6 prefix ID from which DHCPv6 clients are enumerated.
	SubnetAddress *dhcpm.IPv6Address `idl:"name:SubnetAddress" json:"subnet_address"`
	// ResumeHandle: This is a pointer of type DHCP_RESUME_IPV6_HANDLE (section 2.2.1.1.14)
	// that identifies the enumeration operation. Initially, this value MUST be set to zero,
	// with a successful call returning the handle value used for subsequent enumeration
	// requests. This field contains the last IPv6 address retrieved from the DHCPv6 client.
	Resume *dhcpm.ResumeIPv6Handle `idl:"name:ResumeHandle" json:"resume"`
	// PreferredMaximum: This is of type DWORD, specifying the preferred maximum number
	// of bytes to return. The minimum value is 1,024 bytes (1 kilobyte), and the maximum
	// value is 65,536 bytes (64 kilobytes); if the input value is greater or less than
	// this range, it MUST be set to the maximum or minimum value, respectively. To retrieve
	// all the DHCPv6 clients serviced by a specific IPv6 prefix, 0xFFFFFFFF is specified.
	PreferredMaximum uint32 `idl:"name:PreferredMaximum" json:"preferred_maximum"`
}

func (o *EnumSubnetClientsV6Request) xxx_ToOp(ctx context.Context, op *xxx_EnumSubnetClientsV6Operation) *xxx_EnumSubnetClientsV6Operation {
	if op == nil {
		op = &xxx_EnumSubnetClientsV6Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.SubnetAddress = o.SubnetAddress
	op.Resume = o.Resume
	op.PreferredMaximum = o.PreferredMaximum
	return op
}

func (o *EnumSubnetClientsV6Request) xxx_FromOp(ctx context.Context, op *xxx_EnumSubnetClientsV6Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.SubnetAddress = op.SubnetAddress
	o.Resume = op.Resume
	o.PreferredMaximum = op.PreferredMaximum
}
func (o *EnumSubnetClientsV6Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumSubnetClientsV6Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumSubnetClientsV6Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumSubnetClientsV6Response structure represents the R_DhcpEnumSubnetClientsV6 operation response
type EnumSubnetClientsV6Response struct {
	// ResumeHandle: This is a pointer of type DHCP_RESUME_IPV6_HANDLE (section 2.2.1.1.14)
	// that identifies the enumeration operation. Initially, this value MUST be set to zero,
	// with a successful call returning the handle value used for subsequent enumeration
	// requests. This field contains the last IPv6 address retrieved from the DHCPv6 client.
	Resume *dhcpm.ResumeIPv6Handle `idl:"name:ResumeHandle" json:"resume"`
	// ClientInfo: This is a pointer of type LPDHCP_CLIENT_INFO_ARRAY_V6 that points to
	// the location that contains the DHCPv6 client lease record array.
	ClientInfo *dhcpm.ClientInfoArrayV6 `idl:"name:ClientInfo" json:"client_info"`
	// ClientsRead: This is a pointer to a DWORD that specifies the number of DHCPv6 client
	// lease records read in ClientInfo. The caller MUST allocate memory for this parameter
	// equal to the size of data type DWORD.
	ClientsRead uint32 `idl:"name:ClientsRead" json:"clients_read"`
	// ClientsTotal: This is a pointer to a DWORD that specifies the number of DHCPv6 client
	// lease records remaining from the current position. For example, if there are 100
	// DHCPv6 lease record clients for an IPv6 prefix and if 10 DHCPv6 lease records are
	// enumerated per call, then for the first time this would have a value of 90.<66> The
	// caller MUST allocate memory for this parameter equal to the size of data type DWORD.
	ClientsTotal uint32 `idl:"name:ClientsTotal" json:"clients_total"`
	// Return: The R_DhcpEnumSubnetClientsV6 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumSubnetClientsV6Response) xxx_ToOp(ctx context.Context, op *xxx_EnumSubnetClientsV6Operation) *xxx_EnumSubnetClientsV6Operation {
	if op == nil {
		op = &xxx_EnumSubnetClientsV6Operation{}
	}
	if o == nil {
		return op
	}
	op.Resume = o.Resume
	op.ClientInfo = o.ClientInfo
	op.ClientsRead = o.ClientsRead
	op.ClientsTotal = o.ClientsTotal
	op.Return = o.Return
	return op
}

func (o *EnumSubnetClientsV6Response) xxx_FromOp(ctx context.Context, op *xxx_EnumSubnetClientsV6Operation) {
	if o == nil {
		return
	}
	o.Resume = op.Resume
	o.ClientInfo = op.ClientInfo
	o.ClientsRead = op.ClientsRead
	o.ClientsTotal = op.ClientsTotal
	o.Return = op.Return
}
func (o *EnumSubnetClientsV6Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumSubnetClientsV6Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumSubnetClientsV6Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ServerSetConfigV6Operation structure represents the R_DhcpServerSetConfigV6 operation
type xxx_ServerSetConfigV6Operation struct {
	ServerIPAddress string                    `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	ScopeInfo       *dhcpm.OptionScopeInfo6   `idl:"name:ScopeInfo;pointer:ref" json:"scope_info"`
	FieldsToSet     uint32                    `idl:"name:FieldsToSet" json:"fields_to_set"`
	ConfigInfo      *dhcpm.ServerConfigInfoV6 `idl:"name:ConfigInfo;pointer:ref" json:"config_info"`
	Return          uint32                    `idl:"name:Return" json:"return"`
}

func (o *xxx_ServerSetConfigV6Operation) OpNum() int { return 65 }

func (o *xxx_ServerSetConfigV6Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpServerSetConfigV6"
}

func (o *xxx_ServerSetConfigV6Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ServerSetConfigV6Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ScopeInfo {in} (1:{pointer=ref, alias=LPDHCP_OPTION_SCOPE_INFO6}*(1))(2:{alias=DHCP_OPTION_SCOPE_INFO6}(struct))
	{
		if o.ScopeInfo != nil {
			if err := o.ScopeInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.OptionScopeInfo6{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// FieldsToSet {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.FieldsToSet); err != nil {
			return err
		}
	}
	// ConfigInfo {in} (1:{pointer=ref, alias=LPDHCP_SERVER_CONFIG_INFO_V6}*(1))(2:{alias=DHCP_SERVER_CONFIG_INFO_V6}(struct))
	{
		if o.ConfigInfo != nil {
			if err := o.ConfigInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.ServerConfigInfoV6{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_ServerSetConfigV6Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ScopeInfo {in} (1:{pointer=ref, alias=LPDHCP_OPTION_SCOPE_INFO6}*(1))(2:{alias=DHCP_OPTION_SCOPE_INFO6}(struct))
	{
		if o.ScopeInfo == nil {
			o.ScopeInfo = &dhcpm.OptionScopeInfo6{}
		}
		if err := o.ScopeInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// FieldsToSet {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.FieldsToSet); err != nil {
			return err
		}
	}
	// ConfigInfo {in} (1:{pointer=ref, alias=LPDHCP_SERVER_CONFIG_INFO_V6}*(1))(2:{alias=DHCP_SERVER_CONFIG_INFO_V6}(struct))
	{
		if o.ConfigInfo == nil {
			o.ConfigInfo = &dhcpm.ServerConfigInfoV6{}
		}
		if err := o.ConfigInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ServerSetConfigV6Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ServerSetConfigV6Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ServerSetConfigV6Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ServerSetConfigV6Request structure represents the R_DhcpServerSetConfigV6 operation request
type ServerSetConfigV6Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// ScopeInfo: This is a pointer to a LPDHCP_OPTION_SCOPE_INFO6 (section 2.2.1.2.30)
	// that contains the configuration information at the scope or server level.
	ScopeInfo *dhcpm.OptionScopeInfo6 `idl:"name:ScopeInfo;pointer:ref" json:"scope_info"`
	// FieldsToSet: Specifies the fields to be set (see section 2.2.1.2.62 for details of
	// the fields).<68> Valid values are in the following table.
	//
	//	+--------------------------------------+-------------------------------------------------------------+
	//	|                                      |                                                             |
	//	|                VALUE                 |                           MEANING                           |
	//	|                                      |                                                             |
	//	+--------------------------------------+-------------------------------------------------------------+
	//	+--------------------------------------+-------------------------------------------------------------+
	//	| Set_UnicastFlag 0x00000001           | Set unicast option.                                         |
	//	+--------------------------------------+-------------------------------------------------------------+
	//	| Set_RapidCommitFlag 0x00000002       | Set rapid commit option.                                    |
	//	+--------------------------------------+-------------------------------------------------------------+
	//	| Set_PreferredLifetime 0x00000004     | Set preferred lifetime value for nontemporary IPv6 address. |
	//	+--------------------------------------+-------------------------------------------------------------+
	//	| Set_ValidLifetime 0x00000008         | Set valid lifetime value for nontemporary IPv6 address.     |
	//	+--------------------------------------+-------------------------------------------------------------+
	//	| Set_T1 0x00000010                    | Set T1 time value.                                          |
	//	+--------------------------------------+-------------------------------------------------------------+
	//	| Set_T2 0x00000020                    | Set T2 time value.                                          |
	//	+--------------------------------------+-------------------------------------------------------------+
	//	| Set_PreferredLifetimeIATA 0x00000040 | Set preferred lifetime value for temporary IPv6 address.    |
	//	+--------------------------------------+-------------------------------------------------------------+
	//	| Set_ValidLifetimeIATA 0x00000080     | Set valid lifetime value for temporary IPv6 address.        |
	//	+--------------------------------------+-------------------------------------------------------------+
	//	| Set_AuditLogState 0x00000800         | Set audit log state in the registry.                        |
	//	+--------------------------------------+-------------------------------------------------------------+
	FieldsToSet uint32 `idl:"name:FieldsToSet" json:"fields_to_set"`
	// ConfigInfo: This is a pointer of type LPDHCP_SERVER_CONFIG_INFO_V6 (section 2.2.1.2.62)
	// that contains values for the field specified by the FieldsToSet.
	ConfigInfo *dhcpm.ServerConfigInfoV6 `idl:"name:ConfigInfo;pointer:ref" json:"config_info"`
}

func (o *ServerSetConfigV6Request) xxx_ToOp(ctx context.Context, op *xxx_ServerSetConfigV6Operation) *xxx_ServerSetConfigV6Operation {
	if op == nil {
		op = &xxx_ServerSetConfigV6Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.ScopeInfo = o.ScopeInfo
	op.FieldsToSet = o.FieldsToSet
	op.ConfigInfo = o.ConfigInfo
	return op
}

func (o *ServerSetConfigV6Request) xxx_FromOp(ctx context.Context, op *xxx_ServerSetConfigV6Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.ScopeInfo = op.ScopeInfo
	o.FieldsToSet = op.FieldsToSet
	o.ConfigInfo = op.ConfigInfo
}
func (o *ServerSetConfigV6Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *ServerSetConfigV6Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ServerSetConfigV6Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ServerSetConfigV6Response structure represents the R_DhcpServerSetConfigV6 operation response
type ServerSetConfigV6Response struct {
	// Return: The R_DhcpServerSetConfigV6 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ServerSetConfigV6Response) xxx_ToOp(ctx context.Context, op *xxx_ServerSetConfigV6Operation) *xxx_ServerSetConfigV6Operation {
	if op == nil {
		op = &xxx_ServerSetConfigV6Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *ServerSetConfigV6Response) xxx_FromOp(ctx context.Context, op *xxx_ServerSetConfigV6Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *ServerSetConfigV6Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *ServerSetConfigV6Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ServerSetConfigV6Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ServerGetConfigV6Operation structure represents the R_DhcpServerGetConfigV6 operation
type xxx_ServerGetConfigV6Operation struct {
	ServerIPAddress string                    `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	ScopeInfo       *dhcpm.OptionScopeInfo6   `idl:"name:ScopeInfo;pointer:ref" json:"scope_info"`
	ConfigInfo      *dhcpm.ServerConfigInfoV6 `idl:"name:ConfigInfo" json:"config_info"`
	Return          uint32                    `idl:"name:Return" json:"return"`
}

func (o *xxx_ServerGetConfigV6Operation) OpNum() int { return 66 }

func (o *xxx_ServerGetConfigV6Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpServerGetConfigV6"
}

func (o *xxx_ServerGetConfigV6Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ServerGetConfigV6Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ScopeInfo {in} (1:{pointer=ref, alias=LPDHCP_OPTION_SCOPE_INFO6}*(1))(2:{alias=DHCP_OPTION_SCOPE_INFO6}(struct))
	{
		if o.ScopeInfo != nil {
			if err := o.ScopeInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.OptionScopeInfo6{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_ServerGetConfigV6Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ScopeInfo {in} (1:{pointer=ref, alias=LPDHCP_OPTION_SCOPE_INFO6}*(1))(2:{alias=DHCP_OPTION_SCOPE_INFO6}(struct))
	{
		if o.ScopeInfo == nil {
			o.ScopeInfo = &dhcpm.OptionScopeInfo6{}
		}
		if err := o.ScopeInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ServerGetConfigV6Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ServerGetConfigV6Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ConfigInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_SERVER_CONFIG_INFO_V6}*(1))(3:{alias=DHCP_SERVER_CONFIG_INFO_V6}(struct))
	{
		if o.ConfigInfo != nil {
			_ptr_ConfigInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.ConfigInfo != nil {
					if err := o.ConfigInfo.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.ServerConfigInfoV6{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ConfigInfo, _ptr_ConfigInfo); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ServerGetConfigV6Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ConfigInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_SERVER_CONFIG_INFO_V6,pointer=ref}*(1))(3:{alias=DHCP_SERVER_CONFIG_INFO_V6}(struct))
	{
		_ptr_ConfigInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.ConfigInfo == nil {
				o.ConfigInfo = &dhcpm.ServerConfigInfoV6{}
			}
			if err := o.ConfigInfo.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ConfigInfo := func(ptr interface{}) { o.ConfigInfo = *ptr.(**dhcpm.ServerConfigInfoV6) }
		if err := w.ReadPointer(&o.ConfigInfo, _s_ConfigInfo, _ptr_ConfigInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ServerGetConfigV6Request structure represents the R_DhcpServerGetConfigV6 operation request
type ServerGetConfigV6Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// ScopeInfo: This is a pointer of type DHCP_OPTION_SCOPE_INFO6 (section 2.2.1.2.30)
	// that is used to identify the scope whose configuration information is to be retrieved.
	ScopeInfo *dhcpm.OptionScopeInfo6 `idl:"name:ScopeInfo;pointer:ref" json:"scope_info"`
}

func (o *ServerGetConfigV6Request) xxx_ToOp(ctx context.Context, op *xxx_ServerGetConfigV6Operation) *xxx_ServerGetConfigV6Operation {
	if op == nil {
		op = &xxx_ServerGetConfigV6Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.ScopeInfo = o.ScopeInfo
	return op
}

func (o *ServerGetConfigV6Request) xxx_FromOp(ctx context.Context, op *xxx_ServerGetConfigV6Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.ScopeInfo = op.ScopeInfo
}
func (o *ServerGetConfigV6Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *ServerGetConfigV6Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ServerGetConfigV6Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ServerGetConfigV6Response structure represents the R_DhcpServerGetConfigV6 operation response
type ServerGetConfigV6Response struct {
	// ConfigInfo: This is a pointer of type LPDHCP_SERVER_CONFIG_INFO_V6 that points to
	// a location that contains the configuration information.
	ConfigInfo *dhcpm.ServerConfigInfoV6 `idl:"name:ConfigInfo" json:"config_info"`
	// Return: The R_DhcpServerGetConfigV6 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ServerGetConfigV6Response) xxx_ToOp(ctx context.Context, op *xxx_ServerGetConfigV6Operation) *xxx_ServerGetConfigV6Operation {
	if op == nil {
		op = &xxx_ServerGetConfigV6Operation{}
	}
	if o == nil {
		return op
	}
	op.ConfigInfo = o.ConfigInfo
	op.Return = o.Return
	return op
}

func (o *ServerGetConfigV6Response) xxx_FromOp(ctx context.Context, op *xxx_ServerGetConfigV6Operation) {
	if o == nil {
		return
	}
	o.ConfigInfo = op.ConfigInfo
	o.Return = op.Return
}
func (o *ServerGetConfigV6Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *ServerGetConfigV6Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ServerGetConfigV6Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetSubnetInfoV6Operation structure represents the R_DhcpSetSubnetInfoV6 operation
type xxx_SetSubnetInfoV6Operation struct {
	ServerIPAddress string              `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	SubnetAddress   *dhcpm.IPv6Address  `idl:"name:SubnetAddress" json:"subnet_address"`
	SubnetInfo      *dhcpm.SubnetInfoV6 `idl:"name:SubnetInfo;pointer:ref" json:"subnet_info"`
	Return          uint32              `idl:"name:Return" json:"return"`
}

func (o *xxx_SetSubnetInfoV6Operation) OpNum() int { return 67 }

func (o *xxx_SetSubnetInfoV6Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpSetSubnetInfoV6" }

func (o *xxx_SetSubnetInfoV6Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetSubnetInfoV6Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IPV6_ADDRESS}(struct))
	{
		if o.SubnetAddress != nil {
			if err := o.SubnetAddress.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.IPv6Address{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// SubnetInfo {in} (1:{pointer=ref, alias=LPDHCP_SUBNET_INFO_V6}*(1))(2:{alias=DHCP_SUBNET_INFO_V6}(struct))
	{
		if o.SubnetInfo != nil {
			if err := o.SubnetInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.SubnetInfoV6{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetSubnetInfoV6Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IPV6_ADDRESS}(struct))
	{
		if o.SubnetAddress == nil {
			o.SubnetAddress = &dhcpm.IPv6Address{}
		}
		if err := o.SubnetAddress.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// SubnetInfo {in} (1:{pointer=ref, alias=LPDHCP_SUBNET_INFO_V6}*(1))(2:{alias=DHCP_SUBNET_INFO_V6}(struct))
	{
		if o.SubnetInfo == nil {
			o.SubnetInfo = &dhcpm.SubnetInfoV6{}
		}
		if err := o.SubnetInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetSubnetInfoV6Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetSubnetInfoV6Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetSubnetInfoV6Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetSubnetInfoV6Request structure represents the R_DhcpSetSubnetInfoV6 operation request
type SetSubnetInfoV6Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// SubnetAddress: This is of the type DHCP_IPV6_ADDRESS, containing the IPv6 prefix
	// ID for which the subnet information is modified.
	SubnetAddress *dhcpm.IPv6Address `idl:"name:SubnetAddress" json:"subnet_address"`
	// SubnetInfo: This is a pointer to structure DHCP_SUBNET_INFO_V6 (section 2.2.1.2.56)
	// that contains information of the IPv6 prefix that is modified in the existing IPv6
	// prefix identified by SubnetAddress.
	SubnetInfo *dhcpm.SubnetInfoV6 `idl:"name:SubnetInfo;pointer:ref" json:"subnet_info"`
}

func (o *SetSubnetInfoV6Request) xxx_ToOp(ctx context.Context, op *xxx_SetSubnetInfoV6Operation) *xxx_SetSubnetInfoV6Operation {
	if op == nil {
		op = &xxx_SetSubnetInfoV6Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.SubnetAddress = o.SubnetAddress
	op.SubnetInfo = o.SubnetInfo
	return op
}

func (o *SetSubnetInfoV6Request) xxx_FromOp(ctx context.Context, op *xxx_SetSubnetInfoV6Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.SubnetAddress = op.SubnetAddress
	o.SubnetInfo = op.SubnetInfo
}
func (o *SetSubnetInfoV6Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetSubnetInfoV6Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetSubnetInfoV6Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetSubnetInfoV6Response structure represents the R_DhcpSetSubnetInfoV6 operation response
type SetSubnetInfoV6Response struct {
	// Return: The R_DhcpSetSubnetInfoV6 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetSubnetInfoV6Response) xxx_ToOp(ctx context.Context, op *xxx_SetSubnetInfoV6Operation) *xxx_SetSubnetInfoV6Operation {
	if op == nil {
		op = &xxx_SetSubnetInfoV6Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetSubnetInfoV6Response) xxx_FromOp(ctx context.Context, op *xxx_SetSubnetInfoV6Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetSubnetInfoV6Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetSubnetInfoV6Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetSubnetInfoV6Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetMIBInfoV6Operation structure represents the R_DhcpGetMibInfoV6 operation
type xxx_GetMIBInfoV6Operation struct {
	ServerIPAddress string           `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	MIBInfo         *dhcpm.MIBInfoV6 `idl:"name:MibInfo" json:"mib_info"`
	Return          uint32           `idl:"name:Return" json:"return"`
}

func (o *xxx_GetMIBInfoV6Operation) OpNum() int { return 68 }

func (o *xxx_GetMIBInfoV6Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpGetMibInfoV6" }

func (o *xxx_GetMIBInfoV6Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMIBInfoV6Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMIBInfoV6Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMIBInfoV6Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMIBInfoV6Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// MibInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_MIB_INFO_V6}*(1))(3:{alias=DHCP_MIB_INFO_V6}(struct))
	{
		if o.MIBInfo != nil {
			_ptr_MibInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.MIBInfo != nil {
					if err := o.MIBInfo.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.MIBInfoV6{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.MIBInfo, _ptr_MibInfo); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMIBInfoV6Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// MibInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_MIB_INFO_V6,pointer=ref}*(1))(3:{alias=DHCP_MIB_INFO_V6}(struct))
	{
		_ptr_MibInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.MIBInfo == nil {
				o.MIBInfo = &dhcpm.MIBInfoV6{}
			}
			if err := o.MIBInfo.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_MibInfo := func(ptr interface{}) { o.MIBInfo = *ptr.(**dhcpm.MIBInfoV6) }
		if err := w.ReadPointer(&o.MIBInfo, _s_MibInfo, _ptr_MibInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetMIBInfoV6Request structure represents the R_DhcpGetMibInfoV6 operation request
type GetMIBInfoV6Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
}

func (o *GetMIBInfoV6Request) xxx_ToOp(ctx context.Context, op *xxx_GetMIBInfoV6Operation) *xxx_GetMIBInfoV6Operation {
	if op == nil {
		op = &xxx_GetMIBInfoV6Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	return op
}

func (o *GetMIBInfoV6Request) xxx_FromOp(ctx context.Context, op *xxx_GetMIBInfoV6Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
}
func (o *GetMIBInfoV6Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetMIBInfoV6Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetMIBInfoV6Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetMIBInfoV6Response structure represents the R_DhcpGetMibInfoV6 operation response
type GetMIBInfoV6Response struct {
	// MibInfo: This is a pointer of type LPDHCP_MIB_INFO_V6 that points to the location
	// that contains IPv6 MIB information about the DHCPv6 server.
	MIBInfo *dhcpm.MIBInfoV6 `idl:"name:MibInfo" json:"mib_info"`
	// Return: The R_DhcpGetMibInfoV6 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetMIBInfoV6Response) xxx_ToOp(ctx context.Context, op *xxx_GetMIBInfoV6Operation) *xxx_GetMIBInfoV6Operation {
	if op == nil {
		op = &xxx_GetMIBInfoV6Operation{}
	}
	if o == nil {
		return op
	}
	op.MIBInfo = o.MIBInfo
	op.Return = o.Return
	return op
}

func (o *GetMIBInfoV6Response) xxx_FromOp(ctx context.Context, op *xxx_GetMIBInfoV6Operation) {
	if o == nil {
		return
	}
	o.MIBInfo = op.MIBInfo
	o.Return = op.Return
}
func (o *GetMIBInfoV6Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetMIBInfoV6Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetMIBInfoV6Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetServerBindingInfoV6Operation structure represents the R_DhcpGetServerBindingInfoV6 operation
type xxx_GetServerBindingInfoV6Operation struct {
	ServerIPAddress  string                    `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Flags            uint32                    `idl:"name:Flags" json:"flags"`
	BindElementsInfo *dhcpm.BindElementArrayV6 `idl:"name:BindElementsInfo" json:"bind_elements_info"`
	Return           uint32                    `idl:"name:Return" json:"return"`
}

func (o *xxx_GetServerBindingInfoV6Operation) OpNum() int { return 69 }

func (o *xxx_GetServerBindingInfoV6Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpGetServerBindingInfoV6"
}

func (o *xxx_GetServerBindingInfoV6Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServerBindingInfoV6Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServerBindingInfoV6Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServerBindingInfoV6Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServerBindingInfoV6Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// BindElementsInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCPV6_BIND_ELEMENT_ARRAY}*(1))(3:{alias=DHCPV6_BIND_ELEMENT_ARRAY}(struct))
	{
		if o.BindElementsInfo != nil {
			_ptr_BindElementsInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.BindElementsInfo != nil {
					if err := o.BindElementsInfo.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.BindElementArrayV6{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.BindElementsInfo, _ptr_BindElementsInfo); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetServerBindingInfoV6Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// BindElementsInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCPV6_BIND_ELEMENT_ARRAY,pointer=ref}*(1))(3:{alias=DHCPV6_BIND_ELEMENT_ARRAY}(struct))
	{
		_ptr_BindElementsInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.BindElementsInfo == nil {
				o.BindElementsInfo = &dhcpm.BindElementArrayV6{}
			}
			if err := o.BindElementsInfo.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_BindElementsInfo := func(ptr interface{}) { o.BindElementsInfo = *ptr.(**dhcpm.BindElementArrayV6) }
		if err := w.ReadPointer(&o.BindElementsInfo, _s_BindElementsInfo, _ptr_BindElementsInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetServerBindingInfoV6Request structure represents the R_DhcpGetServerBindingInfoV6 operation request
type GetServerBindingInfoV6Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// Flags: This flag is not used, and it MUST be set to 0.
	Flags uint32 `idl:"name:Flags" json:"flags"`
}

func (o *GetServerBindingInfoV6Request) xxx_ToOp(ctx context.Context, op *xxx_GetServerBindingInfoV6Operation) *xxx_GetServerBindingInfoV6Operation {
	if op == nil {
		op = &xxx_GetServerBindingInfoV6Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Flags = o.Flags
	return op
}

func (o *GetServerBindingInfoV6Request) xxx_FromOp(ctx context.Context, op *xxx_GetServerBindingInfoV6Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Flags = op.Flags
}
func (o *GetServerBindingInfoV6Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetServerBindingInfoV6Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetServerBindingInfoV6Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetServerBindingInfoV6Response structure represents the R_DhcpGetServerBindingInfoV6 operation response
type GetServerBindingInfoV6Response struct {
	// BindElementsInfo: This is a pointer of type LPDHCPV6_BIND_ELEMENT_ARRAY that points
	// to the location in which the information about the IPv6 interface binding is retrieved.
	BindElementsInfo *dhcpm.BindElementArrayV6 `idl:"name:BindElementsInfo" json:"bind_elements_info"`
	// Return: The R_DhcpGetServerBindingInfoV6 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetServerBindingInfoV6Response) xxx_ToOp(ctx context.Context, op *xxx_GetServerBindingInfoV6Operation) *xxx_GetServerBindingInfoV6Operation {
	if op == nil {
		op = &xxx_GetServerBindingInfoV6Operation{}
	}
	if o == nil {
		return op
	}
	op.BindElementsInfo = o.BindElementsInfo
	op.Return = o.Return
	return op
}

func (o *GetServerBindingInfoV6Response) xxx_FromOp(ctx context.Context, op *xxx_GetServerBindingInfoV6Operation) {
	if o == nil {
		return
	}
	o.BindElementsInfo = op.BindElementsInfo
	o.Return = op.Return
}
func (o *GetServerBindingInfoV6Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetServerBindingInfoV6Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetServerBindingInfoV6Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetServerBindingInfoV6Operation structure represents the R_DhcpSetServerBindingInfoV6 operation
type xxx_SetServerBindingInfoV6Operation struct {
	ServerIPAddress  string                    `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Flags            uint32                    `idl:"name:Flags" json:"flags"`
	BindElementsInfo *dhcpm.BindElementArrayV6 `idl:"name:BindElementsInfo;pointer:ref" json:"bind_elements_info"`
	Return           uint32                    `idl:"name:Return" json:"return"`
}

func (o *xxx_SetServerBindingInfoV6Operation) OpNum() int { return 70 }

func (o *xxx_SetServerBindingInfoV6Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpSetServerBindingInfoV6"
}

func (o *xxx_SetServerBindingInfoV6Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetServerBindingInfoV6Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	// BindElementsInfo {in} (1:{pointer=ref, alias=LPDHCPV6_BIND_ELEMENT_ARRAY}*(1))(2:{alias=DHCPV6_BIND_ELEMENT_ARRAY}(struct))
	{
		if o.BindElementsInfo != nil {
			if err := o.BindElementsInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.BindElementArrayV6{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetServerBindingInfoV6Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	// BindElementsInfo {in} (1:{pointer=ref, alias=LPDHCPV6_BIND_ELEMENT_ARRAY}*(1))(2:{alias=DHCPV6_BIND_ELEMENT_ARRAY}(struct))
	{
		if o.BindElementsInfo == nil {
			o.BindElementsInfo = &dhcpm.BindElementArrayV6{}
		}
		if err := o.BindElementsInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetServerBindingInfoV6Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetServerBindingInfoV6Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetServerBindingInfoV6Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetServerBindingInfoV6Request structure represents the R_DhcpSetServerBindingInfoV6 operation request
type SetServerBindingInfoV6Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// Flags: This flag is not used, and it MUST be set to 0.
	Flags uint32 `idl:"name:Flags" json:"flags"`
	// BindElementsInfo: This is a pointer of type DHCPV6_BIND_ELEMENT_ARRAY (section 2.2.1.2.83)
	// that points to the location that contains the information about the IPv6 interface
	// binding.
	BindElementsInfo *dhcpm.BindElementArrayV6 `idl:"name:BindElementsInfo;pointer:ref" json:"bind_elements_info"`
}

func (o *SetServerBindingInfoV6Request) xxx_ToOp(ctx context.Context, op *xxx_SetServerBindingInfoV6Operation) *xxx_SetServerBindingInfoV6Operation {
	if op == nil {
		op = &xxx_SetServerBindingInfoV6Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Flags = o.Flags
	op.BindElementsInfo = o.BindElementsInfo
	return op
}

func (o *SetServerBindingInfoV6Request) xxx_FromOp(ctx context.Context, op *xxx_SetServerBindingInfoV6Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Flags = op.Flags
	o.BindElementsInfo = op.BindElementsInfo
}
func (o *SetServerBindingInfoV6Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetServerBindingInfoV6Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetServerBindingInfoV6Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetServerBindingInfoV6Response structure represents the R_DhcpSetServerBindingInfoV6 operation response
type SetServerBindingInfoV6Response struct {
	// Return: The R_DhcpSetServerBindingInfoV6 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetServerBindingInfoV6Response) xxx_ToOp(ctx context.Context, op *xxx_SetServerBindingInfoV6Operation) *xxx_SetServerBindingInfoV6Operation {
	if op == nil {
		op = &xxx_SetServerBindingInfoV6Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetServerBindingInfoV6Response) xxx_FromOp(ctx context.Context, op *xxx_SetServerBindingInfoV6Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetServerBindingInfoV6Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetServerBindingInfoV6Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetServerBindingInfoV6Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetClientInfoV6Operation structure represents the R_DhcpSetClientInfoV6 operation
type xxx_SetClientInfoV6Operation struct {
	ServerIPAddress string              `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	ClientInfo      *dhcpm.ClientInfoV6 `idl:"name:ClientInfo;pointer:ref" json:"client_info"`
	Return          uint32              `idl:"name:Return" json:"return"`
}

func (o *xxx_SetClientInfoV6Operation) OpNum() int { return 71 }

func (o *xxx_SetClientInfoV6Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpSetClientInfoV6" }

func (o *xxx_SetClientInfoV6Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetClientInfoV6Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ClientInfo {in} (1:{pointer=ref, alias=LPDHCP_CLIENT_INFO_V6}*(1))(2:{alias=DHCP_CLIENT_INFO_V6}(struct))
	{
		if o.ClientInfo != nil {
			if err := o.ClientInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.ClientInfoV6{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetClientInfoV6Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ClientInfo {in} (1:{pointer=ref, alias=LPDHCP_CLIENT_INFO_V6}*(1))(2:{alias=DHCP_CLIENT_INFO_V6}(struct))
	{
		if o.ClientInfo == nil {
			o.ClientInfo = &dhcpm.ClientInfoV6{}
		}
		if err := o.ClientInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetClientInfoV6Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetClientInfoV6Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetClientInfoV6Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetClientInfoV6Request structure represents the R_DhcpSetClientInfoV6 operation request
type SetClientInfoV6Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// ClientInfo: This is a pointer of type section DHCP_CLIENT_INFO_V6 (section 2.2.1.2.64)
	// that contains the DHCPv6 client lease record information that needs to be modified
	// on the DHCPv6 server database.
	ClientInfo *dhcpm.ClientInfoV6 `idl:"name:ClientInfo;pointer:ref" json:"client_info"`
}

func (o *SetClientInfoV6Request) xxx_ToOp(ctx context.Context, op *xxx_SetClientInfoV6Operation) *xxx_SetClientInfoV6Operation {
	if op == nil {
		op = &xxx_SetClientInfoV6Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.ClientInfo = o.ClientInfo
	return op
}

func (o *SetClientInfoV6Request) xxx_FromOp(ctx context.Context, op *xxx_SetClientInfoV6Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.ClientInfo = op.ClientInfo
}
func (o *SetClientInfoV6Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetClientInfoV6Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetClientInfoV6Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetClientInfoV6Response structure represents the R_DhcpSetClientInfoV6 operation response
type SetClientInfoV6Response struct {
	// Return: The R_DhcpSetClientInfoV6 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetClientInfoV6Response) xxx_ToOp(ctx context.Context, op *xxx_SetClientInfoV6Operation) *xxx_SetClientInfoV6Operation {
	if op == nil {
		op = &xxx_SetClientInfoV6Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetClientInfoV6Response) xxx_FromOp(ctx context.Context, op *xxx_SetClientInfoV6Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetClientInfoV6Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetClientInfoV6Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetClientInfoV6Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetClientInfoV6Operation structure represents the R_DhcpGetClientInfoV6 operation
type xxx_GetClientInfoV6Operation struct {
	ServerIPAddress string              `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	SearchInfo      *dhcpm.SearchInfoV6 `idl:"name:SearchInfo;pointer:ref" json:"search_info"`
	ClientInfo      *dhcpm.ClientInfoV6 `idl:"name:ClientInfo" json:"client_info"`
	Return          uint32              `idl:"name:Return" json:"return"`
}

func (o *xxx_GetClientInfoV6Operation) OpNum() int { return 72 }

func (o *xxx_GetClientInfoV6Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpGetClientInfoV6" }

func (o *xxx_GetClientInfoV6Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetClientInfoV6Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// SearchInfo {in} (1:{pointer=ref, alias=LPDHCP_SEARCH_INFO_V6}*(1))(2:{alias=DHCP_SEARCH_INFO_V6}(struct))
	{
		if o.SearchInfo != nil {
			if err := o.SearchInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.SearchInfoV6{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetClientInfoV6Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// SearchInfo {in} (1:{pointer=ref, alias=LPDHCP_SEARCH_INFO_V6}*(1))(2:{alias=DHCP_SEARCH_INFO_V6}(struct))
	{
		if o.SearchInfo == nil {
			o.SearchInfo = &dhcpm.SearchInfoV6{}
		}
		if err := o.SearchInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetClientInfoV6Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetClientInfoV6Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ClientInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_CLIENT_INFO_V6}*(1))(3:{alias=DHCP_CLIENT_INFO_V6}(struct))
	{
		if o.ClientInfo != nil {
			_ptr_ClientInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.ClientInfo != nil {
					if err := o.ClientInfo.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.ClientInfoV6{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ClientInfo, _ptr_ClientInfo); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetClientInfoV6Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ClientInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_CLIENT_INFO_V6,pointer=ref}*(1))(3:{alias=DHCP_CLIENT_INFO_V6}(struct))
	{
		_ptr_ClientInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.ClientInfo == nil {
				o.ClientInfo = &dhcpm.ClientInfoV6{}
			}
			if err := o.ClientInfo.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ClientInfo := func(ptr interface{}) { o.ClientInfo = *ptr.(**dhcpm.ClientInfoV6) }
		if err := w.ReadPointer(&o.ClientInfo, _s_ClientInfo, _ptr_ClientInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetClientInfoV6Request structure represents the R_DhcpGetClientInfoV6 operation request
type GetClientInfoV6Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// SearchInfo: This is a pointer to a structure DHCP_SEARCH_INFO_V6 (section 2.2.1.2.69)
	// that specifies the parameter to be used for retrieving the IPv6 address lease information
	// of IPv6 reservation.
	//
	// For this call with SearchType of Dhcpv6ClientDUID (section 2.2.1.1.12), ERROR_INVALID_PARAMETER
	// is returned.
	SearchInfo *dhcpm.SearchInfoV6 `idl:"name:SearchInfo;pointer:ref" json:"search_info"`
}

func (o *GetClientInfoV6Request) xxx_ToOp(ctx context.Context, op *xxx_GetClientInfoV6Operation) *xxx_GetClientInfoV6Operation {
	if op == nil {
		op = &xxx_GetClientInfoV6Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.SearchInfo = o.SearchInfo
	return op
}

func (o *GetClientInfoV6Request) xxx_FromOp(ctx context.Context, op *xxx_GetClientInfoV6Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.SearchInfo = op.SearchInfo
}
func (o *GetClientInfoV6Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetClientInfoV6Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetClientInfoV6Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetClientInfoV6Response structure represents the R_DhcpGetClientInfoV6 operation response
type GetClientInfoV6Response struct {
	// ClientInfo: This is a pointer to type LPDHCP_CLIENT_INFO_V6 that points to a location
	// in which IPv6 address lease information of IPv6 reservation is retrieved. The caller
	// can free up this buffer after using this.
	ClientInfo *dhcpm.ClientInfoV6 `idl:"name:ClientInfo" json:"client_info"`
	// Return: The R_DhcpGetClientInfoV6 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetClientInfoV6Response) xxx_ToOp(ctx context.Context, op *xxx_GetClientInfoV6Operation) *xxx_GetClientInfoV6Operation {
	if op == nil {
		op = &xxx_GetClientInfoV6Operation{}
	}
	if o == nil {
		return op
	}
	op.ClientInfo = o.ClientInfo
	op.Return = o.Return
	return op
}

func (o *GetClientInfoV6Response) xxx_FromOp(ctx context.Context, op *xxx_GetClientInfoV6Operation) {
	if o == nil {
		return
	}
	o.ClientInfo = op.ClientInfo
	o.Return = op.Return
}
func (o *GetClientInfoV6Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetClientInfoV6Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetClientInfoV6Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_DeleteClientInfoV6Operation structure represents the R_DhcpDeleteClientInfoV6 operation
type xxx_DeleteClientInfoV6Operation struct {
	ServerIPAddress string              `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	ClientInfo      *dhcpm.SearchInfoV6 `idl:"name:ClientInfo;pointer:ref" json:"client_info"`
	Return          uint32              `idl:"name:Return" json:"return"`
}

func (o *xxx_DeleteClientInfoV6Operation) OpNum() int { return 73 }

func (o *xxx_DeleteClientInfoV6Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpDeleteClientInfoV6"
}

func (o *xxx_DeleteClientInfoV6Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteClientInfoV6Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ClientInfo {in} (1:{pointer=ref, alias=LPDHCP_SEARCH_INFO_V6}*(1))(2:{alias=DHCP_SEARCH_INFO_V6}(struct))
	{
		if o.ClientInfo != nil {
			if err := o.ClientInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.SearchInfoV6{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteClientInfoV6Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ClientInfo {in} (1:{pointer=ref, alias=LPDHCP_SEARCH_INFO_V6}*(1))(2:{alias=DHCP_SEARCH_INFO_V6}(struct))
	{
		if o.ClientInfo == nil {
			o.ClientInfo = &dhcpm.SearchInfoV6{}
		}
		if err := o.ClientInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteClientInfoV6Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteClientInfoV6Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteClientInfoV6Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// DeleteClientInfoV6Request structure represents the R_DhcpDeleteClientInfoV6 operation request
type DeleteClientInfoV6Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// ClientInfo: This is a pointer to a structure DHCP_SEARCH_INFO_V6 (section 2.2.1.2.69)
	// that defines the key to be used to search the DHCPv6 client lease record that needs
	// to be deleted on the DHCPv6 server.
	ClientInfo *dhcpm.SearchInfoV6 `idl:"name:ClientInfo;pointer:ref" json:"client_info"`
}

func (o *DeleteClientInfoV6Request) xxx_ToOp(ctx context.Context, op *xxx_DeleteClientInfoV6Operation) *xxx_DeleteClientInfoV6Operation {
	if op == nil {
		op = &xxx_DeleteClientInfoV6Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.ClientInfo = o.ClientInfo
	return op
}

func (o *DeleteClientInfoV6Request) xxx_FromOp(ctx context.Context, op *xxx_DeleteClientInfoV6Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.ClientInfo = op.ClientInfo
}
func (o *DeleteClientInfoV6Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *DeleteClientInfoV6Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteClientInfoV6Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// DeleteClientInfoV6Response structure represents the R_DhcpDeleteClientInfoV6 operation response
type DeleteClientInfoV6Response struct {
	// Return: The R_DhcpDeleteClientInfoV6 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *DeleteClientInfoV6Response) xxx_ToOp(ctx context.Context, op *xxx_DeleteClientInfoV6Operation) *xxx_DeleteClientInfoV6Operation {
	if op == nil {
		op = &xxx_DeleteClientInfoV6Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *DeleteClientInfoV6Response) xxx_FromOp(ctx context.Context, op *xxx_DeleteClientInfoV6Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *DeleteClientInfoV6Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *DeleteClientInfoV6Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteClientInfoV6Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CreateClassV6Operation structure represents the R_DhcpCreateClassV6 operation
type xxx_CreateClassV6Operation struct {
	ServerIPAddress string             `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	_               uint32             `idl:"name:ReservedMustBeZero"`
	ClassInfo       *dhcpm.ClassInfoV6 `idl:"name:ClassInfo" json:"class_info"`
	Return          uint32             `idl:"name:Return" json:"return"`
}

func (o *xxx_CreateClassV6Operation) OpNum() int { return 74 }

func (o *xxx_CreateClassV6Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpCreateClassV6" }

func (o *xxx_CreateClassV6Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateClassV6Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ReservedMustBeZero {in} (1:{alias=DWORD}(uint32))
	{
		// reserved ReservedMustBeZero
		if err := w.WriteData(uint32(0)); err != nil {
			return err
		}
	}
	// ClassInfo {in} (1:{alias=LPDHCP_CLASS_INFO_V6}*(1))(2:{alias=DHCP_CLASS_INFO_V6}(struct))
	{
		if o.ClassInfo != nil {
			if err := o.ClassInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.ClassInfoV6{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateClassV6Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ReservedMustBeZero {in} (1:{alias=DWORD}(uint32))
	{
		// reserved ReservedMustBeZero
		var _ReservedMustBeZero uint32
		if err := w.ReadData(&_ReservedMustBeZero); err != nil {
			return err
		}
	}
	// ClassInfo {in} (1:{alias=LPDHCP_CLASS_INFO_V6,pointer=ref}*(1))(2:{alias=DHCP_CLASS_INFO_V6}(struct))
	{
		if o.ClassInfo == nil {
			o.ClassInfo = &dhcpm.ClassInfoV6{}
		}
		if err := o.ClassInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateClassV6Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateClassV6Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateClassV6Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CreateClassV6Request structure represents the R_DhcpCreateClassV6 operation request
type CreateClassV6Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// ClassInfo: This is of type DHCP_CLASS_INFO_V6 (section 2.2.1.2.70), containing information
	// regarding a class.
	ClassInfo *dhcpm.ClassInfoV6 `idl:"name:ClassInfo" json:"class_info"`
}

func (o *CreateClassV6Request) xxx_ToOp(ctx context.Context, op *xxx_CreateClassV6Operation) *xxx_CreateClassV6Operation {
	if op == nil {
		op = &xxx_CreateClassV6Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.ClassInfo = o.ClassInfo
	return op
}

func (o *CreateClassV6Request) xxx_FromOp(ctx context.Context, op *xxx_CreateClassV6Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.ClassInfo = op.ClassInfo
}
func (o *CreateClassV6Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *CreateClassV6Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateClassV6Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CreateClassV6Response structure represents the R_DhcpCreateClassV6 operation response
type CreateClassV6Response struct {
	// Return: The R_DhcpCreateClassV6 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CreateClassV6Response) xxx_ToOp(ctx context.Context, op *xxx_CreateClassV6Operation) *xxx_CreateClassV6Operation {
	if op == nil {
		op = &xxx_CreateClassV6Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *CreateClassV6Response) xxx_FromOp(ctx context.Context, op *xxx_CreateClassV6Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *CreateClassV6Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *CreateClassV6Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateClassV6Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ModifyClassV6Operation structure represents the R_DhcpModifyClassV6 operation
type xxx_ModifyClassV6Operation struct {
	ServerIPAddress string             `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	_               uint32             `idl:"name:ReservedMustBeZero"`
	ClassInfo       *dhcpm.ClassInfoV6 `idl:"name:ClassInfo" json:"class_info"`
	Return          uint32             `idl:"name:Return" json:"return"`
}

func (o *xxx_ModifyClassV6Operation) OpNum() int { return 75 }

func (o *xxx_ModifyClassV6Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpModifyClassV6" }

func (o *xxx_ModifyClassV6Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ModifyClassV6Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ReservedMustBeZero {in} (1:{alias=DWORD}(uint32))
	{
		// reserved ReservedMustBeZero
		if err := w.WriteData(uint32(0)); err != nil {
			return err
		}
	}
	// ClassInfo {in} (1:{alias=LPDHCP_CLASS_INFO_V6}*(1))(2:{alias=DHCP_CLASS_INFO_V6}(struct))
	{
		if o.ClassInfo != nil {
			if err := o.ClassInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.ClassInfoV6{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ModifyClassV6Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ReservedMustBeZero {in} (1:{alias=DWORD}(uint32))
	{
		// reserved ReservedMustBeZero
		var _ReservedMustBeZero uint32
		if err := w.ReadData(&_ReservedMustBeZero); err != nil {
			return err
		}
	}
	// ClassInfo {in} (1:{alias=LPDHCP_CLASS_INFO_V6,pointer=ref}*(1))(2:{alias=DHCP_CLASS_INFO_V6}(struct))
	{
		if o.ClassInfo == nil {
			o.ClassInfo = &dhcpm.ClassInfoV6{}
		}
		if err := o.ClassInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ModifyClassV6Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ModifyClassV6Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ModifyClassV6Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ModifyClassV6Request structure represents the R_DhcpModifyClassV6 operation request
type ModifyClassV6Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// ClassInfo: This is of type DHCP_CLASS_INFO_V6 (section 2.2.1.2.70), containing information
	// regarding a user class or a vendor class.
	ClassInfo *dhcpm.ClassInfoV6 `idl:"name:ClassInfo" json:"class_info"`
}

func (o *ModifyClassV6Request) xxx_ToOp(ctx context.Context, op *xxx_ModifyClassV6Operation) *xxx_ModifyClassV6Operation {
	if op == nil {
		op = &xxx_ModifyClassV6Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.ClassInfo = o.ClassInfo
	return op
}

func (o *ModifyClassV6Request) xxx_FromOp(ctx context.Context, op *xxx_ModifyClassV6Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.ClassInfo = op.ClassInfo
}
func (o *ModifyClassV6Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *ModifyClassV6Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ModifyClassV6Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ModifyClassV6Response structure represents the R_DhcpModifyClassV6 operation response
type ModifyClassV6Response struct {
	// Return: The R_DhcpModifyClassV6 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ModifyClassV6Response) xxx_ToOp(ctx context.Context, op *xxx_ModifyClassV6Operation) *xxx_ModifyClassV6Operation {
	if op == nil {
		op = &xxx_ModifyClassV6Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *ModifyClassV6Response) xxx_FromOp(ctx context.Context, op *xxx_ModifyClassV6Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *ModifyClassV6Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *ModifyClassV6Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ModifyClassV6Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_DeleteClassV6Operation structure represents the R_DhcpDeleteClassV6 operation
type xxx_DeleteClassV6Operation struct {
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	_               uint32 `idl:"name:ReservedMustBeZero"`
	ClassName       string `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
	Return          uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_DeleteClassV6Operation) OpNum() int { return 76 }

func (o *xxx_DeleteClassV6Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpDeleteClassV6" }

func (o *xxx_DeleteClassV6Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteClassV6Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ReservedMustBeZero {in} (1:{alias=DWORD}(uint32))
	{
		// reserved ReservedMustBeZero
		if err := w.WriteData(uint32(0)); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.ClassName != "" {
			_ptr_ClassName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ClassName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ClassName, _ptr_ClassName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteClassV6Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ReservedMustBeZero {in} (1:{alias=DWORD}(uint32))
	{
		// reserved ReservedMustBeZero
		var _ReservedMustBeZero uint32
		if err := w.ReadData(&_ReservedMustBeZero); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_ClassName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ClassName); err != nil {
				return err
			}
			return nil
		})
		_s_ClassName := func(ptr interface{}) { o.ClassName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ClassName, _s_ClassName, _ptr_ClassName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteClassV6Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteClassV6Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteClassV6Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// DeleteClassV6Request structure represents the R_DhcpDeleteClassV6 operation request
type DeleteClassV6Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// ClassName: This is a pointer to WCHAR that contains the name of the class that needs
	// to be deleted.
	ClassName string `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
}

func (o *DeleteClassV6Request) xxx_ToOp(ctx context.Context, op *xxx_DeleteClassV6Operation) *xxx_DeleteClassV6Operation {
	if op == nil {
		op = &xxx_DeleteClassV6Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.ClassName = o.ClassName
	return op
}

func (o *DeleteClassV6Request) xxx_FromOp(ctx context.Context, op *xxx_DeleteClassV6Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.ClassName = op.ClassName
}
func (o *DeleteClassV6Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *DeleteClassV6Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteClassV6Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// DeleteClassV6Response structure represents the R_DhcpDeleteClassV6 operation response
type DeleteClassV6Response struct {
	// Return: The R_DhcpDeleteClassV6 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *DeleteClassV6Response) xxx_ToOp(ctx context.Context, op *xxx_DeleteClassV6Operation) *xxx_DeleteClassV6Operation {
	if op == nil {
		op = &xxx_DeleteClassV6Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *DeleteClassV6Response) xxx_FromOp(ctx context.Context, op *xxx_DeleteClassV6Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *DeleteClassV6Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *DeleteClassV6Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteClassV6Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumClassesV6Operation structure represents the R_DhcpEnumClassesV6 operation
type xxx_EnumClassesV6Operation struct {
	ServerIPAddress  string                  `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	_                uint32                  `idl:"name:ReservedMustBeZero"`
	Resume           uint32                  `idl:"name:ResumeHandle" json:"resume"`
	PreferredMaximum uint32                  `idl:"name:PreferredMaximum" json:"preferred_maximum"`
	ClassInfoArray   *dhcpm.ClassInfoArrayV6 `idl:"name:ClassInfoArray" json:"class_info_array"`
	Read             uint32                  `idl:"name:nRead" json:"read"`
	Total            uint32                  `idl:"name:nTotal" json:"total"`
	Return           uint32                  `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumClassesV6Operation) OpNum() int { return 77 }

func (o *xxx_EnumClassesV6Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpEnumClassesV6" }

func (o *xxx_EnumClassesV6Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumClassesV6Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ReservedMustBeZero {in} (1:{alias=DWORD}(uint32))
	{
		// reserved ReservedMustBeZero
		if err := w.WriteData(uint32(0)); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Resume); err != nil {
			return err
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PreferredMaximum); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumClassesV6Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ReservedMustBeZero {in} (1:{alias=DWORD}(uint32))
	{
		// reserved ReservedMustBeZero
		var _ReservedMustBeZero uint32
		if err := w.ReadData(&_ReservedMustBeZero); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Resume); err != nil {
			return err
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PreferredMaximum); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumClassesV6Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumClassesV6Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Resume); err != nil {
			return err
		}
	}
	// ClassInfoArray {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_CLASS_INFO_ARRAY_V6}*(1))(3:{alias=DHCP_CLASS_INFO_ARRAY_V6}(struct))
	{
		if o.ClassInfoArray != nil {
			_ptr_ClassInfoArray := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.ClassInfoArray != nil {
					if err := o.ClassInfoArray.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.ClassInfoArrayV6{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ClassInfoArray, _ptr_ClassInfoArray); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// nRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Read); err != nil {
			return err
		}
	}
	// nTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Total); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumClassesV6Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Resume); err != nil {
			return err
		}
	}
	// ClassInfoArray {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_CLASS_INFO_ARRAY_V6,pointer=ref}*(1))(3:{alias=DHCP_CLASS_INFO_ARRAY_V6}(struct))
	{
		_ptr_ClassInfoArray := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.ClassInfoArray == nil {
				o.ClassInfoArray = &dhcpm.ClassInfoArrayV6{}
			}
			if err := o.ClassInfoArray.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ClassInfoArray := func(ptr interface{}) { o.ClassInfoArray = *ptr.(**dhcpm.ClassInfoArrayV6) }
		if err := w.ReadPointer(&o.ClassInfoArray, _s_ClassInfoArray, _ptr_ClassInfoArray); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// nRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Read); err != nil {
			return err
		}
	}
	// nTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Total); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumClassesV6Request structure represents the R_DhcpEnumClassesV6 operation request
type EnumClassesV6Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// ResumeHandle: This is a pointer of type DHCP_RESUME_HANDLE (section 2.2.1.2.6) that
	// identifies the enumeration operation. Initially, this value MUST be set to zero,
	// with a successful call returning the handle value used for subsequent enumeration
	// requests (for example, if PreferredMaximum is set to 100 and 200 classes are stored).
	// On the DHCPv6 server, the resume handle can be used after the first 100 classes are
	// retrieved to obtain the next 100 on a subsequent call, and so forth.
	Resume uint32 `idl:"name:ResumeHandle" json:"resume"`
	// PreferredMaximum: This is of type DWORD, specifying the preferred maximum number
	// of bytes to be returned. If the number of bytes required in memory for the remaining
	// unenumerated classes is less than the value of this parameter, then all the classes
	// for the DHCPv6 server are returned. To retrieve all the classes defined on the DHCPv6
	// server, 0xFFFFFFFF is specified.
	PreferredMaximum uint32 `idl:"name:PreferredMaximum" json:"preferred_maximum"`
}

func (o *EnumClassesV6Request) xxx_ToOp(ctx context.Context, op *xxx_EnumClassesV6Operation) *xxx_EnumClassesV6Operation {
	if op == nil {
		op = &xxx_EnumClassesV6Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Resume = o.Resume
	op.PreferredMaximum = o.PreferredMaximum
	return op
}

func (o *EnumClassesV6Request) xxx_FromOp(ctx context.Context, op *xxx_EnumClassesV6Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Resume = op.Resume
	o.PreferredMaximum = op.PreferredMaximum
}
func (o *EnumClassesV6Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumClassesV6Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumClassesV6Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumClassesV6Response structure represents the R_DhcpEnumClassesV6 operation response
type EnumClassesV6Response struct {
	// ResumeHandle: This is a pointer of type DHCP_RESUME_HANDLE (section 2.2.1.2.6) that
	// identifies the enumeration operation. Initially, this value MUST be set to zero,
	// with a successful call returning the handle value used for subsequent enumeration
	// requests (for example, if PreferredMaximum is set to 100 and 200 classes are stored).
	// On the DHCPv6 server, the resume handle can be used after the first 100 classes are
	// retrieved to obtain the next 100 on a subsequent call, and so forth.
	Resume uint32 `idl:"name:ResumeHandle" json:"resume"`
	// ClassInfoArray: This is a pointer of type LPDHCP_CLASS_INFO_ARRAY_V6 in which information
	// of all the classes defined on the DHCPv6 server is retrieved.
	ClassInfoArray *dhcpm.ClassInfoArrayV6 `idl:"name:ClassInfoArray" json:"class_info_array"`
	// nRead: This is a pointer to a DWORD value that specifies the number of classes returned
	// in ClassInfoArray. The caller must allocate memory for this parameter that is equal
	// to the size of data type DWORD.
	Read uint32 `idl:"name:nRead" json:"read"`
	// nTotal: This is a pointer to a DWORD value that specifies the number of classes defined
	// on the DHCPv6 server that have not yet been enumerated. The caller must allocate
	// memory for this parameter that is equal to the size of data type DWORD.
	Total uint32 `idl:"name:nTotal" json:"total"`
	// Return: The R_DhcpEnumClassesV6 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumClassesV6Response) xxx_ToOp(ctx context.Context, op *xxx_EnumClassesV6Operation) *xxx_EnumClassesV6Operation {
	if op == nil {
		op = &xxx_EnumClassesV6Operation{}
	}
	if o == nil {
		return op
	}
	op.Resume = o.Resume
	op.ClassInfoArray = o.ClassInfoArray
	op.Read = o.Read
	op.Total = o.Total
	op.Return = o.Return
	return op
}

func (o *EnumClassesV6Response) xxx_FromOp(ctx context.Context, op *xxx_EnumClassesV6Operation) {
	if o == nil {
		return
	}
	o.Resume = op.Resume
	o.ClassInfoArray = op.ClassInfoArray
	o.Read = op.Read
	o.Total = op.Total
	o.Return = op.Return
}
func (o *EnumClassesV6Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumClassesV6Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumClassesV6Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetOptionValueV6Operation structure represents the R_DhcpGetOptionValueV6 operation
type xxx_GetOptionValueV6Operation struct {
	ServerIPAddress string                  `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Flags           uint32                  `idl:"name:Flags" json:"flags"`
	OptionID        uint32                  `idl:"name:OptionID" json:"option_id"`
	ClassName       string                  `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
	VendorName      string                  `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	ScopeInfo       *dhcpm.OptionScopeInfo6 `idl:"name:ScopeInfo" json:"scope_info"`
	OptionValue     *dhcpm.OptionValue      `idl:"name:OptionValue" json:"option_value"`
	Return          uint32                  `idl:"name:Return" json:"return"`
}

func (o *xxx_GetOptionValueV6Operation) OpNum() int { return 78 }

func (o *xxx_GetOptionValueV6Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpGetOptionValueV6" }

func (o *xxx_GetOptionValueV6Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetOptionValueV6Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	// OptionID {in} (1:{alias=DHCP_OPTION_ID, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.OptionID); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.ClassName != "" {
			_ptr_ClassName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ClassName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ClassName, _ptr_ClassName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.VendorName != "" {
			_ptr_VendorName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.VendorName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.VendorName, _ptr_VendorName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ScopeInfo {in} (1:{alias=LPDHCP_OPTION_SCOPE_INFO6}*(1))(2:{alias=DHCP_OPTION_SCOPE_INFO6}(struct))
	{
		if o.ScopeInfo != nil {
			if err := o.ScopeInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.OptionScopeInfo6{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_GetOptionValueV6Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	// OptionID {in} (1:{alias=DHCP_OPTION_ID, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OptionID); err != nil {
			return err
		}
	}
	// ClassName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_ClassName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ClassName); err != nil {
				return err
			}
			return nil
		})
		_s_ClassName := func(ptr interface{}) { o.ClassName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ClassName, _s_ClassName, _ptr_ClassName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_VendorName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.VendorName); err != nil {
				return err
			}
			return nil
		})
		_s_VendorName := func(ptr interface{}) { o.VendorName = *ptr.(*string) }
		if err := w.ReadPointer(&o.VendorName, _s_VendorName, _ptr_VendorName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ScopeInfo {in} (1:{alias=LPDHCP_OPTION_SCOPE_INFO6,pointer=ref}*(1))(2:{alias=DHCP_OPTION_SCOPE_INFO6}(struct))
	{
		if o.ScopeInfo == nil {
			o.ScopeInfo = &dhcpm.OptionScopeInfo6{}
		}
		if err := o.ScopeInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetOptionValueV6Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetOptionValueV6Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// OptionValue {out} (1:{alias=LPDHCP_OPTION_VALUE}*(1))(2:{alias=DHCP_OPTION_VALUE}(struct))
	{
		if o.OptionValue != nil {
			if err := o.OptionValue.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.OptionValue{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetOptionValueV6Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// OptionValue {out} (1:{alias=LPDHCP_OPTION_VALUE,pointer=ref}*(1))(2:{alias=DHCP_OPTION_VALUE}(struct))
	{
		if o.OptionValue == nil {
			o.OptionValue = &dhcpm.OptionValue{}
		}
		if err := o.OptionValue.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetOptionValueV6Request structure represents the R_DhcpGetOptionValueV6 operation request
type GetOptionValueV6Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// Flags: A value that indicates if the option whose value is retrieved is for a specific
	// vendor class or default vendor class.
	//
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                        |                                                                                  |
	//	|                 VALUE                  |                                     MEANING                                      |
	//	|                                        |                                                                                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_DEFAULT 0x00000000   | Option value is retrieved for the default vendor class.                          |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_IS_VENDOR 0x00000003 | If a bitwise AND operation with this bitmask yields a nonzero value, it          |
	//	|                                        | indicates that the option value is retrieved for the specified vendor class.     |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	Flags uint32 `idl:"name:Flags" json:"flags"`
	// OptionID: This is of type DHCP_OPTION_ID (section 2.2.1.2.3), containing the option
	// identifier for the option being retrieved.
	OptionID uint32 `idl:"name:OptionID" json:"option_id"`
	// ClassName: A pointer to a null-terminated Unicode string that contains the name of
	// the user class for which the option value is being requested. This parameter is optional.
	ClassName string `idl:"name:ClassName;string;pointer:unique" json:"class_name"`
	// VendorName: A pointer to a null-terminated Unicode string that contains the name
	// of the vendor class for which the option value is being requested. If the vendor
	// class is not specified, the default vendor class is used.
	VendorName string `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	// ScopeInfo: This is a pointer to a DHCP_OPTION_SCOPE_INFO6 (section 2.2.1.2.30) that
	// contains information describing the DHCPv6 scope this option value is retrieved on.
	// This value defines that option is being retrieved from the default, server, or scope
	// level or for an IPv6 reservation.
	ScopeInfo *dhcpm.OptionScopeInfo6 `idl:"name:ScopeInfo" json:"scope_info"`
}

func (o *GetOptionValueV6Request) xxx_ToOp(ctx context.Context, op *xxx_GetOptionValueV6Operation) *xxx_GetOptionValueV6Operation {
	if op == nil {
		op = &xxx_GetOptionValueV6Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Flags = o.Flags
	op.OptionID = o.OptionID
	op.ClassName = o.ClassName
	op.VendorName = o.VendorName
	op.ScopeInfo = o.ScopeInfo
	return op
}

func (o *GetOptionValueV6Request) xxx_FromOp(ctx context.Context, op *xxx_GetOptionValueV6Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Flags = op.Flags
	o.OptionID = op.OptionID
	o.ClassName = op.ClassName
	o.VendorName = op.VendorName
	o.ScopeInfo = op.ScopeInfo
}
func (o *GetOptionValueV6Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetOptionValueV6Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetOptionValueV6Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetOptionValueV6Response structure represents the R_DhcpGetOptionValueV6 operation response
type GetOptionValueV6Response struct {
	// OptionValue: This is a pointer of type LPDHCP_OPTION_VALUE in which the option value
	// is retrieved corresponding to OptionID. For dynamic DNS update settings, see section
	// 3.3.2.
	OptionValue *dhcpm.OptionValue `idl:"name:OptionValue" json:"option_value"`
	// Return: The R_DhcpGetOptionValueV6 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetOptionValueV6Response) xxx_ToOp(ctx context.Context, op *xxx_GetOptionValueV6Operation) *xxx_GetOptionValueV6Operation {
	if op == nil {
		op = &xxx_GetOptionValueV6Operation{}
	}
	if o == nil {
		return op
	}
	op.OptionValue = o.OptionValue
	op.Return = o.Return
	return op
}

func (o *GetOptionValueV6Response) xxx_FromOp(ctx context.Context, op *xxx_GetOptionValueV6Operation) {
	if o == nil {
		return
	}
	o.OptionValue = op.OptionValue
	o.Return = op.Return
}
func (o *GetOptionValueV6Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetOptionValueV6Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetOptionValueV6Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetSubnetDelayOfferOperation structure represents the R_DhcpSetSubnetDelayOffer operation
type xxx_SetSubnetDelayOfferOperation struct {
	ServerIPAddress         string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	SubnetAddress           uint32 `idl:"name:SubnetAddress" json:"subnet_address"`
	TimeDelayInMilliseconds uint16 `idl:"name:TimeDelayInMilliseconds" json:"time_delay_in_milliseconds"`
	Return                  uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_SetSubnetDelayOfferOperation) OpNum() int { return 79 }

func (o *xxx_SetSubnetDelayOfferOperation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpSetSubnetDelayOffer"
}

func (o *xxx_SetSubnetDelayOfferOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetSubnetDelayOfferOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.SubnetAddress); err != nil {
			return err
		}
	}
	// TimeDelayInMilliseconds {in} (1:{alias=USHORT}(uint16))
	{
		if err := w.WriteData(o.TimeDelayInMilliseconds); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetSubnetDelayOfferOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.SubnetAddress); err != nil {
			return err
		}
	}
	// TimeDelayInMilliseconds {in} (1:{alias=USHORT}(uint16))
	{
		if err := w.ReadData(&o.TimeDelayInMilliseconds); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetSubnetDelayOfferOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetSubnetDelayOfferOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetSubnetDelayOfferOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetSubnetDelayOfferRequest structure represents the R_DhcpSetSubnetDelayOffer operation request
type SetSubnetDelayOfferRequest struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// SubnetAddress: This is of type DHCP_IP_ADDRESS (section 2.2.1.2.1) which contains
	// the IPv4 subnet ID for which the subnet delay time is set.
	SubnetAddress uint32 `idl:"name:SubnetAddress" json:"subnet_address"`
	// TimeDelayInMilliseconds: This is of type USHORT and contains the value of the time
	// delay in milliseconds, set for a specific scope.
	//
	//	+----------------------+-------------------------+
	//	|        VALUE         |                         |
	//	|    (MILLISECONDS)    |       DESCRIPTION       |
	//	|                      |                         |
	//	+----------------------+-------------------------+
	//	+----------------------+-------------------------+
	//	|                    0 | Minimum Delay (default) |
	//	+----------------------+-------------------------+
	//	|                 1000 | Maximum Delay           |
	//	+----------------------+-------------------------+
	TimeDelayInMilliseconds uint16 `idl:"name:TimeDelayInMilliseconds" json:"time_delay_in_milliseconds"`
}

func (o *SetSubnetDelayOfferRequest) xxx_ToOp(ctx context.Context, op *xxx_SetSubnetDelayOfferOperation) *xxx_SetSubnetDelayOfferOperation {
	if op == nil {
		op = &xxx_SetSubnetDelayOfferOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.SubnetAddress = o.SubnetAddress
	op.TimeDelayInMilliseconds = o.TimeDelayInMilliseconds
	return op
}

func (o *SetSubnetDelayOfferRequest) xxx_FromOp(ctx context.Context, op *xxx_SetSubnetDelayOfferOperation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.SubnetAddress = op.SubnetAddress
	o.TimeDelayInMilliseconds = op.TimeDelayInMilliseconds
}
func (o *SetSubnetDelayOfferRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetSubnetDelayOfferRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetSubnetDelayOfferOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetSubnetDelayOfferResponse structure represents the R_DhcpSetSubnetDelayOffer operation response
type SetSubnetDelayOfferResponse struct {
	// Return: The R_DhcpSetSubnetDelayOffer return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetSubnetDelayOfferResponse) xxx_ToOp(ctx context.Context, op *xxx_SetSubnetDelayOfferOperation) *xxx_SetSubnetDelayOfferOperation {
	if op == nil {
		op = &xxx_SetSubnetDelayOfferOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetSubnetDelayOfferResponse) xxx_FromOp(ctx context.Context, op *xxx_SetSubnetDelayOfferOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetSubnetDelayOfferResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetSubnetDelayOfferResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetSubnetDelayOfferOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetSubnetDelayOfferOperation structure represents the R_DhcpGetSubnetDelayOffer operation
type xxx_GetSubnetDelayOfferOperation struct {
	ServerIPAddress         string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	SubnetAddress           uint32 `idl:"name:SubnetAddress" json:"subnet_address"`
	TimeDelayInMilliseconds uint16 `idl:"name:TimeDelayInMilliseconds" json:"time_delay_in_milliseconds"`
	Return                  uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetSubnetDelayOfferOperation) OpNum() int { return 80 }

func (o *xxx_GetSubnetDelayOfferOperation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpGetSubnetDelayOffer"
}

func (o *xxx_GetSubnetDelayOfferOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetSubnetDelayOfferOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.SubnetAddress); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetSubnetDelayOfferOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.SubnetAddress); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetSubnetDelayOfferOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetSubnetDelayOfferOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// TimeDelayInMilliseconds {out} (1:{pointer=ref}*(1))(2:{alias=USHORT}(uint16))
	{
		if err := w.WriteData(o.TimeDelayInMilliseconds); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetSubnetDelayOfferOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// TimeDelayInMilliseconds {out} (1:{pointer=ref}*(1))(2:{alias=USHORT}(uint16))
	{
		if err := w.ReadData(&o.TimeDelayInMilliseconds); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetSubnetDelayOfferRequest structure represents the R_DhcpGetSubnetDelayOffer operation request
type GetSubnetDelayOfferRequest struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// SubnetAddress: This is of type DHCP_IP_ADDRESS (section 2.2.1.2.1), which contains
	// the IPv4 subnet ID for which the subnet delay time is set.
	SubnetAddress uint32 `idl:"name:SubnetAddress" json:"subnet_address"`
}

func (o *GetSubnetDelayOfferRequest) xxx_ToOp(ctx context.Context, op *xxx_GetSubnetDelayOfferOperation) *xxx_GetSubnetDelayOfferOperation {
	if op == nil {
		op = &xxx_GetSubnetDelayOfferOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.SubnetAddress = o.SubnetAddress
	return op
}

func (o *GetSubnetDelayOfferRequest) xxx_FromOp(ctx context.Context, op *xxx_GetSubnetDelayOfferOperation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.SubnetAddress = op.SubnetAddress
}
func (o *GetSubnetDelayOfferRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetSubnetDelayOfferRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetSubnetDelayOfferOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetSubnetDelayOfferResponse structure represents the R_DhcpGetSubnetDelayOffer operation response
type GetSubnetDelayOfferResponse struct {
	// TimeDelayInMilliseconds: This is a pointer of the type USHORT, which provides the
	// value of the time delay in milliseconds set for a specific scope.
	TimeDelayInMilliseconds uint16 `idl:"name:TimeDelayInMilliseconds" json:"time_delay_in_milliseconds"`
	// Return: The R_DhcpGetSubnetDelayOffer return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetSubnetDelayOfferResponse) xxx_ToOp(ctx context.Context, op *xxx_GetSubnetDelayOfferOperation) *xxx_GetSubnetDelayOfferOperation {
	if op == nil {
		op = &xxx_GetSubnetDelayOfferOperation{}
	}
	if o == nil {
		return op
	}
	op.TimeDelayInMilliseconds = o.TimeDelayInMilliseconds
	op.Return = o.Return
	return op
}

func (o *GetSubnetDelayOfferResponse) xxx_FromOp(ctx context.Context, op *xxx_GetSubnetDelayOfferOperation) {
	if o == nil {
		return
	}
	o.TimeDelayInMilliseconds = op.TimeDelayInMilliseconds
	o.Return = op.Return
}
func (o *GetSubnetDelayOfferResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetSubnetDelayOfferResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetSubnetDelayOfferOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetMIBInfoV5Operation structure represents the R_DhcpGetMibInfoV5 operation
type xxx_GetMIBInfoV5Operation struct {
	ServerIPAddress string           `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	MIBInfo         *dhcpm.MIBInfoV5 `idl:"name:MibInfo" json:"mib_info"`
	Return          uint32           `idl:"name:Return" json:"return"`
}

func (o *xxx_GetMIBInfoV5Operation) OpNum() int { return 81 }

func (o *xxx_GetMIBInfoV5Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpGetMibInfoV5" }

func (o *xxx_GetMIBInfoV5Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMIBInfoV5Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMIBInfoV5Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMIBInfoV5Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMIBInfoV5Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// MibInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_MIB_INFO_V5}*(1))(3:{alias=DHCP_MIB_INFO_V5}(struct))
	{
		if o.MIBInfo != nil {
			_ptr_MibInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.MIBInfo != nil {
					if err := o.MIBInfo.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.MIBInfoV5{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.MIBInfo, _ptr_MibInfo); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetMIBInfoV5Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// MibInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_MIB_INFO_V5,pointer=ref}*(1))(3:{alias=DHCP_MIB_INFO_V5}(struct))
	{
		_ptr_MibInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.MIBInfo == nil {
				o.MIBInfo = &dhcpm.MIBInfoV5{}
			}
			if err := o.MIBInfo.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_MibInfo := func(ptr interface{}) { o.MIBInfo = *ptr.(**dhcpm.MIBInfoV5) }
		if err := w.ReadPointer(&o.MIBInfo, _s_MibInfo, _ptr_MibInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetMIBInfoV5Request structure represents the R_DhcpGetMibInfoV5 operation request
type GetMIBInfoV5Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
}

func (o *GetMIBInfoV5Request) xxx_ToOp(ctx context.Context, op *xxx_GetMIBInfoV5Operation) *xxx_GetMIBInfoV5Operation {
	if op == nil {
		op = &xxx_GetMIBInfoV5Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	return op
}

func (o *GetMIBInfoV5Request) xxx_FromOp(ctx context.Context, op *xxx_GetMIBInfoV5Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
}
func (o *GetMIBInfoV5Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetMIBInfoV5Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetMIBInfoV5Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetMIBInfoV5Response structure represents the R_DhcpGetMibInfoV5 operation response
type GetMIBInfoV5Response struct {
	// MibInfo: This is a pointer of type LPDHCP_MIB_INFO_V5 that points to the location
	// that contains DHCPv4 server statistics.
	MIBInfo *dhcpm.MIBInfoV5 `idl:"name:MibInfo" json:"mib_info"`
	// Return: The R_DhcpGetMibInfoV5 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetMIBInfoV5Response) xxx_ToOp(ctx context.Context, op *xxx_GetMIBInfoV5Operation) *xxx_GetMIBInfoV5Operation {
	if op == nil {
		op = &xxx_GetMIBInfoV5Operation{}
	}
	if o == nil {
		return op
	}
	op.MIBInfo = o.MIBInfo
	op.Return = o.Return
	return op
}

func (o *GetMIBInfoV5Response) xxx_FromOp(ctx context.Context, op *xxx_GetMIBInfoV5Operation) {
	if o == nil {
		return
	}
	o.MIBInfo = op.MIBInfo
	o.Return = op.Return
}
func (o *GetMIBInfoV5Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetMIBInfoV5Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetMIBInfoV5Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddFilterV4Operation structure represents the R_DhcpAddFilterV4 operation
type xxx_AddFilterV4Operation struct {
	ServerIPAddress string               `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	AddFilterInfo   *dhcpm.FilterAddInfo `idl:"name:AddFilterInfo" json:"add_filter_info"`
	ForceFlag       bool                 `idl:"name:ForceFlag" json:"force_flag"`
	Return          uint32               `idl:"name:Return" json:"return"`
}

func (o *xxx_AddFilterV4Operation) OpNum() int { return 82 }

func (o *xxx_AddFilterV4Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpAddFilterV4" }

func (o *xxx_AddFilterV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFilterV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// AddFilterInfo {in} (1:{pointer=ref}*(1))(2:{alias=DHCP_FILTER_ADD_INFO}(struct))
	{
		if o.AddFilterInfo != nil {
			if err := o.AddFilterInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.FilterAddInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ForceFlag {in} (1:{alias=BOOL}(int32))
	{
		if !o.ForceFlag {
			if err := w.WriteData(int32(0)); err != nil {
				return err
			}
		} else {
			if err := w.WriteData(int32(1)); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_AddFilterV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// AddFilterInfo {in} (1:{pointer=ref}*(1))(2:{alias=DHCP_FILTER_ADD_INFO}(struct))
	{
		if o.AddFilterInfo == nil {
			o.AddFilterInfo = &dhcpm.FilterAddInfo{}
		}
		if err := o.AddFilterInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ForceFlag {in} (1:{alias=BOOL}(int32))
	{
		var _bForceFlag int32
		if err := w.ReadData(&_bForceFlag); err != nil {
			return err
		}
		o.ForceFlag = _bForceFlag != 0
	}
	return nil
}

func (o *xxx_AddFilterV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFilterV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFilterV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddFilterV4Request structure represents the R_DhcpAddFilterV4 operation request
type AddFilterV4Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// AddFilterInfo: This is a pointer to a DHCP_FILTER_ADD_INFO (section 2.2.1.2.90) that
	// contains link-layer address/pattern , hardware type information, or both to be added
	// to the database.
	AddFilterInfo *dhcpm.FilterAddInfo `idl:"name:AddFilterInfo" json:"add_filter_info"`
	// ForceFlag: This is of type BOOL that defines the behavior of this method. If the
	// flag is set to TRUE and the filter exists, then it will be overwritten, else if the
	// flag is FALSE and the filter already exists, then it will remain the same and will
	// return error ERROR_DHCP_LINKLAYER_ADDDRESS_EXISTS.
	ForceFlag bool `idl:"name:ForceFlag" json:"force_flag"`
}

func (o *AddFilterV4Request) xxx_ToOp(ctx context.Context, op *xxx_AddFilterV4Operation) *xxx_AddFilterV4Operation {
	if op == nil {
		op = &xxx_AddFilterV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.AddFilterInfo = o.AddFilterInfo
	op.ForceFlag = o.ForceFlag
	return op
}

func (o *AddFilterV4Request) xxx_FromOp(ctx context.Context, op *xxx_AddFilterV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.AddFilterInfo = op.AddFilterInfo
	o.ForceFlag = op.ForceFlag
}
func (o *AddFilterV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *AddFilterV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddFilterV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddFilterV4Response structure represents the R_DhcpAddFilterV4 operation response
type AddFilterV4Response struct {
	// Return: The R_DhcpAddFilterV4 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddFilterV4Response) xxx_ToOp(ctx context.Context, op *xxx_AddFilterV4Operation) *xxx_AddFilterV4Operation {
	if op == nil {
		op = &xxx_AddFilterV4Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *AddFilterV4Response) xxx_FromOp(ctx context.Context, op *xxx_AddFilterV4Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *AddFilterV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *AddFilterV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddFilterV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_DeleteFilterV4Operation structure represents the R_DhcpDeleteFilterV4 operation
type xxx_DeleteFilterV4Operation struct {
	ServerIPAddress  string             `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	DeleteFilterInfo *dhcpm.AddrPattern `idl:"name:DeleteFilterInfo" json:"delete_filter_info"`
	Return           uint32             `idl:"name:Return" json:"return"`
}

func (o *xxx_DeleteFilterV4Operation) OpNum() int { return 83 }

func (o *xxx_DeleteFilterV4Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpDeleteFilterV4" }

func (o *xxx_DeleteFilterV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteFilterV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// DeleteFilterInfo {in} (1:{pointer=ref}*(1))(2:{alias=DHCP_ADDR_PATTERN}(struct))
	{
		if o.DeleteFilterInfo != nil {
			if err := o.DeleteFilterInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.AddrPattern{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_DeleteFilterV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// DeleteFilterInfo {in} (1:{pointer=ref}*(1))(2:{alias=DHCP_ADDR_PATTERN}(struct))
	{
		if o.DeleteFilterInfo == nil {
			o.DeleteFilterInfo = &dhcpm.AddrPattern{}
		}
		if err := o.DeleteFilterInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteFilterV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteFilterV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteFilterV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// DeleteFilterV4Request structure represents the R_DhcpDeleteFilterV4 operation request
type DeleteFilterV4Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// DeleteFilterInfo: This is a pointer to a DHCP_ADDR_PATTERN (section 2.2.1.2.89) that
	// contains link-layer address/pattern information to be deleted from the database,
	// from the allow or deny lists. It can also contain hardware type information to be
	// deleted from the database, from the allow list.
	DeleteFilterInfo *dhcpm.AddrPattern `idl:"name:DeleteFilterInfo" json:"delete_filter_info"`
}

func (o *DeleteFilterV4Request) xxx_ToOp(ctx context.Context, op *xxx_DeleteFilterV4Operation) *xxx_DeleteFilterV4Operation {
	if op == nil {
		op = &xxx_DeleteFilterV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.DeleteFilterInfo = o.DeleteFilterInfo
	return op
}

func (o *DeleteFilterV4Request) xxx_FromOp(ctx context.Context, op *xxx_DeleteFilterV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.DeleteFilterInfo = op.DeleteFilterInfo
}
func (o *DeleteFilterV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *DeleteFilterV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteFilterV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// DeleteFilterV4Response structure represents the R_DhcpDeleteFilterV4 operation response
type DeleteFilterV4Response struct {
	// Return: The R_DhcpDeleteFilterV4 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *DeleteFilterV4Response) xxx_ToOp(ctx context.Context, op *xxx_DeleteFilterV4Operation) *xxx_DeleteFilterV4Operation {
	if op == nil {
		op = &xxx_DeleteFilterV4Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *DeleteFilterV4Response) xxx_FromOp(ctx context.Context, op *xxx_DeleteFilterV4Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *DeleteFilterV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *DeleteFilterV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteFilterV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetFilterV4Operation structure represents the R_DhcpSetFilterV4 operation
type xxx_SetFilterV4Operation struct {
	ServerIPAddress  string                  `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	GlobalFilterInfo *dhcpm.FilterGlobalInfo `idl:"name:GlobalFilterInfo" json:"global_filter_info"`
	Return           uint32                  `idl:"name:Return" json:"return"`
}

func (o *xxx_SetFilterV4Operation) OpNum() int { return 84 }

func (o *xxx_SetFilterV4Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpSetFilterV4" }

func (o *xxx_SetFilterV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFilterV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// GlobalFilterInfo {in} (1:{pointer=ref}*(1))(2:{alias=DHCP_FILTER_GLOBAL_INFO}(struct))
	{
		if o.GlobalFilterInfo != nil {
			if err := o.GlobalFilterInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.FilterGlobalInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_SetFilterV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// GlobalFilterInfo {in} (1:{pointer=ref}*(1))(2:{alias=DHCP_FILTER_GLOBAL_INFO}(struct))
	{
		if o.GlobalFilterInfo == nil {
			o.GlobalFilterInfo = &dhcpm.FilterGlobalInfo{}
		}
		if err := o.GlobalFilterInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFilterV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFilterV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFilterV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetFilterV4Request structure represents the R_DhcpSetFilterV4 operation request
type SetFilterV4Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// GlobalFilterInfo: This is a pointer to a DHCP_FILTER_GLOBAL_INFO (section 2.2.1.2.91)
	// that contains information to enable or disable allow and deny lists.
	GlobalFilterInfo *dhcpm.FilterGlobalInfo `idl:"name:GlobalFilterInfo" json:"global_filter_info"`
}

func (o *SetFilterV4Request) xxx_ToOp(ctx context.Context, op *xxx_SetFilterV4Operation) *xxx_SetFilterV4Operation {
	if op == nil {
		op = &xxx_SetFilterV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.GlobalFilterInfo = o.GlobalFilterInfo
	return op
}

func (o *SetFilterV4Request) xxx_FromOp(ctx context.Context, op *xxx_SetFilterV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.GlobalFilterInfo = op.GlobalFilterInfo
}
func (o *SetFilterV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetFilterV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetFilterV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetFilterV4Response structure represents the R_DhcpSetFilterV4 operation response
type SetFilterV4Response struct {
	// Return: The R_DhcpSetFilterV4 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetFilterV4Response) xxx_ToOp(ctx context.Context, op *xxx_SetFilterV4Operation) *xxx_SetFilterV4Operation {
	if op == nil {
		op = &xxx_SetFilterV4Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetFilterV4Response) xxx_FromOp(ctx context.Context, op *xxx_SetFilterV4Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetFilterV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetFilterV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetFilterV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetFilterV4Operation structure represents the R_DhcpGetFilterV4 operation
type xxx_GetFilterV4Operation struct {
	ServerIPAddress  string                  `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	GlobalFilterInfo *dhcpm.FilterGlobalInfo `idl:"name:GlobalFilterInfo" json:"global_filter_info"`
	Return           uint32                  `idl:"name:Return" json:"return"`
}

func (o *xxx_GetFilterV4Operation) OpNum() int { return 85 }

func (o *xxx_GetFilterV4Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpGetFilterV4" }

func (o *xxx_GetFilterV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetFilterV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetFilterV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetFilterV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetFilterV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// GlobalFilterInfo {out} (1:{pointer=ref}*(1))(2:{alias=DHCP_FILTER_GLOBAL_INFO}(struct))
	{
		if o.GlobalFilterInfo != nil {
			if err := o.GlobalFilterInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.FilterGlobalInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetFilterV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// GlobalFilterInfo {out} (1:{pointer=ref}*(1))(2:{alias=DHCP_FILTER_GLOBAL_INFO}(struct))
	{
		if o.GlobalFilterInfo == nil {
			o.GlobalFilterInfo = &dhcpm.FilterGlobalInfo{}
		}
		if err := o.GlobalFilterInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetFilterV4Request structure represents the R_DhcpGetFilterV4 operation request
type GetFilterV4Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
}

func (o *GetFilterV4Request) xxx_ToOp(ctx context.Context, op *xxx_GetFilterV4Operation) *xxx_GetFilterV4Operation {
	if op == nil {
		op = &xxx_GetFilterV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	return op
}

func (o *GetFilterV4Request) xxx_FromOp(ctx context.Context, op *xxx_GetFilterV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
}
func (o *GetFilterV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetFilterV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetFilterV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetFilterV4Response structure represents the R_DhcpGetFilterV4 operation response
type GetFilterV4Response struct {
	// GlobalFilterInfo: This is a pointer of type LPDHCP_FILTER_GLOBAL_INFO that contains
	// information to enable or disable allow and deny lists. The caller must allocate memory
	// for this parameter that is equal to the size of DHCP_FILTER_GLOBAL_INFO (section
	// 2.2.1.2.91).
	GlobalFilterInfo *dhcpm.FilterGlobalInfo `idl:"name:GlobalFilterInfo" json:"global_filter_info"`
	// Return: The R_DhcpGetFilterV4 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetFilterV4Response) xxx_ToOp(ctx context.Context, op *xxx_GetFilterV4Operation) *xxx_GetFilterV4Operation {
	if op == nil {
		op = &xxx_GetFilterV4Operation{}
	}
	if o == nil {
		return op
	}
	op.GlobalFilterInfo = o.GlobalFilterInfo
	op.Return = o.Return
	return op
}

func (o *GetFilterV4Response) xxx_FromOp(ctx context.Context, op *xxx_GetFilterV4Operation) {
	if o == nil {
		return
	}
	o.GlobalFilterInfo = op.GlobalFilterInfo
	o.Return = op.Return
}
func (o *GetFilterV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetFilterV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetFilterV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumFilterV4Operation structure represents the R_DhcpEnumFilterV4 operation
type xxx_EnumFilterV4Operation struct {
	ServerIPAddress  string                `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Resume           *dhcpm.AddrPattern    `idl:"name:ResumeHandle" json:"resume"`
	PreferredMaximum uint32                `idl:"name:PreferredMaximum" json:"preferred_maximum"`
	ListType         dhcpm.FilterListType  `idl:"name:ListType" json:"list_type"`
	EnumFilterInfo   *dhcpm.FilterEnumInfo `idl:"name:EnumFilterInfo" json:"enum_filter_info"`
	ElementsRead     uint32                `idl:"name:ElementsRead" json:"elements_read"`
	ElementsTotal    uint32                `idl:"name:ElementsTotal" json:"elements_total"`
	Return           uint32                `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumFilterV4Operation) OpNum() int { return 86 }

func (o *xxx_EnumFilterV4Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpEnumFilterV4" }

func (o *xxx_EnumFilterV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFilterV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{alias=LPDHCP_ADDR_PATTERN}*(1))(2:{alias=DHCP_ADDR_PATTERN}(struct))
	{
		if o.Resume != nil {
			if err := o.Resume.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.AddrPattern{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PreferredMaximum); err != nil {
			return err
		}
	}
	// ListType {in} (1:{alias=DHCP_FILTER_LIST_TYPE}(enum))
	{
		if err := w.WriteEnum(uint16(o.ListType)); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFilterV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{alias=LPDHCP_ADDR_PATTERN,pointer=ref}*(1))(2:{alias=DHCP_ADDR_PATTERN}(struct))
	{
		if o.Resume == nil {
			o.Resume = &dhcpm.AddrPattern{}
		}
		if err := o.Resume.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PreferredMaximum); err != nil {
			return err
		}
	}
	// ListType {in} (1:{alias=DHCP_FILTER_LIST_TYPE}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.ListType)); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFilterV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFilterV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ResumeHandle {in, out} (1:{alias=LPDHCP_ADDR_PATTERN}*(1))(2:{alias=DHCP_ADDR_PATTERN}(struct))
	{
		if o.Resume != nil {
			if err := o.Resume.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.AddrPattern{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// EnumFilterInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_FILTER_ENUM_INFO}*(1))(3:{alias=DHCP_FILTER_ENUM_INFO}(struct))
	{
		if o.EnumFilterInfo != nil {
			_ptr_EnumFilterInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.EnumFilterInfo != nil {
					if err := o.EnumFilterInfo.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.FilterEnumInfo{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.EnumFilterInfo, _ptr_EnumFilterInfo); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ElementsRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ElementsRead); err != nil {
			return err
		}
	}
	// ElementsTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ElementsTotal); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFilterV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ResumeHandle {in, out} (1:{alias=LPDHCP_ADDR_PATTERN,pointer=ref}*(1))(2:{alias=DHCP_ADDR_PATTERN}(struct))
	{
		if o.Resume == nil {
			o.Resume = &dhcpm.AddrPattern{}
		}
		if err := o.Resume.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// EnumFilterInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_FILTER_ENUM_INFO,pointer=ref}*(1))(3:{alias=DHCP_FILTER_ENUM_INFO}(struct))
	{
		_ptr_EnumFilterInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.EnumFilterInfo == nil {
				o.EnumFilterInfo = &dhcpm.FilterEnumInfo{}
			}
			if err := o.EnumFilterInfo.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_EnumFilterInfo := func(ptr interface{}) { o.EnumFilterInfo = *ptr.(**dhcpm.FilterEnumInfo) }
		if err := w.ReadPointer(&o.EnumFilterInfo, _s_EnumFilterInfo, _ptr_EnumFilterInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ElementsRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ElementsRead); err != nil {
			return err
		}
	}
	// ElementsTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ElementsTotal); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumFilterV4Request structure represents the R_DhcpEnumFilterV4 operation request
type EnumFilterV4Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// ResumeHandle: This is a pointer of type DHCP_ADDR_PATTERN (section 2.2.1.2.89) which
	// identifies the enumeration operation. Initially, this value MUST be set to zero,
	// with a successful call returning the address/pattern value used for subsequent enumeration
	// requests.
	Resume *dhcpm.AddrPattern `idl:"name:ResumeHandle" json:"resume"`
	// PreferredMaximum: This is of type DWORD which specifies the preferred maximum number
	// of bytes to return. If the number of remaining unenumerated filter information size
	// is less than this value, then all the filters configured on the specific list on
	// the DHCPv4 server are returned. The maximum value for this is 64 kilobytes and the
	// minimum value is 1 kilobyte. To retrieve all filter records, 0xFFFFFFFF is specified.
	PreferredMaximum uint32 `idl:"name:PreferredMaximum" json:"preferred_maximum"`
	// ListType: This is of type DHCP_FILTER_LIST_TYPE (section 2.2.1.1.17), which specifies
	// the list to be enumerated.
	ListType dhcpm.FilterListType `idl:"name:ListType" json:"list_type"`
}

func (o *EnumFilterV4Request) xxx_ToOp(ctx context.Context, op *xxx_EnumFilterV4Operation) *xxx_EnumFilterV4Operation {
	if op == nil {
		op = &xxx_EnumFilterV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Resume = o.Resume
	op.PreferredMaximum = o.PreferredMaximum
	op.ListType = o.ListType
	return op
}

func (o *EnumFilterV4Request) xxx_FromOp(ctx context.Context, op *xxx_EnumFilterV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Resume = op.Resume
	o.PreferredMaximum = op.PreferredMaximum
	o.ListType = op.ListType
}
func (o *EnumFilterV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumFilterV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumFilterV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumFilterV4Response structure represents the R_DhcpEnumFilterV4 operation response
type EnumFilterV4Response struct {
	// ResumeHandle: This is a pointer of type DHCP_ADDR_PATTERN (section 2.2.1.2.89) which
	// identifies the enumeration operation. Initially, this value MUST be set to zero,
	// with a successful call returning the address/pattern value used for subsequent enumeration
	// requests.
	Resume *dhcpm.AddrPattern `idl:"name:ResumeHandle" json:"resume"`
	// EnumFilterInfo: This is a pointer of type LPDHCP_FILTER_ENUM_INFO that points to
	// the location in which the link-layer filter info configured on the DHCPv4 server
	// is returned.
	EnumFilterInfo *dhcpm.FilterEnumInfo `idl:"name:EnumFilterInfo" json:"enum_filter_info"`
	// ElementsRead: This is a pointer to a DWORD value that specifies the number of link-layer
	// filter entries returned in EnumFilterInfo. The caller must allocate memory for this
	// parameter that is equal to the size of data type DWORD.
	ElementsRead uint32 `idl:"name:ElementsRead" json:"elements_read"`
	// ElementsTotal: This is a pointer to a DWORD value that specifies the number of link-layer
	// filter entries defined on the DHCPv4 server that have not yet been enumerated with
	// respect to the resume handle that is returned. The caller must allocate memory for
	// this parameter that is equal to the size of data type DWORD.
	ElementsTotal uint32 `idl:"name:ElementsTotal" json:"elements_total"`
	// Return: The R_DhcpEnumFilterV4 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumFilterV4Response) xxx_ToOp(ctx context.Context, op *xxx_EnumFilterV4Operation) *xxx_EnumFilterV4Operation {
	if op == nil {
		op = &xxx_EnumFilterV4Operation{}
	}
	if o == nil {
		return op
	}
	op.Resume = o.Resume
	op.EnumFilterInfo = o.EnumFilterInfo
	op.ElementsRead = o.ElementsRead
	op.ElementsTotal = o.ElementsTotal
	op.Return = o.Return
	return op
}

func (o *EnumFilterV4Response) xxx_FromOp(ctx context.Context, op *xxx_EnumFilterV4Operation) {
	if o == nil {
		return
	}
	o.Resume = op.Resume
	o.EnumFilterInfo = op.EnumFilterInfo
	o.ElementsRead = op.ElementsRead
	o.ElementsTotal = op.ElementsTotal
	o.Return = op.Return
}
func (o *EnumFilterV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumFilterV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumFilterV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetDNSRegCredentialsV5Operation structure represents the R_DhcpSetDnsRegCredentialsV5 operation
type xxx_SetDNSRegCredentialsV5Operation struct {
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	UserName        string `idl:"name:Uname;string;pointer:unique" json:"user_name"`
	Domain          string `idl:"name:Domain;string;pointer:unique" json:"domain"`
	Password        string `idl:"name:Passwd;string;pointer:unique" json:"password"`
	Return          uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_SetDNSRegCredentialsV5Operation) OpNum() int { return 87 }

func (o *xxx_SetDNSRegCredentialsV5Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpSetDnsRegCredentialsV5"
}

func (o *xxx_SetDNSRegCredentialsV5Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetDNSRegCredentialsV5Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Uname {in} (1:{string, pointer=unique, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.UserName != "" {
			_ptr_Uname := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.UserName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.UserName, _ptr_Uname); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Domain {in} (1:{string, pointer=unique, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.Domain != "" {
			_ptr_Domain := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.Domain); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.Domain, _ptr_Domain); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Passwd {in} (1:{string, pointer=unique, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.Password != "" {
			_ptr_Passwd := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.Password); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.Password, _ptr_Passwd); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetDNSRegCredentialsV5Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Uname {in} (1:{string, pointer=unique, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_Uname := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.UserName); err != nil {
				return err
			}
			return nil
		})
		_s_Uname := func(ptr interface{}) { o.UserName = *ptr.(*string) }
		if err := w.ReadPointer(&o.UserName, _s_Uname, _ptr_Uname); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Domain {in} (1:{string, pointer=unique, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_Domain := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.Domain); err != nil {
				return err
			}
			return nil
		})
		_s_Domain := func(ptr interface{}) { o.Domain = *ptr.(*string) }
		if err := w.ReadPointer(&o.Domain, _s_Domain, _ptr_Domain); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Passwd {in} (1:{string, pointer=unique, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_Passwd := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.Password); err != nil {
				return err
			}
			return nil
		})
		_s_Passwd := func(ptr interface{}) { o.Password = *ptr.(*string) }
		if err := w.ReadPointer(&o.Password, _s_Passwd, _ptr_Passwd); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetDNSRegCredentialsV5Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetDNSRegCredentialsV5Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetDNSRegCredentialsV5Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetDNSRegCredentialsV5Request structure represents the R_DhcpSetDnsRegCredentialsV5 operation request
type SetDNSRegCredentialsV5Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// Uname: A pointer to a null-terminated Unicode string that contains the user name
	// for the DNS credentials.
	UserName string `idl:"name:Uname;string;pointer:unique" json:"user_name"`
	// Domain: A pointer to a null-terminated Unicode string that contains the domain name
	// for the DNS credentials.
	Domain string `idl:"name:Domain;string;pointer:unique" json:"domain"`
	// Passwd: A pointer to a null-terminated Unicode string that contains the password
	// for the DNS user name.
	Password string `idl:"name:Passwd;string;pointer:unique" json:"password"`
}

func (o *SetDNSRegCredentialsV5Request) xxx_ToOp(ctx context.Context, op *xxx_SetDNSRegCredentialsV5Operation) *xxx_SetDNSRegCredentialsV5Operation {
	if op == nil {
		op = &xxx_SetDNSRegCredentialsV5Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.UserName = o.UserName
	op.Domain = o.Domain
	op.Password = o.Password
	return op
}

func (o *SetDNSRegCredentialsV5Request) xxx_FromOp(ctx context.Context, op *xxx_SetDNSRegCredentialsV5Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.UserName = op.UserName
	o.Domain = op.Domain
	o.Password = op.Password
}
func (o *SetDNSRegCredentialsV5Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetDNSRegCredentialsV5Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetDNSRegCredentialsV5Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetDNSRegCredentialsV5Response structure represents the R_DhcpSetDnsRegCredentialsV5 operation response
type SetDNSRegCredentialsV5Response struct {
	// Return: The R_DhcpSetDnsRegCredentialsV5 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetDNSRegCredentialsV5Response) xxx_ToOp(ctx context.Context, op *xxx_SetDNSRegCredentialsV5Operation) *xxx_SetDNSRegCredentialsV5Operation {
	if op == nil {
		op = &xxx_SetDNSRegCredentialsV5Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetDNSRegCredentialsV5Response) xxx_FromOp(ctx context.Context, op *xxx_SetDNSRegCredentialsV5Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetDNSRegCredentialsV5Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetDNSRegCredentialsV5Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetDNSRegCredentialsV5Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumSubnetClientsFilterStatusInfoOperation structure represents the R_DhcpEnumSubnetClientsFilterStatusInfo operation
type xxx_EnumSubnetClientsFilterStatusInfoOperation struct {
	ServerIPAddress  string                             `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	SubnetAddress    uint32                             `idl:"name:SubnetAddress" json:"subnet_address"`
	Resume           uint32                             `idl:"name:ResumeHandle" json:"resume"`
	PreferredMaximum uint32                             `idl:"name:PreferredMaximum" json:"preferred_maximum"`
	ClientInfo       *dhcpm.ClientFilterStatusInfoArray `idl:"name:ClientInfo" json:"client_info"`
	ClientRead       uint32                             `idl:"name:ClientRead" json:"client_read"`
	ClientsTotal     uint32                             `idl:"name:ClientsTotal" json:"clients_total"`
	Return           uint32                             `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumSubnetClientsFilterStatusInfoOperation) OpNum() int { return 88 }

func (o *xxx_EnumSubnetClientsFilterStatusInfoOperation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpEnumSubnetClientsFilterStatusInfo"
}

func (o *xxx_EnumSubnetClientsFilterStatusInfoOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetClientsFilterStatusInfoOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.SubnetAddress); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Resume); err != nil {
			return err
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PreferredMaximum); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetClientsFilterStatusInfoOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.SubnetAddress); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Resume); err != nil {
			return err
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PreferredMaximum); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetClientsFilterStatusInfoOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetClientsFilterStatusInfoOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Resume); err != nil {
			return err
		}
	}
	// ClientInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_CLIENT_FILTER_STATUS_INFO_ARRAY}*(1))(3:{alias=DHCP_CLIENT_FILTER_STATUS_INFO_ARRAY}(struct))
	{
		if o.ClientInfo != nil {
			_ptr_ClientInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.ClientInfo != nil {
					if err := o.ClientInfo.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.ClientFilterStatusInfoArray{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ClientInfo, _ptr_ClientInfo); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ClientRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ClientRead); err != nil {
			return err
		}
	}
	// ClientsTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ClientsTotal); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetClientsFilterStatusInfoOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Resume); err != nil {
			return err
		}
	}
	// ClientInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_CLIENT_FILTER_STATUS_INFO_ARRAY,pointer=ref}*(1))(3:{alias=DHCP_CLIENT_FILTER_STATUS_INFO_ARRAY}(struct))
	{
		_ptr_ClientInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.ClientInfo == nil {
				o.ClientInfo = &dhcpm.ClientFilterStatusInfoArray{}
			}
			if err := o.ClientInfo.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ClientInfo := func(ptr interface{}) { o.ClientInfo = *ptr.(**dhcpm.ClientFilterStatusInfoArray) }
		if err := w.ReadPointer(&o.ClientInfo, _s_ClientInfo, _ptr_ClientInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ClientRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ClientRead); err != nil {
			return err
		}
	}
	// ClientsTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ClientsTotal); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumSubnetClientsFilterStatusInfoRequest structure represents the R_DhcpEnumSubnetClientsFilterStatusInfo operation request
type EnumSubnetClientsFilterStatusInfoRequest struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// SubnetAddress: This is of type DHCP_IP_ADDRESS (section 2.2.1.2.1) which contains
	// the IPv4 subnet ID from which DHCPv4 clients are enumerated. If this parameter is
	// set to 0, the DHCPv4 clients from all the IPv4 subnets are returned.
	SubnetAddress uint32 `idl:"name:SubnetAddress" json:"subnet_address"`
	// ResumeHandle: This is a pointer of type DHCP_RESUME_HANDLE (section 2.2.1.2.6) which
	// identifies the enumeration operation. Initially, this value MUST be set to zero,
	// with a successful call returning the handle value used for subsequent enumeration
	// requests. This field contains the last IPv4 address retrieved.
	Resume uint32 `idl:"name:ResumeHandle" json:"resume"`
	// PreferredMaximum: This is of type DWORD which specifies the preferred maximum number
	// of bytes to return. The minimum value is 1024 bytes (1 kilobyte), and the maximum
	// value is 65536 bytes (64 kilobytes). If the input value is greater or less than this
	// range, it MUST be set to the maximum or minimum value, respectively. To retrieve
	// all DHCPv4 clients serviced by a specific IPv4 subnet, 0xFFFFFFFF is specified.
	PreferredMaximum uint32 `idl:"name:PreferredMaximum" json:"preferred_maximum"`
}

func (o *EnumSubnetClientsFilterStatusInfoRequest) xxx_ToOp(ctx context.Context, op *xxx_EnumSubnetClientsFilterStatusInfoOperation) *xxx_EnumSubnetClientsFilterStatusInfoOperation {
	if op == nil {
		op = &xxx_EnumSubnetClientsFilterStatusInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.SubnetAddress = o.SubnetAddress
	op.Resume = o.Resume
	op.PreferredMaximum = o.PreferredMaximum
	return op
}

func (o *EnumSubnetClientsFilterStatusInfoRequest) xxx_FromOp(ctx context.Context, op *xxx_EnumSubnetClientsFilterStatusInfoOperation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.SubnetAddress = op.SubnetAddress
	o.Resume = op.Resume
	o.PreferredMaximum = op.PreferredMaximum
}
func (o *EnumSubnetClientsFilterStatusInfoRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumSubnetClientsFilterStatusInfoRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumSubnetClientsFilterStatusInfoOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumSubnetClientsFilterStatusInfoResponse structure represents the R_DhcpEnumSubnetClientsFilterStatusInfo operation response
type EnumSubnetClientsFilterStatusInfoResponse struct {
	// ResumeHandle: This is a pointer of type DHCP_RESUME_HANDLE (section 2.2.1.2.6) which
	// identifies the enumeration operation. Initially, this value MUST be set to zero,
	// with a successful call returning the handle value used for subsequent enumeration
	// requests. This field contains the last IPv4 address retrieved.
	Resume uint32 `idl:"name:ResumeHandle" json:"resume"`
	// ClientInfo: This is a pointer of type LPDHCP_CLIENT_FILTER_STATUS_INFO_ARRAY that
	// points to the location which contains the DHCPv4 client lease record array.
	ClientInfo *dhcpm.ClientFilterStatusInfoArray `idl:"name:ClientInfo" json:"client_info"`
	// ClientRead: This is a pointer to a DWORD that specifies the number of DHCPv4 client
	// lease records read in ClientInfo. The caller must allocate memory for this parameter
	// that is equal to the size of data type DWORD.
	ClientRead uint32 `idl:"name:ClientRead" json:"client_read"`
	// ClientsTotal: This is a pointer to a DWORD that specifies the number of DHCPv4 client
	// lease records remaining from the current position. The caller must allocate memory
	// for this parameter that is equal to the size of data type DWORD. For example, if
	// there are 100 DHCPv4 lease record clients for an IPv4 subnet, and if 10 DHCPv4 lease
	// records are enumerated per call, then for the first time this would have a value
	// of 90.<72>
	ClientsTotal uint32 `idl:"name:ClientsTotal" json:"clients_total"`
	// Return: The R_DhcpEnumSubnetClientsFilterStatusInfo return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumSubnetClientsFilterStatusInfoResponse) xxx_ToOp(ctx context.Context, op *xxx_EnumSubnetClientsFilterStatusInfoOperation) *xxx_EnumSubnetClientsFilterStatusInfoOperation {
	if op == nil {
		op = &xxx_EnumSubnetClientsFilterStatusInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.Resume = o.Resume
	op.ClientInfo = o.ClientInfo
	op.ClientRead = o.ClientRead
	op.ClientsTotal = o.ClientsTotal
	op.Return = o.Return
	return op
}

func (o *EnumSubnetClientsFilterStatusInfoResponse) xxx_FromOp(ctx context.Context, op *xxx_EnumSubnetClientsFilterStatusInfoOperation) {
	if o == nil {
		return
	}
	o.Resume = op.Resume
	o.ClientInfo = op.ClientInfo
	o.ClientRead = op.ClientRead
	o.ClientsTotal = op.ClientsTotal
	o.Return = op.Return
}
func (o *EnumSubnetClientsFilterStatusInfoResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumSubnetClientsFilterStatusInfoResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumSubnetClientsFilterStatusInfoOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_FailoverCreateRelationshipV4Operation structure represents the R_DhcpV4FailoverCreateRelationship operation
type xxx_FailoverCreateRelationshipV4Operation struct {
	ServerIPAddress string                      `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Relationship    *dhcpm.FailoverRelationship `idl:"name:pRelationship" json:"relationship"`
	Return          uint32                      `idl:"name:Return" json:"return"`
}

func (o *xxx_FailoverCreateRelationshipV4Operation) OpNum() int { return 89 }

func (o *xxx_FailoverCreateRelationshipV4Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpV4FailoverCreateRelationship"
}

func (o *xxx_FailoverCreateRelationshipV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverCreateRelationshipV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// pRelationship {in} (1:{alias=LPDHCP_FAILOVER_RELATIONSHIP}*(1))(2:{alias=DHCP_FAILOVER_RELATIONSHIP}(struct))
	{
		if o.Relationship != nil {
			if err := o.Relationship.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.FailoverRelationship{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverCreateRelationshipV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// pRelationship {in} (1:{alias=LPDHCP_FAILOVER_RELATIONSHIP,pointer=ref}*(1))(2:{alias=DHCP_FAILOVER_RELATIONSHIP}(struct))
	{
		if o.Relationship == nil {
			o.Relationship = &dhcpm.FailoverRelationship{}
		}
		if err := o.Relationship.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverCreateRelationshipV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverCreateRelationshipV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverCreateRelationshipV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// FailoverCreateRelationshipV4Request structure represents the R_DhcpV4FailoverCreateRelationship operation request
type FailoverCreateRelationshipV4Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// pRelationship: This is a pointer to a type DHCP_FAILOVER_RELATIONSHIP (section 2.2.1.2.98))
	// that contains information about the failover relationship to be created on the DHCPv4
	// server.
	Relationship *dhcpm.FailoverRelationship `idl:"name:pRelationship" json:"relationship"`
}

func (o *FailoverCreateRelationshipV4Request) xxx_ToOp(ctx context.Context, op *xxx_FailoverCreateRelationshipV4Operation) *xxx_FailoverCreateRelationshipV4Operation {
	if op == nil {
		op = &xxx_FailoverCreateRelationshipV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Relationship = o.Relationship
	return op
}

func (o *FailoverCreateRelationshipV4Request) xxx_FromOp(ctx context.Context, op *xxx_FailoverCreateRelationshipV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Relationship = op.Relationship
}
func (o *FailoverCreateRelationshipV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *FailoverCreateRelationshipV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_FailoverCreateRelationshipV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// FailoverCreateRelationshipV4Response structure represents the R_DhcpV4FailoverCreateRelationship operation response
type FailoverCreateRelationshipV4Response struct {
	// Return: The R_DhcpV4FailoverCreateRelationship return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *FailoverCreateRelationshipV4Response) xxx_ToOp(ctx context.Context, op *xxx_FailoverCreateRelationshipV4Operation) *xxx_FailoverCreateRelationshipV4Operation {
	if op == nil {
		op = &xxx_FailoverCreateRelationshipV4Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *FailoverCreateRelationshipV4Response) xxx_FromOp(ctx context.Context, op *xxx_FailoverCreateRelationshipV4Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *FailoverCreateRelationshipV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *FailoverCreateRelationshipV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_FailoverCreateRelationshipV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_FailoverSetRelationshipV4Operation structure represents the R_DhcpV4FailoverSetRelationship operation
type xxx_FailoverSetRelationshipV4Operation struct {
	ServerIPAddress string                      `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Flags           uint32                      `idl:"name:Flags" json:"flags"`
	Relationship    *dhcpm.FailoverRelationship `idl:"name:pRelationship" json:"relationship"`
	Return          uint32                      `idl:"name:Return" json:"return"`
}

func (o *xxx_FailoverSetRelationshipV4Operation) OpNum() int { return 90 }

func (o *xxx_FailoverSetRelationshipV4Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpV4FailoverSetRelationship"
}

func (o *xxx_FailoverSetRelationshipV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverSetRelationshipV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	// pRelationship {in} (1:{alias=LPDHCP_FAILOVER_RELATIONSHIP}*(1))(2:{alias=DHCP_FAILOVER_RELATIONSHIP}(struct))
	{
		if o.Relationship != nil {
			if err := o.Relationship.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.FailoverRelationship{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverSetRelationshipV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	// pRelationship {in} (1:{alias=LPDHCP_FAILOVER_RELATIONSHIP,pointer=ref}*(1))(2:{alias=DHCP_FAILOVER_RELATIONSHIP}(struct))
	{
		if o.Relationship == nil {
			o.Relationship = &dhcpm.FailoverRelationship{}
		}
		if err := o.Relationship.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverSetRelationshipV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverSetRelationshipV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverSetRelationshipV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// FailoverSetRelationshipV4Request structure represents the R_DhcpV4FailoverSetRelationship operation request
type FailoverSetRelationshipV4Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// Flags: A DWORD type that contains the bitmask of the members in the pRelationship
	// parameter structure to be updated. The bit mapping for the various values for the
	// flags parameter is listed in the following table.
	//
	//	+------------------------+----------------------------------------------------------------------------------+
	//	|                        |                                                                                  |
	//	|         VALUE          |                                     MEANING                                      |
	//	|                        |                                                                                  |
	//	+------------------------+----------------------------------------------------------------------------------+
	//	+------------------------+----------------------------------------------------------------------------------+
	//	| MCLT 0x00000001        | Update the mclt member of DHCP_FAILOVER_RELATIONSHIP structure (section          |
	//	|                        | 2.2.1.2.98) to the value specified in the mclt member in pRelationship           |
	//	|                        | parameter.                                                                       |
	//	+------------------------+----------------------------------------------------------------------------------+
	//	| SAFEPERIOD 0x00000002  | Update the safePeriod member of DHCP_FAILOVER_RELATIONSHIP structure (section    |
	//	|                        | 2.2.1.2.98) to the value specified in the safePeriod member in pRelationship     |
	//	|                        | parameter.                                                                       |
	//	+------------------------+----------------------------------------------------------------------------------+
	//	| CHANGESTATE 0x00000004 | Update the state member of DHCP_FAILOVER_RELATIONSHIP structure (section         |
	//	|                        | 2.2.1.2.98) to the value specified in the state member in pRelationship          |
	//	|                        | parameter.                                                                       |
	//	+------------------------+----------------------------------------------------------------------------------+
	//	| PERCENTAGE 0x00000008  | Update the percentage member of DHCP_FAILOVER_RELATIONSHIP structure (section    |
	//	|                        | 2.2.1.2.98) to the value specified in the percentage member in pRelationship     |
	//	|                        | parameter.                                                                       |
	//	+------------------------+----------------------------------------------------------------------------------+
	//	| MODE 0x00000010        | Update the mode member of DHCP_FAILOVER_RELATIONSHIP structure (section          |
	//	|                        | 2.2.1.2.98) to the value specified in the mode member in pRelationship           |
	//	|                        | parameter.                                                                       |
	//	+------------------------+----------------------------------------------------------------------------------+
	//	| PREVSTATE 0x00000020   | Update the prevState member of DHCP_FAILOVER_RELATIONSHIP structure (section     |
	//	|                        | 2.2.1.2.98) to the value specified in the prevState member in pRelationship      |
	//	|                        | parameter.                                                                       |
	//	+------------------------+----------------------------------------------------------------------------------+
	Flags uint32 `idl:"name:Flags" json:"flags"`
	// pRelationship: This is a pointer to a type DHCP_FAILOVER_RELATIONSHIP structure (section
	// 2.2.1.2.98) that contains information about the failover relationship to be modified
	// on the DHCPv4 server.
	Relationship *dhcpm.FailoverRelationship `idl:"name:pRelationship" json:"relationship"`
}

func (o *FailoverSetRelationshipV4Request) xxx_ToOp(ctx context.Context, op *xxx_FailoverSetRelationshipV4Operation) *xxx_FailoverSetRelationshipV4Operation {
	if op == nil {
		op = &xxx_FailoverSetRelationshipV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Flags = o.Flags
	op.Relationship = o.Relationship
	return op
}

func (o *FailoverSetRelationshipV4Request) xxx_FromOp(ctx context.Context, op *xxx_FailoverSetRelationshipV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Flags = op.Flags
	o.Relationship = op.Relationship
}
func (o *FailoverSetRelationshipV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *FailoverSetRelationshipV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_FailoverSetRelationshipV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// FailoverSetRelationshipV4Response structure represents the R_DhcpV4FailoverSetRelationship operation response
type FailoverSetRelationshipV4Response struct {
	// Return: The R_DhcpV4FailoverSetRelationship return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *FailoverSetRelationshipV4Response) xxx_ToOp(ctx context.Context, op *xxx_FailoverSetRelationshipV4Operation) *xxx_FailoverSetRelationshipV4Operation {
	if op == nil {
		op = &xxx_FailoverSetRelationshipV4Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *FailoverSetRelationshipV4Response) xxx_FromOp(ctx context.Context, op *xxx_FailoverSetRelationshipV4Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *FailoverSetRelationshipV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *FailoverSetRelationshipV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_FailoverSetRelationshipV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_FailoverDeleteRelationshipV4Operation structure represents the R_DhcpV4FailoverDeleteRelationship operation
type xxx_FailoverDeleteRelationshipV4Operation struct {
	ServerIPAddress  string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	RelationshipName string `idl:"name:pRelationshipName;string;pointer:unique" json:"relationship_name"`
	Return           uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_FailoverDeleteRelationshipV4Operation) OpNum() int { return 91 }

func (o *xxx_FailoverDeleteRelationshipV4Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpV4FailoverDeleteRelationship"
}

func (o *xxx_FailoverDeleteRelationshipV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverDeleteRelationshipV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// pRelationshipName {in} (1:{string, pointer=unique, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.RelationshipName != "" {
			_ptr_pRelationshipName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.RelationshipName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.RelationshipName, _ptr_pRelationshipName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverDeleteRelationshipV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// pRelationshipName {in} (1:{string, pointer=unique, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_pRelationshipName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.RelationshipName); err != nil {
				return err
			}
			return nil
		})
		_s_pRelationshipName := func(ptr interface{}) { o.RelationshipName = *ptr.(*string) }
		if err := w.ReadPointer(&o.RelationshipName, _s_pRelationshipName, _ptr_pRelationshipName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverDeleteRelationshipV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverDeleteRelationshipV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverDeleteRelationshipV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// FailoverDeleteRelationshipV4Request structure represents the R_DhcpV4FailoverDeleteRelationship operation request
type FailoverDeleteRelationshipV4Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// pRelationshipName: A pointer to a null-terminated Unicode string that contains the
	// name of the failover relationship to be deleted.
	RelationshipName string `idl:"name:pRelationshipName;string;pointer:unique" json:"relationship_name"`
}

func (o *FailoverDeleteRelationshipV4Request) xxx_ToOp(ctx context.Context, op *xxx_FailoverDeleteRelationshipV4Operation) *xxx_FailoverDeleteRelationshipV4Operation {
	if op == nil {
		op = &xxx_FailoverDeleteRelationshipV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.RelationshipName = o.RelationshipName
	return op
}

func (o *FailoverDeleteRelationshipV4Request) xxx_FromOp(ctx context.Context, op *xxx_FailoverDeleteRelationshipV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.RelationshipName = op.RelationshipName
}
func (o *FailoverDeleteRelationshipV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *FailoverDeleteRelationshipV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_FailoverDeleteRelationshipV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// FailoverDeleteRelationshipV4Response structure represents the R_DhcpV4FailoverDeleteRelationship operation response
type FailoverDeleteRelationshipV4Response struct {
	// Return: The R_DhcpV4FailoverDeleteRelationship return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *FailoverDeleteRelationshipV4Response) xxx_ToOp(ctx context.Context, op *xxx_FailoverDeleteRelationshipV4Operation) *xxx_FailoverDeleteRelationshipV4Operation {
	if op == nil {
		op = &xxx_FailoverDeleteRelationshipV4Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *FailoverDeleteRelationshipV4Response) xxx_FromOp(ctx context.Context, op *xxx_FailoverDeleteRelationshipV4Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *FailoverDeleteRelationshipV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *FailoverDeleteRelationshipV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_FailoverDeleteRelationshipV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_FailoverGetRelationshipV4Operation structure represents the R_DhcpV4FailoverGetRelationship operation
type xxx_FailoverGetRelationshipV4Operation struct {
	ServerIPAddress  string                      `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	RelationshipName string                      `idl:"name:pRelationshipName;string;pointer:unique" json:"relationship_name"`
	Relationship     *dhcpm.FailoverRelationship `idl:"name:pRelationship" json:"relationship"`
	Return           uint32                      `idl:"name:Return" json:"return"`
}

func (o *xxx_FailoverGetRelationshipV4Operation) OpNum() int { return 92 }

func (o *xxx_FailoverGetRelationshipV4Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpV4FailoverGetRelationship"
}

func (o *xxx_FailoverGetRelationshipV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverGetRelationshipV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// pRelationshipName {in} (1:{string, pointer=unique, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.RelationshipName != "" {
			_ptr_pRelationshipName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.RelationshipName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.RelationshipName, _ptr_pRelationshipName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverGetRelationshipV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// pRelationshipName {in} (1:{string, pointer=unique, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_pRelationshipName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.RelationshipName); err != nil {
				return err
			}
			return nil
		})
		_s_pRelationshipName := func(ptr interface{}) { o.RelationshipName = *ptr.(*string) }
		if err := w.ReadPointer(&o.RelationshipName, _s_pRelationshipName, _ptr_pRelationshipName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverGetRelationshipV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverGetRelationshipV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pRelationship {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_FAILOVER_RELATIONSHIP}*(1))(3:{alias=DHCP_FAILOVER_RELATIONSHIP}(struct))
	{
		if o.Relationship != nil {
			_ptr_pRelationship := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Relationship != nil {
					if err := o.Relationship.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.FailoverRelationship{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Relationship, _ptr_pRelationship); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverGetRelationshipV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pRelationship {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_FAILOVER_RELATIONSHIP,pointer=ref}*(1))(3:{alias=DHCP_FAILOVER_RELATIONSHIP}(struct))
	{
		_ptr_pRelationship := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Relationship == nil {
				o.Relationship = &dhcpm.FailoverRelationship{}
			}
			if err := o.Relationship.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_pRelationship := func(ptr interface{}) { o.Relationship = *ptr.(**dhcpm.FailoverRelationship) }
		if err := w.ReadPointer(&o.Relationship, _s_pRelationship, _ptr_pRelationship); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// FailoverGetRelationshipV4Request structure represents the R_DhcpV4FailoverGetRelationship operation request
type FailoverGetRelationshipV4Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// pRelationshipName: A pointer to a null-terminated Unicode string that contains the
	// name of the failover relationship for which the information is retrieved. There is
	// no limit on the length of this Unicode string.
	RelationshipName string `idl:"name:pRelationshipName;string;pointer:unique" json:"relationship_name"`
}

func (o *FailoverGetRelationshipV4Request) xxx_ToOp(ctx context.Context, op *xxx_FailoverGetRelationshipV4Operation) *xxx_FailoverGetRelationshipV4Operation {
	if op == nil {
		op = &xxx_FailoverGetRelationshipV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.RelationshipName = o.RelationshipName
	return op
}

func (o *FailoverGetRelationshipV4Request) xxx_FromOp(ctx context.Context, op *xxx_FailoverGetRelationshipV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.RelationshipName = op.RelationshipName
}
func (o *FailoverGetRelationshipV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *FailoverGetRelationshipV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_FailoverGetRelationshipV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// FailoverGetRelationshipV4Response structure represents the R_DhcpV4FailoverGetRelationship operation response
type FailoverGetRelationshipV4Response struct {
	// pRelationship: This is a pointer of type LPDHCP_FAILOVER_RELATIONSHIP (section 2.2.1.2.98)
	// in which the information about the failover relationship is retrieved based on the
	// pRelationshipName parameter.
	Relationship *dhcpm.FailoverRelationship `idl:"name:pRelationship" json:"relationship"`
	// Return: The R_DhcpV4FailoverGetRelationship return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *FailoverGetRelationshipV4Response) xxx_ToOp(ctx context.Context, op *xxx_FailoverGetRelationshipV4Operation) *xxx_FailoverGetRelationshipV4Operation {
	if op == nil {
		op = &xxx_FailoverGetRelationshipV4Operation{}
	}
	if o == nil {
		return op
	}
	op.Relationship = o.Relationship
	op.Return = o.Return
	return op
}

func (o *FailoverGetRelationshipV4Response) xxx_FromOp(ctx context.Context, op *xxx_FailoverGetRelationshipV4Operation) {
	if o == nil {
		return
	}
	o.Relationship = op.Relationship
	o.Return = op.Return
}
func (o *FailoverGetRelationshipV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *FailoverGetRelationshipV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_FailoverGetRelationshipV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_FailoverEnumRelationshipV4Operation structure represents the R_DhcpV4FailoverEnumRelationship operation
type xxx_FailoverEnumRelationshipV4Operation struct {
	ServerIPAddress   string                           `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Resume            uint32                           `idl:"name:ResumeHandle" json:"resume"`
	PreferredMaximum  uint32                           `idl:"name:preferredMaximum" json:"preferred_maximum"`
	Relationship      *dhcpm.FailoverRelationshipArray `idl:"name:pRelationship" json:"relationship"`
	RelationshipRead  uint32                           `idl:"name:relationshipRead" json:"relationship_read"`
	RelationshipTotal uint32                           `idl:"name:relationshipTotal" json:"relationship_total"`
	Return            uint32                           `idl:"name:Return" json:"return"`
}

func (o *xxx_FailoverEnumRelationshipV4Operation) OpNum() int { return 93 }

func (o *xxx_FailoverEnumRelationshipV4Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpV4FailoverEnumRelationship"
}

func (o *xxx_FailoverEnumRelationshipV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverEnumRelationshipV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Resume); err != nil {
			return err
		}
	}
	// preferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PreferredMaximum); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverEnumRelationshipV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Resume); err != nil {
			return err
		}
	}
	// preferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PreferredMaximum); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverEnumRelationshipV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverEnumRelationshipV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Resume); err != nil {
			return err
		}
	}
	// pRelationship {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_FAILOVER_RELATIONSHIP_ARRAY}*(1))(3:{alias=DHCP_FAILOVER_RELATIONSHIP_ARRAY}(struct))
	{
		if o.Relationship != nil {
			_ptr_pRelationship := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Relationship != nil {
					if err := o.Relationship.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.FailoverRelationshipArray{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Relationship, _ptr_pRelationship); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// relationshipRead {out} (1:{alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RelationshipRead); err != nil {
			return err
		}
	}
	// relationshipTotal {out} (1:{alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RelationshipTotal); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverEnumRelationshipV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Resume); err != nil {
			return err
		}
	}
	// pRelationship {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_FAILOVER_RELATIONSHIP_ARRAY,pointer=ref}*(1))(3:{alias=DHCP_FAILOVER_RELATIONSHIP_ARRAY}(struct))
	{
		_ptr_pRelationship := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Relationship == nil {
				o.Relationship = &dhcpm.FailoverRelationshipArray{}
			}
			if err := o.Relationship.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_pRelationship := func(ptr interface{}) { o.Relationship = *ptr.(**dhcpm.FailoverRelationshipArray) }
		if err := w.ReadPointer(&o.Relationship, _s_pRelationship, _ptr_pRelationship); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// relationshipRead {out} (1:{alias=LPDWORD,pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RelationshipRead); err != nil {
			return err
		}
	}
	// relationshipTotal {out} (1:{alias=LPDWORD,pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RelationshipTotal); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// FailoverEnumRelationshipV4Request structure represents the R_DhcpV4FailoverEnumRelationship operation request
type FailoverEnumRelationshipV4Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// ResumeHandle: This is a pointer of type DHCP_RESUME_HANDLE (section 2.2.1.2.6) that
	// identifies the enumeration operation. Initially, this value MUST be set to zero,
	// with a successful call returning the handle value used for subsequent enumeration
	// requests.
	Resume uint32 `idl:"name:ResumeHandle" json:"resume"`
	// preferredMaximum: This is of type DWORD, specifying the preferred maximum number
	// of bytes to be returned. If the number of bytes required in memory for the remaining
	// unenumerated failover relationships is less than the PreferredMaximum parameter value,
	// then all the remaining failover relationships for the DHCP server are returned.
	PreferredMaximum uint32 `idl:"name:preferredMaximum" json:"preferred_maximum"`
}

func (o *FailoverEnumRelationshipV4Request) xxx_ToOp(ctx context.Context, op *xxx_FailoverEnumRelationshipV4Operation) *xxx_FailoverEnumRelationshipV4Operation {
	if op == nil {
		op = &xxx_FailoverEnumRelationshipV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Resume = o.Resume
	op.PreferredMaximum = o.PreferredMaximum
	return op
}

func (o *FailoverEnumRelationshipV4Request) xxx_FromOp(ctx context.Context, op *xxx_FailoverEnumRelationshipV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Resume = op.Resume
	o.PreferredMaximum = op.PreferredMaximum
}
func (o *FailoverEnumRelationshipV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *FailoverEnumRelationshipV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_FailoverEnumRelationshipV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// FailoverEnumRelationshipV4Response structure represents the R_DhcpV4FailoverEnumRelationship operation response
type FailoverEnumRelationshipV4Response struct {
	// ResumeHandle: This is a pointer of type DHCP_RESUME_HANDLE (section 2.2.1.2.6) that
	// identifies the enumeration operation. Initially, this value MUST be set to zero,
	// with a successful call returning the handle value used for subsequent enumeration
	// requests.
	Resume uint32 `idl:"name:ResumeHandle" json:"resume"`
	// pRelationship: This is a pointer of type LPDHCP_FAILOVER_RELATIONSHIP_ARRAY (section
	// 2.2.1.2.99) in which information about all the failover relationships defined on
	// the DHCP server is retrieved.
	Relationship *dhcpm.FailoverRelationshipArray `idl:"name:pRelationship" json:"relationship"`
	// relationshipRead: This is a pointer to a DWORD value that specifies the number of
	// failover relationships returned in the pRelationship parameter. The caller MUST allocate
	// memory for this parameter equal to the size of data type DWORD.
	RelationshipRead uint32 `idl:"name:relationshipRead" json:"relationship_read"`
	// relationshipTotal: This is a pointer to a DWORD value that specifies the number of
	// failover relationships defined on the DHCP server that have not yet been enumerated.
	// The caller MUST allocate memory for this parameter equal to the size of data type
	// DWORD.
	RelationshipTotal uint32 `idl:"name:relationshipTotal" json:"relationship_total"`
	// Return: The R_DhcpV4FailoverEnumRelationship return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *FailoverEnumRelationshipV4Response) xxx_ToOp(ctx context.Context, op *xxx_FailoverEnumRelationshipV4Operation) *xxx_FailoverEnumRelationshipV4Operation {
	if op == nil {
		op = &xxx_FailoverEnumRelationshipV4Operation{}
	}
	if o == nil {
		return op
	}
	op.Resume = o.Resume
	op.Relationship = o.Relationship
	op.RelationshipRead = o.RelationshipRead
	op.RelationshipTotal = o.RelationshipTotal
	op.Return = o.Return
	return op
}

func (o *FailoverEnumRelationshipV4Response) xxx_FromOp(ctx context.Context, op *xxx_FailoverEnumRelationshipV4Operation) {
	if o == nil {
		return
	}
	o.Resume = op.Resume
	o.Relationship = op.Relationship
	o.RelationshipRead = op.RelationshipRead
	o.RelationshipTotal = op.RelationshipTotal
	o.Return = op.Return
}
func (o *FailoverEnumRelationshipV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *FailoverEnumRelationshipV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_FailoverEnumRelationshipV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_FailoverAddScopeToRelationshipV4Operation structure represents the R_DhcpV4FailoverAddScopeToRelationship operation
type xxx_FailoverAddScopeToRelationshipV4Operation struct {
	ServerIPAddress string                      `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Relationship    *dhcpm.FailoverRelationship `idl:"name:pRelationship" json:"relationship"`
	Return          uint32                      `idl:"name:Return" json:"return"`
}

func (o *xxx_FailoverAddScopeToRelationshipV4Operation) OpNum() int { return 94 }

func (o *xxx_FailoverAddScopeToRelationshipV4Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpV4FailoverAddScopeToRelationship"
}

func (o *xxx_FailoverAddScopeToRelationshipV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverAddScopeToRelationshipV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// pRelationship {in} (1:{alias=LPDHCP_FAILOVER_RELATIONSHIP}*(1))(2:{alias=DHCP_FAILOVER_RELATIONSHIP}(struct))
	{
		if o.Relationship != nil {
			if err := o.Relationship.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.FailoverRelationship{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverAddScopeToRelationshipV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// pRelationship {in} (1:{alias=LPDHCP_FAILOVER_RELATIONSHIP,pointer=ref}*(1))(2:{alias=DHCP_FAILOVER_RELATIONSHIP}(struct))
	{
		if o.Relationship == nil {
			o.Relationship = &dhcpm.FailoverRelationship{}
		}
		if err := o.Relationship.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverAddScopeToRelationshipV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverAddScopeToRelationshipV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverAddScopeToRelationshipV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// FailoverAddScopeToRelationshipV4Request structure represents the R_DhcpV4FailoverAddScopeToRelationship operation request
type FailoverAddScopeToRelationshipV4Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// pRelationship: This is a pointer to a type DHCP_FAILOVER_RELATIONSHIP structure (section
	// 2.2.1.2.98) that contains information about the failover relationship to which scopes
	// as specified in the pScopes member of the pRelationship parameter are to be added.
	Relationship *dhcpm.FailoverRelationship `idl:"name:pRelationship" json:"relationship"`
}

func (o *FailoverAddScopeToRelationshipV4Request) xxx_ToOp(ctx context.Context, op *xxx_FailoverAddScopeToRelationshipV4Operation) *xxx_FailoverAddScopeToRelationshipV4Operation {
	if op == nil {
		op = &xxx_FailoverAddScopeToRelationshipV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Relationship = o.Relationship
	return op
}

func (o *FailoverAddScopeToRelationshipV4Request) xxx_FromOp(ctx context.Context, op *xxx_FailoverAddScopeToRelationshipV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Relationship = op.Relationship
}
func (o *FailoverAddScopeToRelationshipV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *FailoverAddScopeToRelationshipV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_FailoverAddScopeToRelationshipV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// FailoverAddScopeToRelationshipV4Response structure represents the R_DhcpV4FailoverAddScopeToRelationship operation response
type FailoverAddScopeToRelationshipV4Response struct {
	// Return: The R_DhcpV4FailoverAddScopeToRelationship return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *FailoverAddScopeToRelationshipV4Response) xxx_ToOp(ctx context.Context, op *xxx_FailoverAddScopeToRelationshipV4Operation) *xxx_FailoverAddScopeToRelationshipV4Operation {
	if op == nil {
		op = &xxx_FailoverAddScopeToRelationshipV4Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *FailoverAddScopeToRelationshipV4Response) xxx_FromOp(ctx context.Context, op *xxx_FailoverAddScopeToRelationshipV4Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *FailoverAddScopeToRelationshipV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *FailoverAddScopeToRelationshipV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_FailoverAddScopeToRelationshipV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_FailoverDeleteScopeFromRelationshipV4Operation structure represents the R_DhcpV4FailoverDeleteScopeFromRelationship operation
type xxx_FailoverDeleteScopeFromRelationshipV4Operation struct {
	ServerIPAddress string                      `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Relationship    *dhcpm.FailoverRelationship `idl:"name:pRelationship" json:"relationship"`
	Return          uint32                      `idl:"name:Return" json:"return"`
}

func (o *xxx_FailoverDeleteScopeFromRelationshipV4Operation) OpNum() int { return 95 }

func (o *xxx_FailoverDeleteScopeFromRelationshipV4Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpV4FailoverDeleteScopeFromRelationship"
}

func (o *xxx_FailoverDeleteScopeFromRelationshipV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverDeleteScopeFromRelationshipV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// pRelationship {in} (1:{alias=LPDHCP_FAILOVER_RELATIONSHIP}*(1))(2:{alias=DHCP_FAILOVER_RELATIONSHIP}(struct))
	{
		if o.Relationship != nil {
			if err := o.Relationship.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.FailoverRelationship{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverDeleteScopeFromRelationshipV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// pRelationship {in} (1:{alias=LPDHCP_FAILOVER_RELATIONSHIP,pointer=ref}*(1))(2:{alias=DHCP_FAILOVER_RELATIONSHIP}(struct))
	{
		if o.Relationship == nil {
			o.Relationship = &dhcpm.FailoverRelationship{}
		}
		if err := o.Relationship.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverDeleteScopeFromRelationshipV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverDeleteScopeFromRelationshipV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverDeleteScopeFromRelationshipV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// FailoverDeleteScopeFromRelationshipV4Request structure represents the R_DhcpV4FailoverDeleteScopeFromRelationship operation request
type FailoverDeleteScopeFromRelationshipV4Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// pRelationship: This is a pointer to a type DHCP_FAILOVER_RELATIONSHIP structure (section
	// 2.2.1.2.98) that contains information about the failover relationship from which
	// scopes as specified in pScopes member of pRelationship.parameter are to be deleted.
	Relationship *dhcpm.FailoverRelationship `idl:"name:pRelationship" json:"relationship"`
}

func (o *FailoverDeleteScopeFromRelationshipV4Request) xxx_ToOp(ctx context.Context, op *xxx_FailoverDeleteScopeFromRelationshipV4Operation) *xxx_FailoverDeleteScopeFromRelationshipV4Operation {
	if op == nil {
		op = &xxx_FailoverDeleteScopeFromRelationshipV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Relationship = o.Relationship
	return op
}

func (o *FailoverDeleteScopeFromRelationshipV4Request) xxx_FromOp(ctx context.Context, op *xxx_FailoverDeleteScopeFromRelationshipV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Relationship = op.Relationship
}
func (o *FailoverDeleteScopeFromRelationshipV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *FailoverDeleteScopeFromRelationshipV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_FailoverDeleteScopeFromRelationshipV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// FailoverDeleteScopeFromRelationshipV4Response structure represents the R_DhcpV4FailoverDeleteScopeFromRelationship operation response
type FailoverDeleteScopeFromRelationshipV4Response struct {
	// Return: The R_DhcpV4FailoverDeleteScopeFromRelationship return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *FailoverDeleteScopeFromRelationshipV4Response) xxx_ToOp(ctx context.Context, op *xxx_FailoverDeleteScopeFromRelationshipV4Operation) *xxx_FailoverDeleteScopeFromRelationshipV4Operation {
	if op == nil {
		op = &xxx_FailoverDeleteScopeFromRelationshipV4Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *FailoverDeleteScopeFromRelationshipV4Response) xxx_FromOp(ctx context.Context, op *xxx_FailoverDeleteScopeFromRelationshipV4Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *FailoverDeleteScopeFromRelationshipV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *FailoverDeleteScopeFromRelationshipV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_FailoverDeleteScopeFromRelationshipV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_FailoverGetScopeRelationshipV4Operation structure represents the R_DhcpV4FailoverGetScopeRelationship operation
type xxx_FailoverGetScopeRelationshipV4Operation struct {
	ServerIPAddress string                      `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	ScopeID         uint32                      `idl:"name:scopeId" json:"scope_id"`
	Relationship    *dhcpm.FailoverRelationship `idl:"name:pRelationship" json:"relationship"`
	Return          uint32                      `idl:"name:Return" json:"return"`
}

func (o *xxx_FailoverGetScopeRelationshipV4Operation) OpNum() int { return 96 }

func (o *xxx_FailoverGetScopeRelationshipV4Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpV4FailoverGetScopeRelationship"
}

func (o *xxx_FailoverGetScopeRelationshipV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverGetScopeRelationshipV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// scopeId {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.ScopeID); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverGetScopeRelationshipV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// scopeId {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ScopeID); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverGetScopeRelationshipV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverGetScopeRelationshipV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pRelationship {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_FAILOVER_RELATIONSHIP}*(1))(3:{alias=DHCP_FAILOVER_RELATIONSHIP}(struct))
	{
		if o.Relationship != nil {
			_ptr_pRelationship := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Relationship != nil {
					if err := o.Relationship.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.FailoverRelationship{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Relationship, _ptr_pRelationship); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverGetScopeRelationshipV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pRelationship {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_FAILOVER_RELATIONSHIP,pointer=ref}*(1))(3:{alias=DHCP_FAILOVER_RELATIONSHIP}(struct))
	{
		_ptr_pRelationship := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Relationship == nil {
				o.Relationship = &dhcpm.FailoverRelationship{}
			}
			if err := o.Relationship.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_pRelationship := func(ptr interface{}) { o.Relationship = *ptr.(**dhcpm.FailoverRelationship) }
		if err := w.ReadPointer(&o.Relationship, _s_pRelationship, _ptr_pRelationship); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// FailoverGetScopeRelationshipV4Request structure represents the R_DhcpV4FailoverGetScopeRelationship operation request
type FailoverGetScopeRelationshipV4Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// scopeId: This is of type DHCP_IP_ADDRESS data type (section 2.2.1.2.1) that contains
	// the IPv4 subnet address which is configured as part of a failover relationship.
	ScopeID uint32 `idl:"name:scopeId" json:"scope_id"`
}

func (o *FailoverGetScopeRelationshipV4Request) xxx_ToOp(ctx context.Context, op *xxx_FailoverGetScopeRelationshipV4Operation) *xxx_FailoverGetScopeRelationshipV4Operation {
	if op == nil {
		op = &xxx_FailoverGetScopeRelationshipV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.ScopeID = o.ScopeID
	return op
}

func (o *FailoverGetScopeRelationshipV4Request) xxx_FromOp(ctx context.Context, op *xxx_FailoverGetScopeRelationshipV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.ScopeID = op.ScopeID
}
func (o *FailoverGetScopeRelationshipV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *FailoverGetScopeRelationshipV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_FailoverGetScopeRelationshipV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// FailoverGetScopeRelationshipV4Response structure represents the R_DhcpV4FailoverGetScopeRelationship operation response
type FailoverGetScopeRelationshipV4Response struct {
	// pRelationship: This is a pointer of type LPDHCP_FAILOVER_RELATIONSHIP (section 2.2.1.2.98)
	// that contains the failover relationship which has the scopeId parameter configured
	// as part of the pScopes member in the pRelationship parameter.
	Relationship *dhcpm.FailoverRelationship `idl:"name:pRelationship" json:"relationship"`
	// Return: The R_DhcpV4FailoverGetScopeRelationship return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *FailoverGetScopeRelationshipV4Response) xxx_ToOp(ctx context.Context, op *xxx_FailoverGetScopeRelationshipV4Operation) *xxx_FailoverGetScopeRelationshipV4Operation {
	if op == nil {
		op = &xxx_FailoverGetScopeRelationshipV4Operation{}
	}
	if o == nil {
		return op
	}
	op.Relationship = o.Relationship
	op.Return = o.Return
	return op
}

func (o *FailoverGetScopeRelationshipV4Response) xxx_FromOp(ctx context.Context, op *xxx_FailoverGetScopeRelationshipV4Operation) {
	if o == nil {
		return
	}
	o.Relationship = op.Relationship
	o.Return = op.Return
}
func (o *FailoverGetScopeRelationshipV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *FailoverGetScopeRelationshipV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_FailoverGetScopeRelationshipV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_FailoverGetScopeStatisticsV4Operation structure represents the R_DhcpV4FailoverGetScopeStatistics operation
type xxx_FailoverGetScopeStatisticsV4Operation struct {
	ServerIPAddress string                    `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	ScopeID         uint32                    `idl:"name:scopeId" json:"scope_id"`
	Stats           *dhcpm.FailoverStatistics `idl:"name:pStats" json:"stats"`
	Return          uint32                    `idl:"name:Return" json:"return"`
}

func (o *xxx_FailoverGetScopeStatisticsV4Operation) OpNum() int { return 97 }

func (o *xxx_FailoverGetScopeStatisticsV4Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpV4FailoverGetScopeStatistics"
}

func (o *xxx_FailoverGetScopeStatisticsV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverGetScopeStatisticsV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// scopeId {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.ScopeID); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverGetScopeStatisticsV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// scopeId {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ScopeID); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverGetScopeStatisticsV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverGetScopeStatisticsV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pStats {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_FAILOVER_STATISTICS}*(1))(3:{alias=DHCP_FAILOVER_STATISTICS}(struct))
	{
		if o.Stats != nil {
			_ptr_pStats := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Stats != nil {
					if err := o.Stats.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.FailoverStatistics{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Stats, _ptr_pStats); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverGetScopeStatisticsV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pStats {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_FAILOVER_STATISTICS,pointer=ref}*(1))(3:{alias=DHCP_FAILOVER_STATISTICS}(struct))
	{
		_ptr_pStats := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Stats == nil {
				o.Stats = &dhcpm.FailoverStatistics{}
			}
			if err := o.Stats.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_pStats := func(ptr interface{}) { o.Stats = *ptr.(**dhcpm.FailoverStatistics) }
		if err := w.ReadPointer(&o.Stats, _s_pStats, _ptr_pStats); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// FailoverGetScopeStatisticsV4Request structure represents the R_DhcpV4FailoverGetScopeStatistics operation request
type FailoverGetScopeStatisticsV4Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// scopeId: This is of type DHCP_IP_ADDRESS data type (section 2.2.1.2.1), that contains
	// a IPv4 subnet address configured for a failover relationship for which statistics
	// information needs to be returned.
	ScopeID uint32 `idl:"name:scopeId" json:"scope_id"`
}

func (o *FailoverGetScopeStatisticsV4Request) xxx_ToOp(ctx context.Context, op *xxx_FailoverGetScopeStatisticsV4Operation) *xxx_FailoverGetScopeStatisticsV4Operation {
	if op == nil {
		op = &xxx_FailoverGetScopeStatisticsV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.ScopeID = o.ScopeID
	return op
}

func (o *FailoverGetScopeStatisticsV4Request) xxx_FromOp(ctx context.Context, op *xxx_FailoverGetScopeStatisticsV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.ScopeID = op.ScopeID
}
func (o *FailoverGetScopeStatisticsV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *FailoverGetScopeStatisticsV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_FailoverGetScopeStatisticsV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// FailoverGetScopeStatisticsV4Response structure represents the R_DhcpV4FailoverGetScopeStatistics operation response
type FailoverGetScopeStatisticsV4Response struct {
	// pStats: This is a pointer of type LPDHCP_FAILOVER_STATISTICS (section 2.2.1.2.100)
	// that contains the statistics information for the scopeId parameter.
	Stats *dhcpm.FailoverStatistics `idl:"name:pStats" json:"stats"`
	// Return: The R_DhcpV4FailoverGetScopeStatistics return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *FailoverGetScopeStatisticsV4Response) xxx_ToOp(ctx context.Context, op *xxx_FailoverGetScopeStatisticsV4Operation) *xxx_FailoverGetScopeStatisticsV4Operation {
	if op == nil {
		op = &xxx_FailoverGetScopeStatisticsV4Operation{}
	}
	if o == nil {
		return op
	}
	op.Stats = o.Stats
	op.Return = o.Return
	return op
}

func (o *FailoverGetScopeStatisticsV4Response) xxx_FromOp(ctx context.Context, op *xxx_FailoverGetScopeStatisticsV4Operation) {
	if o == nil {
		return
	}
	o.Stats = op.Stats
	o.Return = op.Return
}
func (o *FailoverGetScopeStatisticsV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *FailoverGetScopeStatisticsV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_FailoverGetScopeStatisticsV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_FailoverGetClientInfoV4Operation structure represents the R_DhcpV4FailoverGetClientInfo operation
type xxx_FailoverGetClientInfoV4Operation struct {
	ServerIPAddress string                      `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	SearchInfo      *dhcpm.SearchInfo           `idl:"name:SearchInfo;pointer:ref" json:"search_info"`
	ClientInfo      *dhcpm.FailoverClientInfoV4 `idl:"name:ClientInfo" json:"client_info"`
	Return          uint32                      `idl:"name:Return" json:"return"`
}

func (o *xxx_FailoverGetClientInfoV4Operation) OpNum() int { return 98 }

func (o *xxx_FailoverGetClientInfoV4Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpV4FailoverGetClientInfo"
}

func (o *xxx_FailoverGetClientInfoV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverGetClientInfoV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// SearchInfo {in} (1:{pointer=ref, alias=LPDHCP_SEARCH_INFO}*(1))(2:{alias=DHCP_SEARCH_INFO}(struct))
	{
		if o.SearchInfo != nil {
			if err := o.SearchInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.SearchInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverGetClientInfoV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// SearchInfo {in} (1:{pointer=ref, alias=LPDHCP_SEARCH_INFO}*(1))(2:{alias=DHCP_SEARCH_INFO}(struct))
	{
		if o.SearchInfo == nil {
			o.SearchInfo = &dhcpm.SearchInfo{}
		}
		if err := o.SearchInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverGetClientInfoV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverGetClientInfoV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ClientInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCPV4_FAILOVER_CLIENT_INFO}*(1))(3:{alias=DHCPV4_FAILOVER_CLIENT_INFO}(struct))
	{
		if o.ClientInfo != nil {
			_ptr_ClientInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.ClientInfo != nil {
					if err := o.ClientInfo.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.FailoverClientInfoV4{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ClientInfo, _ptr_ClientInfo); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverGetClientInfoV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ClientInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCPV4_FAILOVER_CLIENT_INFO,pointer=ref}*(1))(3:{alias=DHCPV4_FAILOVER_CLIENT_INFO}(struct))
	{
		_ptr_ClientInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.ClientInfo == nil {
				o.ClientInfo = &dhcpm.FailoverClientInfoV4{}
			}
			if err := o.ClientInfo.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ClientInfo := func(ptr interface{}) { o.ClientInfo = *ptr.(**dhcpm.FailoverClientInfoV4) }
		if err := w.ReadPointer(&o.ClientInfo, _s_ClientInfo, _ptr_ClientInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// FailoverGetClientInfoV4Request structure represents the R_DhcpV4FailoverGetClientInfo operation request
type FailoverGetClientInfoV4Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// SearchInfo: This is a pointer to a type DHCP_SEARCH_INFO structure (section 2.2.1.2.18)
	// that defines the key to be used to search the DHCPv4 client lease record on the DHCPv4
	// server. In case the SearchType member is DhcpClientName enumeration value and there
	// are multiple lease records with the same ClientName member, the server will return
	// client information for the client having the lowest numerical IP address.
	SearchInfo *dhcpm.SearchInfo `idl:"name:SearchInfo;pointer:ref" json:"search_info"`
}

func (o *FailoverGetClientInfoV4Request) xxx_ToOp(ctx context.Context, op *xxx_FailoverGetClientInfoV4Operation) *xxx_FailoverGetClientInfoV4Operation {
	if op == nil {
		op = &xxx_FailoverGetClientInfoV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.SearchInfo = o.SearchInfo
	return op
}

func (o *FailoverGetClientInfoV4Request) xxx_FromOp(ctx context.Context, op *xxx_FailoverGetClientInfoV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.SearchInfo = op.SearchInfo
}
func (o *FailoverGetClientInfoV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *FailoverGetClientInfoV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_FailoverGetClientInfoV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// FailoverGetClientInfoV4Response structure represents the R_DhcpV4FailoverGetClientInfo operation response
type FailoverGetClientInfoV4Response struct {
	// ClientInfo: This is a pointer of type LPDHCPV4_FAILOVER_CLIENT_INFO (section 2.2.1.2.101)
	// that points to the location in which specific DHCPv4 client lease record information
	// is retrieved. The caller SHOULD free up this buffer after using this. The ClientHardwareAddress
	// member represents a DHCPv4 client unique ID (section 2.2.1.2.5.2).
	ClientInfo *dhcpm.FailoverClientInfoV4 `idl:"name:ClientInfo" json:"client_info"`
	// Return: The R_DhcpV4FailoverGetClientInfo return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *FailoverGetClientInfoV4Response) xxx_ToOp(ctx context.Context, op *xxx_FailoverGetClientInfoV4Operation) *xxx_FailoverGetClientInfoV4Operation {
	if op == nil {
		op = &xxx_FailoverGetClientInfoV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ClientInfo = o.ClientInfo
	op.Return = o.Return
	return op
}

func (o *FailoverGetClientInfoV4Response) xxx_FromOp(ctx context.Context, op *xxx_FailoverGetClientInfoV4Operation) {
	if o == nil {
		return
	}
	o.ClientInfo = op.ClientInfo
	o.Return = op.Return
}
func (o *FailoverGetClientInfoV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *FailoverGetClientInfoV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_FailoverGetClientInfoV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_FailoverGetSystemTimeV4Operation structure represents the R_DhcpV4FailoverGetSystemTime operation
type xxx_FailoverGetSystemTimeV4Operation struct {
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Time            uint32 `idl:"name:pTime" json:"time"`
	Return          uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_FailoverGetSystemTimeV4Operation) OpNum() int { return 99 }

func (o *xxx_FailoverGetSystemTimeV4Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpV4FailoverGetSystemTime"
}

func (o *xxx_FailoverGetSystemTimeV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverGetSystemTimeV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverGetSystemTimeV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverGetSystemTimeV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverGetSystemTimeV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pTime {out} (1:{alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Time); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverGetSystemTimeV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pTime {out} (1:{alias=LPDWORD,pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Time); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// FailoverGetSystemTimeV4Request structure represents the R_DhcpV4FailoverGetSystemTime operation request
type FailoverGetSystemTimeV4Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
}

func (o *FailoverGetSystemTimeV4Request) xxx_ToOp(ctx context.Context, op *xxx_FailoverGetSystemTimeV4Operation) *xxx_FailoverGetSystemTimeV4Operation {
	if op == nil {
		op = &xxx_FailoverGetSystemTimeV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	return op
}

func (o *FailoverGetSystemTimeV4Request) xxx_FromOp(ctx context.Context, op *xxx_FailoverGetSystemTimeV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
}
func (o *FailoverGetSystemTimeV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *FailoverGetSystemTimeV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_FailoverGetSystemTimeV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// FailoverGetSystemTimeV4Response structure represents the R_DhcpV4FailoverGetSystemTime operation response
type FailoverGetSystemTimeV4Response struct {
	// pTime: This is a pointer to type DWORD and returns the current time, in seconds elapsed
	// since midnight, January 1, 1970, Coordinated Universal Time (UTC), on the DHCP server.
	// The caller of the API must allocate the memory for this parameter.
	Time uint32 `idl:"name:pTime" json:"time"`
	// Return: The R_DhcpV4FailoverGetSystemTime return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *FailoverGetSystemTimeV4Response) xxx_ToOp(ctx context.Context, op *xxx_FailoverGetSystemTimeV4Operation) *xxx_FailoverGetSystemTimeV4Operation {
	if op == nil {
		op = &xxx_FailoverGetSystemTimeV4Operation{}
	}
	if o == nil {
		return op
	}
	op.Time = o.Time
	op.Return = o.Return
	return op
}

func (o *FailoverGetSystemTimeV4Response) xxx_FromOp(ctx context.Context, op *xxx_FailoverGetSystemTimeV4Operation) {
	if o == nil {
		return
	}
	o.Time = op.Time
	o.Return = op.Return
}
func (o *FailoverGetSystemTimeV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *FailoverGetSystemTimeV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_FailoverGetSystemTimeV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_FailoverTriggerAddrAllocationV4Operation structure represents the R_DhcpV4FailoverTriggerAddrAllocation operation
type xxx_FailoverTriggerAddrAllocationV4Operation struct {
	ServerIPAddress  string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	FailRelationName string `idl:"name:FailRelName;string;pointer:unique" json:"fail_relation_name"`
	Return           uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_FailoverTriggerAddrAllocationV4Operation) OpNum() int { return 100 }

func (o *xxx_FailoverTriggerAddrAllocationV4Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpV4FailoverTriggerAddrAllocation"
}

func (o *xxx_FailoverTriggerAddrAllocationV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverTriggerAddrAllocationV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// FailRelName {in} (1:{string, pointer=unique, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.FailRelationName != "" {
			_ptr_FailRelName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.FailRelationName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.FailRelationName, _ptr_FailRelName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverTriggerAddrAllocationV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// FailRelName {in} (1:{string, pointer=unique, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_FailRelName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.FailRelationName); err != nil {
				return err
			}
			return nil
		})
		_s_FailRelName := func(ptr interface{}) { o.FailRelationName = *ptr.(*string) }
		if err := w.ReadPointer(&o.FailRelationName, _s_FailRelName, _ptr_FailRelName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverTriggerAddrAllocationV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverTriggerAddrAllocationV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverTriggerAddrAllocationV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// FailoverTriggerAddrAllocationV4Request structure represents the R_DhcpV4FailoverTriggerAddrAllocation operation request
type FailoverTriggerAddrAllocationV4Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// FailRelName: A pointer to a null-terminated Unicode string that contains the name
	// of the failover relationship for which free addresses are re-distributed. There is
	// no restriction on the length of this Unicode string.
	FailRelationName string `idl:"name:FailRelName;string;pointer:unique" json:"fail_relation_name"`
}

func (o *FailoverTriggerAddrAllocationV4Request) xxx_ToOp(ctx context.Context, op *xxx_FailoverTriggerAddrAllocationV4Operation) *xxx_FailoverTriggerAddrAllocationV4Operation {
	if op == nil {
		op = &xxx_FailoverTriggerAddrAllocationV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.FailRelationName = o.FailRelationName
	return op
}

func (o *FailoverTriggerAddrAllocationV4Request) xxx_FromOp(ctx context.Context, op *xxx_FailoverTriggerAddrAllocationV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.FailRelationName = op.FailRelationName
}
func (o *FailoverTriggerAddrAllocationV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *FailoverTriggerAddrAllocationV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_FailoverTriggerAddrAllocationV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// FailoverTriggerAddrAllocationV4Response structure represents the R_DhcpV4FailoverTriggerAddrAllocation operation response
type FailoverTriggerAddrAllocationV4Response struct {
	// Return: The R_DhcpV4FailoverTriggerAddrAllocation return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *FailoverTriggerAddrAllocationV4Response) xxx_ToOp(ctx context.Context, op *xxx_FailoverTriggerAddrAllocationV4Operation) *xxx_FailoverTriggerAddrAllocationV4Operation {
	if op == nil {
		op = &xxx_FailoverTriggerAddrAllocationV4Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *FailoverTriggerAddrAllocationV4Response) xxx_FromOp(ctx context.Context, op *xxx_FailoverTriggerAddrAllocationV4Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *FailoverTriggerAddrAllocationV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *FailoverTriggerAddrAllocationV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_FailoverTriggerAddrAllocationV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetOptionValueV4Operation structure represents the R_DhcpV4SetOptionValue operation
type xxx_SetOptionValueV4Operation struct {
	ServerIPAddress string                 `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Flags           uint32                 `idl:"name:Flags" json:"flags"`
	OptionID        uint32                 `idl:"name:OptionID" json:"option_id"`
	PolicyName      string                 `idl:"name:PolicyName;string;pointer:unique" json:"policy_name"`
	VendorName      string                 `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	ScopeInfo       *dhcpm.OptionScopeInfo `idl:"name:ScopeInfo" json:"scope_info"`
	OptionValue     *dhcpm.OptionData      `idl:"name:OptionValue" json:"option_value"`
	Return          uint32                 `idl:"name:Return" json:"return"`
}

func (o *xxx_SetOptionValueV4Operation) OpNum() int { return 101 }

func (o *xxx_SetOptionValueV4Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpV4SetOptionValue" }

func (o *xxx_SetOptionValueV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOptionValueV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	// OptionID {in} (1:{alias=DHCP_OPTION_ID, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.OptionID); err != nil {
			return err
		}
	}
	// PolicyName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.PolicyName != "" {
			_ptr_PolicyName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.PolicyName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.PolicyName, _ptr_PolicyName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.VendorName != "" {
			_ptr_VendorName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.VendorName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.VendorName, _ptr_VendorName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ScopeInfo {in} (1:{alias=LPDHCP_OPTION_SCOPE_INFO}*(1))(2:{alias=DHCP_OPTION_SCOPE_INFO}(struct))
	{
		if o.ScopeInfo != nil {
			if err := o.ScopeInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.OptionScopeInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// OptionValue {in} (1:{alias=LPDHCP_OPTION_DATA}*(1))(2:{alias=DHCP_OPTION_DATA}(struct))
	{
		if o.OptionValue != nil {
			if err := o.OptionValue.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.OptionData{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOptionValueV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	// OptionID {in} (1:{alias=DHCP_OPTION_ID, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OptionID); err != nil {
			return err
		}
	}
	// PolicyName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_PolicyName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.PolicyName); err != nil {
				return err
			}
			return nil
		})
		_s_PolicyName := func(ptr interface{}) { o.PolicyName = *ptr.(*string) }
		if err := w.ReadPointer(&o.PolicyName, _s_PolicyName, _ptr_PolicyName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_VendorName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.VendorName); err != nil {
				return err
			}
			return nil
		})
		_s_VendorName := func(ptr interface{}) { o.VendorName = *ptr.(*string) }
		if err := w.ReadPointer(&o.VendorName, _s_VendorName, _ptr_VendorName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ScopeInfo {in} (1:{alias=LPDHCP_OPTION_SCOPE_INFO,pointer=ref}*(1))(2:{alias=DHCP_OPTION_SCOPE_INFO}(struct))
	{
		if o.ScopeInfo == nil {
			o.ScopeInfo = &dhcpm.OptionScopeInfo{}
		}
		if err := o.ScopeInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// OptionValue {in} (1:{alias=LPDHCP_OPTION_DATA,pointer=ref}*(1))(2:{alias=DHCP_OPTION_DATA}(struct))
	{
		if o.OptionValue == nil {
			o.OptionValue = &dhcpm.OptionData{}
		}
		if err := o.OptionValue.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOptionValueV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOptionValueV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOptionValueV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetOptionValueV4Request structure represents the R_DhcpV4SetOptionValue operation request
type SetOptionValueV4Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// Flags: This is of type DWORD that specifies that the option value is set for a specific
	// or default vendor class.
	//
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                        |                                                                                  |
	//	|                 VALUE                  |                                     MEANING                                      |
	//	|                                        |                                                                                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_DEFAULT 0x00000000   | The option definition is set for the default vendor class.                       |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_IS_VENDOR 0x00000003 | If a bitwise AND operation with this bitmask yields a nonzero value, it          |
	//	|                                        | indicates that the option definition is set for a specific vendor class.         |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	Flags    uint32 `idl:"name:Flags" json:"flags"`
	OptionID uint32 `idl:"name:OptionID" json:"option_id"`
	// PolicyName: A pointer to a null-terminated Unicode string that contains the name
	// of the policy inside the subnet identified by the SubnetScopeInfo member of the ScopeInfo
	// parameter for which the option value is being set.
	PolicyName string `idl:"name:PolicyName;string;pointer:unique" json:"policy_name"`
	// VendorName: A pointer to a null-terminated Unicode string that contains the name
	// of the vendor class for which the option value is being set. This parameter is optional.
	// If the vendor class is not specified, the option value is set for the default vendor
	// class.
	VendorName string `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	// ScopeInfo: This is a pointer to a type DHCP_OPTION_SCOPE_INFO structure (section
	// 2.2.1.2.41) that contains information describing the DHCPv4 scope for which this
	// option value is set. This value contains the server or scope level at which the option
	// value is to be set.
	ScopeInfo *dhcpm.OptionScopeInfo `idl:"name:ScopeInfo" json:"scope_info"`
	// OptionValue: A pointer to a type DHCP_OPTION_DATA structure (section 2.2.1.2.24)
	// that contains the option value that is set for an option corresponding to the OptionId
	// parameter.
	OptionValue *dhcpm.OptionData `idl:"name:OptionValue" json:"option_value"`
}

func (o *SetOptionValueV4Request) xxx_ToOp(ctx context.Context, op *xxx_SetOptionValueV4Operation) *xxx_SetOptionValueV4Operation {
	if op == nil {
		op = &xxx_SetOptionValueV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Flags = o.Flags
	op.OptionID = o.OptionID
	op.PolicyName = o.PolicyName
	op.VendorName = o.VendorName
	op.ScopeInfo = o.ScopeInfo
	op.OptionValue = o.OptionValue
	return op
}

func (o *SetOptionValueV4Request) xxx_FromOp(ctx context.Context, op *xxx_SetOptionValueV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Flags = op.Flags
	o.OptionID = op.OptionID
	o.PolicyName = op.PolicyName
	o.VendorName = op.VendorName
	o.ScopeInfo = op.ScopeInfo
	o.OptionValue = op.OptionValue
}
func (o *SetOptionValueV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetOptionValueV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetOptionValueV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetOptionValueV4Response structure represents the R_DhcpV4SetOptionValue operation response
type SetOptionValueV4Response struct {
	// Return: The R_DhcpV4SetOptionValue return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetOptionValueV4Response) xxx_ToOp(ctx context.Context, op *xxx_SetOptionValueV4Operation) *xxx_SetOptionValueV4Operation {
	if op == nil {
		op = &xxx_SetOptionValueV4Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetOptionValueV4Response) xxx_FromOp(ctx context.Context, op *xxx_SetOptionValueV4Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetOptionValueV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetOptionValueV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetOptionValueV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetOptionValuesV4Operation structure represents the R_DhcpV4SetOptionValues operation
type xxx_SetOptionValuesV4Operation struct {
	ServerIPAddress string                  `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Flags           uint32                  `idl:"name:Flags" json:"flags"`
	PolicyName      string                  `idl:"name:PolicyName;string;pointer:unique" json:"policy_name"`
	VendorName      string                  `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	ScopeInfo       *dhcpm.OptionScopeInfo  `idl:"name:ScopeInfo" json:"scope_info"`
	OptionValues    *dhcpm.OptionValueArray `idl:"name:OptionValues" json:"option_values"`
	Return          uint32                  `idl:"name:Return" json:"return"`
}

func (o *xxx_SetOptionValuesV4Operation) OpNum() int { return 102 }

func (o *xxx_SetOptionValuesV4Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpV4SetOptionValues"
}

func (o *xxx_SetOptionValuesV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOptionValuesV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	// PolicyName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.PolicyName != "" {
			_ptr_PolicyName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.PolicyName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.PolicyName, _ptr_PolicyName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.VendorName != "" {
			_ptr_VendorName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.VendorName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.VendorName, _ptr_VendorName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ScopeInfo {in} (1:{alias=LPDHCP_OPTION_SCOPE_INFO}*(1))(2:{alias=DHCP_OPTION_SCOPE_INFO}(struct))
	{
		if o.ScopeInfo != nil {
			if err := o.ScopeInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.OptionScopeInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// OptionValues {in} (1:{alias=LPDHCP_OPTION_VALUE_ARRAY}*(1))(2:{alias=DHCP_OPTION_VALUE_ARRAY}(struct))
	{
		if o.OptionValues != nil {
			if err := o.OptionValues.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.OptionValueArray{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOptionValuesV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	// PolicyName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_PolicyName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.PolicyName); err != nil {
				return err
			}
			return nil
		})
		_s_PolicyName := func(ptr interface{}) { o.PolicyName = *ptr.(*string) }
		if err := w.ReadPointer(&o.PolicyName, _s_PolicyName, _ptr_PolicyName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_VendorName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.VendorName); err != nil {
				return err
			}
			return nil
		})
		_s_VendorName := func(ptr interface{}) { o.VendorName = *ptr.(*string) }
		if err := w.ReadPointer(&o.VendorName, _s_VendorName, _ptr_VendorName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ScopeInfo {in} (1:{alias=LPDHCP_OPTION_SCOPE_INFO,pointer=ref}*(1))(2:{alias=DHCP_OPTION_SCOPE_INFO}(struct))
	{
		if o.ScopeInfo == nil {
			o.ScopeInfo = &dhcpm.OptionScopeInfo{}
		}
		if err := o.ScopeInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// OptionValues {in} (1:{alias=LPDHCP_OPTION_VALUE_ARRAY,pointer=ref}*(1))(2:{alias=DHCP_OPTION_VALUE_ARRAY}(struct))
	{
		if o.OptionValues == nil {
			o.OptionValues = &dhcpm.OptionValueArray{}
		}
		if err := o.OptionValues.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOptionValuesV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOptionValuesV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetOptionValuesV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetOptionValuesV4Request structure represents the R_DhcpV4SetOptionValues operation request
type SetOptionValuesV4Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// Flags: This is of type DWORD that specifies that the option value is set for a specific
	// or default vendor class.
	//
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                        |                                                                                  |
	//	|                 VALUE                  |                                     MEANING                                      |
	//	|                                        |                                                                                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_DEFAULT 0x00000000   | The option definition is set for the default vendor class.                       |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_IS_VENDOR 0x00000003 | If a bitwise AND operation with this bitmask yields a nonzero value, it          |
	//	|                                        | indicates that the option definition is set for a specific vendor class.         |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	Flags uint32 `idl:"name:Flags" json:"flags"`
	// PolicyName: A pointer to a null-terminated Unicode string that contains the name
	// of the policy inside the subnet identified by the SubnetScopeInfo member of the ScopeInfo
	// parameter for which the option value is being set.
	PolicyName string `idl:"name:PolicyName;string;pointer:unique" json:"policy_name"`
	// VendorName: A pointer to a null-terminated Unicode string that contains the name
	// of the vendor class to which the option value is being set. This parameter is optional.
	// If the vendor class is not specified, the option value is set for a default vendor
	// class.
	VendorName string `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	// ScopeInfo: This is a pointer to a type DHCP_OPTION_SCOPE_INFO structure (section
	// 2.2.1.2.41) that contains information describing the DHCPv4 scope for which this
	// option value is set. This value contains the server or scope level at which the option
	// values are set.
	ScopeInfo *dhcpm.OptionScopeInfo `idl:"name:ScopeInfo" json:"scope_info"`
	// OptionValues: This is a pointer to a type DHCP_OPTION_VALUE_ARRAY structure (section
	// 2.2.1.2.43) that points to the location that contains one or more option identifiers,
	// along with the values.
	OptionValues *dhcpm.OptionValueArray `idl:"name:OptionValues" json:"option_values"`
}

func (o *SetOptionValuesV4Request) xxx_ToOp(ctx context.Context, op *xxx_SetOptionValuesV4Operation) *xxx_SetOptionValuesV4Operation {
	if op == nil {
		op = &xxx_SetOptionValuesV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Flags = o.Flags
	op.PolicyName = o.PolicyName
	op.VendorName = o.VendorName
	op.ScopeInfo = o.ScopeInfo
	op.OptionValues = o.OptionValues
	return op
}

func (o *SetOptionValuesV4Request) xxx_FromOp(ctx context.Context, op *xxx_SetOptionValuesV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Flags = op.Flags
	o.PolicyName = op.PolicyName
	o.VendorName = op.VendorName
	o.ScopeInfo = op.ScopeInfo
	o.OptionValues = op.OptionValues
}
func (o *SetOptionValuesV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetOptionValuesV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetOptionValuesV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetOptionValuesV4Response structure represents the R_DhcpV4SetOptionValues operation response
type SetOptionValuesV4Response struct {
	// Return: The R_DhcpV4SetOptionValues return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetOptionValuesV4Response) xxx_ToOp(ctx context.Context, op *xxx_SetOptionValuesV4Operation) *xxx_SetOptionValuesV4Operation {
	if op == nil {
		op = &xxx_SetOptionValuesV4Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetOptionValuesV4Response) xxx_FromOp(ctx context.Context, op *xxx_SetOptionValuesV4Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetOptionValuesV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetOptionValuesV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetOptionValuesV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetOptionValueV4Operation structure represents the R_DhcpV4GetOptionValue operation
type xxx_GetOptionValueV4Operation struct {
	ServerIPAddress string                 `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Flags           uint32                 `idl:"name:Flags" json:"flags"`
	OptionID        uint32                 `idl:"name:OptionID" json:"option_id"`
	PolicyName      string                 `idl:"name:PolicyName;string;pointer:unique" json:"policy_name"`
	VendorName      string                 `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	ScopeInfo       *dhcpm.OptionScopeInfo `idl:"name:ScopeInfo" json:"scope_info"`
	OptionValue     *dhcpm.OptionValue     `idl:"name:OptionValue" json:"option_value"`
	Return          uint32                 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetOptionValueV4Operation) OpNum() int { return 103 }

func (o *xxx_GetOptionValueV4Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpV4GetOptionValue" }

func (o *xxx_GetOptionValueV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetOptionValueV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	// OptionID {in} (1:{alias=DHCP_OPTION_ID, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.OptionID); err != nil {
			return err
		}
	}
	// PolicyName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.PolicyName != "" {
			_ptr_PolicyName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.PolicyName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.PolicyName, _ptr_PolicyName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.VendorName != "" {
			_ptr_VendorName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.VendorName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.VendorName, _ptr_VendorName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ScopeInfo {in} (1:{alias=LPDHCP_OPTION_SCOPE_INFO}*(1))(2:{alias=DHCP_OPTION_SCOPE_INFO}(struct))
	{
		if o.ScopeInfo != nil {
			if err := o.ScopeInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.OptionScopeInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetOptionValueV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	// OptionID {in} (1:{alias=DHCP_OPTION_ID, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OptionID); err != nil {
			return err
		}
	}
	// PolicyName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_PolicyName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.PolicyName); err != nil {
				return err
			}
			return nil
		})
		_s_PolicyName := func(ptr interface{}) { o.PolicyName = *ptr.(*string) }
		if err := w.ReadPointer(&o.PolicyName, _s_PolicyName, _ptr_PolicyName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_VendorName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.VendorName); err != nil {
				return err
			}
			return nil
		})
		_s_VendorName := func(ptr interface{}) { o.VendorName = *ptr.(*string) }
		if err := w.ReadPointer(&o.VendorName, _s_VendorName, _ptr_VendorName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ScopeInfo {in} (1:{alias=LPDHCP_OPTION_SCOPE_INFO,pointer=ref}*(1))(2:{alias=DHCP_OPTION_SCOPE_INFO}(struct))
	{
		if o.ScopeInfo == nil {
			o.ScopeInfo = &dhcpm.OptionScopeInfo{}
		}
		if err := o.ScopeInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetOptionValueV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetOptionValueV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// OptionValue {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_OPTION_VALUE}*(1))(3:{alias=DHCP_OPTION_VALUE}(struct))
	{
		if o.OptionValue != nil {
			_ptr_OptionValue := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.OptionValue != nil {
					if err := o.OptionValue.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.OptionValue{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.OptionValue, _ptr_OptionValue); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetOptionValueV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// OptionValue {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_OPTION_VALUE,pointer=ref}*(1))(3:{alias=DHCP_OPTION_VALUE}(struct))
	{
		_ptr_OptionValue := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.OptionValue == nil {
				o.OptionValue = &dhcpm.OptionValue{}
			}
			if err := o.OptionValue.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_OptionValue := func(ptr interface{}) { o.OptionValue = *ptr.(**dhcpm.OptionValue) }
		if err := w.ReadPointer(&o.OptionValue, _s_OptionValue, _ptr_OptionValue); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetOptionValueV4Request structure represents the R_DhcpV4GetOptionValue operation request
type GetOptionValueV4Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// Flags: This is of type DWORD that specifies that the option value is set for a specific
	// or default vendor class.
	//
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                        |                                                                                  |
	//	|                 VALUE                  |                                     MEANING                                      |
	//	|                                        |                                                                                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_DEFAULT 0x00000000   | The option definition is set for the default vendor class.                       |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_IS_VENDOR 0x00000003 | If a bitwise AND operation with this bitmask yields a nonzero value, it          |
	//	|                                        | indicates that the option definition is set for a specific vendor class.         |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	Flags uint32 `idl:"name:Flags" json:"flags"`
	// OptionID: This is of type DHCP_OPTION_ID data type (section 2.2.1.2.3), containing
	// the option ID of the option being set or modified.
	OptionID uint32 `idl:"name:OptionID" json:"option_id"`
	// PolicyName: A pointer to a null-terminated Unicode string that contains the name
	// of the policy inside the subnet identified by the SubnetScopeInfo member of the ScopeInfo
	// parameter for which the option value is being set.
	PolicyName string `idl:"name:PolicyName;string;pointer:unique" json:"policy_name"`
	// VendorName: A pointer to a null-terminated Unicode string that contains the name
	// of the vendor class to which the option value is being set. This parameter is optional.
	// If the vendor class is not specified, the option value is set for a default vendor
	// class.
	VendorName string `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	// ScopeInfo: This is a pointer to a type DHCP_OPTION_SCOPE_INFO structure (section
	// 2.2.1.2.41) that contains information describing the DHCPv4 scope for which this
	// option value is set. This value contains the server or scope level at which the option
	// values are set.
	ScopeInfo *dhcpm.OptionScopeInfo `idl:"name:ScopeInfo" json:"scope_info"`
}

func (o *GetOptionValueV4Request) xxx_ToOp(ctx context.Context, op *xxx_GetOptionValueV4Operation) *xxx_GetOptionValueV4Operation {
	if op == nil {
		op = &xxx_GetOptionValueV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Flags = o.Flags
	op.OptionID = o.OptionID
	op.PolicyName = o.PolicyName
	op.VendorName = o.VendorName
	op.ScopeInfo = o.ScopeInfo
	return op
}

func (o *GetOptionValueV4Request) xxx_FromOp(ctx context.Context, op *xxx_GetOptionValueV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Flags = op.Flags
	o.OptionID = op.OptionID
	o.PolicyName = op.PolicyName
	o.VendorName = op.VendorName
	o.ScopeInfo = op.ScopeInfo
}
func (o *GetOptionValueV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetOptionValueV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetOptionValueV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetOptionValueV4Response structure represents the R_DhcpV4GetOptionValue operation response
type GetOptionValueV4Response struct {
	// OptionValue: A pointer of type LPDHCP_OPTION_VALUE (section 2.2.1.2.42) that contains
	// the option value that is set for an option corresponding to the OptionId parameter.
	// For Dynamic DNS update settings, see section 3.3.1.
	OptionValue *dhcpm.OptionValue `idl:"name:OptionValue" json:"option_value"`
	// Return: The R_DhcpV4GetOptionValue return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetOptionValueV4Response) xxx_ToOp(ctx context.Context, op *xxx_GetOptionValueV4Operation) *xxx_GetOptionValueV4Operation {
	if op == nil {
		op = &xxx_GetOptionValueV4Operation{}
	}
	if o == nil {
		return op
	}
	op.OptionValue = o.OptionValue
	op.Return = o.Return
	return op
}

func (o *GetOptionValueV4Response) xxx_FromOp(ctx context.Context, op *xxx_GetOptionValueV4Operation) {
	if o == nil {
		return
	}
	o.OptionValue = op.OptionValue
	o.Return = op.Return
}
func (o *GetOptionValueV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetOptionValueV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetOptionValueV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_RemoveOptionValueV4Operation structure represents the R_DhcpV4RemoveOptionValue operation
type xxx_RemoveOptionValueV4Operation struct {
	ServerIPAddress string                 `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Flags           uint32                 `idl:"name:Flags" json:"flags"`
	OptionID        uint32                 `idl:"name:OptionID" json:"option_id"`
	PolicyName      string                 `idl:"name:PolicyName;string;pointer:unique" json:"policy_name"`
	VendorName      string                 `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	ScopeInfo       *dhcpm.OptionScopeInfo `idl:"name:ScopeInfo" json:"scope_info"`
	Return          uint32                 `idl:"name:Return" json:"return"`
}

func (o *xxx_RemoveOptionValueV4Operation) OpNum() int { return 104 }

func (o *xxx_RemoveOptionValueV4Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpV4RemoveOptionValue"
}

func (o *xxx_RemoveOptionValueV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveOptionValueV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	// OptionID {in} (1:{alias=DHCP_OPTION_ID, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.OptionID); err != nil {
			return err
		}
	}
	// PolicyName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.PolicyName != "" {
			_ptr_PolicyName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.PolicyName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.PolicyName, _ptr_PolicyName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.VendorName != "" {
			_ptr_VendorName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.VendorName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.VendorName, _ptr_VendorName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ScopeInfo {in} (1:{alias=LPDHCP_OPTION_SCOPE_INFO}*(1))(2:{alias=DHCP_OPTION_SCOPE_INFO}(struct))
	{
		if o.ScopeInfo != nil {
			if err := o.ScopeInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.OptionScopeInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveOptionValueV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	// OptionID {in} (1:{alias=DHCP_OPTION_ID, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OptionID); err != nil {
			return err
		}
	}
	// PolicyName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_PolicyName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.PolicyName); err != nil {
				return err
			}
			return nil
		})
		_s_PolicyName := func(ptr interface{}) { o.PolicyName = *ptr.(*string) }
		if err := w.ReadPointer(&o.PolicyName, _s_PolicyName, _ptr_PolicyName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// VendorName {in} (1:{string, pointer=unique}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_VendorName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.VendorName); err != nil {
				return err
			}
			return nil
		})
		_s_VendorName := func(ptr interface{}) { o.VendorName = *ptr.(*string) }
		if err := w.ReadPointer(&o.VendorName, _s_VendorName, _ptr_VendorName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ScopeInfo {in} (1:{alias=LPDHCP_OPTION_SCOPE_INFO,pointer=ref}*(1))(2:{alias=DHCP_OPTION_SCOPE_INFO}(struct))
	{
		if o.ScopeInfo == nil {
			o.ScopeInfo = &dhcpm.OptionScopeInfo{}
		}
		if err := o.ScopeInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveOptionValueV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveOptionValueV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemoveOptionValueV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// RemoveOptionValueV4Request structure represents the R_DhcpV4RemoveOptionValue operation request
type RemoveOptionValueV4Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// Flags: This is of type DWORD that specifies that the option value is set for a specific
	// or default vendor class.
	//
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                        |                                                                                  |
	//	|                 VALUE                  |                                     MEANING                                      |
	//	|                                        |                                                                                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_DEFAULT 0x00000000   | The option definition is set for the default vendor class.                       |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_IS_VENDOR 0x00000003 | If a bitwise AND operation with this bitmask yields a nonzero value, it          |
	//	|                                        | indicates that the option definition is set for a specific vendor class.         |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	Flags uint32 `idl:"name:Flags" json:"flags"`
	// OptionID: This is of type DHCP_OPTION_ID data type (section 2.2.1.2.3), containing
	// the option ID of the option being set or modified.
	OptionID uint32 `idl:"name:OptionID" json:"option_id"`
	// PolicyName: A pointer to a null-terminated Unicode string that contains the name
	// of the policy inside the subnet identified by the SubnetScopeInfo member of the ScopeInfo
	// parameter for which the option value is being set.
	PolicyName string `idl:"name:PolicyName;string;pointer:unique" json:"policy_name"`
	// VendorName: A pointer to a null-terminated Unicode string that contains the name
	// of the vendor class to which the option value is being set. This parameter is optional.
	// If the vendor class is not specified, the option value is set for a default vendor
	// class.
	VendorName string `idl:"name:VendorName;string;pointer:unique" json:"vendor_name"`
	// ScopeInfo: This is a pointer to a type DHCP_OPTION_SCOPE_INFO (section 2.2.1.2.41)
	// that contains information describing the DHCPv4 scope for which this option value
	// is set. This value contains the server level or scope level at which the option values
	// are set.
	ScopeInfo *dhcpm.OptionScopeInfo `idl:"name:ScopeInfo" json:"scope_info"`
}

func (o *RemoveOptionValueV4Request) xxx_ToOp(ctx context.Context, op *xxx_RemoveOptionValueV4Operation) *xxx_RemoveOptionValueV4Operation {
	if op == nil {
		op = &xxx_RemoveOptionValueV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Flags = o.Flags
	op.OptionID = o.OptionID
	op.PolicyName = o.PolicyName
	op.VendorName = o.VendorName
	op.ScopeInfo = o.ScopeInfo
	return op
}

func (o *RemoveOptionValueV4Request) xxx_FromOp(ctx context.Context, op *xxx_RemoveOptionValueV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Flags = op.Flags
	o.OptionID = op.OptionID
	o.PolicyName = op.PolicyName
	o.VendorName = op.VendorName
	o.ScopeInfo = op.ScopeInfo
}
func (o *RemoveOptionValueV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *RemoveOptionValueV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemoveOptionValueV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// RemoveOptionValueV4Response structure represents the R_DhcpV4RemoveOptionValue operation response
type RemoveOptionValueV4Response struct {
	// Return: The R_DhcpV4RemoveOptionValue return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *RemoveOptionValueV4Response) xxx_ToOp(ctx context.Context, op *xxx_RemoveOptionValueV4Operation) *xxx_RemoveOptionValueV4Operation {
	if op == nil {
		op = &xxx_RemoveOptionValueV4Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *RemoveOptionValueV4Response) xxx_FromOp(ctx context.Context, op *xxx_RemoveOptionValueV4Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *RemoveOptionValueV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *RemoveOptionValueV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemoveOptionValueV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetAllOptionValuesV4Operation structure represents the R_DhcpV4GetAllOptionValues operation
type xxx_GetAllOptionValuesV4Operation struct {
	ServerIPAddress string                   `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Flags           uint32                   `idl:"name:Flags" json:"flags"`
	ScopeInfo       *dhcpm.OptionScopeInfo   `idl:"name:ScopeInfo" json:"scope_info"`
	Values          *dhcpm.AllOptionValuesPB `idl:"name:Values" json:"values"`
	Return          uint32                   `idl:"name:Return" json:"return"`
}

func (o *xxx_GetAllOptionValuesV4Operation) OpNum() int { return 105 }

func (o *xxx_GetAllOptionValuesV4Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpV4GetAllOptionValues"
}

func (o *xxx_GetAllOptionValuesV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetAllOptionValuesV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	// ScopeInfo {in} (1:{alias=LPDHCP_OPTION_SCOPE_INFO}*(1))(2:{alias=DHCP_OPTION_SCOPE_INFO}(struct))
	{
		if o.ScopeInfo != nil {
			if err := o.ScopeInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.OptionScopeInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetAllOptionValuesV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	// ScopeInfo {in} (1:{alias=LPDHCP_OPTION_SCOPE_INFO,pointer=ref}*(1))(2:{alias=DHCP_OPTION_SCOPE_INFO}(struct))
	{
		if o.ScopeInfo == nil {
			o.ScopeInfo = &dhcpm.OptionScopeInfo{}
		}
		if err := o.ScopeInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetAllOptionValuesV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetAllOptionValuesV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Values {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_ALL_OPTION_VALUES_PB}*(1))(3:{alias=DHCP_ALL_OPTION_VALUES_PB}(struct))
	{
		if o.Values != nil {
			_ptr_Values := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Values != nil {
					if err := o.Values.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.AllOptionValuesPB{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Values, _ptr_Values); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetAllOptionValuesV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Values {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_ALL_OPTION_VALUES_PB,pointer=ref}*(1))(3:{alias=DHCP_ALL_OPTION_VALUES_PB}(struct))
	{
		_ptr_Values := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Values == nil {
				o.Values = &dhcpm.AllOptionValuesPB{}
			}
			if err := o.Values.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_Values := func(ptr interface{}) { o.Values = *ptr.(**dhcpm.AllOptionValuesPB) }
		if err := w.ReadPointer(&o.Values, _s_Values, _ptr_Values); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetAllOptionValuesV4Request structure represents the R_DhcpV4GetAllOptionValues operation request
type GetAllOptionValuesV4Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// Flags: This is of type DWORD and specifies that the option value is set for a specific
	// or default vendor class.
	//
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                        |                                                                                  |
	//	|                 VALUE                  |                                     MEANING                                      |
	//	|                                        |                                                                                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_DEFAULT 0x00000000   | Option definition is set for the default vendor class.                           |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| DHCP_FLAGS_OPTION_IS_VENDOR 0x00000003 | If a bitwise AND operation with this bitmask yields a nonzero value, it          |
	//	|                                        | indicates that the option definition is set for a specific vendor class.         |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	Flags uint32 `idl:"name:Flags" json:"flags"`
	// ScopeInfo: This is a pointer of type DHCP_OPTION_SCOPE_INFO structure (section 2.2.1.2.41)
	// that contains information describing the DHCPv4 scope for which this option value
	// is set. This value contains the default, server, scope, multicast scope, or IPv4
	// reservation level at which the option values are set.
	ScopeInfo *dhcpm.OptionScopeInfo `idl:"name:ScopeInfo" json:"scope_info"`
}

func (o *GetAllOptionValuesV4Request) xxx_ToOp(ctx context.Context, op *xxx_GetAllOptionValuesV4Operation) *xxx_GetAllOptionValuesV4Operation {
	if op == nil {
		op = &xxx_GetAllOptionValuesV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Flags = o.Flags
	op.ScopeInfo = o.ScopeInfo
	return op
}

func (o *GetAllOptionValuesV4Request) xxx_FromOp(ctx context.Context, op *xxx_GetAllOptionValuesV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Flags = op.Flags
	o.ScopeInfo = op.ScopeInfo
}
func (o *GetAllOptionValuesV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetAllOptionValuesV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetAllOptionValuesV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetAllOptionValuesV4Response structure represents the R_DhcpV4GetAllOptionValues operation response
type GetAllOptionValuesV4Response struct {
	// Values: This is a pointer of type LPDHCP_ALL_OPTIONS_VALUES_PB (section 2.2.1.2.109)
	// that contains all the policy option values at server or scope level.
	Values *dhcpm.AllOptionValuesPB `idl:"name:Values" json:"values"`
	// Return: The R_DhcpV4GetAllOptionValues return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetAllOptionValuesV4Response) xxx_ToOp(ctx context.Context, op *xxx_GetAllOptionValuesV4Operation) *xxx_GetAllOptionValuesV4Operation {
	if op == nil {
		op = &xxx_GetAllOptionValuesV4Operation{}
	}
	if o == nil {
		return op
	}
	op.Values = o.Values
	op.Return = o.Return
	return op
}

func (o *GetAllOptionValuesV4Response) xxx_FromOp(ctx context.Context, op *xxx_GetAllOptionValuesV4Operation) {
	if o == nil {
		return
	}
	o.Values = op.Values
	o.Return = op.Return
}
func (o *GetAllOptionValuesV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetAllOptionValuesV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetAllOptionValuesV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_QueryPolicyEnforcementV4Operation structure represents the R_DhcpV4QueryPolicyEnforcement operation
type xxx_QueryPolicyEnforcementV4Operation struct {
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	ServerPolicy    bool   `idl:"name:ServerPolicy" json:"server_policy"`
	SubnetAddress   uint32 `idl:"name:SubnetAddress" json:"subnet_address"`
	Enabled         bool   `idl:"name:Enabled" json:"enabled"`
	Return          uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_QueryPolicyEnforcementV4Operation) OpNum() int { return 106 }

func (o *xxx_QueryPolicyEnforcementV4Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpV4QueryPolicyEnforcement"
}

func (o *xxx_QueryPolicyEnforcementV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryPolicyEnforcementV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ServerPolicy {in} (1:{alias=BOOL}(int32))
	{
		if !o.ServerPolicy {
			if err := w.WriteData(int32(0)); err != nil {
				return err
			}
		} else {
			if err := w.WriteData(int32(1)); err != nil {
				return err
			}
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.SubnetAddress); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryPolicyEnforcementV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ServerPolicy {in} (1:{alias=BOOL}(int32))
	{
		var _bServerPolicy int32
		if err := w.ReadData(&_bServerPolicy); err != nil {
			return err
		}
		o.ServerPolicy = _bServerPolicy != 0
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.SubnetAddress); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryPolicyEnforcementV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryPolicyEnforcementV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Enabled {out} (1:{pointer=ref}*(1))(2:{alias=BOOL}(int32))
	{
		if !o.Enabled {
			if err := w.WriteData(int32(0)); err != nil {
				return err
			}
		} else {
			if err := w.WriteData(int32(1)); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryPolicyEnforcementV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Enabled {out} (1:{pointer=ref}*(1))(2:{alias=BOOL}(int32))
	{
		var _bEnabled int32
		if err := w.ReadData(&_bEnabled); err != nil {
			return err
		}
		o.Enabled = _bEnabled != 0
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// QueryPolicyEnforcementV4Request structure represents the R_DhcpV4QueryPolicyEnforcement operation request
type QueryPolicyEnforcementV4Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// ServerPolicy: This Boolean type indicates if the policy enforcement state of the
	// server can be returned.
	ServerPolicy bool `idl:"name:ServerPolicy" json:"server_policy"`
	// SubnetAddress: This is of type DHCP_IP_ADDRESS (section 2.2.1.2.1), which contains
	// the IPv4 subnet ID for which the policy enforcement state can be returned. This parameter
	// is ignored if ServerPolicy parameter is TRUE.
	SubnetAddress uint32 `idl:"name:SubnetAddress" json:"subnet_address"`
}

func (o *QueryPolicyEnforcementV4Request) xxx_ToOp(ctx context.Context, op *xxx_QueryPolicyEnforcementV4Operation) *xxx_QueryPolicyEnforcementV4Operation {
	if op == nil {
		op = &xxx_QueryPolicyEnforcementV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.ServerPolicy = o.ServerPolicy
	op.SubnetAddress = o.SubnetAddress
	return op
}

func (o *QueryPolicyEnforcementV4Request) xxx_FromOp(ctx context.Context, op *xxx_QueryPolicyEnforcementV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.ServerPolicy = op.ServerPolicy
	o.SubnetAddress = op.SubnetAddress
}
func (o *QueryPolicyEnforcementV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *QueryPolicyEnforcementV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryPolicyEnforcementV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// QueryPolicyEnforcementV4Response structure represents the R_DhcpV4QueryPolicyEnforcement operation response
type QueryPolicyEnforcementV4Response struct {
	// Enabled: This out parameter is a pointer to a Boolean type and indicates the state
	// of policy enforcement. The memory for this must be allocated by the caller.
	Enabled bool `idl:"name:Enabled" json:"enabled"`
	// Return: The R_DhcpV4QueryPolicyEnforcement return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *QueryPolicyEnforcementV4Response) xxx_ToOp(ctx context.Context, op *xxx_QueryPolicyEnforcementV4Operation) *xxx_QueryPolicyEnforcementV4Operation {
	if op == nil {
		op = &xxx_QueryPolicyEnforcementV4Operation{}
	}
	if o == nil {
		return op
	}
	op.Enabled = o.Enabled
	op.Return = o.Return
	return op
}

func (o *QueryPolicyEnforcementV4Response) xxx_FromOp(ctx context.Context, op *xxx_QueryPolicyEnforcementV4Operation) {
	if o == nil {
		return
	}
	o.Enabled = op.Enabled
	o.Return = op.Return
}
func (o *QueryPolicyEnforcementV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *QueryPolicyEnforcementV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryPolicyEnforcementV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetPolicyEnforcementV4Operation structure represents the R_DhcpV4SetPolicyEnforcement operation
type xxx_SetPolicyEnforcementV4Operation struct {
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	ServerPolicy    bool   `idl:"name:ServerPolicy" json:"server_policy"`
	SubnetAddress   uint32 `idl:"name:SubnetAddress" json:"subnet_address"`
	Enable          bool   `idl:"name:Enable" json:"enable"`
	Return          uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_SetPolicyEnforcementV4Operation) OpNum() int { return 107 }

func (o *xxx_SetPolicyEnforcementV4Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpV4SetPolicyEnforcement"
}

func (o *xxx_SetPolicyEnforcementV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetPolicyEnforcementV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ServerPolicy {in} (1:{alias=BOOL}(int32))
	{
		if !o.ServerPolicy {
			if err := w.WriteData(int32(0)); err != nil {
				return err
			}
		} else {
			if err := w.WriteData(int32(1)); err != nil {
				return err
			}
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.SubnetAddress); err != nil {
			return err
		}
	}
	// Enable {in} (1:{alias=BOOL}(int32))
	{
		if !o.Enable {
			if err := w.WriteData(int32(0)); err != nil {
				return err
			}
		} else {
			if err := w.WriteData(int32(1)); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_SetPolicyEnforcementV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ServerPolicy {in} (1:{alias=BOOL}(int32))
	{
		var _bServerPolicy int32
		if err := w.ReadData(&_bServerPolicy); err != nil {
			return err
		}
		o.ServerPolicy = _bServerPolicy != 0
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.SubnetAddress); err != nil {
			return err
		}
	}
	// Enable {in} (1:{alias=BOOL}(int32))
	{
		var _bEnable int32
		if err := w.ReadData(&_bEnable); err != nil {
			return err
		}
		o.Enable = _bEnable != 0
	}
	return nil
}

func (o *xxx_SetPolicyEnforcementV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetPolicyEnforcementV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetPolicyEnforcementV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetPolicyEnforcementV4Request structure represents the R_DhcpV4SetPolicyEnforcement operation request
type SetPolicyEnforcementV4Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// ServerPolicy: This Boolean type indicates if the policy enforcement state of the
	// server can be set.
	ServerPolicy bool `idl:"name:ServerPolicy" json:"server_policy"`
	// SubnetAddress: This is of type DHCP_IP_ADDRESS structure (section 2.2.1.2.1), which
	// contains the IPv4 subnet ID for which the policy enforcement state can be returned.
	// This parameter is ignored if the ServerPolicy parameter is TRUE.
	SubnetAddress uint32 `idl:"name:SubnetAddress" json:"subnet_address"`
	// Enable: This Boolean type parameter specifies the value to set for policy enforcement.
	Enable bool `idl:"name:Enable" json:"enable"`
}

func (o *SetPolicyEnforcementV4Request) xxx_ToOp(ctx context.Context, op *xxx_SetPolicyEnforcementV4Operation) *xxx_SetPolicyEnforcementV4Operation {
	if op == nil {
		op = &xxx_SetPolicyEnforcementV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.ServerPolicy = o.ServerPolicy
	op.SubnetAddress = o.SubnetAddress
	op.Enable = o.Enable
	return op
}

func (o *SetPolicyEnforcementV4Request) xxx_FromOp(ctx context.Context, op *xxx_SetPolicyEnforcementV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.ServerPolicy = op.ServerPolicy
	o.SubnetAddress = op.SubnetAddress
	o.Enable = op.Enable
}
func (o *SetPolicyEnforcementV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetPolicyEnforcementV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetPolicyEnforcementV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetPolicyEnforcementV4Response structure represents the R_DhcpV4SetPolicyEnforcement operation response
type SetPolicyEnforcementV4Response struct {
	// Return: The R_DhcpV4SetPolicyEnforcement return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetPolicyEnforcementV4Response) xxx_ToOp(ctx context.Context, op *xxx_SetPolicyEnforcementV4Operation) *xxx_SetPolicyEnforcementV4Operation {
	if op == nil {
		op = &xxx_SetPolicyEnforcementV4Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetPolicyEnforcementV4Response) xxx_FromOp(ctx context.Context, op *xxx_SetPolicyEnforcementV4Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetPolicyEnforcementV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetPolicyEnforcementV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetPolicyEnforcementV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CreatePolicyV4Operation structure represents the R_DhcpV4CreatePolicy operation
type xxx_CreatePolicyV4Operation struct {
	ServerIPAddress string        `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Policy          *dhcpm.Policy `idl:"name:pPolicy" json:"policy"`
	Return          uint32        `idl:"name:Return" json:"return"`
}

func (o *xxx_CreatePolicyV4Operation) OpNum() int { return 108 }

func (o *xxx_CreatePolicyV4Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpV4CreatePolicy" }

func (o *xxx_CreatePolicyV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreatePolicyV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// pPolicy {in} (1:{alias=LPDHCP_POLICY}*(1))(2:{alias=DHCP_POLICY}(struct))
	{
		if o.Policy != nil {
			if err := o.Policy.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.Policy{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreatePolicyV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// pPolicy {in} (1:{alias=LPDHCP_POLICY,pointer=ref}*(1))(2:{alias=DHCP_POLICY}(struct))
	{
		if o.Policy == nil {
			o.Policy = &dhcpm.Policy{}
		}
		if err := o.Policy.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreatePolicyV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreatePolicyV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreatePolicyV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CreatePolicyV4Request structure represents the R_DhcpV4CreatePolicy operation request
type CreatePolicyV4Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// pPolicy: This is a pointer to a type DHCP_POLICY (section 2.2.1.2.110) and contains
	// the members of the policy to be created.
	Policy *dhcpm.Policy `idl:"name:pPolicy" json:"policy"`
}

func (o *CreatePolicyV4Request) xxx_ToOp(ctx context.Context, op *xxx_CreatePolicyV4Operation) *xxx_CreatePolicyV4Operation {
	if op == nil {
		op = &xxx_CreatePolicyV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Policy = o.Policy
	return op
}

func (o *CreatePolicyV4Request) xxx_FromOp(ctx context.Context, op *xxx_CreatePolicyV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Policy = op.Policy
}
func (o *CreatePolicyV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *CreatePolicyV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreatePolicyV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CreatePolicyV4Response structure represents the R_DhcpV4CreatePolicy operation response
type CreatePolicyV4Response struct {
	// Return: The R_DhcpV4CreatePolicy return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CreatePolicyV4Response) xxx_ToOp(ctx context.Context, op *xxx_CreatePolicyV4Operation) *xxx_CreatePolicyV4Operation {
	if op == nil {
		op = &xxx_CreatePolicyV4Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *CreatePolicyV4Response) xxx_FromOp(ctx context.Context, op *xxx_CreatePolicyV4Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *CreatePolicyV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *CreatePolicyV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreatePolicyV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetPolicyV4Operation structure represents the R_DhcpV4GetPolicy operation
type xxx_GetPolicyV4Operation struct {
	ServerIPAddress string        `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	ServerPolicy    bool          `idl:"name:ServerPolicy" json:"server_policy"`
	SubnetAddress   uint32        `idl:"name:SubnetAddress" json:"subnet_address"`
	PolicyName      string        `idl:"name:PolicyName;string;pointer:unique" json:"policy_name"`
	Policy          *dhcpm.Policy `idl:"name:Policy" json:"policy"`
	Return          uint32        `idl:"name:Return" json:"return"`
}

func (o *xxx_GetPolicyV4Operation) OpNum() int { return 109 }

func (o *xxx_GetPolicyV4Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpV4GetPolicy" }

func (o *xxx_GetPolicyV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetPolicyV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ServerPolicy {in} (1:{alias=BOOL}(int32))
	{
		if !o.ServerPolicy {
			if err := w.WriteData(int32(0)); err != nil {
				return err
			}
		} else {
			if err := w.WriteData(int32(1)); err != nil {
				return err
			}
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.SubnetAddress); err != nil {
			return err
		}
	}
	// PolicyName {in} (1:{string, pointer=unique, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.PolicyName != "" {
			_ptr_PolicyName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.PolicyName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.PolicyName, _ptr_PolicyName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetPolicyV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ServerPolicy {in} (1:{alias=BOOL}(int32))
	{
		var _bServerPolicy int32
		if err := w.ReadData(&_bServerPolicy); err != nil {
			return err
		}
		o.ServerPolicy = _bServerPolicy != 0
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.SubnetAddress); err != nil {
			return err
		}
	}
	// PolicyName {in} (1:{string, pointer=unique, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_PolicyName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.PolicyName); err != nil {
				return err
			}
			return nil
		})
		_s_PolicyName := func(ptr interface{}) { o.PolicyName = *ptr.(*string) }
		if err := w.ReadPointer(&o.PolicyName, _s_PolicyName, _ptr_PolicyName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetPolicyV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetPolicyV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Policy {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_POLICY}*(1))(3:{alias=DHCP_POLICY}(struct))
	{
		if o.Policy != nil {
			_ptr_Policy := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Policy != nil {
					if err := o.Policy.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.Policy{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Policy, _ptr_Policy); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetPolicyV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Policy {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_POLICY,pointer=ref}*(1))(3:{alias=DHCP_POLICY}(struct))
	{
		_ptr_Policy := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Policy == nil {
				o.Policy = &dhcpm.Policy{}
			}
			if err := o.Policy.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_Policy := func(ptr interface{}) { o.Policy = *ptr.(**dhcpm.Policy) }
		if err := w.ReadPointer(&o.Policy, _s_Policy, _ptr_Policy); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetPolicyV4Request structure represents the R_DhcpV4GetPolicy operation request
type GetPolicyV4Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// ServerPolicy: This is of type BOOL and indicates whether the server level policy
	// or scope level policy is being requested.
	ServerPolicy bool `idl:"name:ServerPolicy" json:"server_policy"`
	// SubnetAddress: This is of type DHCP_IP_ADDRESS (section 2.2.1.2.1) and identifies
	// the IPv4 subnet from which the policy is being requested.
	SubnetAddress uint32 `idl:"name:SubnetAddress" json:"subnet_address"`
	// PolicyName: A pointer to a null-terminated Unicode string that contains the name
	// of the policy requested.
	PolicyName string `idl:"name:PolicyName;string;pointer:unique" json:"policy_name"`
}

func (o *GetPolicyV4Request) xxx_ToOp(ctx context.Context, op *xxx_GetPolicyV4Operation) *xxx_GetPolicyV4Operation {
	if op == nil {
		op = &xxx_GetPolicyV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.ServerPolicy = o.ServerPolicy
	op.SubnetAddress = o.SubnetAddress
	op.PolicyName = o.PolicyName
	return op
}

func (o *GetPolicyV4Request) xxx_FromOp(ctx context.Context, op *xxx_GetPolicyV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.ServerPolicy = op.ServerPolicy
	o.SubnetAddress = op.SubnetAddress
	o.PolicyName = op.PolicyName
}
func (o *GetPolicyV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetPolicyV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetPolicyV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetPolicyV4Response structure represents the R_DhcpV4GetPolicy operation response
type GetPolicyV4Response struct {
	// Policy: This out parameter is a pointer of type LPDHCP_POLICY that contains the policy
	// data for the requested policy.
	Policy *dhcpm.Policy `idl:"name:Policy" json:"policy"`
	// Return: The R_DhcpV4GetPolicy return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetPolicyV4Response) xxx_ToOp(ctx context.Context, op *xxx_GetPolicyV4Operation) *xxx_GetPolicyV4Operation {
	if op == nil {
		op = &xxx_GetPolicyV4Operation{}
	}
	if o == nil {
		return op
	}
	op.Policy = o.Policy
	op.Return = o.Return
	return op
}

func (o *GetPolicyV4Response) xxx_FromOp(ctx context.Context, op *xxx_GetPolicyV4Operation) {
	if o == nil {
		return
	}
	o.Policy = op.Policy
	o.Return = op.Return
}
func (o *GetPolicyV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetPolicyV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetPolicyV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetPolicyV4Operation structure represents the R_DhcpV4SetPolicy operation
type xxx_SetPolicyV4Operation struct {
	ServerIPAddress string        `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	FieldsModified  uint32        `idl:"name:FieldsModified" json:"fields_modified"`
	ServerPolicy    bool          `idl:"name:ServerPolicy" json:"server_policy"`
	SubnetAddress   uint32        `idl:"name:SubnetAddress" json:"subnet_address"`
	PolicyName      string        `idl:"name:PolicyName;string;pointer:unique" json:"policy_name"`
	Policy          *dhcpm.Policy `idl:"name:Policy" json:"policy"`
	Return          uint32        `idl:"name:Return" json:"return"`
}

func (o *xxx_SetPolicyV4Operation) OpNum() int { return 110 }

func (o *xxx_SetPolicyV4Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpV4SetPolicy" }

func (o *xxx_SetPolicyV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetPolicyV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// FieldsModified {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.FieldsModified); err != nil {
			return err
		}
	}
	// ServerPolicy {in} (1:{alias=BOOL}(int32))
	{
		if !o.ServerPolicy {
			if err := w.WriteData(int32(0)); err != nil {
				return err
			}
		} else {
			if err := w.WriteData(int32(1)); err != nil {
				return err
			}
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.SubnetAddress); err != nil {
			return err
		}
	}
	// PolicyName {in} (1:{string, pointer=unique, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.PolicyName != "" {
			_ptr_PolicyName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.PolicyName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.PolicyName, _ptr_PolicyName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Policy {in} (1:{alias=LPDHCP_POLICY}*(1))(2:{alias=DHCP_POLICY}(struct))
	{
		if o.Policy != nil {
			if err := o.Policy.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.Policy{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetPolicyV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// FieldsModified {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.FieldsModified); err != nil {
			return err
		}
	}
	// ServerPolicy {in} (1:{alias=BOOL}(int32))
	{
		var _bServerPolicy int32
		if err := w.ReadData(&_bServerPolicy); err != nil {
			return err
		}
		o.ServerPolicy = _bServerPolicy != 0
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.SubnetAddress); err != nil {
			return err
		}
	}
	// PolicyName {in} (1:{string, pointer=unique, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_PolicyName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.PolicyName); err != nil {
				return err
			}
			return nil
		})
		_s_PolicyName := func(ptr interface{}) { o.PolicyName = *ptr.(*string) }
		if err := w.ReadPointer(&o.PolicyName, _s_PolicyName, _ptr_PolicyName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Policy {in} (1:{alias=LPDHCP_POLICY,pointer=ref}*(1))(2:{alias=DHCP_POLICY}(struct))
	{
		if o.Policy == nil {
			o.Policy = &dhcpm.Policy{}
		}
		if err := o.Policy.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetPolicyV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetPolicyV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetPolicyV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetPolicyV4Request structure represents the R_DhcpV4SetPolicy operation request
type SetPolicyV4Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// FieldsModified: This is of type DWORD and contains the bit mask that specifies the
	// fields to be modified as specified in the DHCP_POLICY_FIELDS_TO_UPDATE enumeration
	// (section 2.2.1.1.21).
	FieldsModified uint32 `idl:"name:FieldsModified" json:"fields_modified"`
	// ServerPolicy: This is of type BOOL and specifies whether the server policy or scope
	// policy is being modified.
	ServerPolicy bool `idl:"name:ServerPolicy" json:"server_policy"`
	// SubnetAddress: This is of type DHCP_IP_ADDRESS data type (section 2.2.1.2.1) and
	// identifies the IPv4 subnet from which the policy is being modified.
	SubnetAddress uint32 `idl:"name:SubnetAddress" json:"subnet_address"`
	// PolicyName: A pointer to a null-terminated Unicode string that contains the name
	// of the policy requested.
	PolicyName string `idl:"name:PolicyName;string;pointer:unique" json:"policy_name"`
	// Policy: This is a pointer to a type DHCP_POLICY structure (section 2.2.1.2.110) that
	// contains the policy data to be modified.
	Policy *dhcpm.Policy `idl:"name:Policy" json:"policy"`
}

func (o *SetPolicyV4Request) xxx_ToOp(ctx context.Context, op *xxx_SetPolicyV4Operation) *xxx_SetPolicyV4Operation {
	if op == nil {
		op = &xxx_SetPolicyV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.FieldsModified = o.FieldsModified
	op.ServerPolicy = o.ServerPolicy
	op.SubnetAddress = o.SubnetAddress
	op.PolicyName = o.PolicyName
	op.Policy = o.Policy
	return op
}

func (o *SetPolicyV4Request) xxx_FromOp(ctx context.Context, op *xxx_SetPolicyV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.FieldsModified = op.FieldsModified
	o.ServerPolicy = op.ServerPolicy
	o.SubnetAddress = op.SubnetAddress
	o.PolicyName = op.PolicyName
	o.Policy = op.Policy
}
func (o *SetPolicyV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetPolicyV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetPolicyV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetPolicyV4Response structure represents the R_DhcpV4SetPolicy operation response
type SetPolicyV4Response struct {
	// Return: The R_DhcpV4SetPolicy return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetPolicyV4Response) xxx_ToOp(ctx context.Context, op *xxx_SetPolicyV4Operation) *xxx_SetPolicyV4Operation {
	if op == nil {
		op = &xxx_SetPolicyV4Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetPolicyV4Response) xxx_FromOp(ctx context.Context, op *xxx_SetPolicyV4Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetPolicyV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetPolicyV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetPolicyV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_DeletePolicyV4Operation structure represents the R_DhcpV4DeletePolicy operation
type xxx_DeletePolicyV4Operation struct {
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	ServerPolicy    bool   `idl:"name:ServerPolicy" json:"server_policy"`
	SubnetAddress   uint32 `idl:"name:SubnetAddress" json:"subnet_address"`
	PolicyName      string `idl:"name:PolicyName;string;pointer:unique" json:"policy_name"`
	Return          uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_DeletePolicyV4Operation) OpNum() int { return 111 }

func (o *xxx_DeletePolicyV4Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpV4DeletePolicy" }

func (o *xxx_DeletePolicyV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeletePolicyV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ServerPolicy {in} (1:{alias=BOOL}(int32))
	{
		if !o.ServerPolicy {
			if err := w.WriteData(int32(0)); err != nil {
				return err
			}
		} else {
			if err := w.WriteData(int32(1)); err != nil {
				return err
			}
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.SubnetAddress); err != nil {
			return err
		}
	}
	// PolicyName {in} (1:{string, pointer=unique, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.PolicyName != "" {
			_ptr_PolicyName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.PolicyName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.PolicyName, _ptr_PolicyName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeletePolicyV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ServerPolicy {in} (1:{alias=BOOL}(int32))
	{
		var _bServerPolicy int32
		if err := w.ReadData(&_bServerPolicy); err != nil {
			return err
		}
		o.ServerPolicy = _bServerPolicy != 0
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.SubnetAddress); err != nil {
			return err
		}
	}
	// PolicyName {in} (1:{string, pointer=unique, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_PolicyName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.PolicyName); err != nil {
				return err
			}
			return nil
		})
		_s_PolicyName := func(ptr interface{}) { o.PolicyName = *ptr.(*string) }
		if err := w.ReadPointer(&o.PolicyName, _s_PolicyName, _ptr_PolicyName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeletePolicyV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeletePolicyV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeletePolicyV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// DeletePolicyV4Request structure represents the R_DhcpV4DeletePolicy operation request
type DeletePolicyV4Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// ServerPolicy: This is of type BOOL and indicates whether the server level policy
	// or scope level policy is being deleted.
	ServerPolicy bool `idl:"name:ServerPolicy" json:"server_policy"`
	// SubnetAddress: This is of type DHCP_IP_ADDRESS data type (section 2.2.1.2.1) that
	// identifies the IPv4 subnet from which the policy is being deleted.
	SubnetAddress uint32 `idl:"name:SubnetAddress" json:"subnet_address"`
	// PolicyName: A pointer to a null-terminated Unicode string that contains the name
	// of the policy deleted.
	PolicyName string `idl:"name:PolicyName;string;pointer:unique" json:"policy_name"`
}

func (o *DeletePolicyV4Request) xxx_ToOp(ctx context.Context, op *xxx_DeletePolicyV4Operation) *xxx_DeletePolicyV4Operation {
	if op == nil {
		op = &xxx_DeletePolicyV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.ServerPolicy = o.ServerPolicy
	op.SubnetAddress = o.SubnetAddress
	op.PolicyName = o.PolicyName
	return op
}

func (o *DeletePolicyV4Request) xxx_FromOp(ctx context.Context, op *xxx_DeletePolicyV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.ServerPolicy = op.ServerPolicy
	o.SubnetAddress = op.SubnetAddress
	o.PolicyName = op.PolicyName
}
func (o *DeletePolicyV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *DeletePolicyV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeletePolicyV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// DeletePolicyV4Response structure represents the R_DhcpV4DeletePolicy operation response
type DeletePolicyV4Response struct {
	// Return: The R_DhcpV4DeletePolicy return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *DeletePolicyV4Response) xxx_ToOp(ctx context.Context, op *xxx_DeletePolicyV4Operation) *xxx_DeletePolicyV4Operation {
	if op == nil {
		op = &xxx_DeletePolicyV4Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *DeletePolicyV4Response) xxx_FromOp(ctx context.Context, op *xxx_DeletePolicyV4Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *DeletePolicyV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *DeletePolicyV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeletePolicyV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumPoliciesV4Operation structure represents the R_DhcpV4EnumPolicies operation
type xxx_EnumPoliciesV4Operation struct {
	ServerIPAddress  string             `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Resume           uint32             `idl:"name:ResumeHandle" json:"resume"`
	PreferredMaximum uint32             `idl:"name:PreferredMaximum" json:"preferred_maximum"`
	ServerPolicy     bool               `idl:"name:ServerPolicy" json:"server_policy"`
	SubnetAddress    uint32             `idl:"name:SubnetAddress" json:"subnet_address"`
	EnumInfo         *dhcpm.PolicyArray `idl:"name:EnumInfo" json:"enum_info"`
	ElementsRead     uint32             `idl:"name:ElementsRead" json:"elements_read"`
	ElementsTotal    uint32             `idl:"name:ElementsTotal" json:"elements_total"`
	Return           uint32             `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumPoliciesV4Operation) OpNum() int { return 112 }

func (o *xxx_EnumPoliciesV4Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpV4EnumPolicies" }

func (o *xxx_EnumPoliciesV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumPoliciesV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Resume); err != nil {
			return err
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PreferredMaximum); err != nil {
			return err
		}
	}
	// ServerPolicy {in} (1:{alias=BOOL}(int32))
	{
		if !o.ServerPolicy {
			if err := w.WriteData(int32(0)); err != nil {
				return err
			}
		} else {
			if err := w.WriteData(int32(1)); err != nil {
				return err
			}
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.SubnetAddress); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumPoliciesV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{alias=LPDWORD,pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Resume); err != nil {
			return err
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PreferredMaximum); err != nil {
			return err
		}
	}
	// ServerPolicy {in} (1:{alias=BOOL}(int32))
	{
		var _bServerPolicy int32
		if err := w.ReadData(&_bServerPolicy); err != nil {
			return err
		}
		o.ServerPolicy = _bServerPolicy != 0
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.SubnetAddress); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumPoliciesV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumPoliciesV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ResumeHandle {in, out} (1:{alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Resume); err != nil {
			return err
		}
	}
	// EnumInfo {out} (1:{alias=LPDHCP_POLICY_ARRAY}*(1))(2:{alias=DHCP_POLICY_ARRAY}(struct))
	{
		if o.EnumInfo != nil {
			if err := o.EnumInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.PolicyArray{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ElementsRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ElementsRead); err != nil {
			return err
		}
	}
	// ElementsTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ElementsTotal); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumPoliciesV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ResumeHandle {in, out} (1:{alias=LPDWORD,pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Resume); err != nil {
			return err
		}
	}
	// EnumInfo {out} (1:{alias=LPDHCP_POLICY_ARRAY,pointer=ref}*(1))(2:{alias=DHCP_POLICY_ARRAY}(struct))
	{
		if o.EnumInfo == nil {
			o.EnumInfo = &dhcpm.PolicyArray{}
		}
		if err := o.EnumInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ElementsRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ElementsRead); err != nil {
			return err
		}
	}
	// ElementsTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ElementsTotal); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumPoliciesV4Request structure represents the R_DhcpV4EnumPolicies operation request
type EnumPoliciesV4Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// ResumeHandle: This is a pointer of type DWORD (see DHCP_RESUME_HANDLE data type,
	// section 2.2.1.2.6) that identifies the enumeration operation. Initially, this value
	// MUST be set to zero, with a successful call returning the handle value used for subsequent
	// enumeration requests.
	Resume uint32 `idl:"name:ResumeHandle" json:"resume"`
	// PreferredMaximum: This is of type DWORD specifying the preferred maximum number of
	// policies to be returned. If the number of remaining unenumerated policies is less
	// than the value of this parameter, then all the policies for the DHCPv4 server or
	// for the specific subnet are returned. To retrieve all the policies on the DHCPv4
	// server or the specific subnet, 0xFFFFFFFF SHOULD be specified.
	PreferredMaximum uint32 `idl:"name:PreferredMaximum" json:"preferred_maximum"`
	// ServerPolicy: This is of type BOOL and indicates whether the server level policy
	// or scope level policy is being requested.
	ServerPolicy bool `idl:"name:ServerPolicy" json:"server_policy"`
	// SubnetAddress: This is of type DHCP_IP_ADDRESS data type (section 2.2.1.2.1) and
	// identifies the IPv4 subnet from which the policy is being requested.
	SubnetAddress uint32 `idl:"name:SubnetAddress" json:"subnet_address"`
}

func (o *EnumPoliciesV4Request) xxx_ToOp(ctx context.Context, op *xxx_EnumPoliciesV4Operation) *xxx_EnumPoliciesV4Operation {
	if op == nil {
		op = &xxx_EnumPoliciesV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Resume = o.Resume
	op.PreferredMaximum = o.PreferredMaximum
	op.ServerPolicy = o.ServerPolicy
	op.SubnetAddress = o.SubnetAddress
	return op
}

func (o *EnumPoliciesV4Request) xxx_FromOp(ctx context.Context, op *xxx_EnumPoliciesV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Resume = op.Resume
	o.PreferredMaximum = op.PreferredMaximum
	o.ServerPolicy = op.ServerPolicy
	o.SubnetAddress = op.SubnetAddress
}
func (o *EnumPoliciesV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumPoliciesV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumPoliciesV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumPoliciesV4Response structure represents the R_DhcpV4EnumPolicies operation response
type EnumPoliciesV4Response struct {
	// ResumeHandle: This is a pointer of type DWORD (see DHCP_RESUME_HANDLE data type,
	// section 2.2.1.2.6) that identifies the enumeration operation. Initially, this value
	// MUST be set to zero, with a successful call returning the handle value used for subsequent
	// enumeration requests.
	Resume uint32 `idl:"name:ResumeHandle" json:"resume"`
	// EnumInfo: This is a pointer of type LPDHCP_POLICY_ARRAY (section 2.2.1.2.111) in
	// which policy information is retrieved.
	EnumInfo *dhcpm.PolicyArray `idl:"name:EnumInfo" json:"enum_info"`
	// ElementsRead: This is a pointer to a DWORD value that specifies the number of policies
	// returned in the EnumInfo parameter. The caller MUST allocate memory for this parameter
	// that is equal to the size of the DWORD data type.
	ElementsRead uint32 `idl:"name:ElementsRead" json:"elements_read"`
	// ElementsTotal: This is a pointer to a DWORD value that specifies the number of policies
	// that have not yet been enumerated. The caller MUST allocate memory for this parameter
	// that is equal to the size of the DWORD data type.
	ElementsTotal uint32 `idl:"name:ElementsTotal" json:"elements_total"`
	// Return: The R_DhcpV4EnumPolicies return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumPoliciesV4Response) xxx_ToOp(ctx context.Context, op *xxx_EnumPoliciesV4Operation) *xxx_EnumPoliciesV4Operation {
	if op == nil {
		op = &xxx_EnumPoliciesV4Operation{}
	}
	if o == nil {
		return op
	}
	op.Resume = o.Resume
	op.EnumInfo = o.EnumInfo
	op.ElementsRead = o.ElementsRead
	op.ElementsTotal = o.ElementsTotal
	op.Return = o.Return
	return op
}

func (o *EnumPoliciesV4Response) xxx_FromOp(ctx context.Context, op *xxx_EnumPoliciesV4Operation) {
	if o == nil {
		return
	}
	o.Resume = op.Resume
	o.EnumInfo = op.EnumInfo
	o.ElementsRead = op.ElementsRead
	o.ElementsTotal = op.ElementsTotal
	o.Return = op.Return
}
func (o *EnumPoliciesV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumPoliciesV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumPoliciesV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddPolicyRangeV4Operation structure represents the R_DhcpV4AddPolicyRange operation
type xxx_AddPolicyRangeV4Operation struct {
	ServerIPAddress string         `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	SubnetAddress   uint32         `idl:"name:SubnetAddress" json:"subnet_address"`
	PolicyName      string         `idl:"name:PolicyName;string;pointer:unique" json:"policy_name"`
	Range           *dhcpm.IPRange `idl:"name:Range" json:"range"`
	Return          uint32         `idl:"name:Return" json:"return"`
}

func (o *xxx_AddPolicyRangeV4Operation) OpNum() int { return 113 }

func (o *xxx_AddPolicyRangeV4Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpV4AddPolicyRange" }

func (o *xxx_AddPolicyRangeV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddPolicyRangeV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.SubnetAddress); err != nil {
			return err
		}
	}
	// PolicyName {in} (1:{string, pointer=unique, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.PolicyName != "" {
			_ptr_PolicyName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.PolicyName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.PolicyName, _ptr_PolicyName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Range {in} (1:{alias=LPDHCP_IP_RANGE}*(1))(2:{alias=DHCP_IP_RANGE}(struct))
	{
		if o.Range != nil {
			if err := o.Range.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.IPRange{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_AddPolicyRangeV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.SubnetAddress); err != nil {
			return err
		}
	}
	// PolicyName {in} (1:{string, pointer=unique, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_PolicyName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.PolicyName); err != nil {
				return err
			}
			return nil
		})
		_s_PolicyName := func(ptr interface{}) { o.PolicyName = *ptr.(*string) }
		if err := w.ReadPointer(&o.PolicyName, _s_PolicyName, _ptr_PolicyName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Range {in} (1:{alias=LPDHCP_IP_RANGE,pointer=ref}*(1))(2:{alias=DHCP_IP_RANGE}(struct))
	{
		if o.Range == nil {
			o.Range = &dhcpm.IPRange{}
		}
		if err := o.Range.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddPolicyRangeV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddPolicyRangeV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddPolicyRangeV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddPolicyRangeV4Request structure represents the R_DhcpV4AddPolicyRange operation request
type AddPolicyRangeV4Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// SubnetAddress: This is of type DHCP_IP_ADDRESS structure (section 2.2.1.2.1) that
	// contains the IPv4 subnet ID for which the policy is being set.
	SubnetAddress uint32 `idl:"name:SubnetAddress" json:"subnet_address"`
	// PolicyName: A pointer to a null-terminated Unicode string that contains the name
	// of the policy inside the subnet identified by the SubnetAddress parameter for which
	// the IP address range is being set.
	PolicyName string `idl:"name:PolicyName;string;pointer:unique" json:"policy_name"`
	// Range: This is a pointer to a type DHCP_IP_RANGE structure (section 2.2.1.2.31) that
	// specifies the IP address range to be added to the policy.
	Range *dhcpm.IPRange `idl:"name:Range" json:"range"`
}

func (o *AddPolicyRangeV4Request) xxx_ToOp(ctx context.Context, op *xxx_AddPolicyRangeV4Operation) *xxx_AddPolicyRangeV4Operation {
	if op == nil {
		op = &xxx_AddPolicyRangeV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.SubnetAddress = o.SubnetAddress
	op.PolicyName = o.PolicyName
	op.Range = o.Range
	return op
}

func (o *AddPolicyRangeV4Request) xxx_FromOp(ctx context.Context, op *xxx_AddPolicyRangeV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.SubnetAddress = op.SubnetAddress
	o.PolicyName = op.PolicyName
	o.Range = op.Range
}
func (o *AddPolicyRangeV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *AddPolicyRangeV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddPolicyRangeV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddPolicyRangeV4Response structure represents the R_DhcpV4AddPolicyRange operation response
type AddPolicyRangeV4Response struct {
	// Return: The R_DhcpV4AddPolicyRange return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddPolicyRangeV4Response) xxx_ToOp(ctx context.Context, op *xxx_AddPolicyRangeV4Operation) *xxx_AddPolicyRangeV4Operation {
	if op == nil {
		op = &xxx_AddPolicyRangeV4Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *AddPolicyRangeV4Response) xxx_FromOp(ctx context.Context, op *xxx_AddPolicyRangeV4Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *AddPolicyRangeV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *AddPolicyRangeV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddPolicyRangeV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_RemovePolicyRangeV4Operation structure represents the R_DhcpV4RemovePolicyRange operation
type xxx_RemovePolicyRangeV4Operation struct {
	ServerIPAddress string         `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	SubnetAddress   uint32         `idl:"name:SubnetAddress" json:"subnet_address"`
	PolicyName      string         `idl:"name:PolicyName;string;pointer:unique" json:"policy_name"`
	Range           *dhcpm.IPRange `idl:"name:Range" json:"range"`
	Return          uint32         `idl:"name:Return" json:"return"`
}

func (o *xxx_RemovePolicyRangeV4Operation) OpNum() int { return 114 }

func (o *xxx_RemovePolicyRangeV4Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpV4RemovePolicyRange"
}

func (o *xxx_RemovePolicyRangeV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemovePolicyRangeV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.SubnetAddress); err != nil {
			return err
		}
	}
	// PolicyName {in} (1:{string, pointer=unique, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.PolicyName != "" {
			_ptr_PolicyName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.PolicyName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.PolicyName, _ptr_PolicyName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Range {in} (1:{alias=LPDHCP_IP_RANGE}*(1))(2:{alias=DHCP_IP_RANGE}(struct))
	{
		if o.Range != nil {
			if err := o.Range.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.IPRange{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_RemovePolicyRangeV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.SubnetAddress); err != nil {
			return err
		}
	}
	// PolicyName {in} (1:{string, pointer=unique, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_PolicyName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.PolicyName); err != nil {
				return err
			}
			return nil
		})
		_s_PolicyName := func(ptr interface{}) { o.PolicyName = *ptr.(*string) }
		if err := w.ReadPointer(&o.PolicyName, _s_PolicyName, _ptr_PolicyName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Range {in} (1:{alias=LPDHCP_IP_RANGE,pointer=ref}*(1))(2:{alias=DHCP_IP_RANGE}(struct))
	{
		if o.Range == nil {
			o.Range = &dhcpm.IPRange{}
		}
		if err := o.Range.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemovePolicyRangeV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemovePolicyRangeV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RemovePolicyRangeV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// RemovePolicyRangeV4Request structure represents the R_DhcpV4RemovePolicyRange operation request
type RemovePolicyRangeV4Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// SubnetAddress: This is of type DHCP_IP_ADDRESS (section 2.2.1.2.1) that contains
	// the IPv4 subnet ID that contains the policy identified by the PolicyName parameter.
	SubnetAddress uint32 `idl:"name:SubnetAddress" json:"subnet_address"`
	// PolicyName: A pointer to a null-terminated Unicode string that contains the name
	// of the policy inside the subnet identified by the SubnetAddress parameter from which
	// the IP address range is being deleted.
	PolicyName string `idl:"name:PolicyName;string;pointer:unique" json:"policy_name"`
	// Range: This is a pointer to a structure of type DHCP_IP_RANGE (section 2.2.1.2.31)
	// that specifies the IP address range to be deleted from the policy.
	Range *dhcpm.IPRange `idl:"name:Range" json:"range"`
}

func (o *RemovePolicyRangeV4Request) xxx_ToOp(ctx context.Context, op *xxx_RemovePolicyRangeV4Operation) *xxx_RemovePolicyRangeV4Operation {
	if op == nil {
		op = &xxx_RemovePolicyRangeV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.SubnetAddress = o.SubnetAddress
	op.PolicyName = o.PolicyName
	op.Range = o.Range
	return op
}

func (o *RemovePolicyRangeV4Request) xxx_FromOp(ctx context.Context, op *xxx_RemovePolicyRangeV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.SubnetAddress = op.SubnetAddress
	o.PolicyName = op.PolicyName
	o.Range = op.Range
}
func (o *RemovePolicyRangeV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *RemovePolicyRangeV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemovePolicyRangeV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// RemovePolicyRangeV4Response structure represents the R_DhcpV4RemovePolicyRange operation response
type RemovePolicyRangeV4Response struct {
	// Return: The R_DhcpV4RemovePolicyRange return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *RemovePolicyRangeV4Response) xxx_ToOp(ctx context.Context, op *xxx_RemovePolicyRangeV4Operation) *xxx_RemovePolicyRangeV4Operation {
	if op == nil {
		op = &xxx_RemovePolicyRangeV4Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *RemovePolicyRangeV4Response) xxx_FromOp(ctx context.Context, op *xxx_RemovePolicyRangeV4Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *RemovePolicyRangeV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *RemovePolicyRangeV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RemovePolicyRangeV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumSubnetClientsV4Operation structure represents the R_DhcpV4EnumSubnetClients operation
type xxx_EnumSubnetClientsV4Operation struct {
	ServerIPAddress  string                   `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	SubnetAddress    uint32                   `idl:"name:SubnetAddress" json:"subnet_address"`
	Resume           uint32                   `idl:"name:ResumeHandle" json:"resume"`
	PreferredMaximum uint32                   `idl:"name:PreferredMaximum" json:"preferred_maximum"`
	ClientInfo       *dhcpm.ClientInfoPBArray `idl:"name:ClientInfo" json:"client_info"`
	ClientsRead      uint32                   `idl:"name:ClientsRead" json:"clients_read"`
	ClientsTotal     uint32                   `idl:"name:ClientsTotal" json:"clients_total"`
	Return           uint32                   `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumSubnetClientsV4Operation) OpNum() int { return 115 }

func (o *xxx_EnumSubnetClientsV4Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpV4EnumSubnetClients"
}

func (o *xxx_EnumSubnetClientsV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetClientsV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.SubnetAddress); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Resume); err != nil {
			return err
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PreferredMaximum); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetClientsV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.SubnetAddress); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Resume); err != nil {
			return err
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PreferredMaximum); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetClientsV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetClientsV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Resume); err != nil {
			return err
		}
	}
	// ClientInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_CLIENT_INFO_PB_ARRAY}*(1))(3:{alias=DHCP_CLIENT_INFO_PB_ARRAY}(struct))
	{
		if o.ClientInfo != nil {
			_ptr_ClientInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.ClientInfo != nil {
					if err := o.ClientInfo.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.ClientInfoPBArray{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ClientInfo, _ptr_ClientInfo); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ClientsRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ClientsRead); err != nil {
			return err
		}
	}
	// ClientsTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ClientsTotal); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetClientsV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Resume); err != nil {
			return err
		}
	}
	// ClientInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_CLIENT_INFO_PB_ARRAY,pointer=ref}*(1))(3:{alias=DHCP_CLIENT_INFO_PB_ARRAY}(struct))
	{
		_ptr_ClientInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.ClientInfo == nil {
				o.ClientInfo = &dhcpm.ClientInfoPBArray{}
			}
			if err := o.ClientInfo.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ClientInfo := func(ptr interface{}) { o.ClientInfo = *ptr.(**dhcpm.ClientInfoPBArray) }
		if err := w.ReadPointer(&o.ClientInfo, _s_ClientInfo, _ptr_ClientInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ClientsRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ClientsRead); err != nil {
			return err
		}
	}
	// ClientsTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ClientsTotal); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumSubnetClientsV4Request structure represents the R_DhcpV4EnumSubnetClients operation request
type EnumSubnetClientsV4Request struct {
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// SubnetAddress: A DHCP_IP_ADDRESS structure containing the IPv4 subnet ID from which
	// DHCPv4 clients are enumerated. If this parameter is set to 0, the DHCPv4 clients
	// from all the IPv4 subnets are returned.
	SubnetAddress uint32 `idl:"name:SubnetAddress" json:"subnet_address"`
	// ResumeHandle: A DHCP_RESUME_HANDLE structure that identifies the enumeration operation.
	// Callers MUST set this value to zero. On success, this method returns the handle value
	// used for subsequent enumeration requests in this parameter. The return value is the
	// last IPv4 address retrieved.
	Resume uint32 `idl:"name:ResumeHandle" json:"resume"`
	// PreferredMaximum: A DWORD value that specifies the preferred maximum number of bytes
	// to return. To retrieve all DHCPv4 clients serviced by a specific IPv4 subnet, clients
	// MUST pass the special value 0xFFFFFFFF. Otherwise, the minimum value is 1024, and
	// the maximum value is 65536. If the input value is less than 1024, it must be treated
	// as 1024. If the input value is greater than 65536 but not equal to 0xFFFFFFFF, it
	// MUST be treated as 65536.
	PreferredMaximum uint32 `idl:"name:PreferredMaximum" json:"preferred_maximum"`
}

func (o *EnumSubnetClientsV4Request) xxx_ToOp(ctx context.Context, op *xxx_EnumSubnetClientsV4Operation) *xxx_EnumSubnetClientsV4Operation {
	if op == nil {
		op = &xxx_EnumSubnetClientsV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.SubnetAddress = o.SubnetAddress
	op.Resume = o.Resume
	op.PreferredMaximum = o.PreferredMaximum
	return op
}

func (o *EnumSubnetClientsV4Request) xxx_FromOp(ctx context.Context, op *xxx_EnumSubnetClientsV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.SubnetAddress = op.SubnetAddress
	o.Resume = op.Resume
	o.PreferredMaximum = op.PreferredMaximum
}
func (o *EnumSubnetClientsV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumSubnetClientsV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumSubnetClientsV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumSubnetClientsV4Response structure represents the R_DhcpV4EnumSubnetClients operation response
type EnumSubnetClientsV4Response struct {
	// ResumeHandle: A DHCP_RESUME_HANDLE structure that identifies the enumeration operation.
	// Callers MUST set this value to zero. On success, this method returns the handle value
	// used for subsequent enumeration requests in this parameter. The return value is the
	// last IPv4 address retrieved.
	Resume uint32 `idl:"name:ResumeHandle" json:"resume"`
	// ClientInfo: A pointer to an array of DHCPv4 client lease records.
	ClientInfo *dhcpm.ClientInfoPBArray `idl:"name:ClientInfo" json:"client_info"`
	// ClientsRead: A pointer to a DWORD containing the number of DHCPv4 client lease records
	// copied into the ClientInfo parameter. The caller MUST allocate memory for this parameter
	// equal to the size of data type DWORD.
	ClientsRead uint32 `idl:"name:ClientsRead" json:"clients_read"`
	// ClientsTotal: A pointer to a DWORD containing the number of DHCPv4 client lease records
	// remaining from the current read position. For example, if there are 100 DHCPv4 lease
	// records for an IPv4 subnet, and if 10 records have been read so far, ClientsTotal
	// will hold the value 90 when this method returns. The caller MUST allocate memory
	// for this parameter equal to the size of data type DWORD.
	ClientsTotal uint32 `idl:"name:ClientsTotal" json:"clients_total"`
	// Return: The R_DhcpV4EnumSubnetClients return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumSubnetClientsV4Response) xxx_ToOp(ctx context.Context, op *xxx_EnumSubnetClientsV4Operation) *xxx_EnumSubnetClientsV4Operation {
	if op == nil {
		op = &xxx_EnumSubnetClientsV4Operation{}
	}
	if o == nil {
		return op
	}
	op.Resume = o.Resume
	op.ClientInfo = o.ClientInfo
	op.ClientsRead = o.ClientsRead
	op.ClientsTotal = o.ClientsTotal
	op.Return = o.Return
	return op
}

func (o *EnumSubnetClientsV4Response) xxx_FromOp(ctx context.Context, op *xxx_EnumSubnetClientsV4Operation) {
	if o == nil {
		return
	}
	o.Resume = op.Resume
	o.ClientInfo = op.ClientInfo
	o.ClientsRead = op.ClientsRead
	o.ClientsTotal = op.ClientsTotal
	o.Return = op.Return
}
func (o *EnumSubnetClientsV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumSubnetClientsV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumSubnetClientsV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetStatelessStoreParamsV6Operation structure represents the R_DhcpV6SetStatelessStoreParams operation
type xxx_SetStatelessStoreParamsV6Operation struct {
	ServerIPAddress string                   `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	ServerLevel     bool                     `idl:"name:fServerLevel" json:"server_level"`
	SubnetAddress   *dhcpm.IPv6Address       `idl:"name:SubnetAddress" json:"subnet_address"`
	FieldModified   uint32                   `idl:"name:FieldModified" json:"field_modified"`
	Params          *dhcpm.StatelessParamsV6 `idl:"name:Params" json:"params"`
	Return          uint32                   `idl:"name:Return" json:"return"`
}

func (o *xxx_SetStatelessStoreParamsV6Operation) OpNum() int { return 116 }

func (o *xxx_SetStatelessStoreParamsV6Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpV6SetStatelessStoreParams"
}

func (o *xxx_SetStatelessStoreParamsV6Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetStatelessStoreParamsV6Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// fServerLevel {in} (1:{alias=BOOL}(int32))
	{
		if !o.ServerLevel {
			if err := w.WriteData(int32(0)); err != nil {
				return err
			}
		} else {
			if err := w.WriteData(int32(1)); err != nil {
				return err
			}
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IPV6_ADDRESS}(struct))
	{
		if o.SubnetAddress != nil {
			if err := o.SubnetAddress.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.IPv6Address{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// FieldModified {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.FieldModified); err != nil {
			return err
		}
	}
	// Params {in} (1:{alias=LPDHCPV6_STATELESS_PARAMS}*(1))(2:{alias=DHCPV6_STATELESS_PARAMS}(struct))
	{
		if o.Params != nil {
			if err := o.Params.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.StatelessParamsV6{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_SetStatelessStoreParamsV6Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// fServerLevel {in} (1:{alias=BOOL}(int32))
	{
		var _bServerLevel int32
		if err := w.ReadData(&_bServerLevel); err != nil {
			return err
		}
		o.ServerLevel = _bServerLevel != 0
	}
	// SubnetAddress {in} (1:{alias=DHCP_IPV6_ADDRESS}(struct))
	{
		if o.SubnetAddress == nil {
			o.SubnetAddress = &dhcpm.IPv6Address{}
		}
		if err := o.SubnetAddress.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// FieldModified {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.FieldModified); err != nil {
			return err
		}
	}
	// Params {in} (1:{alias=LPDHCPV6_STATELESS_PARAMS,pointer=ref}*(1))(2:{alias=DHCPV6_STATELESS_PARAMS}(struct))
	{
		if o.Params == nil {
			o.Params = &dhcpm.StatelessParamsV6{}
		}
		if err := o.Params.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetStatelessStoreParamsV6Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetStatelessStoreParamsV6Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetStatelessStoreParamsV6Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetStatelessStoreParamsV6Request structure represents the R_DhcpV6SetStatelessStoreParams operation request
type SetStatelessStoreParamsV6Request struct {
	// ServerIpAddress: The IP Address of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// fServerLevel: A flag representing whether the configuration settings for DHCPv6 stateless
	// client inventory are to be modified at the server level or the scope level. A value
	// of TRUE indicates that the modifications are for the server level; FALSE indicates
	// that the modifications are for the scope level.
	ServerLevel bool `idl:"name:fServerLevel" json:"server_level"`
	// SubnetAddress: The IPv6 subnet address for which the configuration settings are to
	// be modified. If the fServerLevel parameter is set to TRUE, this parameter MUST be
	// set to zero.
	SubnetAddress *dhcpm.IPv6Address `idl:"name:SubnetAddress" json:"subnet_address"`
	// FieldModified: A DWORD of binary flags that indicates which fields in the DHCPv6_STATELESS_PARAMS
	// structure pointed to by the Params parameter are to be set.
	//
	//	+----------------------------+------------+
	//	|          FIELD TO          |            |
	//	|            SET             |    FLAG    |
	//	|                            |            |
	//	+----------------------------+------------+
	//	+----------------------------+------------+
	//	| DhcpStatelessPurgeInterval | 0x00000001 |
	//	+----------------------------+------------+
	//	| DhcpStatelessStatus        | 0x00000002 |
	//	+----------------------------+------------+
	FieldModified uint32 `idl:"name:FieldModified" json:"field_modified"`
	// Params: A pointer to the configuration settings for the DHCPv6 stateless client inventory
	// for a DHCPv6 server.
	Params *dhcpm.StatelessParamsV6 `idl:"name:Params" json:"params"`
}

func (o *SetStatelessStoreParamsV6Request) xxx_ToOp(ctx context.Context, op *xxx_SetStatelessStoreParamsV6Operation) *xxx_SetStatelessStoreParamsV6Operation {
	if op == nil {
		op = &xxx_SetStatelessStoreParamsV6Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.ServerLevel = o.ServerLevel
	op.SubnetAddress = o.SubnetAddress
	op.FieldModified = o.FieldModified
	op.Params = o.Params
	return op
}

func (o *SetStatelessStoreParamsV6Request) xxx_FromOp(ctx context.Context, op *xxx_SetStatelessStoreParamsV6Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.ServerLevel = op.ServerLevel
	o.SubnetAddress = op.SubnetAddress
	o.FieldModified = op.FieldModified
	o.Params = op.Params
}
func (o *SetStatelessStoreParamsV6Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetStatelessStoreParamsV6Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetStatelessStoreParamsV6Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetStatelessStoreParamsV6Response structure represents the R_DhcpV6SetStatelessStoreParams operation response
type SetStatelessStoreParamsV6Response struct {
	// Return: The R_DhcpV6SetStatelessStoreParams return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetStatelessStoreParamsV6Response) xxx_ToOp(ctx context.Context, op *xxx_SetStatelessStoreParamsV6Operation) *xxx_SetStatelessStoreParamsV6Operation {
	if op == nil {
		op = &xxx_SetStatelessStoreParamsV6Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetStatelessStoreParamsV6Response) xxx_FromOp(ctx context.Context, op *xxx_SetStatelessStoreParamsV6Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetStatelessStoreParamsV6Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetStatelessStoreParamsV6Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetStatelessStoreParamsV6Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetStatelessStoreParamsV6Operation structure represents the R_DhcpV6GetStatelessStoreParams operation
type xxx_GetStatelessStoreParamsV6Operation struct {
	ServerIPAddress string                   `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	ServerLevel     bool                     `idl:"name:fServerLevel" json:"server_level"`
	SubnetAddress   *dhcpm.IPv6Address       `idl:"name:SubnetAddress" json:"subnet_address"`
	Params          *dhcpm.StatelessParamsV6 `idl:"name:Params" json:"params"`
	Return          uint32                   `idl:"name:Return" json:"return"`
}

func (o *xxx_GetStatelessStoreParamsV6Operation) OpNum() int { return 117 }

func (o *xxx_GetStatelessStoreParamsV6Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpV6GetStatelessStoreParams"
}

func (o *xxx_GetStatelessStoreParamsV6Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetStatelessStoreParamsV6Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// fServerLevel {in} (1:{alias=BOOL}(int32))
	{
		if !o.ServerLevel {
			if err := w.WriteData(int32(0)); err != nil {
				return err
			}
		} else {
			if err := w.WriteData(int32(1)); err != nil {
				return err
			}
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IPV6_ADDRESS}(struct))
	{
		if o.SubnetAddress != nil {
			if err := o.SubnetAddress.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.IPv6Address{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_GetStatelessStoreParamsV6Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// fServerLevel {in} (1:{alias=BOOL}(int32))
	{
		var _bServerLevel int32
		if err := w.ReadData(&_bServerLevel); err != nil {
			return err
		}
		o.ServerLevel = _bServerLevel != 0
	}
	// SubnetAddress {in} (1:{alias=DHCP_IPV6_ADDRESS}(struct))
	{
		if o.SubnetAddress == nil {
			o.SubnetAddress = &dhcpm.IPv6Address{}
		}
		if err := o.SubnetAddress.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetStatelessStoreParamsV6Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetStatelessStoreParamsV6Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Params {out} (1:{alias=LPDHCPV6_STATELESS_PARAMS}*(1))(2:{alias=DHCPV6_STATELESS_PARAMS}(struct))
	{
		if o.Params != nil {
			if err := o.Params.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.StatelessParamsV6{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetStatelessStoreParamsV6Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Params {out} (1:{alias=LPDHCPV6_STATELESS_PARAMS,pointer=ref}*(1))(2:{alias=DHCPV6_STATELESS_PARAMS}(struct))
	{
		if o.Params == nil {
			o.Params = &dhcpm.StatelessParamsV6{}
		}
		if err := o.Params.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetStatelessStoreParamsV6Request structure represents the R_DhcpV6GetStatelessStoreParams operation request
type GetStatelessStoreParamsV6Request struct {
	// ServerIpAddress: The IP address of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// fServerLevel: A flag representing whether the configuration settings for DHCPv6 stateless
	// client inventory are to be retrieved at the server level or the scope level. A value
	// of TRUE indicates the server level; FALSE indicates the scope level.
	ServerLevel bool `idl:"name:fServerLevel" json:"server_level"`
	// SubnetAddress: The IPv6 subnet address for which the configuration settings are to
	// be retrieved. If the fServerLevel parameter is set to TRUE, this parameter MUST be
	// ignored.
	SubnetAddress *dhcpm.IPv6Address `idl:"name:SubnetAddress" json:"subnet_address"`
}

func (o *GetStatelessStoreParamsV6Request) xxx_ToOp(ctx context.Context, op *xxx_GetStatelessStoreParamsV6Operation) *xxx_GetStatelessStoreParamsV6Operation {
	if op == nil {
		op = &xxx_GetStatelessStoreParamsV6Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.ServerLevel = o.ServerLevel
	op.SubnetAddress = o.SubnetAddress
	return op
}

func (o *GetStatelessStoreParamsV6Request) xxx_FromOp(ctx context.Context, op *xxx_GetStatelessStoreParamsV6Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.ServerLevel = op.ServerLevel
	o.SubnetAddress = op.SubnetAddress
}
func (o *GetStatelessStoreParamsV6Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetStatelessStoreParamsV6Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetStatelessStoreParamsV6Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetStatelessStoreParamsV6Response structure represents the R_DhcpV6GetStatelessStoreParams operation response
type GetStatelessStoreParamsV6Response struct {
	// Params: A pointer of type LPDHCPV6_STATELESS_PARAMS into which this method will place
	// the configuration settings for a DHCPv6 server.
	Params *dhcpm.StatelessParamsV6 `idl:"name:Params" json:"params"`
	// Return: The R_DhcpV6GetStatelessStoreParams return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetStatelessStoreParamsV6Response) xxx_ToOp(ctx context.Context, op *xxx_GetStatelessStoreParamsV6Operation) *xxx_GetStatelessStoreParamsV6Operation {
	if op == nil {
		op = &xxx_GetStatelessStoreParamsV6Operation{}
	}
	if o == nil {
		return op
	}
	op.Params = o.Params
	op.Return = o.Return
	return op
}

func (o *GetStatelessStoreParamsV6Response) xxx_FromOp(ctx context.Context, op *xxx_GetStatelessStoreParamsV6Operation) {
	if o == nil {
		return
	}
	o.Params = op.Params
	o.Return = op.Return
}
func (o *GetStatelessStoreParamsV6Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetStatelessStoreParamsV6Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetStatelessStoreParamsV6Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetStatelessStatisticsV6Operation structure represents the R_DhcpV6GetStatelessStatistics operation
type xxx_GetStatelessStatisticsV6Operation struct {
	ServerIPAddress string                  `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	StatelessStats  *dhcpm.StatelessStatsV6 `idl:"name:StatelessStats" json:"stateless_stats"`
	Return          uint32                  `idl:"name:Return" json:"return"`
}

func (o *xxx_GetStatelessStatisticsV6Operation) OpNum() int { return 118 }

func (o *xxx_GetStatelessStatisticsV6Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpV6GetStatelessStatistics"
}

func (o *xxx_GetStatelessStatisticsV6Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetStatelessStatisticsV6Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetStatelessStatisticsV6Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetStatelessStatisticsV6Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetStatelessStatisticsV6Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// StatelessStats {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCPV6_STATELESS_STATS}*(1))(3:{alias=DHCPV6_STATELESS_STATS}(struct))
	{
		if o.StatelessStats != nil {
			_ptr_StatelessStats := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.StatelessStats != nil {
					if err := o.StatelessStats.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.StatelessStatsV6{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.StatelessStats, _ptr_StatelessStats); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetStatelessStatisticsV6Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// StatelessStats {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCPV6_STATELESS_STATS,pointer=ref}*(1))(3:{alias=DHCPV6_STATELESS_STATS}(struct))
	{
		_ptr_StatelessStats := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.StatelessStats == nil {
				o.StatelessStats = &dhcpm.StatelessStatsV6{}
			}
			if err := o.StatelessStats.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_StatelessStats := func(ptr interface{}) { o.StatelessStats = *ptr.(**dhcpm.StatelessStatsV6) }
		if err := w.ReadPointer(&o.StatelessStats, _s_StatelessStats, _ptr_StatelessStats); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetStatelessStatisticsV6Request structure represents the R_DhcpV6GetStatelessStatistics operation request
type GetStatelessStatisticsV6Request struct {
	// ServerIpAddress: The IP address of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
}

func (o *GetStatelessStatisticsV6Request) xxx_ToOp(ctx context.Context, op *xxx_GetStatelessStatisticsV6Operation) *xxx_GetStatelessStatisticsV6Operation {
	if op == nil {
		op = &xxx_GetStatelessStatisticsV6Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	return op
}

func (o *GetStatelessStatisticsV6Request) xxx_FromOp(ctx context.Context, op *xxx_GetStatelessStatisticsV6Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
}
func (o *GetStatelessStatisticsV6Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetStatelessStatisticsV6Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetStatelessStatisticsV6Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetStatelessStatisticsV6Response structure represents the R_DhcpV6GetStatelessStatistics operation response
type GetStatelessStatisticsV6Response struct {
	// StatelessStats: A pointer of type LPDHCPV6_STATELESS_STATS in which this method will
	// place the DHCPv6 stateless server statistics.
	StatelessStats *dhcpm.StatelessStatsV6 `idl:"name:StatelessStats" json:"stateless_stats"`
	// Return: The R_DhcpV6GetStatelessStatistics return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetStatelessStatisticsV6Response) xxx_ToOp(ctx context.Context, op *xxx_GetStatelessStatisticsV6Operation) *xxx_GetStatelessStatisticsV6Operation {
	if op == nil {
		op = &xxx_GetStatelessStatisticsV6Operation{}
	}
	if o == nil {
		return op
	}
	op.StatelessStats = o.StatelessStats
	op.Return = o.Return
	return op
}

func (o *GetStatelessStatisticsV6Response) xxx_FromOp(ctx context.Context, op *xxx_GetStatelessStatisticsV6Operation) {
	if o == nil {
		return
	}
	o.StatelessStats = op.StatelessStats
	o.Return = op.Return
}
func (o *GetStatelessStatisticsV6Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetStatelessStatisticsV6Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetStatelessStatisticsV6Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumSubnetReservationsV4Operation structure represents the R_DhcpV4EnumSubnetReservations operation
type xxx_EnumSubnetReservationsV4Operation struct {
	ServerIPAddress  string                      `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	SubnetAddress    uint32                      `idl:"name:SubnetAddress" json:"subnet_address"`
	Resume           uint32                      `idl:"name:ResumeHandle" json:"resume"`
	PreferredMaximum uint32                      `idl:"name:PreferredMaximum" json:"preferred_maximum"`
	EnumElementInfo  *dhcpm.ReservationInfoArray `idl:"name:EnumElementInfo" json:"enum_element_info"`
	ElementsRead     uint32                      `idl:"name:ElementsRead" json:"elements_read"`
	ElementsTotal    uint32                      `idl:"name:ElementsTotal" json:"elements_total"`
	Return           uint32                      `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumSubnetReservationsV4Operation) OpNum() int { return 119 }

func (o *xxx_EnumSubnetReservationsV4Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpV4EnumSubnetReservations"
}

func (o *xxx_EnumSubnetReservationsV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetReservationsV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.SubnetAddress); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Resume); err != nil {
			return err
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PreferredMaximum); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetReservationsV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.SubnetAddress); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Resume); err != nil {
			return err
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PreferredMaximum); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetReservationsV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetReservationsV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Resume); err != nil {
			return err
		}
	}
	// EnumElementInfo {out} (1:{alias=LPDHCP_RESERVATION_INFO_ARRAY}*(1))(2:{alias=DHCP_RESERVATION_INFO_ARRAY}(struct))
	{
		if o.EnumElementInfo != nil {
			if err := o.EnumElementInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.ReservationInfoArray{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ElementsRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ElementsRead); err != nil {
			return err
		}
	}
	// ElementsTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ElementsTotal); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetReservationsV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Resume); err != nil {
			return err
		}
	}
	// EnumElementInfo {out} (1:{alias=LPDHCP_RESERVATION_INFO_ARRAY,pointer=ref}*(1))(2:{alias=DHCP_RESERVATION_INFO_ARRAY}(struct))
	{
		if o.EnumElementInfo == nil {
			o.EnumElementInfo = &dhcpm.ReservationInfoArray{}
		}
		if err := o.EnumElementInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ElementsRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ElementsRead); err != nil {
			return err
		}
	}
	// ElementsTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ElementsTotal); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumSubnetReservationsV4Request structure represents the R_DhcpV4EnumSubnetReservations operation request
type EnumSubnetReservationsV4Request struct {
	// ServerIpAddress: The IP address/host name of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// SubnetAddress: This is of type DHCP_IP_ADDRESS structure (section 2.2.1.2.1) that
	// contains the IPv4 subnet address for which DHCPv4 reservations information is retrieved.
	SubnetAddress uint32 `idl:"name:SubnetAddress" json:"subnet_address"`
	// ResumeHandle: This is a pointer of DHCP_RESUME_HANDLE data type (section 2.2.1.2.6)
	// that identifies the enumeration operation. Initially, this value MUST be set to zero,
	// with a successful call returning the handle value used for subsequent enumeration
	// requests.
	Resume uint32 `idl:"name:ResumeHandle" json:"resume"`
	// PreferredMaximum: This is of type DWORD, specifying the preferred maximum number
	// of bytes to be returned. If the number of bytes required in memory for the remaining
	// unenumerated DHCPv4 reservations is less than the PreferredMaximum parameter value,
	// then all the remaining DHCPv4 reservations are returned.
	PreferredMaximum uint32 `idl:"name:PreferredMaximum" json:"preferred_maximum"`
}

func (o *EnumSubnetReservationsV4Request) xxx_ToOp(ctx context.Context, op *xxx_EnumSubnetReservationsV4Operation) *xxx_EnumSubnetReservationsV4Operation {
	if op == nil {
		op = &xxx_EnumSubnetReservationsV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.SubnetAddress = o.SubnetAddress
	op.Resume = o.Resume
	op.PreferredMaximum = o.PreferredMaximum
	return op
}

func (o *EnumSubnetReservationsV4Request) xxx_FromOp(ctx context.Context, op *xxx_EnumSubnetReservationsV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.SubnetAddress = op.SubnetAddress
	o.Resume = op.Resume
	o.PreferredMaximum = op.PreferredMaximum
}
func (o *EnumSubnetReservationsV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumSubnetReservationsV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumSubnetReservationsV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumSubnetReservationsV4Response structure represents the R_DhcpV4EnumSubnetReservations operation response
type EnumSubnetReservationsV4Response struct {
	// ResumeHandle: This is a pointer of DHCP_RESUME_HANDLE data type (section 2.2.1.2.6)
	// that identifies the enumeration operation. Initially, this value MUST be set to zero,
	// with a successful call returning the handle value used for subsequent enumeration
	// requests.
	Resume uint32 `idl:"name:ResumeHandle" json:"resume"`
	// EnumElementInfo: This is a pointer of type LPDHCP_RESERVATION_INFO_ARRAY (section
	// 2.2.1.2.103) in which information for all the reservations on the DHCPv4 server for
	// the given SubnetAddress parameter is retrieved.
	EnumElementInfo *dhcpm.ReservationInfoArray `idl:"name:EnumElementInfo" json:"enum_element_info"`
	// ElementsRead: This is a pointer to a DWORD value that specifies the number of DHCPv4
	// reservations returned in the EnumElementInfo parameter. The caller MUST allocate
	// memory for this parameter equal to the size of data type DWORD.
	ElementsRead uint32 `idl:"name:ElementsRead" json:"elements_read"`
	// ElementsTotal: This is a pointer to a DWORD value that specifies the number of DHCPv4
	// reservations that have not yet been enumerated. The caller MUST allocate memory for
	// this parameter equal to the size of data type DWORD.
	ElementsTotal uint32 `idl:"name:ElementsTotal" json:"elements_total"`
	// Return: The R_DhcpV4EnumSubnetReservations return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumSubnetReservationsV4Response) xxx_ToOp(ctx context.Context, op *xxx_EnumSubnetReservationsV4Operation) *xxx_EnumSubnetReservationsV4Operation {
	if op == nil {
		op = &xxx_EnumSubnetReservationsV4Operation{}
	}
	if o == nil {
		return op
	}
	op.Resume = o.Resume
	op.EnumElementInfo = o.EnumElementInfo
	op.ElementsRead = o.ElementsRead
	op.ElementsTotal = o.ElementsTotal
	op.Return = o.Return
	return op
}

func (o *EnumSubnetReservationsV4Response) xxx_FromOp(ctx context.Context, op *xxx_EnumSubnetReservationsV4Operation) {
	if o == nil {
		return
	}
	o.Resume = op.Resume
	o.EnumElementInfo = op.EnumElementInfo
	o.ElementsRead = op.ElementsRead
	o.ElementsTotal = op.ElementsTotal
	o.Return = op.Return
}
func (o *EnumSubnetReservationsV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumSubnetReservationsV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumSubnetReservationsV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetFreeIPAddressV4Operation structure represents the R_DhcpV4GetFreeIPAddress operation
type xxx_GetFreeIPAddressV4Operation struct {
	ServerIPAddress string         `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	ScopeID         uint32         `idl:"name:ScopeId" json:"scope_id"`
	StartIP         uint32         `idl:"name:startIP" json:"start_ip"`
	EndIP           uint32         `idl:"name:endIP" json:"end_ip"`
	FreeAddrLength  uint32         `idl:"name:numFreeAddr" json:"free_addr_length"`
	IPAddrList      *dhcpm.IPArray `idl:"name:IPAddrList" json:"ip_addr_list"`
	Return          uint32         `idl:"name:Return" json:"return"`
}

func (o *xxx_GetFreeIPAddressV4Operation) OpNum() int { return 120 }

func (o *xxx_GetFreeIPAddressV4Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpV4GetFreeIPAddress"
}

func (o *xxx_GetFreeIPAddressV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetFreeIPAddressV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ScopeId {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.ScopeID); err != nil {
			return err
		}
	}
	// startIP {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.StartIP); err != nil {
			return err
		}
	}
	// endIP {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.EndIP); err != nil {
			return err
		}
	}
	// numFreeAddr {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.FreeAddrLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetFreeIPAddressV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ScopeId {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ScopeID); err != nil {
			return err
		}
	}
	// startIP {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.StartIP); err != nil {
			return err
		}
	}
	// endIP {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.EndIP); err != nil {
			return err
		}
	}
	// numFreeAddr {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.FreeAddrLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetFreeIPAddressV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetFreeIPAddressV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// IPAddrList {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_IP_ARRAY}*(1))(3:{alias=DHCP_IP_ARRAY}(struct))
	{
		if o.IPAddrList != nil {
			_ptr_IPAddrList := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.IPAddrList != nil {
					if err := o.IPAddrList.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.IPArray{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.IPAddrList, _ptr_IPAddrList); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetFreeIPAddressV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// IPAddrList {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_IP_ARRAY,pointer=ref}*(1))(3:{alias=DHCP_IP_ARRAY}(struct))
	{
		_ptr_IPAddrList := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.IPAddrList == nil {
				o.IPAddrList = &dhcpm.IPArray{}
			}
			if err := o.IPAddrList.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_IPAddrList := func(ptr interface{}) { o.IPAddrList = *ptr.(**dhcpm.IPArray) }
		if err := w.ReadPointer(&o.IPAddrList, _s_IPAddrList, _ptr_IPAddrList); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetFreeIPAddressV4Request structure represents the R_DhcpV4GetFreeIPAddress operation request
type GetFreeIPAddressV4Request struct {
	// ServerIpAddress: The IP address of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// ScopeId: The IPv4 subnet ID that contains the addresses available to be leased out.
	ScopeID uint32 `idl:"name:ScopeId" json:"scope_id"`
	// startIP: The IPv4 address at the start of the range of IPv4 addresses available to
	// be leased out. A value of 0 indicates that the method uses the starting address of
	// the IPv4 range of the scope specified by the ScopeId parameter.
	StartIP uint32 `idl:"name:startIP" json:"start_ip"`
	// endIP: The IPv4 address at the end of the range of IPv4 addresses available to be
	// leased out. A value of 0 indicates that the method uses the ending address of the
	// IPv4 range of the scope specified by the ScopeId parameter.
	EndIP uint32 `idl:"name:endIP" json:"end_ip"`
	// numFreeAddr: The number of IPv4 addresses to obtain from the specified scope. If
	// this parameter is 0, only one IPv4 address is returned.
	FreeAddrLength uint32 `idl:"name:numFreeAddr" json:"free_addr_length"`
}

func (o *GetFreeIPAddressV4Request) xxx_ToOp(ctx context.Context, op *xxx_GetFreeIPAddressV4Operation) *xxx_GetFreeIPAddressV4Operation {
	if op == nil {
		op = &xxx_GetFreeIPAddressV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.ScopeID = o.ScopeID
	op.StartIP = o.StartIP
	op.EndIP = o.EndIP
	op.FreeAddrLength = o.FreeAddrLength
	return op
}

func (o *GetFreeIPAddressV4Request) xxx_FromOp(ctx context.Context, op *xxx_GetFreeIPAddressV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.ScopeID = op.ScopeID
	o.StartIP = op.StartIP
	o.EndIP = op.EndIP
	o.FreeAddrLength = op.FreeAddrLength
}
func (o *GetFreeIPAddressV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetFreeIPAddressV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetFreeIPAddressV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetFreeIPAddressV4Response structure represents the R_DhcpV4GetFreeIPAddress operation response
type GetFreeIPAddressV4Response struct {
	IPAddrList *dhcpm.IPArray `idl:"name:IPAddrList" json:"ip_addr_list"`
	// Return: The R_DhcpV4GetFreeIPAddress return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetFreeIPAddressV4Response) xxx_ToOp(ctx context.Context, op *xxx_GetFreeIPAddressV4Operation) *xxx_GetFreeIPAddressV4Operation {
	if op == nil {
		op = &xxx_GetFreeIPAddressV4Operation{}
	}
	if o == nil {
		return op
	}
	op.IPAddrList = o.IPAddrList
	op.Return = o.Return
	return op
}

func (o *GetFreeIPAddressV4Response) xxx_FromOp(ctx context.Context, op *xxx_GetFreeIPAddressV4Operation) {
	if o == nil {
		return
	}
	o.IPAddrList = op.IPAddrList
	o.Return = op.Return
}
func (o *GetFreeIPAddressV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetFreeIPAddressV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetFreeIPAddressV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetFreeIPAddressV6Operation structure represents the R_DhcpV6GetFreeIPAddress operation
type xxx_GetFreeIPAddressV6Operation struct {
	ServerIPAddress string             `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	ScopeID         *dhcpm.IPv6Address `idl:"name:ScopeId" json:"scope_id"`
	StartIP         *dhcpm.IPv6Address `idl:"name:startIP" json:"start_ip"`
	EndIP           *dhcpm.IPv6Address `idl:"name:endIP" json:"end_ip"`
	FreeAddrLength  uint32             `idl:"name:numFreeAddr" json:"free_addr_length"`
	IPAddrList      *dhcpm.IPArrayV6   `idl:"name:IPAddrList" json:"ip_addr_list"`
	Return          uint32             `idl:"name:Return" json:"return"`
}

func (o *xxx_GetFreeIPAddressV6Operation) OpNum() int { return 121 }

func (o *xxx_GetFreeIPAddressV6Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpV6GetFreeIPAddress"
}

func (o *xxx_GetFreeIPAddressV6Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetFreeIPAddressV6Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ScopeId {in} (1:{alias=DHCP_IPV6_ADDRESS}(struct))
	{
		if o.ScopeID != nil {
			if err := o.ScopeID.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.IPv6Address{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// startIP {in} (1:{alias=DHCP_IPV6_ADDRESS}(struct))
	{
		if o.StartIP != nil {
			if err := o.StartIP.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.IPv6Address{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// endIP {in} (1:{alias=DHCP_IPV6_ADDRESS}(struct))
	{
		if o.EndIP != nil {
			if err := o.EndIP.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.IPv6Address{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// numFreeAddr {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.FreeAddrLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetFreeIPAddressV6Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ScopeId {in} (1:{alias=DHCP_IPV6_ADDRESS}(struct))
	{
		if o.ScopeID == nil {
			o.ScopeID = &dhcpm.IPv6Address{}
		}
		if err := o.ScopeID.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// startIP {in} (1:{alias=DHCP_IPV6_ADDRESS}(struct))
	{
		if o.StartIP == nil {
			o.StartIP = &dhcpm.IPv6Address{}
		}
		if err := o.StartIP.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// endIP {in} (1:{alias=DHCP_IPV6_ADDRESS}(struct))
	{
		if o.EndIP == nil {
			o.EndIP = &dhcpm.IPv6Address{}
		}
		if err := o.EndIP.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// numFreeAddr {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.FreeAddrLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetFreeIPAddressV6Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetFreeIPAddressV6Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// IPAddrList {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCPV6_IP_ARRAY}*(1))(3:{alias=DHCPV6_IP_ARRAY}(struct))
	{
		if o.IPAddrList != nil {
			_ptr_IPAddrList := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.IPAddrList != nil {
					if err := o.IPAddrList.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.IPArrayV6{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.IPAddrList, _ptr_IPAddrList); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetFreeIPAddressV6Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// IPAddrList {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCPV6_IP_ARRAY,pointer=ref}*(1))(3:{alias=DHCPV6_IP_ARRAY}(struct))
	{
		_ptr_IPAddrList := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.IPAddrList == nil {
				o.IPAddrList = &dhcpm.IPArrayV6{}
			}
			if err := o.IPAddrList.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_IPAddrList := func(ptr interface{}) { o.IPAddrList = *ptr.(**dhcpm.IPArrayV6) }
		if err := w.ReadPointer(&o.IPAddrList, _s_IPAddrList, _ptr_IPAddrList); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetFreeIPAddressV6Request structure represents the R_DhcpV6GetFreeIPAddress operation request
type GetFreeIPAddressV6Request struct {
	// ServerIpAddress: The IP address of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// ScopeId: The IPv6 subnet ID that contains the addresses available to be leased out.
	ScopeID *dhcpm.IPv6Address `idl:"name:ScopeId" json:"scope_id"`
	// startIP: The IPv6 address at the start of the range of IPv6 addresses available to
	// be leased out. A value of 0 indicates that the method uses the starting address of
	// the IPv6 range of the scope specified by the ScopeId parameter.
	StartIP *dhcpm.IPv6Address `idl:"name:startIP" json:"start_ip"`
	// endIP: The IPv6 address at the end of the range of IPv6 addresses available to be
	// leased out. A value of 0 indicates that the method uses the ending address of the
	// IPv6 range of the scope specified by the ScopeId parameter.
	EndIP *dhcpm.IPv6Address `idl:"name:endIP" json:"end_ip"`
	// numFreeAddr: The number of IPv6 addresses to obtain from the specified scope. If
	// this parameter is 0, only one IPv6 address is returned.
	FreeAddrLength uint32 `idl:"name:numFreeAddr" json:"free_addr_length"`
}

func (o *GetFreeIPAddressV6Request) xxx_ToOp(ctx context.Context, op *xxx_GetFreeIPAddressV6Operation) *xxx_GetFreeIPAddressV6Operation {
	if op == nil {
		op = &xxx_GetFreeIPAddressV6Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.ScopeID = o.ScopeID
	op.StartIP = o.StartIP
	op.EndIP = o.EndIP
	op.FreeAddrLength = o.FreeAddrLength
	return op
}

func (o *GetFreeIPAddressV6Request) xxx_FromOp(ctx context.Context, op *xxx_GetFreeIPAddressV6Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.ScopeID = op.ScopeID
	o.StartIP = op.StartIP
	o.EndIP = op.EndIP
	o.FreeAddrLength = op.FreeAddrLength
}
func (o *GetFreeIPAddressV6Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetFreeIPAddressV6Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetFreeIPAddressV6Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetFreeIPAddressV6Response structure represents the R_DhcpV6GetFreeIPAddress operation response
type GetFreeIPAddressV6Response struct {
	IPAddrList *dhcpm.IPArrayV6 `idl:"name:IPAddrList" json:"ip_addr_list"`
	// Return: The R_DhcpV6GetFreeIPAddress return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetFreeIPAddressV6Response) xxx_ToOp(ctx context.Context, op *xxx_GetFreeIPAddressV6Operation) *xxx_GetFreeIPAddressV6Operation {
	if op == nil {
		op = &xxx_GetFreeIPAddressV6Operation{}
	}
	if o == nil {
		return op
	}
	op.IPAddrList = o.IPAddrList
	op.Return = o.Return
	return op
}

func (o *GetFreeIPAddressV6Response) xxx_FromOp(ctx context.Context, op *xxx_GetFreeIPAddressV6Operation) {
	if o == nil {
		return
	}
	o.IPAddrList = op.IPAddrList
	o.Return = op.Return
}
func (o *GetFreeIPAddressV6Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetFreeIPAddressV6Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetFreeIPAddressV6Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CreateClientInfoV4Operation structure represents the R_DhcpV4CreateClientInfo operation
type xxx_CreateClientInfoV4Operation struct {
	ServerIPAddress string              `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	ClientInfo      *dhcpm.ClientInfoPB `idl:"name:ClientInfo;pointer:ref" json:"client_info"`
	Return          uint32              `idl:"name:Return" json:"return"`
}

func (o *xxx_CreateClientInfoV4Operation) OpNum() int { return 122 }

func (o *xxx_CreateClientInfoV4Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpV4CreateClientInfo"
}

func (o *xxx_CreateClientInfoV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateClientInfoV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ClientInfo {in} (1:{pointer=ref, alias=LPDHCP_CLIENT_INFO_PB}*(1))(2:{alias=DHCP_CLIENT_INFO_PB}(struct))
	{
		if o.ClientInfo != nil {
			if err := o.ClientInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.ClientInfoPB{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateClientInfoV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ClientInfo {in} (1:{pointer=ref, alias=LPDHCP_CLIENT_INFO_PB}*(1))(2:{alias=DHCP_CLIENT_INFO_PB}(struct))
	{
		if o.ClientInfo == nil {
			o.ClientInfo = &dhcpm.ClientInfoPB{}
		}
		if err := o.ClientInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateClientInfoV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateClientInfoV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateClientInfoV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CreateClientInfoV4Request structure represents the R_DhcpV4CreateClientInfo operation request
type CreateClientInfoV4Request struct {
	// ServerIpAddress: The IP address of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// ClientInfo: A pointer to a DHCP_CLIENT_INFO_PB (section 2.2.1.2.115) structure that
	// contains the DHCPv4 client lease record information to be set on the DHCPv4 server.
	// The caller MUST pass the ClientIPAddress and ClientHardwareAddress members when adding
	// a DHCPv4 client lease record to the DHCPv4 server. The ClientHardwareAddress member
	// represents a DHCPv4 client-identifier as specified in section 2.2.1.2.5.1. The ClientName,
	// ClientComment, ClientLeaseExpires, bClientType, AddressState, Status, ProbationEnds,
	// QuarantineCapable, PolicyName, and OwnerHost members are modified on the DHCPv4 client
	// lease record identified by the ClientIpAddress member.
	ClientInfo *dhcpm.ClientInfoPB `idl:"name:ClientInfo;pointer:ref" json:"client_info"`
}

func (o *CreateClientInfoV4Request) xxx_ToOp(ctx context.Context, op *xxx_CreateClientInfoV4Operation) *xxx_CreateClientInfoV4Operation {
	if op == nil {
		op = &xxx_CreateClientInfoV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.ClientInfo = o.ClientInfo
	return op
}

func (o *CreateClientInfoV4Request) xxx_FromOp(ctx context.Context, op *xxx_CreateClientInfoV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.ClientInfo = op.ClientInfo
}
func (o *CreateClientInfoV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *CreateClientInfoV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateClientInfoV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CreateClientInfoV4Response structure represents the R_DhcpV4CreateClientInfo operation response
type CreateClientInfoV4Response struct {
	// Return: The R_DhcpV4CreateClientInfo return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CreateClientInfoV4Response) xxx_ToOp(ctx context.Context, op *xxx_CreateClientInfoV4Operation) *xxx_CreateClientInfoV4Operation {
	if op == nil {
		op = &xxx_CreateClientInfoV4Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *CreateClientInfoV4Response) xxx_FromOp(ctx context.Context, op *xxx_CreateClientInfoV4Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *CreateClientInfoV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *CreateClientInfoV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateClientInfoV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetClientInfoV4Operation structure represents the R_DhcpV4GetClientInfo operation
type xxx_GetClientInfoV4Operation struct {
	ServerIPAddress string              `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	SearchInfo      *dhcpm.SearchInfo   `idl:"name:SearchInfo;pointer:ref" json:"search_info"`
	ClientInfo      *dhcpm.ClientInfoPB `idl:"name:ClientInfo" json:"client_info"`
	Return          uint32              `idl:"name:Return" json:"return"`
}

func (o *xxx_GetClientInfoV4Operation) OpNum() int { return 123 }

func (o *xxx_GetClientInfoV4Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpV4GetClientInfo" }

func (o *xxx_GetClientInfoV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetClientInfoV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// SearchInfo {in} (1:{pointer=ref, alias=LPDHCP_SEARCH_INFO}*(1))(2:{alias=DHCP_SEARCH_INFO}(struct))
	{
		if o.SearchInfo != nil {
			if err := o.SearchInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.SearchInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetClientInfoV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// SearchInfo {in} (1:{pointer=ref, alias=LPDHCP_SEARCH_INFO}*(1))(2:{alias=DHCP_SEARCH_INFO}(struct))
	{
		if o.SearchInfo == nil {
			o.SearchInfo = &dhcpm.SearchInfo{}
		}
		if err := o.SearchInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetClientInfoV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetClientInfoV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ClientInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_CLIENT_INFO_PB}*(1))(3:{alias=DHCP_CLIENT_INFO_PB}(struct))
	{
		if o.ClientInfo != nil {
			_ptr_ClientInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.ClientInfo != nil {
					if err := o.ClientInfo.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.ClientInfoPB{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ClientInfo, _ptr_ClientInfo); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetClientInfoV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ClientInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_CLIENT_INFO_PB,pointer=ref}*(1))(3:{alias=DHCP_CLIENT_INFO_PB}(struct))
	{
		_ptr_ClientInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.ClientInfo == nil {
				o.ClientInfo = &dhcpm.ClientInfoPB{}
			}
			if err := o.ClientInfo.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ClientInfo := func(ptr interface{}) { o.ClientInfo = *ptr.(**dhcpm.ClientInfoPB) }
		if err := w.ReadPointer(&o.ClientInfo, _s_ClientInfo, _ptr_ClientInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetClientInfoV4Request structure represents the R_DhcpV4GetClientInfo operation request
type GetClientInfoV4Request struct {
	// ServerIpAddress: The IP address of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// SearchInfo: A pointer to a type DHCP_SEARCH_INFO (section 2.2.1.2.18) structure that
	// contains the key to be used to search for the DHCPv4 client lease record on the DHCPv4
	// server. If this parameter's SearchType member is set to DhcpClientName and there
	// are multiple lease records with the same ClientName member, the server returns client
	// information for the client having the lowest numerical IP address.
	SearchInfo *dhcpm.SearchInfo `idl:"name:SearchInfo;pointer:ref" json:"search_info"`
}

func (o *GetClientInfoV4Request) xxx_ToOp(ctx context.Context, op *xxx_GetClientInfoV4Operation) *xxx_GetClientInfoV4Operation {
	if op == nil {
		op = &xxx_GetClientInfoV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.SearchInfo = o.SearchInfo
	return op
}

func (o *GetClientInfoV4Request) xxx_FromOp(ctx context.Context, op *xxx_GetClientInfoV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.SearchInfo = op.SearchInfo
}
func (o *GetClientInfoV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetClientInfoV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetClientInfoV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetClientInfoV4Response structure represents the R_DhcpV4GetClientInfo operation response
type GetClientInfoV4Response struct {
	// ClientInfo: A pointer of type LPDHCP_CLIENT_INFO_PB that points to the location where
	// the DHCPv4 client lease record information will be returned. The caller SHOULD free
	// this buffer. The structure's ClientHardwareAddress member represents a DHCPv4 client
	// unique-identifier as specified in section 2.2.1.2.5.2.
	ClientInfo *dhcpm.ClientInfoPB `idl:"name:ClientInfo" json:"client_info"`
	// Return: The R_DhcpV4GetClientInfo return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetClientInfoV4Response) xxx_ToOp(ctx context.Context, op *xxx_GetClientInfoV4Operation) *xxx_GetClientInfoV4Operation {
	if op == nil {
		op = &xxx_GetClientInfoV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ClientInfo = o.ClientInfo
	op.Return = o.Return
	return op
}

func (o *GetClientInfoV4Response) xxx_FromOp(ctx context.Context, op *xxx_GetClientInfoV4Operation) {
	if o == nil {
		return
	}
	o.ClientInfo = op.ClientInfo
	o.Return = op.Return
}
func (o *GetClientInfoV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetClientInfoV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetClientInfoV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CreateClientInfoV6Operation structure represents the R_DhcpV6CreateClientInfo operation
type xxx_CreateClientInfoV6Operation struct {
	ServerIPAddress string              `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	ClientInfo      *dhcpm.ClientInfoV6 `idl:"name:ClientInfo;pointer:ref" json:"client_info"`
	Return          uint32              `idl:"name:Return" json:"return"`
}

func (o *xxx_CreateClientInfoV6Operation) OpNum() int { return 124 }

func (o *xxx_CreateClientInfoV6Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpV6CreateClientInfo"
}

func (o *xxx_CreateClientInfoV6Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateClientInfoV6Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ClientInfo {in} (1:{pointer=ref, alias=LPDHCP_CLIENT_INFO_V6}*(1))(2:{alias=DHCP_CLIENT_INFO_V6}(struct))
	{
		if o.ClientInfo != nil {
			if err := o.ClientInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.ClientInfoV6{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateClientInfoV6Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ClientInfo {in} (1:{pointer=ref, alias=LPDHCP_CLIENT_INFO_V6}*(1))(2:{alias=DHCP_CLIENT_INFO_V6}(struct))
	{
		if o.ClientInfo == nil {
			o.ClientInfo = &dhcpm.ClientInfoV6{}
		}
		if err := o.ClientInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateClientInfoV6Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateClientInfoV6Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateClientInfoV6Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CreateClientInfoV6Request structure represents the R_DhcpV6CreateClientInfo operation request
type CreateClientInfoV6Request struct {
	// ServerIpAddress: The IP address of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// ClientInfo: A pointer to a DHCP_CLIENT_INFO_V6 (section 2.2.1.2.64) structure that
	// contains the DHCPv6 client lease record information to be set on the DHCPv6 server.
	// The caller MUST pass the ClientIPAddress, ClientDUID, and IAID members when adding
	// a DHCPv6 client lease record to the DHCPv6 server. The ClientDUID member represents
	// a DHCPv6 Client-Identifier as specified in section 2.2.1.2.5.3. The ClientName, ClientComment,
	// ClientLeaseValidLeaseExpires, and OwnerHost members can optionally be passed by the
	// caller and will be set on the DHCPv6 client lease record.
	ClientInfo *dhcpm.ClientInfoV6 `idl:"name:ClientInfo;pointer:ref" json:"client_info"`
}

func (o *CreateClientInfoV6Request) xxx_ToOp(ctx context.Context, op *xxx_CreateClientInfoV6Operation) *xxx_CreateClientInfoV6Operation {
	if op == nil {
		op = &xxx_CreateClientInfoV6Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.ClientInfo = o.ClientInfo
	return op
}

func (o *CreateClientInfoV6Request) xxx_FromOp(ctx context.Context, op *xxx_CreateClientInfoV6Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.ClientInfo = op.ClientInfo
}
func (o *CreateClientInfoV6Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *CreateClientInfoV6Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateClientInfoV6Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CreateClientInfoV6Response structure represents the R_DhcpV6CreateClientInfo operation response
type CreateClientInfoV6Response struct {
	// Return: The R_DhcpV6CreateClientInfo return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CreateClientInfoV6Response) xxx_ToOp(ctx context.Context, op *xxx_CreateClientInfoV6Operation) *xxx_CreateClientInfoV6Operation {
	if op == nil {
		op = &xxx_CreateClientInfoV6Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *CreateClientInfoV6Response) xxx_FromOp(ctx context.Context, op *xxx_CreateClientInfoV6Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *CreateClientInfoV6Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *CreateClientInfoV6Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateClientInfoV6Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_FailoverGetAddressStatusV4Operation structure represents the R_DhcpV4FailoverGetAddressStatus operation
type xxx_FailoverGetAddressStatusV4Operation struct {
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	SubnetAddress   uint32 `idl:"name:SubnetAddress" json:"subnet_address"`
	Status          uint32 `idl:"name:pStatus" json:"status"`
	Return          uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_FailoverGetAddressStatusV4Operation) OpNum() int { return 125 }

func (o *xxx_FailoverGetAddressStatusV4Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpV4FailoverGetAddressStatus"
}

func (o *xxx_FailoverGetAddressStatusV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverGetAddressStatusV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.SubnetAddress); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverGetAddressStatusV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.SubnetAddress); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverGetAddressStatusV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverGetAddressStatusV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pStatus {out} (1:{alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Status); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_FailoverGetAddressStatusV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pStatus {out} (1:{alias=LPDWORD,pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Status); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// FailoverGetAddressStatusV4Request structure represents the R_DhcpV4FailoverGetAddressStatus operation request
type FailoverGetAddressStatusV4Request struct {
	// ServerIpAddress: The IP address of the DHCP server. This parameter is unused.
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// SubnetAddress: This is of type DHCP_IP_ADDRESS (section 2.2.1.2.1) and identifies
	// the IPv4 address the status of which is to be queried.
	SubnetAddress uint32 `idl:"name:SubnetAddress" json:"subnet_address"`
}

func (o *FailoverGetAddressStatusV4Request) xxx_ToOp(ctx context.Context, op *xxx_FailoverGetAddressStatusV4Operation) *xxx_FailoverGetAddressStatusV4Operation {
	if op == nil {
		op = &xxx_FailoverGetAddressStatusV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.SubnetAddress = o.SubnetAddress
	return op
}

func (o *FailoverGetAddressStatusV4Request) xxx_FromOp(ctx context.Context, op *xxx_FailoverGetAddressStatusV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.SubnetAddress = op.SubnetAddress
}
func (o *FailoverGetAddressStatusV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *FailoverGetAddressStatusV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_FailoverGetAddressStatusV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// FailoverGetAddressStatusV4Response structure represents the R_DhcpV4FailoverGetAddressStatus operation response
type FailoverGetAddressStatusV4Response struct {
	// pStatus: The out parameter, which represents the status of the address in the failover
	// relationship.
	Status uint32 `idl:"name:pStatus" json:"status"`
	// Return: The R_DhcpV4FailoverGetAddressStatus return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *FailoverGetAddressStatusV4Response) xxx_ToOp(ctx context.Context, op *xxx_FailoverGetAddressStatusV4Operation) *xxx_FailoverGetAddressStatusV4Operation {
	if op == nil {
		op = &xxx_FailoverGetAddressStatusV4Operation{}
	}
	if o == nil {
		return op
	}
	op.Status = o.Status
	op.Return = o.Return
	return op
}

func (o *FailoverGetAddressStatusV4Response) xxx_FromOp(ctx context.Context, op *xxx_FailoverGetAddressStatusV4Operation) {
	if o == nil {
		return
	}
	o.Status = op.Status
	o.Return = op.Return
}
func (o *FailoverGetAddressStatusV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *FailoverGetAddressStatusV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_FailoverGetAddressStatusV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CreatePolicyExV4Operation structure represents the R_DhcpV4CreatePolicyEx operation
type xxx_CreatePolicyExV4Operation struct {
	ServerIPAddress string          `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Policy          *dhcpm.PolicyEx `idl:"name:pPolicy" json:"policy"`
	Return          uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_CreatePolicyExV4Operation) OpNum() int { return 126 }

func (o *xxx_CreatePolicyExV4Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpV4CreatePolicyEx" }

func (o *xxx_CreatePolicyExV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreatePolicyExV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// pPolicy {in} (1:{alias=LPDHCP_POLICY_EX}*(1))(2:{alias=DHCP_POLICY_EX}(struct))
	{
		if o.Policy != nil {
			if err := o.Policy.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.PolicyEx{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreatePolicyExV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// pPolicy {in} (1:{alias=LPDHCP_POLICY_EX,pointer=ref}*(1))(2:{alias=DHCP_POLICY_EX}(struct))
	{
		if o.Policy == nil {
			o.Policy = &dhcpm.PolicyEx{}
		}
		if err := o.Policy.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreatePolicyExV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreatePolicyExV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreatePolicyExV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CreatePolicyExV4Request structure represents the R_DhcpV4CreatePolicyEx operation request
type CreatePolicyExV4Request struct {
	// ServerIpAddress: As specified in R_DhcpV4CreatePolicy (Opnum 108).
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// pPolicy: A DHCP_POLICY_EX (section 2.2.1.2.121) structure that specifies a list of
	// DHCP_PROPERTY (section 2.2.1.2.117) elements that can be associated with the given
	// policy when creating the policy.
	Policy *dhcpm.PolicyEx `idl:"name:pPolicy" json:"policy"`
}

func (o *CreatePolicyExV4Request) xxx_ToOp(ctx context.Context, op *xxx_CreatePolicyExV4Operation) *xxx_CreatePolicyExV4Operation {
	if op == nil {
		op = &xxx_CreatePolicyExV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Policy = o.Policy
	return op
}

func (o *CreatePolicyExV4Request) xxx_FromOp(ctx context.Context, op *xxx_CreatePolicyExV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Policy = op.Policy
}
func (o *CreatePolicyExV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *CreatePolicyExV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreatePolicyExV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CreatePolicyExV4Response structure represents the R_DhcpV4CreatePolicyEx operation response
type CreatePolicyExV4Response struct {
	// Return: The R_DhcpV4CreatePolicyEx return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CreatePolicyExV4Response) xxx_ToOp(ctx context.Context, op *xxx_CreatePolicyExV4Operation) *xxx_CreatePolicyExV4Operation {
	if op == nil {
		op = &xxx_CreatePolicyExV4Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *CreatePolicyExV4Response) xxx_FromOp(ctx context.Context, op *xxx_CreatePolicyExV4Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *CreatePolicyExV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *CreatePolicyExV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreatePolicyExV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetPolicyExV4Operation structure represents the R_DhcpV4GetPolicyEx operation
type xxx_GetPolicyExV4Operation struct {
	ServerIPAddress string          `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	ServerPolicy    bool            `idl:"name:ServerPolicy" json:"server_policy"`
	SubnetAddress   uint32          `idl:"name:SubnetAddress" json:"subnet_address"`
	PolicyName      string          `idl:"name:PolicyName;string;pointer:unique" json:"policy_name"`
	Policy          *dhcpm.PolicyEx `idl:"name:Policy" json:"policy"`
	Return          uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_GetPolicyExV4Operation) OpNum() int { return 127 }

func (o *xxx_GetPolicyExV4Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpV4GetPolicyEx" }

func (o *xxx_GetPolicyExV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetPolicyExV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ServerPolicy {in} (1:{alias=BOOL}(int32))
	{
		if !o.ServerPolicy {
			if err := w.WriteData(int32(0)); err != nil {
				return err
			}
		} else {
			if err := w.WriteData(int32(1)); err != nil {
				return err
			}
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.SubnetAddress); err != nil {
			return err
		}
	}
	// PolicyName {in} (1:{string, pointer=unique, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.PolicyName != "" {
			_ptr_PolicyName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.PolicyName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.PolicyName, _ptr_PolicyName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetPolicyExV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ServerPolicy {in} (1:{alias=BOOL}(int32))
	{
		var _bServerPolicy int32
		if err := w.ReadData(&_bServerPolicy); err != nil {
			return err
		}
		o.ServerPolicy = _bServerPolicy != 0
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.SubnetAddress); err != nil {
			return err
		}
	}
	// PolicyName {in} (1:{string, pointer=unique, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_PolicyName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.PolicyName); err != nil {
				return err
			}
			return nil
		})
		_s_PolicyName := func(ptr interface{}) { o.PolicyName = *ptr.(*string) }
		if err := w.ReadPointer(&o.PolicyName, _s_PolicyName, _ptr_PolicyName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetPolicyExV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetPolicyExV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Policy {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_POLICY_EX}*(1))(3:{alias=DHCP_POLICY_EX}(struct))
	{
		if o.Policy != nil {
			_ptr_Policy := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Policy != nil {
					if err := o.Policy.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.PolicyEx{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Policy, _ptr_Policy); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetPolicyExV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Policy {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_POLICY_EX,pointer=ref}*(1))(3:{alias=DHCP_POLICY_EX}(struct))
	{
		_ptr_Policy := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Policy == nil {
				o.Policy = &dhcpm.PolicyEx{}
			}
			if err := o.Policy.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_Policy := func(ptr interface{}) { o.Policy = *ptr.(**dhcpm.PolicyEx) }
		if err := w.ReadPointer(&o.Policy, _s_Policy, _ptr_Policy); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetPolicyExV4Request structure represents the R_DhcpV4GetPolicyEx operation request
type GetPolicyExV4Request struct {
	// ServerIpAddress: As specified in R_DhcpV4GetPolicy (Opnum 109).
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// ServerPolicy: As specified in R_DhcpV4GetPolicy (Opnum 109).
	ServerPolicy bool `idl:"name:ServerPolicy" json:"server_policy"`
	// SubnetAddress: As specified in R_DhcpV4GetPolicy (Opnum 109).
	SubnetAddress uint32 `idl:"name:SubnetAddress" json:"subnet_address"`
	// PolicyName: As specified in R_DhcpV4GetPolicy (Opnum 109).
	PolicyName string `idl:"name:PolicyName;string;pointer:unique" json:"policy_name"`
}

func (o *GetPolicyExV4Request) xxx_ToOp(ctx context.Context, op *xxx_GetPolicyExV4Operation) *xxx_GetPolicyExV4Operation {
	if op == nil {
		op = &xxx_GetPolicyExV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.ServerPolicy = o.ServerPolicy
	op.SubnetAddress = o.SubnetAddress
	op.PolicyName = o.PolicyName
	return op
}

func (o *GetPolicyExV4Request) xxx_FromOp(ctx context.Context, op *xxx_GetPolicyExV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.ServerPolicy = op.ServerPolicy
	o.SubnetAddress = op.SubnetAddress
	o.PolicyName = op.PolicyName
}
func (o *GetPolicyExV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetPolicyExV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetPolicyExV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetPolicyExV4Response structure represents the R_DhcpV4GetPolicyEx operation response
type GetPolicyExV4Response struct {
	// Policy: This out parameter is a pointer to a DHCP_POLICY_EX structure and contains
	// the policy data for the requested policy. The DHCP_PROPERTY elements that are queried
	// are as follows:
	Policy *dhcpm.PolicyEx `idl:"name:Policy" json:"policy"`
	// Return: The R_DhcpV4GetPolicyEx return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetPolicyExV4Response) xxx_ToOp(ctx context.Context, op *xxx_GetPolicyExV4Operation) *xxx_GetPolicyExV4Operation {
	if op == nil {
		op = &xxx_GetPolicyExV4Operation{}
	}
	if o == nil {
		return op
	}
	op.Policy = o.Policy
	op.Return = o.Return
	return op
}

func (o *GetPolicyExV4Response) xxx_FromOp(ctx context.Context, op *xxx_GetPolicyExV4Operation) {
	if o == nil {
		return
	}
	o.Policy = op.Policy
	o.Return = op.Return
}
func (o *GetPolicyExV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetPolicyExV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetPolicyExV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetPolicyExV4Operation structure represents the R_DhcpV4SetPolicyEx operation
type xxx_SetPolicyExV4Operation struct {
	ServerIPAddress string          `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	FieldsModified  uint32          `idl:"name:FieldsModified" json:"fields_modified"`
	ServerPolicy    bool            `idl:"name:ServerPolicy" json:"server_policy"`
	SubnetAddress   uint32          `idl:"name:SubnetAddress" json:"subnet_address"`
	PolicyName      string          `idl:"name:PolicyName;string;pointer:unique" json:"policy_name"`
	Policy          *dhcpm.PolicyEx `idl:"name:Policy" json:"policy"`
	Return          uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_SetPolicyExV4Operation) OpNum() int { return 128 }

func (o *xxx_SetPolicyExV4Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpV4SetPolicyEx" }

func (o *xxx_SetPolicyExV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetPolicyExV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// FieldsModified {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.FieldsModified); err != nil {
			return err
		}
	}
	// ServerPolicy {in} (1:{alias=BOOL}(int32))
	{
		if !o.ServerPolicy {
			if err := w.WriteData(int32(0)); err != nil {
				return err
			}
		} else {
			if err := w.WriteData(int32(1)); err != nil {
				return err
			}
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.SubnetAddress); err != nil {
			return err
		}
	}
	// PolicyName {in} (1:{string, pointer=unique, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.PolicyName != "" {
			_ptr_PolicyName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.PolicyName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.PolicyName, _ptr_PolicyName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Policy {in} (1:{alias=LPDHCP_POLICY_EX}*(1))(2:{alias=DHCP_POLICY_EX}(struct))
	{
		if o.Policy != nil {
			if err := o.Policy.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.PolicyEx{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetPolicyExV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// FieldsModified {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.FieldsModified); err != nil {
			return err
		}
	}
	// ServerPolicy {in} (1:{alias=BOOL}(int32))
	{
		var _bServerPolicy int32
		if err := w.ReadData(&_bServerPolicy); err != nil {
			return err
		}
		o.ServerPolicy = _bServerPolicy != 0
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.SubnetAddress); err != nil {
			return err
		}
	}
	// PolicyName {in} (1:{string, pointer=unique, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_PolicyName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.PolicyName); err != nil {
				return err
			}
			return nil
		})
		_s_PolicyName := func(ptr interface{}) { o.PolicyName = *ptr.(*string) }
		if err := w.ReadPointer(&o.PolicyName, _s_PolicyName, _ptr_PolicyName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Policy {in} (1:{alias=LPDHCP_POLICY_EX,pointer=ref}*(1))(2:{alias=DHCP_POLICY_EX}(struct))
	{
		if o.Policy == nil {
			o.Policy = &dhcpm.PolicyEx{}
		}
		if err := o.Policy.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetPolicyExV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetPolicyExV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetPolicyExV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetPolicyExV4Request structure represents the R_DhcpV4SetPolicyEx operation request
type SetPolicyExV4Request struct {
	// ServerIpAddress: As specified in R_DhcpV4SetPolicy (Opnum 110).
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// FieldsModified: As specified in R_DhcpV4SetPolicy (Opnum 110).
	FieldsModified uint32 `idl:"name:FieldsModified" json:"fields_modified"`
	// ServerPolicy: As specified in R_DhcpV4SetPolicy (Opnum 110).
	ServerPolicy bool `idl:"name:ServerPolicy" json:"server_policy"`
	// SubnetAddress: As specified in R_DhcpV4SetPolicy (Opnum 110).
	SubnetAddress uint32 `idl:"name:SubnetAddress" json:"subnet_address"`
	// PolicyName: As specified in R_DhcpV4SetPolicy (Opnum 110).
	PolicyName string `idl:"name:PolicyName;string;pointer:unique" json:"policy_name"`
	// Policy: This is a pointer to a DHCP_POLICY_EX structure and contains the policy data
	// to be modified. The DHCP_PROPERTY elements that are modified are as follows:
	Policy *dhcpm.PolicyEx `idl:"name:Policy" json:"policy"`
}

func (o *SetPolicyExV4Request) xxx_ToOp(ctx context.Context, op *xxx_SetPolicyExV4Operation) *xxx_SetPolicyExV4Operation {
	if op == nil {
		op = &xxx_SetPolicyExV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.FieldsModified = o.FieldsModified
	op.ServerPolicy = o.ServerPolicy
	op.SubnetAddress = o.SubnetAddress
	op.PolicyName = o.PolicyName
	op.Policy = o.Policy
	return op
}

func (o *SetPolicyExV4Request) xxx_FromOp(ctx context.Context, op *xxx_SetPolicyExV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.FieldsModified = op.FieldsModified
	o.ServerPolicy = op.ServerPolicy
	o.SubnetAddress = op.SubnetAddress
	o.PolicyName = op.PolicyName
	o.Policy = op.Policy
}
func (o *SetPolicyExV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetPolicyExV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetPolicyExV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetPolicyExV4Response structure represents the R_DhcpV4SetPolicyEx operation response
type SetPolicyExV4Response struct {
	// Return: The R_DhcpV4SetPolicyEx return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetPolicyExV4Response) xxx_ToOp(ctx context.Context, op *xxx_SetPolicyExV4Operation) *xxx_SetPolicyExV4Operation {
	if op == nil {
		op = &xxx_SetPolicyExV4Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetPolicyExV4Response) xxx_FromOp(ctx context.Context, op *xxx_SetPolicyExV4Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetPolicyExV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetPolicyExV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetPolicyExV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumPoliciesExV4Operation structure represents the R_DhcpV4EnumPoliciesEx operation
type xxx_EnumPoliciesExV4Operation struct {
	ServerIPAddress  string               `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	Resume           uint32               `idl:"name:ResumeHandle" json:"resume"`
	PreferredMaximum uint32               `idl:"name:PreferredMaximum" json:"preferred_maximum"`
	ServerPolicy     bool                 `idl:"name:ServerPolicy" json:"server_policy"`
	SubnetAddress    uint32               `idl:"name:SubnetAddress" json:"subnet_address"`
	EnumInfo         *dhcpm.PolicyExArray `idl:"name:EnumInfo" json:"enum_info"`
	ElementsRead     uint32               `idl:"name:ElementsRead" json:"elements_read"`
	ElementsTotal    uint32               `idl:"name:ElementsTotal" json:"elements_total"`
	Return           uint32               `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumPoliciesExV4Operation) OpNum() int { return 129 }

func (o *xxx_EnumPoliciesExV4Operation) OpName() string { return "/dhcpsrv2/v1/R_DhcpV4EnumPoliciesEx" }

func (o *xxx_EnumPoliciesExV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumPoliciesExV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Resume); err != nil {
			return err
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PreferredMaximum); err != nil {
			return err
		}
	}
	// ServerPolicy {in} (1:{alias=BOOL}(int32))
	{
		if !o.ServerPolicy {
			if err := w.WriteData(int32(0)); err != nil {
				return err
			}
		} else {
			if err := w.WriteData(int32(1)); err != nil {
				return err
			}
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.SubnetAddress); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumPoliciesExV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{alias=LPDWORD,pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Resume); err != nil {
			return err
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PreferredMaximum); err != nil {
			return err
		}
	}
	// ServerPolicy {in} (1:{alias=BOOL}(int32))
	{
		var _bServerPolicy int32
		if err := w.ReadData(&_bServerPolicy); err != nil {
			return err
		}
		o.ServerPolicy = _bServerPolicy != 0
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.SubnetAddress); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumPoliciesExV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumPoliciesExV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ResumeHandle {in, out} (1:{alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Resume); err != nil {
			return err
		}
	}
	// EnumInfo {out} (1:{alias=LPDHCP_POLICY_EX_ARRAY}*(1))(2:{alias=DHCP_POLICY_EX_ARRAY}(struct))
	{
		if o.EnumInfo != nil {
			if err := o.EnumInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.PolicyExArray{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ElementsRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ElementsRead); err != nil {
			return err
		}
	}
	// ElementsTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ElementsTotal); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumPoliciesExV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ResumeHandle {in, out} (1:{alias=LPDWORD,pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Resume); err != nil {
			return err
		}
	}
	// EnumInfo {out} (1:{alias=LPDHCP_POLICY_EX_ARRAY,pointer=ref}*(1))(2:{alias=DHCP_POLICY_EX_ARRAY}(struct))
	{
		if o.EnumInfo == nil {
			o.EnumInfo = &dhcpm.PolicyExArray{}
		}
		if err := o.EnumInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ElementsRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ElementsRead); err != nil {
			return err
		}
	}
	// ElementsTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ElementsTotal); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumPoliciesExV4Request structure represents the R_DhcpV4EnumPoliciesEx operation request
type EnumPoliciesExV4Request struct {
	// ServerIpAddress: As specified in R_DhcpV4EnumPolicies (Opnum 112).
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// ResumeHandle: As specified in R_DhcpV4EnumPolicies (Opnum 112).
	Resume uint32 `idl:"name:ResumeHandle" json:"resume"`
	// PreferredMaximum: As specified in R_DhcpV4EnumPolicies (Opnum 112).
	PreferredMaximum uint32 `idl:"name:PreferredMaximum" json:"preferred_maximum"`
	// ServerPolicy: As specified in R_DhcpV4EnumPolicies (Opnum 112).
	ServerPolicy bool `idl:"name:ServerPolicy" json:"server_policy"`
	// SubnetAddress: As specified in R_DhcpV4EnumPolicies (Opnum 112).
	SubnetAddress uint32 `idl:"name:SubnetAddress" json:"subnet_address"`
}

func (o *EnumPoliciesExV4Request) xxx_ToOp(ctx context.Context, op *xxx_EnumPoliciesExV4Operation) *xxx_EnumPoliciesExV4Operation {
	if op == nil {
		op = &xxx_EnumPoliciesExV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.Resume = o.Resume
	op.PreferredMaximum = o.PreferredMaximum
	op.ServerPolicy = o.ServerPolicy
	op.SubnetAddress = o.SubnetAddress
	return op
}

func (o *EnumPoliciesExV4Request) xxx_FromOp(ctx context.Context, op *xxx_EnumPoliciesExV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.Resume = op.Resume
	o.PreferredMaximum = op.PreferredMaximum
	o.ServerPolicy = op.ServerPolicy
	o.SubnetAddress = op.SubnetAddress
}
func (o *EnumPoliciesExV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumPoliciesExV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumPoliciesExV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumPoliciesExV4Response structure represents the R_DhcpV4EnumPoliciesEx operation response
type EnumPoliciesExV4Response struct {
	// ResumeHandle: As specified in R_DhcpV4EnumPolicies (Opnum 112).
	Resume uint32 `idl:"name:ResumeHandle" json:"resume"`
	// EnumInfo: This out parameter contains an array of DHCP_POLICY_EX structures containing
	// an enumerated list of all configured server-level or scope-level policies for the
	// given property. The DHCP_PROPERTY elements that are enumerated are as follows:
	EnumInfo *dhcpm.PolicyExArray `idl:"name:EnumInfo" json:"enum_info"`
	// ElementsRead: As specified in R_DhcpV4EnumPolicies (Opnum 112).
	ElementsRead uint32 `idl:"name:ElementsRead" json:"elements_read"`
	// ElementsTotal: As specified in R_DhcpV4EnumPolicies (Opnum 112).
	ElementsTotal uint32 `idl:"name:ElementsTotal" json:"elements_total"`
	// Return: The R_DhcpV4EnumPoliciesEx return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumPoliciesExV4Response) xxx_ToOp(ctx context.Context, op *xxx_EnumPoliciesExV4Operation) *xxx_EnumPoliciesExV4Operation {
	if op == nil {
		op = &xxx_EnumPoliciesExV4Operation{}
	}
	if o == nil {
		return op
	}
	op.Resume = o.Resume
	op.EnumInfo = o.EnumInfo
	op.ElementsRead = o.ElementsRead
	op.ElementsTotal = o.ElementsTotal
	op.Return = o.Return
	return op
}

func (o *EnumPoliciesExV4Response) xxx_FromOp(ctx context.Context, op *xxx_EnumPoliciesExV4Operation) {
	if o == nil {
		return
	}
	o.Resume = op.Resume
	o.EnumInfo = op.EnumInfo
	o.ElementsRead = op.ElementsRead
	o.ElementsTotal = op.ElementsTotal
	o.Return = op.Return
}
func (o *EnumPoliciesExV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumPoliciesExV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumPoliciesExV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumSubnetClientsExV4Operation structure represents the R_DhcpV4EnumSubnetClientsEx operation
type xxx_EnumSubnetClientsExV4Operation struct {
	ServerIPAddress  string                   `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	SubnetAddress    uint32                   `idl:"name:SubnetAddress" json:"subnet_address"`
	Resume           uint32                   `idl:"name:ResumeHandle" json:"resume"`
	PreferredMaximum uint32                   `idl:"name:PreferredMaximum" json:"preferred_maximum"`
	ClientInfo       *dhcpm.ClientInfoExArray `idl:"name:ClientInfo" json:"client_info"`
	ClientsRead      uint32                   `idl:"name:ClientsRead" json:"clients_read"`
	ClientsTotal     uint32                   `idl:"name:ClientsTotal" json:"clients_total"`
	Return           uint32                   `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumSubnetClientsExV4Operation) OpNum() int { return 130 }

func (o *xxx_EnumSubnetClientsExV4Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpV4EnumSubnetClientsEx"
}

func (o *xxx_EnumSubnetClientsExV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetClientsExV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.SubnetAddress); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Resume); err != nil {
			return err
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PreferredMaximum); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetClientsExV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// SubnetAddress {in} (1:{alias=DHCP_IP_ADDRESS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.SubnetAddress); err != nil {
			return err
		}
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Resume); err != nil {
			return err
		}
	}
	// PreferredMaximum {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PreferredMaximum); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetClientsExV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetClientsExV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Resume); err != nil {
			return err
		}
	}
	// ClientInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_CLIENT_INFO_EX_ARRAY}*(1))(3:{alias=DHCP_CLIENT_INFO_EX_ARRAY}(struct))
	{
		if o.ClientInfo != nil {
			_ptr_ClientInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.ClientInfo != nil {
					if err := o.ClientInfo.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.ClientInfoExArray{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ClientInfo, _ptr_ClientInfo); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ClientsRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ClientsRead); err != nil {
			return err
		}
	}
	// ClientsTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ClientsTotal); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumSubnetClientsExV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ResumeHandle {in, out} (1:{pointer=ref}*(1))(2:{alias=DHCP_RESUME_HANDLE, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Resume); err != nil {
			return err
		}
	}
	// ClientInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_CLIENT_INFO_EX_ARRAY,pointer=ref}*(1))(3:{alias=DHCP_CLIENT_INFO_EX_ARRAY}(struct))
	{
		_ptr_ClientInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.ClientInfo == nil {
				o.ClientInfo = &dhcpm.ClientInfoExArray{}
			}
			if err := o.ClientInfo.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ClientInfo := func(ptr interface{}) { o.ClientInfo = *ptr.(**dhcpm.ClientInfoExArray) }
		if err := w.ReadPointer(&o.ClientInfo, _s_ClientInfo, _ptr_ClientInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ClientsRead {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ClientsRead); err != nil {
			return err
		}
	}
	// ClientsTotal {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ClientsTotal); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumSubnetClientsExV4Request structure represents the R_DhcpV4EnumSubnetClientsEx operation request
type EnumSubnetClientsExV4Request struct {
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// SubnetAddress: As specified in R_DhcpV4EnumSubnetClients (Opnum 115).
	SubnetAddress uint32 `idl:"name:SubnetAddress" json:"subnet_address"`
	// ResumeHandle: As specified in R_DhcpV4EnumSubnetClients (Opnum 115).
	Resume uint32 `idl:"name:ResumeHandle" json:"resume"`
	// PreferredMaximum: As specified in R_DhcpV4EnumSubnetClients (Opnum 115).
	PreferredMaximum uint32 `idl:"name:PreferredMaximum" json:"preferred_maximum"`
}

func (o *EnumSubnetClientsExV4Request) xxx_ToOp(ctx context.Context, op *xxx_EnumSubnetClientsExV4Operation) *xxx_EnumSubnetClientsExV4Operation {
	if op == nil {
		op = &xxx_EnumSubnetClientsExV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.SubnetAddress = o.SubnetAddress
	op.Resume = o.Resume
	op.PreferredMaximum = o.PreferredMaximum
	return op
}

func (o *EnumSubnetClientsExV4Request) xxx_FromOp(ctx context.Context, op *xxx_EnumSubnetClientsExV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.SubnetAddress = op.SubnetAddress
	o.Resume = op.Resume
	o.PreferredMaximum = op.PreferredMaximum
}
func (o *EnumSubnetClientsExV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumSubnetClientsExV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumSubnetClientsExV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumSubnetClientsExV4Response structure represents the R_DhcpV4EnumSubnetClientsEx operation response
type EnumSubnetClientsExV4Response struct {
	// ResumeHandle: As specified in R_DhcpV4EnumSubnetClients (Opnum 115).
	Resume uint32 `idl:"name:ResumeHandle" json:"resume"`
	// ClientInfo: A pointer to an array of DHCPv4 client lease records. This out parameter
	// contains an array of DHCP_CLIENT_INFO_EX structures containing DHCPv4 client lease
	// records. The DHCP_PROPERTY (section 2.2.1.2.117) elements that are enumerated are
	// as follows:
	ClientInfo *dhcpm.ClientInfoExArray `idl:"name:ClientInfo" json:"client_info"`
	// ClientsRead: As specified in R_DhcpV4EnumSubnetClients (Opnum 115).
	ClientsRead uint32 `idl:"name:ClientsRead" json:"clients_read"`
	// ClientsTotal: As specified in R_DhcpV4EnumSubnetClients (Opnum 115).
	ClientsTotal uint32 `idl:"name:ClientsTotal" json:"clients_total"`
	// Return: The R_DhcpV4EnumSubnetClientsEx return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumSubnetClientsExV4Response) xxx_ToOp(ctx context.Context, op *xxx_EnumSubnetClientsExV4Operation) *xxx_EnumSubnetClientsExV4Operation {
	if op == nil {
		op = &xxx_EnumSubnetClientsExV4Operation{}
	}
	if o == nil {
		return op
	}
	op.Resume = o.Resume
	op.ClientInfo = o.ClientInfo
	op.ClientsRead = o.ClientsRead
	op.ClientsTotal = o.ClientsTotal
	op.Return = o.Return
	return op
}

func (o *EnumSubnetClientsExV4Response) xxx_FromOp(ctx context.Context, op *xxx_EnumSubnetClientsExV4Operation) {
	if o == nil {
		return
	}
	o.Resume = op.Resume
	o.ClientInfo = op.ClientInfo
	o.ClientsRead = op.ClientsRead
	o.ClientsTotal = op.ClientsTotal
	o.Return = op.Return
}
func (o *EnumSubnetClientsExV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumSubnetClientsExV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumSubnetClientsExV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_CreateClientInfoExV4Operation structure represents the R_DhcpV4CreateClientInfoEx operation
type xxx_CreateClientInfoExV4Operation struct {
	ServerIPAddress string              `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	ClientInfo      *dhcpm.ClientInfoEx `idl:"name:ClientInfo;pointer:ref" json:"client_info"`
	Return          uint32              `idl:"name:Return" json:"return"`
}

func (o *xxx_CreateClientInfoExV4Operation) OpNum() int { return 131 }

func (o *xxx_CreateClientInfoExV4Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpV4CreateClientInfoEx"
}

func (o *xxx_CreateClientInfoExV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateClientInfoExV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ClientInfo {in} (1:{pointer=ref, alias=LPDHCP_CLIENT_INFO_EX}*(1))(2:{alias=DHCP_CLIENT_INFO_EX}(struct))
	{
		if o.ClientInfo != nil {
			if err := o.ClientInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.ClientInfoEx{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateClientInfoExV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ClientInfo {in} (1:{pointer=ref, alias=LPDHCP_CLIENT_INFO_EX}*(1))(2:{alias=DHCP_CLIENT_INFO_EX}(struct))
	{
		if o.ClientInfo == nil {
			o.ClientInfo = &dhcpm.ClientInfoEx{}
		}
		if err := o.ClientInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateClientInfoExV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateClientInfoExV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_CreateClientInfoExV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// CreateClientInfoExV4Request structure represents the R_DhcpV4CreateClientInfoEx operation request
type CreateClientInfoExV4Request struct {
	// ServerIpAddress: As specified in R_DhcpV4CreateClientInfo (Opnum 122).
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// ClientInfo: A pointer to a DHCP_CLIENT_INFO_EX structure that contains the DHCPv4
	// client lease record information to be set on the DHCPv4 server. The caller MUST pass
	// the ClientIPAddress and ClientHardwareAddress members when adding a DHCPv4 client
	// lease record to the DHCPv4 server. The ClientHardwareAddress member represents a
	// DHCPv4 client-identifier as specified in section 2.2.1.2.5.1. The ClientName, ClientComment,
	// ClientLeaseExpires, bClientType, AddressState, Status, ProbationEnds, QuarantineCapable,
	// PolicyName, and OwnerHost members are modified on the DHCPv4 client lease record
	// identified by the ClientIpAddress member. <89>
	//
	// The DHCP_PROPERTY elements that are supported are as follows:
	//
	// The opnum field value for this method is 131.
	//
	// The remainder of the processing behavior for this method is as defined for the R_DhcpV4CreateClientInfo
	// method.
	ClientInfo *dhcpm.ClientInfoEx `idl:"name:ClientInfo;pointer:ref" json:"client_info"`
}

func (o *CreateClientInfoExV4Request) xxx_ToOp(ctx context.Context, op *xxx_CreateClientInfoExV4Operation) *xxx_CreateClientInfoExV4Operation {
	if op == nil {
		op = &xxx_CreateClientInfoExV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.ClientInfo = o.ClientInfo
	return op
}

func (o *CreateClientInfoExV4Request) xxx_FromOp(ctx context.Context, op *xxx_CreateClientInfoExV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.ClientInfo = op.ClientInfo
}
func (o *CreateClientInfoExV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *CreateClientInfoExV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateClientInfoExV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// CreateClientInfoExV4Response structure represents the R_DhcpV4CreateClientInfoEx operation response
type CreateClientInfoExV4Response struct {
	// Return: The R_DhcpV4CreateClientInfoEx return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *CreateClientInfoExV4Response) xxx_ToOp(ctx context.Context, op *xxx_CreateClientInfoExV4Operation) *xxx_CreateClientInfoExV4Operation {
	if op == nil {
		op = &xxx_CreateClientInfoExV4Operation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *CreateClientInfoExV4Response) xxx_FromOp(ctx context.Context, op *xxx_CreateClientInfoExV4Operation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *CreateClientInfoExV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *CreateClientInfoExV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_CreateClientInfoExV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetClientInfoExV4Operation structure represents the R_DhcpV4GetClientInfoEx operation
type xxx_GetClientInfoExV4Operation struct {
	ServerIPAddress string              `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	SearchInfo      *dhcpm.SearchInfo   `idl:"name:SearchInfo;pointer:ref" json:"search_info"`
	ClientInfo      *dhcpm.ClientInfoEx `idl:"name:ClientInfo" json:"client_info"`
	Return          uint32              `idl:"name:Return" json:"return"`
}

func (o *xxx_GetClientInfoExV4Operation) OpNum() int { return 132 }

func (o *xxx_GetClientInfoExV4Operation) OpName() string {
	return "/dhcpsrv2/v1/R_DhcpV4GetClientInfoEx"
}

func (o *xxx_GetClientInfoExV4Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetClientInfoExV4Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerIPAddress != "" {
			_ptr_ServerIpAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerIPAddress); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerIPAddress, _ptr_ServerIpAddress); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// SearchInfo {in} (1:{pointer=ref, alias=LPDHCP_SEARCH_INFO}*(1))(2:{alias=DHCP_SEARCH_INFO}(struct))
	{
		if o.SearchInfo != nil {
			if err := o.SearchInfo.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&dhcpm.SearchInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetClientInfoExV4Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerIpAddress {in} (1:{handle, string, pointer=unique, alias=DHCP_SRV_HANDLE, names=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerIpAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerIPAddress); err != nil {
				return err
			}
			return nil
		})
		_s_ServerIpAddress := func(ptr interface{}) { o.ServerIPAddress = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerIPAddress, _s_ServerIpAddress, _ptr_ServerIpAddress); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// SearchInfo {in} (1:{pointer=ref, alias=LPDHCP_SEARCH_INFO}*(1))(2:{alias=DHCP_SEARCH_INFO}(struct))
	{
		if o.SearchInfo == nil {
			o.SearchInfo = &dhcpm.SearchInfo{}
		}
		if err := o.SearchInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetClientInfoExV4Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetClientInfoExV4Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ClientInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_CLIENT_INFO_EX}*(1))(3:{alias=DHCP_CLIENT_INFO_EX}(struct))
	{
		if o.ClientInfo != nil {
			_ptr_ClientInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.ClientInfo != nil {
					if err := o.ClientInfo.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dhcpm.ClientInfoEx{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ClientInfo, _ptr_ClientInfo); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetClientInfoExV4Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ClientInfo {out} (1:{pointer=ref}*(2))(2:{alias=LPDHCP_CLIENT_INFO_EX,pointer=ref}*(1))(3:{alias=DHCP_CLIENT_INFO_EX}(struct))
	{
		_ptr_ClientInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.ClientInfo == nil {
				o.ClientInfo = &dhcpm.ClientInfoEx{}
			}
			if err := o.ClientInfo.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ClientInfo := func(ptr interface{}) { o.ClientInfo = *ptr.(**dhcpm.ClientInfoEx) }
		if err := w.ReadPointer(&o.ClientInfo, _s_ClientInfo, _ptr_ClientInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetClientInfoExV4Request structure represents the R_DhcpV4GetClientInfoEx operation request
type GetClientInfoExV4Request struct {
	// ServerIpAddress: As specified in R_DhcpV4GetClientInfo (Opnum 123).
	ServerIPAddress string `idl:"name:ServerIpAddress;string;pointer:unique" json:"server_ip_address"`
	// SearchInfo: As specified in R_DhcpV4GetClientInfo (Opnum 123).
	SearchInfo *dhcpm.SearchInfo `idl:"name:SearchInfo;pointer:ref" json:"search_info"`
}

func (o *GetClientInfoExV4Request) xxx_ToOp(ctx context.Context, op *xxx_GetClientInfoExV4Operation) *xxx_GetClientInfoExV4Operation {
	if op == nil {
		op = &xxx_GetClientInfoExV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerIPAddress = o.ServerIPAddress
	op.SearchInfo = o.SearchInfo
	return op
}

func (o *GetClientInfoExV4Request) xxx_FromOp(ctx context.Context, op *xxx_GetClientInfoExV4Operation) {
	if o == nil {
		return
	}
	o.ServerIPAddress = op.ServerIPAddress
	o.SearchInfo = op.SearchInfo
}
func (o *GetClientInfoExV4Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetClientInfoExV4Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetClientInfoExV4Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetClientInfoExV4Response structure represents the R_DhcpV4GetClientInfoEx operation response
type GetClientInfoExV4Response struct {
	// ClientInfo: A pointer of type LPDHCP_CLIENT_INFO_EX that points to the location where
	// the DHCPv4 client lease record information will be returned. The caller SHOULD free
	// this buffer. The structure's ClientHardwareAddress member represents a DHCPv4 client
	// unique-identifier as specified in section 2.2.1.2.5.2.
	//
	// The DHCP_PROPERTY (section 2.2.1.2.117) elements that are queried are as follows:
	ClientInfo *dhcpm.ClientInfoEx `idl:"name:ClientInfo" json:"client_info"`
	// Return: The R_DhcpV4GetClientInfoEx return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetClientInfoExV4Response) xxx_ToOp(ctx context.Context, op *xxx_GetClientInfoExV4Operation) *xxx_GetClientInfoExV4Operation {
	if op == nil {
		op = &xxx_GetClientInfoExV4Operation{}
	}
	if o == nil {
		return op
	}
	op.ClientInfo = o.ClientInfo
	op.Return = o.Return
	return op
}

func (o *GetClientInfoExV4Response) xxx_FromOp(ctx context.Context, op *xxx_GetClientInfoExV4Operation) {
	if o == nil {
		return
	}
	o.ClientInfo = op.ClientInfo
	o.Return = op.Return
}
func (o *GetClientInfoExV4Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetClientInfoExV4Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetClientInfoExV4Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}
