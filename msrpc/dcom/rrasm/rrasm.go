// The rrasm package implements the RRASM client protocol.
//
// # Introduction
//
// The routing and remote access service (RRAS) server management (RRASM) protocol enables
// remote management (configuration and monitoring) of a RRAS implementation. The RRAS
// implementation here refers to the components that can be configured to provide the
// following functionality:
//
// * Routing
//
// * Remote access service
//
// * Site-to-site connectivity
//
// The RRASM protocol is a client/server protocol based on remote procedure call (RPC).
// It comprises RPC methods that enable the remote management of an RRAS implementation.
//
// It also specifies Distributed Component Object Model (DCOM) interfaces that enable
// the remote management of RRAS implementation. As a part of remote management of RRAS
// implementation, a management application uses the RPC and DCOM methods to manage
// the RRAS implementation actively (while RRAS is running).
//
// This protocol also specifies the registry information that can be used to specify
// the overall RRAS configuration. These registry settings can be managed remotely using
// the [MS-RRP] protocol. When RRAS is not active, the configurations are managed through
// the registry information.
//
// Additionally, for site-to-site connectivity, the settings to be used to connect to
// a remote site are specified in the form of a phonebook file. This protocol also specifies
// the format of the phonebook file used by RRAS server. The management application
// can use the phonebook file format to specify the connection configuration to be used
// for site-to-site connections.
//
// The client-side Remote Access Service (RAS) is a point-to-point or point-to-site
// service that is not in the RRASM protocol. See legacy information in [MSDOCS-RRAS]
// and [MSDOCS-RA-API]. RAS client uses a different phonebook file; see legacy information
// in [MSDOCS-RASpbk].
//
// # Overview
//
// The routing and remote access service (RRAS) server management (RRASM) protocol enables
// remote management (configuration and monitoring) of RRAS routers. This protocol exposes
// the RRAS management data objects (described in sections 1.3.1, 1.3.2, 1.3.3, 1.3.4,
// and 1.3.5) and the methods to manage these objects remotely. An RRAS implementation
// that exposes its configuration in the form of these objects and methods can be managed
// remotely using the RRASM protocol. The RRASM protocol is responsible for providing
// the remote management capability only. The way the management objects are used in
// order to provide RRAS functionality, is specific to the RRAS implementation and is
// outside the scope of this protocol.
//
// The remote procedure call (RPC) protocol provides the mechanism to define methods
// and data structures that are passed as parameters to these methods. It also provides
// the underlying with which these methods can be invoked remotely as well as the data
// passed as parameters.
//
// This document, in addition, specifies the registry keys and values that can be used
// to specify an RRAS server configuration. These registry keys can be remotely configured
// using the [MS-RRP] protocol. They form the initial configuration for the RRAS implementation.
// Runtime configuration changes are done through the RPC protocol itself. An RRAS implementation
// that understands these registry keys and realizes their intended semantics can then
// be configured remotely using the [MS-RRP] protocol.
//
// This document also specifies the format of the phonebook file that can be used to
// specify site-to-site connection settings. An RRAS implementation that understands
// the semantics of this phonebook file can then be configured to provide site-to-site
// connectivity. The phonebook file can be created remotely at a well-known location
// using any remote file management mechanism such as the Server Message Block (SMB)
// protocol. The RRAS implementation can read the settings and realize the configuration
// based on the semantics specified.
//
// The client-side Remote Access Service (RAS) is a point-to-point or point-to-site
// service that is not in this RRASM protocol server site-to-site router remote access
// service. See legacy information in [MSDOCS-RRAS] and [MSDOCS-ROUT-API]. Some of the
// functions in the RAS API are supported only on network servers, and other functions
// are supported only on network clients. See legacy information in [MSDOCS-RA-API].
// RAS client uses a different phonebook file; see legacy information in [MSDOCS-RASpbk].
//
// The interaction between a RRASM client and a RRASM server itself is stateless and
// is accomplished through RPC method invocation. Each RPC method request is independent
// of others and no context is maintained by RRASM pertaining to the sequence of operations.
// Each method involves passing of certain parameters from the RRASM client to the RRAS
// implementation through the RRASM RPC server. The RRAS server performs the required
// operation locally in response to the RPC method request and provides the result of
// the operation to the RRASM server in the form of result information and associated
// data. The RRASM server is responsible for transporting the result information and
// the data associated, back to the client that originated the request. This request-response
// mechanism is provided by the RPC protocol as defined in [MS-RPCE]. In a nutshell,
// the RRASM client and server act as the endpoints providing remote communication to
// the RRAS implementation which already has these objects defined and managed locally.
//
// The following two figures respectively show the Client/server message exchange and
// the RRAS conceptual model.
package rrasm

import (
	"context"
	"fmt"
	"strings"
	"unicode/utf16"

	dcerpc "github.com/oiweiwei/go-msrpc/dcerpc"
	errors "github.com/oiweiwei/go-msrpc/dcerpc/errors"
	uuid "github.com/oiweiwei/go-msrpc/midl/uuid"
	dcom "github.com/oiweiwei/go-msrpc/msrpc/dcom"
	dtyp "github.com/oiweiwei/go-msrpc/msrpc/dtyp"
	ndr "github.com/oiweiwei/go-msrpc/ndr"
)

var (
	_ = context.Background
	_ = fmt.Errorf
	_ = utf16.Encode
	_ = strings.TrimPrefix
	_ = ndr.ZeroString
	_ = (*uuid.UUID)(nil)
	_ = (*dcerpc.SyntaxID)(nil)
	_ = (*errors.Error)(nil)
	_ = dtyp.GoPackage
	_ = dcom.GoPackage
)

var (
	// import guard
	GoPackage = "dcom/rrasm"
)

// MaxSSTPHashSize represents the MAX_SSTP_HASH_SIZE RPC constant
var MaxSSTPHashSize = 32

// MaxGroupLength represents the MAX_GROUP_LEN RPC constant
var MaxGroupLength = 64

// MaxAdaptorNameLength represents the MAX_ADAPTOR_NAME_LEN RPC constant
var MaxAdaptorNameLength = 48

// MaxEntryName represents the RASRPC_MaxEntryName RPC constant
var MaxEntryName = 256

// MaxPortName represents the RASRPC_MaxPortName RPC constant
var MaxPortName = 16

// MaxDeviceName represents the RASRPC_MaxDeviceName RPC constant
var MaxDeviceName = 128

// MaxPhoneNumber represents the RASRPC_MaxPhoneNumber RPC constant
var MaxPhoneNumber = 128

// MaxPath represents the RASRPC_MAX_PATH RPC constant
var MaxPath = 260

// RouterInterfaceType type represents ROUTER_INTERFACE_TYPE RPC enumeration.
//
// The ROUTER_INTERFACE_TYPE type enumerates the different kinds of interfaces on the
// RRAS server.
type RouterInterfaceType uint16

var (
	// ROUTER_IF_TYPE_CLIENT: The interface is for a remote access client.
	RouterInterfaceTypeClient RouterInterfaceType = 0
	// ROUTER_IF_TYPE_HOME_ROUTER: The interface is for a home RRAS server or a one-way
	// initiated demand-dial interface. With one-way initiated connections, one router is
	// always the answering router and the other router is always the calling router [MSFT-ROUTING].
	RouterInterfaceTypeHomeRouter RouterInterfaceType = 1
	// ROUTER_IF_TYPE_FULL_ROUTER: The interface is for a full router or a two-way initiated
	// demand-dial interface. With two-way initiated connections, either router can be the
	// answering router or the calling router, depending on which router initiates the connection
	// [MSFT-ROUTING].
	RouterInterfaceTypeFullRouter RouterInterfaceType = 2
	// ROUTER_IF_TYPE_DEDICATED: The interface is always connected. It is a LAN interface,
	// or the interface is connected over a leased line.
	RouterInterfaceTypeDedicated RouterInterfaceType = 3
	// ROUTER_IF_TYPE_INTERNAL: The interface is an internal-only interface.
	RouterInterfaceTypeInternal RouterInterfaceType = 4
	// ROUTER_IF_TYPE_LOOPBACK: The interface is a loopback interface.
	RouterInterfaceTypeLoopback RouterInterfaceType = 5
	// ROUTER_IF_TYPE_TUNNEL1: The interface is an IP in IP tunnel.<9>
	RouterInterfaceTypeTunnel1 RouterInterfaceType = 6
	// ROUTER_IF_TYPE_DIALOUT: The interface is a demand-dial interface [MSFT-ROUTING].
	RouterInterfaceTypeDialout RouterInterfaceType = 7
)

func (o RouterInterfaceType) String() string {
	switch o {
	case RouterInterfaceTypeClient:
		return "RouterInterfaceTypeClient"
	case RouterInterfaceTypeHomeRouter:
		return "RouterInterfaceTypeHomeRouter"
	case RouterInterfaceTypeFullRouter:
		return "RouterInterfaceTypeFullRouter"
	case RouterInterfaceTypeDedicated:
		return "RouterInterfaceTypeDedicated"
	case RouterInterfaceTypeInternal:
		return "RouterInterfaceTypeInternal"
	case RouterInterfaceTypeLoopback:
		return "RouterInterfaceTypeLoopback"
	case RouterInterfaceTypeTunnel1:
		return "RouterInterfaceTypeTunnel1"
	case RouterInterfaceTypeDialout:
		return "RouterInterfaceTypeDialout"
	}
	return "Invalid"
}

// RouterConnectionState type represents ROUTER_CONNECTION_STATE RPC enumeration.
//
// The ROUTER_CONNECTION_STATE type enumerates the possible states of an interface on
// the RRAS server.
type RouterConnectionState uint16

var (
	// ROUTER_IF_STATE_UNREACHABLE: The interface is unreachable.
	RouterConnectionStateInterfaceStateUnreachable RouterConnectionState = 0
	// ROUTER_IF_STATE_DISCONNECTED: The interface is reachable but disconnected.
	RouterConnectionStateInterfaceStateDisconnected RouterConnectionState = 1
	// ROUTER_IF_STATE_CONNECTING: The interface is in the process of connecting.
	RouterConnectionStateInterfaceStateConnecting RouterConnectionState = 2
	// ROUTER_IF_STATE_CONNECTED: The interface is connected.
	RouterConnectionStateInterfaceStateConnected RouterConnectionState = 3
)

func (o RouterConnectionState) String() string {
	switch o {
	case RouterConnectionStateInterfaceStateUnreachable:
		return "RouterConnectionStateInterfaceStateUnreachable"
	case RouterConnectionStateInterfaceStateDisconnected:
		return "RouterConnectionStateInterfaceStateDisconnected"
	case RouterConnectionStateInterfaceStateConnecting:
		return "RouterConnectionStateInterfaceStateConnecting"
	case RouterConnectionStateInterfaceStateConnected:
		return "RouterConnectionStateInterfaceStateConnected"
	}
	return "Invalid"
}

// RASQuarantineState type represents RAS_QUARANTINE_STATE RPC enumeration.
//
// The RAS_QUARANTINE_STATE enumerated type indicates the quarantine state of a client
// connection [MS-RNAP]. For more information, see [MSDN-NAP].
type RASQuarantineState uint16

var (
	// RAS_QUAR_STATE_NORMAL: The connection state is normal.
	RASQuarantineStateNormal RASQuarantineState = 0
	// RAS_QUAR_STATE_QUARANTINE: The connection is quarantined, meaning that the client
	// did not meet the health requirements [MS-RNAP] and therefore, its access is restricted
	// to specific servers.
	RASQuarantineStateQuarantine RASQuarantineState = 1
	// RAS_QUAR_STATE_PROBATION: The connection is in probation, meaning that the client
	// is not healthy [MS-RNAP] and needs to become healthy within a specified duration.
	RASQuarantineStateProbation RASQuarantineState = 2
	// RAS_QUAR_STATE_UNKNOWN: The connection state is unknown.
	RASQuarantineStateUnknown RASQuarantineState = 3
)

func (o RASQuarantineState) String() string {
	switch o {
	case RASQuarantineStateNormal:
		return "RASQuarantineStateNormal"
	case RASQuarantineStateQuarantine:
		return "RASQuarantineStateQuarantine"
	case RASQuarantineStateProbation:
		return "RASQuarantineStateProbation"
	case RASQuarantineStateUnknown:
		return "RASQuarantineStateUnknown"
	}
	return "Invalid"
}

// RASPortCondition type represents RAS_PORT_CONDITION RPC enumeration.
//
// The RAS_PORT_CONDITION enumerated type specifies information regarding the connection
// condition of a given RAS port.
type RASPortCondition uint16

var (
	// RAS_PORT_NON_OPERATIONAL: The port is non-operational.
	RASPortConditionNonOperational RASPortCondition = 0
	// RAS_PORT_DISCONNECTED: The port is disconnected.
	RASPortConditionDisconnected RASPortCondition = 1
	// RAS_PORT_CALLING_BACK: The port is in the process of a calling back a dialed connection.
	RASPortConditionCallingBack RASPortCondition = 2
	// RAS_PORT_LISTENING: The port is listening for incoming calls.
	RASPortConditionListening RASPortCondition = 3
	// RAS_PORT_AUTHENTICATING: The user connected to the port is being authenticated.
	RASPortConditionAuthenticating RASPortCondition = 4
	// RAS_PORT_AUTHENTICATED: The port has authenticated a user.
	RASPortConditionAuthenticated RASPortCondition = 5
	// RAS_PORT_INITIALIZING: The port is initializing.
	RASPortConditionInitializing RASPortCondition = 6
)

func (o RASPortCondition) String() string {
	switch o {
	case RASPortConditionNonOperational:
		return "RASPortConditionNonOperational"
	case RASPortConditionDisconnected:
		return "RASPortConditionDisconnected"
	case RASPortConditionCallingBack:
		return "RASPortConditionCallingBack"
	case RASPortConditionListening:
		return "RASPortConditionListening"
	case RASPortConditionAuthenticating:
		return "RASPortConditionAuthenticating"
	case RASPortConditionAuthenticated:
		return "RASPortConditionAuthenticated"
	case RASPortConditionInitializing:
		return "RASPortConditionInitializing"
	}
	return "Invalid"
}

// RASHardwareCondition type represents RAS_HARDWARE_CONDITION RPC enumeration.
//
// The RAS_HARDWARE_CONDITION enumeration type specifies hardware status information
// about a given RAS port.
type RASHardwareCondition uint16

var (
	// RAS_HARDWARE_OPERATIONAL: The hardware attached to this RAS port is operational and
	// is ready to receive client calls.
	RASHardwareConditionOperational RASHardwareCondition = 0
	// RAS_HARDWARE_FAILURE: The hardware attached to this RAS port has failed.
	RASHardwareConditionFailure RASHardwareCondition = 1
)

func (o RASHardwareCondition) String() string {
	switch o {
	case RASHardwareConditionOperational:
		return "RASHardwareConditionOperational"
	case RASHardwareConditionFailure:
		return "RASHardwareConditionFailure"
	}
	return "Invalid"
}

// ForwardAction type represents FORWARD_ACTION RPC enumeration.
//
// The FORWARD_ACTION enumeration type specifies the type of action to be taken in a
// filter.
type ForwardAction uint16

var (
	// FORWARD: Allows the traffic to pass through the filter.
	ForwardActionForward ForwardAction = 0
	// DROP: Does not allow the traffic to pass through the filter: drops the traffic.
	ForwardActionDrop ForwardAction = 1
)

func (o ForwardAction) String() string {
	switch o {
	case ForwardActionForward:
		return "ForwardActionForward"
	case ForwardActionDrop:
		return "ForwardActionDrop"
	}
	return "Invalid"
}

// MIBIPForwardType type represents MIB_IPFORWARD_TYPE RPC enumeration.
//
// The MIB_IPFORWARD_TYPE enumeration type specifies the type of the IP route.
type MIBIPForwardType uint16

var (
	// MIB_IPROUTE_TYPE_OTHER: Other than the type specified in [RFC1354].
	MIBIPForwardTypeRouteTypeOther MIBIPForwardType = 1
	// MIB_IPROUTE_TYPE_INVALID: An invalid route is deleted.
	MIBIPForwardTypeRouteTypeInvalid MIBIPForwardType = 2
	// MIB_IPROUTE_TYPE_DIRECT: A local route where the next hop is the final destination
	// (a local interface).
	MIBIPForwardTypeRouteTypeDirect MIBIPForwardType = 3
	// MIB_IPROUTE_TYPE_INDIRECT: The remote route where the next hop is not the final destination
	// (a remote destination).
	MIBIPForwardTypeRouteTypeIndirect MIBIPForwardType = 4
)

func (o MIBIPForwardType) String() string {
	switch o {
	case MIBIPForwardTypeRouteTypeOther:
		return "MIBIPForwardTypeRouteTypeOther"
	case MIBIPForwardTypeRouteTypeInvalid:
		return "MIBIPForwardTypeRouteTypeInvalid"
	case MIBIPForwardTypeRouteTypeDirect:
		return "MIBIPForwardTypeRouteTypeDirect"
	case MIBIPForwardTypeRouteTypeIndirect:
		return "MIBIPForwardTypeRouteTypeIndirect"
	}
	return "Invalid"
}

// MIBIPForwardProto type represents MIB_IPFORWARD_PROTO RPC enumeration.
//
// The MIB_IPFORWARD_PROTO enumeration indicates which protocols have updated routes.
type MIBIPForwardProto uint16

var (
	// MIB_IPPROTO_OTHER: A route added by a protocol not specified in [RFC1354].
	MIBIPForwardProtoOther MIBIPForwardProto = 1
	// MIB_IPPROTO_LOCAL: A route added locally on an interface.
	MIBIPForwardProtoLocal MIBIPForwardProto = 2
	// MIB_IPPROTO_NETMGMT: A static route. This value is used to identify route information
	// for IP routing set through network management such as DHCP, the Simple Network Management
	// Protocol (SNMP), or by any other API to create routes.
	MIBIPForwardProtoNETMGMT MIBIPForwardProto = 3
	// MIB_IPPROTO_ICMP: A route added as a result of an Internet Control Message Protocol
	// (ICMP) redirect.
	MIBIPForwardProtoICMP MIBIPForwardProto = 4
	// MIB_IPPROTO_EGP: A route added by the Exterior Gateway Protocol (EGP), a dynamic
	// routing protocol.
	MIBIPForwardProtoEGP MIBIPForwardProto = 5
	// MIB_IPPROTO_GGP: A route added by the Gateway-to-Gateway Protocol (GGP), a dynamic
	// routing protocol.
	MIBIPForwardProtoGGP MIBIPForwardProto = 6
	// MIB_IPPROTO_HELLO: A route added by the Hellospeak protocol, a dynamic routing protocol.
	// This protocol is not supported and MUST NOT be used.
	MIBIPForwardProtoHello MIBIPForwardProto = 7
	// MIB_IPPROTO_RIP: A route added by the Berkeley Routing Information Protocol (RIP)
	// or RIP-II, a dynamic routing protocol. See [RFC1058] and [RFC1723].
	MIBIPForwardProtoRIP MIBIPForwardProto = 8
	// MIB_IPPROTO_IS_IS: A route added by the Intermediate System-to-Intermediate System
	// (IS-IS) protocol, a dynamic routing protocol. The IS-IS protocol was developed for
	// use in the Open Systems Interconnection (OSI) protocol suite.
	MIBIPForwardProtoISIS MIBIPForwardProto = 9
	// MIB_IPPROTO_ES_IS: A route added by the End System-to-Intermediate System (ES-IS)
	// protocol, a dynamic routing protocol. The ES-IS protocol was developed for use in
	// the Open Systems Interconnection (OSI) protocol suite.
	MIBIPForwardProtoESIS MIBIPForwardProto = 10
	// MIB_IPPROTO_CISCO: A route added by the Cisco Interior Gateway Routing Protocol (IGRP),
	// a dynamic routing protocol.
	MIBIPForwardProtoCisco MIBIPForwardProto = 11
	// MIB_IPPROTO_BBN: A route added by the Bolt, Beranek, and Newman (BBN) Interior Gateway
	// Protocol (IGP) that used the Shortest Path First (SPF) algorithm, a dynamic routing
	// protocol.
	MIBIPForwardProtoBbn MIBIPForwardProto = 12
	// MIB_IPPROTO_OSPF: A route added by the Open Shortest Path First (OSPF) protocol,
	// a dynamic routing protocol.
	MIBIPForwardProtoOSPF MIBIPForwardProto = 13
	// MIB_IPPROTO_BGP: A route added by the Border Gateway Protocol (BGP), a dynamic routing
	// protocol.
	MIBIPForwardProtoBGP MIBIPForwardProto = 14
	// MIB_IPPROTO_NT_AUTOSTATIC: A route that was originally generated by a routing protocol,
	// but now is static.
	MIBIPForwardProtoNTAutostatic MIBIPForwardProto = 10002
	// MIB_IPPROTO_NT_STATIC: A route added as a static route from the routing user interface
	// (5) or a routing command.
	MIBIPForwardProtoNTStatic MIBIPForwardProto = 10006
	// MIB_IPPROTO_NT_STATIC_NON_DOD: A route added as a static route from the routing user
	// interface or a routing command. These routes do not cause demand-dial.
	MIBIPForwardProtoNTStaticNonDOD MIBIPForwardProto = 10007
)

func (o MIBIPForwardProto) String() string {
	switch o {
	case MIBIPForwardProtoOther:
		return "MIBIPForwardProtoOther"
	case MIBIPForwardProtoLocal:
		return "MIBIPForwardProtoLocal"
	case MIBIPForwardProtoNETMGMT:
		return "MIBIPForwardProtoNETMGMT"
	case MIBIPForwardProtoICMP:
		return "MIBIPForwardProtoICMP"
	case MIBIPForwardProtoEGP:
		return "MIBIPForwardProtoEGP"
	case MIBIPForwardProtoGGP:
		return "MIBIPForwardProtoGGP"
	case MIBIPForwardProtoHello:
		return "MIBIPForwardProtoHello"
	case MIBIPForwardProtoRIP:
		return "MIBIPForwardProtoRIP"
	case MIBIPForwardProtoISIS:
		return "MIBIPForwardProtoISIS"
	case MIBIPForwardProtoESIS:
		return "MIBIPForwardProtoESIS"
	case MIBIPForwardProtoCisco:
		return "MIBIPForwardProtoCisco"
	case MIBIPForwardProtoBbn:
		return "MIBIPForwardProtoBbn"
	case MIBIPForwardProtoOSPF:
		return "MIBIPForwardProtoOSPF"
	case MIBIPForwardProtoBGP:
		return "MIBIPForwardProtoBGP"
	case MIBIPForwardProtoNTAutostatic:
		return "MIBIPForwardProtoNTAutostatic"
	case MIBIPForwardProtoNTStatic:
		return "MIBIPForwardProtoNTStatic"
	case MIBIPForwardProtoNTStaticNonDOD:
		return "MIBIPForwardProtoNTStaticNonDOD"
	}
	return "Invalid"
}

// MIBIPStatsForwarding type represents MIB_IPSTATS_FORWARDING RPC enumeration.
//
// The MIB_IPSTATS_FORWARDING enumerates different forwarding possibilities.
type MIBIPStatsForwarding uint16

var (
	MIBIPStatsForwardingIsForwarding    MIBIPStatsForwarding = 1
	MIBIPStatsForwardingIsNotForwarding MIBIPStatsForwarding = 2
)

func (o MIBIPStatsForwarding) String() string {
	switch o {
	case MIBIPStatsForwardingIsForwarding:
		return "MIBIPStatsForwardingIsForwarding"
	case MIBIPStatsForwardingIsNotForwarding:
		return "MIBIPStatsForwardingIsNotForwarding"
	}
	return "Invalid"
}

// MIBTCPState type represents MIB_TCP_STATE RPC enumeration.
//
// The MIB_TCP_STATE enumeration enumerates different possible TCP states.
type MIBTCPState uint16

var (
	// MIB_TCP_STATE_CLOSED: The TCP connection is closed.
	MIBTCPStateClosed MIBTCPState = 1
	// MIB_TCP_STATE_LISTEN: The TCP connection is in the listen state.
	MIBTCPStateListen MIBTCPState = 2
	// MIB_TCP_STATE_SYN_SENT: A SYN packet has been sent.
	MIBTCPStateSynSent MIBTCPState = 3
	// MIB_TCP_STATE_SYN_RCVD: A SYN packet has been received.
	MIBTCPStateSynRcvd MIBTCPState = 4
	// MIB_TCP_STATE_ESTAB: The TCP connection has been established.
	MIBTCPStateEstab MIBTCPState = 5
	// MIB_TCP_STATE_FIN_WAIT1: The TCP connection is waiting for a FIN packet.
	MIBTCPStateInWait1 MIBTCPState = 6
	// MIB_TCP_STATE_FIN_WAIT2: The TCP connection is waiting for a FIN packet.
	MIBTCPStateInWait2 MIBTCPState = 7
	// MIB_TCP_STATE_CLOSE_WAIT: The TCP connection is in the close wait state.
	MIBTCPStateCloseWait MIBTCPState = 8
	// MIB_TCP_STATE_CLOSING: The TCP connection is closing.
	MIBTCPStateClosing MIBTCPState = 9
	// MIB_TCP_STATE_LAST_ACK: The TCP connection is in the last ACK state.
	MIBTCPStateLastAck MIBTCPState = 10
	// MIB_TCP_STATE_TIME_WAIT: The TCP connection is in the time wait state.
	MIBTCPStateTimeWait MIBTCPState = 11
	// MIB_TCP_STATE_DELETE_TCB: The TCP connection is in the delete TCB state.
	MIBTCPStateDeleteTcb MIBTCPState = 12
)

func (o MIBTCPState) String() string {
	switch o {
	case MIBTCPStateClosed:
		return "MIBTCPStateClosed"
	case MIBTCPStateListen:
		return "MIBTCPStateListen"
	case MIBTCPStateSynSent:
		return "MIBTCPStateSynSent"
	case MIBTCPStateSynRcvd:
		return "MIBTCPStateSynRcvd"
	case MIBTCPStateEstab:
		return "MIBTCPStateEstab"
	case MIBTCPStateInWait1:
		return "MIBTCPStateInWait1"
	case MIBTCPStateInWait2:
		return "MIBTCPStateInWait2"
	case MIBTCPStateCloseWait:
		return "MIBTCPStateCloseWait"
	case MIBTCPStateClosing:
		return "MIBTCPStateClosing"
	case MIBTCPStateLastAck:
		return "MIBTCPStateLastAck"
	case MIBTCPStateTimeWait:
		return "MIBTCPStateTimeWait"
	case MIBTCPStateDeleteTcb:
		return "MIBTCPStateDeleteTcb"
	}
	return "Invalid"
}

// TCPRTOAlgorithm type represents TCP_RTO_ALGORITHM RPC enumeration.
//
// The TCP_RTO_ALGORITHM enumerates different TCP retransmission time-out algorithms.
type TCPRTOAlgorithm uint16

var (
	// MIB_TCP_RTO_OTHER: Other.
	TCPRTOAlgorithmMIBTCPRTOOther TCPRTOAlgorithm = 1
	// MIB_TCP_RTO_CONSTANT: Constant time-out.
	TCPRTOAlgorithmMIBTCPRTOConstant TCPRTOAlgorithm = 2
	// MIB_TCP_RTO_RSRE: MIL-STD-1778. See [RFC4022].
	TCPRTOAlgorithmMIBTCPRTORSRE TCPRTOAlgorithm = 3
	// MIB_TCP_RTO_VANJ: Van Jacobson's algorithm. See [RFC1144].
	TCPRTOAlgorithmMIBTCPRTOVANJ TCPRTOAlgorithm = 4
)

func (o TCPRTOAlgorithm) String() string {
	switch o {
	case TCPRTOAlgorithmMIBTCPRTOOther:
		return "TCPRTOAlgorithmMIBTCPRTOOther"
	case TCPRTOAlgorithmMIBTCPRTOConstant:
		return "TCPRTOAlgorithmMIBTCPRTOConstant"
	case TCPRTOAlgorithmMIBTCPRTORSRE:
		return "TCPRTOAlgorithmMIBTCPRTORSRE"
	case TCPRTOAlgorithmMIBTCPRTOVANJ:
		return "TCPRTOAlgorithmMIBTCPRTOVANJ"
	}
	return "Invalid"
}

// IN6Addr structure represents IN6_ADDR RPC structure.
//
// The IN6_ADDR structure represents an IPv6 address.
type IN6Addr struct {
	Union *IN6Addr_Union `idl:"name:u" json:"union"`
}

func (o *IN6Addr) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IN6Addr) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	// FIXME unknown type u
	return nil
}
func (o *IN6Addr) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	// FIXME: unknown type u
	return nil
}

type IN6Addr_Union struct {
	// Byte: An IPv6 address represented as an array of 16 UCHAR values.
	Byte []byte `idl:"name:Byte" json:"byte"`
	// Word: An IPv6 address represented as an array of USHORT values.
	Word []uint16 `idl:"name:Word" json:"word"`
}

// InformationContainer structure represents DIM_INFORMATION_CONTAINER RPC structure.
//
// The DIM_INFORMATION_CONTAINER structure specifies a generic information container
// used by certain methods to store and retrieve information.
type InformationContainer struct {
	// dwBufferSize: This MUST be set to the size, in bytes, of the data being pointed to
	// by pBuffer.
	BufferSize uint32 `idl:"name:dwBufferSize" json:"buffer_size"`
	// pBuffer: A pointer to a buffer of size dwBufferSize that contains the information.
	// The information contained in this buffer is specific to the API in which this structure
	// is used.
	//
	// * MPR_SERVER_0 ( 5d243bef-8203-46ea-970a-962590f56200 )
	//
	// * MPR_SERVER_1 ( 12ffcd88-5613-4ccb-ba5c-c281aec368cb )
	//
	// * MPR_SERVER_2 ( 7f9bfc09-26be-42e8-83d0-fe4ebf384abe )
	//
	// * RASI_CONNECTION_0 ( e979f770-cb84-426a-9b43-1ce5eec2d169 )
	//
	// * RASI_CONNECTION_1 ( 617795bc-29d6-4698-bbaf-2e07bc34bd61 )
	//
	// * RASI_CONNECTION_2 ( 9a183ab0-5b55-4be5-baea-25b1357a62bb )
	//
	// * RASI_CONNECTION_3 ( 9b17d836-13c1-4772-b1fa-24c74fae1918 )
	//
	// * RASI_PORT_0 ( ed4beef4-11ba-413f-abf4-2659412169e8 )
	//
	// * RASI_PORT_1 ( f6b91be9-338a-41b4-9b24-2d5ab26dd9be )
	//
	// * MPRI_INTERFACE_0 ( 1c0f45b1-e5f4-4479-86cf-5f7753b4697c )
	//
	// * MPRI_INTERFACE_1 ( bb6d1b31-4515-44cd-9297-2768221d1397 )
	//
	// * MPRI_INTERFACE_2 ( 0b5fa6fc-b3f2-4a3f-9bfd-96963bfbb03d )
	//
	// DIM_INFORMATION_CONTAINER specifies a generic information container used by the following
	// methods to store and retrieve information:
	//
	// * RMprAdminServerGetInfo (section 3.1.4.1) ( 6b444061-7d03-4899-a1b0-feb5d8645377
	// )
	//
	// * RRasAdminConnectionEnum (section 3.1.4.2) ( 023913fc-f438-47c9-a52b-6e45e0190c6c
	// )
	//
	// * RRasAdminConnectionGetInfo (section 3.1.4.3) ( cb8a4769-8b8c-4c33-84f2-d3418162599f
	// )
	//
	// * RRasAdminPortEnum (section 3.1.4.5) ( 7f77ce09-b084-47ff-a1e0-6fd30cab5744 )
	//
	// * RRasAdminPortGetInfo (section 3.1.4.6) ( f5b9fb82-ead5-46a7-83a0-dc177fa7c55c )
	//
	// * RRouterInterfaceCreate (section 3.1.4.13) ( 72bead5c-821f-4e98-bacd-0de279552379
	// )
	//
	// * RRouterInterfaceGetInfo (section 3.1.4.14) ( 2fbcf316-2082-4f98-878b-eab5d0c2da1d
	// )
	//
	// * RRouterInterfaceSetInfo (section 3.1.4.15) ( 615c1081-5d03-415a-b57c-76876bb2cf23
	// )
	//
	// * RRouterInterfaceEnum (section 3.1.4.21) ( 0d19911e-f4d7-47f0-b615-90feef69831c
	// )
	//
	// * RRouterInterfaceDeviceGetInfo (section 3.1.4.39) ( 7a027868-0815-4cee-90ca-f57e7b673498
	// )
	//
	// * RRouterInterfaceDeviceSetInfo (section 3.1.4.40) ( 0ba65f78-98e2-4b7d-a0da-5fb96be1ef75
	// )
	//
	// * RRouterInterfaceSetCredentialsEx (section 3.1.4.41) ( dcad4e29-723b-4832-84d8-5bfac7895b2e
	// )
	//
	// * RRouterInterfaceGetCredentialsEx (section 3.1.4.42) ( 434d62e9-77b7-4cce-bbda-03a20685ae74
	// )
	//
	// * RMprAdminServerSetInfo (section 3.1.4.44) ( 40aecae7-0ea5-4d3a-9186-cbd0bf6ad608
	// )
	//
	// * RRouterDeviceEnum (section 3.1.4.37) ( 0553ccf0-5b52-4131-b277-4f2644eb41e7 )
	Buffer []byte `idl:"name:pBuffer;size_is:(dwBufferSize)" json:"buffer"`
}

func (o *InformationContainer) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if o.Buffer != nil && o.BufferSize == 0 {
		o.BufferSize = uint32(len(o.Buffer))
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *InformationContainer) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.BufferSize); err != nil {
		return err
	}
	if o.Buffer != nil || o.BufferSize > 0 {
		_ptr_pBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.BufferSize)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Buffer {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.Buffer[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Buffer, _ptr_pBuffer); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *InformationContainer) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.BufferSize); err != nil {
		return err
	}
	_ptr_pBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.BufferSize > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.BufferSize)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
		}
		o.Buffer = make([]byte, sizeInfo[0])
		for i1 := range o.Buffer {
			i1 := i1
			if err := w.ReadData(&o.Buffer[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_pBuffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.Buffer, _s_pBuffer, _ptr_pBuffer); err != nil {
		return err
	}
	return nil
}

// ObjectHeaderIDL structure represents MPRAPI_OBJECT_HEADER_IDL RPC structure.
//
// The MPRAPI_OBJECT_HEADER_IDL structure SHOULD<116> define the version of the structure
// that needs to be used by the following methods and structures:
//
// * *RRasAdminConnectionEnumEx (section 3.1.4.46)* ( d1261e41-c4cf-4a11-8eba-9f161f33dcb9
// )
//
// * *RRasAdminConnectionGetInfoEx (section 3.1.4.47)* ( 2d1031a2-3df3-458e-9b9c-b5477b4130f1
// )
//
// * *RAS_CONNECTION_EX_1_IDL (section 2.2.1.2.133)* ( d9078168-75b2-4d5d-93b6-f39b29736682
// )
//
// * *MPR_SERVER_EX_1 (section 2.2.1.2.142)* ( 453989e4-59d7-4915-9958-d9cd2c277b9a
// )
//
// * *MPR_SERVER_SET_CONFIG_EX_1 (section 2.2.1.2.145)* ( 438f3bb9-06fa-4c06-a772-8c8d7bf6e62a
// )
//
// * *RAS_UPDATE_CONNECTION_1_IDL (section 2.2.1.2.147)* ( ff12a4cb-d190-4476-b674-0048ac93d911
// )
//
// * *MPR_SERVER_SET_CONFIG_EX_2 (section 2.2.1.2.241)* ( f27f87a5-bd12-4c77-b484-d583453bd471
// )
//
// * *MPR_SERVER_EX_2 (section 2.2.1.2.242)* ( 6f9a70b4-6222-4976-a93f-f853fa19d7b2
// )
//
// * *MPR_IF_CUSTOMINFOEX_0 (section 2.2.1.2.244)* ( 54f68223-7380-45b3-bc09-1168944831be
// )
//
// * *MPR_SERVER_SET_CONFIG_EX_3 (section 2.2.1.2.250)* ( c4043842-b5a8-4768-9689-6fe258777266
// )
//
// * *MPR_SERVER_EX_3 (section 2.2.1.2.251)* ( 4795f906-fc58-41b9-9cb9-977165835b98
// )
//
// * *MPR_IF_CUSTOMINFOEX_1 (section 2.2.1.2.269)* ( d0d5f606-5c82-48de-ab99-d106e797813a
// )
//
// typedef struct _MPRAPI_OBJECT_HEADER_IDL {
//
// UCHAR revision;
//
// UCHAR type;
//
// USHORT size;
//
// } MPRAPI_OBJECT_HEADER_IDL,
type ObjectHeaderIDL struct {
	// revision: This represents the version of the structure that is being used depending
	// on the numeric value in the type field. The following values are supported.
	//
	//	+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                                     |                                                                                  |
	//	|                        VALUE                        |                                     MEANING                                      |
	//	|                                                     |                                                                                  |
	//	+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRAPI_RAS_CONNECTION_OBJECT_REVISION_1 0x01        | Represents revision 1 of the structure RAS_CONNECTION_EX_1_IDL (section          |
	//	|                                                     | 2.2.1.2.133) if type is 0x01.                                                    |
	//	+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRAPI_MPR_SERVER_SET_CONFIG_OBJECT_REVISION_1 0x01 | Represents revision 1 of the structure MPR_SERVER_SET_CONFIG_EX_1 (section       |
	//	|                                                     | 2.2.1.2.145) if type is 0x03.                                                    |
	//	+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRAPI_MPR_SERVER_SET_CONFIG_OBJECT_REVISION_2 0x02 | Represents revision 2 of the structure MPR_SERVER_SET_CONFIG_EX_2 (section       |
	//	|                                                     | 2.2.1.2.241) if type is 0x03.                                                    |
	//	+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRAPI_MPR_SERVER_SET_CONFIG_OBJECT_REVISION_3 0x03 | Represents revision 3 of the structure MPR_SERVER_SET_CONFIG_EX_3 (section       |
	//	|                                                     | 2.2.1.2.250) if type is 0x03.                                                    |
	//	+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRAPI_MPR_SERVER_OBJECT_REVISION_1 0x01            | Represents revision 1 of the structure MPR_SERVER_EX_1 (section 2.2.1.2.142) if  |
	//	|                                                     | type is 0x02.                                                                    |
	//	+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRAPI_MPR_SERVER_OBJECT_REVISION_2 0x02            | Represents revision 2 of the structure MPR_SERVER_EX_2 (section 2.2.1.2.242) if  |
	//	|                                                     | type is 0x02.                                                                    |
	//	+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRAPI_MPR_SERVER_OBJECT_REVISION_3 0x03            | Represents revision 3 of the structure MPR_SERVER_EX_3 (section 2.2.1.2.251) if  |
	//	|                                                     | type is 0x02.                                                                    |
	//	+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRAPI_RAS_UPDATE_CONNECTION_OBJECT_REVISION_1 0x01 | Represents revision 1 of the structure RAS_UPDATE_CONNECTION_1_IDL (section      |
	//	|                                                     | 2.2.1.2.147) if type is 0x05.                                                    |
	//	+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRAPI_MPR_IF_CUSTOM_CONFIG_OBJECT_REVISION_1 0x01  | Represents revision 1 of the structure MPR_IF_CUSTOMINFOEX_0 (section            |
	//	|                                                     | 2.2.1.2.244) if type is 0x06.                                                    |
	//	+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRAPI_MPR_IF_CUSTOM_CONFIG_OBJECT_REVISION_2 0x02  | Represents revision 2 of the structure MPR_IF_CUSTOMINFOEX_1 (section            |
	//	|                                                     | 2.2.1.2.269) if type is 0x06.                                                    |
	//	+-----------------------------------------------------+----------------------------------------------------------------------------------+
	Revision uint8 `idl:"name:revision" json:"revision"`
	// type: The following represents the type of structure being used.
	//
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                                      |                                                                                  |
	//	|                        VALUE                         |                                     MEANING                                      |
	//	|                                                      |                                                                                  |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRAPI_OBJECT_TYPE_RAS_CONNECTION_OBJECT 0x01        | Represents a RAS_CONNECTION_EX_IDL (section 2.2.1.2.134) structure.              |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRAPI_OBJECT_TYPE_MPR_SERVER_OBJECT 0x02            | Represents an MPR_SERVER_EX structure (MPR_SERVER_EX_1 (section 2.2.1.2.142)     |
	//	|                                                      | structure or an MPR_SERVER_EX_2 (section 2.2.1.2.242)) based on the value of     |
	//	|                                                      | revision.                                                                        |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRAPI_OBJECT_TYPE_MPR_SERVER_SET_CONFIG_OBJECT 0x03 | Represents an MPR_SERVER_SET_CONFIG_EX structure (an MPR_SERVER_SET_CONFIG_EX_1  |
	//	|                                                      | or an MPR_SERVER_SET_CONFIG_EX_2 (section 2.2.1.2.241) structure based on the    |
	//	|                                                      | value of revision).                                                              |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRAPI_OBJECT_TYPE_UPDATE_CONNECTION_OBJECT 0x05     | Represents a RAS_UPDATE_CONNECTION_1_IDL (section 2.2.1.2.147) structure.        |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRAPI_OBJECT_TYPE_IF_CUSTOM_CONFIG_OBJECT 0x06      | Represents an MPR_IF_CUSTOMINFOEX_IDL (section 2.2.1.2.245) structure.           |
	//	+------------------------------------------------------+----------------------------------------------------------------------------------+
	Type uint8 `idl:"name:type" json:"type"`
	// size: Size of the BLOB (structure) being passed based on the type and revision.
	Size uint16 `idl:"name:size" json:"size"`
}

func (o *ObjectHeaderIDL) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *ObjectHeaderIDL) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(2); err != nil {
		return err
	}
	if err := w.WriteData(o.Revision); err != nil {
		return err
	}
	if err := w.WriteData(o.Type); err != nil {
		return err
	}
	if err := w.WriteData(o.Size); err != nil {
		return err
	}
	return nil
}
func (o *ObjectHeaderIDL) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(2); err != nil {
		return err
	}
	if err := w.ReadData(&o.Revision); err != nil {
		return err
	}
	if err := w.ReadData(&o.Type); err != nil {
		return err
	}
	if err := w.ReadData(&o.Size); err != nil {
		return err
	}
	return nil
}

// PPPProjectionInfo1 structure represents PPP_PROJECTION_INFO_1 RPC structure.
//
// The PPP_PROJECTION_INFO_1 structure<117> contains information obtained during the
// PPP negotiation for the PPP-based tunnels.
type PPPProjectionInfo1 struct {
	// dwIPv4NegotiationError: Same as dwError in PPP_IPCP_INFO (section 2.2.1.2.65).
	IPv4NegotiationError uint32 `idl:"name:dwIPv4NegotiationError" json:"ipv4_negotiation_error"`
	// wszAddress: Same as wszAddress in PPP_IPCP_INFO.
	Address []uint16 `idl:"name:wszAddress" json:"address"`
	// wszRemoteAddress: Same as wszRemoteAddress in PPP_IPCP_INFO.
	RemoteAddress []uint16 `idl:"name:wszRemoteAddress" json:"remote_address"`
	// dwIPv4Options: Same as dwOptions in PPP_IPCP_INFO.
	IPv4Options uint32 `idl:"name:dwIPv4Options" json:"ipv4_options"`
	// dwIPv4RemoteOptions: Same as dwIPv4Options.
	IPv4RemoteOptions uint32 `idl:"name:dwIPv4RemoteOptions" json:"ipv4_remote_options"`
	// IPv4SubInterfaceIndex: Specifies the index of the subinterface corresponding to the
	// connection on the server.
	IPv4SubInterfaceIndex uint64 `idl:"name:IPv4SubInterfaceIndex" json:"ipv4_sub_interface_index"`
	// dwIPv6NegotiationError: Specifies the result of PPP_IPv6. Network control protocol
	// negotiation. A value of zero (0) indicates that either IPv6 was not negotiated or
	// Ipv6 has been negotiated successfully. A nonzero value indicates failure and is the
	// actual fatal error that occurred during the control protocol.
	IPv6NegotiationError uint32 `idl:"name:dwIPv6NegotiationError" json:"ipv6_negotiation_error"`
	// bInterfaceIdentifier: If dwIPv6NegotiationError is zero (0) and IPv6 was negotiated,
	// this MUST be the 64-bit interface identifier of the IPv6 address of the server interface.
	// If dwIPv6NegotiationError is zero, a value of zero for this indicates that IPv6 was
	// not negotiated. It MUST be zero when dwIPv6NegotiationError is nonzero.
	InterfaceID []byte `idl:"name:bInterfaceIdentifier" json:"interface_id"`
	// bRemoteInterfaceIdentifier: If dwIPv6NegotiationError is zero (0) and IPv6 was negotiated,
	// this MUST be the 64-bit interface identifier of the IPv6 address of the client interface.
	// If dwIPv6NegotiationError is zero, a value of zero for this indicates that IPv6 was
	// not negotiated. It MUST be zero when dwIPv6NegotiationError is nonzero.
	RemoteInterfaceID []byte `idl:"name:bRemoteInterfaceIdentifier" json:"remote_interface_id"`
	// bPrefix: Specifies the prefix of the IPv6 address of the client interface.
	Prefix []byte `idl:"name:bPrefix" json:"prefix"`
	// dwPrefixLength: The length, in bits, of the address prefix.
	PrefixLength uint32 `idl:"name:dwPrefixLength" json:"prefix_length"`
	// IPv6SubInterfaceIndex: Specifies the index of the subInterface corresponding to the
	// connection on the server.
	IPv6SubInterfaceIndex uint64 `idl:"name:IPv6SubInterfaceIndex" json:"ipv6_sub_interface_index"`
	// dwLcpError: Specifies the error that occurred if the PPP negotiation was unsuccessful
	// and it MUST be one of the following values.
	//
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                              |                                                                                  |
	//	|                    VALUE                     |                                     MEANING                                      |
	//	|                                              |                                                                                  |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NO_LOCAL_ENCRYPTION 0x000002E5         | The local computer does not support the required data encryption type.           |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NO_REMOTE_ENCRYPTION 0x000002E6        | The remote computer does not support the required data encryption type.          |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_CHANGING_PASSWORD 0x000002C5           | There was an error changing the password on the domain. The password might have  |
	//	|                                              | been too short or might have matched a previously used password.                 |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_PPP_NO_PROTOCOLS_CONFIGURED 0x000002D0 | The PPP controlled protocols were not configured.                                |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_AUTHENTICATION_FAILURE 0x000002B3      | The connection was denied because the username or password specified is not      |
	//	|                                              | valid or because the selected authentication protocol is not permitted on the    |
	//	|                                              | remote server.                                                                   |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_MORE_DATA 0x000000EA                   | More data is available.                                                          |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_PROTOCOL_NOT_CONFIGURED 0x000002DC     | The received control protocol of the PPP is not configured.                      |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_AUTH_INTERNAL 0x00000285               | There was an internal error while processing authentication.                     |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_NO_DIALIN_PERMISSION 0x00000289        | The user does not have permission to dial in.                                    |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_SERVER_POLICY 0x0000032C               | The connection was prevented because of a policy configured on the RRAS.         |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_PEER_REFUSED_AUTH 0x00000397           | The connection could not be established because the authentication protocol used |
	//	|                                              | by the RRAS to verify username and password could not be matched with the one    |
	//	|                                              | proposed by the client.                                                          |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_UNKNOWN_FRAMED_PROTOCOL 0x0000031A     | The Framed Protocol RADIUS [RFC2865] attribute for this client is not PPP.       |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_WRONG_TUNNEL_TYPE 0x0000031B           | The Tunnel Type RADIUS [RFC2865] attribute for this user is not correct.         |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_UNKNOWN_SERVICE_TYPE 0x0000031C        | The Service Type RADIUS [RFC2865] attribute for this user is neither Framed nor  |
	//	|                                              | callback Framed.                                                                 |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_RESTRICTED_LOGON_HOURS 0x00000286      | The user is not permitted to log on at this time of day.                         |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ACCT_DISABLED 0x00000287               | The account is disabled.                                                         |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_PASSWD_EXPIRED 0x00000288              | The password for this account has expired.                                       |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_ILL_FORMED_PASSWORD 0x0000052C         | Unable to update the password. The value provided for the new password contains  |
	//	|                                              | values that are not allowed in passwords.                                        |
	//	+----------------------------------------------+----------------------------------------------------------------------------------+
	LCPError uint32 `idl:"name:dwLcpError" json:"lcp_error"`
	// dwAuthenticationProtocol: The same as dwAuthenticatedProtocol in PPP_LCP_INFO.
	AuthenticationProtocol uint32 `idl:"name:dwAuthenticationProtocol" json:"authentication_protocol"`
	// dwAuthenticationData: The same as dwAuthenticationData in PPP_LCP_INFO (see section
	// 2.2.1.2.71).
	AuthenticationData uint32 `idl:"name:dwAuthenticationData" json:"authentication_data"`
	// dwRemoteAuthenticationProtocol: Specifies the authentication protocol used to authenticate
	// the remote computer. This will be different from dwAuthenticationProtocol in the
	// case of demand-dial if the authentication protocol used by the two ends are different.
	// See the dwAuthenticationProtocol member for a list of possible values.
	RemoteAuthenticationProtocol uint32 `idl:"name:dwRemoteAuthenticationProtocol" json:"remote_authentication_protocol"`
	// dwRemoteAuthenticationData: Specifies additional information about the authentication
	// protocol specified by dwRemoteAuthenticationProtocol. This will be different from
	// dwAuthenticationData in the case of demand-dial if the authentication protocol used
	// by the two ends are different. See the dwAuthenticationData member for a list of
	// possible values.
	RemoteAuthenticationData uint32 `idl:"name:dwRemoteAuthenticationData" json:"remote_authentication_data"`
	// dwLcpTerminateReason: Specifies the reason the connection was terminated by the local
	// computer. This member always has a value of zero (0).
	LCPTerminateReason uint32 `idl:"name:dwLcpTerminateReason" json:"lcp_terminate_reason"`
	// dwLcpRemoteTerminateReason: Specifies the reason the connection was terminated by
	// the remote computer. This member always has a value of zero (0).
	LCPRemoteTerminateReason uint32 `idl:"name:dwLcpRemoteTerminateReason" json:"lcp_remote_terminate_reason"`
	// dwLcpOptions: The same as dwOptions in PPP_LCP_INFO (see section 2.2.1.2.71).
	LCPOptions uint32 `idl:"name:dwLcpOptions" json:"lcp_options"`
	// dwLcpRemoteOptions: Specifies information about the LCP options in use by the remote
	// computer. See the dwLcpOptions member for a list of possible values.
	LCPRemoteOptions uint32 `idl:"name:dwLcpRemoteOptions" json:"lcp_remote_options"`
	// dwEapTypeId: Specifies the type identifier of the EAP used to authenticate the local
	// computer. The value of this member is valid only if dwAuthenticationProtocol is PPP_LCP_EAP.
	// The valid values are defined in [IANA-EAP].
	EAPTypeID uint32 `idl:"name:dwEapTypeId" json:"eap_type_id"`
	// dwRemoteEapTypeId: MUST be zero (0). This value has no significance.
	RemoteEAPTypeID uint32 `idl:"name:dwRemoteEapTypeId" json:"remote_eap_type_id"`
	// dwCcpError: Specifies an error if the negotiation is unsuccessful.
	CCPError uint32 `idl:"name:dwCcpError" json:"ccp_error"`
	// dwCompressionAlgorithm: The same as dwCompressionAlgorithm in PPP_LCP_INFO.
	CompressionAlgorithm uint32 `idl:"name:dwCompressionAlgorithm" json:"compression_algorithm"`
	// dwCcpOptions: The same as dwCcpOptions in PPP_LCP_INFO.
	CCPOptions uint32 `idl:"name:dwCcpOptions" json:"ccp_options"`
	// dwRemoteCompressionAlgorithm: Specifies the compression algorithm used by the remote
	// computer. The values are the same as those for dwCompressionAlgorithm.
	RemoteCompressionAlgorithm uint32 `idl:"name:dwRemoteCompressionAlgorithm" json:"remote_compression_algorithm"`
	// dwCcpRemoteOptions: Specifies the compression options on the remote computer. The
	// following options are supported.
	//
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	|                                       |                                                                                  |
	//	|                 VALUE                 |                                     MEANING                                      |
	//	|                                       |                                                                                  |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| PPP_CCP_COMPRESSION 0x00000001        | Compression without encryption.                                                  |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| PPP_CCP_HISTORYLESS 0x01000000        | MPPE in stateless mode. The session key is changed after every packet. This      |
	//	|                                       | mode improves performance on high-latency networks, or networks that experience  |
	//	|                                       | significant packet loss.                                                         |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| PPP_CCP_ENCRYPTION40BITOLD 0x00000010 | PPE using 40-bit keys.                                                           |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| PPP_CCP_ENCRYPTION40BIT 0x00000020    | MPPE using 40-bit keys.                                                          |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| PPP_CCP_ENCRYPTION56BIT 0x00000080    | MPPE using 56-bit keys.                                                          |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| PPP_CCP_ENCRYPTION128BIT 0x00000040   | MPPE using 128-bit keys.                                                         |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| ERROR_PPP_NOT_CONVERGING 0x000002DC   | The remote computer and RRAS could not converge on address negotiation.          |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	CCPRemoteOptions uint32 `idl:"name:dwCcpRemoteOptions" json:"ccp_remote_options"`
}

func (o *PPPProjectionInfo1) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *PPPProjectionInfo1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if err := w.WriteData(o.IPv4NegotiationError); err != nil {
		return err
	}
	for i1 := range o.Address {
		i1 := i1
		if uint64(i1) >= 16 {
			break
		}
		if err := w.WriteData(o.Address[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Address); uint64(i1) < 16; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	for i1 := range o.RemoteAddress {
		i1 := i1
		if uint64(i1) >= 16 {
			break
		}
		if err := w.WriteData(o.RemoteAddress[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.RemoteAddress); uint64(i1) < 16; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.IPv4Options); err != nil {
		return err
	}
	if err := w.WriteData(o.IPv4RemoteOptions); err != nil {
		return err
	}
	if err := w.WriteData(o.IPv4SubInterfaceIndex); err != nil {
		return err
	}
	if err := w.WriteData(o.IPv6NegotiationError); err != nil {
		return err
	}
	for i1 := range o.InterfaceID {
		i1 := i1
		if uint64(i1) >= 8 {
			break
		}
		if err := w.WriteData(o.InterfaceID[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.InterfaceID); uint64(i1) < 8; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	for i1 := range o.RemoteInterfaceID {
		i1 := i1
		if uint64(i1) >= 8 {
			break
		}
		if err := w.WriteData(o.RemoteInterfaceID[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.RemoteInterfaceID); uint64(i1) < 8; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	for i1 := range o.Prefix {
		i1 := i1
		if uint64(i1) >= 8 {
			break
		}
		if err := w.WriteData(o.Prefix[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Prefix); uint64(i1) < 8; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.PrefixLength); err != nil {
		return err
	}
	if err := w.WriteData(o.IPv6SubInterfaceIndex); err != nil {
		return err
	}
	if err := w.WriteData(o.LCPError); err != nil {
		return err
	}
	if err := w.WriteData(o.AuthenticationProtocol); err != nil {
		return err
	}
	if err := w.WriteData(o.AuthenticationData); err != nil {
		return err
	}
	if err := w.WriteData(o.RemoteAuthenticationProtocol); err != nil {
		return err
	}
	if err := w.WriteData(o.RemoteAuthenticationData); err != nil {
		return err
	}
	if err := w.WriteData(o.LCPTerminateReason); err != nil {
		return err
	}
	if err := w.WriteData(o.LCPRemoteTerminateReason); err != nil {
		return err
	}
	if err := w.WriteData(o.LCPOptions); err != nil {
		return err
	}
	if err := w.WriteData(o.LCPRemoteOptions); err != nil {
		return err
	}
	if err := w.WriteData(o.EAPTypeID); err != nil {
		return err
	}
	if err := w.WriteData(o.RemoteEAPTypeID); err != nil {
		return err
	}
	if err := w.WriteData(o.CCPError); err != nil {
		return err
	}
	if err := w.WriteData(o.CompressionAlgorithm); err != nil {
		return err
	}
	if err := w.WriteData(o.CCPOptions); err != nil {
		return err
	}
	if err := w.WriteData(o.RemoteCompressionAlgorithm); err != nil {
		return err
	}
	if err := w.WriteData(o.CCPRemoteOptions); err != nil {
		return err
	}
	if err := w.WriteTrailingGap(8); err != nil {
		return err
	}
	return nil
}
func (o *PPPProjectionInfo1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if err := w.ReadData(&o.IPv4NegotiationError); err != nil {
		return err
	}
	o.Address = make([]uint16, 16)
	for i1 := range o.Address {
		i1 := i1
		if err := w.ReadData(&o.Address[i1]); err != nil {
			return err
		}
	}
	o.RemoteAddress = make([]uint16, 16)
	for i1 := range o.RemoteAddress {
		i1 := i1
		if err := w.ReadData(&o.RemoteAddress[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.IPv4Options); err != nil {
		return err
	}
	if err := w.ReadData(&o.IPv4RemoteOptions); err != nil {
		return err
	}
	if err := w.ReadData(&o.IPv4SubInterfaceIndex); err != nil {
		return err
	}
	if err := w.ReadData(&o.IPv6NegotiationError); err != nil {
		return err
	}
	o.InterfaceID = make([]byte, 8)
	for i1 := range o.InterfaceID {
		i1 := i1
		if err := w.ReadData(&o.InterfaceID[i1]); err != nil {
			return err
		}
	}
	o.RemoteInterfaceID = make([]byte, 8)
	for i1 := range o.RemoteInterfaceID {
		i1 := i1
		if err := w.ReadData(&o.RemoteInterfaceID[i1]); err != nil {
			return err
		}
	}
	o.Prefix = make([]byte, 8)
	for i1 := range o.Prefix {
		i1 := i1
		if err := w.ReadData(&o.Prefix[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.PrefixLength); err != nil {
		return err
	}
	if err := w.ReadData(&o.IPv6SubInterfaceIndex); err != nil {
		return err
	}
	if err := w.ReadData(&o.LCPError); err != nil {
		return err
	}
	if err := w.ReadData(&o.AuthenticationProtocol); err != nil {
		return err
	}
	if err := w.ReadData(&o.AuthenticationData); err != nil {
		return err
	}
	if err := w.ReadData(&o.RemoteAuthenticationProtocol); err != nil {
		return err
	}
	if err := w.ReadData(&o.RemoteAuthenticationData); err != nil {
		return err
	}
	if err := w.ReadData(&o.LCPTerminateReason); err != nil {
		return err
	}
	if err := w.ReadData(&o.LCPRemoteTerminateReason); err != nil {
		return err
	}
	if err := w.ReadData(&o.LCPOptions); err != nil {
		return err
	}
	if err := w.ReadData(&o.LCPRemoteOptions); err != nil {
		return err
	}
	if err := w.ReadData(&o.EAPTypeID); err != nil {
		return err
	}
	if err := w.ReadData(&o.RemoteEAPTypeID); err != nil {
		return err
	}
	if err := w.ReadData(&o.CCPError); err != nil {
		return err
	}
	if err := w.ReadData(&o.CompressionAlgorithm); err != nil {
		return err
	}
	if err := w.ReadData(&o.CCPOptions); err != nil {
		return err
	}
	if err := w.ReadData(&o.RemoteCompressionAlgorithm); err != nil {
		return err
	}
	if err := w.ReadData(&o.CCPRemoteOptions); err != nil {
		return err
	}
	if err := w.ReadTrailingGap(8); err != nil {
		return err
	}
	return nil
}

// PPPProjectionInfo2 structure represents PPP_PROJECTION_INFO_2 RPC structure.
//
// The PPP_PROJECTION_INFO_2 structure<162> contain information obtained during the
// PPP negotiation for the PPP-based tunnels.
type PPPProjectionInfo2 struct {
	// dwIPv4NegotiationError: Same as dwIPv4NegotiationError in PPP_PROJECTION_INFO_1 (section
	// 2.2.1.2.130).
	IPv4NegotiationError uint32 `idl:"name:dwIPv4NegotiationError" json:"ipv4_negotiation_error"`
	// wszAddress: Same as wszAddress in PPP_PROJECTION_INFO_1.
	Address []uint16 `idl:"name:wszAddress" json:"address"`
	// wszRemoteAddress: Same as wszRemoteAddress in PPP_PROJECTION_INFO_1.
	RemoteAddress []uint16 `idl:"name:wszRemoteAddress" json:"remote_address"`
	// dwIPv4Options: Same as dwIPv4Options in PPP_PROJECTION_INFO_1.
	IPv4Options uint32 `idl:"name:dwIPv4Options" json:"ipv4_options"`
	// dwIPv4RemoteOptions: Same as dwIPv4RemoteOptions in PPP_PROJECTION_INFO_1.
	IPv4RemoteOptions uint32 `idl:"name:dwIPv4RemoteOptions" json:"ipv4_remote_options"`
	// IPv4SubInterfaceIndex: Same as IPv4SubInterfaceIndex in PPP_PROJECTION_INFO_1.
	IPv4SubInterfaceIndex uint64 `idl:"name:IPv4SubInterfaceIndex" json:"ipv4_sub_interface_index"`
	// dwIPv6NegotiationError: Same as dwIPv6NegotiationError in PPP_PROJECTION_INFO_1.
	IPv6NegotiationError uint32 `idl:"name:dwIPv6NegotiationError" json:"ipv6_negotiation_error"`
	// bInterfaceIdentifier: Same as bInterfaceIdentifier in PPP_PROJECTION_INFO_1.
	InterfaceID []byte `idl:"name:bInterfaceIdentifier" json:"interface_id"`
	// bRemoteInterfaceIdentifier: Same as bRemoteInterfaceIdentifier in PPP_PROJECTION_INFO_1.
	RemoteInterfaceID []byte `idl:"name:bRemoteInterfaceIdentifier" json:"remote_interface_id"`
	// bPrefix: Same as bPrefix in PPP_PROJECTION_INFO_1.
	Prefix []byte `idl:"name:bPrefix" json:"prefix"`
	// dwPrefixLength: Same as bPrefix in PPP_PROJECTION_INFO_1.
	PrefixLength uint32 `idl:"name:dwPrefixLength" json:"prefix_length"`
	// IPv6SubInterfaceIndex: Same as IPv6SubInterfaceIndex in PPP_PROJECTION_INFO_1.
	IPv6SubInterfaceIndex uint64 `idl:"name:IPv6SubInterfaceIndex" json:"ipv6_sub_interface_index"`
	// dwLcpError: Same as dwLcpError in PPP_PROJECTION_INFO_1.
	LCPError uint32 `idl:"name:dwLcpError" json:"lcp_error"`
	// dwAuthenticationProtocol: Same as dwAuthenticationProtocol in PPP_PROJECTION_INFO_1.
	AuthenticationProtocol uint32 `idl:"name:dwAuthenticationProtocol" json:"authentication_protocol"`
	// dwAuthenticationData: Same as dwAuthenticationData in PPP_PROJECTION_INFO_1.
	AuthenticationData uint32 `idl:"name:dwAuthenticationData" json:"authentication_data"`
	// dwRemoteAuthenticationProtocol: Same as dwRemoteAuthenticationProtocol in PPP_PROJECTION_INFO_1.
	RemoteAuthenticationProtocol uint32 `idl:"name:dwRemoteAuthenticationProtocol" json:"remote_authentication_protocol"`
	// dwRemoteAuthenticationData: Same as dwRemoteAuthenticationData in PPP_PROJECTION_INFO_1.
	RemoteAuthenticationData uint32 `idl:"name:dwRemoteAuthenticationData" json:"remote_authentication_data"`
	// dwLcpTerminateReason: Same as dwLcpTerminateReason in PPP_PROJECTION_INFO_1.
	LCPTerminateReason uint32 `idl:"name:dwLcpTerminateReason" json:"lcp_terminate_reason"`
	// dwLcpRemoteTerminateReason: Same as dwLcpRemoteTerminateReason in PPP_PROJECTION_INFO_1.
	LCPRemoteTerminateReason uint32 `idl:"name:dwLcpRemoteTerminateReason" json:"lcp_remote_terminate_reason"`
	// dwLcpOptions: Same as dwLcpOptions in PPP_PROJECTION_INFO_1.
	LCPOptions uint32 `idl:"name:dwLcpOptions" json:"lcp_options"`
	// dwLcpRemoteOptions: Same as dwLcpRemoteOptions in PPP_PROJECTION_INFO_1.
	LCPRemoteOptions uint32 `idl:"name:dwLcpRemoteOptions" json:"lcp_remote_options"`
	// dwEapTypeId: Same as dwEapTypeId in PPP_PROJECTION_INFO_1.
	EAPTypeID uint32 `idl:"name:dwEapTypeId" json:"eap_type_id"`
	// dwEmbeddedEAPTypeId: Specifies the type identifier of the inner EAP method used in
	// the EAP [MS-PEAP] authentication. The value of this member is valid only if the dwEapTypeId
	// member is set to PEAP (defined in [IANA-EAP]). The valid values are defined in [IANA-EAP].
	EmbeddedEAPTypeID uint32 `idl:"name:dwEmbeddedEAPTypeId" json:"embedded_eap_type_id"`
	// dwRemoteEapTypeId: Same as dwRemoteEapTypeId in PPP_PROJECTION_INFO_1.
	RemoteEAPTypeID uint32 `idl:"name:dwRemoteEapTypeId" json:"remote_eap_type_id"`
	// dwCcpError: Same as dwCcpError in PPP_PROJECTION_INFO_1.
	CCPError uint32 `idl:"name:dwCcpError" json:"ccp_error"`
	// dwCompressionAlgorithm: Same as dwCompressionAlgorithm in PPP_PROJECTION_INFO_1.
	CompressionAlgorithm uint32 `idl:"name:dwCompressionAlgorithm" json:"compression_algorithm"`
	// dwCcpOptions: Same as dwCcpOptions in PPP_PROJECTION_INFO_1.
	CCPOptions uint32 `idl:"name:dwCcpOptions" json:"ccp_options"`
	// dwRemoteCompressionAlgorithm: Same as dwRemoteCompressionAlgorithm in PPP_PROJECTION_INFO_1.
	RemoteCompressionAlgorithm uint32 `idl:"name:dwRemoteCompressionAlgorithm" json:"remote_compression_algorithm"`
	// dwCcpRemoteOptions: Same as dwCcpRemoteOptions in PPP_PROJECTION_INFO_1.
	CCPRemoteOptions uint32 `idl:"name:dwCcpRemoteOptions" json:"ccp_remote_options"`
}

func (o *PPPProjectionInfo2) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *PPPProjectionInfo2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if err := w.WriteData(o.IPv4NegotiationError); err != nil {
		return err
	}
	for i1 := range o.Address {
		i1 := i1
		if uint64(i1) >= 16 {
			break
		}
		if err := w.WriteData(o.Address[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Address); uint64(i1) < 16; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	for i1 := range o.RemoteAddress {
		i1 := i1
		if uint64(i1) >= 16 {
			break
		}
		if err := w.WriteData(o.RemoteAddress[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.RemoteAddress); uint64(i1) < 16; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.IPv4Options); err != nil {
		return err
	}
	if err := w.WriteData(o.IPv4RemoteOptions); err != nil {
		return err
	}
	if err := w.WriteData(o.IPv4SubInterfaceIndex); err != nil {
		return err
	}
	if err := w.WriteData(o.IPv6NegotiationError); err != nil {
		return err
	}
	for i1 := range o.InterfaceID {
		i1 := i1
		if uint64(i1) >= 8 {
			break
		}
		if err := w.WriteData(o.InterfaceID[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.InterfaceID); uint64(i1) < 8; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	for i1 := range o.RemoteInterfaceID {
		i1 := i1
		if uint64(i1) >= 8 {
			break
		}
		if err := w.WriteData(o.RemoteInterfaceID[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.RemoteInterfaceID); uint64(i1) < 8; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	for i1 := range o.Prefix {
		i1 := i1
		if uint64(i1) >= 8 {
			break
		}
		if err := w.WriteData(o.Prefix[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Prefix); uint64(i1) < 8; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.PrefixLength); err != nil {
		return err
	}
	if err := w.WriteData(o.IPv6SubInterfaceIndex); err != nil {
		return err
	}
	if err := w.WriteData(o.LCPError); err != nil {
		return err
	}
	if err := w.WriteData(o.AuthenticationProtocol); err != nil {
		return err
	}
	if err := w.WriteData(o.AuthenticationData); err != nil {
		return err
	}
	if err := w.WriteData(o.RemoteAuthenticationProtocol); err != nil {
		return err
	}
	if err := w.WriteData(o.RemoteAuthenticationData); err != nil {
		return err
	}
	if err := w.WriteData(o.LCPTerminateReason); err != nil {
		return err
	}
	if err := w.WriteData(o.LCPRemoteTerminateReason); err != nil {
		return err
	}
	if err := w.WriteData(o.LCPOptions); err != nil {
		return err
	}
	if err := w.WriteData(o.LCPRemoteOptions); err != nil {
		return err
	}
	if err := w.WriteData(o.EAPTypeID); err != nil {
		return err
	}
	if err := w.WriteData(o.EmbeddedEAPTypeID); err != nil {
		return err
	}
	if err := w.WriteData(o.RemoteEAPTypeID); err != nil {
		return err
	}
	if err := w.WriteData(o.CCPError); err != nil {
		return err
	}
	if err := w.WriteData(o.CompressionAlgorithm); err != nil {
		return err
	}
	if err := w.WriteData(o.CCPOptions); err != nil {
		return err
	}
	if err := w.WriteData(o.RemoteCompressionAlgorithm); err != nil {
		return err
	}
	if err := w.WriteData(o.CCPRemoteOptions); err != nil {
		return err
	}
	if err := w.WriteTrailingGap(8); err != nil {
		return err
	}
	return nil
}
func (o *PPPProjectionInfo2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if err := w.ReadData(&o.IPv4NegotiationError); err != nil {
		return err
	}
	o.Address = make([]uint16, 16)
	for i1 := range o.Address {
		i1 := i1
		if err := w.ReadData(&o.Address[i1]); err != nil {
			return err
		}
	}
	o.RemoteAddress = make([]uint16, 16)
	for i1 := range o.RemoteAddress {
		i1 := i1
		if err := w.ReadData(&o.RemoteAddress[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.IPv4Options); err != nil {
		return err
	}
	if err := w.ReadData(&o.IPv4RemoteOptions); err != nil {
		return err
	}
	if err := w.ReadData(&o.IPv4SubInterfaceIndex); err != nil {
		return err
	}
	if err := w.ReadData(&o.IPv6NegotiationError); err != nil {
		return err
	}
	o.InterfaceID = make([]byte, 8)
	for i1 := range o.InterfaceID {
		i1 := i1
		if err := w.ReadData(&o.InterfaceID[i1]); err != nil {
			return err
		}
	}
	o.RemoteInterfaceID = make([]byte, 8)
	for i1 := range o.RemoteInterfaceID {
		i1 := i1
		if err := w.ReadData(&o.RemoteInterfaceID[i1]); err != nil {
			return err
		}
	}
	o.Prefix = make([]byte, 8)
	for i1 := range o.Prefix {
		i1 := i1
		if err := w.ReadData(&o.Prefix[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.PrefixLength); err != nil {
		return err
	}
	if err := w.ReadData(&o.IPv6SubInterfaceIndex); err != nil {
		return err
	}
	if err := w.ReadData(&o.LCPError); err != nil {
		return err
	}
	if err := w.ReadData(&o.AuthenticationProtocol); err != nil {
		return err
	}
	if err := w.ReadData(&o.AuthenticationData); err != nil {
		return err
	}
	if err := w.ReadData(&o.RemoteAuthenticationProtocol); err != nil {
		return err
	}
	if err := w.ReadData(&o.RemoteAuthenticationData); err != nil {
		return err
	}
	if err := w.ReadData(&o.LCPTerminateReason); err != nil {
		return err
	}
	if err := w.ReadData(&o.LCPRemoteTerminateReason); err != nil {
		return err
	}
	if err := w.ReadData(&o.LCPOptions); err != nil {
		return err
	}
	if err := w.ReadData(&o.LCPRemoteOptions); err != nil {
		return err
	}
	if err := w.ReadData(&o.EAPTypeID); err != nil {
		return err
	}
	if err := w.ReadData(&o.EmbeddedEAPTypeID); err != nil {
		return err
	}
	if err := w.ReadData(&o.RemoteEAPTypeID); err != nil {
		return err
	}
	if err := w.ReadData(&o.CCPError); err != nil {
		return err
	}
	if err := w.ReadData(&o.CompressionAlgorithm); err != nil {
		return err
	}
	if err := w.ReadData(&o.CCPOptions); err != nil {
		return err
	}
	if err := w.ReadData(&o.RemoteCompressionAlgorithm); err != nil {
		return err
	}
	if err := w.ReadData(&o.CCPRemoteOptions); err != nil {
		return err
	}
	if err := w.ReadTrailingGap(8); err != nil {
		return err
	}
	return nil
}

// IKEv2ProjectionInfo1 structure represents IKEV2_PROJECTION_INFO_1 RPC structure.
//
// The IKEV2_PROJECTION_INFO_1 structure SHOULD<118> contain information obtained during
// Internet Key Exchange (IKE) negotiation.
type IKEv2ProjectionInfo1 struct {
	// dwIPv4NegotiationError: Specifies if an Internal IPv4 address [RFC4306] has been
	// successfully assigned. A value of zero (0) indicates success. A nonzero value indicates
	// failure.
	IPv4NegotiationError uint32 `idl:"name:dwIPv4NegotiationError" json:"ipv4_negotiation_error"`
	// wszAddress: The same as wszAddress in PPP_PROJECTION_INFO_1.
	Address []uint16 `idl:"name:wszAddress" json:"address"`
	// wszRemoteAddress: The same as wszRemoteAddress in PPP_PROJECTION_INFO_1.
	RemoteAddress []uint16 `idl:"name:wszRemoteAddress" json:"remote_address"`
	// IPv4SubInterfaceIndex: The same as IPv4SubInterfaceIndex in PPP_PROJECTION_INFO_1.
	IPv4SubInterfaceIndex uint64 `idl:"name:IPv4SubInterfaceIndex" json:"ipv4_sub_interface_index"`
	// dwIPv6NegotiationError: The same as dwIPv5NegotiationError in PPP_PROJECTION_INFO_1.
	IPv6NegotiationError uint32 `idl:"name:dwIPv6NegotiationError" json:"ipv6_negotiation_error"`
	// bInterfaceIdentifier: The same as bInterfaceIdentifier in PPP_PROJECTION_INFO_1.
	InterfaceID []byte `idl:"name:bInterfaceIdentifier" json:"interface_id"`
	// bRemoteInterfaceIdentifier: The same as bRemoteInterfaceIdentifier in PPP_PROJECTION_INFO_1.
	RemoteInterfaceID []byte `idl:"name:bRemoteInterfaceIdentifier" json:"remote_interface_id"`
	// bPrefix: The same as bPrefix in PPP_PROJECTION_INFO_1.
	Prefix []byte `idl:"name:bPrefix" json:"prefix"`
	// dwPrefixLength: The same as dwPrefixLength in PPP_PROJECTION_INFO_1.
	PrefixLength uint32 `idl:"name:dwPrefixLength" json:"prefix_length"`
	// IPv6SubInterfaceIndex: The same as IPv6SubInterfaceIndex in PPP_PROJECTION_INFO_1.
	IPv6SubInterfaceIndex uint64 `idl:"name:IPv6SubInterfaceIndex" json:"ipv6_sub_interface_index"`
	// dwOptions: Not used.
	Options uint32 `idl:"name:dwOptions" json:"options"`
	// dwAuthenticationProtocol: Specifies the authentication protocol used to authenticate
	// the remote computer. It MUST be one of the following values.
	//
	//	+-----------------------------------------+--------------------------------------------+
	//	|                                         |                                            |
	//	|                  VALUE                  |                  MEANING                   |
	//	|                                         |                                            |
	//	+-----------------------------------------+--------------------------------------------+
	//	+-----------------------------------------+--------------------------------------------+
	//	| MPRAPI_IKEV2_AUTH_USING_CERT 0x00000001 | Using x.509 machine certificate [RFC2459]. |
	//	+-----------------------------------------+--------------------------------------------+
	//	| MPRAPI_IKEV2_AUTH_USING_EAP 0x00000002  | Extensible Authentication Protocol (EAP).  |
	//	+-----------------------------------------+--------------------------------------------+
	AuthenticationProtocol uint32 `idl:"name:dwAuthenticationProtocol" json:"authentication_protocol"`
	// dwEapTypeId: Specifies the type identifier of the EAP used to authenticate the local
	// computer. The value of this member is valid only if dwAuthenticationProtocol is MPRAPI_IKEV2_AUTH_USING_EAP
	// [IANA-EAP].
	EAPTypeID uint32 `idl:"name:dwEapTypeId" json:"eap_type_id"`
	// dwCompressionAlgorithm: Not used.
	CompressionAlgorithm uint32 `idl:"name:dwCompressionAlgorithm" json:"compression_algorithm"`
	// dwEncryptionMethod: Specifies the encryption method used in the connection. It MUST
	// be one of the following values.
	//
	//	+-----------------------------+-------------------------------+
	//	|                             |                               |
	//	|            VALUE            |            MEANING            |
	//	|                             |                               |
	//	+-----------------------------+-------------------------------+
	//	+-----------------------------+-------------------------------+
	//	| IPSEC_CIPHER_TYPE_3DES 2    | Specifies 3DES encryption.    |
	//	+-----------------------------+-------------------------------+
	//	| IPSEC_CIPHER_TYPE_AES_128 3 | Specifies AES-128 encryption. |
	//	+-----------------------------+-------------------------------+
	//	| IPSEC_CIPHER_TYPE_AES_192 4 | Specifies AES-192 encryption. |
	//	+-----------------------------+-------------------------------+
	//	| IPSEC_CIPHER_TYPE_AES_256 5 | Specifies AES-256 encryption. |
	//	+-----------------------------+-------------------------------+
	EncryptionMethod uint32 `idl:"name:dwEncryptionMethod" json:"encryption_method"`
}

func (o *IKEv2ProjectionInfo1) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IKEv2ProjectionInfo1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if err := w.WriteData(o.IPv4NegotiationError); err != nil {
		return err
	}
	for i1 := range o.Address {
		i1 := i1
		if uint64(i1) >= 16 {
			break
		}
		if err := w.WriteData(o.Address[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Address); uint64(i1) < 16; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	for i1 := range o.RemoteAddress {
		i1 := i1
		if uint64(i1) >= 16 {
			break
		}
		if err := w.WriteData(o.RemoteAddress[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.RemoteAddress); uint64(i1) < 16; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.IPv4SubInterfaceIndex); err != nil {
		return err
	}
	if err := w.WriteData(o.IPv6NegotiationError); err != nil {
		return err
	}
	for i1 := range o.InterfaceID {
		i1 := i1
		if uint64(i1) >= 8 {
			break
		}
		if err := w.WriteData(o.InterfaceID[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.InterfaceID); uint64(i1) < 8; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	for i1 := range o.RemoteInterfaceID {
		i1 := i1
		if uint64(i1) >= 8 {
			break
		}
		if err := w.WriteData(o.RemoteInterfaceID[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.RemoteInterfaceID); uint64(i1) < 8; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	for i1 := range o.Prefix {
		i1 := i1
		if uint64(i1) >= 8 {
			break
		}
		if err := w.WriteData(o.Prefix[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Prefix); uint64(i1) < 8; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.PrefixLength); err != nil {
		return err
	}
	if err := w.WriteData(o.IPv6SubInterfaceIndex); err != nil {
		return err
	}
	if err := w.WriteData(o.Options); err != nil {
		return err
	}
	if err := w.WriteData(o.AuthenticationProtocol); err != nil {
		return err
	}
	if err := w.WriteData(o.EAPTypeID); err != nil {
		return err
	}
	if err := w.WriteData(o.CompressionAlgorithm); err != nil {
		return err
	}
	if err := w.WriteData(o.EncryptionMethod); err != nil {
		return err
	}
	if err := w.WriteTrailingGap(8); err != nil {
		return err
	}
	return nil
}
func (o *IKEv2ProjectionInfo1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if err := w.ReadData(&o.IPv4NegotiationError); err != nil {
		return err
	}
	o.Address = make([]uint16, 16)
	for i1 := range o.Address {
		i1 := i1
		if err := w.ReadData(&o.Address[i1]); err != nil {
			return err
		}
	}
	o.RemoteAddress = make([]uint16, 16)
	for i1 := range o.RemoteAddress {
		i1 := i1
		if err := w.ReadData(&o.RemoteAddress[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.IPv4SubInterfaceIndex); err != nil {
		return err
	}
	if err := w.ReadData(&o.IPv6NegotiationError); err != nil {
		return err
	}
	o.InterfaceID = make([]byte, 8)
	for i1 := range o.InterfaceID {
		i1 := i1
		if err := w.ReadData(&o.InterfaceID[i1]); err != nil {
			return err
		}
	}
	o.RemoteInterfaceID = make([]byte, 8)
	for i1 := range o.RemoteInterfaceID {
		i1 := i1
		if err := w.ReadData(&o.RemoteInterfaceID[i1]); err != nil {
			return err
		}
	}
	o.Prefix = make([]byte, 8)
	for i1 := range o.Prefix {
		i1 := i1
		if err := w.ReadData(&o.Prefix[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.PrefixLength); err != nil {
		return err
	}
	if err := w.ReadData(&o.IPv6SubInterfaceIndex); err != nil {
		return err
	}
	if err := w.ReadData(&o.Options); err != nil {
		return err
	}
	if err := w.ReadData(&o.AuthenticationProtocol); err != nil {
		return err
	}
	if err := w.ReadData(&o.EAPTypeID); err != nil {
		return err
	}
	if err := w.ReadData(&o.CompressionAlgorithm); err != nil {
		return err
	}
	if err := w.ReadData(&o.EncryptionMethod); err != nil {
		return err
	}
	if err := w.ReadTrailingGap(8); err != nil {
		return err
	}
	return nil
}

// IKEv2ProjectionInfo2 structure represents IKEV2_PROJECTION_INFO_2 RPC structure.
//
// The IKEV2_PROJECTION_INFO_2 structure<163> contain information obtained during Internet
// key exchange (IKE) negotiation.
type IKEv2ProjectionInfo2 struct {
	// dwIPv4NegotiationError: Same as dwIPv4NegotiationError in IKEV2_PROJECTION_INFO_1.
	IPv4NegotiationError uint32 `idl:"name:dwIPv4NegotiationError" json:"ipv4_negotiation_error"`
	// wszAddress: Same as wszAddress in  IKEV2_PROJECTION_INFO_1.
	Address []uint16 `idl:"name:wszAddress" json:"address"`
	// wszRemoteAddress: Same as wszRemoteAddress in  IKEV2_PROJECTION_INFO_1.
	RemoteAddress []uint16 `idl:"name:wszRemoteAddress" json:"remote_address"`
	// IPv4SubInterfaceIndex: Same as IPv4SubInterfaceIndex in  IKEV2_PROJECTION_INFO_1.
	IPv4SubInterfaceIndex uint64 `idl:"name:IPv4SubInterfaceIndex" json:"ipv4_sub_interface_index"`
	// dwIPv6NegotiationError: Same as dwIPv6NegotiationError in  IKEV2_PROJECTION_INFO_1.
	IPv6NegotiationError uint32 `idl:"name:dwIPv6NegotiationError" json:"ipv6_negotiation_error"`
	// bInterfaceIdentifier: Same as bInterfaceIdentifier in  IKEV2_PROJECTION_INFO_1.
	InterfaceID []byte `idl:"name:bInterfaceIdentifier" json:"interface_id"`
	// bRemoteInterfaceIdentifier: Same as bRemoteInterfaceIdentifier in  IKEV2_PROJECTION_INFO_1.
	RemoteInterfaceID []byte `idl:"name:bRemoteInterfaceIdentifier" json:"remote_interface_id"`
	// bPrefix: Same as bPrefix in  IKEV2_PROJECTION_INFO_1.
	Prefix []byte `idl:"name:bPrefix" json:"prefix"`
	// dwPrefixLength: Same as dwPrefixLength in  IKEV2_PROJECTION_INFO_1.
	PrefixLength uint32 `idl:"name:dwPrefixLength" json:"prefix_length"`
	// IPv6SubInterfaceIndex: Same as IPv6SubInterfaceIndex in  IKEV2_PROJECTION_INFO_1.
	IPv6SubInterfaceIndex uint64 `idl:"name:IPv6SubInterfaceIndex" json:"ipv6_sub_interface_index"`
	// dwOptions: Same as dwOptions in  IKEV2_PROJECTION_INFO_1.
	Options uint32 `idl:"name:dwOptions" json:"options"`
	// dwAuthenticationProtocol: Same as dwAuthenticationProtocol in  IKEV2_PROJECTION_INFO_1.
	AuthenticationProtocol uint32 `idl:"name:dwAuthenticationProtocol" json:"authentication_protocol"`
	// dwEapTypeId: Same as dwEapTypeId in  IKEV2_PROJECTION_INFO_1.
	EAPTypeID uint32 `idl:"name:dwEapTypeId" json:"eap_type_id"`
	// dwEmbeddedEAPTypeId: Same as dwEmbeddedEAPTypeId in  IKEV2_PROJECTION_INFO_1.
	EmbeddedEAPTypeID uint32 `idl:"name:dwEmbeddedEAPTypeId" json:"embedded_eap_type_id"`
	// dwCompressionAlgorithm: Same as dwCompressionAlgorithm in  IKEV2_PROJECTION_INFO_1.
	CompressionAlgorithm uint32 `idl:"name:dwCompressionAlgorithm" json:"compression_algorithm"`
	// dwEncryptionMethod: Same as dwEncryptionMethod in IKEV2_PROJECTION_INFO_1.
	EncryptionMethod uint32 `idl:"name:dwEncryptionMethod" json:"encryption_method"`
}

func (o *IKEv2ProjectionInfo2) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IKEv2ProjectionInfo2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if err := w.WriteData(o.IPv4NegotiationError); err != nil {
		return err
	}
	for i1 := range o.Address {
		i1 := i1
		if uint64(i1) >= 16 {
			break
		}
		if err := w.WriteData(o.Address[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Address); uint64(i1) < 16; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	for i1 := range o.RemoteAddress {
		i1 := i1
		if uint64(i1) >= 16 {
			break
		}
		if err := w.WriteData(o.RemoteAddress[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.RemoteAddress); uint64(i1) < 16; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.IPv4SubInterfaceIndex); err != nil {
		return err
	}
	if err := w.WriteData(o.IPv6NegotiationError); err != nil {
		return err
	}
	for i1 := range o.InterfaceID {
		i1 := i1
		if uint64(i1) >= 8 {
			break
		}
		if err := w.WriteData(o.InterfaceID[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.InterfaceID); uint64(i1) < 8; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	for i1 := range o.RemoteInterfaceID {
		i1 := i1
		if uint64(i1) >= 8 {
			break
		}
		if err := w.WriteData(o.RemoteInterfaceID[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.RemoteInterfaceID); uint64(i1) < 8; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	for i1 := range o.Prefix {
		i1 := i1
		if uint64(i1) >= 8 {
			break
		}
		if err := w.WriteData(o.Prefix[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Prefix); uint64(i1) < 8; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.PrefixLength); err != nil {
		return err
	}
	if err := w.WriteData(o.IPv6SubInterfaceIndex); err != nil {
		return err
	}
	if err := w.WriteData(o.Options); err != nil {
		return err
	}
	if err := w.WriteData(o.AuthenticationProtocol); err != nil {
		return err
	}
	if err := w.WriteData(o.EAPTypeID); err != nil {
		return err
	}
	if err := w.WriteData(o.EmbeddedEAPTypeID); err != nil {
		return err
	}
	if err := w.WriteData(o.CompressionAlgorithm); err != nil {
		return err
	}
	if err := w.WriteData(o.EncryptionMethod); err != nil {
		return err
	}
	if err := w.WriteTrailingGap(8); err != nil {
		return err
	}
	return nil
}
func (o *IKEv2ProjectionInfo2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if err := w.ReadData(&o.IPv4NegotiationError); err != nil {
		return err
	}
	o.Address = make([]uint16, 16)
	for i1 := range o.Address {
		i1 := i1
		if err := w.ReadData(&o.Address[i1]); err != nil {
			return err
		}
	}
	o.RemoteAddress = make([]uint16, 16)
	for i1 := range o.RemoteAddress {
		i1 := i1
		if err := w.ReadData(&o.RemoteAddress[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.IPv4SubInterfaceIndex); err != nil {
		return err
	}
	if err := w.ReadData(&o.IPv6NegotiationError); err != nil {
		return err
	}
	o.InterfaceID = make([]byte, 8)
	for i1 := range o.InterfaceID {
		i1 := i1
		if err := w.ReadData(&o.InterfaceID[i1]); err != nil {
			return err
		}
	}
	o.RemoteInterfaceID = make([]byte, 8)
	for i1 := range o.RemoteInterfaceID {
		i1 := i1
		if err := w.ReadData(&o.RemoteInterfaceID[i1]); err != nil {
			return err
		}
	}
	o.Prefix = make([]byte, 8)
	for i1 := range o.Prefix {
		i1 := i1
		if err := w.ReadData(&o.Prefix[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.PrefixLength); err != nil {
		return err
	}
	if err := w.ReadData(&o.IPv6SubInterfaceIndex); err != nil {
		return err
	}
	if err := w.ReadData(&o.Options); err != nil {
		return err
	}
	if err := w.ReadData(&o.AuthenticationProtocol); err != nil {
		return err
	}
	if err := w.ReadData(&o.EAPTypeID); err != nil {
		return err
	}
	if err := w.ReadData(&o.EmbeddedEAPTypeID); err != nil {
		return err
	}
	if err := w.ReadData(&o.CompressionAlgorithm); err != nil {
		return err
	}
	if err := w.ReadData(&o.EncryptionMethod); err != nil {
		return err
	}
	if err := w.ReadTrailingGap(8); err != nil {
		return err
	}
	return nil
}

// ProjectionInfoIDL1 structure represents PROJECTION_INFO_IDL_1 RPC union.
//
// The PROJECTION_INFO_IDL_1 union is used in RAS_CONNECTION_EX_1_IDL (section 2.2.1.2.133)
// structure as a placeholder for PPP_PROJECTION_INFO_1 (section 2.2.1.2.130) structure
// or IKEV2_PROJECTION_INFO_1 (section 2.2.1.2.131) structure.
type ProjectionInfoIDL1 struct {
	ProjectionInfoType uint8
	// Types that are assignable to Value
	//
	// *ProjectionInfoIDL1_PPPProjectionInfo
	// *ProjectionInfoIDL1_IKEv2ProjectionInfo
	Value is_ProjectionInfoIDL1 `json:"value"`
}

func (o *ProjectionInfoIDL1) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *ProjectionInfoIDL1_PPPProjectionInfo:
		if value != nil {
			return value.PPPProjectionInfo
		}
	case *ProjectionInfoIDL1_IKEv2ProjectionInfo:
		if value != nil {
			return value.IKEv2ProjectionInfo
		}
	}
	return nil
}

type is_ProjectionInfoIDL1 interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_ProjectionInfoIDL1()
}

func (o *ProjectionInfoIDL1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := w.WriteUnionAlign(8); err != nil {
		return err
	}
	if err := w.WriteData(uint8(o.ProjectionInfoType)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(8); err != nil {
		return err
	}
	switch o.ProjectionInfoType {
	case uint8(1):
		_o, _ := o.Value.(*ProjectionInfoIDL1_PPPProjectionInfo)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ProjectionInfoIDL1_PPPProjectionInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint8(2):
		_o, _ := o.Value.(*ProjectionInfoIDL1_IKEv2ProjectionInfo)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ProjectionInfoIDL1_IKEv2ProjectionInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", o.ProjectionInfoType)
	}
	return nil
}

func (o *ProjectionInfoIDL1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadUnionAlign(8); err != nil {
		return err
	}
	if err := w.ReadData((*uint8)(&o.ProjectionInfoType)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(8); err != nil {
		return err
	}
	switch o.ProjectionInfoType {
	case uint8(1):
		o.Value = &ProjectionInfoIDL1_PPPProjectionInfo{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint8(2):
		o.Value = &ProjectionInfoIDL1_IKEv2ProjectionInfo{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", o.ProjectionInfoType)
	}
	return nil
}

// ProjectionInfoIDL1_PPPProjectionInfo structure represents PROJECTION_INFO_IDL_1 RPC union arm.
//
// It has following labels: 1
type ProjectionInfoIDL1_PPPProjectionInfo struct {
	// PppProjectionInfo: Contains a PPP_PROJECTION_INFO_1 for a PPP-based tunnel.
	PPPProjectionInfo *PPPProjectionInfo1 `idl:"name:PppProjectionInfo" json:"ppp_projection_info"`
}

func (*ProjectionInfoIDL1_PPPProjectionInfo) is_ProjectionInfoIDL1() {}

func (o *ProjectionInfoIDL1_PPPProjectionInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.PPPProjectionInfo != nil {
		if err := o.PPPProjectionInfo.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&PPPProjectionInfo1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *ProjectionInfoIDL1_PPPProjectionInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.PPPProjectionInfo == nil {
		o.PPPProjectionInfo = &PPPProjectionInfo1{}
	}
	if err := o.PPPProjectionInfo.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// ProjectionInfoIDL1_IKEv2ProjectionInfo structure represents PROJECTION_INFO_IDL_1 RPC union arm.
//
// It has following labels: 2
type ProjectionInfoIDL1_IKEv2ProjectionInfo struct {
	// Ikev2ProjectionInfo: Contains an IKEV2_PROJECTION_INFO_1 for an IKEv2-based tunnel.
	IKEv2ProjectionInfo *IKEv2ProjectionInfo1 `idl:"name:Ikev2ProjectionInfo" json:"ikev2_projection_info"`
}

func (*ProjectionInfoIDL1_IKEv2ProjectionInfo) is_ProjectionInfoIDL1() {}

func (o *ProjectionInfoIDL1_IKEv2ProjectionInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.IKEv2ProjectionInfo != nil {
		if err := o.IKEv2ProjectionInfo.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&IKEv2ProjectionInfo1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *ProjectionInfoIDL1_IKEv2ProjectionInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.IKEv2ProjectionInfo == nil {
		o.IKEv2ProjectionInfo = &IKEv2ProjectionInfo1{}
	}
	if err := o.IKEv2ProjectionInfo.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// ProjectionInfoIDL2 structure represents PROJECTION_INFO_IDL_2 RPC union.
//
// The PROJECTION_INFO_IDL_2 structure<164> is used in the RAS_CONNECTION_4_IDL (section
// 2.2.1.2.236) structure as a placeholder for PPP_PROJECTION_INFO_2 (section 2.2.1.2.233)
// structure or IKEV2_PROJECTION_INFO_2 (section 2.2.1.2.234) structure.
type ProjectionInfoIDL2 struct {
	ProjectionInfoType uint8
	// Types that are assignable to Value
	//
	// *ProjectionInfoIDL2_PPPProjectionInfo
	// *ProjectionInfoIDL2_IKEv2ProjectionInfo
	Value is_ProjectionInfoIDL2 `json:"value"`
}

func (o *ProjectionInfoIDL2) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *ProjectionInfoIDL2_PPPProjectionInfo:
		if value != nil {
			return value.PPPProjectionInfo
		}
	case *ProjectionInfoIDL2_IKEv2ProjectionInfo:
		if value != nil {
			return value.IKEv2ProjectionInfo
		}
	}
	return nil
}

type is_ProjectionInfoIDL2 interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_ProjectionInfoIDL2()
}

func (o *ProjectionInfoIDL2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := w.WriteUnionAlign(8); err != nil {
		return err
	}
	if err := w.WriteData(uint8(o.ProjectionInfoType)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(8); err != nil {
		return err
	}
	switch o.ProjectionInfoType {
	case uint8(1):
		_o, _ := o.Value.(*ProjectionInfoIDL2_PPPProjectionInfo)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ProjectionInfoIDL2_PPPProjectionInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint8(2):
		_o, _ := o.Value.(*ProjectionInfoIDL2_IKEv2ProjectionInfo)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ProjectionInfoIDL2_IKEv2ProjectionInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", o.ProjectionInfoType)
	}
	return nil
}

func (o *ProjectionInfoIDL2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadUnionAlign(8); err != nil {
		return err
	}
	if err := w.ReadData((*uint8)(&o.ProjectionInfoType)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(8); err != nil {
		return err
	}
	switch o.ProjectionInfoType {
	case uint8(1):
		o.Value = &ProjectionInfoIDL2_PPPProjectionInfo{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint8(2):
		o.Value = &ProjectionInfoIDL2_IKEv2ProjectionInfo{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", o.ProjectionInfoType)
	}
	return nil
}

// ProjectionInfoIDL2_PPPProjectionInfo structure represents PROJECTION_INFO_IDL_2 RPC union arm.
//
// It has following labels: 1
type ProjectionInfoIDL2_PPPProjectionInfo struct {
	// PppProjectionInfo: Contains a PPP_PROJECTION_INFO_2 for a PPP-based tunnel.
	PPPProjectionInfo *PPPProjectionInfo2 `idl:"name:PppProjectionInfo" json:"ppp_projection_info"`
}

func (*ProjectionInfoIDL2_PPPProjectionInfo) is_ProjectionInfoIDL2() {}

func (o *ProjectionInfoIDL2_PPPProjectionInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.PPPProjectionInfo != nil {
		if err := o.PPPProjectionInfo.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&PPPProjectionInfo2{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *ProjectionInfoIDL2_PPPProjectionInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.PPPProjectionInfo == nil {
		o.PPPProjectionInfo = &PPPProjectionInfo2{}
	}
	if err := o.PPPProjectionInfo.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// ProjectionInfoIDL2_IKEv2ProjectionInfo structure represents PROJECTION_INFO_IDL_2 RPC union arm.
//
// It has following labels: 2
type ProjectionInfoIDL2_IKEv2ProjectionInfo struct {
	// Ikev2ProjectionInfo: Contains an IKEV2_PROJECTION_INFO_2 for an IKEv2-based tunnel.
	IKEv2ProjectionInfo *IKEv2ProjectionInfo2 `idl:"name:Ikev2ProjectionInfo" json:"ikev2_projection_info"`
}

func (*ProjectionInfoIDL2_IKEv2ProjectionInfo) is_ProjectionInfoIDL2() {}

func (o *ProjectionInfoIDL2_IKEv2ProjectionInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.IKEv2ProjectionInfo != nil {
		if err := o.IKEv2ProjectionInfo.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&IKEv2ProjectionInfo2{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *ProjectionInfoIDL2_IKEv2ProjectionInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.IKEv2ProjectionInfo == nil {
		o.IKEv2ProjectionInfo = &IKEv2ProjectionInfo2{}
	}
	if err := o.IKEv2ProjectionInfo.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// RASConnectionEx1IDL structure represents RAS_CONNECTION_EX_1_IDL RPC structure.
//
// The RAS_CONNECTION_EX_1_IDL structure contains information for a connection, including
// the GUID that identifies the connection, the NAP, and the PPP or the IKEv2 related
// data for the connection.
type RASConnectionEx1IDL struct {
	// Header: A MPRAPI_OBJECT_HEADER_IDL (section 2.2.1.2.129) whose revision field MUST
	// be 0x01 and type field MUST be 0x01.
	Header *ObjectHeaderIDL `idl:"name:Header" json:"header"`
	// dwConnectDuration: Specifies the duration in seconds for which the current connection
	// is active.
	ConnectDuration uint32 `idl:"name:dwConnectDuration" json:"connect_duration"`
	// dwInterfaceType: Specifies a ROUTER_INTERFACE_TYPE (section 2.2.1.1.1) value specifying
	// the interface type of the current connection.
	InterfaceType RouterInterfaceType `idl:"name:dwInterfaceType" json:"interface_type"`
	// dwConnectionFlags: Specifies certain attributes of the connection.
	//
	// This member SHOULD contain one of the following flags.<119>
	//
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                         |                                                                                  |
	//	|                  VALUE                  |                                     MEANING                                      |
	//	|                                         |                                                                                  |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000                              | No flag is set.                                                                  |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| RAS_FLAGS_PPP_CONNECTION 0x00000001     | The connection is using the Point-to-Point Protocol (PPP).                       |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| RAS_FLAGS_MESSENGER_PRESENT 0x00000002  | The messenger service is active on the client and messages can be sent to the    |
	//	|                                         | client using RRasAdminSendUserMessage (section 3.1.4.36).                        |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| RAS_FLAGS_QUARANTINE_PRESENT 0x00000008 | The connection is currently in quarantine. See                                   |
	//	|                                         | RRasAdminConnectionRemoveQuarantine (section 3.1.4.43) for more information.     |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| RAS_FLAGS_ARAP_CONNECTION 0x00000010    | The connection is using the AppleTalk Remote Access Protocol (ARAP).             |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| RAS_FLAGS_DORMANT 0x00000020            | The connection is using the IKEv2 and the server is not reachable.               |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	ConnectionFlags uint32 `idl:"name:dwConnectionFlags" json:"connection_flags"`
	// wszInterfaceName: Specifies a null-terminated Unicode string that contains the name
	// of the interface for this connection.
	InterfaceName []uint16 `idl:"name:wszInterfaceName" json:"interface_name"`
	// wszUserName: Specifies a null-terminated Unicode string that contains the name of
	// the user logged on to the connection.
	UserName []uint16 `idl:"name:wszUserName" json:"user_name"`
	// wszLogonDomain: Specifies a null-terminated Unicode string that contains the domain
	// on which the connected user is authenticated.
	LogonDomain []uint16 `idl:"name:wszLogonDomain" json:"logon_domain"`
	// wszRemoteComputer: Specifies a null-terminated Unicode string that contains the name
	// of the remote computer.
	RemoteComputer []uint16 `idl:"name:wszRemoteComputer" json:"remote_computer"`
	// guid: A GUID uniquely identifying the connection.
	GUID *dtyp.GUID `idl:"name:guid" json:"guid"`
	// rasQuarState: Specifies the NAP quarantine state for the connection through the type
	// RAS_QUARANTINE_STATE (section 2.2.1.1.3) that contains the quarantine state of this
	// connection.
	RASQuarantineState RASQuarantineState `idl:"name:rasQuarState" json:"ras_quarantine_state"`
	// probationTime: Specifies the NAP probation time for the connection in UTC. This value
	// is valid only if the rasQuarState has a value of RAS_QUAR_STATE_PROBATION (see RAS_QUARANTINE_STATE).
	ProbationTime *dtyp.Filetime `idl:"name:probationTime" json:"probation_time"`
	// dwBytesXmited: Specifies the bytes transmitted on the current connection.
	BytesXmited uint32 `idl:"name:dwBytesXmited" json:"bytes_xmited"`
	// dwBytesRcved: Specifies the bytes received on the current connection.
	BytesRcved uint32 `idl:"name:dwBytesRcved" json:"bytes_rcved"`
	// dwFramesXmited: Specifies the frames transmitted on the current connection.
	FramesXmited uint32 `idl:"name:dwFramesXmited" json:"frames_xmited"`
	// dwFramesRcved: Specifies the frames received on the current connection.
	FramesRcved uint32 `idl:"name:dwFramesRcved" json:"frames_rcved"`
	// dwCrcErr: Specifies the CRC errors on the current connection.
	CRCError uint32 `idl:"name:dwCrcErr" json:"crc_error"`
	// dwTimeoutErr: Specifies the time-out errors on the current connection.
	TimeoutError uint32 `idl:"name:dwTimeoutErr" json:"timeout_error"`
	// dwAlignmentErr: Specifies the alignment errors on the current connection.
	AlignmentError uint32 `idl:"name:dwAlignmentErr" json:"alignment_error"`
	// dwHardwareOverrunErr: Specifies the number of hardware-overrun errors on the current
	// connection.
	HardwareOverrunError uint32 `idl:"name:dwHardwareOverrunErr" json:"hardware_overrun_error"`
	// dwFramingErr: Specifies the number of framing errors for the current connection.
	FramingError uint32 `idl:"name:dwFramingErr" json:"framing_error"`
	// dwBufferOverrunErr: Specifies the number of buffer-overrun errors.
	BufferOverrunError uint32 `idl:"name:dwBufferOverrunErr" json:"buffer_overrun_error"`
	// dwCompressionRatioIn: Specifies a percentage that indicates the degree to which data
	// received on this connection is compressed. The ratio is the size of the compressed
	// data divided by the size of the same data in an uncompressed state.
	CompressionRatioIn uint32 `idl:"name:dwCompressionRatioIn" json:"compression_ratio_in"`
	// dwCompressionRatioOut: Specifies a percentage that indicates the degree to which
	// data transmitted on this connection is compressed. The ratio is the size of the compressed
	// data divided by the size of the same data in an uncompressed state.
	CompressionRatioOut uint32 `idl:"name:dwCompressionRatioOut" json:"compression_ratio_out"`
	// dwNumSwitchOvers: Specifies the number of MOBIKE [RFC4555] switches that happened
	// on the connection. Valid only if dwConnectionFlags is RAS_FLAGS_IKEV2_CONNECTION.
	SwitchOversLength uint32 `idl:"name:dwNumSwitchOvers" json:"switch_overs_length"`
	// wszRemoteEndpointAddress: Specifies a null-terminated Unicode string that holds the
	// remote computer's IP address for the connection. This string has the form a.b.c.d;
	// for example, "10.102.235.84".
	RemoteEndpointAddress []uint16 `idl:"name:wszRemoteEndpointAddress" json:"remote_endpoint_address"`
	// wszLocalEndpointAddress: Specifies a null-terminated Unicode string that holds the
	// local computer's IP address for the connection. This string has the form a.b.c.d
	// or a::1234; for example, "10.102.235.84" or 2ffe::1234.
	LocalEndpointAddress []uint16 `idl:"name:wszLocalEndpointAddress" json:"local_endpoint_address"`
	// ProjectionInfo: This is a PROJECTION_INFO_IDL_1 structure.
	ProjectionInfo *ProjectionInfoIDL1 `idl:"name:ProjectionInfo" json:"projection_info"`
	// hConnection: A handle to the connection.
	Connection uint32 `idl:"name:hConnection" json:"connection"`
	// hInterface: A handle to the interface.
	Interface uint32 `idl:"name:hInterface" json:"interface"`
}

func (o *RASConnectionEx1IDL) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *RASConnectionEx1IDL) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if o.Header != nil {
		if err := o.Header.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ObjectHeaderIDL{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.ConnectDuration); err != nil {
		return err
	}
	if err := w.WriteEnum(uint16(o.InterfaceType)); err != nil {
		return err
	}
	if err := w.WriteData(o.ConnectionFlags); err != nil {
		return err
	}
	for i1 := range o.InterfaceName {
		i1 := i1
		if uint64(i1) >= 257 {
			break
		}
		if err := w.WriteData(o.InterfaceName[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.InterfaceName); uint64(i1) < 257; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	for i1 := range o.UserName {
		i1 := i1
		if uint64(i1) >= 257 {
			break
		}
		if err := w.WriteData(o.UserName[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.UserName); uint64(i1) < 257; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	for i1 := range o.LogonDomain {
		i1 := i1
		if uint64(i1) >= 16 {
			break
		}
		if err := w.WriteData(o.LogonDomain[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.LogonDomain); uint64(i1) < 16; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	for i1 := range o.RemoteComputer {
		i1 := i1
		if uint64(i1) >= 17 {
			break
		}
		if err := w.WriteData(o.RemoteComputer[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.RemoteComputer); uint64(i1) < 17; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	if o.GUID != nil {
		if err := o.GUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteEnum(uint16(o.RASQuarantineState)); err != nil {
		return err
	}
	if o.ProbationTime != nil {
		if err := o.ProbationTime.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.Filetime{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.BytesXmited); err != nil {
		return err
	}
	if err := w.WriteData(o.BytesRcved); err != nil {
		return err
	}
	if err := w.WriteData(o.FramesXmited); err != nil {
		return err
	}
	if err := w.WriteData(o.FramesRcved); err != nil {
		return err
	}
	if err := w.WriteData(o.CRCError); err != nil {
		return err
	}
	if err := w.WriteData(o.TimeoutError); err != nil {
		return err
	}
	if err := w.WriteData(o.AlignmentError); err != nil {
		return err
	}
	if err := w.WriteData(o.HardwareOverrunError); err != nil {
		return err
	}
	if err := w.WriteData(o.FramingError); err != nil {
		return err
	}
	if err := w.WriteData(o.BufferOverrunError); err != nil {
		return err
	}
	if err := w.WriteData(o.CompressionRatioIn); err != nil {
		return err
	}
	if err := w.WriteData(o.CompressionRatioOut); err != nil {
		return err
	}
	if err := w.WriteData(o.SwitchOversLength); err != nil {
		return err
	}
	for i1 := range o.RemoteEndpointAddress {
		i1 := i1
		if uint64(i1) >= 65 {
			break
		}
		if err := w.WriteData(o.RemoteEndpointAddress[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.RemoteEndpointAddress); uint64(i1) < 65; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	for i1 := range o.LocalEndpointAddress {
		i1 := i1
		if uint64(i1) >= 65 {
			break
		}
		if err := w.WriteData(o.LocalEndpointAddress[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.LocalEndpointAddress); uint64(i1) < 65; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	if o.ProjectionInfo != nil {
		if err := o.ProjectionInfo.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ProjectionInfoIDL1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Connection); err != nil {
		return err
	}
	if err := w.WriteData(o.Interface); err != nil {
		return err
	}
	if err := w.WriteTrailingGap(8); err != nil {
		return err
	}
	return nil
}
func (o *RASConnectionEx1IDL) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if o.Header == nil {
		o.Header = &ObjectHeaderIDL{}
	}
	if err := o.Header.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.ConnectDuration); err != nil {
		return err
	}
	if err := w.ReadEnum((*uint16)(&o.InterfaceType)); err != nil {
		return err
	}
	if err := w.ReadData(&o.ConnectionFlags); err != nil {
		return err
	}
	o.InterfaceName = make([]uint16, 257)
	for i1 := range o.InterfaceName {
		i1 := i1
		if err := w.ReadData(&o.InterfaceName[i1]); err != nil {
			return err
		}
	}
	o.UserName = make([]uint16, 257)
	for i1 := range o.UserName {
		i1 := i1
		if err := w.ReadData(&o.UserName[i1]); err != nil {
			return err
		}
	}
	o.LogonDomain = make([]uint16, 16)
	for i1 := range o.LogonDomain {
		i1 := i1
		if err := w.ReadData(&o.LogonDomain[i1]); err != nil {
			return err
		}
	}
	o.RemoteComputer = make([]uint16, 17)
	for i1 := range o.RemoteComputer {
		i1 := i1
		if err := w.ReadData(&o.RemoteComputer[i1]); err != nil {
			return err
		}
	}
	if o.GUID == nil {
		o.GUID = &dtyp.GUID{}
	}
	if err := o.GUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadEnum((*uint16)(&o.RASQuarantineState)); err != nil {
		return err
	}
	if o.ProbationTime == nil {
		o.ProbationTime = &dtyp.Filetime{}
	}
	if err := o.ProbationTime.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.BytesXmited); err != nil {
		return err
	}
	if err := w.ReadData(&o.BytesRcved); err != nil {
		return err
	}
	if err := w.ReadData(&o.FramesXmited); err != nil {
		return err
	}
	if err := w.ReadData(&o.FramesRcved); err != nil {
		return err
	}
	if err := w.ReadData(&o.CRCError); err != nil {
		return err
	}
	if err := w.ReadData(&o.TimeoutError); err != nil {
		return err
	}
	if err := w.ReadData(&o.AlignmentError); err != nil {
		return err
	}
	if err := w.ReadData(&o.HardwareOverrunError); err != nil {
		return err
	}
	if err := w.ReadData(&o.FramingError); err != nil {
		return err
	}
	if err := w.ReadData(&o.BufferOverrunError); err != nil {
		return err
	}
	if err := w.ReadData(&o.CompressionRatioIn); err != nil {
		return err
	}
	if err := w.ReadData(&o.CompressionRatioOut); err != nil {
		return err
	}
	if err := w.ReadData(&o.SwitchOversLength); err != nil {
		return err
	}
	o.RemoteEndpointAddress = make([]uint16, 65)
	for i1 := range o.RemoteEndpointAddress {
		i1 := i1
		if err := w.ReadData(&o.RemoteEndpointAddress[i1]); err != nil {
			return err
		}
	}
	o.LocalEndpointAddress = make([]uint16, 65)
	for i1 := range o.LocalEndpointAddress {
		i1 := i1
		if err := w.ReadData(&o.LocalEndpointAddress[i1]); err != nil {
			return err
		}
	}
	if o.ProjectionInfo == nil {
		o.ProjectionInfo = &ProjectionInfoIDL1{}
	}
	if err := o.ProjectionInfo.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.Connection); err != nil {
		return err
	}
	if err := w.ReadData(&o.Interface); err != nil {
		return err
	}
	if err := w.ReadTrailingGap(8); err != nil {
		return err
	}
	return nil
}

// RASConnectionExIDL structure represents RAS_CONNECTION_EX_IDL RPC union.
//
// The RAS_CONNECTION_EX_IDL union contains a placeholder for RAS_CONNECTION_EX_1_IDL
// (section 2.2.1.2.133) structure. This union is used in the RRasAdminConnectionGetInfoEx
// (section 3.1.4.47) method.
type RASConnectionExIDL struct {
	Revision uint8
	// Types that are assignable to Value
	//
	// *RASConnectionExIDL_RASConnection1
	Value is_RASConnectionExIDL `json:"value"`
}

func (o *RASConnectionExIDL) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *RASConnectionExIDL_RASConnection1:
		if value != nil {
			return value.RASConnection1
		}
	}
	return nil
}

type is_RASConnectionExIDL interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_RASConnectionExIDL()
}

func (o *RASConnectionExIDL) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := w.WriteUnionAlign(8); err != nil {
		return err
	}
	if err := w.WriteData(uint8(o.Revision)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(8); err != nil {
		return err
	}
	switch o.Revision {
	case uint8(1):
		_o, _ := o.Value.(*RASConnectionExIDL_RASConnection1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&RASConnectionExIDL_RASConnection1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", o.Revision)
	}
	return nil
}

func (o *RASConnectionExIDL) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadUnionAlign(8); err != nil {
		return err
	}
	if err := w.ReadData((*uint8)(&o.Revision)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(8); err != nil {
		return err
	}
	switch o.Revision {
	case uint8(1):
		o.Value = &RASConnectionExIDL_RASConnection1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", o.Revision)
	}
	return nil
}

// RASConnectionExIDL_RASConnection1 structure represents RAS_CONNECTION_EX_IDL RPC union arm.
//
// It has following labels: 1
type RASConnectionExIDL_RASConnection1 struct {
	// RasConnection1: This MUST be the structure RAS_CONNECTION_EX_1_IDL.
	RASConnection1 *RASConnectionEx1IDL `idl:"name:RasConnection1" json:"ras_connection1"`
}

func (*RASConnectionExIDL_RASConnection1) is_RASConnectionExIDL() {}

func (o *RASConnectionExIDL_RASConnection1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.RASConnection1 != nil {
		if err := o.RASConnection1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&RASConnectionEx1IDL{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *RASConnectionExIDL_RASConnection1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.RASConnection1 == nil {
		o.RASConnection1 = &RASConnectionEx1IDL{}
	}
	if err := o.RASConnection1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// RASConnection4IDL structure represents RAS_CONNECTION_4_IDL RPC structure.
//
// The RAS_CONNECTION_4_IDL structure<165> contains information for a connection, including
// the GUID that identifies the connection, the NAP, and the PPP or the IKEv2- related
// data for the connection.
type RASConnection4IDL struct {
	// dwConnectDuration: Same as dwConnectDuration in RAS_CONNECTION_EX_1_IDL (section
	// 2.2.1.2.133).
	ConnectDuration uint32 `idl:"name:dwConnectDuration" json:"connect_duration"`
	// dwInterfaceType: Same as dwInterfaceType in RAS_CONNECTION_EX_1_IDL.
	InterfaceType RouterInterfaceType `idl:"name:dwInterfaceType" json:"interface_type"`
	// dwConnectionFlags: Same as dwConnectionFlags in RAS_CONNECTION_EX_1_IDL.
	ConnectionFlags uint32 `idl:"name:dwConnectionFlags" json:"connection_flags"`
	// wszInterfaceName: Same as wszInterfaceName in RAS_CONNECTION_EX_1_IDL.
	InterfaceName []uint16 `idl:"name:wszInterfaceName" json:"interface_name"`
	// wszUserName: Same as wszUserName in RAS_CONNECTION_EX_1_IDL.
	UserName []uint16 `idl:"name:wszUserName" json:"user_name"`
	// wszLogonDomain: Same as wszLogonDomain in RAS_CONNECTION_EX_1_IDL.
	LogonDomain []uint16 `idl:"name:wszLogonDomain" json:"logon_domain"`
	// wszRemoteComputer: Same as wszRemoteComputer in RAS_CONNECTION_EX_1_IDL.
	RemoteComputer []uint16 `idl:"name:wszRemoteComputer" json:"remote_computer"`
	// guid: Same as guid in RAS_CONNECTION_EX_1_IDL.
	GUID *dtyp.GUID `idl:"name:guid" json:"guid"`
	// rasQuarState: Same as rasQuarState in RAS_CONNECTION_EX_1_IDL.
	RASQuarantineState RASQuarantineState `idl:"name:rasQuarState" json:"ras_quarantine_state"`
	// probationTime: Same as probationTime in RAS_CONNECTION_EX_1_IDL.
	ProbationTime *dtyp.Filetime `idl:"name:probationTime" json:"probation_time"`
	// connectionStartTime: Same as connectionStartTime in RAS_CONNECTION_EX_1_IDL.
	ConnectionStartTime *dtyp.Filetime `idl:"name:connectionStartTime" json:"connection_start_time"`
	// dwBytesXmited: Same as dwBytesXmited in RAS_CONNECTION_EX_1_IDL.
	BytesXmited uint32 `idl:"name:dwBytesXmited" json:"bytes_xmited"`
	// dwBytesRcved: Same as dwBytesRcved in RAS_CONNECTION_EX_1_IDL.
	BytesRcved uint32 `idl:"name:dwBytesRcved" json:"bytes_rcved"`
	// dwFramesXmited: Same as dwFramesXmited in RAS_CONNECTION_EX_1_IDL.
	FramesXmited uint32 `idl:"name:dwFramesXmited" json:"frames_xmited"`
	// dwFramesRcved: Same as dwFramesRcved in RAS_CONNECTION_EX_1_IDL.
	FramesRcved uint32 `idl:"name:dwFramesRcved" json:"frames_rcved"`
	// dwCrcErr: Same as dwCrcErr in RAS_CONNECTION_EX_1_IDL.
	CRCError uint32 `idl:"name:dwCrcErr" json:"crc_error"`
	// dwTimeoutErr: Same as dwTimeoutErr in RAS_CONNECTION_EX_1_IDL.
	TimeoutError uint32 `idl:"name:dwTimeoutErr" json:"timeout_error"`
	// dwAlignmentErr: Same as dwAlignmentErr in RAS_CONNECTION_EX_1_IDL.
	AlignmentError uint32 `idl:"name:dwAlignmentErr" json:"alignment_error"`
	// dwHardwareOverrunErr: Same as dwHardwareOverrunErr in RAS_CONNECTION_EX_1_IDL.
	HardwareOverrunError uint32 `idl:"name:dwHardwareOverrunErr" json:"hardware_overrun_error"`
	// dwFramingErr: Same as dwFramingErr in RAS_CONNECTION_EX_1_IDL.
	FramingError uint32 `idl:"name:dwFramingErr" json:"framing_error"`
	// dwBufferOverrunErr: Same as dwBufferOverrunErr in RAS_CONNECTION_EX_1_IDL.
	BufferOverrunError uint32 `idl:"name:dwBufferOverrunErr" json:"buffer_overrun_error"`
	// dwCompressionRatioIn: Same as dwCompressionRatioIn in RAS_CONNECTION_EX_1_IDL.
	CompressionRatioIn uint32 `idl:"name:dwCompressionRatioIn" json:"compression_ratio_in"`
	// dwCompressionRatioOut: Same as dwCompressionRatioOut in RAS_CONNECTION_EX_1_IDL.
	CompressionRatioOut uint32 `idl:"name:dwCompressionRatioOut" json:"compression_ratio_out"`
	// dwNumSwitchOvers: Same as dwNumSwitchOvers in RAS_CONNECTION_EX_1_IDL.
	SwitchOversLength uint32 `idl:"name:dwNumSwitchOvers" json:"switch_overs_length"`
	// wszRemoteEndpointAddress: Same as wszRemoteEndpointAddress in RAS_CONNECTION_EX_1_IDL.
	RemoteEndpointAddress []uint16 `idl:"name:wszRemoteEndpointAddress" json:"remote_endpoint_address"`
	// wszLocalEndpointAddress: Same as wszLocalEndpointAddress in RAS_CONNECTION_EX_1_IDL.
	LocalEndpointAddress []uint16 `idl:"name:wszLocalEndpointAddress" json:"local_endpoint_address"`
	// ProjectionInfo: Same as ProjectionInfo in RAS_CONNECTION_EX_1_IDL.
	ProjectionInfo *ProjectionInfoIDL2 `idl:"name:ProjectionInfo" json:"projection_info"`
	// hConnection: Same as hConnection in RAS_CONNECTION_EX_1_IDL.
	Connection uint32 `idl:"name:hConnection" json:"connection"`
	// hInterface: Same as hInterface in RAS_CONNECTION_EX_1_IDL.
	Interface uint32 `idl:"name:hInterface" json:"interface"`
	// dwDeviceType: Specifies the device type of the port associated with the RAS connection
	// as defined in the RASDEVICETYPE (section 2.2.1.1.16) enumeration type.
	DeviceType uint32 `idl:"name:dwDeviceType" json:"device_type"`
}

func (o *RASConnection4IDL) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *RASConnection4IDL) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if err := w.WriteData(o.ConnectDuration); err != nil {
		return err
	}
	if err := w.WriteEnum(uint16(o.InterfaceType)); err != nil {
		return err
	}
	if err := w.WriteData(o.ConnectionFlags); err != nil {
		return err
	}
	for i1 := range o.InterfaceName {
		i1 := i1
		if uint64(i1) >= 257 {
			break
		}
		if err := w.WriteData(o.InterfaceName[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.InterfaceName); uint64(i1) < 257; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	for i1 := range o.UserName {
		i1 := i1
		if uint64(i1) >= 257 {
			break
		}
		if err := w.WriteData(o.UserName[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.UserName); uint64(i1) < 257; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	for i1 := range o.LogonDomain {
		i1 := i1
		if uint64(i1) >= 16 {
			break
		}
		if err := w.WriteData(o.LogonDomain[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.LogonDomain); uint64(i1) < 16; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	for i1 := range o.RemoteComputer {
		i1 := i1
		if uint64(i1) >= 17 {
			break
		}
		if err := w.WriteData(o.RemoteComputer[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.RemoteComputer); uint64(i1) < 17; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	if o.GUID != nil {
		if err := o.GUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteEnum(uint16(o.RASQuarantineState)); err != nil {
		return err
	}
	if o.ProbationTime != nil {
		if err := o.ProbationTime.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.Filetime{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.ConnectionStartTime != nil {
		if err := o.ConnectionStartTime.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.Filetime{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.BytesXmited); err != nil {
		return err
	}
	if err := w.WriteData(o.BytesRcved); err != nil {
		return err
	}
	if err := w.WriteData(o.FramesXmited); err != nil {
		return err
	}
	if err := w.WriteData(o.FramesRcved); err != nil {
		return err
	}
	if err := w.WriteData(o.CRCError); err != nil {
		return err
	}
	if err := w.WriteData(o.TimeoutError); err != nil {
		return err
	}
	if err := w.WriteData(o.AlignmentError); err != nil {
		return err
	}
	if err := w.WriteData(o.HardwareOverrunError); err != nil {
		return err
	}
	if err := w.WriteData(o.FramingError); err != nil {
		return err
	}
	if err := w.WriteData(o.BufferOverrunError); err != nil {
		return err
	}
	if err := w.WriteData(o.CompressionRatioIn); err != nil {
		return err
	}
	if err := w.WriteData(o.CompressionRatioOut); err != nil {
		return err
	}
	if err := w.WriteData(o.SwitchOversLength); err != nil {
		return err
	}
	for i1 := range o.RemoteEndpointAddress {
		i1 := i1
		if uint64(i1) >= 65 {
			break
		}
		if err := w.WriteData(o.RemoteEndpointAddress[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.RemoteEndpointAddress); uint64(i1) < 65; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	for i1 := range o.LocalEndpointAddress {
		i1 := i1
		if uint64(i1) >= 65 {
			break
		}
		if err := w.WriteData(o.LocalEndpointAddress[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.LocalEndpointAddress); uint64(i1) < 65; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	if o.ProjectionInfo != nil {
		if err := o.ProjectionInfo.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ProjectionInfoIDL2{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Connection); err != nil {
		return err
	}
	if err := w.WriteData(o.Interface); err != nil {
		return err
	}
	if err := w.WriteData(o.DeviceType); err != nil {
		return err
	}
	if err := w.WriteTrailingGap(8); err != nil {
		return err
	}
	return nil
}
func (o *RASConnection4IDL) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if err := w.ReadData(&o.ConnectDuration); err != nil {
		return err
	}
	if err := w.ReadEnum((*uint16)(&o.InterfaceType)); err != nil {
		return err
	}
	if err := w.ReadData(&o.ConnectionFlags); err != nil {
		return err
	}
	o.InterfaceName = make([]uint16, 257)
	for i1 := range o.InterfaceName {
		i1 := i1
		if err := w.ReadData(&o.InterfaceName[i1]); err != nil {
			return err
		}
	}
	o.UserName = make([]uint16, 257)
	for i1 := range o.UserName {
		i1 := i1
		if err := w.ReadData(&o.UserName[i1]); err != nil {
			return err
		}
	}
	o.LogonDomain = make([]uint16, 16)
	for i1 := range o.LogonDomain {
		i1 := i1
		if err := w.ReadData(&o.LogonDomain[i1]); err != nil {
			return err
		}
	}
	o.RemoteComputer = make([]uint16, 17)
	for i1 := range o.RemoteComputer {
		i1 := i1
		if err := w.ReadData(&o.RemoteComputer[i1]); err != nil {
			return err
		}
	}
	if o.GUID == nil {
		o.GUID = &dtyp.GUID{}
	}
	if err := o.GUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadEnum((*uint16)(&o.RASQuarantineState)); err != nil {
		return err
	}
	if o.ProbationTime == nil {
		o.ProbationTime = &dtyp.Filetime{}
	}
	if err := o.ProbationTime.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.ConnectionStartTime == nil {
		o.ConnectionStartTime = &dtyp.Filetime{}
	}
	if err := o.ConnectionStartTime.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.BytesXmited); err != nil {
		return err
	}
	if err := w.ReadData(&o.BytesRcved); err != nil {
		return err
	}
	if err := w.ReadData(&o.FramesXmited); err != nil {
		return err
	}
	if err := w.ReadData(&o.FramesRcved); err != nil {
		return err
	}
	if err := w.ReadData(&o.CRCError); err != nil {
		return err
	}
	if err := w.ReadData(&o.TimeoutError); err != nil {
		return err
	}
	if err := w.ReadData(&o.AlignmentError); err != nil {
		return err
	}
	if err := w.ReadData(&o.HardwareOverrunError); err != nil {
		return err
	}
	if err := w.ReadData(&o.FramingError); err != nil {
		return err
	}
	if err := w.ReadData(&o.BufferOverrunError); err != nil {
		return err
	}
	if err := w.ReadData(&o.CompressionRatioIn); err != nil {
		return err
	}
	if err := w.ReadData(&o.CompressionRatioOut); err != nil {
		return err
	}
	if err := w.ReadData(&o.SwitchOversLength); err != nil {
		return err
	}
	o.RemoteEndpointAddress = make([]uint16, 65)
	for i1 := range o.RemoteEndpointAddress {
		i1 := i1
		if err := w.ReadData(&o.RemoteEndpointAddress[i1]); err != nil {
			return err
		}
	}
	o.LocalEndpointAddress = make([]uint16, 65)
	for i1 := range o.LocalEndpointAddress {
		i1 := i1
		if err := w.ReadData(&o.LocalEndpointAddress[i1]); err != nil {
			return err
		}
	}
	if o.ProjectionInfo == nil {
		o.ProjectionInfo = &ProjectionInfoIDL2{}
	}
	if err := o.ProjectionInfo.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.Connection); err != nil {
		return err
	}
	if err := w.ReadData(&o.Interface); err != nil {
		return err
	}
	if err := w.ReadData(&o.DeviceType); err != nil {
		return err
	}
	if err := w.ReadTrailingGap(8); err != nil {
		return err
	}
	return nil
}

// CertBlob1 structure represents CERT_BLOB_1 RPC structure.
//
// The CERT_BLOB_1 is a generic structure that contains x.509 [RFC2459] certificate
// information.
//
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| cbData                                                                                                                        |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| pbData (variable)                                                                                                             |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
type CertBlob1 struct {
	// cbData (4 bytes): Size (in bytes) of the certificate information present in pbData.
	DataLength uint32 `idl:"name:cbData" json:"data_length"`
	// pbData (variable): Pointer to the information of the certificate. This information
	// depends on the structure in which this used. In the methods IKEV2_TUNNEL_CONFIG_PARAMS_1
	// (section 2.2.1.2.136), IKEV2_TUNNEL_CONFIG_PARAMS_2 (section 2.2.1.2.238), or IKEV2_TUNNEL_CONFIG_PARAMS_3
	// (section 2.2.1.2.247), this points to the subject name of the certificate. In SSTP_CERT_INFO_1,
	// pbData contains a SHA-1 hash.
	Data []byte `idl:"name:pbData;size_is:(cbData)" json:"data"`
}

func (o *CertBlob1) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if o.Data != nil && o.DataLength == 0 {
		o.DataLength = uint32(len(o.Data))
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *CertBlob1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.DataLength); err != nil {
		return err
	}
	if o.Data != nil || o.DataLength > 0 {
		_ptr_pbData := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.DataLength)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Data {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.Data[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.Data); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Data, _ptr_pbData); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *CertBlob1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.DataLength); err != nil {
		return err
	}
	_ptr_pbData := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.DataLength > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.DataLength)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Data", sizeInfo[0])
		}
		o.Data = make([]byte, sizeInfo[0])
		for i1 := range o.Data {
			i1 := i1
			if err := w.ReadData(&o.Data[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_pbData := func(ptr interface{}) { o.Data = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.Data, _s_pbData, _ptr_pbData); err != nil {
		return err
	}
	return nil
}

// CertEKU1 structure represents CERT_EKU_1 RPC structure.
//
// The CERT_EKU_1 structure<175> contains the EKU OID or EKU name of an x.509 certificate
// (see [RFC2459]).
//
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwSize                                                                                                                        |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| IsEKUOID                                                                                                                      |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| pwszEKU (variable)                                                                                                            |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
type CertEKU1 struct {
	// dwSize (4 bytes): The size (in bytes) of pwszEKU.
	Size uint32 `idl:"name:dwSize" json:"size"`
	// IsEKUOID (4 bytes): Specifies a Boolean value that indicates whether the pwszEKU
	// parameter specifies the EKU OID or EKU name of a certificate. If this parameter is
	// a TRUE value, pwszEKU specifies an EKU OID of a certificate. Otherwise, pwszEKU specifies
	// an EKU name of a connection.
	IsEKUOID bool `idl:"name:IsEKUOID" json:"is_ekuoid"`
	// pwszEKU (variable): A pointer to the EKU OID or EKU name of a certificate.
	EKU string `idl:"name:pwszEKU;size_is:(dwSize)" json:"eku"`
}

func (o *CertEKU1) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if o.EKU != "" && o.Size == 0 {
		o.Size = uint32(ndr.UTF16Len(o.EKU))
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *CertEKU1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.Size); err != nil {
		return err
	}
	if !o.IsEKUOID {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if o.EKU != "" || o.Size > 0 {
		_ptr_pwszEKU := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.Size)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			_EKU_buf := utf16.Encode([]rune(o.EKU))
			if uint64(len(_EKU_buf)) > sizeInfo[0] {
				_EKU_buf = _EKU_buf[:sizeInfo[0]]
			}
			for i1 := range _EKU_buf {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(_EKU_buf[i1]); err != nil {
					return err
				}
			}
			for i1 := len(_EKU_buf); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint16(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.EKU, _ptr_pwszEKU); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *CertEKU1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.Size); err != nil {
		return err
	}
	var _bIsEKUOID int32
	if err := w.ReadData(&_bIsEKUOID); err != nil {
		return err
	}
	o.IsEKUOID = _bIsEKUOID != 0
	_ptr_pwszEKU := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.Size > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.Size)
		}
		var _EKU_buf []uint16
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array _EKU_buf", sizeInfo[0])
		}
		_EKU_buf = make([]uint16, sizeInfo[0])
		for i1 := range _EKU_buf {
			i1 := i1
			if err := w.ReadData(&_EKU_buf[i1]); err != nil {
				return err
			}
		}
		o.EKU = strings.TrimRight(string(utf16.Decode(_EKU_buf)), ndr.ZeroString)
		return nil
	})
	_s_pwszEKU := func(ptr interface{}) { o.EKU = *ptr.(*string) }
	if err := w.ReadPointer(&o.EKU, _s_pwszEKU, _ptr_pwszEKU); err != nil {
		return err
	}
	return nil
}

// IKEv2TunnelConfigParams1 structure represents IKEV2_TUNNEL_CONFIG_PARAMS_1 RPC structure.
//
// The IKEV2_TUNNEL_CONFIG_PARAMS_1 structure<120> be used to get or set configured
// parameters for IKEv2 devices [RFC4306].
//
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwIdleTimeout                                                                                                                 |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwNetworkBlackoutTime                                                                                                         |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwSaLifeTime                                                                                                                  |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwSaDataSizeForRenegotiation                                                                                                  |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwConfigOptions                                                                                                               |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwTotalCertificates                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| certificateNames (variable)                                                                                                   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
type IKEv2TunnelConfigParams1 struct {
	// dwIdleTimeout (4 bytes): Duration, in seconds, after which the connection will be
	// disconnected if there is no traffic. This value MUST be between 300 and 17,279,999.
	IdleTimeout uint32 `idl:"name:dwIdleTimeout" json:"idle_timeout"`
	// dwNetworkBlackoutTime (4 bytes): Retransmission timeout, in seconds, for IKEv2 Request
	// packets [RFC4306]. IKEv2 expects a response for every request packet sent, this value
	// specifies the time after which the connection is deleted incase response is not received.
	// This value MUST be greater than or equal to 120.
	NetworkBlackoutTime uint32 `idl:"name:dwNetworkBlackoutTime" json:"network_blackout_time"`
	// dwSaLifeTime (4 bytes): Lifetime of a security association (SA), in seconds, after
	// which the SA is no longer valid [RFC4306]. This value MUST be between 300 and 17,279,999.
	SALifeTime uint32 `idl:"name:dwSaLifeTime" json:"sa_life_time"`
	// dwSaDataSizeForRenegotiation (4 bytes): Number of Kilobytes that are allowed to transfer
	// using a SA. After that the SA will be renegotiated [RFC4306]. This value MUST be
	// greater than or equal to 1024.
	SADataSizeForRenegotiation uint32 `idl:"name:dwSaDataSizeForRenegotiation" json:"sa_data_size_for_renegotiation"`
	// dwConfigOptions (4 bytes): Unused and MUST be set to 0.
	ConfigOptions uint32 `idl:"name:dwConfigOptions" json:"config_options"`
	// dwTotalCertificates (4 bytes): Total number of certificates in member variable certificateNames.
	TotalCertificates uint32 `idl:"name:dwTotalCertificates" json:"total_certificates"`
	// certificateNames (variable): An array of CERT_BLOB_1.
	CertificateNames []*CertBlob1 `idl:"name:certificateNames;size_is:(dwTotalCertificates)" json:"certificate_names"`
}

func (o *IKEv2TunnelConfigParams1) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if o.CertificateNames != nil && o.TotalCertificates == 0 {
		o.TotalCertificates = uint32(len(o.CertificateNames))
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IKEv2TunnelConfigParams1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.IdleTimeout); err != nil {
		return err
	}
	if err := w.WriteData(o.NetworkBlackoutTime); err != nil {
		return err
	}
	if err := w.WriteData(o.SALifeTime); err != nil {
		return err
	}
	if err := w.WriteData(o.SADataSizeForRenegotiation); err != nil {
		return err
	}
	if err := w.WriteData(o.ConfigOptions); err != nil {
		return err
	}
	if err := w.WriteData(o.TotalCertificates); err != nil {
		return err
	}
	if o.CertificateNames != nil || o.TotalCertificates > 0 {
		_ptr_certificateNames := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.TotalCertificates)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.CertificateNames {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.CertificateNames[i1] != nil {
					if err := o.CertificateNames[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&CertBlob1{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.CertificateNames); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&CertBlob1{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.CertificateNames, _ptr_certificateNames); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *IKEv2TunnelConfigParams1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.IdleTimeout); err != nil {
		return err
	}
	if err := w.ReadData(&o.NetworkBlackoutTime); err != nil {
		return err
	}
	if err := w.ReadData(&o.SALifeTime); err != nil {
		return err
	}
	if err := w.ReadData(&o.SADataSizeForRenegotiation); err != nil {
		return err
	}
	if err := w.ReadData(&o.ConfigOptions); err != nil {
		return err
	}
	if err := w.ReadData(&o.TotalCertificates); err != nil {
		return err
	}
	_ptr_certificateNames := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.TotalCertificates > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.TotalCertificates)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.CertificateNames", sizeInfo[0])
		}
		o.CertificateNames = make([]*CertBlob1, sizeInfo[0])
		for i1 := range o.CertificateNames {
			i1 := i1
			if o.CertificateNames[i1] == nil {
				o.CertificateNames[i1] = &CertBlob1{}
			}
			if err := o.CertificateNames[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_certificateNames := func(ptr interface{}) { o.CertificateNames = *ptr.(*[]*CertBlob1) }
	if err := w.ReadPointer(&o.CertificateNames, _s_certificateNames, _ptr_certificateNames); err != nil {
		return err
	}
	return nil
}

// RouterCustomIKEv2Policy0 structure represents ROUTER_CUSTOM_IKEv2_POLICY_0 RPC structure.
//
// The ROUTER_CUSTOM_IKEv2_POLICY_0 structure<166> is used to get or set configuration
// parameters to be used during quick mode security association (QM SA) or main mode
// security association (MM SA) negotiation for IKEv2 [RFC4306] and L2TP devices.
type RouterCustomIKEv2Policy0 struct {
	// dwIntegrityMethod: Specifies the integrity check algorithm to be negotiated during
	// MM SA negotiation [RFC4306]. This SHOULD have one of the following values.
	//
	//	+-------------------------+-------------------------------------+
	//	|                         |                                     |
	//	|          VALUE          |               MEANING               |
	//	|                         |                                     |
	//	+-------------------------+-------------------------------------+
	//	+-------------------------+-------------------------------------+
	//	| INTEGRITY_MD5 (0x0)     | Specifies MD5 hash algorithm.       |
	//	+-------------------------+-------------------------------------+
	//	| INTEGRITY_SHA1 (0x1)    | Specifies SHA1 hash algorithm.      |
	//	+-------------------------+-------------------------------------+
	//	| INTEGRITY_SHA_256 (0x2) | Specifies a 256-bit SHA encryption. |
	//	+-------------------------+-------------------------------------+
	//	| INTEGRITY_SHA_384 (0x3) | Specifies a 384-bit SHA encryption. |
	//	+-------------------------+-------------------------------------+
	IntegrityMethod uint32 `idl:"name:dwIntegrityMethod" json:"integrity_method"`
	// dwEncryptionMethod: Specifies the encryption algorithm to be negotiated during MM
	// SA negotiation [RFC4306]. This SHOULD have one of the following values.
	//
	//	+----------------------+-------------------------------+
	//	|                      |                               |
	//	|        VALUE         |            MEANING            |
	//	|                      |                               |
	//	+----------------------+-------------------------------+
	//	+----------------------+-------------------------------+
	//	| CIPHER_DES (0x0)     | Specifies DES encryption.     |
	//	+----------------------+-------------------------------+
	//	| CIPHER_3DES (0x1)    | Specifies 3DES encryption.    |
	//	+----------------------+-------------------------------+
	//	| CIPHER_AES_128 (0x2) | Specifies AES-128 encryption. |
	//	+----------------------+-------------------------------+
	//	| CIPHER_AES_192 (0x3) | Specifies AES-192 encryption. |
	//	+----------------------+-------------------------------+
	//	| CIPHER_AES_256 (0x4) | Specifies AES-256 encryption. |
	//	+----------------------+-------------------------------+
	EncryptionMethod uint32 `idl:"name:dwEncryptionMethod" json:"encryption_method"`
	// dwCipherTransformConstant: Specifies the encryption algorithm to be negotiated during
	// QM SA negotiation [RFC4306]. This SHOULD have one of the following values.
	//
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	|                                 |                                                                                  |
	//	|              VALUE              |                                     MEANING                                      |
	//	|                                 |                                                                                  |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| CIPHER_CONFIG_CBC_DES (0x1)     | DES (Data Encryption Standard) algorithm. CBC (Cipher Block Chaining) mode of    |
	//	|                                 | operation. [RFC2410]                                                             |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| CIPHER_CONFIG_CBC_3DES (0x2)    | 3DES algorithm. CBC mode of operation. [RFC2451]                                 |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| CIPHER_CONFIG_CBC_AES_128 (0x3) | AES-128 (Advanced Encryption Standard) algorithm. CBC mode of operation.         |
	//	|                                 | [RFC3602]                                                                        |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| CIPHER_CONFIG_CBC_AES_192 (0x4) | AES-192 algorithm. CBC mode of operation. [RFC3602]                              |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| CIPHER_CONFIG_CBC_AES_256 (0x5) | AES-256 algorithm. CBC mode of operation. [RFC3602]                              |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| CIPHER_CONFIG_GCM_AES_128 (0x6) | AES-128 algorithm. GCM (Galois Counter Mode) mode of operation. [RFC4106]        |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| CIPHER_CONFIG_GCM_AES_192 (0x7) | AES-192 algorithm. GCM (Galois Counter Mode) mode of operation. [RFC4106]        |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| CIPHER_CONFIG_GCM_AES_256 (0x8) | AES-256 algorithm. GCM (Galois Counter Mode) mode of operation. [RFC4106]        |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	CipherTransformConstant uint32 `idl:"name:dwCipherTransformConstant" json:"cipher_transform_constant"`
	// dwAuthTransformConstant: Specifies the hash algorithm to be negotiated during QM
	// SA negotiation [RFC4306]. This SHOULD have one of the following values.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|                                    |                                                                                  |
	//	|               VALUE                |                                     MEANING                                      |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| AUTH_CONFIG_HMAC_MD5_96 (0x0)      | Hash-based Message Authentication Code (HMAC) secret key authentication          |
	//	|                                    | algorithm. MD5data integrity and data origin authentication algorithm. [RFC2403] |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| AUTH_CONFIG_HMAC_SHA_1_96 (0x1)    | HMAC secret key authentication algorithm. SHA-1 (Secure Hash Algorithm) data     |
	//	|                                    | integrity and data origin authentication algorithm. [RFC2404]                    |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| AUTH_CONFIG_HMAC_SHA_256_128 (0x2) | HMAC secret key authentication algorithm. SHA-256 data integrity and data origin |
	//	|                                    | authentication algorithm.                                                        |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| AUTH_CONFIG_GCM_AES_128 (0x3)      | GCM (Galois Counter Mode) secret key authentication algorithm. AES(Advanced      |
	//	|                                    | Encryption Standard) data integrity and data origin authentication algorithm,    |
	//	|                                    | with 128-bit key.                                                                |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| AUTH_CONFIG_GCM_AES_192 (0x4)      | GCM secret key authentication algorithm. AES data integrity and data origin      |
	//	|                                    | authentication algorithm, with 192-bit key.                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| AUTH_CONFIG_GCM_AES_256 (0x5)      | GCM secret key authentication algorithm. AES data integrity and data origin      |
	//	|                                    | authentication algorithm, with 256-bit key.                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	AuthTransformConstant uint32 `idl:"name:dwAuthTransformConstant" json:"auth_transform_constant"`
	// dwPfsGroup: Specifies the Diffie-Hellman algorithm to be used for Quick Mode Perfect
	// Forward Secrecy (PFS) [RFC4306]. This SHOULD have one of the following values.
	//
	//	+-------------------+----------------------------------------------------------------------------------+
	//	|                   |                                                                                  |
	//	|       VALUE       |                                     MEANING                                      |
	//	|                   |                                                                                  |
	//	+-------------------+----------------------------------------------------------------------------------+
	//	+-------------------+----------------------------------------------------------------------------------+
	//	| PFS_NONE (0x0)    | Specifies no Quick Mode PFS.                                                     |
	//	+-------------------+----------------------------------------------------------------------------------+
	//	| PFS_1 (0x1)       | Specifies Diffie- Hellman group 1.                                               |
	//	+-------------------+----------------------------------------------------------------------------------+
	//	| PFS_2 (0x2)       | Specifies Diffie- Hellman group 2.                                               |
	//	+-------------------+----------------------------------------------------------------------------------+
	//	| PFS_2048 (0x3)    | Specifies Diffie- Hellman group 2048.                                            |
	//	+-------------------+----------------------------------------------------------------------------------+
	//	| PFS_ECP_256 (0x4) | Specifies Diffie- Hellman ECP group 256.                                         |
	//	+-------------------+----------------------------------------------------------------------------------+
	//	| PFS_ECP_384 (0x5) | Specifies Diffie- Hellman ECP group 384.                                         |
	//	+-------------------+----------------------------------------------------------------------------------+
	//	| PFS_MM (0x6)      | Use the same Diffie- Hellman as the main mode (MM) that contains this quick mode |
	//	|                   | (QM).                                                                            |
	//	+-------------------+----------------------------------------------------------------------------------+
	//	| PFS_24 (0x7)      | Specifies Diffie- Hellman group 24.                                              |
	//	+-------------------+----------------------------------------------------------------------------------+
	PFSGroup uint32 `idl:"name:dwPfsGroup" json:"pfs_group"`
	// dwDhGroup: Specifies the type of Diffie-Hellman group used for Internet Key Exchange
	// (IKE) key generation during MM SA negotiation [RFC4306]. This SHOULD have one of
	// the following values.
	//
	//	+---------------------+----------------------------------------------------------------------------------+
	//	|                     |                                                                                  |
	//	|        VALUE        |                                     MEANING                                      |
	//	|                     |                                                                                  |
	//	+---------------------+----------------------------------------------------------------------------------+
	//	+---------------------+----------------------------------------------------------------------------------+
	//	| DH_GROUP_NONE (0x0) | No key exchange algorithms defined.                                              |
	//	+---------------------+----------------------------------------------------------------------------------+
	//	| DH_GROUP_1 (0x1)    | Do key exchange with Diffie-Hellman group 1.                                     |
	//	+---------------------+----------------------------------------------------------------------------------+
	//	| DH_GROUP_2 (0x2)    | Do key exchange with Diffie-Hellman group 2.                                     |
	//	+---------------------+----------------------------------------------------------------------------------+
	//	| DH_GROUP_14 (0x3)   | Do key exchange with Diffie-Hellman group 14.                                    |
	//	+---------------------+----------------------------------------------------------------------------------+
	//	| DH_GROUP_2048 (0x3) | Do key exchange with Diffie-Hellman group 14. This group was called              |
	//	|                     | Diffie-Hellman group 2048 when it was introduced. The name has been changed to   |
	//	|                     | match standard terminology.                                                      |
	//	+---------------------+----------------------------------------------------------------------------------+
	//	| DH_ECP_256 (0x4)    | Do key exchange with elliptic curve Diffie-Hellman 256.                          |
	//	+---------------------+----------------------------------------------------------------------------------+
	//	| DH_ECP_384 (0x5)    | Do key exchange with elliptic curve Diffie-Hellman 384.                          |
	//	+---------------------+----------------------------------------------------------------------------------+
	//	| DH_GROUP_24 (0x6)   | Do key exchange with Diffie-Hellman group 24.                                    |
	//	+---------------------+----------------------------------------------------------------------------------+
	DHGroup uint32 `idl:"name:dwDhGroup" json:"dh_group"`
}

func (o *RouterCustomIKEv2Policy0) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *RouterCustomIKEv2Policy0) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.IntegrityMethod); err != nil {
		return err
	}
	if err := w.WriteData(o.EncryptionMethod); err != nil {
		return err
	}
	if err := w.WriteData(o.CipherTransformConstant); err != nil {
		return err
	}
	if err := w.WriteData(o.AuthTransformConstant); err != nil {
		return err
	}
	if err := w.WriteData(o.PFSGroup); err != nil {
		return err
	}
	if err := w.WriteData(o.DHGroup); err != nil {
		return err
	}
	return nil
}
func (o *RouterCustomIKEv2Policy0) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.IntegrityMethod); err != nil {
		return err
	}
	if err := w.ReadData(&o.EncryptionMethod); err != nil {
		return err
	}
	if err := w.ReadData(&o.CipherTransformConstant); err != nil {
		return err
	}
	if err := w.ReadData(&o.AuthTransformConstant); err != nil {
		return err
	}
	if err := w.ReadData(&o.PFSGroup); err != nil {
		return err
	}
	if err := w.ReadData(&o.DHGroup); err != nil {
		return err
	}
	return nil
}

// RouterCustomL2TPPolicy0 structure represents ROUTER_CUSTOM_L2TP_POLICY_0 RPC structure.
type RouterCustomL2TPPolicy0 struct {
	IntegrityMethod         uint32 `idl:"name:dwIntegrityMethod" json:"integrity_method"`
	EncryptionMethod        uint32 `idl:"name:dwEncryptionMethod" json:"encryption_method"`
	CipherTransformConstant uint32 `idl:"name:dwCipherTransformConstant" json:"cipher_transform_constant"`
	AuthTransformConstant   uint32 `idl:"name:dwAuthTransformConstant" json:"auth_transform_constant"`
	PFSGroup                uint32 `idl:"name:dwPfsGroup" json:"pfs_group"`
	DHGroup                 uint32 `idl:"name:dwDhGroup" json:"dh_group"`
}

func (o *RouterCustomL2TPPolicy0) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *RouterCustomL2TPPolicy0) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.IntegrityMethod); err != nil {
		return err
	}
	if err := w.WriteData(o.EncryptionMethod); err != nil {
		return err
	}
	if err := w.WriteData(o.CipherTransformConstant); err != nil {
		return err
	}
	if err := w.WriteData(o.AuthTransformConstant); err != nil {
		return err
	}
	if err := w.WriteData(o.PFSGroup); err != nil {
		return err
	}
	if err := w.WriteData(o.DHGroup); err != nil {
		return err
	}
	return nil
}
func (o *RouterCustomL2TPPolicy0) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.IntegrityMethod); err != nil {
		return err
	}
	if err := w.ReadData(&o.EncryptionMethod); err != nil {
		return err
	}
	if err := w.ReadData(&o.CipherTransformConstant); err != nil {
		return err
	}
	if err := w.ReadData(&o.AuthTransformConstant); err != nil {
		return err
	}
	if err := w.ReadData(&o.PFSGroup); err != nil {
		return err
	}
	if err := w.ReadData(&o.DHGroup); err != nil {
		return err
	}
	return nil
}

// RouterIKEv2InterfaceCustomConfig0 structure represents ROUTER_IKEv2_IF_CUSTOM_CONFIG_0 RPC structure.
//
// The ROUTER_IKEv2_IF_CUSTOM_CONFIG_0 structure<172> is used to get or set IKEv2 tunnel
// configuration parameters for IKEv2 tunnel- based demand- dial interfaces.
type RouterIKEv2InterfaceCustomConfig0 struct {
	// dwSaLifeTime: Same as dwSaLifeTime in IKEV2_TUNNEL_CONFIG_PARAMS_1.
	SALifeTime uint32 `idl:"name:dwSaLifeTime" json:"sa_life_time"`
	// dwSaDataSize: Same as dwSaDataSize in IKEV2_TUNNEL_CONFIG_PARAMS_1.
	SADataSize uint32 `idl:"name:dwSaDataSize" json:"sa_data_size"`
	// certificateName: Same as certificateName in IKEV2_TUNNEL_CONFIG_PARAMS_1.
	CertificateName *CertBlob1 `idl:"name:certificateName" json:"certificate_name"`
	// customPolicy: MUST be a pointer to a ROUTER_CUSTOM_IKEv2_POLICY_0 structure.
	CustomPolicy *RouterCustomIKEv2Policy0 `idl:"name:customPolicy" json:"custom_policy"`
}

func (o *RouterIKEv2InterfaceCustomConfig0) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *RouterIKEv2InterfaceCustomConfig0) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.SALifeTime); err != nil {
		return err
	}
	if err := w.WriteData(o.SADataSize); err != nil {
		return err
	}
	if o.CertificateName != nil {
		if err := o.CertificateName.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&CertBlob1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.CustomPolicy != nil {
		_ptr_customPolicy := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.CustomPolicy != nil {
				if err := o.CustomPolicy.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&RouterCustomIKEv2Policy0{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.CustomPolicy, _ptr_customPolicy); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *RouterIKEv2InterfaceCustomConfig0) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.SALifeTime); err != nil {
		return err
	}
	if err := w.ReadData(&o.SADataSize); err != nil {
		return err
	}
	if o.CertificateName == nil {
		o.CertificateName = &CertBlob1{}
	}
	if err := o.CertificateName.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_customPolicy := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.CustomPolicy == nil {
			o.CustomPolicy = &RouterCustomIKEv2Policy0{}
		}
		if err := o.CustomPolicy.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_customPolicy := func(ptr interface{}) { o.CustomPolicy = *ptr.(**RouterCustomIKEv2Policy0) }
	if err := w.ReadPointer(&o.CustomPolicy, _s_customPolicy, _ptr_customPolicy); err != nil {
		return err
	}
	return nil
}

// RouterIKEv2InterfaceCustomConfig1 structure represents ROUTER_IKEv2_IF_CUSTOM_CONFIG_1 RPC structure.
//
// The ROUTER_IKEv2_IF_CUSTOM_CONFIG_1 structure<197> is used to get or set IKEv2 tunnel
// configuration parameters for IKEv2 tunnel-based demand-dial interfaces.
type RouterIKEv2InterfaceCustomConfig1 struct {
	// dwSaLifeTime: This is the same as dwSaLifeTime in ROUTER_IKEv2_IF_CUSTOM_CONFIG_0
	// (section 2.2.1.2.243).
	SALifeTime uint32 `idl:"name:dwSaLifeTime" json:"sa_life_time"`
	// dwSaDataSize: This is the same as dwSaDataSize in ROUTER_IKEv2_IF_CUSTOM_CONFIG_0.
	SADataSize uint32 `idl:"name:dwSaDataSize" json:"sa_data_size"`
	// certificateName: Same as certificateName in ROUTER_IKEv2_IF_CUSTOM_CONFIG_0.
	CertificateName *CertBlob1 `idl:"name:certificateName" json:"certificate_name"`
	// customPolicy: This is the same as customPolicy in ROUTER_IKEv2_IF_CUSTOM_CONFIG_0.
	CustomPolicy *RouterCustomIKEv2Policy0 `idl:"name:customPolicy" json:"custom_policy"`
	// certificateHash: This is the same as machineCertificateHash in IKEV2_TUNNEL_CONFIG_PARAMS_3.
	CertificateHash *CertBlob1 `idl:"name:certificateHash" json:"certificate_hash"`
}

func (o *RouterIKEv2InterfaceCustomConfig1) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *RouterIKEv2InterfaceCustomConfig1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.SALifeTime); err != nil {
		return err
	}
	if err := w.WriteData(o.SADataSize); err != nil {
		return err
	}
	if o.CertificateName != nil {
		if err := o.CertificateName.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&CertBlob1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.CustomPolicy != nil {
		_ptr_customPolicy := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.CustomPolicy != nil {
				if err := o.CustomPolicy.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&RouterCustomIKEv2Policy0{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.CustomPolicy, _ptr_customPolicy); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.CertificateHash != nil {
		if err := o.CertificateHash.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&CertBlob1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *RouterIKEv2InterfaceCustomConfig1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.SALifeTime); err != nil {
		return err
	}
	if err := w.ReadData(&o.SADataSize); err != nil {
		return err
	}
	if o.CertificateName == nil {
		o.CertificateName = &CertBlob1{}
	}
	if err := o.CertificateName.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_customPolicy := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.CustomPolicy == nil {
			o.CustomPolicy = &RouterCustomIKEv2Policy0{}
		}
		if err := o.CustomPolicy.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_customPolicy := func(ptr interface{}) { o.CustomPolicy = *ptr.(**RouterCustomIKEv2Policy0) }
	if err := w.ReadPointer(&o.CustomPolicy, _s_customPolicy, _ptr_customPolicy); err != nil {
		return err
	}
	if o.CertificateHash == nil {
		o.CertificateHash = &CertBlob1{}
	}
	if err := o.CertificateHash.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// InterfaceCustominfoex0 structure represents MPR_IF_CUSTOMINFOEX_0 RPC structure.
//
// The MPR_IF_CUSTOMINFOEX_0 structure<173> contains the IKEv2 policy configuration
// of a demand-dial interface (see section 1.3).
type InterfaceCustominfoex0 struct {
	// Header: This MUST be an MPRAPI_OBJECT_HEADER_IDL (section 2.2.1.2.129). The revision
	// field MUST be 0x01, and the type field MUST be 0x06.
	Header *ObjectHeaderIDL `idl:"name:Header" json:"header"`
	// dwFlags: This MUST be one of the following values that specify the type of tunnel.
	//
	//	+----------------------------------------------+---------------------------------------------------+
	//	|                                              |                                                   |
	//	|                    VALUE                     |                      MEANING                      |
	//	|                                              |                                                   |
	//	+----------------------------------------------+---------------------------------------------------+
	//	+----------------------------------------------+---------------------------------------------------+
	//	| 0x00000000                                   | No custom configuration is available.             |
	//	+----------------------------------------------+---------------------------------------------------+
	//	| MPRAPI_IF_CUSTOM_CONFIG_FOR_IKEV2 0x00000001 | IKEv2 tunnel-specific configuration is available. |
	//	+----------------------------------------------+---------------------------------------------------+
	Flags uint32 `idl:"name:dwFlags" json:"flags"`
	// customIkev2Config: Specifies the IKEv2 tunnel configuration parameters. This MUST
	// be a pointer to ROUTER_IKEv2_IF_CUSTOM_CONFIG_0. The value of this member is valid
	// only if the dwFlag member is set to MPRAPI_IF_CUSTOM_CONFIG_FOR_IKEV2.
	CustomIKEv2Config *RouterIKEv2InterfaceCustomConfig0 `idl:"name:customIkev2Config" json:"custom_ikev2_config"`
}

func (o *InterfaceCustominfoex0) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *InterfaceCustominfoex0) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.Header != nil {
		if err := o.Header.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ObjectHeaderIDL{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	if o.CustomIKEv2Config != nil {
		if err := o.CustomIKEv2Config.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&RouterIKEv2InterfaceCustomConfig0{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *InterfaceCustominfoex0) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if o.Header == nil {
		o.Header = &ObjectHeaderIDL{}
	}
	if err := o.Header.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	if o.CustomIKEv2Config == nil {
		o.CustomIKEv2Config = &RouterIKEv2InterfaceCustomConfig0{}
	}
	if err := o.CustomIKEv2Config.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// InterfaceCustominfoex1 structure represents MPR_IF_CUSTOMINFOEX_1 RPC structure.
//
// The MPR_IF_CUSTOMINFOEX_1 structure<198> contains IKEv2 policy configuration of a
// demand-dial interface.
type InterfaceCustominfoex1 struct {
	// Header: This MUST be an MPRAPI_OBJECT_HEADER_IDL (section 2.2.1.2.129). The revision
	// field MUST be 0x02, and the type field MUST be 0x06.
	Header *ObjectHeaderIDL `idl:"name:Header" json:"header"`
	// dwFlags: This is the same as dwFlag in MPR_IF_CUSTOMINFOEX_0 (section 2.2.1.2.244).
	Flags uint32 `idl:"name:dwFlags" json:"flags"`
	// customIkev2Config: Specifies the IKEv2 tunnel configuration parameters. This MUST
	// be a pointer to ROUTER_IKEv2_IF_CUSTOM_CONFIG_1 (section 2.2.1.2.268). The value
	// of this member is valid only if the dwFlag member is set to MPRAPI_IF_CUSTOM_CONFIG_FOR_IKEV2.
	CustomIKEv2Config *RouterIKEv2InterfaceCustomConfig1 `idl:"name:customIkev2Config" json:"custom_ikev2_config"`
}

func (o *InterfaceCustominfoex1) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *InterfaceCustominfoex1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.Header != nil {
		if err := o.Header.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ObjectHeaderIDL{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	if o.CustomIKEv2Config != nil {
		if err := o.CustomIKEv2Config.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&RouterIKEv2InterfaceCustomConfig1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *InterfaceCustominfoex1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if o.Header == nil {
		o.Header = &ObjectHeaderIDL{}
	}
	if err := o.Header.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	if o.CustomIKEv2Config == nil {
		o.CustomIKEv2Config = &RouterIKEv2InterfaceCustomConfig1{}
	}
	if err := o.CustomIKEv2Config.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// InterfaceCustominfoexIDL structure represents MPR_IF_CUSTOMINFOEX_IDL RPC union.
//
// The MPR_IF_CUSTOMINFOEX_IDL structure<174> is a placeholder for MPR_IF_CUSTOMINFOEX_0
// (section 2.2.1.2.244) and MPR_IF_CUSTOMINFOEX_1 (section 2.2.1.2.269) structures.
type InterfaceCustominfoexIDL struct {
	Revision uint8
	// Types that are assignable to Value
	//
	// *InterfaceCustominfoexIDL_InterfaceConfigObj1
	// *InterfaceCustominfoexIDL_InterfaceConfigObj2
	Value is_InterfaceCustominfoexIDL `json:"value"`
}

func (o *InterfaceCustominfoexIDL) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *InterfaceCustominfoexIDL_InterfaceConfigObj1:
		if value != nil {
			return value.InterfaceConfigObj1
		}
	case *InterfaceCustominfoexIDL_InterfaceConfigObj2:
		if value != nil {
			return value.InterfaceConfigObj2
		}
	}
	return nil
}

type is_InterfaceCustominfoexIDL interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_InterfaceCustominfoexIDL()
}

func (o *InterfaceCustominfoexIDL) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(uint8(o.Revision)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch o.Revision {
	case uint8(1):
		_o, _ := o.Value.(*InterfaceCustominfoexIDL_InterfaceConfigObj1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&InterfaceCustominfoexIDL_InterfaceConfigObj1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint8(2):
		_o, _ := o.Value.(*InterfaceCustominfoexIDL_InterfaceConfigObj2)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&InterfaceCustominfoexIDL_InterfaceConfigObj2{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", o.Revision)
	}
	return nil
}

func (o *InterfaceCustominfoexIDL) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadData((*uint8)(&o.Revision)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch o.Revision {
	case uint8(1):
		o.Value = &InterfaceCustominfoexIDL_InterfaceConfigObj1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint8(2):
		o.Value = &InterfaceCustominfoexIDL_InterfaceConfigObj2{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", o.Revision)
	}
	return nil
}

// InterfaceCustominfoexIDL_InterfaceConfigObj1 structure represents MPR_IF_CUSTOMINFOEX_IDL RPC union arm.
//
// It has following labels: 1
type InterfaceCustominfoexIDL_InterfaceConfigObj1 struct {
	// IfConfigObj1: This MUST be an MPR_IF_CUSTOMINFOEX_0 (section 2.2.1.2.244) structure.
	InterfaceConfigObj1 *InterfaceCustominfoex0 `idl:"name:IfConfigObj1" json:"interface_config_obj1"`
}

func (*InterfaceCustominfoexIDL_InterfaceConfigObj1) is_InterfaceCustominfoexIDL() {}

func (o *InterfaceCustominfoexIDL_InterfaceConfigObj1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.InterfaceConfigObj1 != nil {
		if err := o.InterfaceConfigObj1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&InterfaceCustominfoex0{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *InterfaceCustominfoexIDL_InterfaceConfigObj1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.InterfaceConfigObj1 == nil {
		o.InterfaceConfigObj1 = &InterfaceCustominfoex0{}
	}
	if err := o.InterfaceConfigObj1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// InterfaceCustominfoexIDL_InterfaceConfigObj2 structure represents MPR_IF_CUSTOMINFOEX_IDL RPC union arm.
//
// It has following labels: 2
type InterfaceCustominfoexIDL_InterfaceConfigObj2 struct {
	// IfConfigObj2: This MUST be an MPR_IF_CUSTOMINFOEX_1 (section 2.2.1.2.269) structure.
	InterfaceConfigObj2 *InterfaceCustominfoex1 `idl:"name:IfConfigObj2" json:"interface_config_obj2"`
}

func (*InterfaceCustominfoexIDL_InterfaceConfigObj2) is_InterfaceCustominfoexIDL() {}

func (o *InterfaceCustominfoexIDL_InterfaceConfigObj2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.InterfaceConfigObj2 != nil {
		if err := o.InterfaceConfigObj2.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&InterfaceCustominfoex1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *InterfaceCustominfoexIDL_InterfaceConfigObj2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.InterfaceConfigObj2 == nil {
		o.InterfaceConfigObj2 = &InterfaceCustominfoex1{}
	}
	if err := o.InterfaceConfigObj2.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// IKEv2TunnelConfigParams2 structure represents IKEV2_TUNNEL_CONFIG_PARAMS_2 RPC structure.
//
// The IKEV2_TUNNEL_CONFIG_PARAMS_2 structure<167> is used to get or set configured
// parameters for IKEv2 devices [RFC4306].
//
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwIdleTimeout                                                                                                                 |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwNetworkBlackoutTime                                                                                                         |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwSaLifeTime                                                                                                                  |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwSaDataSizeForRenegotiation                                                                                                  |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwConfigOptions                                                                                                               |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwTotalCertificates                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| certificateNames (variable)                                                                                                   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| machineCertificateName (variable)                                                                                             |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwEncryptionType                                                                                                              |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| customPolicy                                                                                                                  |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
type IKEv2TunnelConfigParams2 struct {
	// dwIdleTimeout (4 bytes): Same as dwIdleTimeout in IKEV2_TUNNEL_CONFIG_PARAMS_1.
	IdleTimeout uint32 `idl:"name:dwIdleTimeout" json:"idle_timeout"`
	// dwNetworkBlackoutTime (4 bytes): Same as dwNetworkBlackoutTime in IKEV2_TUNNEL_CONFIG_PARAMS_1.
	NetworkBlackoutTime uint32 `idl:"name:dwNetworkBlackoutTime" json:"network_blackout_time"`
	// dwSaLifeTime (4 bytes): Same as dwSaLifeTime in IKEV2_TUNNEL_CONFIG_PARAMS_1.
	SALifeTime uint32 `idl:"name:dwSaLifeTime" json:"sa_life_time"`
	// dwSaDataSizeForRenegotiation (4 bytes): Same as dwSaDataSizeForRenegotiation in IKEV2_TUNNEL_CONFIG_PARAMS_1.
	SADataSizeForRenegotiation uint32 `idl:"name:dwSaDataSizeForRenegotiation" json:"sa_data_size_for_renegotiation"`
	// dwConfigOptions (4 bytes): Same as dwConfigOptions in IKEV2_TUNNEL_CONFIG_PARAMS_1.
	ConfigOptions uint32 `idl:"name:dwConfigOptions" json:"config_options"`
	// dwTotalCertificates (4 bytes): Same as dwTotalCertificates in IKEV2_TUNNEL_CONFIG_PARAMS_1.
	TotalCertificates uint32 `idl:"name:dwTotalCertificates" json:"total_certificates"`
	// certificateNames (variable): Same as certificateNames in IKEV2_TUNNEL_CONFIG_PARAMS_1.
	CertificateNames []*CertBlob1 `idl:"name:certificateNames;size_is:(dwTotalCertificates)" json:"certificate_names"`
	// machineCertificateName (variable): This MUST be a CERT_BLOB_1. This member specifies
	// the certificate configured to be sent to the peer for authentication during the main
	// mode (MM SA) negotiation [RFC4306] for the IKE2 tunnel-based VPN connections. A zero
	// (0) value for the cbData member of CERT_BLOB_1 indicates that no certificate is configured.
	MachineCertificateName *CertBlob1 `idl:"name:machineCertificateName" json:"machine_certificate_name"`
	// dwEncryptionType (4 bytes): Specifies the encryption type to be negotiated during
	// the SA negotiation [RFC4306] for the IKE2 tunnel-based VPN connections. This SHOULD
	// have one of the values in the following table.
	//
	//	+-------+----------------------------------------------------------------------------------+
	//	|       |                                                                                  |
	//	| VALUE |                                     MEANING                                      |
	//	|       |                                                                                  |
	//	+-------+----------------------------------------------------------------------------------+
	//	+-------+----------------------------------------------------------------------------------+
	//	|     0 | RRAS will not negotiate encryption.                                              |
	//	+-------+----------------------------------------------------------------------------------+
	//	|     1 | RRAS requests encryption during negotiation. Negotiation will succeed even if    |
	//	|       | remote RRAS does not support encryption.                                         |
	//	+-------+----------------------------------------------------------------------------------+
	//	|     2 | RRAS requires encryption to be negotiated.                                       |
	//	+-------+----------------------------------------------------------------------------------+
	//	|     3 | RRAS requires maximum-strength encryption to be negotiated.                      |
	//	+-------+----------------------------------------------------------------------------------+
	EncryptionType uint32 `idl:"name:dwEncryptionType" json:"encryption_type"`
	// customPolicy (8 bytes): This MUST be a pointer to ROUTER_CUSTOM_IKEv2_POLICY_0 that
	// specifies the custom IKEv2 configurations to be used during the SA negotiation [RFC4306].
	// The NULL value for this member indicates that no custom IKEv2 configuration is available.
	CustomPolicy *RouterCustomIKEv2Policy0 `idl:"name:customPolicy" json:"custom_policy"`
}

func (o *IKEv2TunnelConfigParams2) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if o.CertificateNames != nil && o.TotalCertificates == 0 {
		o.TotalCertificates = uint32(len(o.CertificateNames))
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IKEv2TunnelConfigParams2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.IdleTimeout); err != nil {
		return err
	}
	if err := w.WriteData(o.NetworkBlackoutTime); err != nil {
		return err
	}
	if err := w.WriteData(o.SALifeTime); err != nil {
		return err
	}
	if err := w.WriteData(o.SADataSizeForRenegotiation); err != nil {
		return err
	}
	if err := w.WriteData(o.ConfigOptions); err != nil {
		return err
	}
	if err := w.WriteData(o.TotalCertificates); err != nil {
		return err
	}
	if o.CertificateNames != nil || o.TotalCertificates > 0 {
		_ptr_certificateNames := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.TotalCertificates)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.CertificateNames {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.CertificateNames[i1] != nil {
					if err := o.CertificateNames[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&CertBlob1{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.CertificateNames); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&CertBlob1{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.CertificateNames, _ptr_certificateNames); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.MachineCertificateName != nil {
		if err := o.MachineCertificateName.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&CertBlob1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.EncryptionType); err != nil {
		return err
	}
	if o.CustomPolicy != nil {
		_ptr_customPolicy := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.CustomPolicy != nil {
				if err := o.CustomPolicy.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&RouterCustomIKEv2Policy0{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.CustomPolicy, _ptr_customPolicy); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *IKEv2TunnelConfigParams2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.IdleTimeout); err != nil {
		return err
	}
	if err := w.ReadData(&o.NetworkBlackoutTime); err != nil {
		return err
	}
	if err := w.ReadData(&o.SALifeTime); err != nil {
		return err
	}
	if err := w.ReadData(&o.SADataSizeForRenegotiation); err != nil {
		return err
	}
	if err := w.ReadData(&o.ConfigOptions); err != nil {
		return err
	}
	if err := w.ReadData(&o.TotalCertificates); err != nil {
		return err
	}
	_ptr_certificateNames := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.TotalCertificates > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.TotalCertificates)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.CertificateNames", sizeInfo[0])
		}
		o.CertificateNames = make([]*CertBlob1, sizeInfo[0])
		for i1 := range o.CertificateNames {
			i1 := i1
			if o.CertificateNames[i1] == nil {
				o.CertificateNames[i1] = &CertBlob1{}
			}
			if err := o.CertificateNames[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_certificateNames := func(ptr interface{}) { o.CertificateNames = *ptr.(*[]*CertBlob1) }
	if err := w.ReadPointer(&o.CertificateNames, _s_certificateNames, _ptr_certificateNames); err != nil {
		return err
	}
	if o.MachineCertificateName == nil {
		o.MachineCertificateName = &CertBlob1{}
	}
	if err := o.MachineCertificateName.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.EncryptionType); err != nil {
		return err
	}
	_ptr_customPolicy := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.CustomPolicy == nil {
			o.CustomPolicy = &RouterCustomIKEv2Policy0{}
		}
		if err := o.CustomPolicy.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_customPolicy := func(ptr interface{}) { o.CustomPolicy = *ptr.(**RouterCustomIKEv2Policy0) }
	if err := w.ReadPointer(&o.CustomPolicy, _s_customPolicy, _ptr_customPolicy); err != nil {
		return err
	}
	return nil
}

// IKEv2TunnelConfigParams3 structure represents IKEV2_TUNNEL_CONFIG_PARAMS_3 RPC structure.
//
// The IKEV2_TUNNEL_CONFIG_PARAMS_3 structure<176> is used to get or set configured
// parameters for IKEv2 devices (see [RFC4306]).
//
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwIdleTimeout                                                                                                                 |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwNetworkBlackoutTime                                                                                                         |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwSaLifeTime                                                                                                                  |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwSaDataSizeForRenegotiation                                                                                                  |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwConfigOptions                                                                                                               |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwTotalCertificates                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| certificateNames (variable)                                                                                                   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| machineCertificateName (variable)                                                                                             |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwEncryptionType                                                                                                              |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| customPolicy                                                                                                                  |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwTotalEkus                                                                                                                   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| certificateEKUs (variable)                                                                                                    |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| machineCertificateHash (variable)                                                                                             |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
type IKEv2TunnelConfigParams3 struct {
	// dwIdleTimeout (4 bytes): Same as dwIdleTimeout in IKEV2_TUNNEL_CONFIG_PARAMS_1 (section
	// 2.2.1.2.136).
	IdleTimeout uint32 `idl:"name:dwIdleTimeout" json:"idle_timeout"`
	// dwNetworkBlackoutTime (4 bytes): Same as dwNetworkBlackoutTime in IKEV2_TUNNEL_CONFIG_PARAMS_1.
	NetworkBlackoutTime uint32 `idl:"name:dwNetworkBlackoutTime" json:"network_blackout_time"`
	// dwSaLifeTime (4 bytes): Same as dwSaLifeTime in IKEV2_TUNNEL_CONFIG_PARAMS_1.
	SALifeTime uint32 `idl:"name:dwSaLifeTime" json:"sa_life_time"`
	// dwSaDataSizeForRenegotiation (4 bytes): Same as dwSaDataSizeForRenegotiation in IKEV2_TUNNEL_CONFIG_PARAMS_1.
	SADataSizeForRenegotiation uint32 `idl:"name:dwSaDataSizeForRenegotiation" json:"sa_data_size_for_renegotiation"`
	// dwConfigOptions (4 bytes): Same as dwConfigOptions in IKEV2_TUNNEL_CONFIG_PARAMS_1.
	ConfigOptions uint32 `idl:"name:dwConfigOptions" json:"config_options"`
	// dwTotalCertificates (4 bytes): Same as dwTotalCertificates in IKEV2_TUNNEL_CONFIG_PARAMS_1.
	TotalCertificates uint32 `idl:"name:dwTotalCertificates" json:"total_certificates"`
	// certificateNames (variable): Same as certificateNames in IKEV2_TUNNEL_CONFIG_PARAMS_1.
	CertificateNames []*CertBlob1 `idl:"name:certificateNames;size_is:(dwTotalCertificates)" json:"certificate_names"`
	// machineCertificateName (variable): Same as machineCertificateName in IKEV2_TUNNEL_CONFIG_PARAMS_2
	// (section 2.2.1.2.238).
	MachineCertificateName *CertBlob1 `idl:"name:machineCertificateName" json:"machine_certificate_name"`
	// dwEncryptionType (4 bytes): Same as dwEncryptionType in IKEV2_TUNNEL_CONFIG_PARAMS_2.
	EncryptionType uint32 `idl:"name:dwEncryptionType" json:"encryption_type"`
	// customPolicy (8 bytes): Same as customPolicy in IKEV2_TUNNEL_CONFIG_PARAMS_2.
	CustomPolicy *RouterCustomIKEv2Policy0 `idl:"name:customPolicy" json:"custom_policy"`
	// dwTotalEkus (4 bytes): Total number of EKUs in member variable certificateEKUs.
	TotalEkus uint32 `idl:"name:dwTotalEkus" json:"total_ekus"`
	// certificateEKUs (variable): An array of CERT_EKU_1 (section 2.2.1.2.246) that specifies
	// the EKU parameter of the certificates that are accepted by the RemoteAccess server
	// for IKEv2 tunnel-based VPN connections.
	CertificateEkUs []*CertEKU1 `idl:"name:certificateEKUs;size_is:(dwTotalEkus)" json:"certificate_ek_us"`
	// machineCertificateHash (variable): This MUST be a CERT_BLOB_1 (section 2.2.1.2.135).
	// This member specifies the hash of the X.509 certificate that is configured to be
	// sent to the peer for authentication during the MM SA negotiation [RFC4306] for the
	// IKE2 tunnel-based VPN connections. A zero (0) value for the cbData member of CERT_BLOB_1
	// indicates that no certificate is configured.
	MachineCertificateHash *CertBlob1 `idl:"name:machineCertificateHash" json:"machine_certificate_hash"`
}

func (o *IKEv2TunnelConfigParams3) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if o.CertificateNames != nil && o.TotalCertificates == 0 {
		o.TotalCertificates = uint32(len(o.CertificateNames))
	}
	if o.CertificateEkUs != nil && o.TotalEkus == 0 {
		o.TotalEkus = uint32(len(o.CertificateEkUs))
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IKEv2TunnelConfigParams3) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.IdleTimeout); err != nil {
		return err
	}
	if err := w.WriteData(o.NetworkBlackoutTime); err != nil {
		return err
	}
	if err := w.WriteData(o.SALifeTime); err != nil {
		return err
	}
	if err := w.WriteData(o.SADataSizeForRenegotiation); err != nil {
		return err
	}
	if err := w.WriteData(o.ConfigOptions); err != nil {
		return err
	}
	if err := w.WriteData(o.TotalCertificates); err != nil {
		return err
	}
	if o.CertificateNames != nil || o.TotalCertificates > 0 {
		_ptr_certificateNames := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.TotalCertificates)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.CertificateNames {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.CertificateNames[i1] != nil {
					if err := o.CertificateNames[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&CertBlob1{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.CertificateNames); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&CertBlob1{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.CertificateNames, _ptr_certificateNames); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.MachineCertificateName != nil {
		if err := o.MachineCertificateName.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&CertBlob1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.EncryptionType); err != nil {
		return err
	}
	if o.CustomPolicy != nil {
		_ptr_customPolicy := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.CustomPolicy != nil {
				if err := o.CustomPolicy.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&RouterCustomIKEv2Policy0{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.CustomPolicy, _ptr_customPolicy); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.TotalEkus); err != nil {
		return err
	}
	if o.CertificateEkUs != nil || o.TotalEkus > 0 {
		_ptr_certificateEKUs := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.TotalEkus)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.CertificateEkUs {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.CertificateEkUs[i1] != nil {
					if err := o.CertificateEkUs[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&CertEKU1{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.CertificateEkUs); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&CertEKU1{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.CertificateEkUs, _ptr_certificateEKUs); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.MachineCertificateHash != nil {
		if err := o.MachineCertificateHash.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&CertBlob1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *IKEv2TunnelConfigParams3) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.IdleTimeout); err != nil {
		return err
	}
	if err := w.ReadData(&o.NetworkBlackoutTime); err != nil {
		return err
	}
	if err := w.ReadData(&o.SALifeTime); err != nil {
		return err
	}
	if err := w.ReadData(&o.SADataSizeForRenegotiation); err != nil {
		return err
	}
	if err := w.ReadData(&o.ConfigOptions); err != nil {
		return err
	}
	if err := w.ReadData(&o.TotalCertificates); err != nil {
		return err
	}
	_ptr_certificateNames := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.TotalCertificates > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.TotalCertificates)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.CertificateNames", sizeInfo[0])
		}
		o.CertificateNames = make([]*CertBlob1, sizeInfo[0])
		for i1 := range o.CertificateNames {
			i1 := i1
			if o.CertificateNames[i1] == nil {
				o.CertificateNames[i1] = &CertBlob1{}
			}
			if err := o.CertificateNames[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_certificateNames := func(ptr interface{}) { o.CertificateNames = *ptr.(*[]*CertBlob1) }
	if err := w.ReadPointer(&o.CertificateNames, _s_certificateNames, _ptr_certificateNames); err != nil {
		return err
	}
	if o.MachineCertificateName == nil {
		o.MachineCertificateName = &CertBlob1{}
	}
	if err := o.MachineCertificateName.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.EncryptionType); err != nil {
		return err
	}
	_ptr_customPolicy := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.CustomPolicy == nil {
			o.CustomPolicy = &RouterCustomIKEv2Policy0{}
		}
		if err := o.CustomPolicy.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_customPolicy := func(ptr interface{}) { o.CustomPolicy = *ptr.(**RouterCustomIKEv2Policy0) }
	if err := w.ReadPointer(&o.CustomPolicy, _s_customPolicy, _ptr_customPolicy); err != nil {
		return err
	}
	if err := w.ReadData(&o.TotalEkus); err != nil {
		return err
	}
	_ptr_certificateEKUs := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.TotalEkus > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.TotalEkus)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.CertificateEkUs", sizeInfo[0])
		}
		o.CertificateEkUs = make([]*CertEKU1, sizeInfo[0])
		for i1 := range o.CertificateEkUs {
			i1 := i1
			if o.CertificateEkUs[i1] == nil {
				o.CertificateEkUs[i1] = &CertEKU1{}
			}
			if err := o.CertificateEkUs[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_certificateEKUs := func(ptr interface{}) { o.CertificateEkUs = *ptr.(*[]*CertEKU1) }
	if err := w.ReadPointer(&o.CertificateEkUs, _s_certificateEKUs, _ptr_certificateEKUs); err != nil {
		return err
	}
	if o.MachineCertificateHash == nil {
		o.MachineCertificateHash = &CertBlob1{}
	}
	if err := o.MachineCertificateHash.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// L2TPTunnelConfigParams1 structure represents L2TP_TUNNEL_CONFIG_PARAMS_1 RPC structure.
//
// The L2TP_TUNNEL_CONFIG_PARAMS_1 structure<199> is used to get or set configured parameters
// for L2TP devices.
//
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwIdleTimeout                                                                                                                 |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwEncryptionType                                                                                                              |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwSaLifeTime                                                                                                                  |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwSaDataSizeForRenegotiation                                                                                                  |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| customPolicy                                                                                                                  |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
type L2TPTunnelConfigParams1 struct {
	// dwIdleTimeout (4 bytes): Duration, in seconds, after which the connection will be
	// disconnected if there is no traffic. This value MUST be between 300 and 17,279,999.
	//
	// dwEncryptionType (4 bytes): Specifies the encryption type to be negotiated for the
	// L2TP tunnel-based VPN connections. One of the following values is used.
	//
	//	+-------+----------------------------------------------------------------------------------+
	//	|       |                                                                                  |
	//	| VALUE |                                     MEANING                                      |
	//	|       |                                                                                  |
	//	+-------+----------------------------------------------------------------------------------+
	//	+-------+----------------------------------------------------------------------------------+
	//	|     0 | RRAS will not negotiate encryption.                                              |
	//	+-------+----------------------------------------------------------------------------------+
	//	|     1 | RRAS requests encryption during negotiation. Negotiation will succeed even if    |
	//	|       | remote RRAS does not support encryption.                                         |
	//	+-------+----------------------------------------------------------------------------------+
	//	|     2 | RRAS requires encryption to be negotiated.                                       |
	//	+-------+----------------------------------------------------------------------------------+
	//	|     3 | RRAS requires maximum-strength encryption to be negotiated.                      |
	//	+-------+----------------------------------------------------------------------------------+
	IdleTimeout    uint32 `idl:"name:dwIdleTimeout" json:"idle_timeout"`
	EncryptionType uint32 `idl:"name:dwEncryptionType" json:"encryption_type"`
	// dwSaLifeTime (4 bytes): The lifetime of a security association (SA), in seconds,
	// after which the SA is no longer valid [RFC4306]. This value MUST be between 300 and
	// 17,279,999.
	SALifeTime uint32 `idl:"name:dwSaLifeTime" json:"sa_life_time"`
	// dwSaDataSizeForRenegotiation (4 bytes): Number of kilobytes that are allowed to transfer
	// using a SA. After that, the SA is renegotiated [RFC4306]. This value MUST be greater
	// than or equal to 1024.
	SADataSizeForRenegotiation uint32 `idl:"name:dwSaDataSizeForRenegotiation" json:"sa_data_size_for_renegotiation"`
	// customPolicy (8 bytes): This MUST be a pointer to ROUTER_CUSTOM_IKEv2_POLICY_0 (section
	// 2.2.1.2.237) that specifies the custom IPSec configurations to be used during the
	// SA negotiation [RFC4306]. The NULL value for this member indicates that no custom
	// IPsec configuration is available.
	CustomPolicy *RouterCustomL2TPPolicy0 `idl:"name:customPolicy" json:"custom_policy"`
}

func (o *L2TPTunnelConfigParams1) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *L2TPTunnelConfigParams1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.IdleTimeout); err != nil {
		return err
	}
	if err := w.WriteData(o.EncryptionType); err != nil {
		return err
	}
	if err := w.WriteData(o.SALifeTime); err != nil {
		return err
	}
	if err := w.WriteData(o.SADataSizeForRenegotiation); err != nil {
		return err
	}
	if o.CustomPolicy != nil {
		_ptr_customPolicy := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.CustomPolicy != nil {
				if err := o.CustomPolicy.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&RouterCustomL2TPPolicy0{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.CustomPolicy, _ptr_customPolicy); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *L2TPTunnelConfigParams1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.IdleTimeout); err != nil {
		return err
	}
	if err := w.ReadData(&o.EncryptionType); err != nil {
		return err
	}
	if err := w.ReadData(&o.SALifeTime); err != nil {
		return err
	}
	if err := w.ReadData(&o.SADataSizeForRenegotiation); err != nil {
		return err
	}
	_ptr_customPolicy := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.CustomPolicy == nil {
			o.CustomPolicy = &RouterCustomL2TPPolicy0{}
		}
		if err := o.CustomPolicy.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_customPolicy := func(ptr interface{}) { o.CustomPolicy = *ptr.(**RouterCustomL2TPPolicy0) }
	if err := w.ReadPointer(&o.CustomPolicy, _s_customPolicy, _ptr_customPolicy); err != nil {
		return err
	}
	return nil
}

// IKEv2ConfigParams1 structure represents IKEV2_CONFIG_PARAMS_1 RPC structure.
//
// The IKEV2_CONFIG_PARAMS_1 structure<121> is used to get or set configured parameters
// for IKEv2 devices.
type IKEv2ConfigParams1 struct {
	// dwNumPorts: Specifies the number of ports configured on RRAS to accept IKEv2 connections.
	// This value cannot exceed the server port limit.<122>
	PortsLength uint32 `idl:"name:dwNumPorts" json:"ports_length"`
	// dwPortFlags: Specifies the type of port configured on IKEv2 devices. Possible flag
	// values are as follows.
	//
	//	+-------------------------------------+-------------------------------------+
	//	|                                     |                                     |
	//	|                VALUE                |               MEANING               |
	//	|                                     |                                     |
	//	+-------------------------------------+-------------------------------------+
	//	+-------------------------------------+-------------------------------------+
	//	| MPR_ENABLE_RAS_ON_DEVICE 0x00000001 | Remote Access is enabled for IKEv2. |
	//	+-------------------------------------+-------------------------------------+
	PortFlags uint32 `idl:"name:dwPortFlags" json:"port_flags"`
	// dwTunnelConfigParamFlags: SHOULD be set to 0x00000001 when sent and SHOULD be ignored
	// on receipt.
	TunnelConfigParamFlags uint32 `idl:"name:dwTunnelConfigParamFlags" json:"tunnel_config_param_flags"`
	// TunnelConfigParams: IKEv2 tunnel related parameters. MUST be an IKEV2_TUNNEL_CONFIG_PARAMS_1
	// structure.
	TunnelConfigParams *IKEv2TunnelConfigParams1 `idl:"name:TunnelConfigParams" json:"tunnel_config_params"`
}

func (o *IKEv2ConfigParams1) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IKEv2ConfigParams1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.PortsLength); err != nil {
		return err
	}
	if err := w.WriteData(o.PortFlags); err != nil {
		return err
	}
	if err := w.WriteData(o.TunnelConfigParamFlags); err != nil {
		return err
	}
	if o.TunnelConfigParams != nil {
		if err := o.TunnelConfigParams.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&IKEv2TunnelConfigParams1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *IKEv2ConfigParams1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.PortsLength); err != nil {
		return err
	}
	if err := w.ReadData(&o.PortFlags); err != nil {
		return err
	}
	if err := w.ReadData(&o.TunnelConfigParamFlags); err != nil {
		return err
	}
	if o.TunnelConfigParams == nil {
		o.TunnelConfigParams = &IKEv2TunnelConfigParams1{}
	}
	if err := o.TunnelConfigParams.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// IKEv2ConfigParams2 structure represents IKEV2_CONFIG_PARAMS_2 RPC structure.
//
// The IKEV2_CONFIG_PARAMS_2 structure<168> is used to get or set configured parameters
// for IKEv2 devices.
type IKEv2ConfigParams2 struct {
	// dwNumPorts: Same as dwNumPorts in IKEV2_CONFIG_PARAMS_1.
	PortsLength uint32 `idl:"name:dwNumPorts" json:"ports_length"`
	// dwPortFlags: Same as dwPortFlags in IKEV2_CONFIG_PARAMS_1.
	PortFlags uint32 `idl:"name:dwPortFlags" json:"port_flags"`
	// dwTunnelConfigParamFlags: Same as dwTunnelConfigParamFlags in IKEV2_CONFIG_PARAMS_1.
	TunnelConfigParamFlags uint32 `idl:"name:dwTunnelConfigParamFlags" json:"tunnel_config_param_flags"`
	// TunnelConfigParams: IKEv2 tunnel-related parameters. MUST be an IKEV2_TUNNEL_CONFIG_PARAMS_2
	// structure.
	TunnelConfigParams *IKEv2TunnelConfigParams2 `idl:"name:TunnelConfigParams" json:"tunnel_config_params"`
}

func (o *IKEv2ConfigParams2) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IKEv2ConfigParams2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.PortsLength); err != nil {
		return err
	}
	if err := w.WriteData(o.PortFlags); err != nil {
		return err
	}
	if err := w.WriteData(o.TunnelConfigParamFlags); err != nil {
		return err
	}
	if o.TunnelConfigParams != nil {
		if err := o.TunnelConfigParams.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&IKEv2TunnelConfigParams2{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *IKEv2ConfigParams2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.PortsLength); err != nil {
		return err
	}
	if err := w.ReadData(&o.PortFlags); err != nil {
		return err
	}
	if err := w.ReadData(&o.TunnelConfigParamFlags); err != nil {
		return err
	}
	if o.TunnelConfigParams == nil {
		o.TunnelConfigParams = &IKEv2TunnelConfigParams2{}
	}
	if err := o.TunnelConfigParams.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// IKEv2ConfigParams3 structure represents IKEV2_CONFIG_PARAMS_3 RPC structure.
//
// The IKEV2_CONFIG_PARAMS_3 structure<177> is used to get or set configured parameters
// for IKEv2 devices.
type IKEv2ConfigParams3 struct {
	// dwNumPorts: Same as dwNumPorts in IKEV2_CONFIG_PARAMS_1 (section 2.2.1.2.137).
	PortsLength uint32 `idl:"name:dwNumPorts" json:"ports_length"`
	// dwPortFlags: Same as dwPortFlags in IKEV2_CONFIG_PARAMS_1.
	PortFlags uint32 `idl:"name:dwPortFlags" json:"port_flags"`
	// dwTunnelConfigParamFlags: Same as dwTunnelConfigParamFlags in IKEV2_CONFIG_PARAMS_1.
	TunnelConfigParamFlags uint32 `idl:"name:dwTunnelConfigParamFlags" json:"tunnel_config_param_flags"`
	// TunnelConfigParams: IKEv2 tunnel-related parameters. MUST be an IKEV2_TUNNEL_CONFIG_PARAMS_3
	// structure.
	TunnelConfigParams *IKEv2TunnelConfigParams3 `idl:"name:TunnelConfigParams" json:"tunnel_config_params"`
}

func (o *IKEv2ConfigParams3) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IKEv2ConfigParams3) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.PortsLength); err != nil {
		return err
	}
	if err := w.WriteData(o.PortFlags); err != nil {
		return err
	}
	if err := w.WriteData(o.TunnelConfigParamFlags); err != nil {
		return err
	}
	if o.TunnelConfigParams != nil {
		if err := o.TunnelConfigParams.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&IKEv2TunnelConfigParams3{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *IKEv2ConfigParams3) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.PortsLength); err != nil {
		return err
	}
	if err := w.ReadData(&o.PortFlags); err != nil {
		return err
	}
	if err := w.ReadData(&o.TunnelConfigParamFlags); err != nil {
		return err
	}
	if o.TunnelConfigParams == nil {
		o.TunnelConfigParams = &IKEv2TunnelConfigParams3{}
	}
	if err := o.TunnelConfigParams.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// PPTPConfigParams1 structure represents PPTP_CONFIG_PARAMS_1 RPC structure.
//
// The PPTP_CONFIG_PARAMS_1 structure<123> be used to get or set the device configuration
// for PPTP on the RAS Server.
type PPTPConfigParams1 struct {
	// dwNumPorts: Specifies the number of ports configured on that (PPTP) device. This
	// value cannot exceed the server port limit.<124>
	PortsLength uint32 `idl:"name:dwNumPorts" json:"ports_length"`
	// dwPortFlags: Specifies the type of port configured on PPTP devices. The possible
	// flag values are as follows.
	//
	//	+-----------------------------------------+------------------------------------------------------------+
	//	|                                         |                                                            |
	//	|                  VALUE                  |                          MEANING                           |
	//	|                                         |                                                            |
	//	+-----------------------------------------+------------------------------------------------------------+
	//	+-----------------------------------------+------------------------------------------------------------+
	//	| MPR_ENABLE_RAS_ON_DEVICE 0x00000001     | PPTP is enabled to accept Remote Access client connection. |
	//	+-----------------------------------------+------------------------------------------------------------+
	//	| MPR_ENABLE_ROUTING_ON_DEVICE 0x00000002 | PPTP is enabled to accept demand-dial connections.         |
	//	+-----------------------------------------+------------------------------------------------------------+
	PortFlags uint32 `idl:"name:dwPortFlags" json:"port_flags"`
}

func (o *PPTPConfigParams1) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *PPTPConfigParams1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.PortsLength); err != nil {
		return err
	}
	if err := w.WriteData(o.PortFlags); err != nil {
		return err
	}
	return nil
}
func (o *PPTPConfigParams1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.PortsLength); err != nil {
		return err
	}
	if err := w.ReadData(&o.PortFlags); err != nil {
		return err
	}
	return nil
}

// L2TPConfigParams1 structure represents L2TP_CONFIG_PARAMS_1 RPC structure.
//
// The L2TP_CONFIG_PARAMS_1 structure<125> is used to get or set the device configuration
// for L2TP on RAS Server.
type L2TPConfigParams1 struct {
	// dwNumPorts: Specifies the number of ports configured on the (L2TP) device. This value
	// cannot exceed the server port limit.<126>
	PortsLength uint32 `idl:"name:dwNumPorts" json:"ports_length"`
	// dwPortFlags: Specifies the type of port configured on L2TP devices. Possible flag
	// values are as follows.
	//
	//	+-----------------------------------------+------------------------------------------------------------+
	//	|                                         |                                                            |
	//	|                  VALUE                  |                          MEANING                           |
	//	|                                         |                                                            |
	//	+-----------------------------------------+------------------------------------------------------------+
	//	+-----------------------------------------+------------------------------------------------------------+
	//	| MPR_ENABLE_RAS_ON_DEVICE 0x00000001     | L2TP is enabled to accept Remote Access client connection. |
	//	+-----------------------------------------+------------------------------------------------------------+
	//	| MPR_ENABLE_ROUTING_ON_DEVICE 0x00000002 | L2TP is enabled to accept demand-dial connections.         |
	//	+-----------------------------------------+------------------------------------------------------------+
	PortFlags uint32 `idl:"name:dwPortFlags" json:"port_flags"`
}

func (o *L2TPConfigParams1) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *L2TPConfigParams1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.PortsLength); err != nil {
		return err
	}
	if err := w.WriteData(o.PortFlags); err != nil {
		return err
	}
	return nil
}
func (o *L2TPConfigParams1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.PortsLength); err != nil {
		return err
	}
	if err := w.ReadData(&o.PortFlags); err != nil {
		return err
	}
	return nil
}

// L2TPConfigParams2 structure represents L2TP_CONFIG_PARAMS_2 RPC structure.
//
// The L2TP_CONFIG_PARAMS_2 structure<200> is used to get or set the device configuration
// for L2TP on a RAS server.
type L2TPConfigParams2 struct {
	// dwNumPorts: This is the same as dwNumPort in L2TP_CONFIG_PARAMS_1 (section 2.2.1.2.139).
	PortsLength uint32 `idl:"name:dwNumPorts" json:"ports_length"`
	// dwPortFlags: Same as dwPortFlags in L2TP_CONFIG_PARAMS_1.
	PortFlags uint32 `idl:"name:dwPortFlags" json:"port_flags"`
	// dwTunnelConfigParamFlags: This SHOULD be set to 0x00000001 when sent and ignored
	// on receipt.
	TunnelConfigParamFlags uint32 `idl:"name:dwTunnelConfigParamFlags" json:"tunnel_config_param_flags"`
	// TunnelConfigParams: L2TP tunnel related parameters. This MUST be an L2TP_TUNNEL_CONFIG_PARAMS_1
	// (section 2.2.1.2.270) structure.
	TunnelConfigParams *L2TPTunnelConfigParams1 `idl:"name:TunnelConfigParams" json:"tunnel_config_params"`
}

func (o *L2TPConfigParams2) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *L2TPConfigParams2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.PortsLength); err != nil {
		return err
	}
	if err := w.WriteData(o.PortFlags); err != nil {
		return err
	}
	if err := w.WriteData(o.TunnelConfigParamFlags); err != nil {
		return err
	}
	if o.TunnelConfigParams != nil {
		if err := o.TunnelConfigParams.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&L2TPTunnelConfigParams1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *L2TPConfigParams2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.PortsLength); err != nil {
		return err
	}
	if err := w.ReadData(&o.PortFlags); err != nil {
		return err
	}
	if err := w.ReadData(&o.TunnelConfigParamFlags); err != nil {
		return err
	}
	if o.TunnelConfigParams == nil {
		o.TunnelConfigParams = &L2TPTunnelConfigParams1{}
	}
	if err := o.TunnelConfigParams.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// SSTPCertInfo1 structure represents SSTP_CERT_INFO_1 RPC structure.
//
// The SSTP_CERT_INFO_1 structure<127> contain the subject name of the x.509 certificates
// that will be configured by the RRAS to be used in SSL/TLS negotiation as a part of
// the [MS-SSTP] protocol.
//
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| isDefault                                                                                                                     |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| certBlob (variable)                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
type SSTPCertInfo1 struct {
	// isDefault (4 bytes): This value specifies how the SSTP certificate hash values are
	// configured. Possible flag values are as follows.
	//
	//	+-------+-----------------------------------------------------------------------+
	//	|       |                                                                       |
	//	| VALUE |                                MEANING                                |
	//	|       |                                                                       |
	//	+-------+-----------------------------------------------------------------------+
	//	+-------+-----------------------------------------------------------------------+
	//	| TRUE  | RRAS server chooses a certificate hash on its own automatically.      |
	//	+-------+-----------------------------------------------------------------------+
	//	| FALSE | The SSTP certificate hash values are configured by the administrator. |
	//	+-------+-----------------------------------------------------------------------+
	IsDefault bool `idl:"name:isDefault" json:"is_default"`
	// certBlob (variable): This MUST be a CERT_BLOB_1. This contains the Certificate HASH
	// Length and Certificate Hash. It accepts ONLY SHA256 HASH as the valid HASH. Thus,
	// the value of the length field SHOULD always be 32 [RFC2459]. Specifying a value 0
	// for the cbData member of CERT_BLOB_1 removes the certificate configuration. In this
	// case, RRAS server uses its default certificate selection logic.
	CertBlob *CertBlob1 `idl:"name:certBlob" json:"cert_blob"`
}

func (o *SSTPCertInfo1) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *SSTPCertInfo1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if !o.IsDefault {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if o.CertBlob != nil {
		if err := o.CertBlob.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&CertBlob1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *SSTPCertInfo1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	var _bIsDefault int32
	if err := w.ReadData(&_bIsDefault); err != nil {
		return err
	}
	o.IsDefault = _bIsDefault != 0
	if o.CertBlob == nil {
		o.CertBlob = &CertBlob1{}
	}
	if err := o.CertBlob.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// SSTPConfigParams1 structure represents SSTP_CONFIG_PARAMS_1 RPC structure.
//
// The SSTP_CONFIG_PARAMS_1 structure<128> be used to get or set the device configuration
// for SSTP on a RAS Server [MS-SSTP].
type SSTPConfigParams1 struct {
	// dwNumPorts: Specifies the number of ports configured on that (SSTP) device. This
	// value cannot exceed the server port limit.<129>
	PortsLength uint32 `idl:"name:dwNumPorts" json:"ports_length"`
	// dwPortFlags: Specifies the type of port configured on SSTP devices. Possible flag
	// values are as follows.
	//
	//	+-------------------------------------+------------------------------------+
	//	|                                     |                                    |
	//	|                VALUE                |              MEANING               |
	//	|                                     |                                    |
	//	+-------------------------------------+------------------------------------+
	//	+-------------------------------------+------------------------------------+
	//	| MPR_ENABLE_RAS_ON_DEVICE 0x00000001 | Remote Access is enabled for SSTP. |
	//	+-------------------------------------+------------------------------------+
	PortFlags uint32 `idl:"name:dwPortFlags" json:"port_flags"`
	// isUseHttps: MUST be set to TRUE if HTTPS used, MUST be set to FALSE if HTTPS is not
	// used.
	IsUseHTTPS bool `idl:"name:isUseHttps" json:"is_use_https"`
	// certAlgorithm: MUST be set to 0x0000800C.
	CertAlgorithm uint32 `idl:"name:certAlgorithm" json:"cert_algorithm"`
	// sstpCertDetails: MUST be a SSTP_CERT_INFO_1 structure.
	SSTPCertDetails *SSTPCertInfo1 `idl:"name:sstpCertDetails" json:"sstp_cert_details"`
}

func (o *SSTPConfigParams1) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *SSTPConfigParams1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.PortsLength); err != nil {
		return err
	}
	if err := w.WriteData(o.PortFlags); err != nil {
		return err
	}
	if !o.IsUseHTTPS {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.CertAlgorithm); err != nil {
		return err
	}
	if o.SSTPCertDetails != nil {
		if err := o.SSTPCertDetails.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&SSTPCertInfo1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *SSTPConfigParams1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.PortsLength); err != nil {
		return err
	}
	if err := w.ReadData(&o.PortFlags); err != nil {
		return err
	}
	var _bIsUseHTTPS int32
	if err := w.ReadData(&_bIsUseHTTPS); err != nil {
		return err
	}
	o.IsUseHTTPS = _bIsUseHTTPS != 0
	if err := w.ReadData(&o.CertAlgorithm); err != nil {
		return err
	}
	if o.SSTPCertDetails == nil {
		o.SSTPCertDetails = &SSTPCertInfo1{}
	}
	if err := o.SSTPCertDetails.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// TunnelConfigParams1 structure represents MPRAPI_TUNNEL_CONFIG_PARAMS_1 RPC structure.
//
// The MPRAPI_TUNNEL_CONFIG_PARAMS_1 structure<133> be used to get or set configuration
// of various tunnels on RAS server.
type TunnelConfigParams1 struct {
	// IkeConfigParams: MUST be a IKEV2_CONFIG_PARAMS_1 structure and is used to get or
	// set IKEv2 tunnel parameters.
	IKEConfigParams *IKEv2ConfigParams1 `idl:"name:IkeConfigParams" json:"ike_config_params"`
	// PptpConfigParams: MUST be a PPTP_CONFIG_PARAMS_1 structure and is used to get or
	// set PPTP tunnel parameters.
	PPTPConfigParams *PPTPConfigParams1 `idl:"name:PptpConfigParams" json:"pptp_config_params"`
	// L2tpConfigParams: MUST be a L2TP_CONFIG_PARAMS_1 structure and is used to get or
	// set L2TP tunnel parameters.
	L2TPConfigParams *L2TPConfigParams1 `idl:"name:L2tpConfigParams" json:"l2tp_config_params"`
	// SstpConfigParams: MUST be a SSTP_CONFIG_PARAMS_1 structure and is used to get or
	// set SSTP tunnel parameters.
	SSTPConfigParams *SSTPConfigParams1 `idl:"name:SstpConfigParams" json:"sstp_config_params"`
}

func (o *TunnelConfigParams1) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *TunnelConfigParams1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.IKEConfigParams != nil {
		if err := o.IKEConfigParams.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&IKEv2ConfigParams1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.PPTPConfigParams != nil {
		if err := o.PPTPConfigParams.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&PPTPConfigParams1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.L2TPConfigParams != nil {
		if err := o.L2TPConfigParams.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&L2TPConfigParams1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.SSTPConfigParams != nil {
		if err := o.SSTPConfigParams.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&SSTPConfigParams1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *TunnelConfigParams1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if o.IKEConfigParams == nil {
		o.IKEConfigParams = &IKEv2ConfigParams1{}
	}
	if err := o.IKEConfigParams.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.PPTPConfigParams == nil {
		o.PPTPConfigParams = &PPTPConfigParams1{}
	}
	if err := o.PPTPConfigParams.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.L2TPConfigParams == nil {
		o.L2TPConfigParams = &L2TPConfigParams1{}
	}
	if err := o.L2TPConfigParams.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.SSTPConfigParams == nil {
		o.SSTPConfigParams = &SSTPConfigParams1{}
	}
	if err := o.SSTPConfigParams.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// TunnelConfigParams2 structure represents MPRAPI_TUNNEL_CONFIG_PARAMS_2 RPC structure.
//
// The MPRAPI_TUNNEL_CONFIG_PARAMS_2 structure<169> is used to get or set configuration
// of various tunnels on a RAS server.
type TunnelConfigParams2 struct {
	// IkeConfigParams: MUST be an IKEV2_CONFIG_PARAMS_2 structure and is used to get or
	// set IKEv2 tunnel parameters.
	IKEConfigParams *IKEv2ConfigParams2 `idl:"name:IkeConfigParams" json:"ike_config_params"`
	// PptpConfigParams: MUST be a PPTP_CONFIG_PARAMS_1 structure and is used to get or
	// set PPTP tunnel parameters.
	PPTPConfigParams *PPTPConfigParams1 `idl:"name:PptpConfigParams" json:"pptp_config_params"`
	// L2tpConfigParams: MUST be an L2TP_CONFIG_PARAMS_1 structure and is used to get or
	// set L2TP tunnel parameters.
	L2TPConfigParams *L2TPConfigParams1 `idl:"name:L2tpConfigParams" json:"l2tp_config_params"`
	// SstpConfigParams: MUST be an SSTP_CONFIG_PARAMS_1 structure and is used to get or
	// set SSTP tunnel parameters.
	SSTPConfigParams *SSTPConfigParams1 `idl:"name:SstpConfigParams" json:"sstp_config_params"`
}

func (o *TunnelConfigParams2) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *TunnelConfigParams2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.IKEConfigParams != nil {
		if err := o.IKEConfigParams.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&IKEv2ConfigParams2{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.PPTPConfigParams != nil {
		if err := o.PPTPConfigParams.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&PPTPConfigParams1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.L2TPConfigParams != nil {
		if err := o.L2TPConfigParams.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&L2TPConfigParams1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.SSTPConfigParams != nil {
		if err := o.SSTPConfigParams.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&SSTPConfigParams1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *TunnelConfigParams2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if o.IKEConfigParams == nil {
		o.IKEConfigParams = &IKEv2ConfigParams2{}
	}
	if err := o.IKEConfigParams.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.PPTPConfigParams == nil {
		o.PPTPConfigParams = &PPTPConfigParams1{}
	}
	if err := o.PPTPConfigParams.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.L2TPConfigParams == nil {
		o.L2TPConfigParams = &L2TPConfigParams1{}
	}
	if err := o.L2TPConfigParams.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.SSTPConfigParams == nil {
		o.SSTPConfigParams = &SSTPConfigParams1{}
	}
	if err := o.SSTPConfigParams.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// TunnelConfigParams3 structure represents MPRAPI_TUNNEL_CONFIG_PARAMS_3 RPC structure.
//
// The MPRAPI_TUNNEL_CONFIG_PARAMS_3 structure<178> is used to get or set configuration
// of various tunnels on a RAS server.
type TunnelConfigParams3 struct {
	// IkeConfigParams: MUST be an IKEV2_CONFIG_PARAMS_3 (section 2.2.1.2.2488) structure.
	// This is used to get or set IKEv2 tunnel parameters.
	IKEConfigParams *IKEv2ConfigParams3 `idl:"name:IkeConfigParams" json:"ike_config_params"`
	// PptpConfigParams: MUST be a PPTP_CONFIG_PARAMS_1 (section 2.2.1.2.138) structure.
	// This is used to get or set PPTP tunnel parameters.
	PPTPConfigParams *PPTPConfigParams1 `idl:"name:PptpConfigParams" json:"pptp_config_params"`
	// L2tpConfigParams: MUST be an L2TP_CONFIG_PARAMS_2 (section 2.2.1.2.271) structure.
	// This is used to get or set L2TP tunnel parameters.
	L2TPConfigParams *L2TPConfigParams2 `idl:"name:L2tpConfigParams" json:"l2tp_config_params"`
	// SstpConfigParams: MUST be an SSTP_CONFIG_PARAMS_1 (section 2.2.1.2.141) structure.
	// This is used to get or set SSTP tunnel parameters.
	SSTPConfigParams *SSTPConfigParams1 `idl:"name:SstpConfigParams" json:"sstp_config_params"`
}

func (o *TunnelConfigParams3) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *TunnelConfigParams3) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.IKEConfigParams != nil {
		if err := o.IKEConfigParams.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&IKEv2ConfigParams3{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.PPTPConfigParams != nil {
		if err := o.PPTPConfigParams.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&PPTPConfigParams1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.L2TPConfigParams != nil {
		if err := o.L2TPConfigParams.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&L2TPConfigParams2{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.SSTPConfigParams != nil {
		if err := o.SSTPConfigParams.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&SSTPConfigParams1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *TunnelConfigParams3) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if o.IKEConfigParams == nil {
		o.IKEConfigParams = &IKEv2ConfigParams3{}
	}
	if err := o.IKEConfigParams.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.PPTPConfigParams == nil {
		o.PPTPConfigParams = &PPTPConfigParams1{}
	}
	if err := o.PPTPConfigParams.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.L2TPConfigParams == nil {
		o.L2TPConfigParams = &L2TPConfigParams2{}
	}
	if err := o.L2TPConfigParams.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.SSTPConfigParams == nil {
		o.SSTPConfigParams = &SSTPConfigParams1{}
	}
	if err := o.SSTPConfigParams.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// ServerEx1 structure represents MPR_SERVER_EX_1 RPC structure.
//
// The MPR_SERVER_EX_1 structure<130> be used to get or set the configuration of a RAS
// server.
type ServerEx1 struct {
	// Header: This specifies the version of the MPR_SERVER_EX_1 structure; and MUST be
	// a MPRAPI_OBJECT_HEADER_IDL (section 2.2.1.2.129) whose revision field MUST be 0x01,
	// and whose type field MUST be 0x02.
	Header *ObjectHeaderIDL `idl:"name:Header" json:"header"`
	// fLanOnlyMode: Specifies whether RRAS is running on the router. If TRUE, RRAS is not
	// running as the router; if FALSE, RRAS is running as router.
	LANOnlyMode bool `idl:"name:fLanOnlyMode" json:"lan_only_mode"`
	// dwUpTime: Specifies the elapsed time, in seconds, since the router was started.
	UpTime uint32 `idl:"name:dwUpTime" json:"up_time"`
	// dwTotalPorts: Specifies the number of ports on the system.
	TotalPorts uint32 `idl:"name:dwTotalPorts" json:"total_ports"`
	// dwPortsInUse: Specifies the number of ports currently in use.
	PortsInUse uint32 `idl:"name:dwPortsInUse" json:"ports_in_use"`
	// Reserved: Unused, MUST be set to 0.
	_ uint32 `idl:"name:Reserved"`
	// ConfigParams: This MUST be a MPRAPI_TUNNEL_CONFIG_PARAMS_1 structure.
	ConfigParams *TunnelConfigParams1 `idl:"name:ConfigParams" json:"config_params"`
}

func (o *ServerEx1) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *ServerEx1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.Header != nil {
		if err := o.Header.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ObjectHeaderIDL{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if !o.LANOnlyMode {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.UpTime); err != nil {
		return err
	}
	if err := w.WriteData(o.TotalPorts); err != nil {
		return err
	}
	if err := w.WriteData(o.PortsInUse); err != nil {
		return err
	}
	// reserved Reserved
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	if o.ConfigParams != nil {
		if err := o.ConfigParams.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&TunnelConfigParams1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerEx1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if o.Header == nil {
		o.Header = &ObjectHeaderIDL{}
	}
	if err := o.Header.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	var _bLANOnlyMode int32
	if err := w.ReadData(&_bLANOnlyMode); err != nil {
		return err
	}
	o.LANOnlyMode = _bLANOnlyMode != 0
	if err := w.ReadData(&o.UpTime); err != nil {
		return err
	}
	if err := w.ReadData(&o.TotalPorts); err != nil {
		return err
	}
	if err := w.ReadData(&o.PortsInUse); err != nil {
		return err
	}
	// reserved Reserved
	var _Reserved uint32
	if err := w.ReadData(&_Reserved); err != nil {
		return err
	}
	if o.ConfigParams == nil {
		o.ConfigParams = &TunnelConfigParams1{}
	}
	if err := o.ConfigParams.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// ServerEx2 structure represents MPR_SERVER_EX_2 RPC structure.
//
// The MPR_SERVER_EX_2 structure<171> is used to get or set the configuration of a RAS
// server.
type ServerEx2 struct {
	// Header: This specifies the version of the MPR_SERVER_EX_2 structure and MUST be an
	// MPRAPI_OBJECT_HEADER_IDL (section 2.2.1.2.129) whose revision field MUST be 0x02
	// and whose type field MUST be 0x02.
	Header *ObjectHeaderIDL `idl:"name:Header" json:"header"`
	// fLanOnlyMode: Same as fLanOnlyMode in MPR_SERVER_EX_1.
	LANOnlyMode bool `idl:"name:fLanOnlyMode" json:"lan_only_mode"`
	// dwUpTime: Same as dwUpTime in MPR_SERVER_EX_1.
	UpTime uint32 `idl:"name:dwUpTime" json:"up_time"`
	// dwTotalPorts: Same as dwTotalPorts in MPR_SERVER_EX_1.
	TotalPorts uint32 `idl:"name:dwTotalPorts" json:"total_ports"`
	// dwPortsInUse: Same as dwPortsInUse in MPR_SERVER_EX_1.
	PortsInUse uint32 `idl:"name:dwPortsInUse" json:"ports_in_use"`
	// Reserved: Same as Reserved in MPR_SERVER_EX_1.
	_ uint32 `idl:"name:Reserved"`
	// ConfigParams: This MUST be an MPRAPI_TUNNEL_CONFIG_PARAMS_2 structure.
	ConfigParams *TunnelConfigParams2 `idl:"name:ConfigParams" json:"config_params"`
}

func (o *ServerEx2) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *ServerEx2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.Header != nil {
		if err := o.Header.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ObjectHeaderIDL{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if !o.LANOnlyMode {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.UpTime); err != nil {
		return err
	}
	if err := w.WriteData(o.TotalPorts); err != nil {
		return err
	}
	if err := w.WriteData(o.PortsInUse); err != nil {
		return err
	}
	// reserved Reserved
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	if o.ConfigParams != nil {
		if err := o.ConfigParams.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&TunnelConfigParams2{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerEx2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if o.Header == nil {
		o.Header = &ObjectHeaderIDL{}
	}
	if err := o.Header.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	var _bLANOnlyMode int32
	if err := w.ReadData(&_bLANOnlyMode); err != nil {
		return err
	}
	o.LANOnlyMode = _bLANOnlyMode != 0
	if err := w.ReadData(&o.UpTime); err != nil {
		return err
	}
	if err := w.ReadData(&o.TotalPorts); err != nil {
		return err
	}
	if err := w.ReadData(&o.PortsInUse); err != nil {
		return err
	}
	// reserved Reserved
	var _Reserved uint32
	if err := w.ReadData(&_Reserved); err != nil {
		return err
	}
	if o.ConfigParams == nil {
		o.ConfigParams = &TunnelConfigParams2{}
	}
	if err := o.ConfigParams.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// ServerEx3 structure represents MPR_SERVER_EX_3 RPC structure.
//
// The MPR_SERVER_EX_3 structure<180> is used to get or set the configuration of a RAS
// server.
type ServerEx3 struct {
	// Header: This specifies the version of the MPR_SERVER_EX_3 structure and MUST be an
	// MPRAPI_OBJECT_HEADER_IDL (section 2.2.1.2.129) whose revision field is 0x03 and whose
	// type field is 0x02.
	Header *ObjectHeaderIDL `idl:"name:Header" json:"header"`
	// fLanOnlyMode: This is the same as fLanOnlyMode in MPR_SERVER_EX_1.
	LANOnlyMode bool `idl:"name:fLanOnlyMode" json:"lan_only_mode"`
	// dwUpTime: This is the same as dwUpTime in MPR_SERVER_EX_1.
	UpTime uint32 `idl:"name:dwUpTime" json:"up_time"`
	// dwTotalPorts: This is the same as dwTotalPorts in MPR_SERVER_EX_1.
	TotalPorts uint32 `idl:"name:dwTotalPorts" json:"total_ports"`
	// dwPortsInUse: This is the same as dwPortsInUse in MPR_SERVER_EX_1.
	PortsInUse uint32 `idl:"name:dwPortsInUse" json:"ports_in_use"`
	// Reserved: This is the same as Reserved in MPR_SERVER_EX_1.
	_ uint32 `idl:"name:Reserved"`
	// ConfigParams: This MUST be an MPRAPI_TUNNEL_CONFIG_PARAMS_3 structure.
	ConfigParams *TunnelConfigParams3 `idl:"name:ConfigParams" json:"config_params"`
}

func (o *ServerEx3) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *ServerEx3) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.Header != nil {
		if err := o.Header.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ObjectHeaderIDL{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if !o.LANOnlyMode {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.UpTime); err != nil {
		return err
	}
	if err := w.WriteData(o.TotalPorts); err != nil {
		return err
	}
	if err := w.WriteData(o.PortsInUse); err != nil {
		return err
	}
	// reserved Reserved
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	if o.ConfigParams != nil {
		if err := o.ConfigParams.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&TunnelConfigParams3{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerEx3) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if o.Header == nil {
		o.Header = &ObjectHeaderIDL{}
	}
	if err := o.Header.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	var _bLANOnlyMode int32
	if err := w.ReadData(&_bLANOnlyMode); err != nil {
		return err
	}
	o.LANOnlyMode = _bLANOnlyMode != 0
	if err := w.ReadData(&o.UpTime); err != nil {
		return err
	}
	if err := w.ReadData(&o.TotalPorts); err != nil {
		return err
	}
	if err := w.ReadData(&o.PortsInUse); err != nil {
		return err
	}
	// reserved Reserved
	var _Reserved uint32
	if err := w.ReadData(&_Reserved); err != nil {
		return err
	}
	if o.ConfigParams == nil {
		o.ConfigParams = &TunnelConfigParams3{}
	}
	if err := o.ConfigParams.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// ServerExIDL structure represents MPR_SERVER_EX_IDL RPC union.
//
// The MPR_SERVER_EX_IDL union<131> be a placeholder for one of the following structures:
// MPR_SERVER_EX_1 (section 2.2.1.2.142), MPR_SERVER_EX_2 (section 2.2.1.2.242), or
// MPR_SERVER_EX_3 (section 2.2.1.2.251).<132>
type ServerExIDL struct {
	Revision uint8
	// Types that are assignable to Value
	//
	// *ServerExIDL_ServerConfig1
	// *ServerExIDL_ServerConfig2
	// *ServerExIDL_ServerConfig3
	Value is_ServerExIDL `json:"value"`
}

func (o *ServerExIDL) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *ServerExIDL_ServerConfig1:
		if value != nil {
			return value.ServerConfig1
		}
	case *ServerExIDL_ServerConfig2:
		if value != nil {
			return value.ServerConfig2
		}
	case *ServerExIDL_ServerConfig3:
		if value != nil {
			return value.ServerConfig3
		}
	}
	return nil
}

type is_ServerExIDL interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_ServerExIDL()
}

func (o *ServerExIDL) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(uint8(o.Revision)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch o.Revision {
	case uint8(1):
		_o, _ := o.Value.(*ServerExIDL_ServerConfig1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerExIDL_ServerConfig1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint8(2):
		_o, _ := o.Value.(*ServerExIDL_ServerConfig2)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerExIDL_ServerConfig2{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint8(3):
		_o, _ := o.Value.(*ServerExIDL_ServerConfig3)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerExIDL_ServerConfig3{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", o.Revision)
	}
	return nil
}

func (o *ServerExIDL) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadData((*uint8)(&o.Revision)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch o.Revision {
	case uint8(1):
		o.Value = &ServerExIDL_ServerConfig1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint8(2):
		o.Value = &ServerExIDL_ServerConfig2{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint8(3):
		o.Value = &ServerExIDL_ServerConfig3{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", o.Revision)
	}
	return nil
}

// ServerExIDL_ServerConfig1 structure represents MPR_SERVER_EX_IDL RPC union arm.
//
// It has following labels: 1
type ServerExIDL_ServerConfig1 struct {
	// ServerConfig1: This MUST be an MPR_SERVER_EX_1 structure.
	ServerConfig1 *ServerEx1 `idl:"name:ServerConfig1" json:"server_config1"`
}

func (*ServerExIDL_ServerConfig1) is_ServerExIDL() {}

func (o *ServerExIDL_ServerConfig1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerConfig1 != nil {
		if err := o.ServerConfig1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ServerEx1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerExIDL_ServerConfig1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.ServerConfig1 == nil {
		o.ServerConfig1 = &ServerEx1{}
	}
	if err := o.ServerConfig1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// ServerExIDL_ServerConfig2 structure represents MPR_SERVER_EX_IDL RPC union arm.
//
// It has following labels: 2
type ServerExIDL_ServerConfig2 struct {
	// ServerConfig2: This MUST be an MPR_SERVER_EX_2 structure.
	ServerConfig2 *ServerEx2 `idl:"name:ServerConfig2" json:"server_config2"`
}

func (*ServerExIDL_ServerConfig2) is_ServerExIDL() {}

func (o *ServerExIDL_ServerConfig2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerConfig2 != nil {
		if err := o.ServerConfig2.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ServerEx2{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerExIDL_ServerConfig2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.ServerConfig2 == nil {
		o.ServerConfig2 = &ServerEx2{}
	}
	if err := o.ServerConfig2.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// ServerExIDL_ServerConfig3 structure represents MPR_SERVER_EX_IDL RPC union arm.
//
// It has following labels: 3
type ServerExIDL_ServerConfig3 struct {
	// ServerConfig3: This MUST be an MPR_SERVER_EX_3 structure.
	ServerConfig3 *ServerEx3 `idl:"name:ServerConfig3" json:"server_config3"`
}

func (*ServerExIDL_ServerConfig3) is_ServerExIDL() {}

func (o *ServerExIDL_ServerConfig3) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerConfig3 != nil {
		if err := o.ServerConfig3.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ServerEx3{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerExIDL_ServerConfig3) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.ServerConfig3 == nil {
		o.ServerConfig3 = &ServerEx3{}
	}
	if err := o.ServerConfig3.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// ServerSetConfigEx1 structure represents MPR_SERVER_SET_CONFIG_EX_1 RPC structure.
//
// The MPR_SERVER_SET_CONFIG_EX_1 structure<134> be used to set the configuration parameters
// for the RRAS.
type ServerSetConfigEx1 struct {
	// Header: This MUST be MPRAPI_OBJECT_HEADER_IDL (section 2.2.1.2.129), the revision
	// field MUST be 0x01, and the type field MUST be 0x03.
	Header *ObjectHeaderIDL `idl:"name:Header" json:"header"`
	// setConfigForProtocols: This MUST be one of the following values that specify the
	// type of tunnel.
	//
	//	+-------------------------------------------------+---------------------------------------------------------------------+
	//	|                                                 |                                                                     |
	//	|                      VALUE                      |                               MEANING                               |
	//	|                                                 |                                                                     |
	//	+-------------------------------------------------+---------------------------------------------------------------------+
	//	+-------------------------------------------------+---------------------------------------------------------------------+
	//	| MPRAPI_SET_CONFIG_PROTOCOL_FOR_PPTP 0x00000001  | PPTP device configuration parameters are present in the structure.  |
	//	+-------------------------------------------------+---------------------------------------------------------------------+
	//	| MPRAPI_SET_CONFIG_PROTOCOL_FOR_L2TP 0x00000002  | L2TP device configuration parameters are present in the structure.  |
	//	+-------------------------------------------------+---------------------------------------------------------------------+
	//	| MPRAPI_SET_CONFIG_PROTOCOL_FOR_SSTP 0x00000004  | SSTP device configuration parameters are present in the structure.  |
	//	+-------------------------------------------------+---------------------------------------------------------------------+
	//	| MPRAPI_SET_CONFIG_PROTOCOL_FOR_IKEV2 0x00000008 | IKEv2 device configuration parameters are present in the structure. |
	//	+-------------------------------------------------+---------------------------------------------------------------------+
	SetConfigForProtocols uint32 `idl:"name:setConfigForProtocols" json:"set_config_for_protocols"`
	// ConfigParams: This MUST be a MPRAPI_TUNNEL_CONFIG_PARAMS_1.
	ConfigParams *TunnelConfigParams1 `idl:"name:ConfigParams" json:"config_params"`
}

func (o *ServerSetConfigEx1) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *ServerSetConfigEx1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.Header != nil {
		if err := o.Header.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ObjectHeaderIDL{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.SetConfigForProtocols); err != nil {
		return err
	}
	if o.ConfigParams != nil {
		if err := o.ConfigParams.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&TunnelConfigParams1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerSetConfigEx1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if o.Header == nil {
		o.Header = &ObjectHeaderIDL{}
	}
	if err := o.Header.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.SetConfigForProtocols); err != nil {
		return err
	}
	if o.ConfigParams == nil {
		o.ConfigParams = &TunnelConfigParams1{}
	}
	if err := o.ConfigParams.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// ServerSetConfigEx2 structure represents MPR_SERVER_SET_CONFIG_EX_2 RPC structure.
//
// The MPR_SERVER_SET_CONFIG_EX_2 structure<170> is used to set the configuration parameters
// for the RRAS server.
type ServerSetConfigEx2 struct {
	// Header: This MUST be an MPRAPI_OBJECT_HEADER_IDL (section 2.2.1.2.129) structure,
	// the revision field MUST be 0x02, and the type field MUST be 0x03.
	Header *ObjectHeaderIDL `idl:"name:Header" json:"header"`
	// setConfigForProtocols: Same as setConfigForProtocols in MPR_SERVER_SET_CONFIG_EX_1.
	SetConfigForProtocols uint32 `idl:"name:setConfigForProtocols" json:"set_config_for_protocols"`
	// ConfigParams: This MUST be an MPRAPI_TUNNEL_CONFIG_PARAMS_2 structure.
	ConfigParams *TunnelConfigParams2 `idl:"name:ConfigParams" json:"config_params"`
}

func (o *ServerSetConfigEx2) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *ServerSetConfigEx2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.Header != nil {
		if err := o.Header.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ObjectHeaderIDL{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.SetConfigForProtocols); err != nil {
		return err
	}
	if o.ConfigParams != nil {
		if err := o.ConfigParams.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&TunnelConfigParams2{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerSetConfigEx2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if o.Header == nil {
		o.Header = &ObjectHeaderIDL{}
	}
	if err := o.Header.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.SetConfigForProtocols); err != nil {
		return err
	}
	if o.ConfigParams == nil {
		o.ConfigParams = &TunnelConfigParams2{}
	}
	if err := o.ConfigParams.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// ServerSetConfigEx3 structure represents MPR_SERVER_SET_CONFIG_EX_3 RPC structure.
//
// The MPR_SERVER_SET_CONFIG_EX_3 structure<179> is used to set the configuration parameters
// for the RRAS server
type ServerSetConfigEx3 struct {
	// Header: This MUST be an MPRAPI_OBJECT_HEADER_IDL (section 2.2.1.2.129), the revision
	// field MUST be 0x03, and the type field MUST be 0x03.
	Header *ObjectHeaderIDL `idl:"name:Header" json:"header"`
	// setConfigForProtocols: Same as setConfigForProtocols in MPR_SERVER_SET_CONFIG_EX_1
	// (section 2.2.1.2.145).
	SetConfigForProtocols uint32 `idl:"name:setConfigForProtocols" json:"set_config_for_protocols"`
	// ConfigParams: This MUST be an MPRAPI_TUNNEL_CONFIG_PARAMS_3 (section 2.2.1.2.249)
	// structure.
	ConfigParams *TunnelConfigParams3 `idl:"name:ConfigParams" json:"config_params"`
}

func (o *ServerSetConfigEx3) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *ServerSetConfigEx3) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.Header != nil {
		if err := o.Header.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ObjectHeaderIDL{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.SetConfigForProtocols); err != nil {
		return err
	}
	if o.ConfigParams != nil {
		if err := o.ConfigParams.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&TunnelConfigParams3{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerSetConfigEx3) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if o.Header == nil {
		o.Header = &ObjectHeaderIDL{}
	}
	if err := o.Header.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.SetConfigForProtocols); err != nil {
		return err
	}
	if o.ConfigParams == nil {
		o.ConfigParams = &TunnelConfigParams3{}
	}
	if err := o.ConfigParams.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// ServerSetConfigExIDL structure represents MPR_SERVER_SET_CONFIG_EX_IDL RPC union.
//
// The MPR_SERVER_SET_CONFIG_EX_IDL union is used to get or set configured parameters
// for PPTP, L2TP, SSTP, and IKEv2 devices.
type ServerSetConfigExIDL struct {
	Revision uint8
	// Types that are assignable to Value
	//
	// *ServerSetConfigExIDL_ServerSetConfig1
	// *ServerSetConfigExIDL_ServerSetConfig2
	// *ServerSetConfigExIDL_ServerSetConfig3
	Value is_ServerSetConfigExIDL `json:"value"`
}

func (o *ServerSetConfigExIDL) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *ServerSetConfigExIDL_ServerSetConfig1:
		if value != nil {
			return value.ServerSetConfig1
		}
	case *ServerSetConfigExIDL_ServerSetConfig2:
		if value != nil {
			return value.ServerSetConfig2
		}
	case *ServerSetConfigExIDL_ServerSetConfig3:
		if value != nil {
			return value.ServerSetConfig3
		}
	}
	return nil
}

type is_ServerSetConfigExIDL interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_ServerSetConfigExIDL()
}

func (o *ServerSetConfigExIDL) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(uint8(o.Revision)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch o.Revision {
	case uint8(1):
		_o, _ := o.Value.(*ServerSetConfigExIDL_ServerSetConfig1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerSetConfigExIDL_ServerSetConfig1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint8(2):
		_o, _ := o.Value.(*ServerSetConfigExIDL_ServerSetConfig2)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerSetConfigExIDL_ServerSetConfig2{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint8(3):
		_o, _ := o.Value.(*ServerSetConfigExIDL_ServerSetConfig3)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ServerSetConfigExIDL_ServerSetConfig3{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", o.Revision)
	}
	return nil
}

func (o *ServerSetConfigExIDL) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadData((*uint8)(&o.Revision)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch o.Revision {
	case uint8(1):
		o.Value = &ServerSetConfigExIDL_ServerSetConfig1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint8(2):
		o.Value = &ServerSetConfigExIDL_ServerSetConfig2{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint8(3):
		o.Value = &ServerSetConfigExIDL_ServerSetConfig3{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", o.Revision)
	}
	return nil
}

// ServerSetConfigExIDL_ServerSetConfig1 structure represents MPR_SERVER_SET_CONFIG_EX_IDL RPC union arm.
//
// It has following labels: 1
type ServerSetConfigExIDL_ServerSetConfig1 struct {
	// ServerSetConfig1: This MUST be an MPR_SERVER_SET_CONFIG_EX_1 structure.
	ServerSetConfig1 *ServerSetConfigEx1 `idl:"name:ServerSetConfig1" json:"server_set_config1"`
}

func (*ServerSetConfigExIDL_ServerSetConfig1) is_ServerSetConfigExIDL() {}

func (o *ServerSetConfigExIDL_ServerSetConfig1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerSetConfig1 != nil {
		if err := o.ServerSetConfig1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ServerSetConfigEx1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerSetConfigExIDL_ServerSetConfig1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.ServerSetConfig1 == nil {
		o.ServerSetConfig1 = &ServerSetConfigEx1{}
	}
	if err := o.ServerSetConfig1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// ServerSetConfigExIDL_ServerSetConfig2 structure represents MPR_SERVER_SET_CONFIG_EX_IDL RPC union arm.
//
// It has following labels: 2
type ServerSetConfigExIDL_ServerSetConfig2 struct {
	// ServerSetConfig2: This MUST be an MPR_SERVER_SET_CONFIG_EX_2 structure.
	ServerSetConfig2 *ServerSetConfigEx2 `idl:"name:ServerSetConfig2" json:"server_set_config2"`
}

func (*ServerSetConfigExIDL_ServerSetConfig2) is_ServerSetConfigExIDL() {}

func (o *ServerSetConfigExIDL_ServerSetConfig2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerSetConfig2 != nil {
		if err := o.ServerSetConfig2.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ServerSetConfigEx2{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerSetConfigExIDL_ServerSetConfig2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.ServerSetConfig2 == nil {
		o.ServerSetConfig2 = &ServerSetConfigEx2{}
	}
	if err := o.ServerSetConfig2.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// ServerSetConfigExIDL_ServerSetConfig3 structure represents MPR_SERVER_SET_CONFIG_EX_IDL RPC union arm.
//
// It has following labels: 3
type ServerSetConfigExIDL_ServerSetConfig3 struct {
	// ServerSetConfig3: This MUST be an MPR_SERVER_SET_CONFIG_EX_3 structure.
	ServerSetConfig3 *ServerSetConfigEx3 `idl:"name:ServerSetConfig3" json:"server_set_config3"`
}

func (*ServerSetConfigExIDL_ServerSetConfig3) is_ServerSetConfigExIDL() {}

func (o *ServerSetConfigExIDL_ServerSetConfig3) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ServerSetConfig3 != nil {
		if err := o.ServerSetConfig3.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ServerSetConfigEx3{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServerSetConfigExIDL_ServerSetConfig3) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.ServerSetConfig3 == nil {
		o.ServerSetConfig3 = &ServerSetConfigEx3{}
	}
	if err := o.ServerSetConfig3.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// RASUpdateConnection1IDL structure represents RAS_UPDATE_CONNECTION_1_IDL RPC structure.
//
// The RAS_UPDATE_CONNECTION_1_IDL structure<135> contain information about the tunnel
// endpoint address on an IKEv2 connection.
type RASUpdateConnection1IDL struct {
	// Header: MUST be a MPRAPI_OBJECT_HEADER_IDL.
	Header *ObjectHeaderIDL `idl:"name:Header" json:"header"`
	// dwIfIndex: MUST be set to the index of the local interface to which the connections
	// has to be switched and on which MOBIKE [RFC4555] is to be sent.
	InterfaceIndex uint32 `idl:"name:dwIfIndex" json:"interface_index"`
	// wszRemoteEndpointAddress: Specifies a null-terminated Unicode string that holds the
	// remote IP address to which connections has to be switched and on which MOBIKE is
	// to be sent for the connection. This string has the form a.b.c.d in case of IPv4 address
	// and a::b:c in case of IPv6; for example, "10.102.235.84" or "2001::a456".
	RemoteEndpointAddress []uint16 `idl:"name:wszRemoteEndpointAddress" json:"remote_endpoint_address"`
}

func (o *RASUpdateConnection1IDL) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *RASUpdateConnection1IDL) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if o.Header != nil {
		if err := o.Header.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ObjectHeaderIDL{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.InterfaceIndex); err != nil {
		return err
	}
	for i1 := range o.RemoteEndpointAddress {
		i1 := i1
		if uint64(i1) >= 65 {
			break
		}
		if err := w.WriteData(o.RemoteEndpointAddress[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.RemoteEndpointAddress); uint64(i1) < 65; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	if err := w.WriteTrailingGap(4); err != nil {
		return err
	}
	return nil
}
func (o *RASUpdateConnection1IDL) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if o.Header == nil {
		o.Header = &ObjectHeaderIDL{}
	}
	if err := o.Header.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.InterfaceIndex); err != nil {
		return err
	}
	o.RemoteEndpointAddress = make([]uint16, 65)
	for i1 := range o.RemoteEndpointAddress {
		i1 := i1
		if err := w.ReadData(&o.RemoteEndpointAddress[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadTrailingGap(4); err != nil {
		return err
	}
	return nil
}

// RASUpdateConnectionIDL structure represents RAS_UPDATE_CONNECTION_IDL RPC union.
//
// The RAS_UPDATE_CONNECTION_IDL union<136> be used to send the MOBIKE [RFC4555] on
// an IKEv2 connection.
type RASUpdateConnectionIDL struct {
	Revision uint8
	// Types that are assignable to Value
	//
	// *RASUpdateConnectionIDL_UpdateConnection1
	Value is_RASUpdateConnectionIDL `json:"value"`
}

func (o *RASUpdateConnectionIDL) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *RASUpdateConnectionIDL_UpdateConnection1:
		if value != nil {
			return value.UpdateConnection1
		}
	}
	return nil
}

type is_RASUpdateConnectionIDL interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_RASUpdateConnectionIDL()
}

func (o *RASUpdateConnectionIDL) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := w.WriteUnionAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(uint8(o.Revision)); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(4); err != nil {
		return err
	}
	switch o.Revision {
	case uint8(1):
		_o, _ := o.Value.(*RASUpdateConnectionIDL_UpdateConnection1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&RASUpdateConnectionIDL_UpdateConnection1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", o.Revision)
	}
	return nil
}

func (o *RASUpdateConnectionIDL) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadUnionAlign(4); err != nil {
		return err
	}
	if err := w.ReadData((*uint8)(&o.Revision)); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(4); err != nil {
		return err
	}
	switch o.Revision {
	case uint8(1):
		o.Value = &RASUpdateConnectionIDL_UpdateConnection1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", o.Revision)
	}
	return nil
}

// RASUpdateConnectionIDL_UpdateConnection1 structure represents RAS_UPDATE_CONNECTION_IDL RPC union arm.
//
// It has following labels: 1
type RASUpdateConnectionIDL_UpdateConnection1 struct {
	// UpdateConnection1: This MUST be an RAS_UPDATE_CONNECTION_1_IDL structure.
	UpdateConnection1 *RASUpdateConnection1IDL `idl:"name:UpdateConnection1" json:"update_connection1"`
}

func (*RASUpdateConnectionIDL_UpdateConnection1) is_RASUpdateConnectionIDL() {}

func (o *RASUpdateConnectionIDL_UpdateConnection1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.UpdateConnection1 != nil {
		if err := o.UpdateConnection1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&RASUpdateConnection1IDL{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *RASUpdateConnectionIDL_UpdateConnection1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.UpdateConnection1 == nil {
		o.UpdateConnection1 = &RASUpdateConnection1IDL{}
	}
	if err := o.UpdateConnection1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// InterfaceContainer structure represents DIM_INTERFACE_CONTAINER RPC structure.
//
// The DIM_INTERFACE_CONTAINER structure specifies a generic structure used by certain
// methods to set, create, or retrieve information from the RRAS server.
type InterfaceContainer struct {
	// fGetInterfaceInfo: This field is used to get interface information from the server.
	// This MUST be set to TRUE when the client needs to retrieve interface information
	// from the server while calling the RRouterInterfaceTransportGetGlobalInfo (section
	// 3.1.4.11) and RRouterInterfaceTransportGetInfo (section 3.1.4.19) methods.
	GetInterfaceInfo uint32 `idl:"name:fGetInterfaceInfo" json:"get_interface_info"`
	// dwInterfaceInfoSize: This MUST be set to the size of pInterfaceInfo.
	InterfaceInfoSize uint32 `idl:"name:dwInterfaceInfoSize" json:"interface_info_size"`
	// pInterfaceInfo: This MUST point to a buffer that specifies the default client interface
	// information for the transport. The buffer MUST contain RTR_INFO_BLOCK_HEADER (section
	// 2.2.1.2.3) with a valid info type of RTR_TOC_ENTRY (section 2.2.1.2.4).
	InterfaceInfo []byte `idl:"name:pInterfaceInfo;size_is:(dwInterfaceInfoSize)" json:"interface_info"`
	// fGetGlobalInfo: This field is used to get or set global information. This field MUST
	// be set to TRUE when the client needs to retrieve global information from the server
	// while calling RRouterInterfaceTransportGetGlobalInfo.
	GetGlobalInfo uint32 `idl:"name:fGetGlobalInfo" json:"get_global_info"`
	// dwGlobalInfoSize: This MUST be set to the size of pGlobalInfo.
	GlobalInfoSize uint32 `idl:"name:dwGlobalInfoSize" json:"global_info_size"`
	// pGlobalInfo: This MUST point to a buffer that specifies global information for the
	// transport. The buffer MUST contain a RTR_INFO_BLOCK_HEADER with a valid info type
	// of RTR_TOC_ENTRY.
	//
	// The DIM_INTERFACE_CONTAINER specifies a generic structure used by the following methods
	// to set, create, or retrieve information from the RRAS server:
	//
	// * *RRouterInterfaceTransportSetGlobalInfo (section 3.1.4.10)* ( 071439e7-a9fd-40e4-91f7-ab756108e82f
	// )
	//
	// * *RRouterInterfaceTransportGetGlobalInfo (section 3.1.4.11)*
	//
	// * *RRouterInterfaceTransportAdd (section 3.1.4.18)* ( 927c5bf1-ac91-4325-b945-0d96a58f609b
	// )
	//
	// * *RRouterInterfaceTransportGetInfo (section 3.1.4.19)*
	//
	// * *RRouterInterfaceTransportSetInfo (section 3.1.4.20)* ( 209ba5e7-876e-4406-a05c-65b7e5fb2380
	// )
	//
	// * *RRouterInterfaceTransportCreate (section 3.1.4.38)* ( 9829344c-f22b-4d53-946b-20542ec43be4
	// )
	GlobalInfo []byte `idl:"name:pGlobalInfo;size_is:(dwGlobalInfoSize)" json:"global_info"`
}

func (o *InterfaceContainer) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if o.InterfaceInfo != nil && o.InterfaceInfoSize == 0 {
		o.InterfaceInfoSize = uint32(len(o.InterfaceInfo))
	}
	if o.GlobalInfo != nil && o.GlobalInfoSize == 0 {
		o.GlobalInfoSize = uint32(len(o.GlobalInfo))
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *InterfaceContainer) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.GetInterfaceInfo); err != nil {
		return err
	}
	if err := w.WriteData(o.InterfaceInfoSize); err != nil {
		return err
	}
	if o.InterfaceInfo != nil || o.InterfaceInfoSize > 0 {
		_ptr_pInterfaceInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.InterfaceInfoSize)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.InterfaceInfo {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.InterfaceInfo[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.InterfaceInfo); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.InterfaceInfo, _ptr_pInterfaceInfo); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.GetGlobalInfo); err != nil {
		return err
	}
	if err := w.WriteData(o.GlobalInfoSize); err != nil {
		return err
	}
	if o.GlobalInfo != nil || o.GlobalInfoSize > 0 {
		_ptr_pGlobalInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.GlobalInfoSize)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.GlobalInfo {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.GlobalInfo[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.GlobalInfo); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.GlobalInfo, _ptr_pGlobalInfo); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *InterfaceContainer) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.GetInterfaceInfo); err != nil {
		return err
	}
	if err := w.ReadData(&o.InterfaceInfoSize); err != nil {
		return err
	}
	_ptr_pInterfaceInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.InterfaceInfoSize > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.InterfaceInfoSize)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.InterfaceInfo", sizeInfo[0])
		}
		o.InterfaceInfo = make([]byte, sizeInfo[0])
		for i1 := range o.InterfaceInfo {
			i1 := i1
			if err := w.ReadData(&o.InterfaceInfo[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_pInterfaceInfo := func(ptr interface{}) { o.InterfaceInfo = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.InterfaceInfo, _s_pInterfaceInfo, _ptr_pInterfaceInfo); err != nil {
		return err
	}
	if err := w.ReadData(&o.GetGlobalInfo); err != nil {
		return err
	}
	if err := w.ReadData(&o.GlobalInfoSize); err != nil {
		return err
	}
	_ptr_pGlobalInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.GlobalInfoSize > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.GlobalInfoSize)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.GlobalInfo", sizeInfo[0])
		}
		o.GlobalInfo = make([]byte, sizeInfo[0])
		for i1 := range o.GlobalInfo {
			i1 := i1
			if err := w.ReadData(&o.GlobalInfo[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_pGlobalInfo := func(ptr interface{}) { o.GlobalInfo = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.GlobalInfo, _s_pGlobalInfo, _ptr_pGlobalInfo); err != nil {
		return err
	}
	return nil
}

// RouterTOCEntry structure represents RTR_TOC_ENTRY RPC structure.
//
// The RTR_TOC_ENTRY structure specifies the format in which information pertaining
// to the type of data is stored in RTR_INFO_BLOCK_HEADER (section 2.2.1.2.3). The following
// figure shows the relationships between the block header and the entries.
type RouterTOCEntry struct {
	// InfoType (4 bytes): A 32-bit, unsigned integer in network byte order that MUST indicate
	// the type of data contained in the list. The value MUST be one of the following when
	// the transport is IPv4 or IPv6.<17>
	//
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                          |                                                                                  |                             STRUCTURE POINTED TO AT                              |
	//	|                  VALUE                   |                                     MEANING                                      |                                      OFFSET                                      |
	//	|                                          |                                                                                  |                                                                                  |
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_IN_FILTER_INFO 0xFFFF0001             | The input filter that is applied to the IP packets sent to the RRAS server.      | FILTER_DESCRIPTOR (section 2.2.1.2.5)                                            |
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_OUT_FILTER_INFO 0xFFFF0002            | The output filter that is applied to the IP packets sent from the RRAS server.   | FILTER_DESCRIPTOR (section 2.2.1.2.5)                                            |
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_GLOBAL_INFO 0xFFFF0003                | Global IP filtering information.                                                 | GLOBAL_INFO (section 2.2.1.2.9)                                                  |
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_INTERFACE_STATUS_INFO 0xFFFF0004      | IPv4 interface status information.                                               | INTERFACE_STATUS_INFO (section 2.2.1.2.18)                                       |
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_ROUTE_INFO 0xFFFF0005                 | Routing information is added. If bV4 of INTERFACE_ROUTE_INFO is set, an IPv4     | INTERFACE_ROUTE_INFO (section 2.2.1.2.11)                                        |
	//	|                                          | route is added; otherwise, an IPv6 route is added.                               |                                                                                  |
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_PROT_PRIORITY_INFO 0xFFFF0006         | Protocol priority information.                                                   | PRIORITY_INFO (section 2.2.1.2.12)                                               |
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_PROT_PRIORITY_INFO_EX<18> 0xFFFF0017  | Protocol priority information.                                                   | PRIORITY_INFO_EX (section 2.2.1.2.266)                                           |
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_ROUTER_DISC_INFO 0xFFFF0007           | Router discovery information.                                                    | RTR_DISC_INFO (section 2.2.1.2.14)                                               |
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_DEMAND_DIAL_FILTER_INFO 0xFFFF0009    | The IP traffic that matches this filter indicates that a demand-dial connection  | FILTER_DESCRIPTOR (section 2.2.1.2.5)                                            |
	//	|                                          | is available and all the IP packets matching this filter MUST be routed into the |                                                                                  |
	//	|                                          | connection.                                                                      |                                                                                  |
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_MCAST_HEARTBEAT_INFO 0xFFFF000A       | Specifies the multicast heartbeat configuration for an interface.                | MCAST_HBEAT_INFO (section 2.2.1.2.15)                                            |
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_MCAST_BOUNDARY_INFO 0xFFFF000B        | Multicast boundary information.                                                  | MIB_BOUNDARYROW (section 2.2.1.2.24)                                             |
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_IPINIP_CFG_INFO 0xFFFF000C            | IP in IP configuration information.                                              | IPINIP_CONFIG_INFO (section 2.2.1.2.17)<19>                                      |
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_IFFILTER_INFO 0xFFFF000D              | IPv4 interface filter information.                                               | IFFILTER_INFO (section 2.2.1.2.88)                                               |
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_MCAST_LIMIT_INFO 0xFFFF000E           | Multicast configuration information.                                             | MIB_MCAST_LIMIT_ROW (section 2.2.1.2.16)                                         |
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IPV6_GLOBAL_INFO 0xFFFF000F              | Global lPv6 filtering information.                                               | GLOBAL_INFO (section 2.2.1.2.9)                                                  |
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_IN_FILTER_INFO_V6 0xFFFF0011          | The input filter that MUST be applied to the IPv6 packets sent to the RRAS       | FILTER_DESCRIPTOR_V6 (section 2.2.1.2.7)                                         |
	//	|                                          | server.                                                                          |                                                                                  |
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_OUT_FILTER_INFO_V6 0xFFFF0012         | The output filter that MUST be applied to the IPv6 packets sent from the RRAS    | FILTER_DESCRIPTOR_V6 (section 2.2.1.2.7)                                         |
	//	|                                          | server.                                                                          |                                                                                  |
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_DEMAND_DIAL_FILTER_INFO_V6 0xFFFF0013 | IPv6 traffic that matches this filter indicates that a site-to-site connection   | FILTER_DESCRIPTOR_V6 (section 2.2.1.2.7)                                         |
	//	|                                          | MUST be available and all the IPv6 packets matching this filter MUST be routed   |                                                                                  |
	//	|                                          | into the connection.                                                             |                                                                                  |
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_IFFILTER_INFO_V6 0xFFFF0014           | IPv6 interface filter information.                                               | IFFILTER_INFO (section 2.2.1.2.88)                                               |
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_FILTER_ENABLE_INFO 0xFFFF0015         | Enable or disable IPv4 interface filter.                                         | MPR_FILTER_0 (section 2.2.1.2.89)<20>                                            |
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_FILTER_ENABLE_INFO_V6 0xFFFF0016      | Enable or disable IPv6 interface filter.                                         | MPR_FILTER_0 (section 2.2.1.2.89)                                                |
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MS_IP_BOOTP 0x0000270F                   | IP BOOTP global or interface information depending on the method that calls.     | IPBOOTP_GLOBAL_CONFIG (section 2.2.1.2.149) IPBOOTP_IF_CONFIG (section           |
	//	|                                          |                                                                                  | 2.2.1.2.150)                                                                     |
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MS_IP_IGMP 0x4137000A                    | IGMP global or interface information depending on the method that calls.         | IGMP_MIB_GLOBAL_CONFIG (section 2.2.1.2.173) IGMP_MIB_IF_CONFIG (section         |
	//	|                                          |                                                                                  | 2.2.1.2.174)                                                                     |
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MS_IP_RIP 0x00000008                     | IP RIP global or interface information depending on the method that calls.       | IPRIP_IF_CONFIG (section 2.2.1.2.166) IPRIP_GLOBAL_CONFIG (section 2.2.1.2.164)  |
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MS_IP_BGP 0x0137000E                     | BGP configuration.                                                               | When the transport is IPv4, the structure pointed to at the offset is            |
	//	|                                          |                                                                                  | BGP_CONFIG_HEADER (section 2.2.1.2.252). When the transport is IPv6, the         |
	//	|                                          |                                                                                  | structure pointed to at the offset is BGP_ROUTER_V6 (section 2.2.1.2.265).       |
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MS_IP_DHCP_ALLOCATOR 0x81372714          | DHCP allocator global or interface information depending on the method that      | IP_AUTO_DHCP_GLOBAL_INFO (section 2.2.1.2.191) IP_AUTO_DHCP_INTERFACE_INFO       |
	//	|                                          | calls.                                                                           | (section 2.2.1.2.192)                                                            |
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MS_IP_DNS_PROXY 0x81372713               | DNS Proxy global or interface information depending on the method that calls.    | IP_DNS_PROXY_GLOBAL_INFO (section 2.2.1.2.193) IP_DNS_PROXY_INTERFACE_INFO       |
	//	|                                          |                                                                                  | (section 2.2.1.2.194)                                                            |
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MS_IP_NAT 0x81372715                     | IP NAT global or interface information depending on the method that calls.       | IP_NAT_GLOBAL_INFO (section 2.2.1.2.195) IP_NAT_INTERFACE_INFO (section          |
	//	|                                          |                                                                                  | 2.2.1.2.197)                                                                     |
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MS_IP_OSPF<21> 0x0000000D                | OSPF global or interface information depending on the method that calls.         | OSPF_ROUTE_FILTER_INFO (section 2.2.1.2.209) OSPF_PROTO_FILTER_INFO (section     |
	//	|                                          |                                                                                  | 2.2.1.2.210) OSPF_GLOBAL_PARAM (section 2.2.1.2.211) OSPF_AREA_PARAM             |
	//	|                                          |                                                                                  | (section 2.2.1.2.212) OSPF_AREA_RANGE_PARAM (section 2.2.1.2.213)                |
	//	|                                          |                                                                                  | OSPF_VIRT_INTERFACE_PARAM (section 2.2.1.2.214) OSPF_INTERFACE_PARAM (section    |
	//	|                                          |                                                                                  | 2.2.1.2.215) OSPF_NBMA_NEIGHBOR_PARAM (section 2.2.1.2.216)                      |
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MS_IPV6_DHCP 0x000003E7                  | DHCPv6 Relay global or interface information depending on the method that calls. | DHCPV6R_IF_CONFIG (section 2.2.1.2.159) DHCPV6R_GLOBAL_CONFIG (section           |
	//	|                                          |                                                                                  | 2.2.1.2.157)                                                                     |
	//	+------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//
	// The value MUST be one of the following when the transport is IPX.<22>
	//
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+---------------------------------------------------------------------------+
	//	|                                                    |                                                                                  |                          STRUCTURE POINTED TO AT                          |
	//	|                       VALUE                        |                                     MEANING                                      |                                  OFFSET                                   |
	//	|                                                    |                                                                                  |                                                                           |
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+---------------------------------------------------------------------------+
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+---------------------------------------------------------------------------+
	//	| IPX_INTERFACE_INFO_TYPE 0x00000001                 | Specifies the IPX interface data.                                                | IPX_IF_INFO (section 2.2.1.2.91)                                          |
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+---------------------------------------------------------------------------+
	//	| IPX_STATIC_ROUTE_INFO_TYPE 0x00000002              | Specifies the route information for an IPX interface.                            | IPX_STATIC_ROUTE_INFO (section 2.2.1.2.93)                                |
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+---------------------------------------------------------------------------+
	//	| IPX_STATIC_SERVICE_INFO_TYPE 0x00000003            | Specifies information about the transport layer protocol that is being           | IPX_STATIC_SERVICE_INFO (section 2.2.1.2.94)                              |
	//	|                                                    | multiplexed.                                                                     |                                                                           |
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+---------------------------------------------------------------------------+
	//	| IPX_IN_TRAFFIC_FILTER_INFO_TYPE 0x00000006         | Specifies the filter data for an IPX interface.                                  | IPX_TRAFFIC_FILTER_INFO (section 2.2.1.2.98)                              |
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+---------------------------------------------------------------------------+
	//	| IPX_ADAPTER_INFO_TYPE 0x00000007                   | Specifies the adapter information for the IPX.                                   | IPX_ADAPTER_INFO (section 2.2.1.2.96)                                     |
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+---------------------------------------------------------------------------+
	//	| IPXWAN_IF_INFO 0x00000008                          | Specifies whether IPXWAN negotiation is to be disabled or enabled.               | IPXWAN_IF_INFO (section 2.2.1.2.92)                                       |
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+---------------------------------------------------------------------------+
	//	| IPX_GLOBAL_INFO_TYPE 0x00000009                    | Specifies global IPX information. See IPX_GLOBAL_INFO for the actual             | IPX_GLOBAL_INFO (section 2.2.1.2.90)                                      |
	//	|                                                    | information.                                                                     |                                                                           |
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+---------------------------------------------------------------------------+
	//	| IPX_STATIC_NETBIOS_NAME_INFO_TYPE 0x0000000A       | Specifies the NetBIOS name of an IPX interface.                                  | IPX_STATIC_NETBIOS_NAME_INFO (section 2.2.1.2.95)                         |
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+---------------------------------------------------------------------------+
	//	| IPX_IN_TRAFFIC_FILTER_GLOBAL_INFO_TYPE 0x0000000B  | Specifies the action for a filter match.                                         | IPX_TRAFFIC_FILTER_GLOBAL_INFO (section 2.2.1.2.97)                       |
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+---------------------------------------------------------------------------+
	//	| IPX_OUT_TRAFFIC_FILTER_INFO_TYPE 0x0000000C        | Specifies the filter data for an IPX interface.                                  | IPX_TRAFFIC_FILTER_INFO (section 2.2.1.2.98)                              |
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+---------------------------------------------------------------------------+
	//	| IPX_OUT_TRAFFIC_FILTER_GLOBAL_INFO_TYPE 0x0000000D | Specifies the action for a filter match.                                         | IPX_TRAFFIC_FILTER_GLOBAL_INFO (section 2.2.1.2.97)                       |
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+---------------------------------------------------------------------------+
	//	| IPX_PROTOCOL_RIP 0x00020000                        | RIP global or interface information depending on the method that calls.          | RIP_GLOBAL_INFO (section 2.2.1.2.202) RIP_IF_CONFIG (section 2.2.1.2.206) |
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+---------------------------------------------------------------------------+
	//	| IPX_PROTOCOL_SAP 0x00020001                        | SAP global or interface information depending on the method that calls.          | SAP_GLOBAL_INFO (section 2.2.1.2.207) SAP_IF_CONFIG (section 2.2.1.2.114) |
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+---------------------------------------------------------------------------+
	InfoType uint32 `idl:"name:InfoType" json:"info_type"`
	// InfoSize (4 bytes): A 32-bit, unsigned integer, in network byte-order, that MUST
	// specify the number of bytes in an information structure of this type in this entry.
	InfoSize uint32 `idl:"name:InfoSize" json:"info_size"`
	// Count (4 bytes): A 32-bit, unsigned integer in network byte order that MUST specify
	// the number of information structures of this type in this entry.
	Count uint32 `idl:"name:Count" json:"count"`
	// Offset (4 bytes): A 32-bit, unsigned integer in network byte order that MUST specify
	// the offset of start of the first structure for this entry.
	Offset uint32 `idl:"name:Offset" json:"offset"`
}

func (o *RouterTOCEntry) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *RouterTOCEntry) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.InfoType); err != nil {
		return err
	}
	if err := w.WriteData(o.InfoSize); err != nil {
		return err
	}
	if err := w.WriteData(o.Count); err != nil {
		return err
	}
	if err := w.WriteData(o.Offset); err != nil {
		return err
	}
	return nil
}
func (o *RouterTOCEntry) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.InfoType); err != nil {
		return err
	}
	if err := w.ReadData(&o.InfoSize); err != nil {
		return err
	}
	if err := w.ReadData(&o.Count); err != nil {
		return err
	}
	if err := w.ReadData(&o.Offset); err != nil {
		return err
	}
	return nil
}

// RouterInfoBlockHeader structure represents RTR_INFO_BLOCK_HEADER RPC structure.
//
// The RTR_INFO_BLOCK_HEADER structure specifies information pertaining to the protocol
// using a set of RTR_TOC_ENTRY (section 2.2.1.2.4) structures. These structures are
// encapsulated by an RTR_INFO_BLOCK_HEADER.
//
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| Version                                                                                                                       |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| Size                                                                                                                          |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| TocEntriesCount                                                                                                               |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| TocEntry (variable)                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
type RouterInfoBlockHeader struct {
	// Version (4 bytes): A 32-bit, unsigned integer in network byte order that MUST be
	// set to 0x00000001. No other versions are defined.
	Version uint32 `idl:"name:Version" json:"version"`
	// Size (4 bytes): A 32-bit, unsigned integer in network byte order that MUST specify
	// the size of the structure in bytes including the Version, Size, TocEntriesCount,
	// and entries (TocEntry). The size MUST be at least 28 bytes. The total size depends
	// on the number and type of the entries. This value MUST be the size of the blob represented
	// by the structure. This MUST be the sum of the InfoSize of each element of TocEntry
	// and TocEntriesCount times the size of RTR_TOC_ENTRY.
	Size uint32 `idl:"name:Size" json:"size"`
	// TocEntriesCount (4 bytes): A 32-bit, unsigned integer in network byte order that
	// MUST specify the number of entries. It MUST be greater than 0.
	TOCEntriesCount uint32 `idl:"name:TocEntriesCount" json:"toc_entries_count"`
	// TocEntry (variable): A list of consecutive entries, TocEntriesCount in number, each
	// of which MUST be formatted as defined in RTR_TOC_ENTRY.
	TOCEntry []*RouterTOCEntry `idl:"name:TocEntry" json:"toc_entry"`
}

func (o *RouterInfoBlockHeader) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *RouterInfoBlockHeader) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Version); err != nil {
		return err
	}
	if err := w.WriteData(o.Size); err != nil {
		return err
	}
	if err := w.WriteData(o.TOCEntriesCount); err != nil {
		return err
	}
	for i1 := range o.TOCEntry {
		i1 := i1
		if uint64(i1) >= 1 {
			break
		}
		if o.TOCEntry[i1] != nil {
			if err := o.TOCEntry[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&RouterTOCEntry{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.TOCEntry); uint64(i1) < 1; i1++ {
		if err := (&RouterTOCEntry{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *RouterInfoBlockHeader) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Version); err != nil {
		return err
	}
	if err := w.ReadData(&o.Size); err != nil {
		return err
	}
	if err := w.ReadData(&o.TOCEntriesCount); err != nil {
		return err
	}
	o.TOCEntry = make([]*RouterTOCEntry, 1)
	for i1 := range o.TOCEntry {
		i1 := i1
		if o.TOCEntry[i1] == nil {
			o.TOCEntry[i1] = &RouterTOCEntry{}
		}
		if err := o.TOCEntry[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// FilterInfo structure represents FILTER_INFO RPC structure.
//
// The FILTER_INFO structure MUST specify the five-tuple filter to be used in FILTER_DESCRIPTOR
// (section 2.2.1.2.5).
type FilterInfo struct {
	// dwSrcAddr: A 32-bit, unsigned integer in network byte order that MUST contain the
	// IPv4 source address for which the filter (2) applies. A value of 0x00000000 in this
	// field signifies ANY.
	SourceAddr uint32 `idl:"name:dwSrcAddr" json:"source_addr"`
	// dwSrcMask: A 32-bit, unsigned integer in network byte order that MUST contain the
	// subnet mask for the source address. See [RFC950].
	SourceMask uint32 `idl:"name:dwSrcMask" json:"source_mask"`
	// dwDstAddr: A 32-bit, unsigned integer in network byte order that MUST contain the
	// IPv4 destination address for the filter. A value of 0x00000000 in this field signifies
	// ANY.
	DestinationAddr uint32 `idl:"name:dwDstAddr" json:"destination_addr"`
	// dwDstMask: A 32-bit, unsigned integer in network byte order that MUST be the subnet
	// mask for the destination address in network byte order. See [RFC950].
	DestinationMask uint32 `idl:"name:dwDstMask" json:"destination_mask"`
	// dwProtocol: A 32-bit, unsigned integer in little-endian byte order that MUST be the
	// protocol number (such as TCP or UDP) for the filter. Possible values include the
	// following.
	//
	//	+------------+---------+
	//	|            |         |
	//	|   VALUE    | MEANING |
	//	|            |         |
	//	+------------+---------+
	//	+------------+---------+
	//	| 0x00000000 | ANY     |
	//	+------------+---------+
	//	| 0x00000001 | ICMP    |
	//	+------------+---------+
	//	| 0x0000003A | ICMPv6  |
	//	+------------+---------+
	//	| 0x00000006 | TCP     |
	//	+------------+---------+
	//	| 0x00000011 | UDP     |
	//	+------------+---------+
	Protocol uint32 `idl:"name:dwProtocol" json:"protocol"`
	// fLateBound: A 32-bit, unsigned integer in little-endian byte order that indicates
	// to the RRAS server if the fields in the filter can be dynamically replaced by the
	// RRAS server with values for specific endpoints at the time those endpoints request
	// network access. This MUST be a combination of one or more of the following values.
	//
	//	+------------+-------------------------------------------------------+
	//	|            |                                                       |
	//	|   VALUE    |                        MEANING                        |
	//	|            |                                                       |
	//	+------------+-------------------------------------------------------+
	//	+------------+-------------------------------------------------------+
	//	| 0x00000000 | No source or destination address or mask replacement. |
	//	+------------+-------------------------------------------------------+
	//	| 0x00000001 | Source address replaceable with a new address.        |
	//	+------------+-------------------------------------------------------+
	//	| 0x00000004 | Destination address replaceable with a new address.   |
	//	+------------+-------------------------------------------------------+
	//	| 0x00000010 | Source address mask replaceable with a new mask.      |
	//	+------------+-------------------------------------------------------+
	//	| 0x00000020 | Destination address mask replaceable with a new mask. |
	//	+------------+-------------------------------------------------------+
	LateBound uint32 `idl:"name:fLateBound" json:"late_bound"`
	// wSrcPort: If the protocol is TCP or UDP, this MUST be a 16-bit, unsigned integer
	// in network byte order that specifies a port number for the corresponding protocol.
	// If the protocol is ICMP or ICMPv6, this MUST be a 16-bit, unsigned integer in little-endian
	// byte order that specifies a type indicator for ICMP or ICMPv6 correspondingly. For
	// all other protocol values, this MUST be set to 0 (byte order does not matter).
	SourcePort uint16 `idl:"name:wSrcPort" json:"source_port"`
	// wDstPort: If the protocol is TCP or UDP, this MUST be a 16-bit, unsigned integer
	// in network byte order that specifies a port number for the corresponding protocol.
	// If the protocol is ICMP or ICMPv6, this MUST be a 16-bit, unsigned integer in little-endian
	// byte order that specifies a code indicator for ICMP or ICMPv6 correspondingly. For
	// all other protocol values, this MUST be set to 0 (byte order does not matter).
	DestinationPort uint16 `idl:"name:wDstPort" json:"destination_port"`
}

func (o *FilterInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *FilterInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.SourceAddr); err != nil {
		return err
	}
	if err := w.WriteData(o.SourceMask); err != nil {
		return err
	}
	if err := w.WriteData(o.DestinationAddr); err != nil {
		return err
	}
	if err := w.WriteData(o.DestinationMask); err != nil {
		return err
	}
	if err := w.WriteData(o.Protocol); err != nil {
		return err
	}
	if err := w.WriteData(o.LateBound); err != nil {
		return err
	}
	if err := w.WriteData(o.SourcePort); err != nil {
		return err
	}
	if err := w.WriteData(o.DestinationPort); err != nil {
		return err
	}
	if err := w.WriteTrailingGap(4); err != nil {
		return err
	}
	return nil
}
func (o *FilterInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.SourceAddr); err != nil {
		return err
	}
	if err := w.ReadData(&o.SourceMask); err != nil {
		return err
	}
	if err := w.ReadData(&o.DestinationAddr); err != nil {
		return err
	}
	if err := w.ReadData(&o.DestinationMask); err != nil {
		return err
	}
	if err := w.ReadData(&o.Protocol); err != nil {
		return err
	}
	if err := w.ReadData(&o.LateBound); err != nil {
		return err
	}
	if err := w.ReadData(&o.SourcePort); err != nil {
		return err
	}
	if err := w.ReadData(&o.DestinationPort); err != nil {
		return err
	}
	if err := w.ReadTrailingGap(4); err != nil {
		return err
	}
	return nil
}

// FilterDescriptor structure represents FILTER_DESCRIPTOR RPC structure.
//
// The FILTER_DESCRIPTOR structure MUST be used while specifying IPv4 filters.
//
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwVersion                                                                                                                     |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwNumFilters                                                                                                                  |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| faDefaultAction                                                                                                               |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| fiFilter (variable)                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
type FilterDescriptor struct {
	// dwVersion (4 bytes): A 32-bit integer in network byte order used to specify the version.
	// It MUST be 0x00000001. No other versions are defined.
	Version uint32 `idl:"name:dwVersion" json:"version"`
	// dwNumFilters (4 bytes): A 32-bit integer in network byte order used to specify the
	// number of filters. It MUST be greater than 0.
	FiltersLength uint32 `idl:"name:dwNumFilters" json:"filters_length"`
	// faDefaultAction (4 bytes): A 32-bit integer in network byte order used to specify
	// the action for the filter. It MUST be FORWARD_ACTION (section 2.2.1.1.7).
	DefaultAction ForwardAction `idl:"name:faDefaultAction" json:"default_action"`
	// fiFilter (variable): This MUST contain the actual five-tuple filters as specified
	// in section 2.2.1.2.6.
	//
	// When this structure is used as an embedded structure in RTR_TOC_ENTRY (section 2.2.1.2.4),
	// the infoType of RTR_TOC_ENTRY MUST have the value 0xFFFF0001, 0xFFFF0002, or 0xFFFF0009
	// to specify an IPv4 in filter, an IPv4 out filter, or an IPv4 demand-dial filter respectively.
	//
	// This structure is used in the following methods:
	//
	// * *RRouterInterfaceTransportAdd (section 3.1.4.18)* ( 927c5bf1-ac91-4325-b945-0d96a58f609b
	// )
	//
	// * *RRouterInterfaceTransportGetInfo (section 3.1.4.19)* ( ec9ba293-45e9-4f12-b9af-7e77ec96c90e
	// )
	//
	// * *RRouterInterfaceTransportSetInfo (section 3.1.4.20)* ( 209ba5e7-876e-4406-a05c-65b7e5fb2380
	// )
	//
	// * *RRouterInterfaceTransportCreate (section 3.1.4.38)* ( 9829344c-f22b-4d53-946b-20542ec43be4
	// )
	Filter []*FilterInfo `idl:"name:fiFilter" json:"filter"`
}

func (o *FilterDescriptor) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *FilterDescriptor) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Version); err != nil {
		return err
	}
	if err := w.WriteData(o.FiltersLength); err != nil {
		return err
	}
	if err := w.WriteEnum(uint16(o.DefaultAction)); err != nil {
		return err
	}
	for i1 := range o.Filter {
		i1 := i1
		if uint64(i1) >= 1 {
			break
		}
		if o.Filter[i1] != nil {
			if err := o.Filter[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&FilterInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.Filter); uint64(i1) < 1; i1++ {
		if err := (&FilterInfo{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *FilterDescriptor) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Version); err != nil {
		return err
	}
	if err := w.ReadData(&o.FiltersLength); err != nil {
		return err
	}
	if err := w.ReadEnum((*uint16)(&o.DefaultAction)); err != nil {
		return err
	}
	o.Filter = make([]*FilterInfo, 1)
	for i1 := range o.Filter {
		i1 := i1
		if o.Filter[i1] == nil {
			o.Filter[i1] = &FilterInfo{}
		}
		if err := o.Filter[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// FilterInfoV6 structure represents FILTER_INFO_V6 RPC structure.
//
// The FILTER_INFO_V6 structure SHOULD<24> specify the five-tuple filters to be used
// in FILTER_DESCRIPTOR_V6 (section 2.2.1.2.7).
type FilterInfoV6 struct {
	// ipv6SrcAddr: A 128-bit, unsigned integer in network byte order that MUST contain
	// the IPv6 source address for which the filter applies. A value of zero (0) in this
	// field signifies ANY.
	IPv6SourceAddr []byte `idl:"name:ipv6SrcAddr" json:"ipv6_source_addr"`
	// dwSrcPrefixLength: A 32-bit, unsigned integer in network byte order that MUST be
	// the prefix length for the source address. A value of zero (0) in this field signifies
	// ANY source address.
	SourcePrefixLength uint32 `idl:"name:dwSrcPrefixLength" json:"source_prefix_length"`
	// ipv6DstAddr: A 128-bit, unsigned integer in network byte order that MUST contain
	// the IPv6 destination address for the filter. A value of zero (0) in this field signifies
	// ANY.
	IPv6DestinationAddr []byte `idl:"name:ipv6DstAddr" json:"ipv6_destination_addr"`
	// dwDstPrefixLength: A 32-bit, unsigned integer in network byte order that MUST be
	// the prefix length for the destination address. A value of zero (0) in this field
	// signifies ANY destination address.
	DestinationPrefixLength uint32 `idl:"name:dwDstPrefixLength" json:"destination_prefix_length"`
	// dwProtocol: A 32-bit, unsigned integer in network byte order that specifies the protocol
	// number (such as TCP or UDP) for the filter.
	//
	// Possible values include the following.
	//
	//	+------------+---------+
	//	|            |         |
	//	|   VALUE    | MEANING |
	//	|            |         |
	//	+------------+---------+
	//	+------------+---------+
	//	| 0x00000000 | ANY     |
	//	+------------+---------+
	//	| 0x00000001 | ICMP    |
	//	+------------+---------+
	//	| 0x0000003A | ICMPv6  |
	//	+------------+---------+
	//	| 0x00000006 | TCP     |
	//	+------------+---------+
	//	| 0x00000011 | UDP     |
	//	+------------+---------+
	Protocol uint32 `idl:"name:dwProtocol" json:"protocol"`
	// fLateBound: A 32-bit, unsigned integer in network byte order that indicates if the
	// fields in the filter can be dynamically replaced by the network access server (NAS)
	// with values for specific endpoints.
	//
	// The value MUST be one of the following values, or a bit-wise OR a combination of
	// the following values.
	//
	//	+------------+-------------------------------------------------------+
	//	|            |                                                       |
	//	|   VALUE    |                        MEANING                        |
	//	|            |                                                       |
	//	+------------+-------------------------------------------------------+
	//	+------------+-------------------------------------------------------+
	//	| 0x00000000 | No source or destination address or mask replacement. |
	//	+------------+-------------------------------------------------------+
	//	| 0x00000001 | Source address replaceable with a new address.        |
	//	+------------+-------------------------------------------------------+
	//	| 0x00000004 | Destination address replaceable with a new address.   |
	//	+------------+-------------------------------------------------------+
	//	| 0x00000010 | Source address mask replaceable with a new mask.      |
	//	+------------+-------------------------------------------------------+
	//	| 0x00000020 | Destination address mask replaceable with a new mask. |
	//	+------------+-------------------------------------------------------+
	LateBound uint32 `idl:"name:fLateBound" json:"late_bound"`
	// wSrcPort: If the protocol is TCP or UDP, this MUST be a 16-bit, unsigned integer
	// in network byte order that specifies a port number for the corresponding protocol.
	// If the protocol is ICMP or ICMPv6, this MUST be a 16-bit, unsigned integer in network
	// byte order that specifies a type indicator for ICMP or ICMPv6 correspondingly. For
	// all other protocol values, this MUST be set to 0 (byte order does not matter).
	SourcePort uint16 `idl:"name:wSrcPort" json:"source_port"`
	// wDstPort: If the protocol is TCP or UDP, this MUST be a 16-bit, unsigned integer
	// in network byte order that specifies a port number for the corresponding protocol.
	// If the protocol is ICMP or ICMPv6, this MUST be a 16-bit, unsigned integer in network
	// byte order that specifies a code indicator for ICMP or ICMPv6 correspondingly. For
	// all other protocol values, this MUST be set to 0 (byte order does not matter).
	DestinationPort uint16 `idl:"name:wDstPort" json:"destination_port"`
}

func (o *FilterInfoV6) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *FilterInfoV6) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	for i1 := range o.IPv6SourceAddr {
		i1 := i1
		if uint64(i1) >= 16 {
			break
		}
		if err := w.WriteData(o.IPv6SourceAddr[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.IPv6SourceAddr); uint64(i1) < 16; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.SourcePrefixLength); err != nil {
		return err
	}
	for i1 := range o.IPv6DestinationAddr {
		i1 := i1
		if uint64(i1) >= 16 {
			break
		}
		if err := w.WriteData(o.IPv6DestinationAddr[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.IPv6DestinationAddr); uint64(i1) < 16; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.DestinationPrefixLength); err != nil {
		return err
	}
	if err := w.WriteData(o.Protocol); err != nil {
		return err
	}
	if err := w.WriteData(o.LateBound); err != nil {
		return err
	}
	if err := w.WriteData(o.SourcePort); err != nil {
		return err
	}
	if err := w.WriteData(o.DestinationPort); err != nil {
		return err
	}
	if err := w.WriteTrailingGap(4); err != nil {
		return err
	}
	return nil
}
func (o *FilterInfoV6) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	o.IPv6SourceAddr = make([]byte, 16)
	for i1 := range o.IPv6SourceAddr {
		i1 := i1
		if err := w.ReadData(&o.IPv6SourceAddr[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.SourcePrefixLength); err != nil {
		return err
	}
	o.IPv6DestinationAddr = make([]byte, 16)
	for i1 := range o.IPv6DestinationAddr {
		i1 := i1
		if err := w.ReadData(&o.IPv6DestinationAddr[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.DestinationPrefixLength); err != nil {
		return err
	}
	if err := w.ReadData(&o.Protocol); err != nil {
		return err
	}
	if err := w.ReadData(&o.LateBound); err != nil {
		return err
	}
	if err := w.ReadData(&o.SourcePort); err != nil {
		return err
	}
	if err := w.ReadData(&o.DestinationPort); err != nil {
		return err
	}
	if err := w.ReadTrailingGap(4); err != nil {
		return err
	}
	return nil
}

// FilterDescriptorV6 structure represents FILTER_DESCRIPTOR_V6 RPC structure.
//
// The FILTER_DESCRIPTOR_V6 structure MUST be used while specifying IPv6 filters.
//
// This structure is used in the following methods:
//
// * *RRouterInterfaceTransportAdd (section 3.1.4.18)* ( 927c5bf1-ac91-4325-b945-0d96a58f609b
// )
//
// * *RRouterInterfaceTransportGetInfo (section 3.1.4.19)* ( ec9ba293-45e9-4f12-b9af-7e77ec96c90e
// )
//
// * *RRouterInterfaceTransportSetInfo (section 3.1.4.20)* ( 209ba5e7-876e-4406-a05c-65b7e5fb2380
// )
//
// * *RRouterInterfaceTransportCreate (section 3.1.4.38)* ( 9829344c-f22b-4d53-946b-20542ec43be4
// )
//
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwVersion                                                                                                                     |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwNumFilters                                                                                                                  |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| faDefaultAction                                                                                                               |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| fiFilter (variable)                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
type FilterDescriptorV6 struct {
	// dwVersion (4 bytes): A 32-bit integer in network byte order used to specify the version.
	// It MUST be 0x00000001. No other versions are defined.
	Version uint32 `idl:"name:dwVersion" json:"version"`
	// dwNumFilters (4 bytes): A 32-bit integer in network byte order used to specify the
	// number of filters. It MUST be greater than 0.
	FiltersLength uint32 `idl:"name:dwNumFilters" json:"filters_length"`
	// faDefaultAction (4 bytes): A 32-bit integer in network byte order used to specify
	// the action for the filter. It MUST be FORWARD_ACTION (section 2.2.1.1.7).
	DefaultAction ForwardAction `idl:"name:faDefaultAction" json:"default_action"`
	// fiFilter (variable): This is defined in FILTER_INFO_V6 (section 2.2.1.2.8).
	//
	// When this structure is used as an embedded structure in RTR_TOC_ENTRY (section 2.2.1.2.4),
	// the InfoType of RTR_TOC_ENTRY MUST be 0xFFFF0011, 0xFFFF0012, or 0xFFFF0013 to specify
	// an IPv6 in filter, an IPv6 out filter, or an IPv6 demand-dial filter respectively.<23>
	Filter []*FilterInfoV6 `idl:"name:fiFilter" json:"filter"`
}

func (o *FilterDescriptorV6) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *FilterDescriptorV6) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Version); err != nil {
		return err
	}
	if err := w.WriteData(o.FiltersLength); err != nil {
		return err
	}
	if err := w.WriteEnum(uint16(o.DefaultAction)); err != nil {
		return err
	}
	for i1 := range o.Filter {
		i1 := i1
		if uint64(i1) >= 1 {
			break
		}
		if o.Filter[i1] != nil {
			if err := o.Filter[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&FilterInfoV6{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.Filter); uint64(i1) < 1; i1++ {
		if err := (&FilterInfoV6{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *FilterDescriptorV6) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Version); err != nil {
		return err
	}
	if err := w.ReadData(&o.FiltersLength); err != nil {
		return err
	}
	if err := w.ReadEnum((*uint16)(&o.DefaultAction)); err != nil {
		return err
	}
	o.Filter = make([]*FilterInfoV6, 1)
	for i1 := range o.Filter {
		i1 := i1
		if o.Filter[i1] == nil {
			o.Filter[i1] = &FilterInfoV6{}
		}
		if err := o.Filter[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// GlobalInfo structure represents GLOBAL_INFO RPC structure.
//
// The GLOBAL_INFO structure is used to set logging levels and enable filtering on the
// RRAS server.
//
// This structure is used in the following methods:
//
// * RRouterInterfaceTransportSetGlobalInfo (section 3.1.4.10) ( 071439e7-a9fd-40e4-91f7-ab756108e82f
// )
//
// * RRouterInterfaceTransportGetGlobalInfo (section 3.1.4.11) ( 14ad8d26-d7d7-48dd-914d-da962d5d7049
// )
//
// typedef struct _GLOBAL_INFO {
//
// IN OUT BOOL bFilteringOn;
//
// IN OUT DWORD dwLoggingLevel;
//
// } GLOBAL_INFO,
type GlobalInfo struct {
	// bFilteringOn: This is of type BOOL ([MS-DTYP] section 2.2.3). This MUST be set to
	// 0x00000001; filtering is always enabled.
	FilteringOn bool `idl:"name:bFilteringOn" json:"filtering_on"`
	// dwLoggingLevel: This MUST be set to the logging levels so that if the RRAS server
	// has different levels of logging information this field specifies the logging level
	// and MUST be one of the following values.
	//
	//	+------------+--------------------------------------------+
	//	|            |                                            |
	//	|   VALUE    |                  MEANING                   |
	//	|            |                                            |
	//	+------------+--------------------------------------------+
	//	+------------+--------------------------------------------+
	//	| 0x00000000 | Log no messages.                           |
	//	+------------+--------------------------------------------+
	//	| 0x00000001 | Log all errors.                            |
	//	+------------+--------------------------------------------+
	//	| 0x00000002 | Log all warnings and errors.               |
	//	+------------+--------------------------------------------+
	//	| 0x00000003 | Log all errors, warnings, and information. |
	//	+------------+--------------------------------------------+
	//
	// When this structure is used, the InfoType of RTR_TOC_ENTRY (section 2.2.1.2.4) MUST
	// be 0xFFFF0003 or 0xFFFF000F to specify global IP filtering or global lPv6 filtering.
	LoggingLevel uint32 `idl:"name:dwLoggingLevel" json:"logging_level"`
}

func (o *GlobalInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *GlobalInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if !o.FilteringOn {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.LoggingLevel); err != nil {
		return err
	}
	return nil
}
func (o *GlobalInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	var _bFilteringOn int32
	if err := w.ReadData(&_bFilteringOn); err != nil {
		return err
	}
	o.FilteringOn = _bFilteringOn != 0
	if err := w.ReadData(&o.LoggingLevel); err != nil {
		return err
	}
	return nil
}

// InterfaceRouteInfo structure represents INTERFACE_ROUTE_INFO RPC structure.
//
// The INTERFACE_ROUTE_INFO structure MAY<25> be used or MIB_IPFORWARDROW (section 2.2.1.2.35)
// structure MAY<26> be used to specify the routes to be added or deleted on the RRAS
// server. Whenever this structure is used, the InfoType of RTR_TOC_ENTRY (section 2.2.1.2.4)
// structure MUST be 0xFFFF0005 to specify IP route information.<27>
//
// This structure is used in the following methods:
//
// * RRouterInterfaceTransportAdd (section 3.1.4.18) ( 927c5bf1-ac91-4325-b945-0d96a58f609b
// )
//
// * RRouterInterfaceTransportGetInfo (section 3.1.4.19) ( ec9ba293-45e9-4f12-b9af-7e77ec96c90e
// )
//
// * RRouterInterfaceTransportSetInfo (section 3.1.4.20) ( 209ba5e7-876e-4406-a05c-65b7e5fb2380
// )
//
// typedef struct _INTERFACE_ROUTE_INFO {
//
// union {
//
// struct {
//
// DWORD dwRtInfoDest;
//
// DWORD dwRtInfoMask;
//
// DWORD dwRtInfoPolicy;
//
// DWORD dwRtInfoNextHop;
//
// DWORD dwRtInfoAge;
//
// DWORD dwRtInfoNextHopAS;
//
// DWORD dwRtInfoMetric1;
//
// DWORD dwRtInfoMetric2;
//
// DWORD dwRtInfoMetric3;
//
// };
//
// struct {
//
// IN6_ADDR DestinationPrefix;
//
// DWORD DestPrefixLength;
//
// IN6_ADDR NextHopAddress;
//
// ULONG ValidLifeTime;
//
// DWORD Flags;
//
// ULONG Metric;
//
// };
//
// };
//
// DWORD dwRtInfoIfIndex;
//
// DWORD dwRtInfoType;
//
// DWORD dwRtInfoProto;
//
// DWORD dwRtInfoPreference;
//
// DWORD dwRtInfoViewSet;
//
// BOOL bV4;
//
// } INTERFACE_ROUTE_INFO,
type InterfaceRouteInfo struct {
	Field1 *InterfaceRouteInfo_Field1 `idl:"name:" json:""`
	// dwRtInfoIfIndex: This MUST be the index of the local interface through which the
	// next hop of this route is reachable.
	RTInfoInterfaceIndex uint32 `idl:"name:dwRtInfoIfIndex" json:"rt_info_interface_index"`
	// dwRtInfoType: This MUST be the route type as specified in [RFC1354].
	//
	// The following list shows the possible values for this member.<28>
	//
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	|                                      |                                                                                  |
	//	|                VALUE                 |                                     MEANING                                      |
	//	|                                      |                                                                                  |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| MIB_IPROUTE_TYPE_OTHER 0x00000001    | A type other than what is specified in [RFC1354].                                |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| MIB_IPROUTE_TYPE_INVALID 0x00000002  | An invalid route is logically deleted.                                           |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| MIB_IPROUTE_TYPE_DIRECT 0x00000003   | A local route where the next hop is the final destination (a local interface).   |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| MIB_IPROUTE_TYPE_INDIRECT 0x00000004 | The remote route where the next hop is not the final destination (a remote       |
	//	|                                      | destination).                                                                    |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	RTInfoType uint32 `idl:"name:dwRtInfoType" json:"rt_info_type"`
	// dwRtInfoProto: The protocol or routing mechanism that generated the route. It MUST
	// be one of the values specified in the MIB_IPFORWARD_PROTO enumeration.
	RTInfoProto uint32 `idl:"name:dwRtInfoProto" json:"rt_info_proto"`
	// dwRtInfoPreference: Specifies the route preference as determined by the routing protocol
	// in dwRtInfoProto.
	RTInfoPreference uint32 `idl:"name:dwRtInfoPreference" json:"rt_info_preference"`
	// dwRtInfoViewSet: Specifies the Route Information Table views. It MUST be a combination
	// of the following values, or a combination of RTM_VIEW_MASK_UCAST and RTM_VIEW_MASK_MCAST.
	//
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	|                                |                                                                                  |
	//	|             VALUE              |                                     MEANING                                      |
	//	|                                |                                                                                  |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	| RTM_VIEW_MASK_ANY 0x00000000   | This value is used to define or set the mask for the Route Information Table     |
	//	|                                | view. This value is a mask for any type of route.                                |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	| RTM_VIEW_MASK_UCAST 0x00000001 | This value is used to define or set the mask for Route Information Table view.   |
	//	|                                | This value is a mask for unicast routes.                                         |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	| RTM_VIEW_MASK_MCAST 0x00000002 | This value is used to define or set the mask for the Route Information Table     |
	//	|                                | view. This value is a mask for multicast routes.                                 |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	| RTM_VIEW_MASK_ALL 0xFFFFFFFF   | This value is used to define or set the mask for the Route Information Table     |
	//	|                                | view. This value is a mask for all types of routes.                              |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	RTInfoViewSet uint32 `idl:"name:dwRtInfoViewSet" json:"rt_info_view_set"`
	// bV4: Set to 1 if it is an IPV4 route; set to 0 to indicate an IPV6 route. For an
	// IPV4 route, the first structure in the union is used. For an IPV6 route, the second
	// structure in the union is used.
	V4 bool `idl:"name:bV4" json:"v4"`
}

func (o *InterfaceRouteInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *InterfaceRouteInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	// FIXME unknown type
	if err := w.WriteData(o.RTInfoInterfaceIndex); err != nil {
		return err
	}
	if err := w.WriteData(o.RTInfoType); err != nil {
		return err
	}
	if err := w.WriteData(o.RTInfoProto); err != nil {
		return err
	}
	if err := w.WriteData(o.RTInfoPreference); err != nil {
		return err
	}
	if err := w.WriteData(o.RTInfoViewSet); err != nil {
		return err
	}
	if !o.V4 {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	return nil
}
func (o *InterfaceRouteInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	// FIXME: unknown type
	if err := w.ReadData(&o.RTInfoInterfaceIndex); err != nil {
		return err
	}
	if err := w.ReadData(&o.RTInfoType); err != nil {
		return err
	}
	if err := w.ReadData(&o.RTInfoProto); err != nil {
		return err
	}
	if err := w.ReadData(&o.RTInfoPreference); err != nil {
		return err
	}
	if err := w.ReadData(&o.RTInfoViewSet); err != nil {
		return err
	}
	var _bV4 int32
	if err := w.ReadData(&_bV4); err != nil {
		return err
	}
	o.V4 = _bV4 != 0
	return nil
}

type InterfaceRouteInfo_Field1 struct {
	Field1 *InterfaceRouteInfo_Field1_Field1 `idl:"name:" json:""`
	Field2 *InterfaceRouteInfo_Field1_Field2 `idl:"name:" json:""`
}

// InterfaceRouteInfo_Field1_Field1 structure represents INTERFACE_ROUTE_INFO structure anonymous member.
//
// The INTERFACE_ROUTE_INFO structure MAY<25> be used or MIB_IPFORWARDROW (section 2.2.1.2.35)
// structure MAY<26> be used to specify the routes to be added or deleted on the RRAS
// server. Whenever this structure is used, the InfoType of RTR_TOC_ENTRY (section 2.2.1.2.4)
// structure MUST be 0xFFFF0005 to specify IP route information.<27>
//
// This structure is used in the following methods:
//
// * RRouterInterfaceTransportAdd (section 3.1.4.18) ( 927c5bf1-ac91-4325-b945-0d96a58f609b
// )
//
// * RRouterInterfaceTransportGetInfo (section 3.1.4.19) ( ec9ba293-45e9-4f12-b9af-7e77ec96c90e
// )
//
// * RRouterInterfaceTransportSetInfo (section 3.1.4.20) ( 209ba5e7-876e-4406-a05c-65b7e5fb2380
// )
//
// typedef struct _INTERFACE_ROUTE_INFO {
//
// union {
//
// struct {
//
// DWORD dwRtInfoDest;
//
// DWORD dwRtInfoMask;
//
// DWORD dwRtInfoPolicy;
//
// DWORD dwRtInfoNextHop;
//
// DWORD dwRtInfoAge;
//
// DWORD dwRtInfoNextHopAS;
//
// DWORD dwRtInfoMetric1;
//
// DWORD dwRtInfoMetric2;
//
// DWORD dwRtInfoMetric3;
//
// };
//
// struct {
//
// IN6_ADDR DestinationPrefix;
//
// DWORD DestPrefixLength;
//
// IN6_ADDR NextHopAddress;
//
// ULONG ValidLifeTime;
//
// DWORD Flags;
//
// ULONG Metric;
//
// };
//
// };
//
// DWORD dwRtInfoIfIndex;
//
// DWORD dwRtInfoType;
//
// DWORD dwRtInfoProto;
//
// DWORD dwRtInfoPreference;
//
// DWORD dwRtInfoViewSet;
//
// BOOL bV4;
//
// } INTERFACE_ROUTE_INFO,
type InterfaceRouteInfo_Field1_Field1 struct {
	// dwRtInfoDest: This MUST be the destination IPv4 address of the route. An entry with
	// an IPv4 address of 0.0.0.0 is considered a default route. This member cannot be set
	// to a multicast IPv4 address.
	RTInfoDestination uint32 `idl:"name:dwRtInfoDest" json:"rt_info_destination"`
	// dwRtInfoMask: This MUST be the IPv4 subnet mask to be logically ANDed with the destination
	// IPv4 address before being compared to the value in the dwRtInfoDest member. See [RFC950].
	RTInfoMask uint32 `idl:"name:dwRtInfoMask" json:"rt_info_mask"`
	// dwRtInfoPolicy: This MUST be set to the conditions that would cause the selection
	// of a multipath route (the set of next hops for a given destination). This member
	// is typically in IP TOS format. The encoding of this member is specified in [RFC1354].
	RTInfoPolicy uint32 `idl:"name:dwRtInfoPolicy" json:"rt_info_policy"`
	// dwRtInfoNextHop: This MUST be the IPv4 address of the next system in the route. Otherwise,
	// this member SHOULD be an IPv4 address of 0.0.0.0.
	RTInfoNextHop uint32 `idl:"name:dwRtInfoNextHop" json:"rt_info_next_hop"`
	// dwRtInfoAge: This MUST be the number of seconds since the route was added or modified
	// in the network routing table.
	RTInfoAge uint32 `idl:"name:dwRtInfoAge" json:"rt_info_age"`
	// dwRtInfoNextHopAS: This MUST be the autonomous system number of the next hop. When
	// this member is unknown or not relevant to the protocol or routing mechanism specified
	// in dwRtInfoProto, this value SHOULD be set to 0. This value is documented in [RFC1354].
	RTInfoNextHopAs uint32 `idl:"name:dwRtInfoNextHopAS" json:"rt_info_next_hop_as"`
	// dwRtInfoMetric1: This MUST be the primary routing metric value for this route. The
	// semantics of this metric are determined by the routing protocol specified in the
	// dwRtInfoProto member. If this metric is not used, its value SHOULD be set to -1.
	// This value is documented in [RFC1354].
	RTInfoMetric1 uint32 `idl:"name:dwRtInfoMetric1" json:"rt_info_metric1"`
	// dwRtInfoMetric2: This MUST be an alternate routing metric value for this route. The
	// semantics of this metric are determined by the routing protocol specified in the
	// dwRtInfoProto member. If this metric is not used, its value SHOULD be set to -1.
	// This value is documented in [RFC1354].
	RTInfoMetric2 uint32 `idl:"name:dwRtInfoMetric2" json:"rt_info_metric2"`
	// dwRtInfoMetric3: This MUST be an alternate routing metric value for this route. The
	// semantics of this metric are determined by the routing protocol specified in the
	// dwRtInfoProto member. If this metric is not used, its value SHOULD be set to -1.
	// This value is documented in [RFC1354].
	RTInfoMetric3 uint32 `idl:"name:dwRtInfoMetric3" json:"rt_info_metric3"`
}

func (o *InterfaceRouteInfo_Field1_Field1) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *InterfaceRouteInfo_Field1_Field1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.RTInfoDestination); err != nil {
		return err
	}
	if err := w.WriteData(o.RTInfoMask); err != nil {
		return err
	}
	if err := w.WriteData(o.RTInfoPolicy); err != nil {
		return err
	}
	if err := w.WriteData(o.RTInfoNextHop); err != nil {
		return err
	}
	if err := w.WriteData(o.RTInfoAge); err != nil {
		return err
	}
	if err := w.WriteData(o.RTInfoNextHopAs); err != nil {
		return err
	}
	if err := w.WriteData(o.RTInfoMetric1); err != nil {
		return err
	}
	if err := w.WriteData(o.RTInfoMetric2); err != nil {
		return err
	}
	if err := w.WriteData(o.RTInfoMetric3); err != nil {
		return err
	}
	return nil
}
func (o *InterfaceRouteInfo_Field1_Field1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.RTInfoDestination); err != nil {
		return err
	}
	if err := w.ReadData(&o.RTInfoMask); err != nil {
		return err
	}
	if err := w.ReadData(&o.RTInfoPolicy); err != nil {
		return err
	}
	if err := w.ReadData(&o.RTInfoNextHop); err != nil {
		return err
	}
	if err := w.ReadData(&o.RTInfoAge); err != nil {
		return err
	}
	if err := w.ReadData(&o.RTInfoNextHopAs); err != nil {
		return err
	}
	if err := w.ReadData(&o.RTInfoMetric1); err != nil {
		return err
	}
	if err := w.ReadData(&o.RTInfoMetric2); err != nil {
		return err
	}
	if err := w.ReadData(&o.RTInfoMetric3); err != nil {
		return err
	}
	return nil
}

// InterfaceRouteInfo_Field1_Field2 structure represents INTERFACE_ROUTE_INFO structure anonymous member.
//
// The INTERFACE_ROUTE_INFO structure MAY<25> be used or MIB_IPFORWARDROW (section 2.2.1.2.35)
// structure MAY<26> be used to specify the routes to be added or deleted on the RRAS
// server. Whenever this structure is used, the InfoType of RTR_TOC_ENTRY (section 2.2.1.2.4)
// structure MUST be 0xFFFF0005 to specify IP route information.<27>
//
// This structure is used in the following methods:
//
// * RRouterInterfaceTransportAdd (section 3.1.4.18) ( 927c5bf1-ac91-4325-b945-0d96a58f609b
// )
//
// * RRouterInterfaceTransportGetInfo (section 3.1.4.19) ( ec9ba293-45e9-4f12-b9af-7e77ec96c90e
// )
//
// * RRouterInterfaceTransportSetInfo (section 3.1.4.20) ( 209ba5e7-876e-4406-a05c-65b7e5fb2380
// )
//
// typedef struct _INTERFACE_ROUTE_INFO {
//
// union {
//
// struct {
//
// DWORD dwRtInfoDest;
//
// DWORD dwRtInfoMask;
//
// DWORD dwRtInfoPolicy;
//
// DWORD dwRtInfoNextHop;
//
// DWORD dwRtInfoAge;
//
// DWORD dwRtInfoNextHopAS;
//
// DWORD dwRtInfoMetric1;
//
// DWORD dwRtInfoMetric2;
//
// DWORD dwRtInfoMetric3;
//
// };
//
// struct {
//
// IN6_ADDR DestinationPrefix;
//
// DWORD DestPrefixLength;
//
// IN6_ADDR NextHopAddress;
//
// ULONG ValidLifeTime;
//
// DWORD Flags;
//
// ULONG Metric;
//
// };
//
// };
//
// DWORD dwRtInfoIfIndex;
//
// DWORD dwRtInfoType;
//
// DWORD dwRtInfoProto;
//
// DWORD dwRtInfoPreference;
//
// DWORD dwRtInfoViewSet;
//
// BOOL bV4;
//
// } INTERFACE_ROUTE_INFO,
type InterfaceRouteInfo_Field1_Field2 struct {
	// DestinationPrefix: This MUST be the IPv6 address prefix for the destination IP address
	// for this route.
	DestinationPrefix *IN6Addr `idl:"name:DestinationPrefix" json:"destination_prefix"`
	// DestPrefixLength: The length, in bits, of the site prefix or network part of the
	// IP address specified in DestinationPrefix. Any value greater than 128 is an illegal
	// value. A value of 255 is commonly used to represent an illegal value.
	DestinationPrefixLength uint32 `idl:"name:DestPrefixLength" json:"destination_prefix_length"`
	// NextHopAddress: This MUST be the IPv6 address of the next system or gateway for a
	// remote route. If the route is to a local loopback address or an IP address on the
	// local link, the next hop is unspecified (all zeros). For a local loopback route,
	// this member SHOULD be an IPv6 address of 0::0.
	NextHopAddress *IN6Addr `idl:"name:NextHopAddress" json:"next_hop_address"`
	// ValidLifeTime: The maximum time, in seconds, the IP route entry is valid. A value
	// of 0xFFFFFFFF is infinite.
	ValidLifeTime uint32 `idl:"name:ValidLifeTime" json:"valid_life_time"`
	// Flags: Reserved. This MUST be set to 0.
	Flags uint32 `idl:"name:Flags" json:"flags"`
	// Metric: The route metric offset for this IP route entry. The semantics of this metric
	// are determined by the routing protocol specified in dwRtInfoProto. If this metric
	// is not used, its value SHOULD be set to -1. This value is documented in [RFC4292].
	Metric uint32 `idl:"name:Metric" json:"metric"`
}

func (o *InterfaceRouteInfo_Field1_Field2) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *InterfaceRouteInfo_Field1_Field2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if o.DestinationPrefix != nil {
		if err := o.DestinationPrefix.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&IN6Addr{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.DestinationPrefixLength); err != nil {
		return err
	}
	if o.NextHopAddress != nil {
		if err := o.NextHopAddress.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&IN6Addr{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.ValidLifeTime); err != nil {
		return err
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	if err := w.WriteData(o.Metric); err != nil {
		return err
	}
	return nil
}
func (o *InterfaceRouteInfo_Field1_Field2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if o.DestinationPrefix == nil {
		o.DestinationPrefix = &IN6Addr{}
	}
	if err := o.DestinationPrefix.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.DestinationPrefixLength); err != nil {
		return err
	}
	if o.NextHopAddress == nil {
		o.NextHopAddress = &IN6Addr{}
	}
	if err := o.NextHopAddress.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.ValidLifeTime); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	if err := w.ReadData(&o.Metric); err != nil {
		return err
	}
	return nil
}

// ProtocolMetric structure represents PROTOCOL_METRIC RPC structure.
type ProtocolMetric struct {
	ProtocolID uint32 `idl:"name:dwProtocolId" json:"protocol_id"`
	Metric     uint32 `idl:"name:dwMetric" json:"metric"`
}

func (o *ProtocolMetric) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *ProtocolMetric) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.ProtocolID); err != nil {
		return err
	}
	if err := w.WriteData(o.Metric); err != nil {
		return err
	}
	return nil
}
func (o *ProtocolMetric) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.ProtocolID); err != nil {
		return err
	}
	if err := w.ReadData(&o.Metric); err != nil {
		return err
	}
	return nil
}

// PriorityInfo structure represents PRIORITY_INFO RPC structure.
//
// The PRIORITY_INFO structure MUST be used to set preferences to different protocols
// on the RRAS server.
//
// This structure is used in the following methods:
//
// * *RRouterInterfaceTransportSetGlobalInfo (section 3.1.4.10)* ( 071439e7-a9fd-40e4-91f7-ab756108e82f
// )
//
// * *RRouterInterfaceTransportGetGlobalInfo (section 3.1.4.11)* ( 14ad8d26-d7d7-48dd-914d-da962d5d7049
// )
//
// * *RRouterInterfaceTransportCreate (section 3.1.4.38)* ( 9829344c-f22b-4d53-946b-20542ec43be4
// )
//
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwNumProtocols                                                                                                                |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ppmProtocolMetric (variable)                                                                                                  |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
type PriorityInfo struct {
	// dwNumProtocols (4 bytes): This MUST be the number of protocols for which metric information
	// is given in the PROTOCOL_METRIC (section 2.2.1.2.13) structure.
	ProtocolsLength uint32 `idl:"name:dwNumProtocols" json:"protocols_length"`
	// ppmProtocolMetric (variable): This MUST be an array of PROTOCOL_METRIC structures
	// with dwNumProtocols specifying the number of elements in the array.
	//
	// When this structure is used, the InfoType of RTR_TOC_ENTRY (section 2.2.1.2.4) structure
	// MUST be 0xFFFF0006 to specify protocol priority information. Multiple instances of
	// this structure can be present. If multiple instances are present, and there are overlapping
	// protocol IDs, the metric specified in the last instance will be set.
	ProtocolMetric []*ProtocolMetric `idl:"name:ppmProtocolMetric" json:"protocol_metric"`
}

func (o *PriorityInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *PriorityInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.ProtocolsLength); err != nil {
		return err
	}
	for i1 := range o.ProtocolMetric {
		i1 := i1
		if uint64(i1) >= 1 {
			break
		}
		if o.ProtocolMetric[i1] != nil {
			if err := o.ProtocolMetric[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ProtocolMetric{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.ProtocolMetric); uint64(i1) < 1; i1++ {
		if err := (&ProtocolMetric{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *PriorityInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.ProtocolsLength); err != nil {
		return err
	}
	o.ProtocolMetric = make([]*ProtocolMetric, 1)
	for i1 := range o.ProtocolMetric {
		i1 := i1
		if o.ProtocolMetric[i1] == nil {
			o.ProtocolMetric[i1] = &ProtocolMetric{}
		}
		if err := o.ProtocolMetric[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// ProtocolMetricEx structure represents PROTOCOL_METRIC_EX RPC structure.
type ProtocolMetricEx struct {
	ProtocolID    uint32 `idl:"name:dwProtocolId" json:"protocol_id"`
	SubProtocolID uint32 `idl:"name:dwSubProtocolId" json:"sub_protocol_id"`
	Metric        uint32 `idl:"name:dwMetric" json:"metric"`
}

func (o *ProtocolMetricEx) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *ProtocolMetricEx) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.ProtocolID); err != nil {
		return err
	}
	if err := w.WriteData(o.SubProtocolID); err != nil {
		return err
	}
	if err := w.WriteData(o.Metric); err != nil {
		return err
	}
	return nil
}
func (o *ProtocolMetricEx) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.ProtocolID); err != nil {
		return err
	}
	if err := w.ReadData(&o.SubProtocolID); err != nil {
		return err
	}
	if err := w.ReadData(&o.Metric); err != nil {
		return err
	}
	return nil
}

// PriorityInfoEx structure represents PRIORITY_INFO_EX RPC structure.
//
// The PRIORITY_INFO_EX structure<195> is used to set preferences to different protocols
// on the RRAS server. This structure is used in the following methods:
//
// * *RRouterInterfaceTransportSetGlobalInfo (section 3.1.4.10)* ( 071439e7-a9fd-40e4-91f7-ab756108e82f
// )
//
// * *RRouterInterfaceTransportGetGlobalInfo (section 3.2.4.11)* ( bf82d259-06a7-4886-bb4e-9870d597eae9
// )
//
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwNumProtocols                                                                                                                |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ppmProtocolMetric (variable)                                                                                                  |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
type PriorityInfoEx struct {
	// dwNumProtocols (4 bytes): This MUST be the number of protocols for which metric information
	// is given in this structure PROTOCOL_METRIC_EX (section 2.2.1.2.267).
	ProtocolsLength uint32 `idl:"name:dwNumProtocols" json:"protocols_length"`
	// ppmProtocolMetric (variable): This MUST be an array of PROTOCOL_METRIC_EX structures
	// with dwNumProtocols specifying the number of elements in the array.
	//
	// When this structure is used, the InfoType of RTR_TOC_ENTRY (section 2.2.1.2.4) MUST
	// be 0xFFFF0017. Multiple instances of this structure can be present. If multiple instances
	// are present, and there are overlapping protocol IDs, the metric specified in the
	// last instance will be set.
	ProtocolMetric []*ProtocolMetricEx `idl:"name:ppmProtocolMetric" json:"protocol_metric"`
}

func (o *PriorityInfoEx) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *PriorityInfoEx) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.ProtocolsLength); err != nil {
		return err
	}
	for i1 := range o.ProtocolMetric {
		i1 := i1
		if uint64(i1) >= 1 {
			break
		}
		if o.ProtocolMetric[i1] != nil {
			if err := o.ProtocolMetric[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ProtocolMetricEx{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.ProtocolMetric); uint64(i1) < 1; i1++ {
		if err := (&ProtocolMetricEx{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *PriorityInfoEx) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.ProtocolsLength); err != nil {
		return err
	}
	o.ProtocolMetric = make([]*ProtocolMetricEx, 1)
	for i1 := range o.ProtocolMetric {
		i1 := i1
		if o.ProtocolMetric[i1] == nil {
			o.ProtocolMetric[i1] = &ProtocolMetricEx{}
		}
		if err := o.ProtocolMetric[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// RouterDiscInfo structure represents RTR_DISC_INFO RPC structure.
//
// The RTR_DISC_INFO structure is used to set and retrieve router discovery information
// according to [RFC1256].
//
// This structure is used in the following methods:
//
// * *RRouterInterfaceTransportSetInfo (section 3.1.4.20)* ( 209ba5e7-876e-4406-a05c-65b7e5fb2380
// )
//
// * *RRouterInterfaceTransportAdd (section 3.1.4.18)* ( 927c5bf1-ac91-4325-b945-0d96a58f609b
// )
//
// typedef struct _RTR_DISC_INFO {
//
// IN OUT WORD wMaxAdvtInterval;
//
// IN OUT WORD wMinAdvtInterval;
//
// IN OUT WORD wAdvtLifetime;
//
// IN OUT BOOL bAdvertise;
//
// IN OUT LONG lPrefLevel;
//
// } RTR_DISC_INFO,
type RouterDiscInfo struct {
	// wMaxAdvtInterval: This MUST be set to the maximum time allowed between sending multicast
	// Router Advertisements from the interface, in seconds. It MUST be no less than 4 seconds
	// and no greater than 1800 seconds.
	MaxAdvertiseInterval uint16 `idl:"name:wMaxAdvtInterval" json:"max_advertise_interval"`
	// wMinAdvtInterval: This MUST be the minimum time allowed between sending unsolicited
	// multicast Router Advertisements from the interface, in seconds. It MUST be no less
	// than 3 seconds and no greater than wMaxAdvtInterval.
	MinAdvertiseInterval uint16 `idl:"name:wMinAdvtInterval" json:"min_advertise_interval"`
	// wAdvtLifetime: This MUST be the value to be placed in the Lifetime field of Router
	// Advertisements sent from the interface, in seconds. It MUST be no less than wMaxAdvtInterval
	// and no greater than 9000 seconds.
	AdvertiseLifetime uint16 `idl:"name:wAdvtLifetime" json:"advertise_lifetime"`
	// bAdvertise: This MUST be the flag indicating whether or not the address is to be
	// advertised.
	Advertise bool `idl:"name:bAdvertise" json:"advertise"`
	// lPrefLevel: This MUST be the preference of the address as a default router address,
	// relative to other router addresses on the same subnet. A 32-bit, signed, twos complement
	// integer, with higher values meaning more preferable. The minimum value (0x80000000)
	// is used to indicate that the address, even if advertised, is not to be used by neighboring
	// hosts as a default router address.
	//
	// When this structure is used, the InfoType of RTR_TOC_ENTRY (section 2.2.1.2.4) MUST
	// be 0xFFFF0007 to specify router discovery information.
	PrefLevel int32 `idl:"name:lPrefLevel" json:"pref_level"`
}

func (o *RouterDiscInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *RouterDiscInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxAdvertiseInterval); err != nil {
		return err
	}
	if err := w.WriteData(o.MinAdvertiseInterval); err != nil {
		return err
	}
	if err := w.WriteData(o.AdvertiseLifetime); err != nil {
		return err
	}
	if !o.Advertise {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.PrefLevel); err != nil {
		return err
	}
	return nil
}
func (o *RouterDiscInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxAdvertiseInterval); err != nil {
		return err
	}
	if err := w.ReadData(&o.MinAdvertiseInterval); err != nil {
		return err
	}
	if err := w.ReadData(&o.AdvertiseLifetime); err != nil {
		return err
	}
	var _bAdvertise int32
	if err := w.ReadData(&_bAdvertise); err != nil {
		return err
	}
	o.Advertise = _bAdvertise != 0
	if err := w.ReadData(&o.PrefLevel); err != nil {
		return err
	}
	return nil
}

// MulticastHBeatInfo structure represents MCAST_HBEAT_INFO RPC structure.
//
// The MCAST_HBEAT_INFO is used for multicast heartbeat information. See [RFC1301] and
// [RFC3376] for more details.
type MulticastHBeatInfo struct {
	// pwszGroup: A null-terminated Unicode string that contains the name and address of
	// the multicast group.
	Group []uint16 `idl:"name:pwszGroup" json:"group"`
	// bActive: Indicates whether or not the heartbeat is active.
	Active bool `idl:"name:bActive" json:"active"`
	// ulDeadInterval: The dead interval in minutes.
	DeadInterval uint32 `idl:"name:ulDeadInterval" json:"dead_interval"`
	// byProtocol: Specifies how the heartbeat is being carried out. This MUST have one
	// of the following values.
	//
	//	+------------+----------------------------------------------------------------------------------+
	//	|            |                                                                                  |
	//	|   VALUE    |                                     MEANING                                      |
	//	|            |                                                                                  |
	//	+------------+----------------------------------------------------------------------------------+
	//	+------------+----------------------------------------------------------------------------------+
	//	| RAW (0xFF) | A non-UDP based protocol is specified for use as multicast heartbeat. wPort      |
	//	|            | specifies the identifier for the protocol.                                       |
	//	+------------+----------------------------------------------------------------------------------+
	//	| UDP (0x11) | UDP-based protocol is specified for use as multicast heartbeat. wPort specifies  |
	//	|            | the UDP port number.                                                             |
	//	+------------+----------------------------------------------------------------------------------+
	ByProtocol uint8 `idl:"name:byProtocol" json:"by_protocol"`
	// wPort: The port or protocol for which the heartbeat is being carried out.
	//
	// When this structure is used, the InfoType of RTR_TOC_ENTRY (section 2.2.1.2.4) MUST
	// be 0xFFFF000A to specify IP multicast heartbeat configuration.
	Port uint16 `idl:"name:wPort" json:"port"`
}

func (o *MulticastHBeatInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MulticastHBeatInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	for i1 := range o.Group {
		i1 := i1
		if uint64(i1) >= 64 {
			break
		}
		if err := w.WriteData(o.Group[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Group); uint64(i1) < 64; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	if !o.Active {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.DeadInterval); err != nil {
		return err
	}
	if err := w.WriteData(o.ByProtocol); err != nil {
		return err
	}
	if err := w.WriteData(o.Port); err != nil {
		return err
	}
	if err := w.WriteTrailingGap(4); err != nil {
		return err
	}
	return nil
}
func (o *MulticastHBeatInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	o.Group = make([]uint16, 64)
	for i1 := range o.Group {
		i1 := i1
		if err := w.ReadData(&o.Group[i1]); err != nil {
			return err
		}
	}
	var _bActive int32
	if err := w.ReadData(&_bActive); err != nil {
		return err
	}
	o.Active = _bActive != 0
	if err := w.ReadData(&o.DeadInterval); err != nil {
		return err
	}
	if err := w.ReadData(&o.ByProtocol); err != nil {
		return err
	}
	if err := w.ReadData(&o.Port); err != nil {
		return err
	}
	if err := w.ReadTrailingGap(4); err != nil {
		return err
	}
	return nil
}

// MIBMulticastLimitRow structure represents MIB_MCAST_LIMIT_ROW RPC structure.
//
// The MIB_MCAST_LIMIT_ROW structure is used to specify the configuration information
// for a multicast interface. It contains the configurable limit information from a
// corresponding MIB_IPMCAST_IF_ENTRY (section 2.2.1.2.40) structure. Whenever this
// structure is used, the InfoType of RTR_TOC_ENTRY (section 2.2.1.2.4) MUST be 0xFFFF000E
// to specify multicast configuration information.
//
// This structure is used in the following methods:
//
// * *RRouterInterfaceTransportAdd (section 3.1.4.18)* ( 927c5bf1-ac91-4325-b945-0d96a58f609b
// )
//
// * *RRouterInterfaceTransportGetInfo (section 3.1.4.19)* ( ec9ba293-45e9-4f12-b9af-7e77ec96c90e
// )
//
// * *RRouterInterfaceTransportSetInfo (section 3.1.4.20)* ( 209ba5e7-876e-4406-a05c-65b7e5fb2380
// )
//
// typedef struct {
//
// DWORD dwTtl;
//
// DWORD dwRateLimit;
//
// } MIB_MCAST_LIMIT_ROW,
type MIBMulticastLimitRow struct {
	// dwTtl: The Time to Live (TTL) value for a multicast interface.
	TTL uint32 `idl:"name:dwTtl" json:"ttl"`
	// dwRateLimit: The rate limit for a multicast interface. This MUST be set to 0.
	//
	// When this structure is used, the InfoType of RTR_TOC_ENTRY (section 2.2.1.2.4) MUST
	// be 0xFFFF000E to specify IP multicast configuration.
	RateLimit uint32 `idl:"name:dwRateLimit" json:"rate_limit"`
}

func (o *MIBMulticastLimitRow) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBMulticastLimitRow) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.TTL); err != nil {
		return err
	}
	if err := w.WriteData(o.RateLimit); err != nil {
		return err
	}
	return nil
}
func (o *MIBMulticastLimitRow) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.TTL); err != nil {
		return err
	}
	if err := w.ReadData(&o.RateLimit); err != nil {
		return err
	}
	return nil
}

// IPInIPConfigInfo structure represents IPINIP_CONFIG_INFO RPC structure.
//
// The IPINIP_CONFIG_INFO structure MAY<31> be used to specify configuration information
// for an IP in an IP tunnel.
type IPInIPConfigInfo struct {
	// dwRemoteAddress: The destination address of the IP in the IP packet.
	RemoteAddress uint32 `idl:"name:dwRemoteAddress" json:"remote_address"`
	// dwLocalAddress: The source address of the IP in the IP packet.
	LocalAddress uint32 `idl:"name:dwLocalAddress" json:"local_address"`
	// byTtl: The TTL field for the IP in the IP packet.
	//
	// When this structure is used, the InfoType of RTR_TOC_ENTRY (section 2.2.1.2.4) MUST
	// be 0xFFFF000C to specify IP in IP configuration information.
	ByTTL uint8 `idl:"name:byTtl" json:"by_ttl"`
}

func (o *IPInIPConfigInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPInIPConfigInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.RemoteAddress); err != nil {
		return err
	}
	if err := w.WriteData(o.LocalAddress); err != nil {
		return err
	}
	if err := w.WriteData(o.ByTTL); err != nil {
		return err
	}
	if err := w.WriteTrailingGap(4); err != nil {
		return err
	}
	return nil
}
func (o *IPInIPConfigInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.RemoteAddress); err != nil {
		return err
	}
	if err := w.ReadData(&o.LocalAddress); err != nil {
		return err
	}
	if err := w.ReadData(&o.ByTTL); err != nil {
		return err
	}
	if err := w.ReadTrailingGap(4); err != nil {
		return err
	}
	return nil
}

// InterfaceStatusInfo structure represents INTERFACE_STATUS_INFO RPC structure.
//
// The INTERFACE_STATUS_INFO structure contains the administrative status of an interface.
//
// This structure is used in the following methods:
//
// * *RRouterInterfaceTransportAdd (section 3.1.4.18)* ( 927c5bf1-ac91-4325-b945-0d96a58f609b
// )
//
// * *RRouterInterfaceTransportGetInfo (section 3.1.4.19)* ( ec9ba293-45e9-4f12-b9af-7e77ec96c90e
// )
//
// * *RRouterInterfaceTransportSetInfo (section 3.1.4.20)* ( 209ba5e7-876e-4406-a05c-65b7e5fb2380
// )
//
// typedef struct _INTERFACE_STATUS_INFO {
//
// IN OUT DWORD dwAdminStatus;
//
// } INTERFACE_STATUS_INFO,
type InterfaceStatusInfo struct {
	// dwAdminStatus: The administrative status of the interface. It MUST be one of the
	// following values.
	//
	//	+---------------------------------+----------------------------------------+
	//	|                                 |                                        |
	//	|              VALUE              |                MEANING                 |
	//	|                                 |                                        |
	//	+---------------------------------+----------------------------------------+
	//	+---------------------------------+----------------------------------------+
	//	| IF_ADMIN_STATUS_UP 0x00000001   | Interface is administratively enabled  |
	//	+---------------------------------+----------------------------------------+
	//	| IF_ADMIN_STATUS_DOWN 0x00000002 | Interface is administratively disabled |
	//	+---------------------------------+----------------------------------------+
	//
	// When this structure is used, the InfoType of RTR_TOC_ENTRY (section 2.2.1.2.4) MUST
	// be 0xFFFF0004 to specify IPv4 interface status information.
	AdminStatus uint32 `idl:"name:dwAdminStatus" json:"admin_status"`
}

func (o *InterfaceStatusInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *InterfaceStatusInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.AdminStatus); err != nil {
		return err
	}
	return nil
}
func (o *InterfaceStatusInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.AdminStatus); err != nil {
		return err
	}
	return nil
}

// MIBEntryContainer structure represents DIM_MIB_ENTRY_CONTAINER RPC structure.
//
// The DIM_MIB_ENTRY_CONTAINER structure contains the size and the data for the management
// information base (MIB) entries that are either set or retrieved from the MIB variables.
// This structure is used in the following methods:
//
// * *RMIBEntryCreate (section 3.1.4.27)* ( 4a8dc1a9-4b2a-4eba-bd0e-df9e8dc97908 )
//
// * *RMIBEntryDelete (section 3.1.4.28)* ( a8ed0e17-9395-4aef-9f4e-9b3e93cf3f4c )
//
// * *RMIBEntrySet (section 3.1.4.29)* ( 61ae7aea-8604-4bf3-8ae5-88542152cf8e )
//
// * *RMIBEntryGet (section 3.1.4.30)* ( ebc5c709-36d8-4520-a0ac-6f36d2d6c0b2 )
//
// * *RMIBEntryGetFirst (section 3.1.4.31)* ( 9102e585-2f62-4408-bfb6-02a6460cc883 )
//
// * *RMIBEntryGetNext (section 3.1.4.32)* ( 50f78033-d248-4272-b4b9-a2519a0f304d )
//
// typedef struct _DIM_MIB_ENTRY_CONTAINER
//
// {
//
// DWORD dwMibInEntrySize;
//
// [size_is(dwMibInEntrySize)] LPBYTE pMibInEntry;
//
// DWORD dwMibOutEntrySize;
//
// [size_is(dwMibOutEntrySize)] LPBYTE pMibOutEntry;
//
// } DIM_MIB_ENTRY_CONTAINER,
type MIBEntryContainer struct {
	// dwMibInEntrySize: This field gives the size of the MIB entry data being input. It
	// represents the size of the data contained in pMibInEntry.
	MIBInEntrySize uint32 `idl:"name:dwMibInEntrySize" json:"mib_in_entry_size"`
	// pMibInEntry: A pointer to a protocol-specific structure that contains input data.
	MIBInEntry []byte `idl:"name:pMibInEntry;size_is:(dwMibInEntrySize)" json:"mib_in_entry"`
	// dwMibOutEntrySize: This field gives the size of the MIB entry data being output.
	// It represents the size of the data contained in pMibOutEntry.
	MIBOutEntrySize uint32 `idl:"name:dwMibOutEntrySize" json:"mib_out_entry_size"`
	// pMibOutEntry: This member points to the protocol-specific structure that points to
	// the MIB.
	//
	// The contents of pMibInEntry and pMibOutEntry are based on the transport and the routing
	// protocol for which the MIB information is requested.
	//
	//	+---------------------+---------------------------------+--------------------------------------------------+---------------------------------------------------+
	//	|                     |             ROUTING             |                                                  |                                                   |
	//	|      TRANSPORT      |            PROTOCOL             |                   PMIBINENTRY                    |                   PMIBOUTENTRY                    |
	//	|                     |                                 |                                                  |                                                   |
	//	+---------------------+---------------------------------+--------------------------------------------------+---------------------------------------------------+
	//	+---------------------+---------------------------------+--------------------------------------------------+---------------------------------------------------+
	//	| PID_IP 0x00000021   | IPRTRMGR_PID 0x00002710         | MIB_OPAQUE_QUERY (section 2.2.1.2.53)            | MIB_OPAQUE_QUERY (section 2.2.1.2.53)             |
	//	+---------------------+---------------------------------+--------------------------------------------------+---------------------------------------------------+
	//	| PID_IP 0x00000021   | MS_IP_BOOTP 0x0000270F          | IPBOOT_MIB_GET_INPUT_DATA (section 2.2.1.2.151)  | IPBOOTP_MIB_GET_OUTPUT_DATA (section 2.2.1.2.152) |
	//	+---------------------+---------------------------------+--------------------------------------------------+---------------------------------------------------+
	//	| PID_IP 0x00000021   | MS_IP_NAT 0x81372715            | IP_NAT_MIB_QUERY (section 2.2.1.2.182)           | IP_NAT_MIB_QUERY (section 2.2.1.2.182)            |
	//	+---------------------+---------------------------------+--------------------------------------------------+---------------------------------------------------+
	//	| PID_IP 0x00000021   | MS_IP_DNS_PROXY 0x81372713      | IP_DNS_PROXY_MIB_QUERY (section 2.2.1.2.186)     | IP_DNS_PROXY_MIB_QUERY (section 2.2.1.2.186)      |
	//	+---------------------+---------------------------------+--------------------------------------------------+---------------------------------------------------+
	//	| PID_IP 0x00000021   | MS_IP_DHCP_ALLOCATOR 0x81372714 | IP_AUTO_DHCP_MIB_QUERY (section 2.2.1.2.188)     | IP_AUTO_DHCP_MIB_QUERY (section 2.2.1.2.188)      |
	//	+---------------------+---------------------------------+--------------------------------------------------+---------------------------------------------------+
	//	| PID_IP 0x00000021   | MS_IP_OSPF 0x0000000D           | MIB_DA_MSG (section 2.2.1.2.190)                 | MIB_DA_MSG (section 2.2.1.2.190)                  |
	//	+---------------------+---------------------------------+--------------------------------------------------+---------------------------------------------------+
	//	| PID_IP 0x00000021   | MS_IP_RIP 0x00000008            | IPRIP_MIB_GET_INPUT_DATA (section 2.2.1.2.161)   | IPRIP_MIB_GET_OUTPUT_DATA (section 2.2.1.2.162)   |
	//	+---------------------+---------------------------------+--------------------------------------------------+---------------------------------------------------+
	//	| PID_IP 0x00000021   | MS_IP_IGMP 0x4137000A           | IGMP_MIB_GET_INPUT_DATA (section 2.2.1.2.171)    | IGMP_MIB_GET_OUTPUT_DATA (section 2.2.1.2.172)    |
	//	+---------------------+---------------------------------+--------------------------------------------------+---------------------------------------------------+
	//	| PID_IPV6 0x00000057 | MS_IPV6_DHCP 0x000003E7         | DHCPV6R_MIB_GET_INPUT_DATA (section 2.2.1.2.160) | DHCPV6R_MIB_GET_OUTPUT_DATA (section 2.2.1.2.156) |
	//	+---------------------+---------------------------------+--------------------------------------------------+---------------------------------------------------+
	//	| PID_IPV6 0x00000057 | IPRTRMGR_PID 0x00002710         | MIB_OPAQUE_QUERY (section 2.2.1.2.53)            | MIB_OPAQUE_QUERY (section 2.2.1.2.53)             |
	//	+---------------------+---------------------------------+--------------------------------------------------+---------------------------------------------------+
	//	| PID_IPX 0x0000002B  | IPX_PROTOCOL_BASE 0x0001FFFF    | IPX_MIB_GET_INPUT_DATA (section 2.2.1.2.105)     | IPX_MIB_GET_INPUT_DATA (section 2.2.1.2.105)      |
	//	+---------------------+---------------------------------+--------------------------------------------------+---------------------------------------------------+
	//	| PID_IPX 0x0000002B  | IPX_PROTOCOL_RIP 0x00020000     | RIP_MIB_GET_INPUT_DATA (section 2.2.1.2.125)     | RIP_MIB_GET_INPUT_DATA (section 2.2.1.2.125)      |
	//	+---------------------+---------------------------------+--------------------------------------------------+---------------------------------------------------+
	//	| PID_IPX 0x0000002B  | IPX_PROTOCOL_SAP 0x00020000     | SAP_MIB_GET_INPUT_DATA (section 2.2.1.2.118)     | SAP_MIB_GET_INPUT_DATA (section 2.2.1.2.118)      |
	//	+---------------------+---------------------------------+--------------------------------------------------+---------------------------------------------------+
	MIBOutEntry []byte `idl:"name:pMibOutEntry;size_is:(dwMibOutEntrySize)" json:"mib_out_entry"`
}

func (o *MIBEntryContainer) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if o.MIBInEntry != nil && o.MIBInEntrySize == 0 {
		o.MIBInEntrySize = uint32(len(o.MIBInEntry))
	}
	if o.MIBOutEntry != nil && o.MIBOutEntrySize == 0 {
		o.MIBOutEntrySize = uint32(len(o.MIBOutEntry))
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBEntryContainer) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.MIBInEntrySize); err != nil {
		return err
	}
	if o.MIBInEntry != nil || o.MIBInEntrySize > 0 {
		_ptr_pMibInEntry := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.MIBInEntrySize)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.MIBInEntry {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.MIBInEntry[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.MIBInEntry); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.MIBInEntry, _ptr_pMibInEntry); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.MIBOutEntrySize); err != nil {
		return err
	}
	if o.MIBOutEntry != nil || o.MIBOutEntrySize > 0 {
		_ptr_pMibOutEntry := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.MIBOutEntrySize)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.MIBOutEntry {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.MIBOutEntry[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.MIBOutEntry); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.MIBOutEntry, _ptr_pMibOutEntry); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MIBEntryContainer) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.MIBInEntrySize); err != nil {
		return err
	}
	_ptr_pMibInEntry := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.MIBInEntrySize > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.MIBInEntrySize)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.MIBInEntry", sizeInfo[0])
		}
		o.MIBInEntry = make([]byte, sizeInfo[0])
		for i1 := range o.MIBInEntry {
			i1 := i1
			if err := w.ReadData(&o.MIBInEntry[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_pMibInEntry := func(ptr interface{}) { o.MIBInEntry = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.MIBInEntry, _s_pMibInEntry, _ptr_pMibInEntry); err != nil {
		return err
	}
	if err := w.ReadData(&o.MIBOutEntrySize); err != nil {
		return err
	}
	_ptr_pMibOutEntry := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.MIBOutEntrySize > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.MIBOutEntrySize)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.MIBOutEntry", sizeInfo[0])
		}
		o.MIBOutEntry = make([]byte, sizeInfo[0])
		for i1 := range o.MIBOutEntry {
			i1 := i1
			if err := w.ReadData(&o.MIBOutEntry[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_pMibOutEntry := func(ptr interface{}) { o.MIBOutEntry = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.MIBOutEntry, _s_pMibOutEntry, _ptr_pMibOutEntry); err != nil {
		return err
	}
	return nil
}

// MIBIPForwardRow structure represents MIB_IPFORWARDROW RPC structure.
//
// The MIB_IPFORWARDROW structure contains information that describes an IPv4 network
// route. This structure is used in the following methods:
//
// * *MIB_OPAQUE_INFO* (section 2.2.1.2.52 ( 169e435d-a975-4c1c-bf41-55fd2bd76125 )
// )
//
// * *MIB_IPDESTROW (section 2.2.1.2.20)* ( 3e73e08b-3421-4875-a433-a1279deeefe7 )
//
// * *MIB_IPFORWARDTABLE (section 2.2.1.2.36)* ( 538d5740-fa34-4b20-bdc6-2946b36a055a
// )
//
// typedef struct _MIB_IPFORWARDROW
//
// {
//
// DWORD dwForwardDest;
//
// DWORD dwForwardMask;
//
// DWORD dwForwardPolicy;
//
// DWORD dwForwardNextHop;
//
// DWORD dwForwardIfIndex;
//
// union {
//
// DWORD dwForwardType;
//
// MIB_IPFORWARD_TYPE ForwardType;
//
// };
//
// union {
//
// DWORD dwForwardProto;
//
// MIB_IPFORWARD_PROTO ForwardProto;
//
// };
//
// DWORD dwForwardAge;
//
// DWORD dwForwardNextHopAS;
//
// DWORD dwForwardMetric1;
//
// DWORD dwForwardMetric2;
//
// DWORD dwForwardMetric3;
//
// DWORD dwForwardMetric4;
//
// DWORD dwForwardMetric5;
//
// } MIB_IPFORWARDROW,
type MIBIPForwardRow struct {
	// dwForwardDest: The destination IPv4 address of the route. An entry with an IPv4 address
	// of 0.0.0.0 is considered a default route. This member MUST NOT be set to a multicast
	// (class D) IPv4 address.
	ForwardDestination uint32 `idl:"name:dwForwardDest" json:"forward_destination"`
	// dwForwardMask: The IPv4 subnet mask to be logically ANDed with the destination IPv4
	// address before being compared to the value in the dwForwardDest member; see [RFC950].
	ForwardMask uint32 `idl:"name:dwForwardMask" json:"forward_mask"`
	// dwForwardPolicy: The set of conditions that would cause the selection of a multipath
	// route (the set of next hops for a given destination). This member is typically in
	// IP TOS format. The encoding of this member is specified in [RFC1354].
	ForwardPolicy uint32 `idl:"name:dwForwardPolicy" json:"forward_policy"`
	// dwForwardNextHop: For remote routes, the IPv4 address of the next system in the route.
	// Otherwise, this member SHOULD be an IPv4 address of 0x00000000.
	ForwardNextHop uint32 `idl:"name:dwForwardNextHop" json:"forward_next_hop"`
	// dwForwardIfIndex: The index of the local interface through which the next hop of
	// this route is reachable. This MUST be an interface index of one of the interfaces
	// on RRAS.
	ForwardInterfaceIndex uint32 `idl:"name:dwForwardIfIndex" json:"forward_interface_index"`
	// ForwardType: The route type as specified in [RFC1354].<34>
	ForwardType MIBIPForwardType `idl:"name:ForwardType" json:"forward_type"`
	// ForwardProto: The protocol or routing mechanism that generated the route.<35>
	ForwardProto MIBIPForwardProto `idl:"name:ForwardProto" json:"forward_proto"`
	// dwForwardAge: The number of seconds since the route was added or modified in the
	// network routing table. The dwForwardAge member is also used if the RRAS server is
	// running for routes of type PROTO_IP_NETMGMT as defined on the Protocol Identifiers
	// reference page. When dwForwardAge is set to INFINITE (-1) when running the RRAS server,
	// the route will not be removed based on a time-out value.
	ForwardAge uint32 `idl:"name:dwForwardAge" json:"forward_age"`
	// dwForwardNextHopAS: The autonomous system number of the next hop. When this member
	// is unknown or not relevant to the protocol or routing mechanism specified in dwForwardProto,
	// this value SHOULD be set to 0. This value is documented in [RFC1354].
	ForwardNextHopAs uint32 `idl:"name:dwForwardNextHopAS" json:"forward_next_hop_as"`
	// dwForwardMetric1: The primary routing metric value for this route. The semantics
	// of this metric are determined by the routing protocol specified in the dwForwardProto
	// member. If this metric is not used, its value SHOULD be set to MIB_IPROUTE_METRIC_UNUSED
	// (-1). This value is documented in [RFC1354].
	ForwardMetric1 uint32 `idl:"name:dwForwardMetric1" json:"forward_metric1"`
	// dwForwardMetric2: An alternate routing metric value for this route. The semantics
	// of this metric are determined by the routing protocol specified in the dwForwardProto
	// member. If this metric is not used, its value SHOULD be set to -1. This value is
	// documented in [RFC1354].
	ForwardMetric2 uint32 `idl:"name:dwForwardMetric2" json:"forward_metric2"`
	// dwForwardMetric3: An alternate routing metric value for this route. The semantics
	// of this metric are determined by the routing protocol specified in the dwForwardProto
	// member. If this metric is not used, its value SHOULD be set to -1. This value is
	// documented in [RFC1354].
	ForwardMetric3 uint32 `idl:"name:dwForwardMetric3" json:"forward_metric3"`
	// dwForwardMetric4: An alternate routing metric value for this route. The semantics
	// of this metric are determined by the routing protocol specified in the dwForwardProto
	// member. If this metric is not used, its value SHOULD be set to -1. This value is
	// documented in [RFC1354].
	ForwardMetric4 uint32 `idl:"name:dwForwardMetric4" json:"forward_metric4"`
	// dwForwardMetric5: An alternate routing metric value for this route. The semantics
	// of this metric are determined by the routing protocol specified in the dwForwardProto
	// member. If this metric is not used, its value SHOULD be set to -1. This value is
	// documented in [RFC1354].
	ForwardMetric5 uint32 `idl:"name:dwForwardMetric5" json:"forward_metric5"`
}

func (o *MIBIPForwardRow) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBIPForwardRow) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.ForwardDestination); err != nil {
		return err
	}
	if err := w.WriteData(o.ForwardMask); err != nil {
		return err
	}
	if err := w.WriteData(o.ForwardPolicy); err != nil {
		return err
	}
	if err := w.WriteData(o.ForwardNextHop); err != nil {
		return err
	}
	if err := w.WriteData(o.ForwardInterfaceIndex); err != nil {
		return err
	}
	if err := w.WriteEnum(uint16(o.ForwardType)); err != nil {
		return err
	}
	if err := w.WriteEnum(uint16(o.ForwardProto)); err != nil {
		return err
	}
	if err := w.WriteData(o.ForwardAge); err != nil {
		return err
	}
	if err := w.WriteData(o.ForwardNextHopAs); err != nil {
		return err
	}
	if err := w.WriteData(o.ForwardMetric1); err != nil {
		return err
	}
	if err := w.WriteData(o.ForwardMetric2); err != nil {
		return err
	}
	if err := w.WriteData(o.ForwardMetric3); err != nil {
		return err
	}
	if err := w.WriteData(o.ForwardMetric4); err != nil {
		return err
	}
	if err := w.WriteData(o.ForwardMetric5); err != nil {
		return err
	}
	return nil
}
func (o *MIBIPForwardRow) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.ForwardDestination); err != nil {
		return err
	}
	if err := w.ReadData(&o.ForwardMask); err != nil {
		return err
	}
	if err := w.ReadData(&o.ForwardPolicy); err != nil {
		return err
	}
	if err := w.ReadData(&o.ForwardNextHop); err != nil {
		return err
	}
	if err := w.ReadData(&o.ForwardInterfaceIndex); err != nil {
		return err
	}
	if err := w.ReadEnum((*uint16)(&o.ForwardType)); err != nil {
		return err
	}
	if err := w.ReadEnum((*uint16)(&o.ForwardProto)); err != nil {
		return err
	}
	if err := w.ReadData(&o.ForwardAge); err != nil {
		return err
	}
	if err := w.ReadData(&o.ForwardNextHopAs); err != nil {
		return err
	}
	if err := w.ReadData(&o.ForwardMetric1); err != nil {
		return err
	}
	if err := w.ReadData(&o.ForwardMetric2); err != nil {
		return err
	}
	if err := w.ReadData(&o.ForwardMetric3); err != nil {
		return err
	}
	if err := w.ReadData(&o.ForwardMetric4); err != nil {
		return err
	}
	if err := w.ReadData(&o.ForwardMetric5); err != nil {
		return err
	}
	return nil
}

// MIBIPDestinationRow structure represents MIB_IPDESTROW RPC structure.
//
// The MIB_IPDESTROW structure contains information about how a destination can be reached.
// In addition to the route information, this structure contains preference and view
// information. This structure is used in MIB_OPAQUE_INFO (section 2.2.1.2.52) structure.
type MIBIPDestinationRow struct {
	// ForwardRow: Contains the MIB_IPFORWARDROW (section 2.2.1.2.35) structure that contains
	// the route information.
	ForwardRow *MIBIPForwardRow `idl:"name:ForwardRow" json:"forward_row"`
	// dwForwardPreference: This MUST be the preference value of the ForwardRow. While routing
	// packets for two routes, if the prefix length is the same, the packet with the lower
	// dwForwardPreference is chosen.
	ForwardPreference uint32 `idl:"name:dwForwardPreference" json:"forward_preference"`
	// dwForwardViewSet: This MUST be the view information of the ForwardRow. This member
	// describes the type of route, for example a multicast route. For more information,
	// see the dwRtInfoViewSet member of INTERFACE_ROUTE_INFO (section 2.2.1.2.11).
	ForwardViewSet uint32 `idl:"name:dwForwardViewSet" json:"forward_view_set"`
}

func (o *MIBIPDestinationRow) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBIPDestinationRow) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if o.ForwardRow != nil {
		if err := o.ForwardRow.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MIBIPForwardRow{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.ForwardPreference); err != nil {
		return err
	}
	if err := w.WriteData(o.ForwardViewSet); err != nil {
		return err
	}
	return nil
}
func (o *MIBIPDestinationRow) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if o.ForwardRow == nil {
		o.ForwardRow = &MIBIPForwardRow{}
	}
	if err := o.ForwardRow.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.ForwardPreference); err != nil {
		return err
	}
	if err := w.ReadData(&o.ForwardViewSet); err != nil {
		return err
	}
	return nil
}

// MIBIPDestinationTable structure represents MIB_IPDESTTABLE RPC structure.
//
// The MIB_IPDESTTABLE structure contains a table of MIB_IPDESTROW (section 2.2.1.2.20)
// structures that contains the interface entries.
//
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwNumEntries                                                                                                                  |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| table (variable)                                                                                                              |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
type MIBIPDestinationTable struct {
	// dwNumEntries (4 bytes): The number of interface entries in the table.
	EntriesLength uint32 `idl:"name:dwNumEntries" json:"entries_length"`
	// table (variable): An array of MIB_IPDESTROW structures that contains the interface
	// entries.
	Table []*MIBIPDestinationRow `idl:"name:table" json:"table"`
}

func (o *MIBIPDestinationTable) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBIPDestinationTable) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.EntriesLength); err != nil {
		return err
	}
	for i1 := range o.Table {
		i1 := i1
		if uint64(i1) >= 1 {
			break
		}
		if o.Table[i1] != nil {
			if err := o.Table[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MIBIPDestinationRow{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.Table); uint64(i1) < 1; i1++ {
		if err := (&MIBIPDestinationRow{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MIBIPDestinationTable) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntriesLength); err != nil {
		return err
	}
	o.Table = make([]*MIBIPDestinationRow, 1)
	for i1 := range o.Table {
		i1 := i1
		if o.Table[i1] == nil {
			o.Table[i1] = &MIBIPDestinationRow{}
		}
		if err := o.Table[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// MIBRouteState structure represents MIB_ROUTESTATE RPC structure.
//
// The MIB_ROUTESTATE structure contains information as to whether the route needs to
// be added to the forwarder or not. Typically, only the best routes are added to the
// forwarder.
type MIBRouteState struct {
	// bRoutesSetToStack: This MUST be set to 0x00000001 to set routes to the forwarder.
	RoutesSetToStack bool `idl:"name:bRoutesSetToStack" json:"routes_set_to_stack"`
}

func (o *MIBRouteState) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBRouteState) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if !o.RoutesSetToStack {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	return nil
}
func (o *MIBRouteState) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	var _bRoutesSetToStack int32
	if err := w.ReadData(&_bRoutesSetToStack); err != nil {
		return err
	}
	o.RoutesSetToStack = _bRoutesSetToStack != 0
	return nil
}

// MIBBestInterface structure represents MIB_BEST_IF RPC structure.
//
// The MIB_BEST_IF structure stores the index of the interface that has the best route
// to a specific destination IPv4 address.
type MIBBestInterface struct {
	// dwDestAddr: Specifies the IPv4 address of the destination address.
	DestinationAddr uint32 `idl:"name:dwDestAddr" json:"destination_addr"`
	// dwIfIndex: Specifies the index of the interface that has the best route to the destination
	// address specified by the dwDestAddr member.
	InterfaceIndex uint32 `idl:"name:dwIfIndex" json:"interface_index"`
}

func (o *MIBBestInterface) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBBestInterface) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.DestinationAddr); err != nil {
		return err
	}
	if err := w.WriteData(o.InterfaceIndex); err != nil {
		return err
	}
	return nil
}
func (o *MIBBestInterface) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.DestinationAddr); err != nil {
		return err
	}
	if err := w.ReadData(&o.InterfaceIndex); err != nil {
		return err
	}
	return nil
}

// MIBBoundaryrow structure represents MIB_BOUNDARYROW RPC structure.
//
// The MIB_BOUNDARYROW structure contains the IPv4 group address value and mask for
// a multicast boundary. Whenever this structure is used, the InfoType of RTR_TOC_ENTRY
// (section 2.2.1.2.4) MUST be 0xFFFF000B to specify multicast boundary information.
//
// This structure is used in MIB_OPAQUE_INFO (section 2.2.1.2.52) structure.
//
// This structure is used in the following methods:
//
// * *RRouterInterfaceTransportAdd (section 3.1.4.18)* ( 927c5bf1-ac91-4325-b945-0d96a58f609b
// )
//
// * *RRouterInterfaceTransportSetInfo (section 3.1.4.20)* ( 209ba5e7-876e-4406-a05c-65b7e5fb2380
// )
//
// * *RRouterInterfaceTransportGetInfo (section 3.1.4.19)* ( ec9ba293-45e9-4f12-b9af-7e77ec96c90e
// )
//
// typedef struct {
//
// DWORD dwGroupAddress;
//
// DWORD dwGroupMask;
//
// } MIB_BOUNDARYROW,
type MIBBoundaryrow struct {
	// dwGroupAddress: The 32-bit integer representation of the IPv4 group address which,
	// when combined with the corresponding value in dwGroupMask, identifies the group range
	// for which the scoped boundary exists.
	//
	// Note  Scoped addresses MUST come from the range 239.*.*.* as specified in [RFC2365].
	GroupAddress uint32 `idl:"name:dwGroupAddress" json:"group_address"`
	// dwGroupMask: The 32-bit integer representation of the IPv4 group address mask which,
	// when combined with the corresponding value in dwGroupAddress, identifies the group
	// range for which the scoped boundary exists.
	GroupMask uint32 `idl:"name:dwGroupMask" json:"group_mask"`
}

func (o *MIBBoundaryrow) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBBoundaryrow) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.GroupAddress); err != nil {
		return err
	}
	if err := w.WriteData(o.GroupMask); err != nil {
		return err
	}
	return nil
}
func (o *MIBBoundaryrow) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.GroupAddress); err != nil {
		return err
	}
	if err := w.ReadData(&o.GroupMask); err != nil {
		return err
	}
	return nil
}

// MIBICMPStats structure represents MIBICMPSTATS RPC structure.
//
// The MIBICMPSTATS structure contains statistics for the ICMP messages on a specific
// computer. This structure is used in MIBICMPINFO (section 2.2.1.2.26).
type MIBICMPStats struct {
	// dwMsgs: The number of ICMP messages received or sent.
	Msgs uint32 `idl:"name:dwMsgs" json:"msgs"`
	// dwErrors: The number of errors that occurred while sending or receiving ICMP messages.
	Errors uint32 `idl:"name:dwErrors" json:"errors"`
	// dwDestUnreachs: The number of destination-unreachable messages received or sent.
	// A destination-unreachable message is sent to the originating computer when the destination
	// address in a datagram cannot be reached.
	DestinationUnreachs uint32 `idl:"name:dwDestUnreachs" json:"destination_unreachs"`
	// dwTimeExcds: The number of TTL-exceeded messages received or sent. A TTL-exceeded
	// message is sent to the originating computer when a datagram is discarded because
	// the number of routers it has passed through exceeds its TTL value.
	TimeExcds uint32 `idl:"name:dwTimeExcds" json:"time_excds"`
	// dwParmProbs: The number of parameter-problem messages received or sent. A parameter-problem
	// message is sent to the originating computer when a router or host detects an error
	// in a datagram's IP header.
	ParameterProbs uint32 `idl:"name:dwParmProbs" json:"parameter_probs"`
	// dwSrcQuenchs: The number of source quench messages received or sent. A source quench
	// request is sent to a computer to request that it reduce its rate of packet transmission.
	SourceQuenchs uint32 `idl:"name:dwSrcQuenchs" json:"source_quenchs"`
	// dwRedirects: The number of redirect messages received or sent. A redirect message
	// is sent to the originating computer when a better route is discovered for a datagram
	// sent by that computer.
	Redirects uint32 `idl:"name:dwRedirects" json:"redirects"`
	// dwEchos: The number of echo requests received or sent. An echo request causes the
	// receiving computer to send an echo reply message back to the originating computer.
	Echos uint32 `idl:"name:dwEchos" json:"echos"`
	// dwEchoReps: The number of echo replies received or sent. A computer sends an echo
	// reply in response to receiving an echo request message.
	EchoReps uint32 `idl:"name:dwEchoReps" json:"echo_reps"`
	// dwTimestamps: The number of time stamp requests received or sent. A time stamp request
	// causes the receiving computer to send a time stamp reply back to the originating
	// computer.
	Timestamps uint32 `idl:"name:dwTimestamps" json:"timestamps"`
	// dwTimestampReps: The number of time stamp replies received or sent. A computer sends
	// a time stamp reply in response to having received a time stamp request. Routers can
	// use time stamp requests and replies to measure the transmission speed of datagrams
	// on a network.
	TimestampReps uint32 `idl:"name:dwTimestampReps" json:"timestamp_reps"`
	// dwAddrMasks: The number of address mask requests received or sent. A computer sends
	// an address mask request to determine the number of bits in the subnet mask for its
	// local subnet.
	AddrMasks uint32 `idl:"name:dwAddrMasks" json:"addr_masks"`
	// dwAddrMaskReps: The number of address mask responses received or sent. A computer
	// sends an address mask response in response to an address mask request.
	AddrMaskReps uint32 `idl:"name:dwAddrMaskReps" json:"addr_mask_reps"`
}

func (o *MIBICMPStats) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBICMPStats) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Msgs); err != nil {
		return err
	}
	if err := w.WriteData(o.Errors); err != nil {
		return err
	}
	if err := w.WriteData(o.DestinationUnreachs); err != nil {
		return err
	}
	if err := w.WriteData(o.TimeExcds); err != nil {
		return err
	}
	if err := w.WriteData(o.ParameterProbs); err != nil {
		return err
	}
	if err := w.WriteData(o.SourceQuenchs); err != nil {
		return err
	}
	if err := w.WriteData(o.Redirects); err != nil {
		return err
	}
	if err := w.WriteData(o.Echos); err != nil {
		return err
	}
	if err := w.WriteData(o.EchoReps); err != nil {
		return err
	}
	if err := w.WriteData(o.Timestamps); err != nil {
		return err
	}
	if err := w.WriteData(o.TimestampReps); err != nil {
		return err
	}
	if err := w.WriteData(o.AddrMasks); err != nil {
		return err
	}
	if err := w.WriteData(o.AddrMaskReps); err != nil {
		return err
	}
	return nil
}
func (o *MIBICMPStats) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Msgs); err != nil {
		return err
	}
	if err := w.ReadData(&o.Errors); err != nil {
		return err
	}
	if err := w.ReadData(&o.DestinationUnreachs); err != nil {
		return err
	}
	if err := w.ReadData(&o.TimeExcds); err != nil {
		return err
	}
	if err := w.ReadData(&o.ParameterProbs); err != nil {
		return err
	}
	if err := w.ReadData(&o.SourceQuenchs); err != nil {
		return err
	}
	if err := w.ReadData(&o.Redirects); err != nil {
		return err
	}
	if err := w.ReadData(&o.Echos); err != nil {
		return err
	}
	if err := w.ReadData(&o.EchoReps); err != nil {
		return err
	}
	if err := w.ReadData(&o.Timestamps); err != nil {
		return err
	}
	if err := w.ReadData(&o.TimestampReps); err != nil {
		return err
	}
	if err := w.ReadData(&o.AddrMasks); err != nil {
		return err
	}
	if err := w.ReadData(&o.AddrMaskReps); err != nil {
		return err
	}
	return nil
}

// MIBICMPInfo structure represents MIBICMPINFO RPC structure.
//
// The MIBICMPINFO structure that contains the incoming and outgoing statistics for
// the ICMP.
//
// This structure is used in MIB_ICMP (section 2.2.1.2.25) structure.
type MIBICMPInfo struct {
	// icmpInStats: An MIBICMPSTATS (section 2.2.1.2.27) structure that contains the statistics
	// for incoming ICMP messages.
	ICMPInStats *MIBICMPStats `idl:"name:icmpInStats" json:"icmp_in_stats"`
	// icmpOutStats: An MIBICMPSTATS structure that contains the statistics for outgoing
	// ICMP messages.
	ICMPOutStats *MIBICMPStats `idl:"name:icmpOutStats" json:"icmp_out_stats"`
}

func (o *MIBICMPInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBICMPInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if o.ICMPInStats != nil {
		if err := o.ICMPInStats.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MIBICMPStats{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.ICMPOutStats != nil {
		if err := o.ICMPOutStats.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MIBICMPStats{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MIBICMPInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if o.ICMPInStats == nil {
		o.ICMPInStats = &MIBICMPStats{}
	}
	if err := o.ICMPInStats.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.ICMPOutStats == nil {
		o.ICMPOutStats = &MIBICMPStats{}
	}
	if err := o.ICMPOutStats.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MIBICMP structure represents MIB_ICMP RPC structure.
//
// The MIB_ICMP structure contains the ICMP statistics. This structure is used in MIB_OPAQUE_INFO
// (section 2.2.1.2.52) structure.
type MIBICMP struct {
	// stats: An MIBICMPINFO (section 2.2.1.2.26) structure that contains the ICMP statistics.
	Stats *MIBICMPInfo `idl:"name:stats" json:"stats"`
}

func (o *MIBICMP) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBICMP) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if o.Stats != nil {
		if err := o.Stats.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&MIBICMPInfo{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MIBICMP) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if o.Stats == nil {
		o.Stats = &MIBICMPInfo{}
	}
	if err := o.Stats.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MIBInterfaceNumber structure represents MIB_IFNUMBER RPC structure.
//
// The MIB_IFNUMBER structure stores the number of interfaces on a specific computer.
type MIBInterfaceNumber struct {
	// dwValue: The number of interfaces on the computer.
	Value uint32 `idl:"name:dwValue" json:"value"`
}

func (o *MIBInterfaceNumber) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBInterfaceNumber) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Value); err != nil {
		return err
	}
	return nil
}
func (o *MIBInterfaceNumber) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Value); err != nil {
		return err
	}
	return nil
}

// MIBInterfaceRow structure represents MIB_IFROW RPC structure.
//
// The MIB_IFROW structure stores information about a specific interface.
type MIBInterfaceRow struct {
	// wszName: A pointer to a Unicode string that contains the name of the interface.
	Name []uint16 `idl:"name:wszName" json:"name"`
	// dwIndex: The index that identifies the interface. This index value is not persistent
	// and can change when a network adapter is disabled and then enabled.
	Index uint32 `idl:"name:dwIndex" json:"index"`
	// dwType: The interface type as defined by the Internet Assigned Names Authority (IANA)
	// [IANAifType].
	//
	// The following table lists common values for the interface type, although many other
	// values are possible.
	//
	//	+---------------------------------------+------------------------------------------------------------------------+
	//	|                                       |                                                                        |
	//	|                 VALUE                 |                                MEANING                                 |
	//	|                                       |                                                                        |
	//	+---------------------------------------+------------------------------------------------------------------------+
	//	+---------------------------------------+------------------------------------------------------------------------+
	//	| IF_TYPE_OTHER 0x00000001              | Another type of network interface.                                     |
	//	+---------------------------------------+------------------------------------------------------------------------+
	//	| IF_TYPE_ETHERNET_CSMACD 0x00000006    | An Ethernet network interface.                                         |
	//	+---------------------------------------+------------------------------------------------------------------------+
	//	| IF_TYPE_ISO88025_TOKENRING 0x00000009 | A token ring network interface.                                        |
	//	+---------------------------------------+------------------------------------------------------------------------+
	//	| IF_TYPE_PPP 0x00000017                | A PPP network interface.                                               |
	//	+---------------------------------------+------------------------------------------------------------------------+
	//	| IF_TYPE_SOFTWARE_LOOPBACK 0x00000018  | A software loopback network interface.                                 |
	//	+---------------------------------------+------------------------------------------------------------------------+
	//	| IF_TYPE_ATM 0x00000027                | An ATM network interface.                                              |
	//	+---------------------------------------+------------------------------------------------------------------------+
	//	| IF_TYPE_IEEE80211 0x00000047          | An IEEE 802.11 wireless network interface.                             |
	//	+---------------------------------------+------------------------------------------------------------------------+
	//	| IF_TYPE_TUNNEL 0x00000083             | A tunnel type encapsulation network interface.                         |
	//	+---------------------------------------+------------------------------------------------------------------------+
	//	| IF_TYPE_IEEE1394 0x00000090           | An IEEE 1394 (FireWire) high-performance serial bus network interface. |
	//	+---------------------------------------+------------------------------------------------------------------------+
	Type uint32 `idl:"name:dwType" json:"type"`
	// dwMtu: The maximum transmission unit (MTU) size in bytes.
	MTU uint32 `idl:"name:dwMtu" json:"mtu"`
	// dwSpeed: The speed of the interface in bits per second.
	Speed uint32 `idl:"name:dwSpeed" json:"speed"`
	// dwPhysAddrLen: The length, in bytes, of the physical address specified by the bPhysAddr
	// member.
	PhysicalAddrLength uint32 `idl:"name:dwPhysAddrLen" json:"physical_addr_length"`
	// bPhysAddr: The physical address of the adapter for this interface.
	PhysicalAddr []byte `idl:"name:bPhysAddr" json:"physical_addr"`
	// dwAdminStatus: The administrative status of the interface. It can be either enabled
	// or disabled.
	AdminStatus uint32 `idl:"name:dwAdminStatus" json:"admin_status"`
	// dwOperStatus: The operational status of the interface.
	//
	// This member can be one of the following values.
	//
	//	+-------------------------------------------+-----------------------------------------------------------------------------+
	//	|                                           |                                                                             |
	//	|                   VALUE                   |                                   MEANING                                   |
	//	|                                           |                                                                             |
	//	+-------------------------------------------+-----------------------------------------------------------------------------+
	//	+-------------------------------------------+-----------------------------------------------------------------------------+
	//	| IF_OPER_STATUS_NON_OPERATIONAL 0x00000000 | LAN adapter has been disabled, for example, because of an address conflict. |
	//	+-------------------------------------------+-----------------------------------------------------------------------------+
	//	| IF_OPER_STATUS_UNREACHABLE 0x00000001     | WAN adapter that is not connected.                                          |
	//	+-------------------------------------------+-----------------------------------------------------------------------------+
	//	| IF_OPER_STATUS_DISCONNECTED 0x00000002    | For LAN adapters: network cable disconnected. For WAN adapters: no carrier. |
	//	+-------------------------------------------+-----------------------------------------------------------------------------+
	//	| IF_OPER_STATUS_CONNECTING 0x00000003      | WAN adapter that is in the process of connecting.                           |
	//	+-------------------------------------------+-----------------------------------------------------------------------------+
	//	| IF_OPER_STATUS_CONNECTED 0x00000004       | WAN adapter that is connected to a remote peer.                             |
	//	+-------------------------------------------+-----------------------------------------------------------------------------+
	//	| IF_OPER_STATUS_OPERATIONAL 0x00000005     | Default status for LAN adapters.                                            |
	//	+-------------------------------------------+-----------------------------------------------------------------------------+
	OperatorStatus uint32 `idl:"name:dwOperStatus" json:"operator_status"`
	// dwLastChange: The length of time, in hundredths of seconds, starting from the last
	// computer restart, when the interface entered its current operational state.<32>
	LastChange uint32 `idl:"name:dwLastChange" json:"last_change"`
	// dwInOctets: The number of octets of data received through this interface.
	InOctets uint32 `idl:"name:dwInOctets" json:"in_octets"`
	// dwInUcastPkts: The number of unicast packets received through this interface.
	InUcastPackets uint32 `idl:"name:dwInUcastPkts" json:"in_ucast_packets"`
	// dwInNUcastPkts: The number of nonunicast packets received through this interface.
	// Broadcast and multicast packets are included.
	InNUcastPackets uint32 `idl:"name:dwInNUcastPkts" json:"in_n_ucast_packets"`
	// dwInDiscards: The number of incoming packets that were discarded even though they
	// did not have errors.
	InDiscards uint32 `idl:"name:dwInDiscards" json:"in_discards"`
	// dwInErrors: The number of incoming packets that were discarded because of errors.
	InErrors uint32 `idl:"name:dwInErrors" json:"in_errors"`
	// dwInUnknownProtos: The number of incoming packets that were discarded because the
	// protocol was unknown.
	InUnknownProtos uint32 `idl:"name:dwInUnknownProtos" json:"in_unknown_protos"`
	// dwOutOctets: The number of octets of data sent through this interface.
	OutOctets uint32 `idl:"name:dwOutOctets" json:"out_octets"`
	// dwOutUcastPkts: The number of unicast packets sent through this interface.
	OutUcastPackets uint32 `idl:"name:dwOutUcastPkts" json:"out_ucast_packets"`
	// dwOutNUcastPkts: The number of nonunicast packets sent through this interface. Broadcast
	// and multicast packets are included.
	OutNUcastPackets uint32 `idl:"name:dwOutNUcastPkts" json:"out_n_ucast_packets"`
	// dwOutDiscards: The number of outgoing packets that were discarded even though they
	// did not have errors.
	OutDiscards uint32 `idl:"name:dwOutDiscards" json:"out_discards"`
	// dwOutErrors: The number of outgoing packets that were discarded because of errors.
	OutErrors uint32 `idl:"name:dwOutErrors" json:"out_errors"`
	// dwOutQLen: The transmit queue length. This field is not currently used.
	OutQLength uint32 `idl:"name:dwOutQLen" json:"out_q_length"`
	// dwDescrLen: The length, in bytes, of the bDescr member.
	DescriptionLength uint32 `idl:"name:dwDescrLen" json:"description_length"`
	// bDescr: A null-terminated ASCII string that contains the description of the interface.
	Description []byte `idl:"name:bDescr" json:"description"`
}

func (o *MIBInterfaceRow) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBInterfaceRow) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	for i1 := range o.Name {
		i1 := i1
		if uint64(i1) >= 256 {
			break
		}
		if err := w.WriteData(o.Name[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Name); uint64(i1) < 256; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Index); err != nil {
		return err
	}
	if err := w.WriteData(o.Type); err != nil {
		return err
	}
	if err := w.WriteData(o.MTU); err != nil {
		return err
	}
	if err := w.WriteData(o.Speed); err != nil {
		return err
	}
	if err := w.WriteData(o.PhysicalAddrLength); err != nil {
		return err
	}
	for i1 := range o.PhysicalAddr {
		i1 := i1
		if uint64(i1) >= 8 {
			break
		}
		if err := w.WriteData(o.PhysicalAddr[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.PhysicalAddr); uint64(i1) < 8; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.AdminStatus); err != nil {
		return err
	}
	if err := w.WriteData(o.OperatorStatus); err != nil {
		return err
	}
	if err := w.WriteData(o.LastChange); err != nil {
		return err
	}
	if err := w.WriteData(o.InOctets); err != nil {
		return err
	}
	if err := w.WriteData(o.InUcastPackets); err != nil {
		return err
	}
	if err := w.WriteData(o.InNUcastPackets); err != nil {
		return err
	}
	if err := w.WriteData(o.InDiscards); err != nil {
		return err
	}
	if err := w.WriteData(o.InErrors); err != nil {
		return err
	}
	if err := w.WriteData(o.InUnknownProtos); err != nil {
		return err
	}
	if err := w.WriteData(o.OutOctets); err != nil {
		return err
	}
	if err := w.WriteData(o.OutUcastPackets); err != nil {
		return err
	}
	if err := w.WriteData(o.OutNUcastPackets); err != nil {
		return err
	}
	if err := w.WriteData(o.OutDiscards); err != nil {
		return err
	}
	if err := w.WriteData(o.OutErrors); err != nil {
		return err
	}
	if err := w.WriteData(o.OutQLength); err != nil {
		return err
	}
	if err := w.WriteData(o.DescriptionLength); err != nil {
		return err
	}
	for i1 := range o.Description {
		i1 := i1
		if uint64(i1) >= 256 {
			break
		}
		if err := w.WriteData(o.Description[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Description); uint64(i1) < 256; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteTrailingGap(4); err != nil {
		return err
	}
	return nil
}
func (o *MIBInterfaceRow) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	o.Name = make([]uint16, 256)
	for i1 := range o.Name {
		i1 := i1
		if err := w.ReadData(&o.Name[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.Index); err != nil {
		return err
	}
	if err := w.ReadData(&o.Type); err != nil {
		return err
	}
	if err := w.ReadData(&o.MTU); err != nil {
		return err
	}
	if err := w.ReadData(&o.Speed); err != nil {
		return err
	}
	if err := w.ReadData(&o.PhysicalAddrLength); err != nil {
		return err
	}
	o.PhysicalAddr = make([]byte, 8)
	for i1 := range o.PhysicalAddr {
		i1 := i1
		if err := w.ReadData(&o.PhysicalAddr[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.AdminStatus); err != nil {
		return err
	}
	if err := w.ReadData(&o.OperatorStatus); err != nil {
		return err
	}
	if err := w.ReadData(&o.LastChange); err != nil {
		return err
	}
	if err := w.ReadData(&o.InOctets); err != nil {
		return err
	}
	if err := w.ReadData(&o.InUcastPackets); err != nil {
		return err
	}
	if err := w.ReadData(&o.InNUcastPackets); err != nil {
		return err
	}
	if err := w.ReadData(&o.InDiscards); err != nil {
		return err
	}
	if err := w.ReadData(&o.InErrors); err != nil {
		return err
	}
	if err := w.ReadData(&o.InUnknownProtos); err != nil {
		return err
	}
	if err := w.ReadData(&o.OutOctets); err != nil {
		return err
	}
	if err := w.ReadData(&o.OutUcastPackets); err != nil {
		return err
	}
	if err := w.ReadData(&o.OutNUcastPackets); err != nil {
		return err
	}
	if err := w.ReadData(&o.OutDiscards); err != nil {
		return err
	}
	if err := w.ReadData(&o.OutErrors); err != nil {
		return err
	}
	if err := w.ReadData(&o.OutQLength); err != nil {
		return err
	}
	if err := w.ReadData(&o.DescriptionLength); err != nil {
		return err
	}
	o.Description = make([]byte, 256)
	for i1 := range o.Description {
		i1 := i1
		if err := w.ReadData(&o.Description[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadTrailingGap(4); err != nil {
		return err
	}
	return nil
}

// MIBInterfaceStatus structure represents MIB_IFSTATUS RPC structure.
//
// The MIB_IFSTATUS structure stores status information for a specific interface.
type MIBInterfaceStatus struct {
	// dwIfIndex: The index that identifies the interface.
	InterfaceIndex uint32 `idl:"name:dwIfIndex" json:"interface_index"`
	// dwAdminStatus: The administrative status of the interface, that is, whether the interface
	// is administratively enabled or disabled.
	AdminStatus uint32 `idl:"name:dwAdminStatus" json:"admin_status"`
	// dwOperationalStatus: The operational status of the interface. This member can be
	// one of the values defined in ROUTER_CONNECTION_STATE (section 2.2.1.1.2).
	OperationalStatus uint32 `idl:"name:dwOperationalStatus" json:"operational_status"`
	// bMHbeatActive: Specifies whether multicast heartbeat detection is enabled. A value
	// of TRUE indicates that heartbeat detection is enabled. A value of FALSE indicates
	// that heartbeat detection is disabled.
	//
	//	+-------+----------------------------------+
	//	|       |                                  |
	//	| VALUE |             MEANING              |
	//	|       |                                  |
	//	+-------+----------------------------------+
	//	+-------+----------------------------------+
	//	| TRUE  | Heartbeat detection is enabled.  |
	//	+-------+----------------------------------+
	//	| FALSE | Heartbeat detection is disabled. |
	//	+-------+----------------------------------+
	MHBeatActive bool `idl:"name:bMHbeatActive" json:"m_hbeat_active"`
	// bMHbeatAlive: Specifies whether the multicast heartbeat dead interval has been exceeded.
	// A value of FALSE indicates that the interval has been exceeded. A value of TRUE indicates
	// that the interval has not been exceeded.
	//
	//	+-------+------------------------------------------------+
	//	|       |                                                |
	//	| VALUE |                    MEANING                     |
	//	|       |                                                |
	//	+-------+------------------------------------------------+
	//	+-------+------------------------------------------------+
	//	| TRUE  | Heartbeat dead interval has not been exceeded. |
	//	+-------+------------------------------------------------+
	//	| FALSE | Heartbeat dead interval has been exceeded.     |
	//	+-------+------------------------------------------------+
	MHBeatAlive bool `idl:"name:bMHbeatAlive" json:"m_hbeat_alive"`
}

func (o *MIBInterfaceStatus) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBInterfaceStatus) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.InterfaceIndex); err != nil {
		return err
	}
	if err := w.WriteData(o.AdminStatus); err != nil {
		return err
	}
	if err := w.WriteData(o.OperationalStatus); err != nil {
		return err
	}
	if !o.MHBeatActive {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if !o.MHBeatAlive {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	return nil
}
func (o *MIBInterfaceStatus) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.InterfaceIndex); err != nil {
		return err
	}
	if err := w.ReadData(&o.AdminStatus); err != nil {
		return err
	}
	if err := w.ReadData(&o.OperationalStatus); err != nil {
		return err
	}
	var _bMHBeatActive int32
	if err := w.ReadData(&_bMHBeatActive); err != nil {
		return err
	}
	o.MHBeatActive = _bMHBeatActive != 0
	var _bMHBeatAlive int32
	if err := w.ReadData(&_bMHBeatAlive); err != nil {
		return err
	}
	o.MHBeatAlive = _bMHBeatAlive != 0
	return nil
}

// MIBInterfaceTable structure represents MIB_IFTABLE RPC structure.
//
// The MIB_IFTABLE structure contains a table of interface entries. This structure is
// used in MIB_OPAQUE_INFO (section 2.2.1.2.52) structure.
//
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwNumEntries                                                                                                                  |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| table (variable)                                                                                                              |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
type MIBInterfaceTable struct {
	// dwNumEntries (4 bytes): The number of interface entries in the table.
	EntriesLength uint32 `idl:"name:dwNumEntries" json:"entries_length"`
	// table (variable): An array of MIB_IFROW (section 2.2.1.2.29) structures that contains
	// interface entries.
	Table []*MIBInterfaceRow `idl:"name:table" json:"table"`
}

func (o *MIBInterfaceTable) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBInterfaceTable) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.EntriesLength); err != nil {
		return err
	}
	for i1 := range o.Table {
		i1 := i1
		if uint64(i1) >= 1 {
			break
		}
		if o.Table[i1] != nil {
			if err := o.Table[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MIBInterfaceRow{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.Table); uint64(i1) < 1; i1++ {
		if err := (&MIBInterfaceRow{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MIBInterfaceTable) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntriesLength); err != nil {
		return err
	}
	o.Table = make([]*MIBInterfaceRow, 1)
	for i1 := range o.Table {
		i1 := i1
		if o.Table[i1] == nil {
			o.Table[i1] = &MIBInterfaceRow{}
		}
		if err := o.Table[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// MIBIPAddrRow structure represents MIB_IPADDRROW RPC structure.
//
// The MIB_IPADDRROW structure specifies information for a specific IPv4 address. This
// structure is used in the following methods:
//
// * *MIB_OPAQUE_INFO* (section 2.2.1.2.52 ( 169e435d-a975-4c1c-bf41-55fd2bd76125 )
// )
//
// * *MIB_IPADDRTABLE (section 2.2.1.2.33)* ( dda988f0-4cce-4ffe-b8c9-d5199deafba5 )
//
// typedef struct _MIB_IPADDRROW {
//
// DWORD dwAddr;
//
// DWORD dwIndex;
//
// DWORD dwMask;
//
// DWORD dwBCastAddr;
//
// DWORD dwReasmSize;
//
// unsigned short unused1;
//
// unsigned short wType;
//
// } MIB_IPADDRROW,
type MIBIPAddrRow struct {
	// dwAddr: The IPv4 address.
	Addr uint32 `idl:"name:dwAddr" json:"addr"`
	// dwIndex: The index of the interface associated with this IPv4 address.
	Index uint32 `idl:"name:dwIndex" json:"index"`
	// dwMask: The subnet mask for the IPv4 address. See [RFC950].
	Mask uint32 `idl:"name:dwMask" json:"mask"`
	// dwBCastAddr: The broadcast address. A broadcast address is typically the IPv4 address
	// with the host portion set to either all zeros or all ones.
	BCastAddr uint32 `idl:"name:dwBCastAddr" json:"b_cast_addr"`
	// dwReasmSize: The maximum reassembly size for received datagrams.
	ReasmSize uint32 `idl:"name:dwReasmSize" json:"reasm_size"`
	// unused1: This member is reserved and SHOULD be set to 0.
	_ uint16 `idl:"name:unused1"`
	// wType: The address type or state.<33>
	//
	//	+--------------------------------+-----------------------------------------+
	//	|                                |                                         |
	//	|             VALUE              |                 MEANING                 |
	//	|                                |                                         |
	//	+--------------------------------+-----------------------------------------+
	//	+--------------------------------+-----------------------------------------+
	//	| MIB_IPADDR_PRIMARY 0x0001      | Primary IP address.                     |
	//	+--------------------------------+-----------------------------------------+
	//	| MIB_IPADDR_DYNAMIC 0x0004      | Dynamic IP address.                     |
	//	+--------------------------------+-----------------------------------------+
	//	| MIB_IPADDR_DISCONNECTED 0x0008 | Address is on a disconnected interface. |
	//	+--------------------------------+-----------------------------------------+
	//	| MIB_IPADDR_DELETED 0x0040      | Address is being deleted.               |
	//	+--------------------------------+-----------------------------------------+
	//	| MIB_IPADDR_TRANSIENT 0x0080    | Transient address.                      |
	//	+--------------------------------+-----------------------------------------+
	Type uint16 `idl:"name:wType" json:"type"`
}

func (o *MIBIPAddrRow) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBIPAddrRow) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Addr); err != nil {
		return err
	}
	if err := w.WriteData(o.Index); err != nil {
		return err
	}
	if err := w.WriteData(o.Mask); err != nil {
		return err
	}
	if err := w.WriteData(o.BCastAddr); err != nil {
		return err
	}
	if err := w.WriteData(o.ReasmSize); err != nil {
		return err
	}
	// reserved unused1
	if err := w.WriteData(uint16(0)); err != nil {
		return err
	}
	if err := w.WriteData(o.Type); err != nil {
		return err
	}
	if err := w.WriteTrailingGap(4); err != nil {
		return err
	}
	return nil
}
func (o *MIBIPAddrRow) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Addr); err != nil {
		return err
	}
	if err := w.ReadData(&o.Index); err != nil {
		return err
	}
	if err := w.ReadData(&o.Mask); err != nil {
		return err
	}
	if err := w.ReadData(&o.BCastAddr); err != nil {
		return err
	}
	if err := w.ReadData(&o.ReasmSize); err != nil {
		return err
	}
	// reserved unused1
	var _unused1 uint16
	if err := w.ReadData(&_unused1); err != nil {
		return err
	}
	if err := w.ReadData(&o.Type); err != nil {
		return err
	}
	if err := w.ReadTrailingGap(4); err != nil {
		return err
	}
	return nil
}

// MIBIPAddrTable structure represents MIB_IPADDRTABLE RPC structure.
//
// The MIB_IPADDRTABLE structure contains a table of IPv4 address entries. This structure
// is used in MIB_OPAQUE_INFO (section 2.2.1.2.52) structure.
//
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwNumEntries                                                                                                                  |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| table (variable)                                                                                                              |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
type MIBIPAddrTable struct {
	// dwNumEntries (4 bytes): The number of IPv4 address entries in the table.
	EntriesLength uint32 `idl:"name:dwNumEntries" json:"entries_length"`
	// table (variable): A pointer to a table of IPv4 address entries implemented as an
	// array of MIB_IPADDRROW (section 2.2.1.2.32) structures.
	Table []*MIBIPAddrRow `idl:"name:table" json:"table"`
}

func (o *MIBIPAddrTable) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBIPAddrTable) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.EntriesLength); err != nil {
		return err
	}
	for i1 := range o.Table {
		i1 := i1
		if uint64(i1) >= 1 {
			break
		}
		if o.Table[i1] != nil {
			if err := o.Table[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MIBIPAddrRow{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.Table); uint64(i1) < 1; i1++ {
		if err := (&MIBIPAddrRow{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MIBIPAddrTable) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntriesLength); err != nil {
		return err
	}
	o.Table = make([]*MIBIPAddrRow, 1)
	for i1 := range o.Table {
		i1 := i1
		if o.Table[i1] == nil {
			o.Table[i1] = &MIBIPAddrRow{}
		}
		if err := o.Table[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// MIBIPForwardNumber structure represents MIB_IPFORWARDNUMBER RPC structure.
//
// The MIB_IPFORWARDNUMBER structure stores the number of routes in a specific IP routing
// table.
type MIBIPForwardNumber struct {
	// dwValue: Specifies the number of routes in the IP routing table.
	Value uint32 `idl:"name:dwValue" json:"value"`
}

func (o *MIBIPForwardNumber) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBIPForwardNumber) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Value); err != nil {
		return err
	}
	return nil
}
func (o *MIBIPForwardNumber) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Value); err != nil {
		return err
	}
	return nil
}

// MIBIPForwardTable structure represents MIB_IPFORWARDTABLE RPC structure.
//
// The MIB_IPFORWARDTABLE structure contains a table of the IP route entries.
//
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwNumEntries                                                                                                                  |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| table (variable)                                                                                                              |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| reserved                                                                                                                      |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
type MIBIPForwardTable struct {
	// dwNumEntries (4 bytes): Specifies the number of route entries in the table.
	EntriesLength uint32 `idl:"name:dwNumEntries" json:"entries_length"`
	// table (variable): Pointer to a table of route entries implemented as an array of
	// MIB_IPFORWARDROW (section 2.2.1.2.35) structures.
	Table []*MIBIPForwardRow `idl:"name:table" json:"table"`
	// reserved (8 bytes): An array of 8 bytes that SHOULD be set to zero (0) and ignored
	// on receipt.
	_ []byte `idl:"name:reserved"`
}

func (o *MIBIPForwardTable) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBIPForwardTable) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.EntriesLength); err != nil {
		return err
	}
	for i1 := range o.Table {
		i1 := i1
		if uint64(i1) >= 1 {
			break
		}
		if o.Table[i1] != nil {
			if err := o.Table[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MIBIPForwardRow{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.Table); uint64(i1) < 1; i1++ {
		if err := (&MIBIPForwardRow{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// reserved reserved
	for i1 := 0; uint64(i1) < 8; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteTrailingGap(4); err != nil {
		return err
	}
	return nil
}
func (o *MIBIPForwardTable) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntriesLength); err != nil {
		return err
	}
	o.Table = make([]*MIBIPForwardRow, 1)
	for i1 := range o.Table {
		i1 := i1
		if o.Table[i1] == nil {
			o.Table[i1] = &MIBIPForwardRow{}
		}
		if err := o.Table[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// reserved reserved
	var _reserved []byte
	_reserved = make([]byte, 8)
	for i1 := range _reserved {
		i1 := i1
		if err := w.ReadData(&_reserved[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadTrailingGap(4); err != nil {
		return err
	}
	return nil
}

// MIBIPMulticastBoundary structure represents MIB_IPMCAST_BOUNDARY RPC structure.
//
// The MIB_IPMCAST_BOUNDARY structure contains a router's scoped IPv4 multicast address
// boundaries. This structure is used in the following methods:
//
// * *MIB_OPAQUE_INFO* (section 2.2.1.2.52 ( 169e435d-a975-4c1c-bf41-55fd2bd76125 )
// )
//
// * *MIB_IPMCAST_BOUNDARY_TABLE (section 2.2.1.2.38)* ( a6a848da-af0c-4772-af06-6bfd49723824
// )
//
// typedef struct {
//
// DWORD dwIfIndex;
//
// DWORD dwGroupAddress;
//
// DWORD dwGroupMask;
//
// DWORD dwStatus;
//
// } MIB_IPMCAST_BOUNDARY,
type MIBIPMulticastBoundary struct {
	// dwIfIndex: The index value for the interface that applies to this boundary. Packets
	// with a destination address in the associated address/mask range are not forwarded
	// with this interface.
	InterfaceIndex uint32 `idl:"name:dwIfIndex" json:"interface_index"`
	// dwGroupAddress: The 32-bit integer representation of the IPv4 group address which,
	// when combined with the corresponding value in dwGroupMask, identifies the group range
	// for which the scoped boundary exists.
	GroupAddress uint32 `idl:"name:dwGroupAddress" json:"group_address"`
	// dwGroupMask: The 32-bit integer representation of the IPv4 group address mask which,
	// when combined with the corresponding value in dwGroupAddress, identifies the group
	// range for which the scoped boundary exists.
	GroupMask uint32 `idl:"name:dwGroupMask" json:"group_mask"`
	// dwStatus: A status value that describes the current status of this entry in a multicast
	// forwarding entry (MFE) boundary table.
	//
	//	+------------------------------------+---------------------------------------+
	//	|                                    |                                       |
	//	|               VALUE                |                MEANING                |
	//	|                                    |                                       |
	//	+------------------------------------+---------------------------------------+
	//	+------------------------------------+---------------------------------------+
	//	| ROWSTATUS_ACTIVE 0x00000001        | The entry has an active status.       |
	//	+------------------------------------+---------------------------------------+
	//	| ROWSTATUS_NOTINSERVICE 0x00000002  | The entry has a notInService status.  |
	//	+------------------------------------+---------------------------------------+
	//	| ROWSTATUS_NOTREADY 0x00000003      | The entry has a notReady status.      |
	//	+------------------------------------+---------------------------------------+
	//	| ROWSTATUS_CREATEANDGO 0x00000004   | The entry has a createAndGo status.   |
	//	+------------------------------------+---------------------------------------+
	//	| ROWSTATUS_CREATEANDWAIT 0x00000005 | The entry has a createAndWait status. |
	//	+------------------------------------+---------------------------------------+
	//	| ROWSTATUS_DESTROY 0x00000006       | The entry has a destroy status.       |
	//	+------------------------------------+---------------------------------------+
	Status uint32 `idl:"name:dwStatus" json:"status"`
}

func (o *MIBIPMulticastBoundary) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBIPMulticastBoundary) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.InterfaceIndex); err != nil {
		return err
	}
	if err := w.WriteData(o.GroupAddress); err != nil {
		return err
	}
	if err := w.WriteData(o.GroupMask); err != nil {
		return err
	}
	if err := w.WriteData(o.Status); err != nil {
		return err
	}
	return nil
}
func (o *MIBIPMulticastBoundary) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.InterfaceIndex); err != nil {
		return err
	}
	if err := w.ReadData(&o.GroupAddress); err != nil {
		return err
	}
	if err := w.ReadData(&o.GroupMask); err != nil {
		return err
	}
	if err := w.ReadData(&o.Status); err != nil {
		return err
	}
	return nil
}

// MIBIPMulticastBoundaryTable structure represents MIB_IPMCAST_BOUNDARY_TABLE RPC structure.
//
// The MIB_IPMCAST_BOUNDARY_TABLE structure contains a list of a router's scoped IPv4
// multicast address boundaries. This structure is used in MIB_OPAQUE_INFO (section
// 2.2.1.2.52) structure.
//
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwNumEntries                                                                                                                  |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| table (variable)                                                                                                              |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
type MIBIPMulticastBoundaryTable struct {
	// dwNumEntries (4 bytes): The number of MIB_IPMCAST_BOUNDARY (section 2.2.1.2.37) structures
	// listed in table.
	EntriesLength uint32 `idl:"name:dwNumEntries" json:"entries_length"`
	// table (variable): An array of MIB_IPMCAST_BOUNDARY structures that collectively define
	// the set of scoped IPv4 multicast address boundaries on a router
	Table []*MIBIPMulticastBoundary `idl:"name:table" json:"table"`
}

func (o *MIBIPMulticastBoundaryTable) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBIPMulticastBoundaryTable) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.EntriesLength); err != nil {
		return err
	}
	for i1 := range o.Table {
		i1 := i1
		if uint64(i1) >= 1 {
			break
		}
		if o.Table[i1] != nil {
			if err := o.Table[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MIBIPMulticastBoundary{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.Table); uint64(i1) < 1; i1++ {
		if err := (&MIBIPMulticastBoundary{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MIBIPMulticastBoundaryTable) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntriesLength); err != nil {
		return err
	}
	o.Table = make([]*MIBIPMulticastBoundary, 1)
	for i1 := range o.Table {
		i1 := i1
		if o.Table[i1] == nil {
			o.Table[i1] = &MIBIPMulticastBoundary{}
		}
		if err := o.Table[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// MIBIPMulticastGlobal structure represents MIB_IPMCAST_GLOBAL RPC structure.
//
// The MIB_IPMCAST_GLOBAL structure stores global information for IP multicast on a
// specific computer.
type MIBIPMulticastGlobal struct {
	// dwEnable: Specifies whether or not IP multicast is enabled on the computer. This
	// value is set to 1 if IP multicast is enabled on the computer and is set to 2 if IP
	// multicast is not enabled on the computer.
	Enable uint32 `idl:"name:dwEnable" json:"enable"`
}

func (o *MIBIPMulticastGlobal) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBIPMulticastGlobal) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Enable); err != nil {
		return err
	}
	return nil
}
func (o *MIBIPMulticastGlobal) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Enable); err != nil {
		return err
	}
	return nil
}

// MIBIPMulticastInterfaceEntry structure represents MIB_IPMCAST_IF_ENTRY RPC structure.
//
// The MIB_IPMCAST_IF_ENTRY structure stores information about an IP multicast interface.
type MIBIPMulticastInterfaceEntry struct {
	// dwIfIndex: The index of this interface.
	InterfaceIndex uint32 `idl:"name:dwIfIndex" json:"interface_index"`
	// dwTtl: The TTL value for this interface.
	TTL uint32 `idl:"name:dwTtl" json:"ttl"`
	// dwProtocol: The multicast routing protocol that owns this interface.
	Protocol uint32 `idl:"name:dwProtocol" json:"protocol"`
	// dwRateLimit: The rate limit of this interface.
	RateLimit uint32 `idl:"name:dwRateLimit" json:"rate_limit"`
	// ulInMcastOctets: The number of octets of multicast data received through this interface.
	InMulticastOctets uint32 `idl:"name:ulInMcastOctets" json:"in_multicast_octets"`
	// ulOutMcastOctets: The number of octets of multicast data sent through this interface.
	OutMulticastOctets uint32 `idl:"name:ulOutMcastOctets" json:"out_multicast_octets"`
}

func (o *MIBIPMulticastInterfaceEntry) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBIPMulticastInterfaceEntry) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.InterfaceIndex); err != nil {
		return err
	}
	if err := w.WriteData(o.TTL); err != nil {
		return err
	}
	if err := w.WriteData(o.Protocol); err != nil {
		return err
	}
	if err := w.WriteData(o.RateLimit); err != nil {
		return err
	}
	if err := w.WriteData(o.InMulticastOctets); err != nil {
		return err
	}
	if err := w.WriteData(o.OutMulticastOctets); err != nil {
		return err
	}
	return nil
}
func (o *MIBIPMulticastInterfaceEntry) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.InterfaceIndex); err != nil {
		return err
	}
	if err := w.ReadData(&o.TTL); err != nil {
		return err
	}
	if err := w.ReadData(&o.Protocol); err != nil {
		return err
	}
	if err := w.ReadData(&o.RateLimit); err != nil {
		return err
	}
	if err := w.ReadData(&o.InMulticastOctets); err != nil {
		return err
	}
	if err := w.ReadData(&o.OutMulticastOctets); err != nil {
		return err
	}
	return nil
}

// MIBIPMulticastInterfaceTable structure represents MIB_IPMCAST_IF_TABLE RPC structure.
//
// The MIB_IPMCAST_IF_TABLE structure contains a table of IP multicast interface entries.
type MIBIPMulticastInterfaceTable struct {
	// dwNumEntries: Specifies the number of interface entries in the table.
	EntriesLength uint32 `idl:"name:dwNumEntries" json:"entries_length"`
	// table: A pointer to a table of interface entries implemented as an array of MIB_IPMCAST_IF_ENTRY
	// (section 2.2.1.2.40) structures.
	Table []*MIBIPMulticastInterfaceEntry `idl:"name:table" json:"table"`
}

func (o *MIBIPMulticastInterfaceTable) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBIPMulticastInterfaceTable) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.EntriesLength); err != nil {
		return err
	}
	for i1 := range o.Table {
		i1 := i1
		if uint64(i1) >= 1 {
			break
		}
		if o.Table[i1] != nil {
			if err := o.Table[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MIBIPMulticastInterfaceEntry{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.Table); uint64(i1) < 1; i1++ {
		if err := (&MIBIPMulticastInterfaceEntry{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MIBIPMulticastInterfaceTable) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntriesLength); err != nil {
		return err
	}
	o.Table = make([]*MIBIPMulticastInterfaceEntry, 1)
	for i1 := range o.Table {
		i1 := i1
		if o.Table[i1] == nil {
			o.Table[i1] = &MIBIPMulticastInterfaceEntry{}
		}
		if err := o.Table[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// MIBIPMulticastOutgoingInterface structure represents MIB_IPMCAST_OIF RPC structure.
//
// The MIB_IPMCAST_OIF structure stores the information required to send an outgoing
// IP multicast packet.
type MIBIPMulticastOutgoingInterface struct {
	// dwOutIfIndex: The index of the interface on which to send the outgoing IP multicast
	// packet.
	OutInterfaceIndex uint32 `idl:"name:dwOutIfIndex" json:"out_interface_index"`
	// dwNextHopAddr: The destination address for the outgoing IPv4 multicast packet.
	NextHopAddr uint32 `idl:"name:dwNextHopAddr" json:"next_hop_addr"`
	// pvReserved: Reserved. This member MUST be NULL.
	_ []byte `idl:"name:pvReserved"`
	// dwReserved: Reserved. This member MUST be zero (0).
	_ uint32 `idl:"name:dwReserved"`
}

func (o *MIBIPMulticastOutgoingInterface) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBIPMulticastOutgoingInterface) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.OutInterfaceIndex); err != nil {
		return err
	}
	if err := w.WriteData(o.NextHopAddr); err != nil {
		return err
	}
	// reserved pvReserved
	if err := w.WritePointer(nil); err != nil {
		return err
	}
	// reserved dwReserved
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	if err := w.WriteTrailingGap(9); err != nil {
		return err
	}
	return nil
}
func (o *MIBIPMulticastOutgoingInterface) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.OutInterfaceIndex); err != nil {
		return err
	}
	if err := w.ReadData(&o.NextHopAddr); err != nil {
		return err
	}
	// reserved pvReserved
	var _pvReserved []byte
	_ptr_pvReserved := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		// FIXME: unknown type pvReserved
		return nil
	})
	_s_pvReserved := func(ptr interface{}) { _pvReserved = *ptr.(*[]byte) }
	if err := w.ReadPointer(&_pvReserved, _s_pvReserved, _ptr_pvReserved); err != nil {
		return err
	}
	// reserved dwReserved
	var _dwReserved uint32
	if err := w.ReadData(&_dwReserved); err != nil {
		return err
	}
	if err := w.ReadTrailingGap(9); err != nil {
		return err
	}
	return nil
}

// MIBIPMulticastMulticastForwardingEntry structure represents MIB_IPMCAST_MFE RPC structure.
//
// The MIB_IPMCAST_MFE structure stores the information for an IP multicast forwarding
// entry (MFE). This structure is used in MIB_MFE_TABLE (section 2.2.1.2.51) structure.
type MIBIPMulticastMulticastForwardingEntry struct {
	// dwGroup: The range of IPv4 multicast groups for this MFE. A value of zero (0) indicates
	// a wildcard group.
	Group uint32 `idl:"name:dwGroup" json:"group"`
	// dwSource: The range of IPv4 source addresses for this MFE. A value of zero (0) indicates
	// a wildcard source.
	Source uint32 `idl:"name:dwSource" json:"source"`
	// dwSrcMask: The IPv4 subnet mask that corresponds to dwSource. The dwSource and dwSrcMask
	// members are used together to define a range of sources.
	SourceMask uint32 `idl:"name:dwSrcMask" json:"source_mask"`
	// dwUpStrmNgbr: The upstream neighbor that is related to this MFE.
	UpstreamNeighbor uint32 `idl:"name:dwUpStrmNgbr" json:"upstream_neighbor"`
	// dwInIfIndex: The index of the interface to which this MFE is related.
	InInterfaceIndex uint32 `idl:"name:dwInIfIndex" json:"in_interface_index"`
	// dwInIfProtocol: The routing protocol that owns the incoming interface to which this
	// MFE is related.
	InInterfaceProtocol uint32 `idl:"name:dwInIfProtocol" json:"in_interface_protocol"`
	// dwRouteProtocol: The protocol that created the route. This is the enum MIB_IPFORWARD_PROTO
	// (section 2.2.1.1.9).
	RouteProtocol uint32 `idl:"name:dwRouteProtocol" json:"route_protocol"`
	// dwRouteNetwork: The IPv4 address associated with the route referred to by dwRouteProtocol.
	RouteNetwork uint32 `idl:"name:dwRouteNetwork" json:"route_network"`
	// dwRouteMask: The IPv4 mask associated with the route referred to by dwRouteProtocol.
	RouteMask uint32 `idl:"name:dwRouteMask" json:"route_mask"`
	// ulUpTime: The time, in seconds, that this MFE has been valid. This value starts from
	// zero (0) and is incremented until it reaches the ulTimeOut value, at which time the
	// MFE is deleted.
	UpTime uint32 `idl:"name:ulUpTime" json:"up_time"`
	// ulExpiryTime: The time, in seconds, that remains before the MFE expires and is deleted.
	// This value starts from ulTimeOut and is decremented until it reaches zero (0), at
	// which time the MFE is deleted.
	ExpiryTime uint32 `idl:"name:ulExpiryTime" json:"expiry_time"`
	// ulTimeOut: The total length of time, in seconds, that this MFE remains valid. After
	// the time-out value is exceeded, the MFE is deleted.
	Timeout uint32 `idl:"name:ulTimeOut" json:"timeout"`
	// ulNumOutIf: The number of outgoing interfaces that are associated with this MFE.
	NumOutInterface uint32 `idl:"name:ulNumOutIf" json:"num_out_interface"`
	// fFlags: Reserved. This member SHOULD be NULL.
	Flags uint32 `idl:"name:fFlags" json:"flags"`
	// dwReserved: Reserved. This member SHOULD be NULL.
	_ uint32 `idl:"name:dwReserved"`
	// rgmioOutInfo: A pointer to a table of outgoing interface statistics that are implemented
	// as an array of MIB_IPMCAST_OIF (section 2.2.1.2.43) structures.
	RgmioOutInfo []*MIBIPMulticastOutgoingInterface `idl:"name:rgmioOutInfo" json:"rgmio_out_info"`
}

func (o *MIBIPMulticastMulticastForwardingEntry) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBIPMulticastMulticastForwardingEntry) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.Group); err != nil {
		return err
	}
	if err := w.WriteData(o.Source); err != nil {
		return err
	}
	if err := w.WriteData(o.SourceMask); err != nil {
		return err
	}
	if err := w.WriteData(o.UpstreamNeighbor); err != nil {
		return err
	}
	if err := w.WriteData(o.InInterfaceIndex); err != nil {
		return err
	}
	if err := w.WriteData(o.InInterfaceProtocol); err != nil {
		return err
	}
	if err := w.WriteData(o.RouteProtocol); err != nil {
		return err
	}
	if err := w.WriteData(o.RouteNetwork); err != nil {
		return err
	}
	if err := w.WriteData(o.RouteMask); err != nil {
		return err
	}
	if err := w.WriteData(o.UpTime); err != nil {
		return err
	}
	if err := w.WriteData(o.ExpiryTime); err != nil {
		return err
	}
	if err := w.WriteData(o.Timeout); err != nil {
		return err
	}
	if err := w.WriteData(o.NumOutInterface); err != nil {
		return err
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	// reserved dwReserved
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	for i1 := range o.RgmioOutInfo {
		i1 := i1
		if uint64(i1) >= 1 {
			break
		}
		if o.RgmioOutInfo[i1] != nil {
			if err := o.RgmioOutInfo[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MIBIPMulticastOutgoingInterface{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.RgmioOutInfo); uint64(i1) < 1; i1++ {
		if err := (&MIBIPMulticastOutgoingInterface{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MIBIPMulticastMulticastForwardingEntry) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.Group); err != nil {
		return err
	}
	if err := w.ReadData(&o.Source); err != nil {
		return err
	}
	if err := w.ReadData(&o.SourceMask); err != nil {
		return err
	}
	if err := w.ReadData(&o.UpstreamNeighbor); err != nil {
		return err
	}
	if err := w.ReadData(&o.InInterfaceIndex); err != nil {
		return err
	}
	if err := w.ReadData(&o.InInterfaceProtocol); err != nil {
		return err
	}
	if err := w.ReadData(&o.RouteProtocol); err != nil {
		return err
	}
	if err := w.ReadData(&o.RouteNetwork); err != nil {
		return err
	}
	if err := w.ReadData(&o.RouteMask); err != nil {
		return err
	}
	if err := w.ReadData(&o.UpTime); err != nil {
		return err
	}
	if err := w.ReadData(&o.ExpiryTime); err != nil {
		return err
	}
	if err := w.ReadData(&o.Timeout); err != nil {
		return err
	}
	if err := w.ReadData(&o.NumOutInterface); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	// reserved dwReserved
	var _dwReserved uint32
	if err := w.ReadData(&_dwReserved); err != nil {
		return err
	}
	o.RgmioOutInfo = make([]*MIBIPMulticastOutgoingInterface, 1)
	for i1 := range o.RgmioOutInfo {
		i1 := i1
		if o.RgmioOutInfo[i1] == nil {
			o.RgmioOutInfo[i1] = &MIBIPMulticastOutgoingInterface{}
		}
		if err := o.RgmioOutInfo[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// MIBIPMulticastOutgoingInterfaceStats structure represents MIB_IPMCAST_OIF_STATS RPC structure.
//
// The MIB_IPMCAST_OIF_STATS structure stores the statistics that are associated with
// an outgoing multicast interface.
type MIBIPMulticastOutgoingInterfaceStats struct {
	// dwOutIfIndex: Specifies the outgoing interface to which these statistics are related.
	OutInterfaceIndex uint32 `idl:"name:dwOutIfIndex" json:"out_interface_index"`
	// dwNextHopAddr: Specifies the address of the next hop that corresponds to dwOutIfIndex.
	// The dwOutIfIndex and dwNextHopAddr members uniquely identify a next hop on point-to-multipoint
	// interfaces, where one interface connects to multiple networks. Examples of point-to-multipoint
	// interfaces include non-broadcast multiple-access (NBMA) interfaces, and the internal
	// interface on which all dial-up clients connect. For Ethernet and other broadcast
	// interfaces, specify zero (0). Also specify zero (0) for point-to-point interfaces,
	// which are identified by only dwOutIfIndex.
	NextHopAddr uint32 `idl:"name:dwNextHopAddr" json:"next_hop_addr"`
	// pvDialContext: Reserved. This member MUST be NULL.
	DialContext []byte `idl:"name:pvDialContext" json:"dial_context"`
	// ulTtlTooLow: Specifies the number of packets on this outgoing interface that were
	// discarded because the packet's TTL value was too low.
	TTLTooLow uint32 `idl:"name:ulTtlTooLow" json:"ttl_too_low"`
	// ulFragNeeded: Specifies the number of packets that required fragmentation when they
	// were forwarded on this interface.
	FragNeeded uint32 `idl:"name:ulFragNeeded" json:"frag_needed"`
	// ulOutPackets: Specifies the number of packets that were forwarded out of this interface.
	OutPackets uint32 `idl:"name:ulOutPackets" json:"out_packets"`
	// ulOutDiscards: Specifies the number of packets that were discarded on this interface.
	OutDiscards uint32 `idl:"name:ulOutDiscards" json:"out_discards"`
}

func (o *MIBIPMulticastOutgoingInterfaceStats) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBIPMulticastOutgoingInterfaceStats) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.OutInterfaceIndex); err != nil {
		return err
	}
	if err := w.WriteData(o.NextHopAddr); err != nil {
		return err
	}
	if o.DialContext != nil {
		_ptr_pvDialContext := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			// FIXME unknown type pvDialContext
			return nil
		})
		if err := w.WritePointer(&o.DialContext, _ptr_pvDialContext); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.TTLTooLow); err != nil {
		return err
	}
	if err := w.WriteData(o.FragNeeded); err != nil {
		return err
	}
	if err := w.WriteData(o.OutPackets); err != nil {
		return err
	}
	if err := w.WriteData(o.OutDiscards); err != nil {
		return err
	}
	if err := w.WriteTrailingGap(9); err != nil {
		return err
	}
	return nil
}
func (o *MIBIPMulticastOutgoingInterfaceStats) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.OutInterfaceIndex); err != nil {
		return err
	}
	if err := w.ReadData(&o.NextHopAddr); err != nil {
		return err
	}
	_ptr_pvDialContext := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		// FIXME: unknown type pvDialContext
		return nil
	})
	_s_pvDialContext := func(ptr interface{}) { o.DialContext = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.DialContext, _s_pvDialContext, _ptr_pvDialContext); err != nil {
		return err
	}
	if err := w.ReadData(&o.TTLTooLow); err != nil {
		return err
	}
	if err := w.ReadData(&o.FragNeeded); err != nil {
		return err
	}
	if err := w.ReadData(&o.OutPackets); err != nil {
		return err
	}
	if err := w.ReadData(&o.OutDiscards); err != nil {
		return err
	}
	if err := w.ReadTrailingGap(9); err != nil {
		return err
	}
	return nil
}

// MIBIPMulticastMulticastForwardingEntryStats structure represents MIB_IPMCAST_MFE_STATS RPC structure.
//
// The MIB_IPMCAST_MFE_STATS structure stores the statistics associated with an MFE.
//
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwGroup                                                                                                                       |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwSource                                                                                                                      |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwSrcMask                                                                                                                     |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwUpStrmNgbr                                                                                                                  |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwInIfIndex                                                                                                                   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwInIfProtocol                                                                                                                |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwRouteProtocol                                                                                                               |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwRouteNetwork                                                                                                                |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwRouteMask                                                                                                                   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ulUpTime                                                                                                                      |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ulExpiryTime                                                                                                                  |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ulNumOutIf                                                                                                                    |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ulInPkts                                                                                                                      |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ulInOctets                                                                                                                    |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ulPktsDifferentIf                                                                                                             |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ulQueueOverflow                                                                                                               |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| rgmiosOutStats (variable)                                                                                                     |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
type MIBIPMulticastMulticastForwardingEntryStats struct {
	// dwGroup (4 bytes): The multicast group for this MFE. A value of zero (0) indicates
	// a wildcard group.
	Group uint32 `idl:"name:dwGroup" json:"group"`
	// dwSource (4 bytes): The range of source addresses for this MFE. A value of zero (0)
	// indicates a wildcard source.
	Source uint32 `idl:"name:dwSource" json:"source"`
	// dwSrcMask (4 bytes): The IPv4 subnet mask that corresponds to the dwSource. The dwSource
	// and the dwSrcMask members are used together to define a range of sources.
	SourceMask uint32 `idl:"name:dwSrcMask" json:"source_mask"`
	// dwUpStrmNgbr (4 bytes): The upstream neighbor that is related to this MFE.
	UpstreamNeighbor uint32 `idl:"name:dwUpStrmNgbr" json:"upstream_neighbor"`
	// dwInIfIndex (4 bytes): The index of the incoming interface that is related to this
	// MFE.
	InInterfaceIndex uint32 `idl:"name:dwInIfIndex" json:"in_interface_index"`
	// dwInIfProtocol (4 bytes): The routing protocol that owns the incoming interface that
	// is related to this MFE.
	InInterfaceProtocol uint32 `idl:"name:dwInIfProtocol" json:"in_interface_protocol"`
	// dwRouteProtocol (4 bytes): The protocol that created the route. It is the enum MIB_IPFORWARD_PROTO
	// (section 2.2.1.1.9).
	RouteProtocol uint32 `idl:"name:dwRouteProtocol" json:"route_protocol"`
	// dwRouteNetwork (4 bytes): The address associated with the route referred to by the
	// dwRouteProtocol.
	RouteNetwork uint32 `idl:"name:dwRouteNetwork" json:"route_network"`
	// dwRouteMask (4 bytes): The mask associated with the route referred to by the dwRouteProtocol.
	RouteMask uint32 `idl:"name:dwRouteMask" json:"route_mask"`
	// ulUpTime (4 bytes): The time, in 100ths of a second, since the MFE was created.
	UpTime uint32 `idl:"name:ulUpTime" json:"up_time"`
	// ulExpiryTime (4 bytes): The time, in 100ths of a second, until the MFE will be deleted.
	// A value of zero (0) is specified if the MFE is not subject to aging requirements.
	ExpiryTime uint32 `idl:"name:ulExpiryTime" json:"expiry_time"`
	// ulNumOutIf (4 bytes): The number of interfaces in the outgoing interface list for
	// this MFE.
	NumOutInterface uint32 `idl:"name:ulNumOutIf" json:"num_out_interface"`
	// ulInPkts (4 bytes): The number of packets that have been forwarded that matched this
	// MFE.
	InPackets uint32 `idl:"name:ulInPkts" json:"in_packets"`
	// ulInOctets (4 bytes): The number of octets of data forwarded that match this MFE.
	InOctets uint32 `idl:"name:ulInOctets" json:"in_octets"`
	// ulPktsDifferentIf (4 bytes): The number of packets matching this MFE that were dropped
	// due to an incoming interface check.
	PacketsDifferentInterface uint32 `idl:"name:ulPktsDifferentIf" json:"packets_different_interface"`
	// ulQueueOverflow (4 bytes): The number of packets matching this MFE that were dropped
	// due to a queue overflow. There is one queue per MFE.
	QueueOverflow uint32 `idl:"name:ulQueueOverflow" json:"queue_overflow"`
	// rgmiosOutStats (variable): A pointer to a table of outgoing interface statistics
	// that are implemented as an array of MIB_IPMCAST_OIF_STATS (section 2.2.1.2.45) structures.
	// The number of entries in the table is specified by the value of the ulNumOutIf member.
	OutStats []*MIBIPMulticastOutgoingInterfaceStats `idl:"name:rgmiosOutStats" json:"out_stats"`
}

func (o *MIBIPMulticastMulticastForwardingEntryStats) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBIPMulticastMulticastForwardingEntryStats) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.Group); err != nil {
		return err
	}
	if err := w.WriteData(o.Source); err != nil {
		return err
	}
	if err := w.WriteData(o.SourceMask); err != nil {
		return err
	}
	if err := w.WriteData(o.UpstreamNeighbor); err != nil {
		return err
	}
	if err := w.WriteData(o.InInterfaceIndex); err != nil {
		return err
	}
	if err := w.WriteData(o.InInterfaceProtocol); err != nil {
		return err
	}
	if err := w.WriteData(o.RouteProtocol); err != nil {
		return err
	}
	if err := w.WriteData(o.RouteNetwork); err != nil {
		return err
	}
	if err := w.WriteData(o.RouteMask); err != nil {
		return err
	}
	if err := w.WriteData(o.UpTime); err != nil {
		return err
	}
	if err := w.WriteData(o.ExpiryTime); err != nil {
		return err
	}
	if err := w.WriteData(o.NumOutInterface); err != nil {
		return err
	}
	if err := w.WriteData(o.InPackets); err != nil {
		return err
	}
	if err := w.WriteData(o.InOctets); err != nil {
		return err
	}
	if err := w.WriteData(o.PacketsDifferentInterface); err != nil {
		return err
	}
	if err := w.WriteData(o.QueueOverflow); err != nil {
		return err
	}
	for i1 := range o.OutStats {
		i1 := i1
		if uint64(i1) >= 1 {
			break
		}
		if o.OutStats[i1] != nil {
			if err := o.OutStats[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MIBIPMulticastOutgoingInterfaceStats{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.OutStats); uint64(i1) < 1; i1++ {
		if err := (&MIBIPMulticastOutgoingInterfaceStats{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MIBIPMulticastMulticastForwardingEntryStats) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.Group); err != nil {
		return err
	}
	if err := w.ReadData(&o.Source); err != nil {
		return err
	}
	if err := w.ReadData(&o.SourceMask); err != nil {
		return err
	}
	if err := w.ReadData(&o.UpstreamNeighbor); err != nil {
		return err
	}
	if err := w.ReadData(&o.InInterfaceIndex); err != nil {
		return err
	}
	if err := w.ReadData(&o.InInterfaceProtocol); err != nil {
		return err
	}
	if err := w.ReadData(&o.RouteProtocol); err != nil {
		return err
	}
	if err := w.ReadData(&o.RouteNetwork); err != nil {
		return err
	}
	if err := w.ReadData(&o.RouteMask); err != nil {
		return err
	}
	if err := w.ReadData(&o.UpTime); err != nil {
		return err
	}
	if err := w.ReadData(&o.ExpiryTime); err != nil {
		return err
	}
	if err := w.ReadData(&o.NumOutInterface); err != nil {
		return err
	}
	if err := w.ReadData(&o.InPackets); err != nil {
		return err
	}
	if err := w.ReadData(&o.InOctets); err != nil {
		return err
	}
	if err := w.ReadData(&o.PacketsDifferentInterface); err != nil {
		return err
	}
	if err := w.ReadData(&o.QueueOverflow); err != nil {
		return err
	}
	o.OutStats = make([]*MIBIPMulticastOutgoingInterfaceStats, 1)
	for i1 := range o.OutStats {
		i1 := i1
		if o.OutStats[i1] == nil {
			o.OutStats[i1] = &MIBIPMulticastOutgoingInterfaceStats{}
		}
		if err := o.OutStats[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// MIBIPMulticastScope structure represents MIB_IPMCAST_SCOPE RPC structure.
//
// The MIB_IPMCAST_SCOPE structure contains a multicast scope name and the associated
// IPv4 multicast group address and mask that define the scope. This structure is used
// in MIB_OPAQUE_INFO (section 2.2.1.2.52) structure.
type MIBIPMulticastScope struct {
	// dwGroupAddress: A 32-bit integer representation of the IPv4 group address which,
	// when combined with the corresponding value in dwGroupMask, identifies the group range
	// for which the multicast scope exists.
	GroupAddress uint32 `idl:"name:dwGroupAddress" json:"group_address"`
	// dwGroupMask: A 32-bit integer representation of the IPv4 group address mask which,
	// when combined with the corresponding value in dwGroupAddress, identifies the group
	// range for which the multicast scope exists.
	GroupMask uint32 `idl:"name:dwGroupMask" json:"group_mask"`
	// snNameBuffer: A Unicode string, suitable for display to multicast application users,
	// that contains the text name associated with the multicast scope.
	NameBuffer []uint16 `idl:"name:snNameBuffer" json:"name_buffer"`
	// dwStatus: A status value that describes the current status of this row in an MFE
	// scope table.
	//
	//	+------------+---------------------------------+
	//	|            |                                 |
	//	|   VALUE    |             MEANING             |
	//	|            |                                 |
	//	+------------+---------------------------------+
	//	+------------+---------------------------------+
	//	| 0x00000001 | Row has an active status.       |
	//	+------------+---------------------------------+
	//	| 0x00000002 | Row has a notInService status.  |
	//	+------------+---------------------------------+
	//	| 0x00000003 | Row has a notReady status.      |
	//	+------------+---------------------------------+
	//	| 0x00000004 | Row has a createAndGo status.   |
	//	+------------+---------------------------------+
	//	| 0x00000005 | Row has a createAndWait status. |
	//	+------------+---------------------------------+
	//	| 0x00000006 | Row has a destroy status.       |
	//	+------------+---------------------------------+
	Status uint32 `idl:"name:dwStatus" json:"status"`
	// reserved: An array of 492 bytes that SHOULD be set to 0 and ignored on receive.
	_ []byte `idl:"name:reserved"`
}

func (o *MIBIPMulticastScope) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBIPMulticastScope) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.GroupAddress); err != nil {
		return err
	}
	if err := w.WriteData(o.GroupMask); err != nil {
		return err
	}
	for i1 := range o.NameBuffer {
		i1 := i1
		if uint64(i1) >= 256 {
			break
		}
		if err := w.WriteData(o.NameBuffer[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.NameBuffer); uint64(i1) < 256; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Status); err != nil {
		return err
	}
	// reserved reserved
	for i1 := 0; uint64(i1) < 492; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteTrailingGap(4); err != nil {
		return err
	}
	return nil
}
func (o *MIBIPMulticastScope) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.GroupAddress); err != nil {
		return err
	}
	if err := w.ReadData(&o.GroupMask); err != nil {
		return err
	}
	o.NameBuffer = make([]uint16, 256)
	for i1 := range o.NameBuffer {
		i1 := i1
		if err := w.ReadData(&o.NameBuffer[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.Status); err != nil {
		return err
	}
	// reserved reserved
	var _reserved []byte
	_reserved = make([]byte, 492)
	for i1 := range _reserved {
		i1 := i1
		if err := w.ReadData(&_reserved[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadTrailingGap(4); err != nil {
		return err
	}
	return nil
}

// MIBIPNetRow structure represents MIB_IPNETROW RPC structure.
//
// The MIB_IPNETROW structure contains information for an Address Resolution Protocol
// (ARP) table entry for an IPv4 address. This structure is used in MIB_OPAQUE_INFO
// (section 2.2.1.2.52) structure.
type MIBIPNetRow struct {
	// dwIndex: This MUST be the interface index of an adapter.
	Index uint32 `idl:"name:dwIndex" json:"index"`
	// dwPhysAddrLen: The length, in bytes, of the physical address.
	PhysicalAddrLength uint32 `idl:"name:dwPhysAddrLen" json:"physical_addr_length"`
	// bPhysAddr: The physical address.
	PhysicalAddr []byte `idl:"name:bPhysAddr" json:"physical_addr"`
	// dwAddr: The IPv4 address.
	Addr uint32 `idl:"name:dwAddr" json:"addr"`
	// dwType: The type of ARP entry. This type MUST be one of the following values.
	//
	//	+------------+---------+
	//	|            |         |
	//	|   VALUE    | MEANING |
	//	|            |         |
	//	+------------+---------+
	//	+------------+---------+
	//	| 0x00000001 | Other   |
	//	+------------+---------+
	//	| 0x00000002 | Invalid |
	//	+------------+---------+
	//	| 0x00000003 | Dynamic |
	//	+------------+---------+
	//	| 0x00000004 | Static  |
	//	+------------+---------+
	Type uint32 `idl:"name:dwType" json:"type"`
}

func (o *MIBIPNetRow) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBIPNetRow) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Index); err != nil {
		return err
	}
	if err := w.WriteData(o.PhysicalAddrLength); err != nil {
		return err
	}
	for i1 := range o.PhysicalAddr {
		i1 := i1
		if uint64(i1) >= 8 {
			break
		}
		if err := w.WriteData(o.PhysicalAddr[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.PhysicalAddr); uint64(i1) < 8; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Addr); err != nil {
		return err
	}
	if err := w.WriteData(o.Type); err != nil {
		return err
	}
	return nil
}
func (o *MIBIPNetRow) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Index); err != nil {
		return err
	}
	if err := w.ReadData(&o.PhysicalAddrLength); err != nil {
		return err
	}
	o.PhysicalAddr = make([]byte, 8)
	for i1 := range o.PhysicalAddr {
		i1 := i1
		if err := w.ReadData(&o.PhysicalAddr[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.Addr); err != nil {
		return err
	}
	if err := w.ReadData(&o.Type); err != nil {
		return err
	}
	return nil
}

// MIBIPNetTable structure represents MIB_IPNETTABLE RPC structure.
//
// The MIB_IPNETTABLE structure contains a table of ARP entries for IPv4 addresses.
type MIBIPNetTable struct {
	// dwNumEntries: The number of ARP entries in the table.
	EntriesLength uint32 `idl:"name:dwNumEntries" json:"entries_length"`
	// table: A pointer to a table of ARP entries implemented as an array of MIB_IPNETROW
	// (section 2.2.1.2.47) structures.
	Table []*MIBIPNetRow `idl:"name:table" json:"table"`
	// reserved: An array of 8 bytes that SHOULD be set to 0 and ignored on receipt.
	_ []byte `idl:"name:reserved"`
}

func (o *MIBIPNetTable) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBIPNetTable) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.EntriesLength); err != nil {
		return err
	}
	for i1 := range o.Table {
		i1 := i1
		if uint64(i1) >= 1 {
			break
		}
		if o.Table[i1] != nil {
			if err := o.Table[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MIBIPNetRow{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.Table); uint64(i1) < 1; i1++ {
		if err := (&MIBIPNetRow{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// reserved reserved
	for i1 := 0; uint64(i1) < 8; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteTrailingGap(4); err != nil {
		return err
	}
	return nil
}
func (o *MIBIPNetTable) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntriesLength); err != nil {
		return err
	}
	o.Table = make([]*MIBIPNetRow, 1)
	for i1 := range o.Table {
		i1 := i1
		if o.Table[i1] == nil {
			o.Table[i1] = &MIBIPNetRow{}
		}
		if err := o.Table[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// reserved reserved
	var _reserved []byte
	_reserved = make([]byte, 8)
	for i1 := range _reserved {
		i1 := i1
		if err := w.ReadData(&_reserved[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadTrailingGap(4); err != nil {
		return err
	}
	return nil
}

// MIBIPStats structure represents MIB_IPSTATS RPC structure.
//
// The MIB_IPSTATS structure stores information about the IP protocol running on a specific
// computer. This structure is used in MIB_OPAQUE_INFO (section 2.2.1.2.52) structure.
type MIBIPStats struct {
	// Forwarding: Specifies whether IP forwarding is enabled or disabled.<36>
	Forwarding MIBIPStatsForwarding `idl:"name:Forwarding" json:"forwarding"`
	// dwDefaultTTL: The default initial TTL for datagrams originating on a specific computer.
	// This value MUST be 0xFFFFFFFF or a value less than or equal to 255.
	DefaultTTL uint32 `idl:"name:dwDefaultTTL" json:"default_ttl"`
	// dwInReceives: The number of datagrams received. This is a read-only field and MUST
	// be ignored while writing.
	InReceives uint32 `idl:"name:dwInReceives" json:"in_receives"`
	// dwInHdrErrors: The number of datagrams received that have header errors. This is
	// a read-only field and MUST be ignored while writing.
	InHdrErrors uint32 `idl:"name:dwInHdrErrors" json:"in_hdr_errors"`
	// dwInAddrErrors: The number of datagrams received that have address errors. This is
	// a read-only field and MUST be ignored while writing.
	InAddrErrors uint32 `idl:"name:dwInAddrErrors" json:"in_addr_errors"`
	// dwForwDatagrams: The number of datagrams forwarded. This is a read-only field and
	// MUST be ignored while writing.
	ForwDatagrams uint32 `idl:"name:dwForwDatagrams" json:"forw_datagrams"`
	// dwInUnknownProtos: The number of datagrams received that have an unknown protocol.
	// This is a read-only field and MUST be ignored while writing.
	InUnknownProtos uint32 `idl:"name:dwInUnknownProtos" json:"in_unknown_protos"`
	// dwInDiscards: The number of received datagrams discarded. This is a read-only field
	// and MUST be ignored while writing.
	InDiscards uint32 `idl:"name:dwInDiscards" json:"in_discards"`
	// dwInDelivers: The number of received datagrams delivered. This is a read-only field
	// and MUST be ignored while writing.
	InDelivers uint32 `idl:"name:dwInDelivers" json:"in_delivers"`
	// dwOutRequests: The number of outgoing datagrams that the IP is requested to transmit.
	// This number does not include forwarded datagrams. This is a read-only field and MUST
	// be ignored while writing.
	OutRequests uint32 `idl:"name:dwOutRequests" json:"out_requests"`
	// dwRoutingDiscards: The number of outgoing datagrams discarded. This is a read-only
	// field and MUST be ignored while writing.
	RoutingDiscards uint32 `idl:"name:dwRoutingDiscards" json:"routing_discards"`
	// dwOutDiscards: The number of transmitted datagrams to be discarded. This is a read-only
	// field and MUST be ignored while writing.
	OutDiscards uint32 `idl:"name:dwOutDiscards" json:"out_discards"`
	// dwOutNoRoutes: The number of datagrams for which this computer did not have a route
	// to the destination IP address. These datagrams were discarded. This is a read-only
	// field and MUST be ignored while writing.
	OutNoRoutes uint32 `idl:"name:dwOutNoRoutes" json:"out_no_routes"`
	// dwReasmTimeout: The amount of time allowed for all pieces of a fragmented datagram
	// to arrive. If all pieces do not arrive within this time, the datagram is discarded.
	// This is a read-only field and MUST be ignored while writing.
	ReasmTimeout uint32 `idl:"name:dwReasmTimeout" json:"reasm_timeout"`
	// dwReasmReqds: The number of datagrams that require reassembly. This is a read-only
	// field and MUST be ignored while writing.
	ReasmReqds uint32 `idl:"name:dwReasmReqds" json:"reasm_reqds"`
	// dwReasmOks: The number of datagrams that were successfully reassembled. This is a
	// read-only field and MUST be ignored while writing.
	ReasmOKs uint32 `idl:"name:dwReasmOks" json:"reasm_oks"`
	// dwReasmFails: The number of datagrams that cannot be reassembled. This is a read-only
	// field and MUST be ignored while writing.
	ReasmFails uint32 `idl:"name:dwReasmFails" json:"reasm_fails"`
	// dwFragOks: The number of datagrams that were fragmented successfully. This is a read-only
	// field and MUST be ignored while writing.
	FragOKs uint32 `idl:"name:dwFragOks" json:"frag_oks"`
	// dwFragFails: The number of datagrams that have not been fragmented because the IP
	// header specifies no fragmentation. These datagrams are discarded. This is a read-only
	// field and MUST be ignored while writing.
	FragFails uint32 `idl:"name:dwFragFails" json:"frag_fails"`
	// dwFragCreates: The number of fragments created. This is a read-only field and MUST
	// be ignored while writing.
	FragCreates uint32 `idl:"name:dwFragCreates" json:"frag_creates"`
	// dwNumIf: The number of interfaces. This is a read-only field and MUST be ignored
	// while writing.
	InterfaceLength uint32 `idl:"name:dwNumIf" json:"interface_length"`
	// dwNumAddr: The number of IP addresses associated with this computer. This is a read-only
	// field and MUST be ignored while writing.
	AddrLength uint32 `idl:"name:dwNumAddr" json:"addr_length"`
	// dwNumRoutes: The number of routes in the IP routing table. This is a read-only field
	// and MUST be ignored while writing.
	RoutesLength uint32 `idl:"name:dwNumRoutes" json:"routes_length"`
}

func (o *MIBIPStats) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBIPStats) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteEnum(uint16(o.Forwarding)); err != nil {
		return err
	}
	if err := w.WriteData(o.DefaultTTL); err != nil {
		return err
	}
	if err := w.WriteData(o.InReceives); err != nil {
		return err
	}
	if err := w.WriteData(o.InHdrErrors); err != nil {
		return err
	}
	if err := w.WriteData(o.InAddrErrors); err != nil {
		return err
	}
	if err := w.WriteData(o.ForwDatagrams); err != nil {
		return err
	}
	if err := w.WriteData(o.InUnknownProtos); err != nil {
		return err
	}
	if err := w.WriteData(o.InDiscards); err != nil {
		return err
	}
	if err := w.WriteData(o.InDelivers); err != nil {
		return err
	}
	if err := w.WriteData(o.OutRequests); err != nil {
		return err
	}
	if err := w.WriteData(o.RoutingDiscards); err != nil {
		return err
	}
	if err := w.WriteData(o.OutDiscards); err != nil {
		return err
	}
	if err := w.WriteData(o.OutNoRoutes); err != nil {
		return err
	}
	if err := w.WriteData(o.ReasmTimeout); err != nil {
		return err
	}
	if err := w.WriteData(o.ReasmReqds); err != nil {
		return err
	}
	if err := w.WriteData(o.ReasmOKs); err != nil {
		return err
	}
	if err := w.WriteData(o.ReasmFails); err != nil {
		return err
	}
	if err := w.WriteData(o.FragOKs); err != nil {
		return err
	}
	if err := w.WriteData(o.FragFails); err != nil {
		return err
	}
	if err := w.WriteData(o.FragCreates); err != nil {
		return err
	}
	if err := w.WriteData(o.InterfaceLength); err != nil {
		return err
	}
	if err := w.WriteData(o.AddrLength); err != nil {
		return err
	}
	if err := w.WriteData(o.RoutesLength); err != nil {
		return err
	}
	return nil
}
func (o *MIBIPStats) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadEnum((*uint16)(&o.Forwarding)); err != nil {
		return err
	}
	if err := w.ReadData(&o.DefaultTTL); err != nil {
		return err
	}
	if err := w.ReadData(&o.InReceives); err != nil {
		return err
	}
	if err := w.ReadData(&o.InHdrErrors); err != nil {
		return err
	}
	if err := w.ReadData(&o.InAddrErrors); err != nil {
		return err
	}
	if err := w.ReadData(&o.ForwDatagrams); err != nil {
		return err
	}
	if err := w.ReadData(&o.InUnknownProtos); err != nil {
		return err
	}
	if err := w.ReadData(&o.InDiscards); err != nil {
		return err
	}
	if err := w.ReadData(&o.InDelivers); err != nil {
		return err
	}
	if err := w.ReadData(&o.OutRequests); err != nil {
		return err
	}
	if err := w.ReadData(&o.RoutingDiscards); err != nil {
		return err
	}
	if err := w.ReadData(&o.OutDiscards); err != nil {
		return err
	}
	if err := w.ReadData(&o.OutNoRoutes); err != nil {
		return err
	}
	if err := w.ReadData(&o.ReasmTimeout); err != nil {
		return err
	}
	if err := w.ReadData(&o.ReasmReqds); err != nil {
		return err
	}
	if err := w.ReadData(&o.ReasmOKs); err != nil {
		return err
	}
	if err := w.ReadData(&o.ReasmFails); err != nil {
		return err
	}
	if err := w.ReadData(&o.FragOKs); err != nil {
		return err
	}
	if err := w.ReadData(&o.FragFails); err != nil {
		return err
	}
	if err := w.ReadData(&o.FragCreates); err != nil {
		return err
	}
	if err := w.ReadData(&o.InterfaceLength); err != nil {
		return err
	}
	if err := w.ReadData(&o.AddrLength); err != nil {
		return err
	}
	if err := w.ReadData(&o.RoutesLength); err != nil {
		return err
	}
	return nil
}

// MIBMulticastForwardingEntryStatsTable structure represents MIB_MFE_STATS_TABLE RPC structure.
//
// The MIB_MFE_STATS_TABLE structure stores statistics for a group of MFEs. This structure
// is used in MIB_OPAQUE_INFO (section 2.2.1.2.52) structure.
//
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwNumEntries                                                                                                                  |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| table (variable)                                                                                                              |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
type MIBMulticastForwardingEntryStatsTable struct {
	// dwNumEntries (4 bytes): The number of MFEs in the table.
	EntriesLength uint32 `idl:"name:dwNumEntries" json:"entries_length"`
	// table (variable): A pointer to a table of MFEs that are implemented as an array of
	// MIB_IPMCAST_MFE_STATS (section 2.2.1.2.44) structures.
	Table []*MIBIPMulticastMulticastForwardingEntryStats `idl:"name:table" json:"table"`
}

func (o *MIBMulticastForwardingEntryStatsTable) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBMulticastForwardingEntryStatsTable) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.EntriesLength); err != nil {
		return err
	}
	for i1 := range o.Table {
		i1 := i1
		if uint64(i1) >= 1 {
			break
		}
		if o.Table[i1] != nil {
			if err := o.Table[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MIBIPMulticastMulticastForwardingEntryStats{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.Table); uint64(i1) < 1; i1++ {
		if err := (&MIBIPMulticastMulticastForwardingEntryStats{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MIBMulticastForwardingEntryStatsTable) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntriesLength); err != nil {
		return err
	}
	o.Table = make([]*MIBIPMulticastMulticastForwardingEntryStats, 1)
	for i1 := range o.Table {
		i1 := i1
		if o.Table[i1] == nil {
			o.Table[i1] = &MIBIPMulticastMulticastForwardingEntryStats{}
		}
		if err := o.Table[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// MIBMulticastForwardingEntryTable structure represents MIB_MFE_TABLE RPC structure.
//
// The MIB_MFE_TABLE structure contains a table of MFEs. This structure is used in MIB_OPAQUE_INFO
// (section 2.2.1.2.52) structure.
//
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwNumEntries                                                                                                                  |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| table (variable)                                                                                                              |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
type MIBMulticastForwardingEntryTable struct {
	// dwNumEntries (4 bytes): The number of MFEs in the table.
	EntriesLength uint32 `idl:"name:dwNumEntries" json:"entries_length"`
	// table (variable): A pointer to a table of MFEs implemented as an array of MIB_IPMCAST_MFE
	// (section 2.2.1.2.42) structures.
	Table []*MIBIPMulticastMulticastForwardingEntry `idl:"name:table" json:"table"`
}

func (o *MIBMulticastForwardingEntryTable) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBMulticastForwardingEntryTable) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.EntriesLength); err != nil {
		return err
	}
	for i1 := range o.Table {
		i1 := i1
		if uint64(i1) >= 1 {
			break
		}
		if o.Table[i1] != nil {
			if err := o.Table[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MIBIPMulticastMulticastForwardingEntry{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.Table); uint64(i1) < 1; i1++ {
		if err := (&MIBIPMulticastMulticastForwardingEntry{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MIBMulticastForwardingEntryTable) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntriesLength); err != nil {
		return err
	}
	o.Table = make([]*MIBIPMulticastMulticastForwardingEntry, 1)
	for i1 := range o.Table {
		i1 := i1
		if o.Table[i1] == nil {
			o.Table[i1] = &MIBIPMulticastMulticastForwardingEntry{}
		}
		if err := o.Table[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// MIBOpaqueInfo structure represents MIB_OPAQUE_INFO RPC structure.
//
// The MIB_OPAQUE_INFO structure contains information related to an MIB entry. This
// structure is used to handle MIB data in MIB methods such as the following:
//
// * *RMIBEntryCreate (section 3.1.4.27)* ( 4a8dc1a9-4b2a-4eba-bd0e-df9e8dc97908 )
//
// * *RMIBEntrySet (section 3.1.4.29)* ( 61ae7aea-8604-4bf3-8ae5-88542152cf8e )
//
// * *RMIBEntryGet (section 3.1.4.30)* ( ebc5c709-36d8-4520-a0ac-6f36d2d6c0b2 )
//
// * *RMIBEntryGetFirst (section 3.1.4.31)* ( 9102e585-2f62-4408-bfb6-02a6460cc883 )
//
// * *RMIBEntryGetNext (section 3.1.4.32)* ( 50f78033-d248-4272-b4b9-a2519a0f304d )
//
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwId                                                                                                                          |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ullAlign                                                                                                                      |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| rgbyData                                                                                                                      |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
type MIBOpaqueInfo struct {
	// dwId (4 bytes): MIB ID for the type of information being submitted or returned. IPX
	// does not use this structure. For IP transport, the MIB ID MUST be one of the following
	// values.
	//
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	|             DWID              |                                                                                  |                          STRUCTURE TO BE POINTED TO BY                           |
	//	|             VALUE             |                                     MEANING                                      |                                     RGBYDATA                                     |
	//	|                               |                                                                                  |                                                                                  |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IF_NUMBER 0x00000000          | Information about number of interfaces on the server.                            | MIB_IFNUMBER (section 2.2.1.2.28)                                                |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IF_TABLE 0x00000001           | Table of interface entries.                                                      | MIB_IFTABLE (section 2.2.1.2.31)                                                 |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IF_ROW 0x00000002             | Information about a particular interface.                                        | MIB_IFROW (section 2.2.1.2.29)                                                   |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_STATS 0x00000003           | Information about the IP protocol.                                               | MIB_IPSTATS (section 2.2.1.2.49)                                                 |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_ADDRTABLE 0x00000004       | Table of IPv4 address entries.                                                   | MIB_IPADDRTABLE (section 2.2.1.2.33)                                             |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_ADDRROW 0x00000005         | Information for a particular IPv4 address.                                       | MIB_IPADDRROW (section 2.2.1.2.32)                                               |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_FORWARDNUMBER 0x00000006   | Information about number of routes in a particular IP routing table.             | MIB_IPFORWARDNUMBER (section 2.2.1.2.34)                                         |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_FORWARDTABLE 0x00000007    | Table of IPv4 route entries.                                                     | MIB_IPFORWARDTABLE (section 2.2.1.2.36)                                          |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_FORWARDROW 0x00000008      | Information that describes an IPv4/IPv6 network route.                           | MIB_IPFORWARDROW (section 2.2.1.2.35) for IPv4, INTERFACE_ROUTE_ENTRY (section   |
	//	|                               |                                                                                  | 2.2.1.2.181) for IPv6 based on the transport                                     |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_NETTABLE 0x00000009        | Table of ARP entries for IPv4 addresses.                                         | MIB_IPNETTABLE (section 2.2.1.2.48)                                              |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_NETROW 0x0000000A          | Information about an ARP table entry for an IPv4 address.                        | MIB_IPNETROW (section 2.2.1.2.47)                                                |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| ICMP_STATS 0x0000000B         | Statistics for ICMP messages on a particular computer.                           | MIB_ICMP (section 2.2.1.2.25)                                                    |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| TCP_STATS 0x0000000C          | Statistics for the TCP protocol running on the local computer.                   | MIB_TCPSTATS (section 2.2.1.2.56)                                                |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| TCP_TABLE 0x0000000D          | Table of IPv4 TCP connections.                                                   | MIB_TCPTABLE (section 2.2.1.2.57)                                                |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| TCP_ROW 0x0000000E            | Information for an IPv4 TCP connection.                                          | MIB_TCPROW (section 2.2.1.2.55)                                                  |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| UDP_STATS 0x0000000F          | Statistics for the UDP running on the local computer.                            | MIB_UDPSTATS (section 2.2.1.2.59)                                                |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| UDP_TABLE 0x00000010          | Table of address information for sending and receiving UDP datagrams.            | MIB_UDPTABLE (section 2.2.1.2.60)                                                |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| UDP_ROW 0x00000011            | Information for a UDP session.                                                   | MIB_UDPROW (section 2.2.1.2.58)                                                  |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MCAST_MFE 0x00000012          | Information for an IP multicast forwarding entry.                                | MIB_MFE_TABLE (section 2.2.1.2.51). rgbyData SHOULD be specified as NULL         |
	//	|                               |                                                                                  | when the requested IP multicast forwarding entry is not found when using the     |
	//	|                               |                                                                                  | RMIBEntryGet, RMIBEntryGetFirst, and RMIBEntryGetNext methods. These methods     |
	//	|                               |                                                                                  | return ERROR_SUCCESS even if they do not find the requested IP multicast         |
	//	|                               |                                                                                  | forwarding entry.                                                                |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MCAST_MFE_STATS 0x00000013    | Statistics associated with an MFE.                                               | MIB_MFE_STATS_TABLE (section 2.2.1.2.50)                                         |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| BEST_IF 0x00000014            | Information about the interface that has the best route to a particular          | MIB_BEST_IF (section 2.2.1.2.23)                                                 |
	//	|                               | destination IPv4 address.                                                        |                                                                                  |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| BEST_ROUTE 0x00000015         | Information about a particular route.                                            | INTERFACE_ROUTE_INFO (section 2.2.1.2.11)                                        |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| PROXY_ARP 0x00000016          | Information for a Proxy Address Resolution Protocol (PARP) entry.                | MIB_PROXYARP (section 2.2.1.2.54)                                                |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MCAST_IF_ENTRY 0x00000017     | Information about an IP multicast interface.                                     | MIB_IPMCAST_IF_ENTRY (section 2.2.1.2.40)                                        |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MCAST_GLOBAL 0x00000018       | Global information for IP multicast on a particular computer.                    | MIB_IPMCAST_GLOBAL (section 2.2.1.2.39)                                          |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IF_STATUS 0x00000019          | Status information for a particular interface.                                   | MIB_IFSTATUS (section 2.2.1.2.30)                                                |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MCAST_BOUNDARY 0x0000001A     | Information about a router's scoped IPv4 multicast address boundaries.           | MIB_IPMCAST_BOUNDARY (section 2.2.1.2.37)                                        |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MCAST_SCOPE 0x0000001B        | Information about a multicast scope.                                             | MIB_IPMCAST_SCOPE (section 2.2.1.2.46)                                           |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| DEST_MATCHING 0x0000001C      | Route information about a matching destination.                                  | MIB_IPDESTTABLE (section 2.2.1.2.21)                                             |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| DEST_LONGER 0x0000001D        | Information about all the possible routes to a destination.                      | MIB_IPDESTTABLE (section 2.2.1.2.21)                                             |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| DEST_SHORTER 0x0000001E       | Information about the best matching routes to a destination.                     | MIB_IPDESTTABLE (section 2.2.1.2.21)                                             |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| ROUTE_MATCHING 0x0000001F     | Information about a matching IP route.                                           | MIB_IPDESTTABLE (section 2.2.1.2.21)                                             |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| ROUTE_LONGER 0x00000020       | Information about all the possible routes to a destination.                      | MIB_IPDESTTABLE (section 2.2.1.2.21)                                             |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| ROUTE_SHORTER 0x00000021      | Information about the best matching routes to a destination.                     | MIB_IPDESTTABLE (section 2.2.1.2.21)                                             |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| ROUTE_STATE 0x00000022        | Information about whether the route needs to be added to the forwarder or not.   | MIB_ROUTESTATE (section 2.2.1.2.22)                                              |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MCAST_MFE_STATS_EX 0x00000023 | Statistics associated with an MFE.                                               | MIB_MFE_STATS_TABLE (section 2.2.1.2.50)                                         |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	ID uint32 `idl:"name:dwId" json:"id"`
	// ullAlign (4 bytes): The number of bytes that align the information returned. This
	// is used to align the field to a long boundary so that the structure is aligned.
	Align uint64 `idl:"name:ullAlign" json:"align"`
}

func (o *MIBOpaqueInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBOpaqueInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if err := w.WriteData(o.ID); err != nil {
		return err
	}
	if err := w.WriteData(o.Align); err != nil {
		return err
	}
	return nil
}
func (o *MIBOpaqueInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if err := w.ReadData(&o.ID); err != nil {
		return err
	}
	if err := w.ReadData(&o.Align); err != nil {
		return err
	}
	return nil
}

// MIBOpaqueQuery structure represents MIB_OPAQUE_QUERY RPC structure.
//
// The MIB_OPAQUE_QUERY structure contains the MIB ID and the corresponding index of
// the MIB object. This structure is used in the following methods:
//
// * *RMIBEntryGet (section 3.1.4.30)* ( ebc5c709-36d8-4520-a0ac-6f36d2d6c0b2 )
//
// * *RMIBEntryDelete (section 3.1.4.28)* ( a8ed0e17-9395-4aef-9f4e-9b3e93cf3f4c )
//
// * *RMIBEntryGetFirst (section 3.1.4.31)* ( 9102e585-2f62-4408-bfb6-02a6460cc883 )
//
// * *RMIBEntryGetNext (section 3.1.4.32)* ( 50f78033-d248-4272-b4b9-a2519a0f304d )
//
// The same structure is also used as a blob for querying MIB if dwPid is PID_IPX, or
// if dwPid is PID_IP and dwRoutingPid is not IPRTRMGR_PID (0x00002710) in the parameter
// of the methods using this structure.
//
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwVarId                                                                                                                       |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| rgdwVarIndex (variable)                                                                                                       |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
type MIBOpaqueQuery struct {
	// dwVarId (4 bytes): The identifier of the MIB object while querying IPv4 or IPv6 MIB
	// variables. The value MUST be the same as dwId for MIB_OPAQUE_INFO (section 2.2.1.2.52)
	// structure.
	VarID uint32 `idl:"name:dwVarId" json:"var_id"`
	// rgdwVarIndex (variable): Place holder for data of the blob as previously mentioned.
	// If dwRoutingPid is IPRTRMGR_PID (0x00002710), then this MUST indicate the index of
	// the MIB object to query as shown in the following table.
	//
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	|                               |                                                                                  |                            STRUCTURE THAT NEEDS TO BE                            |                                    MEANING OF                                    |
	//	|            DWVARID            |                                   RGDWVARINDEX                                   |                                    RETRIEVED                                     |                                   RGDWVARINDEX                                   |
	//	|                               |                                                                                  |                                                                                  |                                                                                  |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IF_NUMBER 0x00000000          | Not used.                                                                        | MIB_IFNUMBER (section 2.2.1.2.28)                                                | Not used.                                                                        |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IF_TABLE 0x00000001           | Not used.                                                                        | MIB_IFTABLE (section 2.2.1.2.31)                                                 | Not used.                                                                        |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IF_ROW 0x00000002             | Index of the interface.                                                          | MIB_IFROW (section 2.2.1.2.29)                                                   | The instance of the structure whose interface index matches with the value       |
	//	|                               |                                                                                  |                                                                                  | specified in rgdwVarIndex.                                                       |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_STATS 0x00000003           | Not used.                                                                        | MIB_IPSTATS (section 2.2.1.2.49)                                                 | Not used.                                                                        |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000004 IP_ADDRTABLE       | Not used.                                                                        | MIB_IPADDRTABLE (section 2.2.1.2.33)                                             | Not used.                                                                        |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_ADDRROW 0x00000005         | IP address.                                                                      | MIB_IPADDRROW (section 2.2.1.2.32)                                               | The instance of the structure whose dwAddr matches the value specified in        |
	//	|                               |                                                                                  |                                                                                  | rgdwVarIndex.                                                                    |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_FORWARDNUMBER 0x00000006   | Not used.                                                                        | MIB_IPFORWARDNUMBER (section 2.2.1.2.34)                                         | Not used.                                                                        |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_FORWARDTABLE 0x00000007    | Not used.                                                                        | MIB_IPFORWARDTABLE (section 2.2.1.2.36)                                          | Not used.                                                                        |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_FORWARDROW 0x00000008      | This MUST be of 4 DWORDS size (rgdwVarIndex[4]) for IPV4. For IPV6 this MUST be  | MIB_IPFORWARDROW (section 2.2.1.2.35) for IPv4, INTERFACE_ROUTE_ENTRY (section   | For IPv4, the instance of the structure whose dwForwardDest matches              |
	//	|                               | index.                                                                           | 2.2.1.2.181) for IPv6                                                            | rgdwVarIndex[0], dwForwardProto matches rgdwVarIndex[1], dwForwardPolicy matches |
	//	|                               |                                                                                  |                                                                                  | rgdwVarIndex[2], and dwForwardNextHop matches rgdwVarIndex[3]. For IPv6, the     |
	//	|                               |                                                                                  |                                                                                  | instance of the structure whose dwIndex matches rgdwVarIndex.                    |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_NETTABLE 0x00000009        | MUST be of size one DWORD (rgdwVarIndex[1]) or two DWORDS (rgdwVarIndex[2]).     | MIB_IPNETTABLE (section 2.2.1.2.48)                                              | If one DWORD is passed, an instance of the structure whose dwIndex matches       |
	//	|                               |                                                                                  |                                                                                  | the value specified in rgdwVarIndex[0] is returned. If two DWORDs are passed,    |
	//	|                               |                                                                                  |                                                                                  | an instance of the structure whose dwIndex matches the value specified in        |
	//	|                               |                                                                                  |                                                                                  | rgdwVarIndex[0] and whose dwAddr matches rgdwVarIndex[1] is returned.            |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_NETROW 0x0000000A          | This MUST be of size one DWORD (rgdwVarIndex[1]) or two DWORDS                   | MIB_IPNETROW (section 2.2.1.2.47)                                                | If one DWORD is passed, an instance of the structure whose dwIndex matches       |
	//	|                               | (rgdwVarIndex[2]).                                                               |                                                                                  | the value specified in rgdwVarIndex[0] is returned. If two DWORDs are passed,    |
	//	|                               |                                                                                  |                                                                                  | an instance of the structure whose dwIndex matches the value specified in        |
	//	|                               |                                                                                  |                                                                                  | rgdwVarIndex[0] and whose dwAddr matches rgdwVarIndex[1] is returned.            |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| ICMP_STATS 0x0000000B         | Not used.                                                                        | MIB_ICMP (section 2.2.1.2.25)                                                    | Not used.                                                                        |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| TCP_STATS 0x0000000C          | Not used.                                                                        | MIB_TCPSTATS (section 2.2.1.2.56)                                                | Not used.                                                                        |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| TCP_ROW 0x0000000E            | This MUST be of 4 DWORDS size (rgdwVarIndex[4]) for IPV4.                        | MIB_TCPROW (section 2.2.1.2.55)                                                  | The instance of the structure whose dwLocalAddr matches rgdwVarIndex[0],         |
	//	|                               |                                                                                  |                                                                                  | dwLocalPort matches rgdwVarIndex[1], dwRemoteAddr matches rgdwVarIndex[2], and   |
	//	|                               |                                                                                  |                                                                                  | dwRemotePort matches rgdwVarIndex[3].                                            |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| UDP_STATS 0x0000000F          | Not used.                                                                        | MIB_UDPSTATS (section 2.2.1.2.59)                                                | Not used.                                                                        |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| UDP_TABLE 0x00000010          | Not used.                                                                        | MIB_UDPTABLE (section 2.2.1.2.60)                                                | Not used.                                                                        |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| UDP_ROW 0x00000011            | This MUST be of size one DWORD (rgdwVarIndex[1]) or two DWORDS                   | MIB_UDPROW (section 2.2.1.2.58)                                                  | If one DWORD is passed, an instance of the structure whose dwLocalAddr           |
	//	|                               | (rgdwVarIndex[2]).                                                               |                                                                                  | matches the value specified in rgdwVarIndex[0] is returned. If two DWORDs        |
	//	|                               |                                                                                  |                                                                                  | are passed, an instance of the structure whose dwLocalAddr matches the value     |
	//	|                               |                                                                                  |                                                                                  | specified in rgdwVarIndex[0] and whose dwLocalPort matches the value specified   |
	//	|                               |                                                                                  |                                                                                  | in rgdwVarIndex[1]. Both dwLocalAddr and dwLocalPort MUST be specified for       |
	//	|                               |                                                                                  |                                                                                  | RMIBEntryGet.                                                                    |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MCAST_MFE 0x00000012          | This MUST be of 3 DWORDS size (rgdwVarIndex[3]).                                 | MIB_MFE_TABLE (section 2.2.1.2.51)                                               | The instance of the structure whose dwGroup matches rgdwVarIndex[0], dwSource    |
	//	|                               |                                                                                  |                                                                                  | matches rgdwVarIndex[1], dwSrcMask matches rgdwVarIndex[2] is returned, and      |
	//	|                               |                                                                                  |                                                                                  | rgdwVarIndex[2] MUST be 0xFFFFFFFF.                                              |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MCAST_MFE_STATS 0x00000013    | This MUST be of 3 DWORDS size (rgdwVarIndex[3]).                                 | MIB_IPMCAST_MFE_STATS (section 2.2.1.2.44)                                       | The instance of the structure whose dwGroup matches rgdwVarIndex[0], dwSource    |
	//	|                               |                                                                                  |                                                                                  | matches rgdwVarIndex[1], dwSrcMask matches rgdwVarIndex[2] is returned, and      |
	//	|                               |                                                                                  |                                                                                  | rgdwVarIndex[2] MUST be 0xFFFFFFFF.                                              |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| BEST_IF 0x00000014            | MUST be of 1 DWORDS size (rgdwVarIndex[1]).                                      | MIB_BEST_IF (section 2.2.1.2.23)                                                 | The interface having the best route for the destination specified in             |
	//	|                               |                                                                                  |                                                                                  | rgdwVarIndex[0] is returned.                                                     |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| BEST_ROUTE 0x00000015         | MUST be of 2 DWORDS size (rgdwVarIndex[2])                                       | INTERFACE_ROUTE_INFO (section 2.2.1.2.11)                                        | The best route information for the destination specified in rgdwVarIndex[0] is   |
	//	|                               |                                                                                  |                                                                                  | returned; rgdwVarIndex[1] MUST be set to 0.                                      |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MCAST_IF_ENTRY 0x00000017     | MUST be of 1 DWORDS size (rgdwVarIndex[1]).                                      | MIB_IPMCAST_IF_ENTRY (section 2.2.1.2.40)                                        | The instance of the structure whose interface index matches with the value       |
	//	|                               |                                                                                  |                                                                                  | specified in rgdwVarIndex.                                                       |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MCAST_GLOBAL 0x00000018       | Not used.                                                                        | MIB_IPMCAST_GLOBAL (section 2.2.1.2.39)                                          | Not used.                                                                        |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IF_STATUS 0x00000019          | MUST be of 1 DWORDS size (rgdwVarIndex[1]).                                      | MIB_IFSTATUS (section 2.2.1.2.30)                                                | The instance of the structure whose interface index matches with the value       |
	//	|                               |                                                                                  |                                                                                  | specified in rgdwVarIndex.                                                       |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MCAST_BOUNDARY 0x0000001A     | MUST be of 3 DWORDS size (rgdwVarIndex[3]).                                      | MIB_IPMCAST_BOUNDARY (section 2.2.1.2.37)                                        | The instance with dwIfIndex equal to rgdwVarIndex[0], dwGroupAddress equal to    |
	//	|                               |                                                                                  |                                                                                  | rgdwVarIndex[1], and dwGroupMask equal to  rgdwVarIndex[2] is returned.          |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MCAST_SCOPE 0x0000001B        | MUST be of size one DWORD (rgdwVarIndex[1]) or two DWORDS (rgdwVarIndex[2]).     | MIB_IPMCAST_SCOPE (section 2.2.1.2.46)                                           | If one DWORD is passed, an instance of the structure whose dwGroupAddress        |
	//	|                               |                                                                                  |                                                                                  | matches the value specified in rgdwVarIndex[0] is returned. If two DWORDs are    |
	//	|                               |                                                                                  |                                                                                  | passed, an instance of the structure whose dwGroupAddress matches the value      |
	//	|                               |                                                                                  |                                                                                  | specified in rgdwVarIndex[0] and whose dwGroupMask matches rgdwVarIndex[1]       |
	//	|                               |                                                                                  |                                                                                  | is returned. Both dwGroupAddress and dwGroupMask MUST be specified for           |
	//	|                               |                                                                                  |                                                                                  | RMIBEntryGet.                                                                    |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| DEST_MATCHING 0x0000001C      | MUST be of 4 DWORDS size (rgdwVarIndex[4]).                                      | MIB_IPDESTTABLE (section 2.2.1.2.21)                                             | The instance of the structure whose ForwardRow fields of dwForwardDest matches   |
	//	|                               |                                                                                  |                                                                                  | rgdwVarIndex[0], dwForwardMask matches rgdwVarIndex[1], dwForwardViewSet matches |
	//	|                               |                                                                                  |                                                                                  | rgdwVarIndex[2], and whose dwForwardProto matches rgdwVarIndex[3].               |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| DEST_LONGER 0x0000001D        | MUST be of 4 DWORDS size (rgdwVarIndex[4]).                                      | MIB_IPDESTTABLE (section 2.2.1.2.21)                                             | The instance of the structure whose ForwardRow fields of dwForwardDest matches   |
	//	|                               |                                                                                  |                                                                                  | rgdwVarIndex[0], dwForwardMask matches rgdwVarIndex[1], dwForwardViewSet matches |
	//	|                               |                                                                                  |                                                                                  | rgdwVarIndex[2], and whose dwForwardProto matches rgdwVarIndex[3].               |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| DEST_SHORTER 0x0000001E       | MUST be of 4 DWORDS size (rgdwVarIndex[4]).                                      | MIB_IPDESTTABLE (section 2.2.1.2.21)                                             | The instance of the structure whose ForwardRow fields of dwForwardDest matches   |
	//	|                               |                                                                                  |                                                                                  | rgdwVarIndex[0], dwForwardMask matches rgdwVarIndex[1], dwForwardViewSet matches |
	//	|                               |                                                                                  |                                                                                  | rgdwVarIndex[2], and whose dwForwardProto matches rgdwVarIndex[3].               |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| ROUTE_MATCHING 0x0000001F     | This MUST be of 4 DWORDS size (rgdwVarIndex[4]).                                 | MIB_IPDESTTABLE (section 2.2.1.2.21)                                             | The instance of the structure whose ForwardRow fields of dwForwardDest matches   |
	//	|                               |                                                                                  |                                                                                  | rgdwVarIndex[0], dwForwardMask matches rgdwVarIndex[1], dwForwardViewSet matches |
	//	|                               |                                                                                  |                                                                                  | rgdwVarIndex[2], and whose dwForwardProto matches rgdwVarIndex[3].               |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| ROUTE_LONGER 0x00000020       | MUST be of 4 DWORDS size (rgdwVarIndex[4]).                                      | MIB_IPDESTTABLE (section 2.2.1.2.21)                                             | The instance of the structure whose ForwardRow fields of dwForwardDest matches   |
	//	|                               |                                                                                  |                                                                                  | rgdwVarIndex[0], dwForwardMask matches rgdwVarIndex[1], dwForwardViewSet matches |
	//	|                               |                                                                                  |                                                                                  | rgdwVarIndex[2], and whose dwForwardProto matches rgdwVarIndex[3].               |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| ROUTE_SHORTER 0x00000021      | MUST be of 4 DWORDS size (rgdwVarIndex[4]).                                      | MIB_IPDESTTABLE (section 2.2.1.2.21)                                             | The instance of the structure whose ForwardRow fields of dwForwardDest matches   |
	//	|                               |                                                                                  |                                                                                  | rgdwVarIndex[0], dwForwardMask matches rgdwVarIndex[1], dwForwardViewSet matches |
	//	|                               |                                                                                  |                                                                                  | rgdwVarIndex[2], and whose dwForwardProto matches rgdwVarIndex[3].               |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| ROUTE_STATE 0x00000022        | Not used.                                                                        | MIB_ROUTESTATE (section 2.2.1.2.22)                                              | Not used.                                                                        |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MCAST_MFE_STATS_EX 0x00000023 | MUST be of 3 DWORDS size (rgdwVarIndex[3]).                                      | MIB_MFE_STATS_TABLE (section 2.2.1.2.50)                                         | The instance of the structure whose dwGroup field matches rgdwVarIndex[0],       |
	//	|                               |                                                                                  |                                                                                  | dwSource matches rgdwVarIndex[1], and rgdwVarIndex[2] is not used.               |
	//	+-------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
	VarIndex []uint32 `idl:"name:rgdwVarIndex" json:"var_index"`
}

func (o *MIBOpaqueQuery) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBOpaqueQuery) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.VarID); err != nil {
		return err
	}
	for i1 := range o.VarIndex {
		i1 := i1
		if uint64(i1) >= 1 {
			break
		}
		if err := w.WriteData(o.VarIndex[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.VarIndex); uint64(i1) < 1; i1++ {
		if err := w.WriteData(uint32(0)); err != nil {
			return err
		}
	}
	return nil
}
func (o *MIBOpaqueQuery) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.VarID); err != nil {
		return err
	}
	o.VarIndex = make([]uint32, 1)
	for i1 := range o.VarIndex {
		i1 := i1
		if err := w.ReadData(&o.VarIndex[i1]); err != nil {
			return err
		}
	}
	return nil
}

// MIBProxyArp structure represents MIB_PROXYARP RPC structure.
//
// The MIB_PROXYARP structure stores information for a Proxy Address Resolution Protocol
// (PARP) entry. This structure is used in MIB_OPAQUE_INFO (section 2.2.1.2.52).
type MIBProxyArp struct {
	// dwAddress: The IPv4 address that acts as a proxy.
	Address uint32 `idl:"name:dwAddress" json:"address"`
	// dwMask: The subnet mask for the IPv4 address specified by the dwAddress member. See
	// [RFC950].
	Mask uint32 `idl:"name:dwMask" json:"mask"`
	// dwIfIndex: The index of the interface that acts as a proxy for the address specified
	// by the dwAddress member.
	InterfaceIndex uint32 `idl:"name:dwIfIndex" json:"interface_index"`
}

func (o *MIBProxyArp) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBProxyArp) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Address); err != nil {
		return err
	}
	if err := w.WriteData(o.Mask); err != nil {
		return err
	}
	if err := w.WriteData(o.InterfaceIndex); err != nil {
		return err
	}
	return nil
}
func (o *MIBProxyArp) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Address); err != nil {
		return err
	}
	if err := w.ReadData(&o.Mask); err != nil {
		return err
	}
	if err := w.ReadData(&o.InterfaceIndex); err != nil {
		return err
	}
	return nil
}

// MIBTCPRow structure represents MIB_TCPROW RPC structure.
//
// The MIB_TCPROW structure contains information for an IPv4 TCP connection. This structure
// is used in the following structures:
//
// * *MIB_OPAQUE_INFO* (section 2.2.1.2.52 ( 169e435d-a975-4c1c-bf41-55fd2bd76125 )
// )
//
// * *MIB_TCPTABLE* (section 2.2.1.2.57 ( e944eb35-ab38-41af-9b9a-384d0b3e11a3 ) )
//
// typedef struct _MIB_TCPROW {
//
// union {
//
// DWORD dwState;
//
// MIB_TCP_STATE State;
//
// };
//
// DWORD dwLocalAddr;
//
// DWORD dwLocalPort;
//
// DWORD dwRemoteAddr;
//
// DWORD dwRemotePort;
//
// } MIB_TCPROW,
type MIBTCPRow struct {
	// State: The state of the TCP connection.<37>
	State MIBTCPState `idl:"name:State" json:"state"`
	// dwLocalAddr: The local IPv4 address for the TCP connection on the local computer.
	// A value of zero (0) indicates the listener can accept a connection on any interface.
	LocalAddr uint32 `idl:"name:dwLocalAddr" json:"local_addr"`
	// dwLocalPort: The local port number in network byte order for the TCP connection on
	// the local computer.
	LocalPort uint32 `idl:"name:dwLocalPort" json:"local_port"`
	// dwRemoteAddr: The IPv4 address for the TCP connection on the remote computer.
	RemoteAddr uint32 `idl:"name:dwRemoteAddr" json:"remote_addr"`
	// dwRemotePort: The remote port number in network byte order for the TCP connection
	// on the remote computer.
	RemotePort uint32 `idl:"name:dwRemotePort" json:"remote_port"`
}

func (o *MIBTCPRow) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBTCPRow) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteEnum(uint16(o.State)); err != nil {
		return err
	}
	if err := w.WriteData(o.LocalAddr); err != nil {
		return err
	}
	if err := w.WriteData(o.LocalPort); err != nil {
		return err
	}
	if err := w.WriteData(o.RemoteAddr); err != nil {
		return err
	}
	if err := w.WriteData(o.RemotePort); err != nil {
		return err
	}
	return nil
}
func (o *MIBTCPRow) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadEnum((*uint16)(&o.State)); err != nil {
		return err
	}
	if err := w.ReadData(&o.LocalAddr); err != nil {
		return err
	}
	if err := w.ReadData(&o.LocalPort); err != nil {
		return err
	}
	if err := w.ReadData(&o.RemoteAddr); err != nil {
		return err
	}
	if err := w.ReadData(&o.RemotePort); err != nil {
		return err
	}
	return nil
}

// MIBTCPStats structure represents MIB_TCPSTATS RPC structure.
//
// The MIB_TCPSTATS structure contains statistics for the TCP protocol running on the
// local computer. This structure is used in MIB_OPAQUE_INFO (section 2.2.1.2.52) structure.
type MIBTCPStats struct {
	// RtoAlgorithm: The RTO algorithm in use.<38>
	RTOAlgorithm TCPRTOAlgorithm `idl:"name:RtoAlgorithm" json:"rto_algorithm"`
	// dwRtoMin: The minimum RTO value in milliseconds.
	RTOMin uint32 `idl:"name:dwRtoMin" json:"rto_min"`
	// dwRtoMax: The maximum RTO value in milliseconds.
	RTOMax uint32 `idl:"name:dwRtoMax" json:"rto_max"`
	// dwMaxConn: The maximum number of connections. If this member is -1, the maximum number
	// of connections is variable.
	MaxConn uint32 `idl:"name:dwMaxConn" json:"max_conn"`
	// dwActiveOpens: The number of active open connections. In an active open, the client
	// is initiating a connection with the server.
	ActiveOpens uint32 `idl:"name:dwActiveOpens" json:"active_opens"`
	// dwPassiveOpens: The number of passive open connections. In a passive open, the server
	// is listening for a connection request from a client.
	PassiveOpens uint32 `idl:"name:dwPassiveOpens" json:"passive_opens"`
	// dwAttemptFails: The number of failed connection attempts.
	AttemptFails uint32 `idl:"name:dwAttemptFails" json:"attempt_fails"`
	// dwEstabResets: The number of established connections that were reset.
	EstabResets uint32 `idl:"name:dwEstabResets" json:"estab_resets"`
	// dwCurrEstab: The number of currently established connections.
	CurrentEstab uint32 `idl:"name:dwCurrEstab" json:"current_estab"`
	// dwInSegs: The number of segments received.
	InSegs uint32 `idl:"name:dwInSegs" json:"in_segs"`
	// dwOutSegs: The number of segments transmitted. This number does not include retransmitted
	// segments.
	OutSegs uint32 `idl:"name:dwOutSegs" json:"out_segs"`
	// dwRetransSegs: The number of segments retransmitted.
	RetransimitSegs uint32 `idl:"name:dwRetransSegs" json:"retransimit_segs"`
	// dwInErrs: The number of errors received.
	InErrs uint32 `idl:"name:dwInErrs" json:"in_errs"`
	// dwOutRsts: The number of segments transmitted with the reset flag set.
	OutRsts uint32 `idl:"name:dwOutRsts" json:"out_rsts"`
	// dwNumConns: The number of connections that are currently present in the system. This
	// total number includes connections in all states except listening connections.
	ConnsLength uint32 `idl:"name:dwNumConns" json:"conns_length"`
}

func (o *MIBTCPStats) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBTCPStats) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteEnum(uint16(o.RTOAlgorithm)); err != nil {
		return err
	}
	if err := w.WriteData(o.RTOMin); err != nil {
		return err
	}
	if err := w.WriteData(o.RTOMax); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxConn); err != nil {
		return err
	}
	if err := w.WriteData(o.ActiveOpens); err != nil {
		return err
	}
	if err := w.WriteData(o.PassiveOpens); err != nil {
		return err
	}
	if err := w.WriteData(o.AttemptFails); err != nil {
		return err
	}
	if err := w.WriteData(o.EstabResets); err != nil {
		return err
	}
	if err := w.WriteData(o.CurrentEstab); err != nil {
		return err
	}
	if err := w.WriteData(o.InSegs); err != nil {
		return err
	}
	if err := w.WriteData(o.OutSegs); err != nil {
		return err
	}
	if err := w.WriteData(o.RetransimitSegs); err != nil {
		return err
	}
	if err := w.WriteData(o.InErrs); err != nil {
		return err
	}
	if err := w.WriteData(o.OutRsts); err != nil {
		return err
	}
	if err := w.WriteData(o.ConnsLength); err != nil {
		return err
	}
	return nil
}
func (o *MIBTCPStats) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadEnum((*uint16)(&o.RTOAlgorithm)); err != nil {
		return err
	}
	if err := w.ReadData(&o.RTOMin); err != nil {
		return err
	}
	if err := w.ReadData(&o.RTOMax); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxConn); err != nil {
		return err
	}
	if err := w.ReadData(&o.ActiveOpens); err != nil {
		return err
	}
	if err := w.ReadData(&o.PassiveOpens); err != nil {
		return err
	}
	if err := w.ReadData(&o.AttemptFails); err != nil {
		return err
	}
	if err := w.ReadData(&o.EstabResets); err != nil {
		return err
	}
	if err := w.ReadData(&o.CurrentEstab); err != nil {
		return err
	}
	if err := w.ReadData(&o.InSegs); err != nil {
		return err
	}
	if err := w.ReadData(&o.OutSegs); err != nil {
		return err
	}
	if err := w.ReadData(&o.RetransimitSegs); err != nil {
		return err
	}
	if err := w.ReadData(&o.InErrs); err != nil {
		return err
	}
	if err := w.ReadData(&o.OutRsts); err != nil {
		return err
	}
	if err := w.ReadData(&o.ConnsLength); err != nil {
		return err
	}
	return nil
}

// MIBTCPTable structure represents MIB_TCPTABLE RPC structure.
//
// The MIB_TCPTABLE structure contains a table of IPv4 TCP connections on the local
// computer.
type MIBTCPTable struct {
	// dwNumEntries: The number of entries in the table.
	EntriesLength uint32 `idl:"name:dwNumEntries" json:"entries_length"`
	// table: A pointer to a table of TCP connections implemented as an array of MIB_TCPROW
	// (section 2.2.1.2.55) structures.
	Table []*MIBTCPRow `idl:"name:table" json:"table"`
	// reserved: An array of 8 bytes that SHOULD be set to 0 and ignored on receipt.
	_ []byte `idl:"name:reserved"`
}

func (o *MIBTCPTable) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBTCPTable) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.EntriesLength); err != nil {
		return err
	}
	for i1 := range o.Table {
		i1 := i1
		if uint64(i1) >= 1 {
			break
		}
		if o.Table[i1] != nil {
			if err := o.Table[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MIBTCPRow{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.Table); uint64(i1) < 1; i1++ {
		if err := (&MIBTCPRow{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// reserved reserved
	for i1 := 0; uint64(i1) < 8; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteTrailingGap(4); err != nil {
		return err
	}
	return nil
}
func (o *MIBTCPTable) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntriesLength); err != nil {
		return err
	}
	o.Table = make([]*MIBTCPRow, 1)
	for i1 := range o.Table {
		i1 := i1
		if o.Table[i1] == nil {
			o.Table[i1] = &MIBTCPRow{}
		}
		if err := o.Table[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// reserved reserved
	var _reserved []byte
	_reserved = make([]byte, 8)
	for i1 := range _reserved {
		i1 := i1
		if err := w.ReadData(&_reserved[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadTrailingGap(4); err != nil {
		return err
	}
	return nil
}

// MIBUDPRow structure represents MIB_UDPROW RPC structure.
//
// The MIB_UDPROW structure contains address information for sending and receiving User
// Datagram Protocol (UDP) datagrams. This structure is used in the following structures:
//
// * *MIB_OPAQUE_INFO* (section 2.2.1.2.52 ( 169e435d-a975-4c1c-bf41-55fd2bd76125 )
// )
//
// * *MIB_UDPTABLE* (section 2.2.1.2.60 ( 3994ba16-51a1-4e1c-801e-f3ea2d01fd74 ) )
//
// typedef struct _MIB_UDPROW {
//
// DWORD dwLocalAddr;
//
// DWORD dwLocalPort;
//
// } MIB_UDPROW,
type MIBUDPRow struct {
	// dwLocalAddr: The IPv4 address on the local computer.
	LocalAddr uint32 `idl:"name:dwLocalAddr" json:"local_addr"`
	// dwLocalPort: The port number on the local computer.
	LocalPort uint32 `idl:"name:dwLocalPort" json:"local_port"`
}

func (o *MIBUDPRow) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBUDPRow) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.LocalAddr); err != nil {
		return err
	}
	if err := w.WriteData(o.LocalPort); err != nil {
		return err
	}
	return nil
}
func (o *MIBUDPRow) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.LocalAddr); err != nil {
		return err
	}
	if err := w.ReadData(&o.LocalPort); err != nil {
		return err
	}
	return nil
}

// MIBUDPStats structure represents MIB_UDPSTATS RPC structure.
//
// The MIB_UDPSTATS structure contains statistics for the UDP running on the local computer.
// This structure is used in MIB_OPAQUE_INFO (section 2.2.1.2.52) structure.
type MIBUDPStats struct {
	// dwInDatagrams: The number of datagrams received.
	InDatagrams uint32 `idl:"name:dwInDatagrams" json:"in_datagrams"`
	// dwNoPorts: The number of datagrams received that were discarded because the port
	// specified was invalid.
	NoPorts uint32 `idl:"name:dwNoPorts" json:"no_ports"`
	// dwInErrors: The number of erroneous datagrams received. This number does not include
	// the value contained by the dwNoPorts member.
	InErrors uint32 `idl:"name:dwInErrors" json:"in_errors"`
	// dwOutDatagrams: The number of datagrams transmitted.
	OutDatagrams uint32 `idl:"name:dwOutDatagrams" json:"out_datagrams"`
	// dwNumAddrs: The number of entries in the UDP listener table.
	AddrsLength uint32 `idl:"name:dwNumAddrs" json:"addrs_length"`
}

func (o *MIBUDPStats) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBUDPStats) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.InDatagrams); err != nil {
		return err
	}
	if err := w.WriteData(o.NoPorts); err != nil {
		return err
	}
	if err := w.WriteData(o.InErrors); err != nil {
		return err
	}
	if err := w.WriteData(o.OutDatagrams); err != nil {
		return err
	}
	if err := w.WriteData(o.AddrsLength); err != nil {
		return err
	}
	return nil
}
func (o *MIBUDPStats) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.InDatagrams); err != nil {
		return err
	}
	if err := w.ReadData(&o.NoPorts); err != nil {
		return err
	}
	if err := w.ReadData(&o.InErrors); err != nil {
		return err
	}
	if err := w.ReadData(&o.OutDatagrams); err != nil {
		return err
	}
	if err := w.ReadData(&o.AddrsLength); err != nil {
		return err
	}
	return nil
}

// MIBUDPTable structure represents MIB_UDPTABLE RPC structure.
//
// The MIB_UDPTABLE structure contains a table of address information for sending and
// receiving UDP datagrams on the local computer.
type MIBUDPTable struct {
	// dwNumEntries: The number of entries in the table.
	EntriesLength uint32 `idl:"name:dwNumEntries" json:"entries_length"`
	// table: Pointer to an array of MIB_UDPROW (section 2.2.1.2.58) structures.
	Table []*MIBUDPRow `idl:"name:table" json:"table"`
	// reserved: An array of 8 bytes that SHOULD be set to 0 and ignored on receipt.
	_ []byte `idl:"name:reserved"`
}

func (o *MIBUDPTable) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBUDPTable) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.EntriesLength); err != nil {
		return err
	}
	for i1 := range o.Table {
		i1 := i1
		if uint64(i1) >= 1 {
			break
		}
		if o.Table[i1] != nil {
			if err := o.Table[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MIBUDPRow{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.Table); uint64(i1) < 1; i1++ {
		if err := (&MIBUDPRow{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// reserved reserved
	for i1 := 0; uint64(i1) < 8; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteTrailingGap(4); err != nil {
		return err
	}
	return nil
}
func (o *MIBUDPTable) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntriesLength); err != nil {
		return err
	}
	o.Table = make([]*MIBUDPRow, 1)
	for i1 := range o.Table {
		i1 := i1
		if o.Table[i1] == nil {
			o.Table[i1] = &MIBUDPRow{}
		}
		if err := o.Table[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// reserved reserved
	var _reserved []byte
	_reserved = make([]byte, 8)
	for i1 := range _reserved {
		i1 := i1
		if err := w.ReadData(&_reserved[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadTrailingGap(4); err != nil {
		return err
	}
	return nil
}

// Server0 structure represents MPR_SERVER_0 RPC structure.
//
// The MPR_SERVER_0 structure contains configuration information for a router.
type Server0 struct {
	// fLanOnlyMode: This is of type BOOL. It specifies whether the RRAS server is running
	// in LAN only mode or not. If the value is 1, the RRAS server is not routing; if the
	// value is 0, then the RRAS server is functioning as a router.
	//
	//	+-------+---------------------------------------------+
	//	|       |                                             |
	//	| VALUE |                   MEANING                   |
	//	|       |                                             |
	//	+-------+---------------------------------------------+
	//	+-------+---------------------------------------------+
	//	|     0 | The RRAS server is functioning as a router. |
	//	+-------+---------------------------------------------+
	//	|     1 | The RRAS server is not routing.             |
	//	+-------+---------------------------------------------+
	LANOnlyMode bool `idl:"name:fLanOnlyMode" json:"lan_only_mode"`
	// dwUpTime: Specifies the elapsed time (in seconds) since the router was started.
	UpTime uint32 `idl:"name:dwUpTime" json:"up_time"`
	// dwTotalPorts: Specifies the number of ports on the router.
	TotalPorts uint32 `idl:"name:dwTotalPorts" json:"total_ports"`
	// dwPortsInUse: Specifies the number of ports on the router currently in use.
	PortsInUse uint32 `idl:"name:dwPortsInUse" json:"ports_in_use"`
}

func (o *Server0) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *Server0) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if !o.LANOnlyMode {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.UpTime); err != nil {
		return err
	}
	if err := w.WriteData(o.TotalPorts); err != nil {
		return err
	}
	if err := w.WriteData(o.PortsInUse); err != nil {
		return err
	}
	return nil
}
func (o *Server0) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	var _bLANOnlyMode int32
	if err := w.ReadData(&_bLANOnlyMode); err != nil {
		return err
	}
	o.LANOnlyMode = _bLANOnlyMode != 0
	if err := w.ReadData(&o.UpTime); err != nil {
		return err
	}
	if err := w.ReadData(&o.TotalPorts); err != nil {
		return err
	}
	if err := w.ReadData(&o.PortsInUse); err != nil {
		return err
	}
	return nil
}

// Server1 structure represents MPR_SERVER_1 RPC structure.
//
// The MPR_SERVER_1 structure is used to get and set the number of Point-to-Point Tunneling
// Protocol/Layer Two Tunneling Protocol (PPTP/L2TP) ports configured on the RRAS server.
// It is also used to get and set the RRAS functionality and router functionality enabled
// on those ports.
type Server1 struct {
	// dwNumPptpPorts: Specifies the number of ports configured on that (PPTP) device. This
	// value cannot exceed the server port limit.<39>
	PPTPPortsLength uint32 `idl:"name:dwNumPptpPorts" json:"pptp_ports_length"`
	// dwPptpPortFlags: Indicates the RRAS server and/or router functionality configured
	// on the PPTP device. Possible flag values are as follows.
	//
	//	+-----------------------------------------+------------------------------------+
	//	|                                         |                                    |
	//	|                  VALUE                  |              MEANING               |
	//	|                                         |                                    |
	//	+-----------------------------------------+------------------------------------+
	//	+-----------------------------------------+------------------------------------+
	//	| MPR_ENABLE_RAS_ON_DEVICE 0x00000001     | Remote access is enabled for PPTP. |
	//	+-----------------------------------------+------------------------------------+
	//	| MPR_ENABLE_ROUTING_ON_DEVICE 0x00000002 | Routing is enabled for PPTP.       |
	//	+-----------------------------------------+------------------------------------+
	PPTPPortFlags uint32 `idl:"name:dwPptpPortFlags" json:"pptp_port_flags"`
	// dwNumL2tpPorts: Specifies the number of ports configured on that (L2TP) device. This
	// value cannot exceed the server port limit.<40>
	L2TPPortsLength uint32 `idl:"name:dwNumL2tpPorts" json:"l2tp_ports_length"`
	// dwL2tpPortFlags: Indicates the RAS and/or router functionality configured on the
	// L2TP device. Possible flag values are as follows.
	//
	//	+-----------------------------------------+------------------------------------+
	//	|                                         |                                    |
	//	|                  VALUE                  |              MEANING               |
	//	|                                         |                                    |
	//	+-----------------------------------------+------------------------------------+
	//	+-----------------------------------------+------------------------------------+
	//	| MPR_ENABLE_RAS_ON_DEVICE 0x00000001     | Remote access is enabled for L2TP. |
	//	+-----------------------------------------+------------------------------------+
	//	| MPR_ENABLE_ROUTING_ON_DEVICE 0x00000002 | Routing is enabled for L2TP.       |
	//	+-----------------------------------------+------------------------------------+
	L2TPPortFlags uint32 `idl:"name:dwL2tpPortFlags" json:"l2tp_port_flags"`
}

func (o *Server1) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *Server1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.PPTPPortsLength); err != nil {
		return err
	}
	if err := w.WriteData(o.PPTPPortFlags); err != nil {
		return err
	}
	if err := w.WriteData(o.L2TPPortsLength); err != nil {
		return err
	}
	if err := w.WriteData(o.L2TPPortFlags); err != nil {
		return err
	}
	return nil
}
func (o *Server1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.PPTPPortsLength); err != nil {
		return err
	}
	if err := w.ReadData(&o.PPTPPortFlags); err != nil {
		return err
	}
	if err := w.ReadData(&o.L2TPPortsLength); err != nil {
		return err
	}
	if err := w.ReadData(&o.L2TPPortFlags); err != nil {
		return err
	}
	return nil
}

// Server2 structure represents MPR_SERVER_2 RPC structure.
//
// The MPR_SERVER_2 structure<41> is used to get and set the number of Point-to-Point
// Tunneling Protocol/Layer Two Tunneling Protocol/Secure Socket Tunneling Protocol
// (PPTP/L2TP/SSTP) ports configured on the RRAS server. It also gets and sets the RRAS
// functionality and router functionality enabled on the server.
type Server2 struct {
	// dwNumPptpPorts: Specifies the number of ports configured on that (PPTP) device. This
	// value cannot exceed the server port limit.<42>
	PPTPPortsLength uint32 `idl:"name:dwNumPptpPorts" json:"pptp_ports_length"`
	// dwPptpPortFlags: Indicates the RRAS server and/or router functionality configured
	// on the PPTP device. Possible flag values are as follows.
	//
	//	+-----------------------------------------+------------------------------------+
	//	|                                         |                                    |
	//	|                  VALUE                  |              MEANING               |
	//	|                                         |                                    |
	//	+-----------------------------------------+------------------------------------+
	//	+-----------------------------------------+------------------------------------+
	//	| MPR_ENABLE_RAS_ON_DEVICE 0x00000001     | Remote access is enabled for PPTP. |
	//	+-----------------------------------------+------------------------------------+
	//	| MPR_ENABLE_ROUTING_ON_DEVICE 0x00000002 | Routing is enabled for PPTP.       |
	//	+-----------------------------------------+------------------------------------+
	PPTPPortFlags uint32 `idl:"name:dwPptpPortFlags" json:"pptp_port_flags"`
	// dwNumL2tpPorts: Specifies the number of ports configured on that (L2TP) device. This
	// value cannot exceed the server port limit.<43>
	L2TPPortsLength uint32 `idl:"name:dwNumL2tpPorts" json:"l2tp_ports_length"`
	// dwL2tpPortFlags: Indicates the RRAS server and/or router functionality configured
	// on the L2TP device. Possible flag values are as follows.
	//
	//	+-----------------------------------------+------------------------------------+
	//	|                                         |                                    |
	//	|                  VALUE                  |              MEANING               |
	//	|                                         |                                    |
	//	+-----------------------------------------+------------------------------------+
	//	+-----------------------------------------+------------------------------------+
	//	| MPR_ENABLE_RAS_ON_DEVICE 0x00000001     | Remote access is enabled for L2TP. |
	//	+-----------------------------------------+------------------------------------+
	//	| MPR_ENABLE_ROUTING_ON_DEVICE 0x00000002 | Routing is enabled for L2TP.       |
	//	+-----------------------------------------+------------------------------------+
	L2TPPortFlags uint32 `idl:"name:dwL2tpPortFlags" json:"l2tp_port_flags"`
	// dwNumSstpPorts: specifies the number of ports configured on that (SSTP) device. This
	// value cannot exceed the server port limit.<44>
	SSTPPortsLength uint32 `idl:"name:dwNumSstpPorts" json:"sstp_ports_length"`
	// dwSstpPortFlags: indicates the RRAS server and/or router functionality configured
	// on the SSTP device. Possible flag values are as follows.<45>
	//
	//	+-------------------------------------+------------------------------------+
	//	|                                     |                                    |
	//	|                VALUE                |              MEANING               |
	//	|                                     |                                    |
	//	+-------------------------------------+------------------------------------+
	//	+-------------------------------------+------------------------------------+
	//	| MPR_ENABLE_RAS_ON_DEVICE 0x00000001 | Remote access is enabled for SSTP. |
	//	+-------------------------------------+------------------------------------+
	SSTPPortFlags uint32 `idl:"name:dwSstpPortFlags" json:"sstp_port_flags"`
}

func (o *Server2) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *Server2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.PPTPPortsLength); err != nil {
		return err
	}
	if err := w.WriteData(o.PPTPPortFlags); err != nil {
		return err
	}
	if err := w.WriteData(o.L2TPPortsLength); err != nil {
		return err
	}
	if err := w.WriteData(o.L2TPPortFlags); err != nil {
		return err
	}
	if err := w.WriteData(o.SSTPPortsLength); err != nil {
		return err
	}
	if err := w.WriteData(o.SSTPPortFlags); err != nil {
		return err
	}
	return nil
}
func (o *Server2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.PPTPPortsLength); err != nil {
		return err
	}
	if err := w.ReadData(&o.PPTPPortFlags); err != nil {
		return err
	}
	if err := w.ReadData(&o.L2TPPortsLength); err != nil {
		return err
	}
	if err := w.ReadData(&o.L2TPPortFlags); err != nil {
		return err
	}
	if err := w.ReadData(&o.SSTPPortsLength); err != nil {
		return err
	}
	if err := w.ReadData(&o.SSTPPortFlags); err != nil {
		return err
	}
	return nil
}

// PPPNbfcpInfo structure represents PPP_NBFCP_INFO RPC structure.
//
// The PPP_NBFCP_INFO structure MAY<46> be used to contain the result of a PPP NetBEUI
// Framer (NBF) projection operation.
type PPPNbfcpInfo struct {
	// dwError: Specifies the result of the PPP control protocol negotiation. A value of
	// zero (0) indicates success. A nonzero value indicates failure and is the actual fatal
	// error that occurred during the control protocol negotiation.
	Error uint32 `idl:"name:dwError" json:"error"`
	// wszWksta: Specifies a null-terminated Unicode string that is the local workstation's
	// computer name. This unique computer name is the closest NetBIOS equivalent to a client's
	// NetBEUI address on a remote access connection.
	Workstation []uint16 `idl:"name:wszWksta" json:"workstation"`
}

func (o *PPPNbfcpInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *PPPNbfcpInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Error); err != nil {
		return err
	}
	for i1 := range o.Workstation {
		i1 := i1
		if uint64(i1) >= 17 {
			break
		}
		if err := w.WriteData(o.Workstation[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Workstation); uint64(i1) < 17; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	if err := w.WriteTrailingGap(4); err != nil {
		return err
	}
	return nil
}
func (o *PPPNbfcpInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Error); err != nil {
		return err
	}
	o.Workstation = make([]uint16, 17)
	for i1 := range o.Workstation {
		i1 := i1
		if err := w.ReadData(&o.Workstation[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadTrailingGap(4); err != nil {
		return err
	}
	return nil
}

// PPPIPCPInfo structure represents PPP_IPCP_INFO RPC structure.
//
// The PPP_IPCP_INFO structure contains the result of a PPP control protocol negotiation
// for IP.
type PPPIPCPInfo struct {
	// dwError: Specifies the result of the PPP control protocol negotiation. A value of
	// zero (0) indicates success. A nonzero value indicates failure and is the actual fatal
	// error that occurred during the control protocol negotiation.
	Error uint32 `idl:"name:dwError" json:"error"`
	// wszAddress: Specifies a null-terminated Unicode string that holds the local computer's
	// IP address for the connection. This string has the form a.b.c.d; for example, "10.102.235.84".
	Address []uint16 `idl:"name:wszAddress" json:"address"`
	// wszRemoteAddress: Specifies a null-terminated Unicode string that holds the IP address
	// of the remote computer. This string has the form a.b.c.d. If the address is not available,
	// this member is an empty string.
	RemoteAddress []uint16 `idl:"name:wszRemoteAddress" json:"remote_address"`
}

func (o *PPPIPCPInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *PPPIPCPInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Error); err != nil {
		return err
	}
	for i1 := range o.Address {
		i1 := i1
		if uint64(i1) >= 16 {
			break
		}
		if err := w.WriteData(o.Address[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Address); uint64(i1) < 16; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	for i1 := range o.RemoteAddress {
		i1 := i1
		if uint64(i1) >= 16 {
			break
		}
		if err := w.WriteData(o.RemoteAddress[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.RemoteAddress); uint64(i1) < 16; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	if err := w.WriteTrailingGap(4); err != nil {
		return err
	}
	return nil
}
func (o *PPPIPCPInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Error); err != nil {
		return err
	}
	o.Address = make([]uint16, 16)
	for i1 := range o.Address {
		i1 := i1
		if err := w.ReadData(&o.Address[i1]); err != nil {
			return err
		}
	}
	o.RemoteAddress = make([]uint16, 16)
	for i1 := range o.RemoteAddress {
		i1 := i1
		if err := w.ReadData(&o.RemoteAddress[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadTrailingGap(4); err != nil {
		return err
	}
	return nil
}

// PPPIPCPInfo2 structure represents PPP_IPCP_INFO2 RPC structure.
//
// The PPP_IPCP_INFO2 structure contains the result of a PPP control protocol negotiation
// for the IP.
type PPPIPCPInfo2 struct {
	// dwError: See dwError in PPP_IPCP_INFO (section 2.2.1.2.65).
	Error uint32 `idl:"name:dwError" json:"error"`
	// wszAddress: See wszAddress in PPP_IPCP_INFO.
	Address []uint16 `idl:"name:wszAddress" json:"address"`
	// wszRemoteAddress: See wszRemoteAddress in PPP_IPCP_INFO.
	RemoteAddress []uint16 `idl:"name:wszRemoteAddress" json:"remote_address"`
	// dwOptions: Specifies IP Configuration Parameters (IPCP) options for the local computer.
	Options uint32 `idl:"name:dwOptions" json:"options"`
	// dwRemoteOptons: Uses the same values as dwOptions but applies to datagrams received
	// by the local computer.
	RemoteOptons uint32 `idl:"name:dwRemoteOptons" json:"remote_optons"`
}

func (o *PPPIPCPInfo2) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *PPPIPCPInfo2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Error); err != nil {
		return err
	}
	for i1 := range o.Address {
		i1 := i1
		if uint64(i1) >= 16 {
			break
		}
		if err := w.WriteData(o.Address[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Address); uint64(i1) < 16; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	for i1 := range o.RemoteAddress {
		i1 := i1
		if uint64(i1) >= 16 {
			break
		}
		if err := w.WriteData(o.RemoteAddress[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.RemoteAddress); uint64(i1) < 16; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Options); err != nil {
		return err
	}
	if err := w.WriteData(o.RemoteOptons); err != nil {
		return err
	}
	return nil
}
func (o *PPPIPCPInfo2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Error); err != nil {
		return err
	}
	o.Address = make([]uint16, 16)
	for i1 := range o.Address {
		i1 := i1
		if err := w.ReadData(&o.Address[i1]); err != nil {
			return err
		}
	}
	o.RemoteAddress = make([]uint16, 16)
	for i1 := range o.RemoteAddress {
		i1 := i1
		if err := w.ReadData(&o.RemoteAddress[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.Options); err != nil {
		return err
	}
	if err := w.ReadData(&o.RemoteOptons); err != nil {
		return err
	}
	return nil
}

// PPPIpxcpInfo structure represents PPP_IPXCP_INFO RPC structure.
//
// The PPP_IPXCP_INFO structure MAY<47> be used to contain the result of a PPP IPX projection
// operation.
type PPPIpxcpInfo struct {
	// dwError: Specifies the result of the PPP control protocol negotiation. As value of
	// zero (0) indicates success. A nonzero value indicates failure and is the actual fatal
	// error that occurred during the control protocol negotiation.
	Error uint32 `idl:"name:dwError" json:"error"`
	// wszAddress: Specifies a null-terminated Unicode string that holds the client's IPX
	// address on the RRAS server connection. This address string has the form of "net.node"
	// (for example, "1234ABCD.12AB34CD56EF").
	Address []uint16 `idl:"name:wszAddress" json:"address"`
}

func (o *PPPIpxcpInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *PPPIpxcpInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Error); err != nil {
		return err
	}
	for i1 := range o.Address {
		i1 := i1
		if uint64(i1) >= 16 {
			break
		}
		if err := w.WriteData(o.Address[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Address); uint64(i1) < 16; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	if err := w.WriteTrailingGap(4); err != nil {
		return err
	}
	return nil
}
func (o *PPPIpxcpInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Error); err != nil {
		return err
	}
	o.Address = make([]uint16, 16)
	for i1 := range o.Address {
		i1 := i1
		if err := w.ReadData(&o.Address[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadTrailingGap(4); err != nil {
		return err
	}
	return nil
}

// PPPIPv6CreatePartitionInfo structure represents PPP_IPV6_CP_INFO RPC structure.
//
// The PPP_IPV6_CP_INFO structure contains the result of a PPP control protocol negotiation
// for IPv6.
type PPPIPv6CreatePartitionInfo struct {
	// dwVersion: Specifies the version of the PPP_IPV6_CP_INFO structure used. Currently
	// this field is not used and MUST be set to zero (0).
	Version uint32 `idl:"name:dwVersion" json:"version"`
	// dwSize: This SHOULD be set to 0. This MAY be used to specify the size, in bytes,
	// of this PPP_IPV6_CP_INFO structure.
	Size uint32 `idl:"name:dwSize" json:"size"`
	// dwError: Specifies the result of the PPP control protocol negotiation. A value of
	// zero (0) indicates success. A nonzero value indicates failure and is the actual fatal
	// error that occurred during the control protocol negotiation.
	Error uint32 `idl:"name:dwError" json:"error"`
	// bInterfaceIdentifier: Specifies the 64-bit interface identifier of the IPv6 server
	// interface.
	InterfaceID []byte `idl:"name:bInterfaceIdentifier" json:"interface_id"`
	// bRemoteInterfaceIdentifier: Specifies the 64-bit interface identifier of the IPv6
	// client interface.
	RemoteInterfaceID []byte `idl:"name:bRemoteInterfaceIdentifier" json:"remote_interface_id"`
	// dwOptions: Currently this is not used and MUST be set to zero (0).
	Options uint32 `idl:"name:dwOptions" json:"options"`
	// dwRemoteOptions: Currently this is not used and MUST be set to zero (0).
	RemoteOptions uint32 `idl:"name:dwRemoteOptions" json:"remote_options"`
	// bPrefix: Specifies the address prefix of the IPv6 client interface.
	Prefix []byte `idl:"name:bPrefix" json:"prefix"`
	// dwPrefixLength: The length, in bits, of the address prefix.
	PrefixLength uint32 `idl:"name:dwPrefixLength" json:"prefix_length"`
}

func (o *PPPIPv6CreatePartitionInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *PPPIPv6CreatePartitionInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Version); err != nil {
		return err
	}
	if err := w.WriteData(o.Size); err != nil {
		return err
	}
	if err := w.WriteData(o.Error); err != nil {
		return err
	}
	for i1 := range o.InterfaceID {
		i1 := i1
		if uint64(i1) >= 8 {
			break
		}
		if err := w.WriteData(o.InterfaceID[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.InterfaceID); uint64(i1) < 8; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	for i1 := range o.RemoteInterfaceID {
		i1 := i1
		if uint64(i1) >= 8 {
			break
		}
		if err := w.WriteData(o.RemoteInterfaceID[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.RemoteInterfaceID); uint64(i1) < 8; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Options); err != nil {
		return err
	}
	if err := w.WriteData(o.RemoteOptions); err != nil {
		return err
	}
	for i1 := range o.Prefix {
		i1 := i1
		if uint64(i1) >= 8 {
			break
		}
		if err := w.WriteData(o.Prefix[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Prefix); uint64(i1) < 8; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.PrefixLength); err != nil {
		return err
	}
	return nil
}
func (o *PPPIPv6CreatePartitionInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Version); err != nil {
		return err
	}
	if err := w.ReadData(&o.Size); err != nil {
		return err
	}
	if err := w.ReadData(&o.Error); err != nil {
		return err
	}
	o.InterfaceID = make([]byte, 8)
	for i1 := range o.InterfaceID {
		i1 := i1
		if err := w.ReadData(&o.InterfaceID[i1]); err != nil {
			return err
		}
	}
	o.RemoteInterfaceID = make([]byte, 8)
	for i1 := range o.RemoteInterfaceID {
		i1 := i1
		if err := w.ReadData(&o.RemoteInterfaceID[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.Options); err != nil {
		return err
	}
	if err := w.ReadData(&o.RemoteOptions); err != nil {
		return err
	}
	o.Prefix = make([]byte, 8)
	for i1 := range o.Prefix {
		i1 := i1
		if err := w.ReadData(&o.Prefix[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.PrefixLength); err != nil {
		return err
	}
	return nil
}

// PPPATCPInfo structure represents PPP_ATCP_INFO RPC structure.
//
// The PPP_ATCP_INFO structure MAY<48> be used to contain the result of a PPP AppleTalk
// projection operation.
type PPPATCPInfo struct {
	// dwError: Specifies the result of the PPP control protocol negotiation. A value of
	// zero (0) indicates success. A nonzero value indicates failure and is the actual fatal
	// error that occurred during the control protocol negotiation.
	Error uint32 `idl:"name:dwError" json:"error"`
	// wszAddress: Specifies a null-terminated Unicode string that holds the client's AppleTalk
	// address on the RRAS server connection.
	Address []uint16 `idl:"name:wszAddress" json:"address"`
}

func (o *PPPATCPInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *PPPATCPInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Error); err != nil {
		return err
	}
	for i1 := range o.Address {
		i1 := i1
		if uint64(i1) >= 33 {
			break
		}
		if err := w.WriteData(o.Address[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Address); uint64(i1) < 33; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	if err := w.WriteTrailingGap(4); err != nil {
		return err
	}
	return nil
}
func (o *PPPATCPInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Error); err != nil {
		return err
	}
	o.Address = make([]uint16, 33)
	for i1 := range o.Address {
		i1 := i1
		if err := w.ReadData(&o.Address[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadTrailingGap(4); err != nil {
		return err
	}
	return nil
}

// PPPCCPInfo structure represents PPP_CCP_INFO RPC structure.
//
// The PPP_CCP_INFO structure contains information that describes the results of a Compression
// Control Protocol (CCP) negotiation.
type PPPCCPInfo struct {
	// dwError: Specifies an error if the negotiation were unsuccessful. Zero (0) indicates
	// success.
	Error uint32 `idl:"name:dwError" json:"error"`
	// dwCompressionAlgorithm: Specifies the compression algorithm used by the local computer.
	// The following table shows the possible values for this member.
	//
	//	+--------------------------+------------------------------------------------------------------+
	//	|                          |                                                                  |
	//	|          VALUE           |                             MEANING                              |
	//	|                          |                                                                  |
	//	+--------------------------+------------------------------------------------------------------+
	//	+--------------------------+------------------------------------------------------------------+
	//	| 0x00000000               | The local computer has not negotiated any compression algorithm. |
	//	+--------------------------+------------------------------------------------------------------+
	//	| RASCCPCA_MPPC 0x00000006 | Microsoft Point-to-Point Compression (MPPC) Protocol.            |
	//	+--------------------------+------------------------------------------------------------------+
	//	| RASCCPCA_STAC 0x00000005 | STAC LZS data compression algorithm [RFC1974] option 4.          |
	//	+--------------------------+------------------------------------------------------------------+
	CompressionAlgorithm uint32 `idl:"name:dwCompressionAlgorithm" json:"compression_algorithm"`
	// dwOptions: Specifies the compression options on the local computer. The following
	// options are supported.
	//
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	|                                     |                                                                                  |
	//	|                VALUE                |                                     MEANING                                      |
	//	|                                     |                                                                                  |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000                          | No additional compression options are available.                                 |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| PPP_CCP_COMPRESSION 0x00000001      | Compression without encryption.                                                  |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| PPP_CCP_HISTORYLESS 0x01000000      | Microsoft Point-to-Point Encryption (MPPE) in stateless mode. The session key    |
	//	|                                     | is changed after every packet. This mode improves performance on high-latency    |
	//	|                                     | networks, or networks that experience significant packet loss.                   |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| PPP_CCP_ENCRYPTION40BIT 0x00000020  | MPPE using 40-bit keys.                                                          |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| PPP_CCP_ENCRYPTION56BIT 0x00000080  | MPPE using 56-bit keys.                                                          |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| PPP_CCP_ENCRYPTION128BIT 0x00000040 | MPPE using 128-bit keys.                                                         |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	Options uint32 `idl:"name:dwOptions" json:"options"`
	// dwRemoteCompressionAlgorithm: Specifies the compression algorithm used by the remote
	// computer. The following table shows the possible values for this member.
	//
	//	+--------------------------+-------------------------------------------------------------------+
	//	|                          |                                                                   |
	//	|          VALUE           |                              MEANING                              |
	//	|                          |                                                                   |
	//	+--------------------------+-------------------------------------------------------------------+
	//	+--------------------------+-------------------------------------------------------------------+
	//	| 0x00000000               | The remote computer has not negotiated any compression algorithm. |
	//	+--------------------------+-------------------------------------------------------------------+
	//	| RASCCPCA_MPPC 0x00000006 | MPPC Protocol.                                                    |
	//	+--------------------------+-------------------------------------------------------------------+
	//	| RASCCPCA_STAC 0x00000005 | STAC option 4.                                                    |
	//	+--------------------------+-------------------------------------------------------------------+
	RemoteCompressionAlgorithm uint32 `idl:"name:dwRemoteCompressionAlgorithm" json:"remote_compression_algorithm"`
	// dwRemoteOptions: Specifies the compression options on the remote computer. The following
	// options are supported.
	//
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	|                                     |                                                                                  |
	//	|                VALUE                |                                     MEANING                                      |
	//	|                                     |                                                                                  |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000                          | No additional compression options are available.                                 |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| PPP_CCP_COMPRESSION 0x00000001      | Compression without encryption.                                                  |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| PPP_CCP_HISTORYLESS 0x01000000      | MPPE in stateless mode. The session key is changed after every packet. This      |
	//	|                                     | mode improves performance on high-latency networks, or networks that experience  |
	//	|                                     | significant packet loss.                                                         |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| PPP_CCP_ENCRYPTION40BIT 0x00000020  | MPPE using 40-bit keys.                                                          |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| PPP_CCP_ENCRYPTION56BIT 0x00000080  | MPPE using 56-bit keys.                                                          |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| PPP_CCP_ENCRYPTION128BIT 0x00000040 | MPPE using 128-bit keys.                                                         |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	RemoteOptions uint32 `idl:"name:dwRemoteOptions" json:"remote_options"`
}

func (o *PPPCCPInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *PPPCCPInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Error); err != nil {
		return err
	}
	if err := w.WriteData(o.CompressionAlgorithm); err != nil {
		return err
	}
	if err := w.WriteData(o.Options); err != nil {
		return err
	}
	if err := w.WriteData(o.RemoteCompressionAlgorithm); err != nil {
		return err
	}
	if err := w.WriteData(o.RemoteOptions); err != nil {
		return err
	}
	return nil
}
func (o *PPPCCPInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Error); err != nil {
		return err
	}
	if err := w.ReadData(&o.CompressionAlgorithm); err != nil {
		return err
	}
	if err := w.ReadData(&o.Options); err != nil {
		return err
	}
	if err := w.ReadData(&o.RemoteCompressionAlgorithm); err != nil {
		return err
	}
	if err := w.ReadData(&o.RemoteOptions); err != nil {
		return err
	}
	return nil
}

// PPPLCPInfo structure represents PPP_LCP_INFO RPC structure.
//
// The PPP_LCP_INFO structure contains information that describes the results of a PPP
// Link Control Protocol (LCP) negotiation.
type PPPLCPInfo struct {
	// dwError: Specifies the error that occurred if the negotiation were unsuccessful.
	// Zero (0) indicates success.
	Error uint32 `idl:"name:dwError" json:"error"`
	// dwAuthenticationProtocol: Specifies the authentication protocol used to authenticate
	// the local computer. The following table shows the possible values for this member.<49>
	//
	//	+-------------------------+----------------------------------------------------------------------------------+
	//	|                         |                                                                                  |
	//	|          VALUE          |                                     MEANING                                      |
	//	|                         |                                                                                  |
	//	+-------------------------+----------------------------------------------------------------------------------+
	//	+-------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000              | Either no authentication was negotiated by the local end, or no LCP settings are |
	//	|                         | applicable for the connection (for example, an IKEv2 connection).                |
	//	+-------------------------+----------------------------------------------------------------------------------+
	//	| PPP_LCP_PAP 0x0000C023  | Password Authentication Protocol (PAP)                                           |
	//	+-------------------------+----------------------------------------------------------------------------------+
	//	| PPP_LCP_SPAP 0x0000C027 | Shiva Password Authentication Protocol (SPAP)                                    |
	//	+-------------------------+----------------------------------------------------------------------------------+
	//	| PPP_LCP_CHAP 0x0000C223 | Challenge-Handshake Authentication Protocol (CHAP)                               |
	//	+-------------------------+----------------------------------------------------------------------------------+
	//	| PPP_LCP_EAP 0x0000C227  | Extensible Authentication Protocol (EAP)                                         |
	//	+-------------------------+----------------------------------------------------------------------------------+
	AuthenticationProtocol uint32 `idl:"name:dwAuthenticationProtocol" json:"authentication_protocol"`
	// dwAuthenticationData: Specifies additional information about the authentication protocol
	// specified by the dwAuthenticationProtocol member. The following table shows the possible
	// values for this member.<50>
	//
	//	+------------------------------+--------------------------------------------+
	//	|                              |                                            |
	//	|            VALUE             |                  MEANING                   |
	//	|                              |                                            |
	//	+------------------------------+--------------------------------------------+
	//	+------------------------------+--------------------------------------------+
	//	| 0x00000000                   | No additional authentication data applies. |
	//	+------------------------------+--------------------------------------------+
	//	| PPP_LCP_CHAP_MD5 0x00000005  | MD5 CHAP                                   |
	//	+------------------------------+--------------------------------------------+
	//	| PPP_LCP_CHAP_MS 0x00000080   | Microsoft CHAP                             |
	//	+------------------------------+--------------------------------------------+
	//	| PPP_LCP_CHAP_MSV2 0x00000081 | Microsoft CHAP version 2                   |
	//	+------------------------------+--------------------------------------------+
	AuthenticationData uint32 `idl:"name:dwAuthenticationData" json:"authentication_data"`
	// dwRemoteAuthenticationProtocol: Specifies the authentication protocol used to authenticate
	// the remote computer. See the dwAuthenticationProtocol member for a list of possible
	// values. The following table shows the possible values for this member.<51>
	//
	//	+-------------------------+----------------------------------------------------------------------------------+
	//	|                         |                                                                                  |
	//	|          VALUE          |                                     MEANING                                      |
	//	|                         |                                                                                  |
	//	+-------------------------+----------------------------------------------------------------------------------+
	//	+-------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000              | Either no authentication was negotiated by the remote end, or no LCP settings    |
	//	|                         | are applicable for the connection (for example, an IKEv2 connection).            |
	//	+-------------------------+----------------------------------------------------------------------------------+
	//	| PPP_LCP_PAP 0x0000C023  | Password Authentication Protocol (PAP)                                           |
	//	+-------------------------+----------------------------------------------------------------------------------+
	//	| PPP_LCP_SPAP 0x0000C027 | Shiva Password Authentication Protocol (SPAP)                                    |
	//	+-------------------------+----------------------------------------------------------------------------------+
	//	| PPP_LCP_CHAP 0x0000C223 | Challenge-Handshake Authentication Protocol (CHAP)                               |
	//	+-------------------------+----------------------------------------------------------------------------------+
	//	| PPP_LCP_EAP 0x0000C227  | Extensible Authentication Protocol (EAP)                                         |
	//	+-------------------------+----------------------------------------------------------------------------------+
	RemoteAuthenticationProtocol uint32 `idl:"name:dwRemoteAuthenticationProtocol" json:"remote_authentication_protocol"`
	// dwRemoteAuthenticationData: Specifies additional information about the authentication
	// protocol specified by dwRemoteAuthenticationProtocol. See the dwAuthenticationData
	// member for a list of possible values.
	RemoteAuthenticationData uint32 `idl:"name:dwRemoteAuthenticationData" json:"remote_authentication_data"`
	// dwTerminateReason: Specifies the reason the connection was terminated by the local
	// computer. This member always has a value of zero (0).
	TerminateReason uint32 `idl:"name:dwTerminateReason" json:"terminate_reason"`
	// dwRemoteTerminateReason: Specifies the reason the connection was terminated by the
	// remote computer. This member always has a value of zero (0).
	RemoteTerminateReason uint32 `idl:"name:dwRemoteTerminateReason" json:"remote_terminate_reason"`
	// dwOptions: Specifies information about the LCP options in use by the local computer.
	// This member is a combination of the following flags.<52>
	//
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	|                                      |                                                                                  |
	//	|                VALUE                 |                                     MEANING                                      |
	//	|                                      |                                                                                  |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000                           | No flag is set.                                                                  |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| PPP_LCP_MULTILINK_FRAMING 0x00000001 | The connection is using multilink.                                               |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| PPP_LCP_PFC 0x00000002               | Protocol Field Compression (see [RFC1172]).                                      |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| PPP_LCP_ACFC 0x00000004              | Address and Control Field Compression (see [RFC1172]).                           |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| PPP_LCP_SSHF 0x00000008              | Short Sequence Number Header Format (see [RFC1990]).                             |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| PPP_LCP_DES_56 0x00000010            | Data Encryption Standard (DES) 56-bit encryption.                                |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| PPP_LCP_3_DES 0x00000020             | Triple DES encryption.                                                           |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| PPP_LCP_AES_128 0x00000040           | 128-bit AES encryption.                                                          |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| PPP_LCP_AES_256 0x00000080           | 256-bit AES encryption.                                                          |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| PPP_LCP_AES_192 0x00000100           | 192-bit AES encryption.                                                          |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| PPP_LCP_GCM_AES_128 0x00000200       | 128-bit AES encryption GCM (Galois Counter Mode) mode of operation (see          |
	//	|                                      | [RFC4106]).                                                                      |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| PPP_LCP_GCM_AES_192 0x00000400       | 192-bit AES encryption GCM (Galois Counter Mode) mode of operation (see          |
	//	|                                      | [RFC4106]).                                                                      |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	//	| PPP_LCP_GCM_AES_256 0x00000800       | 256-bit AES encryption GCM (Galois Counter Mode) mode of operation (see          |
	//	|                                      | [RFC4106]).                                                                      |
	//	+--------------------------------------+----------------------------------------------------------------------------------+
	Options uint32 `idl:"name:dwOptions" json:"options"`
	// dwRemoteOptions: Specifies information about the LCP options in use by the remote
	// computer. See dwOptions member for a list of possible values.
	RemoteOptions uint32 `idl:"name:dwRemoteOptions" json:"remote_options"`
	// dwEapTypeId: Specifies the type identifier of the EAP used to authenticate the local
	// computer. MUST be one of the values specified in Method Types of [IANA-EAP]. The
	// value of this member is valid only if dwAuthenticationProtocol is PPP_LCP_EAP.
	EAPTypeID uint32 `idl:"name:dwEapTypeId" json:"eap_type_id"`
	// dwRemoteEapTypeId: This field MUST be zero (0) and has no significance.
	RemoteEAPTypeID uint32 `idl:"name:dwRemoteEapTypeId" json:"remote_eap_type_id"`
}

func (o *PPPLCPInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *PPPLCPInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Error); err != nil {
		return err
	}
	if err := w.WriteData(o.AuthenticationProtocol); err != nil {
		return err
	}
	if err := w.WriteData(o.AuthenticationData); err != nil {
		return err
	}
	if err := w.WriteData(o.RemoteAuthenticationProtocol); err != nil {
		return err
	}
	if err := w.WriteData(o.RemoteAuthenticationData); err != nil {
		return err
	}
	if err := w.WriteData(o.TerminateReason); err != nil {
		return err
	}
	if err := w.WriteData(o.RemoteTerminateReason); err != nil {
		return err
	}
	if err := w.WriteData(o.Options); err != nil {
		return err
	}
	if err := w.WriteData(o.RemoteOptions); err != nil {
		return err
	}
	if err := w.WriteData(o.EAPTypeID); err != nil {
		return err
	}
	if err := w.WriteData(o.RemoteEAPTypeID); err != nil {
		return err
	}
	return nil
}
func (o *PPPLCPInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Error); err != nil {
		return err
	}
	if err := w.ReadData(&o.AuthenticationProtocol); err != nil {
		return err
	}
	if err := w.ReadData(&o.AuthenticationData); err != nil {
		return err
	}
	if err := w.ReadData(&o.RemoteAuthenticationProtocol); err != nil {
		return err
	}
	if err := w.ReadData(&o.RemoteAuthenticationData); err != nil {
		return err
	}
	if err := w.ReadData(&o.TerminateReason); err != nil {
		return err
	}
	if err := w.ReadData(&o.RemoteTerminateReason); err != nil {
		return err
	}
	if err := w.ReadData(&o.Options); err != nil {
		return err
	}
	if err := w.ReadData(&o.RemoteOptions); err != nil {
		return err
	}
	if err := w.ReadData(&o.EAPTypeID); err != nil {
		return err
	}
	if err := w.ReadData(&o.RemoteEAPTypeID); err != nil {
		return err
	}
	return nil
}

// PPPInfo structure represents PPP_INFO RPC structure.
//
// The PPP_INFO structure is used to report the results of the various PPP projection
// operations for a connection.
type PPPInfo struct {
	// nbf: A PPP_NBFCP_INFO (section 2.2.1.2.64) structure that contains information about
	// the NetBEUI Framer (NBF) for a connection.
	NBF *PPPNbfcpInfo `idl:"name:nbf" json:"nbf"`
	// ip: A PPP_IPCP_INFO (section 2.2.1.2.65) structure that contains the IPv4 PPP information
	// for a connection.
	IP *PPPIPCPInfo `idl:"name:ip" json:"ip"`
	// ipx: A PPP_IPXCP_INFO (section 2.2.1.2.67) structure<53> that contains the IPX information
	// for a connection.
	IPX *PPPIpxcpInfo `idl:"name:ipx" json:"ipx"`
	// at: A PPP_ATCP_INFO (section 2.2.1.2.69) structure<54> that contains the AppleTalk
	// information for a connection.
	AT *PPPATCPInfo `idl:"name:at" json:"at"`
}

func (o *PPPInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *PPPInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if o.NBF != nil {
		if err := o.NBF.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&PPPNbfcpInfo{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.IP != nil {
		if err := o.IP.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&PPPIPCPInfo{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.IPX != nil {
		if err := o.IPX.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&PPPIpxcpInfo{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.AT != nil {
		if err := o.AT.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&PPPATCPInfo{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *PPPInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if o.NBF == nil {
		o.NBF = &PPPNbfcpInfo{}
	}
	if err := o.NBF.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.IP == nil {
		o.IP = &PPPIPCPInfo{}
	}
	if err := o.IP.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.IPX == nil {
		o.IPX = &PPPIpxcpInfo{}
	}
	if err := o.IPX.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.AT == nil {
		o.AT = &PPPATCPInfo{}
	}
	if err := o.AT.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// PPPInfo2 structure represents PPP_INFO_2 RPC structure.
//
// The PPP_INFO_2 structure<55> is used to report the results of the various PPP projection
// operations for a connection.
type PPPInfo2 struct {
	// nbf: A PPP_NBFCP_INFO (section 2.2.1.2.64) structure that contains information about
	// the NetBEUI Framer (NBF) for a connection.
	NBF *PPPNbfcpInfo `idl:"name:nbf" json:"nbf"`
	// ip: A PPP_IPCP_INFO2 (section 2.2.1.2.66) structure that contains the IPv4 information
	// for a connection.
	IP *PPPIPCPInfo2 `idl:"name:ip" json:"ip"`
	// ipx: A PPP_IPXCP_INFO (section 2.2.1.2.67) structure<56> that contains the IPX information
	// for a connection.
	IPX *PPPIpxcpInfo `idl:"name:ipx" json:"ipx"`
	// at: A PPP_ATCP_INFO (section 2.2.1.2.69) structure<57> that contains AppleTalk information
	// for a connection.
	AT *PPPATCPInfo `idl:"name:at" json:"at"`
	// ccp: A PPP_CCP_INFO (section 2.2.1.2.70) structure that contains compression information
	// details for a given PPP connection.
	CCP *PPPCCPInfo `idl:"name:ccp" json:"ccp"`
	// lcp: A PPP_LCP_INFO (section 2.2.1.2.71) structure that contains the PPP information
	// related to the Link Control Protocol (LCP) for a given connection.
	LCP *PPPLCPInfo `idl:"name:lcp" json:"lcp"`
}

func (o *PPPInfo2) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *PPPInfo2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if o.NBF != nil {
		if err := o.NBF.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&PPPNbfcpInfo{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.IP != nil {
		if err := o.IP.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&PPPIPCPInfo2{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.IPX != nil {
		if err := o.IPX.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&PPPIpxcpInfo{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.AT != nil {
		if err := o.AT.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&PPPATCPInfo{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.CCP != nil {
		if err := o.CCP.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&PPPCCPInfo{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.LCP != nil {
		if err := o.LCP.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&PPPLCPInfo{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *PPPInfo2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if o.NBF == nil {
		o.NBF = &PPPNbfcpInfo{}
	}
	if err := o.NBF.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.IP == nil {
		o.IP = &PPPIPCPInfo2{}
	}
	if err := o.IP.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.IPX == nil {
		o.IPX = &PPPIpxcpInfo{}
	}
	if err := o.IPX.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.AT == nil {
		o.AT = &PPPATCPInfo{}
	}
	if err := o.AT.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.CCP == nil {
		o.CCP = &PPPCCPInfo{}
	}
	if err := o.CCP.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.LCP == nil {
		o.LCP = &PPPLCPInfo{}
	}
	if err := o.LCP.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// PPPInfo3 structure represents PPP_INFO_3 RPC structure.
//
// The PPP_INFO_3 structure<58> be used to report the results of the various PPP projection
// operations for a connection.
type PPPInfo3 struct {
	// nbf: A PPP_NBFCP_INFO (section 2.2.1.2.64) structure that contains information about
	// NetBEUI Framer (NBF) for a connection.
	NBF *PPPNbfcpInfo `idl:"name:nbf" json:"nbf"`
	// ip: A PPP_IPCP_INFO2 (section 2.2.1.2.66) structure that contains the IPv4 information
	// for a connection.
	IP *PPPIPCPInfo2 `idl:"name:ip" json:"ip"`
	// ipv6: A PPP_IPV6_CP_INFO (section 2.2.1.2.68) structure that contains the IPv6 information
	// for a connection.
	IPv6 *PPPIPv6CreatePartitionInfo `idl:"name:ipv6" json:"ipv6"`
	// ccp: A PPP_CCP_INFO (section 2.2.1.2.70) structure that contains the compression
	// information details for a given connection.
	CCP *PPPCCPInfo `idl:"name:ccp" json:"ccp"`
	// lcp: A PPP_LCP_INFO (section 2.2.1.2.71) structure that contains the compression
	// information related to the Link Control Protocol (LCP) for a given connection.
	LCP *PPPLCPInfo `idl:"name:lcp" json:"lcp"`
}

func (o *PPPInfo3) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *PPPInfo3) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if o.NBF != nil {
		if err := o.NBF.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&PPPNbfcpInfo{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.IP != nil {
		if err := o.IP.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&PPPIPCPInfo2{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.IPv6 != nil {
		if err := o.IPv6.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&PPPIPv6CreatePartitionInfo{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.CCP != nil {
		if err := o.CCP.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&PPPCCPInfo{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.LCP != nil {
		if err := o.LCP.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&PPPLCPInfo{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *PPPInfo3) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if o.NBF == nil {
		o.NBF = &PPPNbfcpInfo{}
	}
	if err := o.NBF.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.IP == nil {
		o.IP = &PPPIPCPInfo2{}
	}
	if err := o.IP.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.IPv6 == nil {
		o.IPv6 = &PPPIPv6CreatePartitionInfo{}
	}
	if err := o.IPv6.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.CCP == nil {
		o.CCP = &PPPCCPInfo{}
	}
	if err := o.CCP.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.LCP == nil {
		o.LCP = &PPPLCPInfo{}
	}
	if err := o.LCP.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// RASIPort0 structure represents RASI_PORT_0 RPC structure.
//
// The RASI_PORT_0 structure contains general information regarding a specific RRAS
// port, such as the port condition and the port name.
type RASIPort0 struct {
	// dwPort: A unique identifier for the port.
	Port uint32 `idl:"name:dwPort" json:"port"`
	// dwConnection: A unique identifier that specifies the connection.
	Connection uint32 `idl:"name:dwConnection" json:"connection"`
	// dwPortCondition: A RAS_PORT_CONDITION (section 2.2.1.1.4) enumeration value indicating
	// the condition of a port specified in dwPort.
	PortCondition RASPortCondition `idl:"name:dwPortCondition" json:"port_condition"`
	// dwTotalNumberOfCalls: Specifies the cumulative number of calls that this port has
	// serviced.
	TotalNumberOfCalls uint32 `idl:"name:dwTotalNumberOfCalls" json:"total_number_of_calls"`
	// dwConnectDuration: Specifies the duration of the current connection on this port,
	// in seconds.
	ConnectDuration uint32 `idl:"name:dwConnectDuration" json:"connect_duration"`
	// wszPortName: Specifies the port name.
	PortName []uint16 `idl:"name:wszPortName" json:"port_name"`
	// wszMediaName: Specifies the media name.
	MediaName []uint16 `idl:"name:wszMediaName" json:"media_name"`
	// wszDeviceName: Specifies the device name.
	DeviceName []uint16 `idl:"name:wszDeviceName" json:"device_name"`
	// wszDeviceType: Specifies the device type. This member can be one of the following
	// string constants.
	//
	//	+-------------------------------+-----------------------------------------------------------------------+
	//	|                               |                                                                       |
	//	|             VALUE             |                                MEANING                                |
	//	|                               |                                                                       |
	//	+-------------------------------+-----------------------------------------------------------------------+
	//	+-------------------------------+-----------------------------------------------------------------------+
	//	| MPRDT_Modem "Modem"           | A modem that is accessed through a Component Object Model (COM) port. |
	//	+-------------------------------+-----------------------------------------------------------------------+
	//	| MPRDT_Isdn "Isdn"             | An ISDN adapter with the corresponding NDISWAN driver installed.      |
	//	+-------------------------------+-----------------------------------------------------------------------+
	//	| MPRDT_X25 "x25"               | An X.25 adapter with the corresponding NDISWAN driver installed.      |
	//	+-------------------------------+-----------------------------------------------------------------------+
	//	| MPRDT_Vpn "Vpn"               | A virtual private network (VPN) connection.                           |
	//	+-------------------------------+-----------------------------------------------------------------------+
	//	| MPRDT_Pad "Pad"               | A packet assembler/disassembler.                                      |
	//	+-------------------------------+-----------------------------------------------------------------------+
	//	| MPRDT_Generic "GENERIC"       | Generic.                                                              |
	//	+-------------------------------+-----------------------------------------------------------------------+
	//	| MPRDT_Serial "SERIAL"         | Direct serial connection through a serial port.                       |
	//	+-------------------------------+-----------------------------------------------------------------------+
	//	| MPRDT_FrameRelay "FRAMERELAY" | Frame relay.                                                          |
	//	+-------------------------------+-----------------------------------------------------------------------+
	//	| MPRDT_Atm "ATM"               | Asynchronous transfer mode (ATM).                                     |
	//	+-------------------------------+-----------------------------------------------------------------------+
	//	| MPRDT_Sonet "SONET"           | Sonet.                                                                |
	//	+-------------------------------+-----------------------------------------------------------------------+
	//	| MPRDT_SW56 "SW56"             | Switched 56K access.                                                  |
	//	+-------------------------------+-----------------------------------------------------------------------+
	//	| MPRDT_Irda "IRDA"             | An Infrared Data Association (IrDA)-compliant device.                 |
	//	+-------------------------------+-----------------------------------------------------------------------+
	//	| MPRDT_Parallel "PARALLEL"     | Direct parallel connection through a parallel port.                   |
	//	+-------------------------------+-----------------------------------------------------------------------+
	DeviceType []uint16 `idl:"name:wszDeviceType" json:"device_type"`
}

func (o *RASIPort0) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *RASIPort0) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Port); err != nil {
		return err
	}
	if err := w.WriteData(o.Connection); err != nil {
		return err
	}
	if err := w.WriteEnum(uint16(o.PortCondition)); err != nil {
		return err
	}
	if err := w.WriteData(o.TotalNumberOfCalls); err != nil {
		return err
	}
	if err := w.WriteData(o.ConnectDuration); err != nil {
		return err
	}
	for i1 := range o.PortName {
		i1 := i1
		if uint64(i1) >= 17 {
			break
		}
		if err := w.WriteData(o.PortName[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.PortName); uint64(i1) < 17; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	for i1 := range o.MediaName {
		i1 := i1
		if uint64(i1) >= 17 {
			break
		}
		if err := w.WriteData(o.MediaName[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.MediaName); uint64(i1) < 17; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	for i1 := range o.DeviceName {
		i1 := i1
		if uint64(i1) >= 129 {
			break
		}
		if err := w.WriteData(o.DeviceName[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.DeviceName); uint64(i1) < 129; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	for i1 := range o.DeviceType {
		i1 := i1
		if uint64(i1) >= 17 {
			break
		}
		if err := w.WriteData(o.DeviceType[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.DeviceType); uint64(i1) < 17; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	if err := w.WriteTrailingGap(4); err != nil {
		return err
	}
	return nil
}
func (o *RASIPort0) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Port); err != nil {
		return err
	}
	if err := w.ReadData(&o.Connection); err != nil {
		return err
	}
	if err := w.ReadEnum((*uint16)(&o.PortCondition)); err != nil {
		return err
	}
	if err := w.ReadData(&o.TotalNumberOfCalls); err != nil {
		return err
	}
	if err := w.ReadData(&o.ConnectDuration); err != nil {
		return err
	}
	o.PortName = make([]uint16, 17)
	for i1 := range o.PortName {
		i1 := i1
		if err := w.ReadData(&o.PortName[i1]); err != nil {
			return err
		}
	}
	o.MediaName = make([]uint16, 17)
	for i1 := range o.MediaName {
		i1 := i1
		if err := w.ReadData(&o.MediaName[i1]); err != nil {
			return err
		}
	}
	o.DeviceName = make([]uint16, 129)
	for i1 := range o.DeviceName {
		i1 := i1
		if err := w.ReadData(&o.DeviceName[i1]); err != nil {
			return err
		}
	}
	o.DeviceType = make([]uint16, 17)
	for i1 := range o.DeviceType {
		i1 := i1
		if err := w.ReadData(&o.DeviceType[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadTrailingGap(4); err != nil {
		return err
	}
	return nil
}

// RASIPort1 structure represents RASI_PORT_1 RPC structure.
//
// The RASI_PORT_1 structure contains information about a RRAS port.
type RASIPort1 struct {
	// dwPort: A unique identifier that specifies the port.
	Port uint32 `idl:"name:dwPort" json:"port"`
	// dwConnection: A unique identifier that specifies the connection.
	Connection uint32 `idl:"name:dwConnection" json:"connection"`
	// dwHardwareCondition: A RAS_HARDWARE_CONDITION (section 2.2.1.1.5) value that specifies
	// the condition of a port specified in dwPort.
	HardwareCondition RASHardwareCondition `idl:"name:dwHardwareCondition" json:"hardware_condition"`
	// dwLineSpeed: Specifies the line speed of the port, represented in bits per second.
	LineSpeed uint32 `idl:"name:dwLineSpeed" json:"line_speed"`
	// dwBytesXmited: Specifies the bytes transmitted on the port. This value is the number
	// of bytes of compressed data.
	BytesXmited uint32 `idl:"name:dwBytesXmited" json:"bytes_xmited"`
	// dwBytesRcved: Specifies the bytes received on the port. This value is the number
	// of bytes of compressed data.
	BytesRcved uint32 `idl:"name:dwBytesRcved" json:"bytes_rcved"`
	// dwFramesXmited: Specifies the frames transmitted on the port.
	FramesXmited uint32 `idl:"name:dwFramesXmited" json:"frames_xmited"`
	// dwFramesRcved: Specifies the frames received on the port.
	FramesRcved uint32 `idl:"name:dwFramesRcved" json:"frames_rcved"`
	// dwCrcErr: Specifies the cyclic redundancy check (CRC) errors on the port.
	CRCError uint32 `idl:"name:dwCrcErr" json:"crc_error"`
	// dwTimeoutErr: Specifies the time-out errors on the port.
	TimeoutError uint32 `idl:"name:dwTimeoutErr" json:"timeout_error"`
	// dwAlignmentErr: Specifies the alignment errors on the port.
	AlignmentError uint32 `idl:"name:dwAlignmentErr" json:"alignment_error"`
	// dwHardwareOverrunErr: Specifies the hardware-overrun errors on the port.
	HardwareOverrunError uint32 `idl:"name:dwHardwareOverrunErr" json:"hardware_overrun_error"`
	// dwFramingErr: Specifies the framing errors on the port.
	FramingError uint32 `idl:"name:dwFramingErr" json:"framing_error"`
	// dwBufferOverrunErr: Specifies the buffer-overrun errors on the port.
	BufferOverrunError uint32 `idl:"name:dwBufferOverrunErr" json:"buffer_overrun_error"`
	// dwCompressionRatioIn: Specifies a percentage that indicates the degree to which data
	// received on this connection is compressed. The ratio is the size of the compressed
	// data divided by the size of the same data in an uncompressed state.
	CompressionRatioIn uint32 `idl:"name:dwCompressionRatioIn" json:"compression_ratio_in"`
	// dwCompressionRatioOut: Specifies a percentage indicating the degree to which data
	// transmitted on this connection is compressed. The ratio is the size of the compressed
	// data divided by the size of the same data in an uncompressed state.
	CompressionRatioOut uint32 `idl:"name:dwCompressionRatioOut" json:"compression_ratio_out"`
}

func (o *RASIPort1) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *RASIPort1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Port); err != nil {
		return err
	}
	if err := w.WriteData(o.Connection); err != nil {
		return err
	}
	if err := w.WriteEnum(uint16(o.HardwareCondition)); err != nil {
		return err
	}
	if err := w.WriteData(o.LineSpeed); err != nil {
		return err
	}
	if err := w.WriteData(o.BytesXmited); err != nil {
		return err
	}
	if err := w.WriteData(o.BytesRcved); err != nil {
		return err
	}
	if err := w.WriteData(o.FramesXmited); err != nil {
		return err
	}
	if err := w.WriteData(o.FramesRcved); err != nil {
		return err
	}
	if err := w.WriteData(o.CRCError); err != nil {
		return err
	}
	if err := w.WriteData(o.TimeoutError); err != nil {
		return err
	}
	if err := w.WriteData(o.AlignmentError); err != nil {
		return err
	}
	if err := w.WriteData(o.HardwareOverrunError); err != nil {
		return err
	}
	if err := w.WriteData(o.FramingError); err != nil {
		return err
	}
	if err := w.WriteData(o.BufferOverrunError); err != nil {
		return err
	}
	if err := w.WriteData(o.CompressionRatioIn); err != nil {
		return err
	}
	if err := w.WriteData(o.CompressionRatioOut); err != nil {
		return err
	}
	return nil
}
func (o *RASIPort1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Port); err != nil {
		return err
	}
	if err := w.ReadData(&o.Connection); err != nil {
		return err
	}
	if err := w.ReadEnum((*uint16)(&o.HardwareCondition)); err != nil {
		return err
	}
	if err := w.ReadData(&o.LineSpeed); err != nil {
		return err
	}
	if err := w.ReadData(&o.BytesXmited); err != nil {
		return err
	}
	if err := w.ReadData(&o.BytesRcved); err != nil {
		return err
	}
	if err := w.ReadData(&o.FramesXmited); err != nil {
		return err
	}
	if err := w.ReadData(&o.FramesRcved); err != nil {
		return err
	}
	if err := w.ReadData(&o.CRCError); err != nil {
		return err
	}
	if err := w.ReadData(&o.TimeoutError); err != nil {
		return err
	}
	if err := w.ReadData(&o.AlignmentError); err != nil {
		return err
	}
	if err := w.ReadData(&o.HardwareOverrunError); err != nil {
		return err
	}
	if err := w.ReadData(&o.FramingError); err != nil {
		return err
	}
	if err := w.ReadData(&o.BufferOverrunError); err != nil {
		return err
	}
	if err := w.ReadData(&o.CompressionRatioIn); err != nil {
		return err
	}
	if err := w.ReadData(&o.CompressionRatioOut); err != nil {
		return err
	}
	return nil
}

// RASIConnection0 structure represents RASI_CONNECTION_0 RPC structure.
//
// The RASI_CONNECTION_0 structure contains general information regarding a specific
// connection, such as username or domain.
type RASIConnection0 struct {
	// dwConnection: Contains the connection handle that specifies a unique identifier of
	// the connection.
	Connection uint32 `idl:"name:dwConnection" json:"connection"`
	// dwInterface: Contains the interface handle and specifies a unique identifier of the
	// interface through which the connection exists.
	Interface uint32 `idl:"name:dwInterface" json:"interface"`
	// dwConnectDuration: Specifies the duration of the current connection, in seconds.
	ConnectDuration uint32 `idl:"name:dwConnectDuration" json:"connect_duration"`
	// dwInterfaceType: A ROUTER_INTERFACE_TYPE (section 2.2.1.1.1) value specifying the
	// interface type of the current connection.
	InterfaceType RouterInterfaceType `idl:"name:dwInterfaceType" json:"interface_type"`
	// dwConnectionFlags: Specifies certain attributes of the connection. This member can
	// contain the following flags.
	//
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                         |                                                                                  |
	//	|                  VALUE                  |                                     MEANING                                      |
	//	|                                         |                                                                                  |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| RAS_FLAGS_PPP_CONNECTION 0x00000001     | The connection is using PPP.                                                     |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| RAS_FLAGS_MESSENGER_PRESENT 0x00000002  | The messenger service is active on the client, and messages can be sent to the   |
	//	|                                         | client using RRasAdminSendUserMessage (section 3.1.4.36).                        |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| RAS_FLAGS_RAS_CONNECTION 0x00000004     | The connection is a NetBIOS connection.                                          |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| RAS_FLAGS_QUARANTINE_PRESENT 0x00000008 | The connection is currently in quarantine. See                                   |
	//	|                                         | RRasAdminConnectionRemoveQuarantine (section 3.1.4.43) for more information.     |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	//	| RAS_FLAGS_ARAP_CONNECTION 0x00000010    | The connection is using AppleTalk Remote Access Protocol (ARAP).<59>             |
	//	+-----------------------------------------+----------------------------------------------------------------------------------+
	ConnectionFlags uint32 `idl:"name:dwConnectionFlags" json:"connection_flags"`
	// wszInterfaceName: Specifies a null-terminated Unicode string that contains the name
	// of the interface for this connection.
	InterfaceName []uint16 `idl:"name:wszInterfaceName" json:"interface_name"`
	// wszUserName: Specifies a null-terminated Unicode string that contains the name of
	// the user logged on to the connection.
	UserName []uint16 `idl:"name:wszUserName" json:"user_name"`
	// wszLogonDomain: Specifies a null-terminated Unicode string that contains the domain
	// on which the connected user is authenticated.
	LogonDomain []uint16 `idl:"name:wszLogonDomain" json:"logon_domain"`
	// wszRemoteComputer: Specifies a null-terminated Unicode string that contains the name
	// of the remote computer.
	RemoteComputer []uint16 `idl:"name:wszRemoteComputer" json:"remote_computer"`
}

func (o *RASIConnection0) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *RASIConnection0) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Connection); err != nil {
		return err
	}
	if err := w.WriteData(o.Interface); err != nil {
		return err
	}
	if err := w.WriteData(o.ConnectDuration); err != nil {
		return err
	}
	if err := w.WriteEnum(uint16(o.InterfaceType)); err != nil {
		return err
	}
	if err := w.WriteData(o.ConnectionFlags); err != nil {
		return err
	}
	for i1 := range o.InterfaceName {
		i1 := i1
		if uint64(i1) >= 257 {
			break
		}
		if err := w.WriteData(o.InterfaceName[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.InterfaceName); uint64(i1) < 257; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	for i1 := range o.UserName {
		i1 := i1
		if uint64(i1) >= 257 {
			break
		}
		if err := w.WriteData(o.UserName[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.UserName); uint64(i1) < 257; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	for i1 := range o.LogonDomain {
		i1 := i1
		if uint64(i1) >= 16 {
			break
		}
		if err := w.WriteData(o.LogonDomain[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.LogonDomain); uint64(i1) < 16; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	for i1 := range o.RemoteComputer {
		i1 := i1
		if uint64(i1) >= 17 {
			break
		}
		if err := w.WriteData(o.RemoteComputer[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.RemoteComputer); uint64(i1) < 17; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	if err := w.WriteTrailingGap(4); err != nil {
		return err
	}
	return nil
}
func (o *RASIConnection0) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Connection); err != nil {
		return err
	}
	if err := w.ReadData(&o.Interface); err != nil {
		return err
	}
	if err := w.ReadData(&o.ConnectDuration); err != nil {
		return err
	}
	if err := w.ReadEnum((*uint16)(&o.InterfaceType)); err != nil {
		return err
	}
	if err := w.ReadData(&o.ConnectionFlags); err != nil {
		return err
	}
	o.InterfaceName = make([]uint16, 257)
	for i1 := range o.InterfaceName {
		i1 := i1
		if err := w.ReadData(&o.InterfaceName[i1]); err != nil {
			return err
		}
	}
	o.UserName = make([]uint16, 257)
	for i1 := range o.UserName {
		i1 := i1
		if err := w.ReadData(&o.UserName[i1]); err != nil {
			return err
		}
	}
	o.LogonDomain = make([]uint16, 16)
	for i1 := range o.LogonDomain {
		i1 := i1
		if err := w.ReadData(&o.LogonDomain[i1]); err != nil {
			return err
		}
	}
	o.RemoteComputer = make([]uint16, 17)
	for i1 := range o.RemoteComputer {
		i1 := i1
		if err := w.ReadData(&o.RemoteComputer[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadTrailingGap(4); err != nil {
		return err
	}
	return nil
}

// RASIConnection1 structure represents RASI_CONNECTION_1 RPC structure.
//
// The RASI_CONNECTION_1 structure contains detailed statistical information regarding
// a specific connection, such as error counts and bytes received.
type RASIConnection1 struct {
	// dwConnection: See dwConnection in RASI_CONNECTION_0 (section 2.2.1.2.77).
	Connection uint32 `idl:"name:dwConnection" json:"connection"`
	// dwInterface: See dwInterface in RASI_CONNECTION_0.
	Interface uint32 `idl:"name:dwInterface" json:"interface"`
	// PppInfo: A PPP_INFO (section 2.2.1.2.72) structure giving the connections details.
	PPPInfo *PPPInfo `idl:"name:PppInfo" json:"ppp_info"`
	// dwBytesXmited: Specifies the bytes transmitted on the current connection.
	BytesXmited uint32 `idl:"name:dwBytesXmited" json:"bytes_xmited"`
	// dwBytesRcved: Specifies the bytes received on the current connection.
	BytesRcved uint32 `idl:"name:dwBytesRcved" json:"bytes_rcved"`
	// dwFramesXmited: Specifies the frames transmitted on the current connection.
	FramesXmited uint32 `idl:"name:dwFramesXmited" json:"frames_xmited"`
	// dwFramesRcved: Specifies the frames received on the current connection.
	FramesRcved uint32 `idl:"name:dwFramesRcved" json:"frames_rcved"`
	// dwCrcErr: Specifies the CRC errors on the current connection.
	CRCError uint32 `idl:"name:dwCrcErr" json:"crc_error"`
	// dwTimeoutErr: Specifies the time-out errors on the current connection.
	TimeoutError uint32 `idl:"name:dwTimeoutErr" json:"timeout_error"`
	// dwAlignmentErr: Specifies the alignment errors on the current connection.
	AlignmentError uint32 `idl:"name:dwAlignmentErr" json:"alignment_error"`
	// dwHardwareOverrunErr: Specifies the number of hardware-overrun errors on the current
	// connection.
	HardwareOverrunError uint32 `idl:"name:dwHardwareOverrunErr" json:"hardware_overrun_error"`
	// dwFramingErr: Specifies the number of framing errors for the current connection.
	FramingError uint32 `idl:"name:dwFramingErr" json:"framing_error"`
	// dwBufferOverrunErr: Specifies the number of buffer-overrun errors.
	BufferOverrunError uint32 `idl:"name:dwBufferOverrunErr" json:"buffer_overrun_error"`
	// dwCompressionRatioIn: Specifies a percentage that indicates the degree to which data
	// received on this connection is compressed. The ratio is the size of the compressed
	// data divided by the size of the same data in an uncompressed state.
	CompressionRatioIn uint32 `idl:"name:dwCompressionRatioIn" json:"compression_ratio_in"`
	// dwCompressionRatioOut: Specifies a percentage that indicates the degree to which
	// data transmitted on this connection is compressed. The ratio is the size of the compressed
	// data divided by the size of the same data in an uncompressed state.
	CompressionRatioOut uint32 `idl:"name:dwCompressionRatioOut" json:"compression_ratio_out"`
}

func (o *RASIConnection1) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *RASIConnection1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Connection); err != nil {
		return err
	}
	if err := w.WriteData(o.Interface); err != nil {
		return err
	}
	if o.PPPInfo != nil {
		if err := o.PPPInfo.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&PPPInfo{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.BytesXmited); err != nil {
		return err
	}
	if err := w.WriteData(o.BytesRcved); err != nil {
		return err
	}
	if err := w.WriteData(o.FramesXmited); err != nil {
		return err
	}
	if err := w.WriteData(o.FramesRcved); err != nil {
		return err
	}
	if err := w.WriteData(o.CRCError); err != nil {
		return err
	}
	if err := w.WriteData(o.TimeoutError); err != nil {
		return err
	}
	if err := w.WriteData(o.AlignmentError); err != nil {
		return err
	}
	if err := w.WriteData(o.HardwareOverrunError); err != nil {
		return err
	}
	if err := w.WriteData(o.FramingError); err != nil {
		return err
	}
	if err := w.WriteData(o.BufferOverrunError); err != nil {
		return err
	}
	if err := w.WriteData(o.CompressionRatioIn); err != nil {
		return err
	}
	if err := w.WriteData(o.CompressionRatioOut); err != nil {
		return err
	}
	return nil
}
func (o *RASIConnection1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Connection); err != nil {
		return err
	}
	if err := w.ReadData(&o.Interface); err != nil {
		return err
	}
	if o.PPPInfo == nil {
		o.PPPInfo = &PPPInfo{}
	}
	if err := o.PPPInfo.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.BytesXmited); err != nil {
		return err
	}
	if err := w.ReadData(&o.BytesRcved); err != nil {
		return err
	}
	if err := w.ReadData(&o.FramesXmited); err != nil {
		return err
	}
	if err := w.ReadData(&o.FramesRcved); err != nil {
		return err
	}
	if err := w.ReadData(&o.CRCError); err != nil {
		return err
	}
	if err := w.ReadData(&o.TimeoutError); err != nil {
		return err
	}
	if err := w.ReadData(&o.AlignmentError); err != nil {
		return err
	}
	if err := w.ReadData(&o.HardwareOverrunError); err != nil {
		return err
	}
	if err := w.ReadData(&o.FramingError); err != nil {
		return err
	}
	if err := w.ReadData(&o.BufferOverrunError); err != nil {
		return err
	}
	if err := w.ReadData(&o.CompressionRatioIn); err != nil {
		return err
	}
	if err := w.ReadData(&o.CompressionRatioOut); err != nil {
		return err
	}
	return nil
}

// RASIConnection2 structure represents RASI_CONNECTION_2 RPC structure.
//
// The RASI_CONNECTION_2 structure contains information for a connection, including
// the GUID that identifies the connection, as defined in [MS-DTYP] section 2.3.4.
type RASIConnection2 struct {
	// dwConnection: See dwConnection in RASI_CONNECTION_0 (section 2.2.1.2.77).
	Connection uint32 `idl:"name:dwConnection" json:"connection"`
	// wszUserName: See wszUserName in RASI_CONNECTION_0.
	UserName []uint16 `idl:"name:wszUserName" json:"user_name"`
	// dwInterfaceType: A ROUTER_INTERFACE_TYPE (section 2.2.1.1.1) that specifies the interface
	// type of the current connection.
	InterfaceType RouterInterfaceType `idl:"name:dwInterfaceType" json:"interface_type"`
	// guid: A GUID uniquely identifying the connection.
	GUID *dtyp.GUID `idl:"name:guid" json:"guid"`
	// PppInfo2: A PPP_INFO_2 (section 2.2.1.2.73) structure that contains information about
	// the PPP negotiation for this connection.
	PPPInfo2 *PPPInfo2 `idl:"name:PppInfo2" json:"ppp_info2"`
}

func (o *RASIConnection2) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *RASIConnection2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Connection); err != nil {
		return err
	}
	for i1 := range o.UserName {
		i1 := i1
		if uint64(i1) >= 257 {
			break
		}
		if err := w.WriteData(o.UserName[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.UserName); uint64(i1) < 257; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	if err := w.WriteEnum(uint16(o.InterfaceType)); err != nil {
		return err
	}
	if o.GUID != nil {
		if err := o.GUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.PPPInfo2 != nil {
		if err := o.PPPInfo2.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&PPPInfo2{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *RASIConnection2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Connection); err != nil {
		return err
	}
	o.UserName = make([]uint16, 257)
	for i1 := range o.UserName {
		i1 := i1
		if err := w.ReadData(&o.UserName[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadEnum((*uint16)(&o.InterfaceType)); err != nil {
		return err
	}
	if o.GUID == nil {
		o.GUID = &dtyp.GUID{}
	}
	if err := o.GUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.PPPInfo2 == nil {
		o.PPPInfo2 = &PPPInfo2{}
	}
	if err := o.PPPInfo2.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// RASIConnection3 structure represents RASI_CONNECTION_3 RPC structure.
//
// The RASI_CONNECTION_3 structure contains information for a connection, including
// the GUID that identifies the connection, the Network Access Protection (NAP), and
// the PPP-related data for the connection.
type RASIConnection3 struct {
	// dwVersion: Determines the version of the RASI_CONNECTION_3 structure used.
	Version uint32 `idl:"name:dwVersion" json:"version"`
	// dwSize: This SHOULD be set to 0. This MAY be used to specify the size, in bytes,
	// of this RASI_CONNECTION_3 structure.
	Size uint32 `idl:"name:dwSize" json:"size"`
	// dwConnection: Contains the connection handle that specifies a unique identifier of
	// a connection.
	Connection uint32 `idl:"name:dwConnection" json:"connection"`
	// wszUserName: Specifies a null-terminated Unicode string that contains the name of
	// the user on this connection.
	UserName []uint16 `idl:"name:wszUserName" json:"user_name"`
	// dwInterfaceType: A ROUTER_INTERFACE_TYPE (section 2.2.1.1.1) value that specifies
	// the type of interface.
	InterfaceType RouterInterfaceType `idl:"name:dwInterfaceType" json:"interface_type"`
	// guid: Specifies a GUID that identifies the connection. For an incoming connection,
	// this GUID is valid only as long as the connection is active.
	GUID *dtyp.GUID `idl:"name:guid" json:"guid"`
	// PppInfo3: Specifies a PPP_INFO_3 (section 2.2.1.2.74) structure<60> that contains
	// information about the PPP negotiation for this connection.
	PPPInfo3 *PPPInfo3 `idl:"name:PppInfo3" json:"ppp_info3"`
	// rasQuarState: Specifies the NAP quarantine state for the connection through the RAS_QUARANTINE_STATE
	// (section 2.2.1.1.3) that contains the quarantine state of this connection.
	RASQuarantineState RASQuarantineState `idl:"name:rasQuarState" json:"ras_quarantine_state"`
	// timer: Specifies the NAP probation time for the connection in the UTC. This value
	// is valid only if the rasQuarState has a value of RAS_QUAR_STATE_PROBATION (see RAS_QUARANTINE_STATE
	// section 2.2.1.1.3).
	Timer *dtyp.Filetime `idl:"name:timer" json:"timer"`
}

func (o *RASIConnection3) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *RASIConnection3) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Version); err != nil {
		return err
	}
	if err := w.WriteData(o.Size); err != nil {
		return err
	}
	if err := w.WriteData(o.Connection); err != nil {
		return err
	}
	for i1 := range o.UserName {
		i1 := i1
		if uint64(i1) >= 257 {
			break
		}
		if err := w.WriteData(o.UserName[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.UserName); uint64(i1) < 257; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	if err := w.WriteEnum(uint16(o.InterfaceType)); err != nil {
		return err
	}
	if o.GUID != nil {
		if err := o.GUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.PPPInfo3 != nil {
		if err := o.PPPInfo3.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&PPPInfo3{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteEnum(uint16(o.RASQuarantineState)); err != nil {
		return err
	}
	if o.Timer != nil {
		if err := o.Timer.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.Filetime{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *RASIConnection3) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Version); err != nil {
		return err
	}
	if err := w.ReadData(&o.Size); err != nil {
		return err
	}
	if err := w.ReadData(&o.Connection); err != nil {
		return err
	}
	o.UserName = make([]uint16, 257)
	for i1 := range o.UserName {
		i1 := i1
		if err := w.ReadData(&o.UserName[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadEnum((*uint16)(&o.InterfaceType)); err != nil {
		return err
	}
	if o.GUID == nil {
		o.GUID = &dtyp.GUID{}
	}
	if err := o.GUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.PPPInfo3 == nil {
		o.PPPInfo3 = &PPPInfo3{}
	}
	if err := o.PPPInfo3.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadEnum((*uint16)(&o.RASQuarantineState)); err != nil {
		return err
	}
	if o.Timer == nil {
		o.Timer = &dtyp.Filetime{}
	}
	if err := o.Timer.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// Interface0 structure represents MPRI_INTERFACE_0 RPC structure.
//
// The MPRI_INTERFACE_0 structure contains information for a particular router interface.
// This structure is used in the following methods:
//
// * *RRouterInterfaceCreate (section 3.1.4.13)* ( 72bead5c-821f-4e98-bacd-0de279552379
// )
//
// * *RRouterInterfaceGetInfo (section 3.1.4.14)* ( 2fbcf316-2082-4f98-878b-eab5d0c2da1d
// )
//
// * *RRouterInterfaceSetInfo (section 3.1.4.15)* ( 615c1081-5d03-415a-b57c-76876bb2cf23
// )
//
// * *RRouterInterfaceEnum (section 3.1.4.21)* ( 0d19911e-f4d7-47f0-b615-90feef69831c
// )
//
// typedef struct _MPRI_INTERFACE_0 {
//
// WCHAR wszInterfaceName[257];
//
// DWORD dwInterface;
//
// BOOL fEnabled;
//
// ROUTER_INTERFACE_TYPE dwIfType;
//
// ROUTER_CONNECTION_STATE dwConnectionState;
//
// DWORD fUnReachabilityReasons;
//
// DWORD dwLastError;
//
// } MPRI_INTERFACE_0,
type Interface0 struct {
	// wszInterfaceName: A null-terminated Unicode string that contains the name of a valid
	// interface. This value MUST be specified during the call to RRouterInterfaceCreate
	// and cannot be modified after the interface is created.
	InterfaceName []uint16 `idl:"name:wszInterfaceName" json:"interface_name"`
	// dwInterface: Specifies a unique identifier of the interface. This is a read-only
	// field that cannot be set or modified.
	Interface uint32 `idl:"name:dwInterface" json:"interface"`
	// fEnabled: Specifies whether the interface is enabled. The value TRUE is greater than
	// zero (0) if the interface is enabled, or FALSE is zero (0) if the interface is disabled
	// by an administrator.
	//
	// This member can have one of the following values.
	//
	//	+---------+----------------------------+
	//	|         |                            |
	//	|  VALUE  |          MEANING           |
	//	|         |                            |
	//	+---------+----------------------------+
	//	+---------+----------------------------+
	//	| TRUE >0 | The interface is enabled.  |
	//	+---------+----------------------------+
	//	| FALSE 0 | The interface is disabled. |
	//	+---------+----------------------------+
	Enabled bool `idl:"name:fEnabled" json:"enabled"`
	// dwIfType: A ROUTER_INTERFACE_TYPE (section 2.2.1.1.1) value that specifies the interface
	// type. This value MUST be specified during the call to RRouterInterfaceCreate and
	// cannot be modified after the interface is created.
	InterfaceType RouterInterfaceType `idl:"name:dwIfType" json:"interface_type"`
	// dwConnectionState: A ROUTER_CONNECTION_STATE (section 2.2.1.1.2) value that specifies
	// the current state of the interface (for example: connected, disconnected, or unreachable).
	// This is a read-only field that cannot be set or modified.
	ConnectionState RouterConnectionState `idl:"name:dwConnectionState" json:"connection_state"`
	// fUnReachabilityReasons: Specifies a value that represents a reason the interface
	// cannot be reached. This is a read-only field that cannot be set or modified. The
	// following table lists constant values that indicate why an interface is unreachable.
	//
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                                    |                                                                                  |
	//	|                       VALUE                        |                                     MEANING                                      |
	//	|                                                    |                                                                                  |
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPR_INTERFACE_OUT_OF_RESOURCES 0x00000001          | No ports or devices are available for use.                                       |
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPR_INTERFACE_ADMIN_DISABLED 0x00000002            | The administrator has disabled the interface.                                    |
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPR_INTERFACE_CONNECTION_FAILURE 0x00000004        | The previous connection attempt failed. Look at the dwLastError member for the   |
	//	|                                                    | error code.                                                                      |
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPR_INTERFACE_DIALOUT_HOURS_RESTRICTION 0x00000010 | Dialing out is not allowed at the current time.                                  |
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPR_INTERFACE_SERVICE_PAUSED 0x00000008            | The RRAS is paused.                                                              |
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPR_INTERFACE_NO_MEDIA_SENSE 0x00000020            | The network cable is disconnected from the network card.                         |
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPR_INTERFACE_NO_DEVICE 0x00000040                 | The network card has been removed from the machine.                              |
	//	+----------------------------------------------------+----------------------------------------------------------------------------------+
	UnReachabilityReasons uint32 `idl:"name:fUnReachabilityReasons" json:"un_reachability_reasons"`
	// dwLastError: Specifies a nonzero value if the interface fails to connect. The value
	// is a Win32 error code as specified in [MS-ERREF]. This is a read-only field that
	// cannot be set or modified.
	LastError uint32 `idl:"name:dwLastError" json:"last_error"`
}

func (o *Interface0) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *Interface0) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	for i1 := range o.InterfaceName {
		i1 := i1
		if uint64(i1) >= 257 {
			break
		}
		if err := w.WriteData(o.InterfaceName[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.InterfaceName); uint64(i1) < 257; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Interface); err != nil {
		return err
	}
	if !o.Enabled {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if err := w.WriteEnum(uint16(o.InterfaceType)); err != nil {
		return err
	}
	if err := w.WriteEnum(uint16(o.ConnectionState)); err != nil {
		return err
	}
	if err := w.WriteData(o.UnReachabilityReasons); err != nil {
		return err
	}
	if err := w.WriteData(o.LastError); err != nil {
		return err
	}
	return nil
}
func (o *Interface0) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	o.InterfaceName = make([]uint16, 257)
	for i1 := range o.InterfaceName {
		i1 := i1
		if err := w.ReadData(&o.InterfaceName[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.Interface); err != nil {
		return err
	}
	var _bEnabled int32
	if err := w.ReadData(&_bEnabled); err != nil {
		return err
	}
	o.Enabled = _bEnabled != 0
	if err := w.ReadEnum((*uint16)(&o.InterfaceType)); err != nil {
		return err
	}
	if err := w.ReadEnum((*uint16)(&o.ConnectionState)); err != nil {
		return err
	}
	if err := w.ReadData(&o.UnReachabilityReasons); err != nil {
		return err
	}
	if err := w.ReadData(&o.LastError); err != nil {
		return err
	}
	return nil
}

// Interface1 structure represents MPRI_INTERFACE_1 RPC structure.
//
// The MPRI_INTERFACE_1 structure<61> is used to contain configuration and status information
// for a specific router interface. This structure is used in the following methods:
//
// * *RRouterInterfaceCreate (section 3.1.4.13)* ( 72bead5c-821f-4e98-bacd-0de279552379
// )
//
// * *RRouterInterfaceGetInfo (section 3.1.4.14)* ( 2fbcf316-2082-4f98-878b-eab5d0c2da1d
// )
//
// * *RRouterInterfaceSetInfo (section 3.1.4.15)* ( 615c1081-5d03-415a-b57c-76876bb2cf23
// )
//
// typedef struct _MPRI_INTERFACE_1 {
//
// WCHAR wszInterfaceName[257];
//
// DWORD dwInterface;
//
// BOOL fEnabled;
//
// ROUTER_INTERFACE_TYPE dwIfType;
//
// ROUTER_CONNECTION_STATE dwConnectionState;
//
// DWORD fUnReachabilityReasons;
//
// DWORD dwLastError;
//
// LPWSTR lpwsDialoutHoursRestriction;
//
// } MPRI_INTERFACE_1,
type Interface1 struct {
	// wszInterfaceName: The same as wszInterfaceName in MPRI_INTERFACE_0 (section 2.2.1.2.81)
	// structure.
	InterfaceName []uint16 `idl:"name:wszInterfaceName" json:"interface_name"`
	// dwInterface: The same as dwInterface in MPRI_INTERFACE_0.
	Interface uint32 `idl:"name:dwInterface" json:"interface"`
	// fEnabled: The same as fEnabled in MPRI_INTERFACE_0.
	Enabled bool `idl:"name:fEnabled" json:"enabled"`
	// dwIfType: The same as dwIfType in MPRI_INTERFACE_0.
	InterfaceType RouterInterfaceType `idl:"name:dwIfType" json:"interface_type"`
	// dwConnectionState: The same as dwConnectionState in MPRI_INTERFACE_0.
	ConnectionState RouterConnectionState `idl:"name:dwConnectionState" json:"connection_state"`
	// fUnReachabilityReasons: The same as fUnReachabilityReasons in MPRI_INTERFACE_0.
	UnReachabilityReasons uint32 `idl:"name:fUnReachabilityReasons" json:"un_reachability_reasons"`
	// dwLastError: The same as dwLastError in MPRI_INTERFACE_0.
	LastError uint32 `idl:"name:dwLastError" json:"last_error"`
	// lpwsDialoutHoursRestriction: Pointer to a Unicode string that specifies the times
	// during which dial-out is restricted. The format for this string is as follows.
	//
	// <day><space><time range><space><time range>. . .<NULL><day>. . .<NULL><NULL>
	//
	// Where <day> is a numeral that corresponds to a day of the week.
	//
	//	+-------+-----------+
	//	|       |           |
	//	| VALUE |  MEANING  |
	//	|       |           |
	//	+-------+-----------+
	//	+-------+-----------+
	//	|     0 | Sunday    |
	//	+-------+-----------+
	//	|     1 | Monday    |
	//	+-------+-----------+
	//	|     2 | Tuesday   |
	//	+-------+-----------+
	//	|     3 | Wednesday |
	//	+-------+-----------+
	//	|     4 | Thursday  |
	//	+-------+-----------+
	//	|     5 | Friday    |
	//	+-------+-----------+
	//	|     6 | Saturday  |
	//	+-------+-----------+
	//
	// <Time range> is of the form HH:MM-HH:MM, using 24-hour notation.
	//
	// <space> denotes a space character.
	//
	// <NULL> denotes a null character. The restriction string is terminated by two consecutive
	// null characters as in the following example:
	//
	// 2 09:00-12:00 13:00-17:30<NULL>4 09:00-12:00 13:00-17:30<NULL><NULL>
	DialoutHoursRestriction string `idl:"name:lpwsDialoutHoursRestriction" json:"dialout_hours_restriction"`
}

func (o *Interface1) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *Interface1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	for i1 := range o.InterfaceName {
		i1 := i1
		if uint64(i1) >= 257 {
			break
		}
		if err := w.WriteData(o.InterfaceName[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.InterfaceName); uint64(i1) < 257; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Interface); err != nil {
		return err
	}
	if !o.Enabled {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if err := w.WriteEnum(uint16(o.InterfaceType)); err != nil {
		return err
	}
	if err := w.WriteEnum(uint16(o.ConnectionState)); err != nil {
		return err
	}
	if err := w.WriteData(o.UnReachabilityReasons); err != nil {
		return err
	}
	if err := w.WriteData(o.LastError); err != nil {
		return err
	}
	if o.DialoutHoursRestriction != "" {
		_ptr_lpwsDialoutHoursRestriction := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16String(ctx, w, o.DialoutHoursRestriction); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.DialoutHoursRestriction, _ptr_lpwsDialoutHoursRestriction); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *Interface1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	o.InterfaceName = make([]uint16, 257)
	for i1 := range o.InterfaceName {
		i1 := i1
		if err := w.ReadData(&o.InterfaceName[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.Interface); err != nil {
		return err
	}
	var _bEnabled int32
	if err := w.ReadData(&_bEnabled); err != nil {
		return err
	}
	o.Enabled = _bEnabled != 0
	if err := w.ReadEnum((*uint16)(&o.InterfaceType)); err != nil {
		return err
	}
	if err := w.ReadEnum((*uint16)(&o.ConnectionState)); err != nil {
		return err
	}
	if err := w.ReadData(&o.UnReachabilityReasons); err != nil {
		return err
	}
	if err := w.ReadData(&o.LastError); err != nil {
		return err
	}
	_ptr_lpwsDialoutHoursRestriction := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16String(ctx, w, &o.DialoutHoursRestriction); err != nil {
			return err
		}
		return nil
	})
	_s_lpwsDialoutHoursRestriction := func(ptr interface{}) { o.DialoutHoursRestriction = *ptr.(*string) }
	if err := w.ReadPointer(&o.DialoutHoursRestriction, _s_lpwsDialoutHoursRestriction, _ptr_lpwsDialoutHoursRestriction); err != nil {
		return err
	}
	return nil
}

// Interface2 structure represents MPRI_INTERFACE_2 RPC structure.
//
// The MPRI_INTERFACE_2 structure<62> is used to contain data for a router demand-dial
// interface. This structure is used in the following methods:
//
// * *RRouterInterfaceCreate (section 3.1.4.13)* ( 72bead5c-821f-4e98-bacd-0de279552379
// )
//
// * *RRouterInterfaceGetInfo (section 3.1.4.14)* ( 2fbcf316-2082-4f98-878b-eab5d0c2da1d
// )
//
// * *RRouterInterfaceSetInfo (section 3.1.4.15)* ( 615c1081-5d03-415a-b57c-76876bb2cf23
// )
//
// typedef struct _MPRI_INTERFACE_2 {
//
// WCHAR wszInterfaceName[257];
//
// DWORD dwInterface;
//
// BOOL fEnabled;
//
// ROUTER_INTERFACE_TYPE dwIfType;
//
// ROUTER_CONNECTION_STATE dwConnectionState;
//
// DWORD fUnReachabilityReasons;
//
// DWORD dwLastError;
//
// DWORD dwfOptions;
//
// WCHAR szLocalPhoneNumber[129];
//
// PWCHAR szAlternates;
//
// DWORD ipaddr;
//
// DWORD ipaddrDns;
//
// DWORD ipaddrDnsAlt;
//
// DWORD ipaddrWins;
//
// DWORD ipaddrWinsAlt;
//
// DWORD dwfNetProtocols;
//
// WCHAR szDeviceType[17];
//
// WCHAR szDeviceName[129];
//
// WCHAR szX25PadType[33];
//
// WCHAR szX25Address[201];
//
// WCHAR szX25Facilities[201];
//
// WCHAR szX25UserData[201];
//
// DWORD dwChannels;
//
// DWORD dwSubEntries;
//
// DWORD dwDialMode;
//
// DWORD dwDialExtraPercent;
//
// DWORD dwDialExtraSampleSeconds;
//
// DWORD dwHangUpExtraPercent;
//
// DWORD dwHangUpExtraSampleSeconds;
//
// DWORD dwIdleDisconnectSeconds;
//
// DWORD dwType;
//
// DWORD dwEncryptionType;
//
// DWORD dwCustomAuthKey;
//
// DWORD dwCustomAuthDataSize;
//
// LPBYTE lpbCustomAuthData;
//
// GUID guidId;
//
// DWORD dwVpnStrategy;
//
// } MPRI_INTERFACE_2,
type Interface2 struct {
	// wszInterfaceName: Specifies a Unicode string that contains the name of a valid interface.
	// This value MUST be specified during the call to the RRouterInterfaceCreate<63> method
	// and cannot be modified after the interface is created.<64>
	InterfaceName []uint16 `idl:"name:wszInterfaceName" json:"interface_name"`
	// dwInterface: Specifies a unique identifier of the interface. This is a read-only
	// field and cannot be set or modified.
	Interface uint32 `idl:"name:dwInterface" json:"interface"`
	// fEnabled: Specifies whether the interface is enabled. The value TRUE is greater than
	// zero (0) if the interface is enabled, or FALSE is zero (0) if the interface is disabled
	// by an administrator.
	//
	//	+---------+----------------------------+
	//	|         |                            |
	//	|  VALUE  |          MEANING           |
	//	|         |                            |
	//	+---------+----------------------------+
	//	+---------+----------------------------+
	//	| TRUE >0 | The interface is enabled.  |
	//	+---------+----------------------------+
	//	| FALSE 0 | The interface is disabled. |
	//	+---------+----------------------------+
	Enabled bool `idl:"name:fEnabled" json:"enabled"`
	// dwIfType: A ROUTER_INTERFACE_TYPE (section 2.2.1.1.1) value that specifies the type
	// of  interface.
	InterfaceType RouterInterfaceType `idl:"name:dwIfType" json:"interface_type"`
	// dwConnectionState: A ROUTER_CONNECTION_STATE (section 2.2.1.1.2) value that specifies
	// the current state of the interface (for example: connected, disconnected, or unreachable).
	// This is a read-only field and cannot be set or modified.
	ConnectionState RouterConnectionState `idl:"name:dwConnectionState" json:"connection_state"`
	// fUnReachabilityReasons: A value that describes the reason that the interface is unreachable.
	// This is a read-only field and cannot be set or modified. The following is the list
	// of possible values.
	//
	//	+----------------------------------------------------+----------------------------------------------------------+
	//	|                                                    |                                                          |
	//	|                       VALUE                        |                         MEANING                          |
	//	|                                                    |                                                          |
	//	+----------------------------------------------------+----------------------------------------------------------+
	//	+----------------------------------------------------+----------------------------------------------------------+
	//	| MPR_INTERFACE_ADMIN_DISABLED 0x00000002            | The administrator has disabled the interface.            |
	//	+----------------------------------------------------+----------------------------------------------------------+
	//	| MPR_INTERFACE_CONNECTION_FAILURE 0x00000004        | The previous connection attempt failed.                  |
	//	+----------------------------------------------------+----------------------------------------------------------+
	//	| MPR_INTERFACE_DIALOUT_HOURS_RESTRICTION 0x00000010 | Dial-out is not allowed at the current time.             |
	//	+----------------------------------------------------+----------------------------------------------------------+
	//	| MPR_INTERFACE_OUT_OF_RESOURCES 0x00000001          | No ports or devices are available for use.               |
	//	+----------------------------------------------------+----------------------------------------------------------+
	//	| MPR_INTERFACE_SERVICE_PAUSED 0x00000008            | The service is paused.                                   |
	//	+----------------------------------------------------+----------------------------------------------------------+
	//	| MPR_INTERFACE_NO_MEDIA_SENSE 0x00000020            | The network cable is disconnected from the network card. |
	//	+----------------------------------------------------+----------------------------------------------------------+
	//	| MPR_INTERFACE_NO_DEVICE 0x00000040                 | The network card has been removed from the machine.      |
	//	+----------------------------------------------------+----------------------------------------------------------+
	UnReachabilityReasons uint32 `idl:"name:fUnReachabilityReasons" json:"un_reachability_reasons"`
	// dwLastError: Contains a nonzero value if the interface fails to connect. This value
	// is a Win32 error code as defined in [MS-ERREF]. This is a read-only field and cannot
	// be set or modified.
	LastError uint32 `idl:"name:dwLastError" json:"last_error"`
	// dwfOptions: A value that specifies the bit flags that are used to set connection
	// options. This value SHOULD<65> be a combination of the flags listed in the following
	// table.
	//
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                                   |                                                                                  |
	//	|                       VALUE                       |                                     MEANING                                      |
	//	|                                                   |                                                                                  |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_SpecificIpAddr 0x00000002                   | If this flag is set, the RRAS server attempts to use the IP address specified by |
	//	|                                                   | the ipaddr field as the IP address for the dial-up connection. If this flag is   |
	//	|                                                   | not set, the value of the ipaddr member is ignored.                              |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_SpecificNameServers 0x00000004              | If this flag is set, the RRAS server uses the ipaddrDns, ipaddrDnsAlt,           |
	//	|                                                   | ipaddrWins, and ipaddrWinsAlt members to specify the name server addresses for   |
	//	|                                                   | the dial-up connection. If this flag is not set, the RRAS server ignores these   |
	//	|                                                   | members.                                                                         |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_IpHeaderCompression 0x00000008              | If this flag is set, the RRAS server negotiates to use the IP header             |
	//	|                                                   | compression on PPP connections. The IP header compression can significantly      |
	//	|                                                   | improve performance. If this flag is not set, the IP header compression is not   |
	//	|                                                   | negotiated.                                                                      |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_RemoteDefaultGateway 0x00000010             | If this flag is set, the default route for the IP packets is through the dial-up |
	//	|                                                   | adapter when the connection is active. If this flag is cleared, the default      |
	//	|                                                   | route is not modified.                                                           |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_DisableLcpExtensions 0x00000020             | If this flag is set, the PPP LCP extensions defined in [RFC1570] are disabled    |
	//	|                                                   | for the connection associated with the interface. This flag MUST not be set,     |
	//	|                                                   | unless interoperating with some older PPP implementations that do not support    |
	//	|                                                   | LCP extensions.                                                                  |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_SwCompression 0x00000200                    | If this flag is set, software compression is negotiated on the link. Setting     |
	//	|                                                   | this flag causes the PPP to attempt to negotiate a Compression Control Protocol  |
	//	|                                                   | (CCP) with the server. This flag SHOULD be set by default but clearing it        |
	//	|                                                   | can reduce the negotiation period if the server does not support a compatible    |
	//	|                                                   | compression protocol.                                                            |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_RequireEncryptedPw 0x00000400               | If this flag is set, only secure password schemes can be used to authenticate    |
	//	|                                                   | the client with the server. This prevents the PPP from using the PAP plaintext   |
	//	|                                                   | authentication protocol to authenticate the client. However, the [MS-CHAP],      |
	//	|                                                   | MD5-CHAP, and SPAP authentication protocols are supported. For increased         |
	//	|                                                   | security, set this flag. For increased interoperability, clear this flag.        |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_RequireMsEncryptedPw 0x00000800             | If this flag is set, it prevents the PPP from using the PAP plaintext            |
	//	|                                                   | authentication protocol, MD5-CHAP, or SPAP. For increased security, set          |
	//	|                                                   | this flag. For increased interoperability, clear this flag. This flag takes      |
	//	|                                                   | precedence over MPRIO_RequireEncryptedPw.                                        |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_RequireDataEncryption 0x00001000            | If this flag is set, data encryption MUST be negotiated successfully or the      |
	//	|                                                   | connection is dropped. This flag is ignored unless MPRIO_RequireMsEncryptedPw is |
	//	|                                                   | also set.                                                                        |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_UseLogonCredentials 0x00004000              | If this flag is set, the RRAS server uses the username, password, and domain     |
	//	|                                                   | of the currently logged-on user when dialing this entry. This flag is ignored    |
	//	|                                                   | unless MPRIO_RequireMsEncryptedPw is also set.                                   |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_PromoteAlternates 0x00008000                | This flag has an effect when alternate phone numbers are defined by the          |
	//	|                                                   | szAlternates member. If this flag is set, an alternate phone number that         |
	//	|                                                   | connects successfully becomes the primary phone number, and the current primary  |
	//	|                                                   | phone number is moved to the alternate list.                                     |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_SecureLocalFiles 0x00010000                 | If this flag is set, the RRAS server checks for an existing remote file          |
	//	|                                                   | system and remote printer bindings before making a connection with this entry.   |
	//	|                                                   | Typically, this flag is set on phone book entries for public networks to remind  |
	//	|                                                   | users to break connections to their private network before connecting to a       |
	//	|                                                   | public network.                                                                  |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_RequireEAP 0x00020000                       | If this flag is set, Extensible Authentication Protocol (EAP) MUST be supported  |
	//	|                                                   | for authentication.                                                              |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_RequirePAP 0x00040000                       | If this flag is set, Password Authentication Protocol (PAP) MUST be supported    |
	//	|                                                   | for authentication.                                                              |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_RequireSPAP 0x00080000                      | If this flag is set, Shiva's Password Authentication Protocol (SPAP) MUST be     |
	//	|                                                   | supported for authentication.                                                    |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_SharedPhoneNumbers 0x00800000               | This flag is not used.                                                           |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_RequireCHAP 0x08000000                      | If this flag is set, the Challenge Handshake Authentication Protocol (CHAP) MUST |
	//	|                                                   | be supported for authentication.                                                 |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_RequireMsCHAP 0x10000000                    | If this flag is set, the Microsoft Challenge Handshake Authentication Protocol   |
	//	|                                                   | [MS-CHAP] MUST be supported for authentication.                                  |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_RequireMsCHAP2 0x20000000                   | If this flag is set, version 2 of the [MS-CHAP] MUST be supported for            |
	//	|                                                   | authentication.                                                                  |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_IpSecPreSharedKey 0x80000000                | Configured the demand-dial interface to use preshared key.                       |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_RequireMachineCertificates 0x01000000       | If this flag is set, the machine certificate is to be used for IKEv2             |
	//	|                                                   | authentication.                                                                  |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_UsePreSharedKeyForIkev2Initiator 0x02000000 | If this flag is set, a preshared key is to be used by the initiator of the IKEv2 |
	//	|                                                   | connection for authentication.                                                   |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_UsePreSharedKeyForIkev2Responder 0x04000000 | If this flag is set, a preshared key is to be used by the responder of the IKEv2 |
	//	|                                                   | connection for authentication.                                                   |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	Options uint32 `idl:"name:dwfOptions" json:"options"`
	// szLocalPhoneNumber: A null-terminated Unicode string that contains the local telephone
	// number or the destination IP, IPv4, or IPv6 address.
	LocalPhoneNumber []uint16 `idl:"name:szLocalPhoneNumber" json:"local_phone_number"`
	// szAlternates: Offset from the beginning of this structure where the alternate phone
	// numbers are stored. If no alternate phone number is available, this value MUST be
	// set to 0. Alternate phone numbers are a list of consecutive null-terminated Unicode
	// strings. The last string is terminated by two consecutive null characters. The strings
	// are alternate phone numbers that the router dials, in the order listed, if the primary
	// number fails to connect. For more information, see the description of szLocalPhoneNumber.
	// The alternate phone numbers MUST be stored after the CustomAuthData field that is
	// appended at the end of this structure.
	Alternates string `idl:"name:szAlternates" json:"alternates"`
	// ipaddr: A value that specifies the IP address to be used while this connection is
	// active. This member is ignored unless dwfOptions specifies the MPRIO_SpecificIpAddr
	// flag.
	IPAddr uint32 `idl:"name:ipaddr" json:"ip_addr"`
	// ipaddrDns: A value that specifies the IP address of the DNS server to be used while
	// this connection is active. This member is ignored unless dwfOptions specifies the
	// MPRIO_SpecificNameServers flag.
	IPAddrDNS uint32 `idl:"name:ipaddrDns" json:"ip_addr_dns"`
	// ipaddrDnsAlt: A value that specifies the IP address of a secondary or backup DNS
	// server to be used while this connection is active. This member is ignored unless
	// dwfOptions specifies the MPRIO_SpecificNameServers flag.
	IPAddrDNSAlt uint32 `idl:"name:ipaddrDnsAlt" json:"ip_addr_dns_alt"`
	// ipaddrWins: A value that specifies the IP address of the WINS server to be used while
	// this connection is active. This member is ignored unless dwfOptions specifies the
	// MPRIO_SpecificNameServers flag.
	IPAddrWINS uint32 `idl:"name:ipaddrWins" json:"ip_addr_wins"`
	// ipaddrWinsAlt: A value that specifies the IP address of a secondary WINS server to
	// be used while this connection is active. This member is ignored unless dwfOptions
	// specifies the MPRIO_SpecificNameServers flag.
	IPAddrWINSAlt uint32 `idl:"name:ipaddrWinsAlt" json:"ip_addr_wins_alt"`
	// dwfNetProtocols: A value that specifies the network protocols to negotiate. This
	// member can be a combination of the following flags.<66>
	//
	//	+-----------------------+----------------------------------+
	//	|                       |                                  |
	//	|         VALUE         |             MEANING              |
	//	|                       |                                  |
	//	+-----------------------+----------------------------------+
	//	+-----------------------+----------------------------------+
	//	| MPRNP_Ipx 0x00000002  | Negotiate the IPX protocol.      |
	//	+-----------------------+----------------------------------+
	//	| MPRNP_Ip 0x00000004   | Negotiate the TCP/IPv4 protocol. |
	//	+-----------------------+----------------------------------+
	//	| MPRNP_Ipv6 0x00000008 | Negotiate the TCP/IPv6 protocol. |
	//	+-----------------------+----------------------------------+
	NetProtocols uint32 `idl:"name:dwfNetProtocols" json:"net_protocols"`
	// szDeviceType: A value that specifies a null-terminated Unicode string that indicates
	// the RRAS server device type that is referenced by szDeviceName. This is a read-only
	// field that is computed based on the value of szDeviceName. This member can be one
	// of the following string constants.
	//
	//	+-------------------------------+------------------------------------------------------------------+
	//	|                               |                                                                  |
	//	|             VALUE             |                             MEANING                              |
	//	|                               |                                                                  |
	//	+-------------------------------+------------------------------------------------------------------+
	//	+-------------------------------+------------------------------------------------------------------+
	//	| MPRDT_Modem "Modem"           | A modem that is accessed through a COM port.                     |
	//	+-------------------------------+------------------------------------------------------------------+
	//	| MPRDT_Isdn "Isdn"             | An ISDN adapter with the corresponding NDISWAN driver installed. |
	//	+-------------------------------+------------------------------------------------------------------+
	//	| MPRDT_X25 "x25"               | An X.25 adapter with the corresponding NDISWAN driver installed. |
	//	+-------------------------------+------------------------------------------------------------------+
	//	| MPRDT_Vpn "Vpn"               | A VPN connection.                                                |
	//	+-------------------------------+------------------------------------------------------------------+
	//	| MPRDT_Pad "Pad"               | A packet assembler/disassembler.                                 |
	//	+-------------------------------+------------------------------------------------------------------+
	//	| MPRDT_Generic "GENERIC"       | Generic.                                                         |
	//	+-------------------------------+------------------------------------------------------------------+
	//	| MPRDT_Serial "SERIAL"         | Direct serial connection through a serial port.                  |
	//	+-------------------------------+------------------------------------------------------------------+
	//	| MPRDT_FrameRelay "FRAMERELAY" | Frame relay.                                                     |
	//	+-------------------------------+------------------------------------------------------------------+
	//	| MPRDT_Atm "ATM"               | Asynchronous transfer mode.                                      |
	//	+-------------------------------+------------------------------------------------------------------+
	//	| MPRDT_Sonet "SONET"           | Sonet.                                                           |
	//	+-------------------------------+------------------------------------------------------------------+
	//	| MPRDT_SW56 "SW56"             | Switched 56K access.                                             |
	//	+-------------------------------+------------------------------------------------------------------+
	//	| MPRDT_Irda "IRDA"             | An Infrared Data Association (IrDA)-compliant device.            |
	//	+-------------------------------+------------------------------------------------------------------+
	//	| MPRDT_Parallel "PARALLEL"     | Direct parallel connection through a parallel port.              |
	//	+-------------------------------+------------------------------------------------------------------+
	DeviceType []uint16 `idl:"name:szDeviceType" json:"device_type"`
	// szDeviceName: Specifies a null-terminated Unicode string that contains the name of
	// a telephony application programming interface (TAPI) device to use with this phone
	// book entry, for example, "Fabrikam Inc 28800 External". To enumerate all available
	// RAS-capable devices, use the RRouterDeviceEnum (section 3.1.4.37) function.
	DeviceName []uint16 `idl:"name:szDeviceName" json:"device_name"`
	// szX25PadType: Contains a null-terminated Unicode string that identifies the X.25
	// PAD type. This value SHOULD be set to an empty string ("") unless the entry dials
	// using an X.25 PAD.<67>
	X25PadType []uint16 `idl:"name:szX25PadType" json:"x25_pad_type"`
	// szX25Address: Contains a null-terminated Unicode string that identifies the X.25
	// address to connect to. This value SHOULD be set to an empty string ("") unless the
	// entry dials using an X.25 PAD or native X.25 device.<68>
	X25Address []uint16 `idl:"name:szX25Address" json:"x25_address"`
	// szX25Facilities: Contains a null-terminated Unicode string that specifies the facilities
	// to request from the X.25 host at connection time. This member is ignored if szX25Address
	// is an empty string ("").
	X25Facilities []uint16 `idl:"name:szX25Facilities" json:"x25_facilities"`
	// szX25UserData: Contains a null-terminated Unicode string that specifies additional
	// connection data supplied to the X.25 host at connection time. This member is ignored
	// if szX25Address is an empty string ("").
	X25UserData []uint16 `idl:"name:szX25UserData" json:"x25_user_data"`
	// dwChannels: Not used and MUST be set to zero (0).
	Channels uint32 `idl:"name:dwChannels" json:"channels"`
	// dwSubEntries: A value that specifies the number of multilink subentries associated
	// with this entry. This is a read-only field that cannot be set or modified. Multilink
	// subentries can be added and configured as described in 3.1.4.40. Multilink subentries
	// can be removed by updating the Media section of the phonebook file as specified in
	// 2.2.2.2.96.
	SubEntries uint32 `idl:"name:dwSubEntries" json:"sub_entries"`
	// dwDialMode: Indicates whether the RRAS server dials all of this entry's multilink
	// subentries when the entry is first connected. This member can be one of the following
	// values.
	//
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	|                               |                                                                                  |
	//	|             VALUE             |                                     MEANING                                      |
	//	|                               |                                                                                  |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000                    | Dial the first available device only.                                            |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	| MPRDM_DialAll 0x00000001      | Dial all subentries initially.                                                   |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	| MPRDM_DialAsNeeded 0x00000002 | Adjust the number of subentries as bandwidth is required. The RRAS server uses   |
	//	|                               | the dwDialExtraPercent, dwDialExtraSampleSeconds, dwDialHangUpExtraPercent,      |
	//	|                               | and dwHangUpExtraSampleSeconds members to determine when to dial or disconnect   |
	//	|                               | a subentry. This value SHOULD<69> be ignored and treated identically to          |
	//	|                               | MPRDM_DialAll.                                                                   |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	DialMode uint32 `idl:"name:dwDialMode" json:"dial_mode"`
	// dwDialExtraPercent: A value that specifies the percentage of the total bandwidth
	// that is available from the currently connected subentries. The RRAS server dials
	// an additional subentry when the total bandwidth that is used exceeds the percentage
	// limit (dwDialExtraPercent) of the available bandwidth for at least dwDialExtraSampleSeconds
	// seconds.
	DialExtraPercent uint32 `idl:"name:dwDialExtraPercent" json:"dial_extra_percent"`
	// dwDialExtraSampleSeconds: A value that specifies the time, in seconds, for which
	// current bandwidth usage MUST exceed the threshold that is specified by dwHangUpExtraSampleSeconds
	// before the RRAS server dials an additional subentry.
	DialExtraSampleSeconds uint32 `idl:"name:dwDialExtraSampleSeconds" json:"dial_extra_sample_seconds"`
	// dwHangUpExtraPercent: A value that specifies the percentage of the total bandwidth
	// that is available from the currently connected subentries. The RRAS server terminates
	// (hangs up) an existing subentry connection when the total bandwidth used is less
	// than the percentage limit, indicated by dwHangUpExtraPercent, of the available bandwidth
	// for at least dwHangUpExtraSampleSeconds seconds.
	HangUpExtraPercent uint32 `idl:"name:dwHangUpExtraPercent" json:"hang_up_extra_percent"`
	// dwHangUpExtraSampleSeconds: A value that specifies the time, in seconds, for which
	// current bandwidth usage MUST be less than the threshold that is specified by dwHangUpExtraPercent
	// before the RRAS server terminates an existing subentry connection.
	HangUpExtraSampleSeconds uint32 `idl:"name:dwHangUpExtraSampleSeconds" json:"hang_up_extra_sample_seconds"`
	// dwIdleDisconnectSeconds: A value that specifies the time, in seconds, after which
	// an idle connection is terminated. Unless the idle time-out is disabled, the entire
	// connection is terminated if the connection is idle for the specified dwIdleDisconnectSeconds.
	// This member can specify either a time-out value or one of the following values.
	//
	//	+----------------------------------+------------------------------------------------+
	//	|                                  |                                                |
	//	|              VALUE               |                    MEANING                     |
	//	|                                  |                                                |
	//	+----------------------------------+------------------------------------------------+
	//	+----------------------------------+------------------------------------------------+
	//	| MPRIDS_UseGlobalValue 0x00000000 | Use the user preference value as the default.  |
	//	+----------------------------------+------------------------------------------------+
	//	| MPRIDS_Disabled 0xFFFFFFFF       | There is no idle time-out for this connection. |
	//	+----------------------------------+------------------------------------------------+
	IdleDisconnectSeconds uint32 `idl:"name:dwIdleDisconnectSeconds" json:"idle_disconnect_seconds"`
	// dwType: A value that specifies the type of phone book entry. This is a read-only
	// field and specifies the type of entry based on the value of the szDeviceType member.
	// This member can be one of the following types.<70>
	//
	//	+-------------------------+-------------------------------------------------+
	//	|                         |                                                 |
	//	|          VALUE          |                     MEANING                     |
	//	|                         |                                                 |
	//	+-------------------------+-------------------------------------------------+
	//	+-------------------------+-------------------------------------------------+
	//	| MPRET_Phone 0x00000001  | Phone line (for example: modem, ISDN, or X.25). |
	//	+-------------------------+-------------------------------------------------+
	//	| MPRET_Vpn 0x00000002    | Virtual private network (VPN).                  |
	//	+-------------------------+-------------------------------------------------+
	//	| MPRET_Direct 0x00000003 | Direct serial or parallel connection.           |
	//	+-------------------------+-------------------------------------------------+
	Type uint32 `idl:"name:dwType" json:"type"`
	// dwEncryptionType: A value that specifies the type of encryption to use for Microsoft
	// Point-to-Point Encryption (MPPE) with the connection. This member can be one of the
	// following values.
	//
	//	+------------------------------+----------------------------------+
	//	|                              |                                  |
	//	|            VALUE             |             MEANING              |
	//	|                              |                                  |
	//	+------------------------------+----------------------------------+
	//	+------------------------------+----------------------------------+
	//	| MPR_ET_None 0x00000000       | Do not use encryption.           |
	//	+------------------------------+----------------------------------+
	//	| MPR_ET_Require 0x00000001    | Use encryption.                  |
	//	+------------------------------+----------------------------------+
	//	| MPR_ET_RequireMax 0x00000002 | Use maximum-strength encryption. |
	//	+------------------------------+----------------------------------+
	//	| MPR_ET_Optional 0x00000003   | If possible, use encryption.     |
	//	+------------------------------+----------------------------------+
	EncryptionType uint32 `idl:"name:dwEncryptionType" json:"encryption_type"`
	// dwCustomAuthKey: A value that specifies the authentication key to be provided to
	// an EAP vendor.
	CustomAuthKey uint32 `idl:"name:dwCustomAuthKey" json:"custom_auth_key"`
	// dwCustomAuthDataSize: A value that specifies the size of the data pointed to by the
	// lpbCustomAuthData member.
	CustomAuthDataSize uint32 `idl:"name:dwCustomAuthDataSize" json:"custom_auth_data_size"`
	// lpbCustomAuthData: Offset from the beginning of this structure where the CustomAuthData
	// is stored. If CustomAuthData is not specified, it MUST be set to 0. CustomAuthData
	// is the authentication data to use with EAP. CustomAuthData MUST be appended to the
	// end of this structure.
	CustomAuthData uint8 `idl:"name:lpbCustomAuthData" json:"custom_auth_data"`
	// guidId: The GUID that represents this phone book entry. This member is read-only.
	ID *dtyp.GUID `idl:"name:guidId" json:"id"`
	// dwVpnStrategy: The VPN strategy to use when dialing a VPN connection. This member
	// can have one of the following values.<71>
	//
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	|                              |                                                                                  |
	//	|            VALUE             |                                     MEANING                                      |
	//	|                              |                                                                                  |
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	| MPR_VS_Default 0x00000000    | The RRAS server dials the PPTP first. If the PPTP fails, the L2TP is attempted.  |
	//	|                              | If the L2TP fails, the IKEv2 is attempted. The protocol that succeeds is tried   |
	//	|                              | first in subsequent dialing for this entry.                                      |
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	| MPR_VS_PptpOnly 0x00000001   | The RRAS server dials only the PPTP.                                             |
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	| MPR_VS_PptpFirst 0x00000002  | The RRAS server always dials the PPTP first, the L2TP second, and the IKEv2      |
	//	|                              | third.                                                                           |
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	| MPR_VS_L2tpOnly 0x00000003   | The RRAS server dials only the L2TP.                                             |
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	| MPR_VS_L2tpFirst 0x00000004  | The RRAS server dials the L2TP first, the PPTP second, and the IKEv2 third.      |
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	| MPR_VS_Ikev2Only 0x00000007  | The RRAS server dials only the IKEv2.                                            |
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	| MPR_VS_Ikev2First 0x00000008 | The RRAS server dials the IKEv2 first, the PPTP second, and the L2TP third.      |
	//	+------------------------------+----------------------------------------------------------------------------------+
	VPNStrategy uint32 `idl:"name:dwVpnStrategy" json:"vpn_strategy"`
}

func (o *Interface2) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *Interface2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	for i1 := range o.InterfaceName {
		i1 := i1
		if uint64(i1) >= 257 {
			break
		}
		if err := w.WriteData(o.InterfaceName[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.InterfaceName); uint64(i1) < 257; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Interface); err != nil {
		return err
	}
	if !o.Enabled {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if err := w.WriteEnum(uint16(o.InterfaceType)); err != nil {
		return err
	}
	if err := w.WriteEnum(uint16(o.ConnectionState)); err != nil {
		return err
	}
	if err := w.WriteData(o.UnReachabilityReasons); err != nil {
		return err
	}
	if err := w.WriteData(o.LastError); err != nil {
		return err
	}
	if err := w.WriteData(o.Options); err != nil {
		return err
	}
	for i1 := range o.LocalPhoneNumber {
		i1 := i1
		if uint64(i1) >= 129 {
			break
		}
		if err := w.WriteData(o.LocalPhoneNumber[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.LocalPhoneNumber); uint64(i1) < 129; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	if o.Alternates != "" {
		_ptr_szAlternates := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16String(ctx, w, o.Alternates); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Alternates, _ptr_szAlternates); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.IPAddr); err != nil {
		return err
	}
	if err := w.WriteData(o.IPAddrDNS); err != nil {
		return err
	}
	if err := w.WriteData(o.IPAddrDNSAlt); err != nil {
		return err
	}
	if err := w.WriteData(o.IPAddrWINS); err != nil {
		return err
	}
	if err := w.WriteData(o.IPAddrWINSAlt); err != nil {
		return err
	}
	if err := w.WriteData(o.NetProtocols); err != nil {
		return err
	}
	for i1 := range o.DeviceType {
		i1 := i1
		if uint64(i1) >= 17 {
			break
		}
		if err := w.WriteData(o.DeviceType[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.DeviceType); uint64(i1) < 17; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	for i1 := range o.DeviceName {
		i1 := i1
		if uint64(i1) >= 129 {
			break
		}
		if err := w.WriteData(o.DeviceName[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.DeviceName); uint64(i1) < 129; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	for i1 := range o.X25PadType {
		i1 := i1
		if uint64(i1) >= 33 {
			break
		}
		if err := w.WriteData(o.X25PadType[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.X25PadType); uint64(i1) < 33; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	for i1 := range o.X25Address {
		i1 := i1
		if uint64(i1) >= 201 {
			break
		}
		if err := w.WriteData(o.X25Address[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.X25Address); uint64(i1) < 201; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	for i1 := range o.X25Facilities {
		i1 := i1
		if uint64(i1) >= 201 {
			break
		}
		if err := w.WriteData(o.X25Facilities[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.X25Facilities); uint64(i1) < 201; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	for i1 := range o.X25UserData {
		i1 := i1
		if uint64(i1) >= 201 {
			break
		}
		if err := w.WriteData(o.X25UserData[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.X25UserData); uint64(i1) < 201; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Channels); err != nil {
		return err
	}
	if err := w.WriteData(o.SubEntries); err != nil {
		return err
	}
	if err := w.WriteData(o.DialMode); err != nil {
		return err
	}
	if err := w.WriteData(o.DialExtraPercent); err != nil {
		return err
	}
	if err := w.WriteData(o.DialExtraSampleSeconds); err != nil {
		return err
	}
	if err := w.WriteData(o.HangUpExtraPercent); err != nil {
		return err
	}
	if err := w.WriteData(o.HangUpExtraSampleSeconds); err != nil {
		return err
	}
	if err := w.WriteData(o.IdleDisconnectSeconds); err != nil {
		return err
	}
	if err := w.WriteData(o.Type); err != nil {
		return err
	}
	if err := w.WriteData(o.EncryptionType); err != nil {
		return err
	}
	if err := w.WriteData(o.CustomAuthKey); err != nil {
		return err
	}
	if err := w.WriteData(o.CustomAuthDataSize); err != nil {
		return err
	}
	// XXX pointer to primitive type, default behavior is to write non-null pointer.
	// if this behavior is not desired, use goext_default_null([cond]) attribute.
	_ptr_lpbCustomAuthData := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
		if err := w.WriteData(o.CustomAuthData); err != nil {
			return err
		}
		return nil
	})
	if err := w.WritePointer(&o.CustomAuthData, _ptr_lpbCustomAuthData); err != nil {
		return err
	}
	if o.ID != nil {
		if err := o.ID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.VPNStrategy); err != nil {
		return err
	}
	if err := w.WriteTrailingGap(9); err != nil {
		return err
	}
	return nil
}
func (o *Interface2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	o.InterfaceName = make([]uint16, 257)
	for i1 := range o.InterfaceName {
		i1 := i1
		if err := w.ReadData(&o.InterfaceName[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.Interface); err != nil {
		return err
	}
	var _bEnabled int32
	if err := w.ReadData(&_bEnabled); err != nil {
		return err
	}
	o.Enabled = _bEnabled != 0
	if err := w.ReadEnum((*uint16)(&o.InterfaceType)); err != nil {
		return err
	}
	if err := w.ReadEnum((*uint16)(&o.ConnectionState)); err != nil {
		return err
	}
	if err := w.ReadData(&o.UnReachabilityReasons); err != nil {
		return err
	}
	if err := w.ReadData(&o.LastError); err != nil {
		return err
	}
	if err := w.ReadData(&o.Options); err != nil {
		return err
	}
	o.LocalPhoneNumber = make([]uint16, 129)
	for i1 := range o.LocalPhoneNumber {
		i1 := i1
		if err := w.ReadData(&o.LocalPhoneNumber[i1]); err != nil {
			return err
		}
	}
	_ptr_szAlternates := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16String(ctx, w, &o.Alternates); err != nil {
			return err
		}
		return nil
	})
	_s_szAlternates := func(ptr interface{}) { o.Alternates = *ptr.(*string) }
	if err := w.ReadPointer(&o.Alternates, _s_szAlternates, _ptr_szAlternates); err != nil {
		return err
	}
	if err := w.ReadData(&o.IPAddr); err != nil {
		return err
	}
	if err := w.ReadData(&o.IPAddrDNS); err != nil {
		return err
	}
	if err := w.ReadData(&o.IPAddrDNSAlt); err != nil {
		return err
	}
	if err := w.ReadData(&o.IPAddrWINS); err != nil {
		return err
	}
	if err := w.ReadData(&o.IPAddrWINSAlt); err != nil {
		return err
	}
	if err := w.ReadData(&o.NetProtocols); err != nil {
		return err
	}
	o.DeviceType = make([]uint16, 17)
	for i1 := range o.DeviceType {
		i1 := i1
		if err := w.ReadData(&o.DeviceType[i1]); err != nil {
			return err
		}
	}
	o.DeviceName = make([]uint16, 129)
	for i1 := range o.DeviceName {
		i1 := i1
		if err := w.ReadData(&o.DeviceName[i1]); err != nil {
			return err
		}
	}
	o.X25PadType = make([]uint16, 33)
	for i1 := range o.X25PadType {
		i1 := i1
		if err := w.ReadData(&o.X25PadType[i1]); err != nil {
			return err
		}
	}
	o.X25Address = make([]uint16, 201)
	for i1 := range o.X25Address {
		i1 := i1
		if err := w.ReadData(&o.X25Address[i1]); err != nil {
			return err
		}
	}
	o.X25Facilities = make([]uint16, 201)
	for i1 := range o.X25Facilities {
		i1 := i1
		if err := w.ReadData(&o.X25Facilities[i1]); err != nil {
			return err
		}
	}
	o.X25UserData = make([]uint16, 201)
	for i1 := range o.X25UserData {
		i1 := i1
		if err := w.ReadData(&o.X25UserData[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.Channels); err != nil {
		return err
	}
	if err := w.ReadData(&o.SubEntries); err != nil {
		return err
	}
	if err := w.ReadData(&o.DialMode); err != nil {
		return err
	}
	if err := w.ReadData(&o.DialExtraPercent); err != nil {
		return err
	}
	if err := w.ReadData(&o.DialExtraSampleSeconds); err != nil {
		return err
	}
	if err := w.ReadData(&o.HangUpExtraPercent); err != nil {
		return err
	}
	if err := w.ReadData(&o.HangUpExtraSampleSeconds); err != nil {
		return err
	}
	if err := w.ReadData(&o.IdleDisconnectSeconds); err != nil {
		return err
	}
	if err := w.ReadData(&o.Type); err != nil {
		return err
	}
	if err := w.ReadData(&o.EncryptionType); err != nil {
		return err
	}
	if err := w.ReadData(&o.CustomAuthKey); err != nil {
		return err
	}
	if err := w.ReadData(&o.CustomAuthDataSize); err != nil {
		return err
	}
	_ptr_lpbCustomAuthData := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := w.ReadData(&o.CustomAuthData); err != nil {
			return err
		}
		return nil
	})
	_s_lpbCustomAuthData := func(ptr interface{}) { o.CustomAuthData = *ptr.(*uint8) }
	if err := w.ReadPointer(&o.CustomAuthData, _s_lpbCustomAuthData, _ptr_lpbCustomAuthData); err != nil {
		return err
	}
	if o.ID == nil {
		o.ID = &dtyp.GUID{}
	}
	if err := o.ID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.VPNStrategy); err != nil {
		return err
	}
	if err := w.ReadTrailingGap(9); err != nil {
		return err
	}
	return nil
}

// Interface3 structure represents MPRI_INTERFACE_3 RPC structure.
//
// The MPRI_INTERFACE_3 structure<72> is used to contain data for a router demand-dial
// interface. This structure is used in the following methods:
//
// * *RRouterInterfaceCreate (section 3.1.4.13)* ( 72bead5c-821f-4e98-bacd-0de279552379
// )
//
// * *RRouterInterfaceGetInfo (section 3.1.4.14)* ( 2fbcf316-2082-4f98-878b-eab5d0c2da1d
// )
//
// * *RRouterInterfaceSetInfo (section 3.1.4.15)* ( 615c1081-5d03-415a-b57c-76876bb2cf23
// )
//
// typedef struct _MPR_INTERFACE_3 {
//
// WCHAR wszInterfaceName[257];
//
// DWORD dwInterface;
//
// BOOL fEnabled;
//
// ROUTER_INTERFACE_TYPE dwIfType;
//
// ROUTER_CONNECTION_STATE dwConnectionState;
//
// DWORD fUnReachabilityReasons;
//
// DWORD dwLastError;
//
// DWORD dwfOptions;
//
// WCHAR szLocalPhoneNumber[129];
//
// PWCHAR szAlternates;
//
// DWORD ipaddr;
//
// DWORD ipaddrDns;
//
// DWORD ipaddrDnsAlt;
//
// DWORD ipaddrWins;
//
// DWORD ipaddrWinsAlt;
//
// DWORD dwfNetProtocols;
//
// WCHAR szDeviceType[17];
//
// WCHAR szDeviceName[129];
//
// WCHAR szX25PadType[33];
//
// WCHAR szX25Address[201];
//
// WCHAR szX25Facilities[201];
//
// WCHAR szX25UserData[201];
//
// DWORD dwChannels;
//
// DWORD dwSubEntries;
//
// DWORD dwDialMode;
//
// DWORD dwDialExtraPercent;
//
// DWORD dwDialExtraSampleSeconds;
//
// DWORD dwHangUpExtraPercent;
//
// DWORD dwHangUpExtraSampleSeconds;
//
// DWORD dwIdleDisconnectSeconds;
//
// DWORD dwType;
//
// DWORD dwEncryptionType;
//
// DWORD dwCustomAuthKey;
//
// DWORD dwCustomAuthDataSize;
//
// LPBYTE lpbCustomAuthData;
//
// GUID guidId;
//
// DWORD dwVpnStrategy;
//
// ULONG AddressCount;
//
// IN6_ADDR ipv6addrDns;
//
// IN6_ADDR ipv6addrDnsAlt;
//
// * } MPRI_INTERFACE_3,
type Interface3 struct {
	// wszInterfaceName: A pointer to a Unicode string that contains the name of the interface.
	// This value MUST be specified during the call to the RRouterInterfaceCreate<73> method
	// and cannot be modified after the interface is created.<74>
	InterfaceName []uint16 `idl:"name:wszInterfaceName" json:"interface_name"`
	// dwInterface: Specifies a unique identifier of the interface. This is a read-only
	// field and cannot be set or modified.
	Interface uint32 `idl:"name:dwInterface" json:"interface"`
	// fEnabled: Specifies whether the interface is enabled. The value TRUE is greater than
	// zero (0) if the interface is enabled, or FALSE is zero (0) if the interface is disabled
	// by an administrator.
	//
	//	+---------+----------------------------+
	//	|         |                            |
	//	|  VALUE  |          MEANING           |
	//	|         |                            |
	//	+---------+----------------------------+
	//	+---------+----------------------------+
	//	| TRUE >0 | The interface is enabled.  |
	//	+---------+----------------------------+
	//	| FALSE 0 | The interface is disabled. |
	//	+---------+----------------------------+
	Enabled bool `idl:"name:fEnabled" json:"enabled"`
	// dwIfType: A ROUTER_INTERFACE_TYPE (section 2.2.1.1.1) value specifying the type of
	// interface.
	InterfaceType RouterInterfaceType `idl:"name:dwIfType" json:"interface_type"`
	// dwConnectionState: A ROUTER_CONNECTION_STATE (section 2.2.1.1.2) value specifying
	// the current state of the interface (for example: connected, disconnected, or unreachable).
	// This is a read-only field and cannot be set or modified.
	ConnectionState RouterConnectionState `idl:"name:dwConnectionState" json:"connection_state"`
	// fUnReachabilityReasons: A value that describes the reason why the interface is unreachable.
	// This is a read-only field and cannot be set or modified. The following table has
	// the list of possible values.
	//
	//	+----------------------------------------------------+----------------------------------------------------------+
	//	|                                                    |                                                          |
	//	|                       VALUE                        |                         MEANING                          |
	//	|                                                    |                                                          |
	//	+----------------------------------------------------+----------------------------------------------------------+
	//	+----------------------------------------------------+----------------------------------------------------------+
	//	| MPR_INTERFACE_ADMIN_DISABLED 0x00000002            | The administrator has disabled the interface.            |
	//	+----------------------------------------------------+----------------------------------------------------------+
	//	| MPR_INTERFACE_CONNECTION_FAILURE 0x00000004        | The previous connection attempt failed.                  |
	//	+----------------------------------------------------+----------------------------------------------------------+
	//	| MPR_INTERFACE_DIALOUT_HOURS_RESTRICTION 0x00000010 | Dial-out is not allowed at the current time.             |
	//	+----------------------------------------------------+----------------------------------------------------------+
	//	| MPR_INTERFACE_OUT_OF_RESOURCES 0x00000001          | No ports or devices are available for use.               |
	//	+----------------------------------------------------+----------------------------------------------------------+
	//	| MPR_INTERFACE_SERVICE_PAUSED 0x00000008            | The service is paused.                                   |
	//	+----------------------------------------------------+----------------------------------------------------------+
	//	| MPR_INTERFACE_NO_MEDIA_SENSE 0x00000020            | The network cable is disconnected from the network card. |
	//	+----------------------------------------------------+----------------------------------------------------------+
	//	| MPR_INTERFACE_NO_DEVICE 0x00000040                 | The network card has been removed from the machine.      |
	//	+----------------------------------------------------+----------------------------------------------------------+
	UnReachabilityReasons uint32 `idl:"name:fUnReachabilityReasons" json:"un_reachability_reasons"`
	// dwLastError: A value that contains a nonzero value if the interface fails to connect.
	// This value is a Win32 error code as defined in [MS-ERREF]. This is a read-only field
	// and cannot be set or modified.
	LastError uint32 `idl:"name:dwLastError" json:"last_error"`
	// dwfOptions: A value that specifies bit flags used to set connection options. It SHOULD<75>
	// be a combination of the flags listed in the following table.
	//
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                                   |                                                                                  |
	//	|                       VALUE                       |                                     MEANING                                      |
	//	|                                                   |                                                                                  |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_SpecificIpAddr 0x00000002                   | If this flag is set, the RRAS server attempts to use the IP address specified by |
	//	|                                                   | the ipaddr field as the IP address for the dial-up connection. If this flag is   |
	//	|                                                   | not set, the value of the ipaddr member is ignored.                              |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_SpecificNameServers 0x00000004              | If this flag is set, the RRAS server uses the ipaddrDns, ipaddrDnsAlt,           |
	//	|                                                   | ipaddrWins, and ipaddrWinsAlt members to specify the name server addresses for   |
	//	|                                                   | the dial-up connection. If this flag is not set, the RRAS server ignores these   |
	//	|                                                   | members.                                                                         |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_IpHeaderCompression 0x00000008              | If this flag is set, the RRAS server negotiates to use the IP header compression |
	//	|                                                   | on the PPP connections. The IP header compression can significantly improve      |
	//	|                                                   | performance. If this flag is not set, the IP header compression is not           |
	//	|                                                   | negotiated.                                                                      |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_RemoteDefaultGateway 0x00000010             | If this flag is set, the default route for the IP packets is through the dial-up |
	//	|                                                   | adapter when the connection is active. If this flag is cleared, the default      |
	//	|                                                   | route is not modified.                                                           |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_DisableLcpExtensions 0x00000020             | If this flag is set, the RRAS server disables the PPP LCP extensions defined in  |
	//	|                                                   | [RFC1570]. Disabling the PPP LCP extensions is sometimes necessary to connect    |
	//	|                                                   | to certain older PPP implementations, but it interferes with features such as    |
	//	|                                                   | server callback. This flag MUST NOT be set unless it is specifically required.   |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_SwCompression 0x00000200                    | If this flag is set, software compression is negotiated on the link. Setting     |
	//	|                                                   | this flag causes the PPP to attempt to negotiate the CCP with the server. This   |
	//	|                                                   | flag SHOULD be set by default but clearing it can reduce the negotiation period  |
	//	|                                                   | if the server does not support a compatible compression protocol.                |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_RequireEncryptedPw 0x00000400               | If this flag is set, only secure password schemes can be used to authenticate    |
	//	|                                                   | the client with the server. This prevents the PPP from using the PAP plaintext   |
	//	|                                                   | authentication protocol to authenticate the client. However, the [MS-CHAP],      |
	//	|                                                   | MD5-CHAP, and SPAP authentication protocols are supported. For increased         |
	//	|                                                   | security, set this flag. For increased interoperability, clear this flag.        |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_RequireMsEncryptedPw 0x00000800             | If this flag is set, only the Microsoft secure password schemes can be used      |
	//	|                                                   | to authenticate the client with the server. This prevents the PPP from using     |
	//	|                                                   | the PAP plaintext authentication protocol, MD5-CHAP, or SPAP. For increased      |
	//	|                                                   | security, set this flag. For increased interoperability, clear this flag. This   |
	//	|                                                   | flag takes precedence over MPRIO_RequireEncryptedPw.                             |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_RequireDataEncryption 0x00001000            | If this flag is set, data encryption MUST be negotiated successfully or the      |
	//	|                                                   | connection is dropped. This flag is ignored unless MPRIO_RequireMsEncryptedPw is |
	//	|                                                   | also set.                                                                        |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_UseLogonCredentials 0x00004000              | If this flag is set, the RRAS server uses the username, password, and domain     |
	//	|                                                   | of the currently logged-on user when dialing this entry. This flag is ignored    |
	//	|                                                   | unless MPRIO_RequireMsEncryptedPw is also set.                                   |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_PromoteAlternates 0x00008000                | This flag has an effect when alternate phone numbers are defined by the          |
	//	|                                                   | szAlternates member. If this flag is set, an alternate phone number that         |
	//	|                                                   | connects successfully becomes the primary phone number, and the current primary  |
	//	|                                                   | phone number is moved to the alternate list.                                     |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_SecureLocalFiles 0x00010000                 | If this flag is set, the RRAS server checks for an existing remote file          |
	//	|                                                   | system and remote printer bindings before making a connection with this entry.   |
	//	|                                                   | Typically, this flag is set on phone book entries for public networks to remind  |
	//	|                                                   | users to break connections to their private network before connecting to a       |
	//	|                                                   | public network.                                                                  |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_RequireEAP 0x00020000                       | If this flag is set, Extensible Authentication Protocol (EAP) MUST be supported  |
	//	|                                                   | for authentication.                                                              |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_RequirePAP 0x00040000                       | If this flag is set, Password Authentication Protocol (PAP) MUST be supported    |
	//	|                                                   | for authentication.                                                              |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_RequireSPAP 0x00080000                      | If this flag is set, Shiva's Password Authentication Protocol (SPAP) MUST be     |
	//	|                                                   | supported for authentication.                                                    |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_SharedPhoneNumbers 0x00800000               | If this flag is set, phone numbers are shared.                                   |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_RequireCHAP 0x08000000                      | If this flag is set, the Challenge Handshake Authentication Protocol (CHAP) MUST |
	//	|                                                   | be supported for authentication.                                                 |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_RequireMsCHAP 0x10000000                    | If this flag is set, the Microsoft Challenge Handshake Authentication Protocol   |
	//	|                                                   | [MS-CHAP] MUST be supported for authentication.                                  |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_RequireMsCHAP2 0x20000000                   | If this flag is set, version 2 of the [MS-CHAP] MUST be supported for            |
	//	|                                                   | authentication.                                                                  |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_IpSecPreSharedKey 0x80000000                | Configured the demand-dial interface to use preshared key.                       |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_RequireMachineCertificates 0x01000000       | If this flag is set, a machine certificate is to be used for IKEv2               |
	//	|                                                   | authentication.                                                                  |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_UsePreSharedKeyForIkev2Initiator 0x02000000 | If this flag is set, a preshared key is to be used by the initiator of the IKEv2 |
	//	|                                                   | connection for authentication.                                                   |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	//	| MPRIO_UsePreSharedKeyForIkev2Responder 0x04000000 | If this flag is set, a preshared key is to be used by the responder of the IKEv2 |
	//	|                                                   | connection for authentication.                                                   |
	//	+---------------------------------------------------+----------------------------------------------------------------------------------+
	Options uint32 `idl:"name:dwfOptions" json:"options"`
	// szLocalPhoneNumber: A value that specifies a null-terminated Unicode string that
	// contains a telephone number.
	LocalPhoneNumber []uint16 `idl:"name:szLocalPhoneNumber" json:"local_phone_number"`
	// szAlternates: The offset from the beginning of this structure where the alternate
	// phone numbers are stored. If no alternate phone number is available, this value MUST
	// be set to 0. Alternate phone numbers are a list of consecutive null-terminated Unicode
	// strings. The last string is terminated by two consecutive null characters. The strings
	// are alternate phone numbers that the router dials, in the order listed, if the primary
	// number fails to connect. For more information, see szLocalPhoneNumber. The alternate
	// phone numbers MUST be stored after the custom data that is appended to this structure.
	Alternates string `idl:"name:szAlternates" json:"alternates"`
	// ipaddr: A value that specifies the IP address to be used while this connection is
	// active. This member is ignored unless dwfOptions specifies the MPRIO_SpecificIpAddr
	// flag.
	IPAddr uint32 `idl:"name:ipaddr" json:"ip_addr"`
	// ipaddrDns: A value that specifies the IP address of the DNS server to be used while
	// this connection is active. This member is ignored unless dwfOptions specifies the
	// MPRIO_SpecificNameServers flag.
	IPAddrDNS uint32 `idl:"name:ipaddrDns" json:"ip_addr_dns"`
	// ipaddrDnsAlt: A value that specifies the IP address of a secondary or backup DNS
	// server to be used while this connection is active. This member is ignored unless
	// dwfOptions specifies the MPRIO_SpecificNameServers flag.
	IPAddrDNSAlt uint32 `idl:"name:ipaddrDnsAlt" json:"ip_addr_dns_alt"`
	// ipaddrWins: A value that specifies the IP address of the WINS server to be used while
	// this connection is active. This member is ignored unless dwfOptions specifies the
	// MPRIO_SpecificNameServers flag.
	IPAddrWINS uint32 `idl:"name:ipaddrWins" json:"ip_addr_wins"`
	// ipaddrWinsAlt: A value that specifies the IP address of a secondary WINS server to
	// be used while this connection is active. This member is ignored unless dwfOptions
	// specifies the MPRIO_SpecificNameServers flag.
	IPAddrWINSAlt uint32 `idl:"name:ipaddrWinsAlt" json:"ip_addr_wins_alt"`
	// dwfNetProtocols: A value that specifies the network protocols to negotiate. This
	// member can be a combination of the following flags.
	//
	//	+-----------------------+----------------------------------+
	//	|                       |                                  |
	//	|         VALUE         |             MEANING              |
	//	|                       |                                  |
	//	+-----------------------+----------------------------------+
	//	+-----------------------+----------------------------------+
	//	| MPRNP_Ipx 0x00000002  | Negotiate the IPX protocol.      |
	//	+-----------------------+----------------------------------+
	//	| MPRNP_Ip 0x00000004   | Negotiate the TCP/IPv4 protocol. |
	//	+-----------------------+----------------------------------+
	//	| MPRNP_Ipv6 0x00000008 | Negotiate the TCP/IPv6 protocol. |
	//	+-----------------------+----------------------------------+
	NetProtocols uint32 `idl:"name:dwfNetProtocols" json:"net_protocols"`
	// szDeviceType: A value that specifies a null-terminated Unicode string that indicates
	// the RRAS server device type that is referenced by szDeviceName. This is a read-only
	// field that is computed based on the value of the szDeviceName member. The possible
	// values for this member are the same as the wszDeviceName defined in RASI_PORT_0.
	DeviceType []uint16 `idl:"name:szDeviceType" json:"device_type"`
	// szDeviceName: Contains a null-terminated Unicode string that contains the name of
	// a TAPI device to use with this phone book entry (for example, "Fabrikam Inc 28800
	// External"). To enumerate all available RAS-capable devices, use the RRouterDeviceEnum
	// (section 3.1.4.37) method.
	DeviceName []uint16 `idl:"name:szDeviceName" json:"device_name"`
	// szX25PadType: Contains a null-terminated Unicode string that identifies the X.25
	// PAD type. This value SHOULD be set to an empty string ("") unless the entry dials
	// using an X.25 PAD.<76>
	X25PadType []uint16 `idl:"name:szX25PadType" json:"x25_pad_type"`
	// szX25Address: Contains a null-terminated Unicode string that identifies the X.25
	// address to connect to. This value SHOULD be set to an empty string ("") unless the
	// entry dials using an X.25 PAD or native X.25 device.<77>
	X25Address []uint16 `idl:"name:szX25Address" json:"x25_address"`
	// szX25Facilities: Contains a null-terminated Unicode string that specifies the facilities
	// to request from the X.25 host at connection time. This member is ignored if szX25Address
	// is an empty string ("").
	X25Facilities []uint16 `idl:"name:szX25Facilities" json:"x25_facilities"`
	// szX25UserData: Contains a null-terminated Unicode string that specifies the additional
	// connection data supplied to the X.25 host at connection time. This member is ignored
	// if szX25Address is an empty string ("").
	X25UserData []uint16 `idl:"name:szX25UserData" json:"x25_user_data"`
	// dwChannels: Reserved for future use.
	Channels uint32 `idl:"name:dwChannels" json:"channels"`
	// dwSubEntries: A value that specifies the number of multilink subentries associated
	// with this entry. This is a read-only field and cannot be set or modified. Multilink
	// entries SHOULD be specified by updating the Media section of the phonebook file as
	// specified in 2.2.2.2.96.
	SubEntries uint32 `idl:"name:dwSubEntries" json:"sub_entries"`
	// dwDialMode: Indicates whether the RRAS server needs to dial all of this entry's multilink
	// subentries when the entry is first connected. This member can be one of the following
	// values.
	//
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	|                               |                                                                                  |
	//	|             VALUE             |                                     MEANING                                      |
	//	|                               |                                                                                  |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000000                    | Dial the first available device only.                                            |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	| MPRDM_DialAll 0x00000001      | Dial all subentries initially.                                                   |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	| MPRDM_DialAsNeeded 0x00000002 | Adjust the number of subentries as bandwidth is required. The RRAS server uses   |
	//	|                               | the dwDialExtraPercent, dwDialExtraSampleSeconds, dwDialHangUpExtraPercent,      |
	//	|                               | and dwHangUpExtraSampleSeconds members to determine when to dial or disconnect   |
	//	|                               | a subentry. This value SHOULD<78> be ignored and treated identically to          |
	//	|                               | MPRDM_DialAll.                                                                   |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	DialMode uint32 `idl:"name:dwDialMode" json:"dial_mode"`
	// dwDialExtraPercent: A value that specifies the percentage of the total bandwidth
	// that is available from the currently connected subentries. The RRAS server dials
	// an additional subentry when the total bandwidth that is used exceeds dwDialExtraPercent
	// percent of the available bandwidth for at least dwDialExtraSampleSeconds seconds.
	DialExtraPercent uint32 `idl:"name:dwDialExtraPercent" json:"dial_extra_percent"`
	// dwDialExtraSampleSeconds: A value that specifies the time, in seconds, for which
	// current bandwidth usage MUST exceed the threshold that is specified by dwDialExtraPercent
	// before the RRAS server dials an additional subentry.
	DialExtraSampleSeconds uint32 `idl:"name:dwDialExtraSampleSeconds" json:"dial_extra_sample_seconds"`
	// dwHangUpExtraPercent: A value that specifies the percentage of the total bandwidth
	// that is available from the currently connected subentries. The RRAS server terminates
	// (hangs up) an existing subentry connection when the total bandwidth used is less
	// than dwHangUpExtraPercent percent of the available bandwidth for at least dwHangUpExtraSampleSeconds
	// seconds.
	HangUpExtraPercent uint32 `idl:"name:dwHangUpExtraPercent" json:"hang_up_extra_percent"`
	// dwHangUpExtraSampleSeconds: A value that specifies the time, in seconds, for which
	// current bandwidth usage MUST be less than the threshold that is specified by dwHangUpExtraPercent
	// before the RRAS server terminates an existing subentry connection.
	HangUpExtraSampleSeconds uint32 `idl:"name:dwHangUpExtraSampleSeconds" json:"hang_up_extra_sample_seconds"`
	// dwIdleDisconnectSeconds: A value that specifies the time, in seconds, after which
	// an inactive connection is terminated. Unless the idle time-out is disabled, the entire
	// connection is terminated if the connection is idle for the specified interval. This
	// member can specify either a time-out value or one of the following values.
	//
	//	+----------------------------------+------------------------------------------------+
	//	|                                  |                                                |
	//	|              VALUE               |                    MEANING                     |
	//	|                                  |                                                |
	//	+----------------------------------+------------------------------------------------+
	//	+----------------------------------+------------------------------------------------+
	//	| MPRIDS_UseGlobalValue 0x00000000 | Use the user preference value as the default.  |
	//	+----------------------------------+------------------------------------------------+
	//	| MPRIDS_Disabled 0xFFFFFFFF       | There is no idle time-out for this connection. |
	//	+----------------------------------+------------------------------------------------+
	IdleDisconnectSeconds uint32 `idl:"name:dwIdleDisconnectSeconds" json:"idle_disconnect_seconds"`
	// dwType: A value that specifies the type of phone book entry. This is a read-only
	// field that is calculated based on the value of the szDeviceType member. This member
	// can be one of the following types.
	//
	//	+-------------------------+-------------------------------------------------+
	//	|                         |                                                 |
	//	|          VALUE          |                     MEANING                     |
	//	|                         |                                                 |
	//	+-------------------------+-------------------------------------------------+
	//	+-------------------------+-------------------------------------------------+
	//	| MPRET_Phone 0x00000001  | Phone line (for example: modem, ISDN, or X.25). |
	//	+-------------------------+-------------------------------------------------+
	//	| MPRET_Vpn 0x00000002    | Virtual private network (VPN).                  |
	//	+-------------------------+-------------------------------------------------+
	//	| MPRET_Direct 0x00000003 | Direct serial or parallel connection.           |
	//	+-------------------------+-------------------------------------------------+
	Type uint32 `idl:"name:dwType" json:"type"`
	// dwEncryptionType: A value that specifies the type of encryption to use for Microsoft
	// Point-to-Point Encryption (MPPE) with the connection. This member can be one of the
	// following values.
	//
	//	+------------------------------+----------------------------------+
	//	|                              |                                  |
	//	|            VALUE             |             MEANING              |
	//	|                              |                                  |
	//	+------------------------------+----------------------------------+
	//	+------------------------------+----------------------------------+
	//	| MPR_ET_None 0x00000000       | Do not use encryption.           |
	//	+------------------------------+----------------------------------+
	//	| MPR_ET_Require 0x00000001    | Use encryption.                  |
	//	+------------------------------+----------------------------------+
	//	| MPR_ET_RequireMax 0x00000002 | Use maximum-strength encryption. |
	//	+------------------------------+----------------------------------+
	//	| MPR_ET_Optional 0x00000003   | If possible, use encryption.     |
	//	+------------------------------+----------------------------------+
	EncryptionType uint32 `idl:"name:dwEncryptionType" json:"encryption_type"`
	// dwCustomAuthKey: A value that specifies the authentication key to be provided to
	// an EAP ([MS-PEAP]) vendor.
	CustomAuthKey uint32 `idl:"name:dwCustomAuthKey" json:"custom_auth_key"`
	// dwCustomAuthDataSize: A value that specifies the size of the data pointed to by the
	// lpbCustomAuthData member.
	CustomAuthDataSize uint32 `idl:"name:dwCustomAuthDataSize" json:"custom_auth_data_size"`
	// lpbCustomAuthData: The offset from the beginning of this structure where the CustomAuthData
	// is stored. If CustomAuthData are not specified, this member MUST be set to 0. CustomAuthData
	// is the authentication data to use with EAP [MS-PEAP]. CustomAuthData MUST be appended
	// to the end of this structure.
	CustomAuthData uint8 `idl:"name:lpbCustomAuthData" json:"custom_auth_data"`
	// guidId: The GUID that represents this phone book entry. This member is read-only.
	ID *dtyp.GUID `idl:"name:guidId" json:"id"`
	// dwVpnStrategy: The VPN strategy to use when dialing a VPN connection. This member
	// SHOULD have one of the following values.<79>
	//
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	|                              |                                                                                  |
	//	|            VALUE             |                                     MEANING                                      |
	//	|                              |                                                                                  |
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	| MPR_VS_Default 0x00000000    | The RRAS server dials the PPTP first. If the PPTP fails, the L2TP is attempted.  |
	//	|                              | If the L2TP fails, the IKEv2 is attempted. The protocol that succeeds is tried   |
	//	|                              | first in subsequent dialing for this entry.                                      |
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	| MPR_VS_PptpOnly 0x00000001   | The RRAS server dials only the PPTP.                                             |
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	| MPR_VS_PptpFirst 0x00000002  | The RRAS server always dials the PPTP first, the L2TP second, and the IKEv2      |
	//	|                              | third.                                                                           |
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	| MPR_VS_L2tpOnly 0x00000003   | The RRAS server dials only the L2TP.                                             |
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	| MPR_VS_L2tpFirst 0x00000004  | The RRAS server dials the L2TP first, the PPTP second, and the IKEv2 third.      |
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	| MPR_VS_Ikev2Only 0x00000007  | The RRAS server dials only the IKEv2.                                            |
	//	+------------------------------+----------------------------------------------------------------------------------+
	//	| MPR_VS_Ikev2First 0x00000008 | The RRAS server dials the IKEv2 first, the PPTP second, and the L2TP third.      |
	//	+------------------------------+----------------------------------------------------------------------------------+
	VPNStrategy uint32 `idl:"name:dwVpnStrategy" json:"vpn_strategy"`
	// AddressCount: Not used.
	AddressCount uint32 `idl:"name:AddressCount" json:"address_count"`
	// ipv6addrDns: A value that specifies the IP address of the DNS server to be used while
	// this connection is active.
	Ipv6addrDNS *IN6Addr `idl:"name:ipv6addrDns" json:"ipv6addr_dns"`
	// ipv6addrDnsAlt: A value that specifies the IP address of a secondary or backup DNS
	// server to be used while this connection is active.
	Ipv6addrDNSAlt *IN6Addr `idl:"name:ipv6addrDnsAlt" json:"ipv6addr_dns_alt"`
	// ipv6addr: Not used.
	Ipv6addr *IN6Addr `idl:"name:ipv6addr" json:"ipv6addr"`
}

func (o *Interface3) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *Interface3) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	for i1 := range o.InterfaceName {
		i1 := i1
		if uint64(i1) >= 257 {
			break
		}
		if err := w.WriteData(o.InterfaceName[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.InterfaceName); uint64(i1) < 257; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Interface); err != nil {
		return err
	}
	if !o.Enabled {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if err := w.WriteEnum(uint16(o.InterfaceType)); err != nil {
		return err
	}
	if err := w.WriteEnum(uint16(o.ConnectionState)); err != nil {
		return err
	}
	if err := w.WriteData(o.UnReachabilityReasons); err != nil {
		return err
	}
	if err := w.WriteData(o.LastError); err != nil {
		return err
	}
	if err := w.WriteData(o.Options); err != nil {
		return err
	}
	for i1 := range o.LocalPhoneNumber {
		i1 := i1
		if uint64(i1) >= 129 {
			break
		}
		if err := w.WriteData(o.LocalPhoneNumber[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.LocalPhoneNumber); uint64(i1) < 129; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	if o.Alternates != "" {
		_ptr_szAlternates := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16String(ctx, w, o.Alternates); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Alternates, _ptr_szAlternates); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.IPAddr); err != nil {
		return err
	}
	if err := w.WriteData(o.IPAddrDNS); err != nil {
		return err
	}
	if err := w.WriteData(o.IPAddrDNSAlt); err != nil {
		return err
	}
	if err := w.WriteData(o.IPAddrWINS); err != nil {
		return err
	}
	if err := w.WriteData(o.IPAddrWINSAlt); err != nil {
		return err
	}
	if err := w.WriteData(o.NetProtocols); err != nil {
		return err
	}
	for i1 := range o.DeviceType {
		i1 := i1
		if uint64(i1) >= 17 {
			break
		}
		if err := w.WriteData(o.DeviceType[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.DeviceType); uint64(i1) < 17; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	for i1 := range o.DeviceName {
		i1 := i1
		if uint64(i1) >= 129 {
			break
		}
		if err := w.WriteData(o.DeviceName[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.DeviceName); uint64(i1) < 129; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	for i1 := range o.X25PadType {
		i1 := i1
		if uint64(i1) >= 33 {
			break
		}
		if err := w.WriteData(o.X25PadType[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.X25PadType); uint64(i1) < 33; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	for i1 := range o.X25Address {
		i1 := i1
		if uint64(i1) >= 201 {
			break
		}
		if err := w.WriteData(o.X25Address[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.X25Address); uint64(i1) < 201; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	for i1 := range o.X25Facilities {
		i1 := i1
		if uint64(i1) >= 201 {
			break
		}
		if err := w.WriteData(o.X25Facilities[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.X25Facilities); uint64(i1) < 201; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	for i1 := range o.X25UserData {
		i1 := i1
		if uint64(i1) >= 201 {
			break
		}
		if err := w.WriteData(o.X25UserData[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.X25UserData); uint64(i1) < 201; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Channels); err != nil {
		return err
	}
	if err := w.WriteData(o.SubEntries); err != nil {
		return err
	}
	if err := w.WriteData(o.DialMode); err != nil {
		return err
	}
	if err := w.WriteData(o.DialExtraPercent); err != nil {
		return err
	}
	if err := w.WriteData(o.DialExtraSampleSeconds); err != nil {
		return err
	}
	if err := w.WriteData(o.HangUpExtraPercent); err != nil {
		return err
	}
	if err := w.WriteData(o.HangUpExtraSampleSeconds); err != nil {
		return err
	}
	if err := w.WriteData(o.IdleDisconnectSeconds); err != nil {
		return err
	}
	if err := w.WriteData(o.Type); err != nil {
		return err
	}
	if err := w.WriteData(o.EncryptionType); err != nil {
		return err
	}
	if err := w.WriteData(o.CustomAuthKey); err != nil {
		return err
	}
	if err := w.WriteData(o.CustomAuthDataSize); err != nil {
		return err
	}
	// XXX pointer to primitive type, default behavior is to write non-null pointer.
	// if this behavior is not desired, use goext_default_null([cond]) attribute.
	_ptr_lpbCustomAuthData := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
		if err := w.WriteData(o.CustomAuthData); err != nil {
			return err
		}
		return nil
	})
	if err := w.WritePointer(&o.CustomAuthData, _ptr_lpbCustomAuthData); err != nil {
		return err
	}
	if o.ID != nil {
		if err := o.ID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.VPNStrategy); err != nil {
		return err
	}
	if err := w.WriteData(o.AddressCount); err != nil {
		return err
	}
	if o.Ipv6addrDNS != nil {
		if err := o.Ipv6addrDNS.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&IN6Addr{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.Ipv6addrDNSAlt != nil {
		if err := o.Ipv6addrDNSAlt.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&IN6Addr{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.Ipv6addr != nil {
		_ptr_ipv6addr := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Ipv6addr != nil {
				if err := o.Ipv6addr.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&IN6Addr{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Ipv6addr, _ptr_ipv6addr); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *Interface3) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	o.InterfaceName = make([]uint16, 257)
	for i1 := range o.InterfaceName {
		i1 := i1
		if err := w.ReadData(&o.InterfaceName[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.Interface); err != nil {
		return err
	}
	var _bEnabled int32
	if err := w.ReadData(&_bEnabled); err != nil {
		return err
	}
	o.Enabled = _bEnabled != 0
	if err := w.ReadEnum((*uint16)(&o.InterfaceType)); err != nil {
		return err
	}
	if err := w.ReadEnum((*uint16)(&o.ConnectionState)); err != nil {
		return err
	}
	if err := w.ReadData(&o.UnReachabilityReasons); err != nil {
		return err
	}
	if err := w.ReadData(&o.LastError); err != nil {
		return err
	}
	if err := w.ReadData(&o.Options); err != nil {
		return err
	}
	o.LocalPhoneNumber = make([]uint16, 129)
	for i1 := range o.LocalPhoneNumber {
		i1 := i1
		if err := w.ReadData(&o.LocalPhoneNumber[i1]); err != nil {
			return err
		}
	}
	_ptr_szAlternates := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16String(ctx, w, &o.Alternates); err != nil {
			return err
		}
		return nil
	})
	_s_szAlternates := func(ptr interface{}) { o.Alternates = *ptr.(*string) }
	if err := w.ReadPointer(&o.Alternates, _s_szAlternates, _ptr_szAlternates); err != nil {
		return err
	}
	if err := w.ReadData(&o.IPAddr); err != nil {
		return err
	}
	if err := w.ReadData(&o.IPAddrDNS); err != nil {
		return err
	}
	if err := w.ReadData(&o.IPAddrDNSAlt); err != nil {
		return err
	}
	if err := w.ReadData(&o.IPAddrWINS); err != nil {
		return err
	}
	if err := w.ReadData(&o.IPAddrWINSAlt); err != nil {
		return err
	}
	if err := w.ReadData(&o.NetProtocols); err != nil {
		return err
	}
	o.DeviceType = make([]uint16, 17)
	for i1 := range o.DeviceType {
		i1 := i1
		if err := w.ReadData(&o.DeviceType[i1]); err != nil {
			return err
		}
	}
	o.DeviceName = make([]uint16, 129)
	for i1 := range o.DeviceName {
		i1 := i1
		if err := w.ReadData(&o.DeviceName[i1]); err != nil {
			return err
		}
	}
	o.X25PadType = make([]uint16, 33)
	for i1 := range o.X25PadType {
		i1 := i1
		if err := w.ReadData(&o.X25PadType[i1]); err != nil {
			return err
		}
	}
	o.X25Address = make([]uint16, 201)
	for i1 := range o.X25Address {
		i1 := i1
		if err := w.ReadData(&o.X25Address[i1]); err != nil {
			return err
		}
	}
	o.X25Facilities = make([]uint16, 201)
	for i1 := range o.X25Facilities {
		i1 := i1
		if err := w.ReadData(&o.X25Facilities[i1]); err != nil {
			return err
		}
	}
	o.X25UserData = make([]uint16, 201)
	for i1 := range o.X25UserData {
		i1 := i1
		if err := w.ReadData(&o.X25UserData[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.Channels); err != nil {
		return err
	}
	if err := w.ReadData(&o.SubEntries); err != nil {
		return err
	}
	if err := w.ReadData(&o.DialMode); err != nil {
		return err
	}
	if err := w.ReadData(&o.DialExtraPercent); err != nil {
		return err
	}
	if err := w.ReadData(&o.DialExtraSampleSeconds); err != nil {
		return err
	}
	if err := w.ReadData(&o.HangUpExtraPercent); err != nil {
		return err
	}
	if err := w.ReadData(&o.HangUpExtraSampleSeconds); err != nil {
		return err
	}
	if err := w.ReadData(&o.IdleDisconnectSeconds); err != nil {
		return err
	}
	if err := w.ReadData(&o.Type); err != nil {
		return err
	}
	if err := w.ReadData(&o.EncryptionType); err != nil {
		return err
	}
	if err := w.ReadData(&o.CustomAuthKey); err != nil {
		return err
	}
	if err := w.ReadData(&o.CustomAuthDataSize); err != nil {
		return err
	}
	_ptr_lpbCustomAuthData := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := w.ReadData(&o.CustomAuthData); err != nil {
			return err
		}
		return nil
	})
	_s_lpbCustomAuthData := func(ptr interface{}) { o.CustomAuthData = *ptr.(*uint8) }
	if err := w.ReadPointer(&o.CustomAuthData, _s_lpbCustomAuthData, _ptr_lpbCustomAuthData); err != nil {
		return err
	}
	if o.ID == nil {
		o.ID = &dtyp.GUID{}
	}
	if err := o.ID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.VPNStrategy); err != nil {
		return err
	}
	if err := w.ReadData(&o.AddressCount); err != nil {
		return err
	}
	if o.Ipv6addrDNS == nil {
		o.Ipv6addrDNS = &IN6Addr{}
	}
	if err := o.Ipv6addrDNS.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.Ipv6addrDNSAlt == nil {
		o.Ipv6addrDNSAlt = &IN6Addr{}
	}
	if err := o.Ipv6addrDNSAlt.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_ipv6addr := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Ipv6addr == nil {
			o.Ipv6addr = &IN6Addr{}
		}
		if err := o.Ipv6addr.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ipv6addr := func(ptr interface{}) { o.Ipv6addr = *ptr.(**IN6Addr) }
	if err := w.ReadPointer(&o.Ipv6addr, _s_ipv6addr, _ptr_ipv6addr); err != nil {
		return err
	}
	return nil
}

// Device0 structure represents MPR_DEVICE_0 RPC structure.
//
// The MPR_DEVICE_0 structure stores information about a device used for a link in a
// multilinked demand-dial interface.
type Device0 struct {
	// szDeviceType: Specifies a null-terminated Unicode string that indicates the RRAS
	// server device type referenced by szDeviceName. See MPRI_INTERFACE_2 (section 2.2.1.2.83)
	// for a list of possible device types.
	DeviceType []uint16 `idl:"name:szDeviceType" json:"device_type"`
	// szDeviceName: Specifies a null-terminated Unicode string that contains the name of
	// the TAPI device to use with this phone book entry.
	DeviceName []uint16 `idl:"name:szDeviceName" json:"device_name"`
}

func (o *Device0) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *Device0) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(2); err != nil {
		return err
	}
	for i1 := range o.DeviceType {
		i1 := i1
		if uint64(i1) >= 17 {
			break
		}
		if err := w.WriteData(o.DeviceType[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.DeviceType); uint64(i1) < 17; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	for i1 := range o.DeviceName {
		i1 := i1
		if uint64(i1) >= 129 {
			break
		}
		if err := w.WriteData(o.DeviceName[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.DeviceName); uint64(i1) < 129; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	return nil
}
func (o *Device0) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(2); err != nil {
		return err
	}
	o.DeviceType = make([]uint16, 17)
	for i1 := range o.DeviceType {
		i1 := i1
		if err := w.ReadData(&o.DeviceType[i1]); err != nil {
			return err
		}
	}
	o.DeviceName = make([]uint16, 129)
	for i1 := range o.DeviceName {
		i1 := i1
		if err := w.ReadData(&o.DeviceName[i1]); err != nil {
			return err
		}
	}
	return nil
}

// Device1 structure represents MPR_DEVICE_1 RPC structure.
//
// The MPR_DEVICE_1 structure stores information about a device used for a link in a
// multilinked demand-dial interface. In addition to the information in MPR_DEVICE_0
// (section 2.2.1.2.85), MPR_DEVICE_1 contains phone number information.
type Device1 struct {
	// szDeviceType: Specifies a null-terminated Unicode string that indicates the device
	// type referenced by szDeviceName. See MPRI_INTERFACE_2 (section 2.2.1.2.83) for a
	// list of possible device types.
	DeviceType []uint16 `idl:"name:szDeviceType" json:"device_type"`
	// szDeviceName: Specifies a null-terminated Unicode string that contains the name of
	// the TAPI device to use with this phone book entry.
	DeviceName []uint16 `idl:"name:szDeviceName" json:"device_name"`
	// szLocalPhoneNumber: Specifies a null-terminated Unicode string that contains a telephone
	// number. The router uses the szLocalPhoneNumber string as the entire phone number.
	LocalPhoneNumber []uint16 `idl:"name:szLocalPhoneNumber" json:"local_phone_number"`
	// szAlternates: Pointer to a list of consecutive null-terminated Unicode strings. The
	// last string is terminated by two consecutive null characters. The strings are alternate
	// phone numbers that the router dials in the order listed if the primary number (see
	// szLocalPhoneNumber) fails to connect.
	Alternates string `idl:"name:szAlternates" json:"alternates"`
}

func (o *Device1) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *Device1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(7); err != nil {
		return err
	}
	for i1 := range o.DeviceType {
		i1 := i1
		if uint64(i1) >= 17 {
			break
		}
		if err := w.WriteData(o.DeviceType[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.DeviceType); uint64(i1) < 17; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	for i1 := range o.DeviceName {
		i1 := i1
		if uint64(i1) >= 129 {
			break
		}
		if err := w.WriteData(o.DeviceName[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.DeviceName); uint64(i1) < 129; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	for i1 := range o.LocalPhoneNumber {
		i1 := i1
		if uint64(i1) >= 129 {
			break
		}
		if err := w.WriteData(o.LocalPhoneNumber[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.LocalPhoneNumber); uint64(i1) < 129; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	if o.Alternates != "" {
		_ptr_szAlternates := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16String(ctx, w, o.Alternates); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Alternates, _ptr_szAlternates); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *Device1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(7); err != nil {
		return err
	}
	o.DeviceType = make([]uint16, 17)
	for i1 := range o.DeviceType {
		i1 := i1
		if err := w.ReadData(&o.DeviceType[i1]); err != nil {
			return err
		}
	}
	o.DeviceName = make([]uint16, 129)
	for i1 := range o.DeviceName {
		i1 := i1
		if err := w.ReadData(&o.DeviceName[i1]); err != nil {
			return err
		}
	}
	o.LocalPhoneNumber = make([]uint16, 129)
	for i1 := range o.LocalPhoneNumber {
		i1 := i1
		if err := w.ReadData(&o.LocalPhoneNumber[i1]); err != nil {
			return err
		}
	}
	_ptr_szAlternates := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16String(ctx, w, &o.Alternates); err != nil {
			return err
		}
		return nil
	})
	_s_szAlternates := func(ptr interface{}) { o.Alternates = *ptr.(*string) }
	if err := w.ReadPointer(&o.Alternates, _s_szAlternates, _ptr_szAlternates); err != nil {
		return err
	}
	return nil
}

// Credentialsex1 structure represents MPR_CREDENTIALSEX_1 RPC structure.
//
// The MPR_CREDENTIALSEX_1 structure is used to contain extended credentials information
// (other than username/password), such as the information used by Extensible Authentication
// Protocols (EAPs) or a preshared key based on the level being passed in by the methods
// that use this structure. This structure is used in RRouterInterfaceSetCredentialsEx
// (section 3.1.4.41) and RRouterInterfaceGetCredentialsEx (section 3.1.4.42). If a
// preshared key is being used dwSsize MUST be less than 257. Note that the preshared
// key here is used to specify the credential for the connection endpoint on the RRAS
// server. The other end of the connection endpoint MUST be configured with the same
// preshared key in order for the connection to be successful.
type Credentialsex1 struct {
	// dwSize: Specifies the size of the data pointed to by the bData member. If dwSize
	// is zero (0) in a call to RRouterInterfaceSetCredentialsEx and the key is a preshared
	// key, the key is deleted.
	Size uint32 `idl:"name:dwSize" json:"size"`
	// dwOffset: Offset where the data starts in the structure.
	Offset uint32 `idl:"name:dwOffset" json:"offset"`
	// bData: Pointer to the credential information. Note that bData[1] is only a placeholder
	// and the actual data of size dwSize is stored at the end of the structure. The actual
	// value stored here can be either a preshared key or the EAP information EAPTLS_USER_PROPERTIES
	// (section 2.2.1.2.128).
	Data []byte `idl:"name:bData" json:"data"`
}

func (o *Credentialsex1) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *Credentialsex1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Size); err != nil {
		return err
	}
	if err := w.WriteData(o.Offset); err != nil {
		return err
	}
	for i1 := range o.Data {
		i1 := i1
		if uint64(i1) >= 1 {
			break
		}
		if err := w.WriteData(o.Data[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Data); uint64(i1) < 1; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteTrailingGap(4); err != nil {
		return err
	}
	return nil
}
func (o *Credentialsex1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Size); err != nil {
		return err
	}
	if err := w.ReadData(&o.Offset); err != nil {
		return err
	}
	o.Data = make([]byte, 1)
	for i1 := range o.Data {
		i1 := i1
		if err := w.ReadData(&o.Data[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadTrailingGap(4); err != nil {
		return err
	}
	return nil
}

// InterfaceFilterInfo structure represents IFFILTER_INFO RPC structure.
//
// The IFFILTER_INFO structure is used to specify the filter settings for an interface.
// When this structure is encapsulated within the RTR_TOC_ENTRY (section 2.2.1.2.4)
// structure, the InfoType value used MUST be 0xFFFF000D or 0xFFFF0014 to specify IPv4
// interface filter or IPv6 interface filter information.
type InterfaceFilterInfo struct {
	// bEnableFragChk: When this field is set to TRUE, the fragmented packets are filtered
	// at the interface and dropped. If this field is set to FALSE, the fragment checking
	// is not done at the interface.
	//
	//	+-------+-------------------------------------------------+
	//	|       |                                                 |
	//	| VALUE |                     MEANING                     |
	//	|       |                                                 |
	//	+-------+-------------------------------------------------+
	//	+-------+-------------------------------------------------+
	//	| TRUE  | Fragment checking is done at the interface.     |
	//	+-------+-------------------------------------------------+
	//	| FALSE | Fragment checking is not done at the interface. |
	//	+-------+-------------------------------------------------+
	EnableFragChk bool `idl:"name:bEnableFragChk" json:"enable_frag_chk"`
}

func (o *InterfaceFilterInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *InterfaceFilterInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if !o.EnableFragChk {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	return nil
}
func (o *InterfaceFilterInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	var _bEnableFragChk int32
	if err := w.ReadData(&_bEnableFragChk); err != nil {
		return err
	}
	o.EnableFragChk = _bEnableFragChk != 0
	return nil
}

// Filter0 structure represents MPR_FILTER_0 RPC structure.
//
// The MPR_FILTER_0 structure<80> is used to specify whether RRAS server filtering is
// enabled or not. When this structure is encapsulated within RTR_TOC_ENTRY (section
// 2.2.1.2.4), the InfoType value used MUST be 0xFFFF0015 or 0xFFFF0016.
type Filter0 struct {
	// fEnable: This MUST be set to 0x00000000 to disable filtering and MUST be set to 0x00000001
	// to enable filtering on the RRAS server.
	Enable bool `idl:"name:fEnable" json:"enable"`
}

func (o *Filter0) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *Filter0) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if !o.Enable {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	return nil
}
func (o *Filter0) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	var _bEnable int32
	if err := w.ReadData(&_bEnable); err != nil {
		return err
	}
	o.Enable = _bEnable != 0
	return nil
}

// IPXGlobalInfo structure represents IPX_GLOBAL_INFO RPC structure.
//
// The IPX_GLOBAL_INFO structure MAY<81> be used to give the global IPX information
// for the RRAS server. When this structure is encapsulated in RTR_TOC_ENTRY (section
// 2.2.1.2.4), the InfoType value used MUST be 0x00000009.
type IPXGlobalInfo struct {
	// RoutingTableHashSize: The hash size of the IPX routing table.
	RoutingTableHashSize uint32 `idl:"name:RoutingTableHashSize" json:"routing_table_hash_size"`
	// EventLogMask: Mask to manage event logging on the IPX interface on the RRAS server.
	EventLogMask uint32 `idl:"name:EventLogMask" json:"event_log_mask"`
}

func (o *IPXGlobalInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPXGlobalInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.RoutingTableHashSize); err != nil {
		return err
	}
	if err := w.WriteData(o.EventLogMask); err != nil {
		return err
	}
	return nil
}
func (o *IPXGlobalInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.RoutingTableHashSize); err != nil {
		return err
	}
	if err := w.ReadData(&o.EventLogMask); err != nil {
		return err
	}
	return nil
}

// IPXInterfaceInfo structure represents IPX_IF_INFO RPC structure.
//
// The IPX_IF_INFO structure MAY<82> be used to specify the IPX interface data. When
// this structure is encapsulated in RTR_TOC_ENTRY (section 2.2.1.2.4), the InfoType
// value used MUST be 0x00000001.
type IPXInterfaceInfo struct {
	// AdministratorState: This MUST be set to the desired state of the interface (5). A
	// value of 0x00000001 disables the interface and a value of 0x00000002 enables the
	// interface.
	AdministratorState uint32 `idl:"name:AdministratorState" json:"administrator_state"`
	// NetbiosAccept: This MUST be set to 0x00000001 for the interface to accept NetBIOS
	// broadcast packets.
	NetBIOSAccept uint32 `idl:"name:NetbiosAccept" json:"netbios_accept"`
	// NetbiosDeliver: This MUST be set to 0x00000000 on a WAN interface and 0x00000001
	// on a LAN interface.
	NetBIOSDeliver uint32 `idl:"name:NetbiosDeliver" json:"netbios_deliver"`
}

func (o *IPXInterfaceInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPXInterfaceInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.AdministratorState); err != nil {
		return err
	}
	if err := w.WriteData(o.NetBIOSAccept); err != nil {
		return err
	}
	if err := w.WriteData(o.NetBIOSDeliver); err != nil {
		return err
	}
	return nil
}
func (o *IPXInterfaceInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.AdministratorState); err != nil {
		return err
	}
	if err := w.ReadData(&o.NetBIOSAccept); err != nil {
		return err
	}
	if err := w.ReadData(&o.NetBIOSDeliver); err != nil {
		return err
	}
	return nil
}

// IpxwanInterfaceInfo structure represents IPXWAN_IF_INFO RPC structure.
//
// The IPXWAN_IF_INFO structure MAY<83> be used to specify the IPX interface data for
// the WAN interface. When this structure is encapsulated in RTR_TOC_ENTRY (section
// 2.2.1.2.4), the InfoType value used MUST be 0x00000008.
type IpxwanInterfaceInfo struct {
	// Adminstate: This MUST be set to the desired state of the interface. A value of 0x00000001
	// disables the interface, and a value of 0x00000002 enables the interface. This enables
	// or disables the IPXWAN negotiation.
	Adminstate uint32 `idl:"name:Adminstate" json:"adminstate"`
}

func (o *IpxwanInterfaceInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IpxwanInterfaceInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Adminstate); err != nil {
		return err
	}
	return nil
}
func (o *IpxwanInterfaceInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Adminstate); err != nil {
		return err
	}
	return nil
}

// IPXStaticRouteInfo structure represents IPX_STATIC_ROUTE_INFO RPC structure.
//
// The IPX_STATIC_ROUTE_INFO structure MAY<84> be used to carry the route information
// for an IPX interface. When this structure is encapsulated within the RTR_TOC_ENTRY
// (section 2.2.1.2.4), the InfoType value used MUST be 0x00000002.
type IPXStaticRouteInfo struct {
	Field1 *IPXStaticRouteInfo_Field1 `idl:"name:" json:""`
	// TickCount: This MUST be the number of ticks to get to the network number. One unit
	// of tick count is approximately 1/18 seconds.
	TickCount uint16 `idl:"name:TickCount" json:"tick_count"`
	// HopCount: This MUST be the number of routers to be traversed to get to the network
	// number.
	HopCount uint16 `idl:"name:HopCount" json:"hop_count"`
	// NextHopMacAddress: This MUST be the 6-byte MAC address of the next hop in hexadecimal
	// (12 hexadecimal digits).
	NextHopMACAddress []byte `idl:"name:NextHopMacAddress" json:"next_hop_mac_address"`
}

func (o *IPXStaticRouteInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPXStaticRouteInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	// FIXME unknown type
	if err := w.WriteData(o.TickCount); err != nil {
		return err
	}
	if err := w.WriteData(o.HopCount); err != nil {
		return err
	}
	for i1 := range o.NextHopMACAddress {
		i1 := i1
		if uint64(i1) >= 6 {
			break
		}
		if err := w.WriteData(o.NextHopMACAddress[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.NextHopMACAddress); uint64(i1) < 6; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteTrailingGap(4); err != nil {
		return err
	}
	return nil
}
func (o *IPXStaticRouteInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	// FIXME: unknown type
	if err := w.ReadData(&o.TickCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.HopCount); err != nil {
		return err
	}
	o.NextHopMACAddress = make([]byte, 6)
	for i1 := range o.NextHopMACAddress {
		i1 := i1
		if err := w.ReadData(&o.NextHopMACAddress[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadTrailingGap(4); err != nil {
		return err
	}
	return nil
}

type IPXStaticRouteInfo_Field1 struct {
	// DwordAlign: This field of the union MUST NOT be used.
	DwordAlign uint32 `idl:"name:DwordAlign" json:"dword_align"`
	// Network: This member MUST be the 4-byte IPX network number in hexadecimal (8 hexadecimal
	// digits). For example, 1abe32.0000.0c33.2331. The first 32 bits represent the network
	// address and the remaining bits represent the node address; that is, the format is
	// network.node.
	Network []byte `idl:"name:Network" json:"network"`
}

// IPXStaticServiceInfo structure represents IPX_STATIC_SERVICE_INFO RPC structure.
type IPXStaticServiceInfo IPXServerEntry

func (o *IPXStaticServiceInfo) IPXServerEntry() *IPXServerEntry { return (*IPXServerEntry)(o) }

func (o *IPXStaticServiceInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPXStaticServiceInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(2); err != nil {
		return err
	}
	if err := w.WriteData(o.Type); err != nil {
		return err
	}
	for i1 := range o.Name {
		i1 := i1
		if uint64(i1) >= 48 {
			break
		}
		if err := w.WriteData(o.Name[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Name); uint64(i1) < 48; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	for i1 := range o.Network {
		i1 := i1
		if uint64(i1) >= 4 {
			break
		}
		if err := w.WriteData(o.Network[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Network); uint64(i1) < 4; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	for i1 := range o.Node {
		i1 := i1
		if uint64(i1) >= 6 {
			break
		}
		if err := w.WriteData(o.Node[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Node); uint64(i1) < 6; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	for i1 := range o.Socket {
		i1 := i1
		if uint64(i1) >= 2 {
			break
		}
		if err := w.WriteData(o.Socket[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Socket); uint64(i1) < 2; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.HopCount); err != nil {
		return err
	}
	return nil
}
func (o *IPXStaticServiceInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(2); err != nil {
		return err
	}
	if err := w.ReadData(&o.Type); err != nil {
		return err
	}
	o.Name = make([]byte, 48)
	for i1 := range o.Name {
		i1 := i1
		if err := w.ReadData(&o.Name[i1]); err != nil {
			return err
		}
	}
	o.Network = make([]byte, 4)
	for i1 := range o.Network {
		i1 := i1
		if err := w.ReadData(&o.Network[i1]); err != nil {
			return err
		}
	}
	o.Node = make([]byte, 6)
	for i1 := range o.Node {
		i1 := i1
		if err := w.ReadData(&o.Node[i1]); err != nil {
			return err
		}
	}
	o.Socket = make([]byte, 2)
	for i1 := range o.Socket {
		i1 := i1
		if err := w.ReadData(&o.Socket[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.HopCount); err != nil {
		return err
	}
	return nil
}

// IPXServerEntry structure represents IPX_SERVER_ENTRY RPC structure.
//
// The IPX_STATIC_SERVICE_INFO structure MAY<85> be used to carry the IPX server information.
// When this structure is encapsulated in RTR_TOC_ENTRY (section 2.2.1.2.4), the InfoType
// value used MUST be 0x00000003.
type IPXServerEntry struct {
	// Type: Indicates the contents of the payload portion of the IPX packet. It allows
	// a number of client protocols to use the IPX and be identified by the IPX router.
	//
	// Routers can filter the IPX traffic based on the Packet Type field. For example, some
	// routers by default do not propagate NetBIOS over IPX broadcast traffic and MUST be
	// manually configured to enable packets with a packet type value of 20. The following
	// table lists some common defined values of the IPX packet type.
	//
	//	+--------+----------------------------------------------------------+
	//	|        |                                                          |
	//	| VALUE  |                         MEANING                          |
	//	|        |                                                          |
	//	+--------+----------------------------------------------------------+
	//	+--------+----------------------------------------------------------+
	//	| 0x0000 | Unspecified                                              |
	//	+--------+----------------------------------------------------------+
	//	| 0x0001 | RIP                                                      |
	//	+--------+----------------------------------------------------------+
	//	| 0x0004 | SAP/Normal IPX                                           |
	//	+--------+----------------------------------------------------------+
	//	| 0x0005 | SPX                                                      |
	//	+--------+----------------------------------------------------------+
	//	| 0x0014 | IPX WAN broadcast (used for NetBIOS over IPX broadcasts) |
	//	+--------+----------------------------------------------------------+
	Type uint16 `idl:"name:Type" json:"type"`
	// Name: A null-terminated Unicode string giving the name of the interface.
	Name []byte `idl:"name:Name" json:"name"`
	// Network: This MUST be the 4-byte IPX network number in hexadecimal (8 hexadecimal
	// digits).
	Network []byte `idl:"name:Network" json:"network"`
	// Node: Identifies a node on an IPX network. The 6-byte fields can be used to store
	// physical addresses, also known as media access control (MAC) addresses.
	Node []byte `idl:"name:Node" json:"node"`
	// Socket: Identifies the software process addresses of the destination and source applications.
	// With multiple processes communicating between the same two computers, the IPX network
	// and node numbers are the same. The IPX socket number is a software process identifier
	// that is used to forward the IPX payload to the proper process.
	Socket []byte `idl:"name:Socket" json:"socket"`
	// HopCount: This MUST be the number of routers to be traversed to get to the network
	// number.
	HopCount uint16 `idl:"name:HopCount" json:"hop_count"`
}

func (o *IPXServerEntry) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPXServerEntry) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(2); err != nil {
		return err
	}
	if err := w.WriteData(o.Type); err != nil {
		return err
	}
	for i1 := range o.Name {
		i1 := i1
		if uint64(i1) >= 48 {
			break
		}
		if err := w.WriteData(o.Name[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Name); uint64(i1) < 48; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	for i1 := range o.Network {
		i1 := i1
		if uint64(i1) >= 4 {
			break
		}
		if err := w.WriteData(o.Network[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Network); uint64(i1) < 4; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	for i1 := range o.Node {
		i1 := i1
		if uint64(i1) >= 6 {
			break
		}
		if err := w.WriteData(o.Node[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Node); uint64(i1) < 6; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	for i1 := range o.Socket {
		i1 := i1
		if uint64(i1) >= 2 {
			break
		}
		if err := w.WriteData(o.Socket[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Socket); uint64(i1) < 2; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.HopCount); err != nil {
		return err
	}
	return nil
}
func (o *IPXServerEntry) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(2); err != nil {
		return err
	}
	if err := w.ReadData(&o.Type); err != nil {
		return err
	}
	o.Name = make([]byte, 48)
	for i1 := range o.Name {
		i1 := i1
		if err := w.ReadData(&o.Name[i1]); err != nil {
			return err
		}
	}
	o.Network = make([]byte, 4)
	for i1 := range o.Network {
		i1 := i1
		if err := w.ReadData(&o.Network[i1]); err != nil {
			return err
		}
	}
	o.Node = make([]byte, 6)
	for i1 := range o.Node {
		i1 := i1
		if err := w.ReadData(&o.Node[i1]); err != nil {
			return err
		}
	}
	o.Socket = make([]byte, 2)
	for i1 := range o.Socket {
		i1 := i1
		if err := w.ReadData(&o.Socket[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.HopCount); err != nil {
		return err
	}
	return nil
}

// IPXStaticNetBIOSNameInfo structure represents IPX_STATIC_NETBIOS_NAME_INFO RPC structure.
//
// The IPX_STATIC_NETBIOS_NAME_INFO structure MAY<86> be used to contain the static
// NetBIOS name for an IPX interface. When this structure is encapsulated in RTR_TOC_ENTRY
// (section 2.2.1.2.4), the InfoType value MUST be 0x0000000A.
type IPXStaticNetBIOSNameInfo struct {
	Field1 *IPXStaticNetBIOSNameInfo_Field1 `idl:"name:" json:""`
}

func (o *IPXStaticNetBIOSNameInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPXStaticNetBIOSNameInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	// FIXME unknown type
	return nil
}
func (o *IPXStaticNetBIOSNameInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	// FIXME: unknown type
	return nil
}

type IPXStaticNetBIOSNameInfo_Field1 struct {
	// DwordAlign: This field of the union MUST NOT be used.
	DwordAlign uint32 `idl:"name:DwordAlign" json:"dword_align"`
	// Name: Static NetBIOS names MUST be used to confine NetBIOS over IPX broadcast traffic
	// in environments where client-side NetBIOS applications need to access a small set
	// of server-side NetBIOS applications.
	Name []byte `idl:"name:Name" json:"name"`
}

// IPXAdapterInfo structure represents IPX_ADAPTER_INFO RPC structure.
//
// The IPX_ADAPTER_INFO structure MAY<87> be used to contain the adapter information
// for the IPX. When this structure is encapsulated in RTR_TOC_ENTRY (section 2.2.1.2.4),
// the InfoType value used MUST be 0x00000007.
type IPXAdapterInfo struct {
	// PacketType: The PacketType field indicates the contents of the payload portion of
	// the IPX packet. It allows several client protocols to use the IPX and be identified
	// by the IPX router. The following table lists some common defined values of the IPX
	// packet type.
	//
	//	+--------+----------------------------------------------------------+
	//	|        |                                                          |
	//	| VALUE  |                         MEANING                          |
	//	|        |                                                          |
	//	+--------+----------------------------------------------------------+
	//	+--------+----------------------------------------------------------+
	//	| 0x0000 | Unspecified                                              |
	//	+--------+----------------------------------------------------------+
	//	| 0x0001 | RIP                                                      |
	//	+--------+----------------------------------------------------------+
	//	| 0x0004 | SAP/Normal IPX                                           |
	//	+--------+----------------------------------------------------------+
	//	| 0x0005 | SPX                                                      |
	//	+--------+----------------------------------------------------------+
	//	| 0x0014 | IPX WAN broadcast (used for NetBIOS over IPX broadcasts) |
	//	+--------+----------------------------------------------------------+
	PacketType uint32 `idl:"name:PacketType" json:"packet_type"`
	// AdapterName: Name of the adapter. The MAX_ADAPTER_NAME_LEN value is defined as follows.
	AdapterName []uint16 `idl:"name:AdapterName" json:"adapter_name"`
}

func (o *IPXAdapterInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPXAdapterInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.PacketType); err != nil {
		return err
	}
	for i1 := range o.AdapterName {
		i1 := i1
		if uint64(i1) >= 48 {
			break
		}
		if err := w.WriteData(o.AdapterName[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.AdapterName); uint64(i1) < 48; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	if err := w.WriteTrailingGap(4); err != nil {
		return err
	}
	return nil
}
func (o *IPXAdapterInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.PacketType); err != nil {
		return err
	}
	o.AdapterName = make([]uint16, 48)
	for i1 := range o.AdapterName {
		i1 := i1
		if err := w.ReadData(&o.AdapterName[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadTrailingGap(4); err != nil {
		return err
	}
	return nil
}

// IPXTrafficFilterGlobalInfo structure represents IPX_TRAFFIC_FILTER_GLOBAL_INFO RPC structure.
//
// The IPX_TRAFFIC_FILTER_GLOBAL_INFO structure MAY<88> be used to specify the filter
// action to be taken when any IPX interface filter condition is met. When this structure
// is encapsulated in RTR_TOC_ENTRY (section 2.2.1.2.4), the InfoType value MUST be
// 0x0000000B or 0x0000000D. If the value in InfoType is 0x0000000B, the filter is applied
// to incoming traffic and if the value is 0x0000000D, the filter is applied to outgoing
// traffic.
type IPXTrafficFilterGlobalInfo struct {
	// FilterAction: This specifies the action if there is a match with any filter on the
	// interface. This MUST be set to 0x00000001 to permit traffic and to 0x00000002 to
	// deny traffic.
	//
	//	+------------+----------------+
	//	|            |                |
	//	|   VALUE    |    MEANING     |
	//	|            |                |
	//	+------------+----------------+
	//	+------------+----------------+
	//	| 0x00000001 | Permit traffic |
	//	+------------+----------------+
	//	| 0x00000002 | Deny traffic   |
	//	+------------+----------------+
	FilterAction uint32 `idl:"name:FilterAction" json:"filter_action"`
}

func (o *IPXTrafficFilterGlobalInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPXTrafficFilterGlobalInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.FilterAction); err != nil {
		return err
	}
	return nil
}
func (o *IPXTrafficFilterGlobalInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.FilterAction); err != nil {
		return err
	}
	return nil
}

// IPXTrafficFilterInfo structure represents IPX_TRAFFIC_FILTER_INFO RPC structure.
//
// The IPX_TRAFFIC_FILTER_INFO structure MAY<89> be used to specify the filter data
// for an IPX interface. When this structure is encapsulated in RTR_TOC_ENTRY (section
// 2.2.1.2.4), the InfoType value MUST be 0x00000006 or 0x0000000C. If the value of
// InfoType is 0x00000006, the filter is applied to incoming traffic, if the value of
// InfoType is 0x0000000C, the filter is applied to outgoing traffic.
type IPXTrafficFilterInfo struct {
	// FilterDefinition: Flags that specify relevant IPX address fields to filter on. The
	// values MUST be one of the following values.
	//
	//	+--------------------------------------------+--------------------------------------+
	//	|                                            |                                      |
	//	|                   VALUE                    |               MEANING                |
	//	|                                            |                                      |
	//	+--------------------------------------------+--------------------------------------+
	//	+--------------------------------------------+--------------------------------------+
	//	| IPX_TRAFFIC_FILTER_ON_SRCNET 0x00000001    | Apply filter on source network.      |
	//	+--------------------------------------------+--------------------------------------+
	//	| IPX_TRAFFIC_FILTER_ON_SRCNODE 0x00000002   | Apply filter on source node.         |
	//	+--------------------------------------------+--------------------------------------+
	//	| IPX_TRAFFIC_FILTER_ON_SRCSOCKET 0x00000004 | Apply filter on source socket.       |
	//	+--------------------------------------------+--------------------------------------+
	//	| IPX_TRAFFIC_FILTER_ON_DSTNET 0x00000010    | Apply filter on destination network. |
	//	+--------------------------------------------+--------------------------------------+
	//	| IPX_TRAFFIC_FILTER_ON_DSTNODE 0x00000020   | Apply filter on destination node.    |
	//	+--------------------------------------------+--------------------------------------+
	//	| IPX_TRAFFIC_FILTER_ON_DSTSOCKET 0x00000040 | Apply filter on destination socket.  |
	//	+--------------------------------------------+--------------------------------------+
	//	| IPX_TRAFFIC_FILTER_ON_PKTTYPE 0x00000100   | Apply filter based on packet type.   |
	//	+--------------------------------------------+--------------------------------------+
	//	| IPX_TRAFFIC_FILTER_LOG_MATCHES 0x80000000  | Apply filters based on log matches.  |
	//	+--------------------------------------------+--------------------------------------+
	FilterDefinition uint32 `idl:"name:FilterDefinition" json:"filter_definition"`
	// DestinationNetwork: The DestinationNetwork field identifies the network (a segment
	// of the IPX internetwork bounded by the IPX routers) to which an IPX node is connected.
	DestinationNetwork []byte `idl:"name:DestinationNetwork" json:"destination_network"`
	// DestinationNetworkMask: The mask that MUST be logically ANDed with DestinationNetwork.
	DestinationNetworkMask []byte `idl:"name:DestinationNetworkMask" json:"destination_network_mask"`
	// DestinationNode: Identifies a node on an IPX network. The 6-byte fields can be used
	// to store physical addresses, also known as MAC addresses.
	DestinationNode []byte `idl:"name:DestinationNode" json:"destination_node"`
	// DestinationSocket: Identifies the software process addresses of the destination and
	// source applications respectively. With multiple processes communicating between the
	// same two computers, the IPX network and node numbers are the same. The IPX socket
	// number is a software process identifier that is used to forward the IPX payload to
	// the proper process.
	DestinationSocket []byte `idl:"name:DestinationSocket" json:"destination_socket"`
	// SourceNetwork: Identifies the network (a segment of the IPX internetwork bounded
	// by the IPX routers) to which an IPX node is connected.
	SourceNetwork []byte `idl:"name:SourceNetwork" json:"source_network"`
	// SourceNetworkMask: The mask that MUST be logically ANDed with SourceNetwork.
	SourceNetworkMask []byte `idl:"name:SourceNetworkMask" json:"source_network_mask"`
	// SourceNode: Identifies a node on an IPX network. The 6-byte fields can be used to
	// store physical addresses, also known as MAC addresses.
	SourceNode []byte `idl:"name:SourceNode" json:"source_node"`
	// SourceSocket: Identifies the software process addresses of the destination and source
	// applications respectively. With multiple processes communicating between the same
	// two computers, the IPX network and node numbers are the same. The IPX socket number
	// is a software process identifier that is used to forward the IPX payload to the proper
	// process.
	SourceSocket []byte `idl:"name:SourceSocket" json:"source_socket"`
	// PacketType: The PacketType field indicates the contents of the payload portion of
	// the IPX packet. It allows several client protocols to use the IPX and be identified
	// by the IPX router. The following table lists some common defined values of the IPX
	// packet type.
	//
	//	+--------+----------------------------------------------------------+
	//	|        |                                                          |
	//	| VALUE  |                         MEANING                          |
	//	|        |                                                          |
	//	+--------+----------------------------------------------------------+
	//	+--------+----------------------------------------------------------+
	//	| 0x0000 | Unspecified                                              |
	//	+--------+----------------------------------------------------------+
	//	| 0x0001 | RIP                                                      |
	//	+--------+----------------------------------------------------------+
	//	| 0x0004 | SAP/Normal IPX                                           |
	//	+--------+----------------------------------------------------------+
	//	| 0x0005 | SPX                                                      |
	//	+--------+----------------------------------------------------------+
	//	| 0x0014 | IPX WAN broadcast (used for NetBIOS over IPX broadcasts) |
	//	+--------+----------------------------------------------------------+
	PacketType uint8 `idl:"name:PacketType" json:"packet_type"`
}

func (o *IPXTrafficFilterInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPXTrafficFilterInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.FilterDefinition); err != nil {
		return err
	}
	for i1 := range o.DestinationNetwork {
		i1 := i1
		if uint64(i1) >= 4 {
			break
		}
		if err := w.WriteData(o.DestinationNetwork[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.DestinationNetwork); uint64(i1) < 4; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	for i1 := range o.DestinationNetworkMask {
		i1 := i1
		if uint64(i1) >= 4 {
			break
		}
		if err := w.WriteData(o.DestinationNetworkMask[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.DestinationNetworkMask); uint64(i1) < 4; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	for i1 := range o.DestinationNode {
		i1 := i1
		if uint64(i1) >= 6 {
			break
		}
		if err := w.WriteData(o.DestinationNode[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.DestinationNode); uint64(i1) < 6; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	for i1 := range o.DestinationSocket {
		i1 := i1
		if uint64(i1) >= 2 {
			break
		}
		if err := w.WriteData(o.DestinationSocket[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.DestinationSocket); uint64(i1) < 2; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	for i1 := range o.SourceNetwork {
		i1 := i1
		if uint64(i1) >= 4 {
			break
		}
		if err := w.WriteData(o.SourceNetwork[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.SourceNetwork); uint64(i1) < 4; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	for i1 := range o.SourceNetworkMask {
		i1 := i1
		if uint64(i1) >= 4 {
			break
		}
		if err := w.WriteData(o.SourceNetworkMask[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.SourceNetworkMask); uint64(i1) < 4; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	for i1 := range o.SourceNode {
		i1 := i1
		if uint64(i1) >= 6 {
			break
		}
		if err := w.WriteData(o.SourceNode[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.SourceNode); uint64(i1) < 6; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	for i1 := range o.SourceSocket {
		i1 := i1
		if uint64(i1) >= 2 {
			break
		}
		if err := w.WriteData(o.SourceSocket[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.SourceSocket); uint64(i1) < 2; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.PacketType); err != nil {
		return err
	}
	if err := w.WriteTrailingGap(4); err != nil {
		return err
	}
	return nil
}
func (o *IPXTrafficFilterInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.FilterDefinition); err != nil {
		return err
	}
	o.DestinationNetwork = make([]byte, 4)
	for i1 := range o.DestinationNetwork {
		i1 := i1
		if err := w.ReadData(&o.DestinationNetwork[i1]); err != nil {
			return err
		}
	}
	o.DestinationNetworkMask = make([]byte, 4)
	for i1 := range o.DestinationNetworkMask {
		i1 := i1
		if err := w.ReadData(&o.DestinationNetworkMask[i1]); err != nil {
			return err
		}
	}
	o.DestinationNode = make([]byte, 6)
	for i1 := range o.DestinationNode {
		i1 := i1
		if err := w.ReadData(&o.DestinationNode[i1]); err != nil {
			return err
		}
	}
	o.DestinationSocket = make([]byte, 2)
	for i1 := range o.DestinationSocket {
		i1 := i1
		if err := w.ReadData(&o.DestinationSocket[i1]); err != nil {
			return err
		}
	}
	o.SourceNetwork = make([]byte, 4)
	for i1 := range o.SourceNetwork {
		i1 := i1
		if err := w.ReadData(&o.SourceNetwork[i1]); err != nil {
			return err
		}
	}
	o.SourceNetworkMask = make([]byte, 4)
	for i1 := range o.SourceNetworkMask {
		i1 := i1
		if err := w.ReadData(&o.SourceNetworkMask[i1]); err != nil {
			return err
		}
	}
	o.SourceNode = make([]byte, 6)
	for i1 := range o.SourceNode {
		i1 := i1
		if err := w.ReadData(&o.SourceNode[i1]); err != nil {
			return err
		}
	}
	o.SourceSocket = make([]byte, 2)
	for i1 := range o.SourceSocket {
		i1 := i1
		if err := w.ReadData(&o.SourceSocket[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.PacketType); err != nil {
		return err
	}
	if err := w.ReadTrailingGap(4); err != nil {
		return err
	}
	return nil
}

// InterfaceTableIndex structure represents IF_TABLE_INDEX RPC structure.
//
// The IF_TABLE_INDEX structure MAY<90> be used to specify the index within the Interface
// Table. It is used in the IPX_MIB_INDEX (section 2.2.1.2.104) structure.
type InterfaceTableIndex struct {
	// InterfaceIndex: The local index value for the network interface. This index value
	// MAY change when a network adapter is disabled and then enabled, or under other circumstances,
	// and need not be persistent.
	InterfaceIndex uint32 `idl:"name:InterfaceIndex" json:"interface_index"`
}

func (o *InterfaceTableIndex) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *InterfaceTableIndex) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.InterfaceIndex); err != nil {
		return err
	}
	return nil
}
func (o *InterfaceTableIndex) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.InterfaceIndex); err != nil {
		return err
	}
	return nil
}

// RoutingTableIndex structure represents ROUTING_TABLE_INDEX RPC structure.
//
// The ROUTING_TABLE_INDEX structure MAY<91> be used to specify the index within the
// routing table. It is used in IPX_MIB_INDEX (section 2.2.1.2.104).
type RoutingTableIndex struct {
	// Network: This MUST be the 4-byte IPX network number in hexadecimal (8 hexadecimal
	// digits).
	Network []byte `idl:"name:Network" json:"network"`
}

func (o *RoutingTableIndex) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *RoutingTableIndex) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	for i1 := range o.Network {
		i1 := i1
		if uint64(i1) >= 4 {
			break
		}
		if err := w.WriteData(o.Network[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Network); uint64(i1) < 4; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	return nil
}
func (o *RoutingTableIndex) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	o.Network = make([]byte, 4)
	for i1 := range o.Network {
		i1 := i1
		if err := w.ReadData(&o.Network[i1]); err != nil {
			return err
		}
	}
	return nil
}

// StaticRoutesTableIndex structure represents STATIC_ROUTES_TABLE_INDEX RPC structure.
//
// The STATIC_ROUTES_TABLE_INDEX structure MAY<92> be used to specify the index within
// the static routes table. It is used in IPX_MIB_INDEX (section 2.2.1.2.104).
type StaticRoutesTableIndex struct {
	// InterfaceIndex: The local index value for the network interface. This index value
	// MAY change when a network adapter is disabled and then enabled, or under other circumstances,
	// and need not be persistent.
	InterfaceIndex uint32 `idl:"name:InterfaceIndex" json:"interface_index"`
	// Network: This MUST be the 4-byte IPX network number in hexadecimal (8 hexadecimal
	// digits).
	Network []byte `idl:"name:Network" json:"network"`
}

func (o *StaticRoutesTableIndex) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *StaticRoutesTableIndex) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.InterfaceIndex); err != nil {
		return err
	}
	for i1 := range o.Network {
		i1 := i1
		if uint64(i1) >= 4 {
			break
		}
		if err := w.WriteData(o.Network[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Network); uint64(i1) < 4; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteTrailingGap(4); err != nil {
		return err
	}
	return nil
}
func (o *StaticRoutesTableIndex) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.InterfaceIndex); err != nil {
		return err
	}
	o.Network = make([]byte, 4)
	for i1 := range o.Network {
		i1 := i1
		if err := w.ReadData(&o.Network[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadTrailingGap(4); err != nil {
		return err
	}
	return nil
}

// ServicesTableIndex structure represents SERVICES_TABLE_INDEX RPC structure.
//
// The SERVICES_TABLE_INDEX structure MAY<93> be used to specify the index within the
// services table. It is used in IPX_MIB_INDEX (section 2.2.1.2.104).
type ServicesTableIndex struct {
	// ServiceType: The type of service (for example: file server, print server, or application
	// server). Commonly used types are described in the following table.
	//
	//	+----------------------------+----------------------+
	//	|        SERVICE TYPE        |                      |
	//	|       (HEXADECIMAL)        |        SERVER        |
	//	|                            |                      |
	//	+----------------------------+----------------------+
	//	+----------------------------+----------------------+
	//	| 0x0000                     | Unknown              |
	//	+----------------------------+----------------------+
	//	| 0x0000 — 0x0004            | NetWare file server  |
	//	+----------------------------+----------------------+
	//	| 0x0000 — 0x0007            | NetWare print server |
	//	+----------------------------+----------------------+
	//	| 0x0006 — 0x0040            | Microsoft RPC server |
	//	+----------------------------+----------------------+
	//	| 0x00FF                     | General SAP request  |
	//	+----------------------------+----------------------+
	ServiceType uint16 `idl:"name:ServiceType" json:"service_type"`
	// ServiceName: The name of the server hosting the service.
	ServiceName []byte `idl:"name:ServiceName" json:"service_name"`
}

func (o *ServicesTableIndex) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *ServicesTableIndex) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(2); err != nil {
		return err
	}
	if err := w.WriteData(o.ServiceType); err != nil {
		return err
	}
	for i1 := range o.ServiceName {
		i1 := i1
		if uint64(i1) >= 48 {
			break
		}
		if err := w.WriteData(o.ServiceName[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.ServiceName); uint64(i1) < 48; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteTrailingGap(2); err != nil {
		return err
	}
	return nil
}
func (o *ServicesTableIndex) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(2); err != nil {
		return err
	}
	if err := w.ReadData(&o.ServiceType); err != nil {
		return err
	}
	o.ServiceName = make([]byte, 48)
	for i1 := range o.ServiceName {
		i1 := i1
		if err := w.ReadData(&o.ServiceName[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadTrailingGap(2); err != nil {
		return err
	}
	return nil
}

// StaticServicesTableIndex structure represents STATIC_SERVICES_TABLE_INDEX RPC structure.
//
// The STATIC_SERVICES_TABLE_INDEX structure MAY<94> be used to specify the index within
// the static services table. It is used in IPX_MIB_INDEX (section 2.2.1.2.104).
type StaticServicesTableIndex struct {
	// InterfaceIndex: The local index value for the network interface. This index value
	// MAY change when a network adapter is disabled and then enabled, or under other circumstances,
	// and need not be persistent.
	InterfaceIndex uint32 `idl:"name:InterfaceIndex" json:"interface_index"`
	// ServiceType: The type of service (for example: file server, print server, or application
	// server). Commonly used types are described in the following table.
	//
	//	+----------------------------+----------------------+
	//	|        SERVICE TYPE        |                      |
	//	|       (HEXADECIMAL)        |        SERVER        |
	//	|                            |                      |
	//	+----------------------------+----------------------+
	//	+----------------------------+----------------------+
	//	| 0x0000                     | Unknown              |
	//	+----------------------------+----------------------+
	//	| 0x0000 — 0x0004            | NetWare File Server  |
	//	+----------------------------+----------------------+
	//	| 0x0000 — 0x0007            | NetWare Print Server |
	//	+----------------------------+----------------------+
	//	| 0x0006 — 0x0040            | Microsoft RPC Server |
	//	+----------------------------+----------------------+
	//	| 0x00FF                     | General SAP Request  |
	//	+----------------------------+----------------------+
	ServiceType uint16 `idl:"name:ServiceType" json:"service_type"`
	// ServiceName: The name of the server hosting the service.
	ServiceName []byte `idl:"name:ServiceName" json:"service_name"`
}

func (o *StaticServicesTableIndex) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *StaticServicesTableIndex) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.InterfaceIndex); err != nil {
		return err
	}
	if err := w.WriteData(o.ServiceType); err != nil {
		return err
	}
	for i1 := range o.ServiceName {
		i1 := i1
		if uint64(i1) >= 48 {
			break
		}
		if err := w.WriteData(o.ServiceName[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.ServiceName); uint64(i1) < 48; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteTrailingGap(4); err != nil {
		return err
	}
	return nil
}
func (o *StaticServicesTableIndex) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.InterfaceIndex); err != nil {
		return err
	}
	if err := w.ReadData(&o.ServiceType); err != nil {
		return err
	}
	o.ServiceName = make([]byte, 48)
	for i1 := range o.ServiceName {
		i1 := i1
		if err := w.ReadData(&o.ServiceName[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadTrailingGap(4); err != nil {
		return err
	}
	return nil
}

type IPXMIBIndex struct {
	// InterfaceTableIndex: Gives the MIB index within the interface table, as specified
	// in section 2.2.1.2.99.
	InterfaceTableIndex *InterfaceTableIndex `idl:"name:InterfaceTableIndex" json:"interface_table_index"`
	// RoutingTableIndex: Gives the MIB index within the routing table, as specified in
	// section 2.2.1.2.100.
	RoutingTableIndex *RoutingTableIndex `idl:"name:RoutingTableIndex" json:"routing_table_index"`
	// StaticRoutesTableIndex: Gives the MIB index within the static routes table, as specified
	// in section 2.2.1.2.101.
	StaticRoutesTableIndex *StaticRoutesTableIndex `idl:"name:StaticRoutesTableIndex" json:"static_routes_table_index"`
	// ServicesTableIndex: Gives the MIB index within the services table, as specified in
	// section 2.2.1.2.102.
	ServicesTableIndex *ServicesTableIndex `idl:"name:ServicesTableIndex" json:"services_table_index"`
	// StaticServicesTableIndex: Gives the MIB index within the static services table, as
	// specified in section 2.2.1.2.103.
	StaticServicesTableIndex *StaticServicesTableIndex `idl:"name:StaticServicesTableIndex" json:"static_services_table_index"`
}

// IPXMIBGetInputData structure represents IPX_MIB_GET_INPUT_DATA RPC structure.
//
// The IPX_MIB_GET_INPUT_DATA structure MAY<96> be used to retrieve IPX MIB entries.
// This structure is used in the following methods:
//
// * RMIBEntryGet (section 3.1.4.30) ( ebc5c709-36d8-4520-a0ac-6f36d2d6c0b2 )
//
// * RMIBEntryGetFirst (section 3.1.4.31) ( 9102e585-2f62-4408-bfb6-02a6460cc883 )
//
// * RMIBEntryGetNext (section 3.1.4.32) ( 50f78033-d248-4272-b4b9-a2519a0f304d )
//
// typedef struct _IPX_MIB_GET_INPUT_DATA {
//
// ULONG TableId;
//
// IPX_MIB_INDEX MibIndex;
//
// } IPX_MIB_GET_INPUT_DATA,
type IPXMIBGetInputData struct {
	// TableId: Specifies the type of table. Values MUST be one of the following values.
	//
	//	+-----------------------------------+-----------------------------------------------------------------------------+
	//	|                                   |                                                                             |
	//	|               VALUE               |                                   MEANING                                   |
	//	|                                   |                                                                             |
	//	+-----------------------------------+-----------------------------------------------------------------------------+
	//	+-----------------------------------+-----------------------------------------------------------------------------+
	//	| IPX_BASE_ENTRY 0x00000000         | IPX base. See IPXMIB_BASE (section 2.2.1.2.106).                            |
	//	+-----------------------------------+-----------------------------------------------------------------------------+
	//	| IPX_INTERFACE_TABLE 0x00000001    | IPX interface table. See IPX_INTERFACE (section 2.2.1.2.108).               |
	//	+-----------------------------------+-----------------------------------------------------------------------------+
	//	| IPX_DEST_TABLE 0x00000002         | IPX destination table. See IPX_ROUTE (section 2.2.1.2.109).                 |
	//	+-----------------------------------+-----------------------------------------------------------------------------+
	//	| IPX_STATIC_ROUTE_TABLE 0x00000003 | IPX Static Route Table. See IPX_STATIC_ROUTE_INFO (section 2.2.1.2.93).     |
	//	+-----------------------------------+-----------------------------------------------------------------------------+
	//	| IPX_SERV_TABLE 0x00000004         | IPX service table. See IPX_SERVICE (section 2.2.1.2.120).                   |
	//	+-----------------------------------+-----------------------------------------------------------------------------+
	//	| IPX_STATIC_SERV_TABLE 0x00000005  | IPX static service table. See IPX_STATIC_SERVICE_INFO (section 2.2.1.2.94). |
	//	+-----------------------------------+-----------------------------------------------------------------------------+
	TableID uint32 `idl:"name:TableId" json:"table_id"`
	// MibIndex: Specifies the MIB index for the query. See section 2.2.1.2.104.
	MIBIndex *IPXMIBIndex `idl:"name:MibIndex" json:"mib_index"`
}

func (o *IPXMIBGetInputData) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPXMIBGetInputData) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.TableID); err != nil {
		return err
	}
	// FIXME unknown type MibIndex
	return nil
}
func (o *IPXMIBGetInputData) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.TableID); err != nil {
		return err
	}
	// FIXME: unknown type MibIndex
	return nil
}

// IpxmibBase structure represents IPXMIB_BASE RPC structure.
//
// The IPXMIB_BASE structure MAY<97> be used to contain basic information about the
// IPX protocol. This structure is returned as part of the following methods:
//
// * *RMIBEntryGet (section 3.1.4.30)* ( ebc5c709-36d8-4520-a0ac-6f36d2d6c0b2 )
//
// * *RMIBEntryGetFirst (section 3.1.4.31)* ( 9102e585-2f62-4408-bfb6-02a6460cc883 )
//
// * *RMIBEntryGetNext (section 3.1.4.32)* ( 50f78033-d248-4272-b4b9-a2519a0f304d )
//
// typedef struct _IPXMIB_BASE {
//
// ULONG OperState;
//
// UCHAR PrimaryNetNumber[4];
//
// UCHAR Node[6];
//
// UCHAR SysName[48];
//
// ULONG MaxPathSplits;
//
// ULONG IfCount;
//
// ULONG DestCount;
//
// ULONG ServCount;
//
// } IPXMIB_BASE,
type IpxmibBase struct {
	// OperState: The operational status of the interface. This member can be one of the
	// following values.
	//
	//	+--------------------------------+-------------------------------------------------+
	//	|                                |                                                 |
	//	|             VALUE              |                     MEANING                     |
	//	|                                |                                                 |
	//	+--------------------------------+-------------------------------------------------+
	//	+--------------------------------+-------------------------------------------------+
	//	| OPER_STATE_DOWN 0x00000001     | Nonoperational.                                 |
	//	+--------------------------------+-------------------------------------------------+
	//	| OPER_STATE_UP 0x00000002       | Operational and can pass packets.               |
	//	+--------------------------------+-------------------------------------------------+
	//	| OPER_STATE_SLEEPING 0x00000003 | Operational but has to connect to pass packets. |
	//	+--------------------------------+-------------------------------------------------+
	OperatorState uint32 `idl:"name:OperState" json:"operator_state"`
	// PrimaryNetNumber: Every IPX WAN router has a "primary network number". This is an
	// IPX network number unique to the entire internet. This number will be a permanently
	// assigned network number for the router.
	PrimaryNetNumber []byte `idl:"name:PrimaryNetNumber" json:"primary_net_number"`
	// Node: A 48-bit number that identifies the LAN hardware address. If the node number
	// is FFFF FFFF FFFF, it means broadcast. If the node number is 0000 0000 0001, that
	// means it is the server.
	Node []byte `idl:"name:Node" json:"node"`
	// SysName: An administratively assigned name for this managed node. By convention,
	// this is the node's fully qualified domain name.
	SystemName []byte `idl:"name:SysName" json:"system_name"`
	// MaxPathSplits: The maximum number of path splits implies the number of network interface
	// boards in the server that are connected to the network or the number of ports in
	// the server that are connected to a switch. The highest possible number is 8.
	MaxPathSplits uint32 `idl:"name:MaxPathSplits" json:"max_path_splits"`
	// IfCount: Indicates the number of available interfaces.
	InterfaceCount uint32 `idl:"name:IfCount" json:"interface_count"`
	// DestCount: This value indicates the maximum destinations (networks) that the user
	// expects the router to learn. This is used to pre-allocate table sizes for network
	// tables. Changing this value can greatly affect the memory used by the IPX, but it
	// can also speed learning times.
	DestinationCount uint32 `idl:"name:DestCount" json:"destination_count"`
	// ServCount: This value indicates the maximum services that the user expects the router
	// to learn. This is used to pre-allocate table sizes for service tables. Changing this
	// value can greatly affect the memory used by the IPX, but it can also speed learning
	// times.
	ServCount uint32 `idl:"name:ServCount" json:"serv_count"`
}

func (o *IpxmibBase) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IpxmibBase) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.OperatorState); err != nil {
		return err
	}
	for i1 := range o.PrimaryNetNumber {
		i1 := i1
		if uint64(i1) >= 4 {
			break
		}
		if err := w.WriteData(o.PrimaryNetNumber[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.PrimaryNetNumber); uint64(i1) < 4; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	for i1 := range o.Node {
		i1 := i1
		if uint64(i1) >= 6 {
			break
		}
		if err := w.WriteData(o.Node[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Node); uint64(i1) < 6; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	for i1 := range o.SystemName {
		i1 := i1
		if uint64(i1) >= 48 {
			break
		}
		if err := w.WriteData(o.SystemName[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.SystemName); uint64(i1) < 48; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.MaxPathSplits); err != nil {
		return err
	}
	if err := w.WriteData(o.InterfaceCount); err != nil {
		return err
	}
	if err := w.WriteData(o.DestinationCount); err != nil {
		return err
	}
	if err := w.WriteData(o.ServCount); err != nil {
		return err
	}
	return nil
}
func (o *IpxmibBase) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.OperatorState); err != nil {
		return err
	}
	o.PrimaryNetNumber = make([]byte, 4)
	for i1 := range o.PrimaryNetNumber {
		i1 := i1
		if err := w.ReadData(&o.PrimaryNetNumber[i1]); err != nil {
			return err
		}
	}
	o.Node = make([]byte, 6)
	for i1 := range o.Node {
		i1 := i1
		if err := w.ReadData(&o.Node[i1]); err != nil {
			return err
		}
	}
	o.SystemName = make([]byte, 48)
	for i1 := range o.SystemName {
		i1 := i1
		if err := w.ReadData(&o.SystemName[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.MaxPathSplits); err != nil {
		return err
	}
	if err := w.ReadData(&o.InterfaceCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.DestinationCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.ServCount); err != nil {
		return err
	}
	return nil
}

// IPXInterfaceStats structure represents IPX_IF_STATS RPC structure.
//
// The IPX_IF_STATS structure MAY<98> be used to gather the IPX interface statistics.
// This structure is returned as part of the following methods:
//
// * *RMIBEntryGet (section 3.1.4.30)* ( ebc5c709-36d8-4520-a0ac-6f36d2d6c0b2 )
//
// * *RMIBEntryGetFirst (section 3.1.4.31)* ( 9102e585-2f62-4408-bfb6-02a6460cc883 )
//
// * *RMIBEntryGetNext (section 3.1.4.32)* ( 50f78033-d248-4272-b4b9-a2519a0f304d )
//
// typedef struct _IPX_IF_STATS {
//
// ULONG IfOperState;
//
// ULONG MaxPacketSize;
//
// ULONG InHdrErrors;
//
// ULONG InFiltered;
//
// ULONG InNoRoutes;
//
// ULONG InDiscards;
//
// ULONG InDelivers;
//
// ULONG OutFiltered;
//
// ULONG OutDiscards;
//
// ULONG OutDelivers;
//
// ULONG NetbiosReceived;
//
// ULONG NetbiosSent;
//
// } IPX_IF_STATS,
type IPXInterfaceStats struct {
	// IfOperState: The operational status of the interface. This member can be one of the
	// following values.
	//
	//	+--------------------------------+-------------------------------------------------+
	//	|                                |                                                 |
	//	|             VALUE              |                     MEANING                     |
	//	|                                |                                                 |
	//	+--------------------------------+-------------------------------------------------+
	//	+--------------------------------+-------------------------------------------------+
	//	| OPER_STATE_DOWN 0x00000001     | Nonoperational.                                 |
	//	+--------------------------------+-------------------------------------------------+
	//	| OPER_STATE_UP 0x00000002       | Operational and can pass packets.               |
	//	+--------------------------------+-------------------------------------------------+
	//	| OPER_STATE_SLEEPING 0x00000003 | Operational but has to connect to pass packets. |
	//	+--------------------------------+-------------------------------------------------+
	InterfaceOperatorState uint32 `idl:"name:IfOperState" json:"interface_operator_state"`
	// MaxPacketSize: The size of the MAX size packet received on the interface.
	MaxPacketSize uint32 `idl:"name:MaxPacketSize" json:"max_packet_size"`
	// InHdrErrors: The number of packets received with header errors.
	InHdrErrors uint32 `idl:"name:InHdrErrors" json:"in_hdr_errors"`
	// InFiltered: The number of incoming packets filtered.
	InFiltered uint32 `idl:"name:InFiltered" json:"in_filtered"`
	// InNoRoutes: The number of packets received with no matching routes.
	InNoRoutes uint32 `idl:"name:InNoRoutes" json:"in_no_routes"`
	// InDiscards: The number of incoming packets discarded.
	InDiscards uint32 `idl:"name:InDiscards" json:"in_discards"`
	// InDelivers: The number of incoming packets delivered.
	InDelivers uint32 `idl:"name:InDelivers" json:"in_delivers"`
	// OutFiltered: The number of outgoing packets filtered.
	OutFiltered uint32 `idl:"name:OutFiltered" json:"out_filtered"`
	// OutDiscards: The number of outgoing packets discarded.
	OutDiscards uint32 `idl:"name:OutDiscards" json:"out_discards"`
	// OutDelivers: The number of outgoing packets delivered.
	OutDelivers uint32 `idl:"name:OutDelivers" json:"out_delivers"`
	// NetbiosReceived: The number of NetBIOS packets received.
	NetBIOSReceived uint32 `idl:"name:NetbiosReceived" json:"netbios_received"`
	// NetbiosSent: The number of NetBIOS packets sent.
	NetBIOSSent uint32 `idl:"name:NetbiosSent" json:"netbios_sent"`
}

func (o *IPXInterfaceStats) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPXInterfaceStats) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.InterfaceOperatorState); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxPacketSize); err != nil {
		return err
	}
	if err := w.WriteData(o.InHdrErrors); err != nil {
		return err
	}
	if err := w.WriteData(o.InFiltered); err != nil {
		return err
	}
	if err := w.WriteData(o.InNoRoutes); err != nil {
		return err
	}
	if err := w.WriteData(o.InDiscards); err != nil {
		return err
	}
	if err := w.WriteData(o.InDelivers); err != nil {
		return err
	}
	if err := w.WriteData(o.OutFiltered); err != nil {
		return err
	}
	if err := w.WriteData(o.OutDiscards); err != nil {
		return err
	}
	if err := w.WriteData(o.OutDelivers); err != nil {
		return err
	}
	if err := w.WriteData(o.NetBIOSReceived); err != nil {
		return err
	}
	if err := w.WriteData(o.NetBIOSSent); err != nil {
		return err
	}
	return nil
}
func (o *IPXInterfaceStats) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.InterfaceOperatorState); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxPacketSize); err != nil {
		return err
	}
	if err := w.ReadData(&o.InHdrErrors); err != nil {
		return err
	}
	if err := w.ReadData(&o.InFiltered); err != nil {
		return err
	}
	if err := w.ReadData(&o.InNoRoutes); err != nil {
		return err
	}
	if err := w.ReadData(&o.InDiscards); err != nil {
		return err
	}
	if err := w.ReadData(&o.InDelivers); err != nil {
		return err
	}
	if err := w.ReadData(&o.OutFiltered); err != nil {
		return err
	}
	if err := w.ReadData(&o.OutDiscards); err != nil {
		return err
	}
	if err := w.ReadData(&o.OutDelivers); err != nil {
		return err
	}
	if err := w.ReadData(&o.NetBIOSReceived); err != nil {
		return err
	}
	if err := w.ReadData(&o.NetBIOSSent); err != nil {
		return err
	}
	return nil
}

// IPXInterface structure represents IPX_INTERFACE RPC structure.
//
// The IPX_INTERFACE structure MAY<99> be used to describe the MIB Row for IPX_INTERFACE_TABLE.
// This structure is returned as part of the following methods:
//
// * *RMIBEntryGet (section 3.1.4.30)* ( ebc5c709-36d8-4520-a0ac-6f36d2d6c0b2 )
//
// * *RMIBEntryGetFirst (section 3.1.4.31)* ( 9102e585-2f62-4408-bfb6-02a6460cc883 )
//
// * *RMIBEntryGetNext (section 3.1.4.32)* ( 50f78033-d248-4272-b4b9-a2519a0f304d )
//
// typedef struct _IPX_INTERFACE {
//
// ULONG InterfaceIndex;
//
// ULONG AdministratorState;
//
// ULONG AdapterIndex;
//
// UCHAR InterfaceName[48];
//
// ULONG InterfaceType;
//
// ULONG MediaType;
//
// UCHAR NetNumber[4];
//
// UCHAR MacAddress[6];
//
// ULONG Delay;
//
// ULONG Throughput;
//
// ULONG NetbiosAccept;
//
// ULONG NetbiosDeliver;
//
// ULONG EnableIpxWanNegotiation;
//
// IPX_IF_STATS IfStats;
//
// } IPX_INTERFACE,
type IPXInterface struct {
	// InterfaceIndex: The local index value for the network interface. This index value
	// MAY change when a network adapter is disabled and then enabled, or under other circumstances,
	// and need not be persistent.
	InterfaceIndex uint32 `idl:"name:InterfaceIndex" json:"interface_index"`
	// AdministratorState: This MUST be set to the desired state of the interface. A value
	// of 0x00000001 disables the interface and a value of 0x00000002 enables the interface.
	AdministratorState uint32 `idl:"name:AdministratorState" json:"administrator_state"`
	// AdapterIndex: The interface index associated with the network adapter.
	AdapterIndex uint32 `idl:"name:AdapterIndex" json:"adapter_index"`
	// InterfaceName: A null-terminated Unicode string that contains the name of the adapter.
	InterfaceName []byte `idl:"name:InterfaceName" json:"interface_name"`
	// InterfaceType: The type of the interface. The type MUST be one of the following values.
	//
	//	+---------------------------------------------------+-------------------------------------+
	//	|                                                   |                                     |
	//	|                       VALUE                       |               MEANING               |
	//	|                                                   |                                     |
	//	+---------------------------------------------------+-------------------------------------+
	//	+---------------------------------------------------+-------------------------------------+
	//	| IF_TYPE_OTHER 0x00000001                          | Other                               |
	//	+---------------------------------------------------+-------------------------------------+
	//	| IF_TYPE_LAN 0x00000002                            | LAN                                 |
	//	+---------------------------------------------------+-------------------------------------+
	//	| IF_TYPE_WAN_ROUTER 0x00000003                     | WAN router                          |
	//	+---------------------------------------------------+-------------------------------------+
	//	| IF_TYPE_WAN_WORKSTATION 0x00000004                | Remote workstation dialing in       |
	//	+---------------------------------------------------+-------------------------------------+
	//	| IF_TYPE_INTERNAL 0x00000005                       | Internal (virtual) interface        |
	//	+---------------------------------------------------+-------------------------------------+
	//	| IF_TYPE_PERSONAL_WAN_ROUTER 0x00000006            | Personal WAN router                 |
	//	+---------------------------------------------------+-------------------------------------+
	//	| IF_TYPE_ROUTER_WORKSTATION_DIALOUT 0x00000007     | Local workstation dialing out       |
	//	+---------------------------------------------------+-------------------------------------+
	//	| IF_TYPE_STANDALONE_WORKSTATION_DIALOUT 0x00000008 | Stand-alone workstation dialing out |
	//	+---------------------------------------------------+-------------------------------------+
	InterfaceType uint32 `idl:"name:InterfaceType" json:"interface_type"`
	// MediaType: The type of media. This MUST one of the following values.
	//
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	|                                   |                                                                                  |
	//	|               VALUE               |                                     MEANING                                      |
	//	|                                   |                                                                                  |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| NdisMedium802_3 0x00000000        | An Ethernet (802.3) network.                                                     |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| NdisMedium802_5 0x00000001        | A Token Ring (802.5) network.                                                    |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| NdisMediumFddi 0x00000002         | A Fiber Distributed Data Interface (FDDI) network.                               |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| NdisMediumWan 0x00000003          | A wide area network (WAN). This type covers various forms of point-to-point and  |
	//	|                                   | WAN NICs and variant address/header formats that MUST be negotiated between the  |
	//	|                                   | protocol driver and the underlying driver after the binding is established.      |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| NdisMediumLocalTalk 0x00000004    | A LocalTalk network.                                                             |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| NdisMediumDix 0x00000005          | An Ethernet network for which the drivers use the DIX Ethernet header format.    |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| NdisMediumArcnetRaw 0x00000006    | An ARCNET network.                                                               |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| NdisMediumArcnet878_2 0x00000007  | An ARCNET (878.2) network.                                                       |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| NdisMediumAtm 0x00000008          | An ATM network. Connection-oriented client protocol drivers can bind themselves  |
	//	|                                   | to an underlying miniport driver that returns this value. Otherwise, legacy      |
	//	|                                   | protocol drivers bind themselves to the system-supplied LanE intermediate        |
	//	|                                   | driver, which reports its medium type as either NdisMedium802_3 or               |
	//	|                                   | NdisMedium802_5, depending on how the network administrator configures the LanE  |
	//	|                                   | driver.                                                                          |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| NdisMediumWirelessWan 0x00000009  | A wireless network. NDIS 5.x miniport drivers that support wireless LAN (WLAN)   |
	//	|                                   | or wireless WAN (WWAN) packets declare their medium as NdisMedium802_3 and       |
	//	|                                   | emulate Ethernet to higher-level NDIS drivers.<100>                              |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| NdisMediumIrda 0x0000000A         | An infrared (IrDA) network.                                                      |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| NdisMediumBpc 0x0000000B          | A broadcast computer network.                                                    |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| NdisMediumCoWan 0x0000000C        | A wide area network (WAN) in a connection-oriented environment.                  |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| NdisMedium1394 0x0000000D         | An IEEE 1394 (FireWire) network.                                                 |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| NdisMediumInfiniBand 0x0000000E   | An InfiniBand network.                                                           |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| NdisMediumTunnel 0x0000000F       | A tunnel network.                                                                |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| NdisMediumNative802_11 0x00000010 | A native IEEE 802.11 network.                                                    |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| NdisMediumLoopback 0x00000011     | An NDIS loopback network.                                                        |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	MediaType uint32 `idl:"name:MediaType" json:"media_type"`
	// NetNumber: The IPX network number that is matched to the destination network number
	// in a packet's IPX header.
	NetNumber []byte `idl:"name:NetNumber" json:"net_number"`
	// MacAddress: The destination MAC address of the IPX packet when it is forwarded to
	// the next hop. For directly attached networks, the Forwarding MAC Address field is
	// blank.
	MACAddress []byte `idl:"name:MacAddress" json:"mac_address"`
	// Delay: Link delay indicated in milliseconds.
	Delay uint32 `idl:"name:Delay" json:"delay"`
	// Throughput: Throughput of the interface indicated in bits per second.
	Throughput uint32 `idl:"name:Throughput" json:"throughput"`
	// NetbiosAccept: This MUST be set to 0x00000001 for the interface to accept NetBIOS
	// broadcast packets.
	NetBIOSAccept uint32 `idl:"name:NetbiosAccept" json:"netbios_accept"`
	// NetbiosDeliver: This MUST be set to 0x00000000 on the WAN interface and 0x00000001
	// on the LAN interface.
	NetBIOSDeliver uint32 `idl:"name:NetbiosDeliver" json:"netbios_deliver"`
	// EnableIpxWanNegotiation: A value of 0x00000001 disables the WAN negotiation, and
	// a value of 0x00000002 enables the WAN negotiation.
	EnableIPXWANNegotiation uint32 `idl:"name:EnableIpxWanNegotiation" json:"enable_ipx_wan_negotiation"`
	// IfStats: The interface statistics. See IPX_IF_STATS (section 2.2.1.2.107).
	InterfaceStats *IPXInterfaceStats `idl:"name:IfStats" json:"interface_stats"`
}

func (o *IPXInterface) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPXInterface) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.InterfaceIndex); err != nil {
		return err
	}
	if err := w.WriteData(o.AdministratorState); err != nil {
		return err
	}
	if err := w.WriteData(o.AdapterIndex); err != nil {
		return err
	}
	for i1 := range o.InterfaceName {
		i1 := i1
		if uint64(i1) >= 48 {
			break
		}
		if err := w.WriteData(o.InterfaceName[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.InterfaceName); uint64(i1) < 48; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.InterfaceType); err != nil {
		return err
	}
	if err := w.WriteData(o.MediaType); err != nil {
		return err
	}
	for i1 := range o.NetNumber {
		i1 := i1
		if uint64(i1) >= 4 {
			break
		}
		if err := w.WriteData(o.NetNumber[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.NetNumber); uint64(i1) < 4; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	for i1 := range o.MACAddress {
		i1 := i1
		if uint64(i1) >= 6 {
			break
		}
		if err := w.WriteData(o.MACAddress[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.MACAddress); uint64(i1) < 6; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Delay); err != nil {
		return err
	}
	if err := w.WriteData(o.Throughput); err != nil {
		return err
	}
	if err := w.WriteData(o.NetBIOSAccept); err != nil {
		return err
	}
	if err := w.WriteData(o.NetBIOSDeliver); err != nil {
		return err
	}
	if err := w.WriteData(o.EnableIPXWANNegotiation); err != nil {
		return err
	}
	if o.InterfaceStats != nil {
		if err := o.InterfaceStats.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&IPXInterfaceStats{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *IPXInterface) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.InterfaceIndex); err != nil {
		return err
	}
	if err := w.ReadData(&o.AdministratorState); err != nil {
		return err
	}
	if err := w.ReadData(&o.AdapterIndex); err != nil {
		return err
	}
	o.InterfaceName = make([]byte, 48)
	for i1 := range o.InterfaceName {
		i1 := i1
		if err := w.ReadData(&o.InterfaceName[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.InterfaceType); err != nil {
		return err
	}
	if err := w.ReadData(&o.MediaType); err != nil {
		return err
	}
	o.NetNumber = make([]byte, 4)
	for i1 := range o.NetNumber {
		i1 := i1
		if err := w.ReadData(&o.NetNumber[i1]); err != nil {
			return err
		}
	}
	o.MACAddress = make([]byte, 6)
	for i1 := range o.MACAddress {
		i1 := i1
		if err := w.ReadData(&o.MACAddress[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.Delay); err != nil {
		return err
	}
	if err := w.ReadData(&o.Throughput); err != nil {
		return err
	}
	if err := w.ReadData(&o.NetBIOSAccept); err != nil {
		return err
	}
	if err := w.ReadData(&o.NetBIOSDeliver); err != nil {
		return err
	}
	if err := w.ReadData(&o.EnableIPXWANNegotiation); err != nil {
		return err
	}
	if o.InterfaceStats == nil {
		o.InterfaceStats = &IPXInterfaceStats{}
	}
	if err := o.InterfaceStats.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// IPXRoute structure represents IPX_ROUTE RPC structure.
//
// The IPX_ROUTE structure MAY<101> be used to specify the details for an IPX route
// in the RRAS server.
type IPXRoute struct {
	// InterfaceIndex: The local index value for the network interface. This index value
	// MAY change when a network adapter is disabled and then enabled, or under other circumstances,
	// and need not be persistent.
	InterfaceIndex uint32 `idl:"name:InterfaceIndex" json:"interface_index"`
	// Protocol: The protocol that added the route. The value MUST be one of the following
	// values.
	//
	//	+--------------------------------+---------------+
	//	|                                |               |
	//	|             VALUE              |    MEANING    |
	//	|                                |               |
	//	+--------------------------------+---------------+
	//	+--------------------------------+---------------+
	//	| IPX_PROTOCOL_LOCAL 0x00000000  | Local route   |
	//	+--------------------------------+---------------+
	//	| IPX_PROTOCOL_STATIC 0x00000001 | Static route  |
	//	+--------------------------------+---------------+
	//	| IPX_PROTOCOL_RIP 0x00000002    | Added by RIP  |
	//	+--------------------------------+---------------+
	//	| IPX_PROTOCOL_NLSP 0x00000004   | Added by NLSP |
	//	+--------------------------------+---------------+
	Protocol uint32 `idl:"name:Protocol" json:"protocol"`
	// Network: This MUST be the 4-byte IPX network number in hexadecimal (8 hexadecimal
	// digits).
	Network []byte `idl:"name:Network" json:"network"`
	// TickCount: The number of ticks it takes to reach the destination network where one
	// tick is approximately 1/18 of a second. This estimate is based on ongoing RIP requests
	// and replies and is determined by the transmission speed of network segments. LAN
	// links are typically one tick, and WAN links, such as a T1 link, are usually six or
	// seven ticks. The tick count is an estimated, not precise, measurement of the delay.
	TickCount uint16 `idl:"name:TickCount" json:"tick_count"`
	// HopCount: This MUST be the number of routers to be traversed to get to the network
	// number.
	HopCount uint16 `idl:"name:HopCount" json:"hop_count"`
	// NextHopMacAddress: This MUST be the 6-byte MAC address of the next hop in hexadecimal
	// (12 hexadecimal digits).
	NextHopMACAddress []byte `idl:"name:NextHopMacAddress" json:"next_hop_mac_address"`
	// Flags: Indicates the type of route being added. It MUST be one of the following values.
	//
	//	+-----------------------------------+-------------------------------+
	//	|                                   |                               |
	//	|               VALUE               |            MEANING            |
	//	|                                   |                               |
	//	+-----------------------------------+-------------------------------+
	//	+-----------------------------------+-------------------------------+
	//	| GLOBAL_WAN_ROUTE 0x00000001       | Global route.                 |
	//	+-----------------------------------+-------------------------------+
	//	| DO_NOT_ADVERTISE_ROUTE 0x00000002 | This route is not advertised. |
	//	+-----------------------------------+-------------------------------+
	Flags uint32 `idl:"name:Flags" json:"flags"`
}

func (o *IPXRoute) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPXRoute) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.InterfaceIndex); err != nil {
		return err
	}
	if err := w.WriteData(o.Protocol); err != nil {
		return err
	}
	for i1 := range o.Network {
		i1 := i1
		if uint64(i1) >= 4 {
			break
		}
		if err := w.WriteData(o.Network[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Network); uint64(i1) < 4; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.TickCount); err != nil {
		return err
	}
	if err := w.WriteData(o.HopCount); err != nil {
		return err
	}
	for i1 := range o.NextHopMACAddress {
		i1 := i1
		if uint64(i1) >= 6 {
			break
		}
		if err := w.WriteData(o.NextHopMACAddress[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.NextHopMACAddress); uint64(i1) < 6; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	return nil
}
func (o *IPXRoute) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.InterfaceIndex); err != nil {
		return err
	}
	if err := w.ReadData(&o.Protocol); err != nil {
		return err
	}
	o.Network = make([]byte, 4)
	for i1 := range o.Network {
		i1 := i1
		if err := w.ReadData(&o.Network[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.TickCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.HopCount); err != nil {
		return err
	}
	o.NextHopMACAddress = make([]byte, 6)
	for i1 := range o.NextHopMACAddress {
		i1 := i1
		if err := w.ReadData(&o.NextHopMACAddress[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	return nil
}

// IPXService structure represents IPX_SERVICE RPC structure.
//
// The IPX_SERVICE structure MAY<112> be used to contain information about the IPX service
// and is part of the IPX_MIB_ROW (section 2.2.1.2.110) structure.
type IPXService struct {
	// InterfaceIndex: This MUST be the interface index.
	InterfaceIndex uint32 `idl:"name:InterfaceIndex" json:"interface_index"`
	// Protocol: This MUST be the protocol from which knowledge of the service was obtained.
	Protocol uint32 `idl:"name:Protocol" json:"protocol"`
	// Server: This MUST be an IPX_SERVER_ENTRY (section 2.2.1.2.94) structure.
	Server *IPXServerEntry `idl:"name:Server" json:"server"`
}

func (o *IPXService) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPXService) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.InterfaceIndex); err != nil {
		return err
	}
	if err := w.WriteData(o.Protocol); err != nil {
		return err
	}
	if o.Server != nil {
		if err := o.Server.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&IPXServerEntry{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteTrailingGap(4); err != nil {
		return err
	}
	return nil
}
func (o *IPXService) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.InterfaceIndex); err != nil {
		return err
	}
	if err := w.ReadData(&o.Protocol); err != nil {
		return err
	}
	if o.Server == nil {
		o.Server = &IPXServerEntry{}
	}
	if err := o.Server.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadTrailingGap(4); err != nil {
		return err
	}
	return nil
}

type IPXMIBRow struct {
	// Interface: The IPX_INTERFACE (section 2.2.1.2.108) structure.
	Interface *IPXInterface `idl:"name:Interface" json:"interface"`
	// Route: The IPX_ROUTE (section 2.2.1.2.109) structure.
	Route *IPXRoute `idl:"name:Route" json:"route"`
	// Service: The IPX_SERVICE (section 2.2.1.2.120) structure.
	Service *IPXService `idl:"name:Service" json:"service"`
}

// IPXMIBSetInputData structure represents IPX_MIB_SET_INPUT_DATA RPC structure.
//
// The IPX_MIB_SET_INPUT_DATA structure MAY<103> be used in RMIBEntrySet (section 3.1.4.29)
// method.
type IPXMIBSetInputData struct {
	// TableId: Specifies the type of tables. It MUST be one of the following values.
	//
	//	+------------+------------------------+
	//	|            |                        |
	//	|   VALUE    |        MEANING         |
	//	|            |                        |
	//	+------------+------------------------+
	//	+------------+------------------------+
	//	| 0x00000000 | IPX_BASE_ENTRY         |
	//	+------------+------------------------+
	//	| 0x00000001 | IPX_INTERFACE_TABLE    |
	//	+------------+------------------------+
	//	| 0x00000002 | IPX_DEST_TABLE         |
	//	+------------+------------------------+
	//	| 0x00000003 | IPX_STATIC_ROUTE_TABLE |
	//	+------------+------------------------+
	//	| 0x00000004 | IPX_SERV_TABLE         |
	//	+------------+------------------------+
	//	| 0x00000005 | IPX_STATIC_SERV_TABLE  |
	//	+------------+------------------------+
	TableID uint32 `idl:"name:TableId" json:"table_id"`
	// MibRow: An IPX_MIB_ROW (section 2.2.1.2.110) structure.
	MIBRow *IPXMIBRow `idl:"name:MibRow" json:"mib_row"`
}

func (o *IPXMIBSetInputData) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPXMIBSetInputData) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.TableID); err != nil {
		return err
	}
	// FIXME unknown type MibRow
	return nil
}
func (o *IPXMIBSetInputData) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.TableID); err != nil {
		return err
	}
	// FIXME: unknown type MibRow
	return nil
}

// SAPServiceFilterInfo structure represents SAP_SERVICE_FILTER_INFO RPC structure.
//
// The SAP_SERVICE_FILTER_INFO structure MAY<104> be used in the structure SAP_IF_FILTERS
// (section 2.2.1.2.113).
type SAPServiceFilterInfo struct {
	Field1 *SAPServiceFilterInfo_Field1 `idl:"name:" json:""`
	// ServiceName: Stores the name of the server advertising the service. The combination
	// of server name and service type uniquely identifies a service on an IPX internetwork.
	// Server names that are fewer than 48 bytes are terminated with the ASCII NULL character.
	ServiceName []byte `idl:"name:ServiceName" json:"service_name"`
}

func (o *SAPServiceFilterInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *SAPServiceFilterInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(2); err != nil {
		return err
	}
	// FIXME unknown type
	for i1 := range o.ServiceName {
		i1 := i1
		if uint64(i1) >= 48 {
			break
		}
		if err := w.WriteData(o.ServiceName[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.ServiceName); uint64(i1) < 48; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteTrailingGap(2); err != nil {
		return err
	}
	return nil
}
func (o *SAPServiceFilterInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(2); err != nil {
		return err
	}
	// FIXME: unknown type
	o.ServiceName = make([]byte, 48)
	for i1 := range o.ServiceName {
		i1 := i1
		if err := w.ReadData(&o.ServiceName[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadTrailingGap(2); err != nil {
		return err
	}
	return nil
}

type SAPServiceFilterInfo_Field1 struct {
	// ServiceType: A field that indicates the type of the service. Service types are assigned
	// uniquely by Novell, Inc. Some commonly defined SAP service types are listed in the
	// following table.
	//
	//	+----------------------------+----------------------+
	//	|        SERVICE TYPE        |                      |
	//	|       (HEXADECIMAL)        |        SERVER        |
	//	|                            |                      |
	//	+----------------------------+----------------------+
	//	+----------------------------+----------------------+
	//	| 0x00                       | Unknown              |
	//	+----------------------------+----------------------+
	//	| 0x00 — 0x04                | NetWare file server  |
	//	+----------------------------+----------------------+
	//	| 0x00 — 0x07                | NetWare print server |
	//	+----------------------------+----------------------+
	//	| 0x06 — 0x40                | Microsoft RPC server |
	//	+----------------------------+----------------------+
	//	| 0xFF                       | General SAP request  |
	//	+----------------------------+----------------------+
	ServiceType uint16 `idl:"name:ServiceType" json:"service_type"`
	// ServiceType_align: Ensures alignment.
	ServiceTypeAlign uint32 `idl:"name:ServiceType_align" json:"service_type_align"`
}

// SAPInterfaceFilters structure represents SAP_IF_FILTERS RPC structure.
//
// The SAP_IF_FILTERS structure MAY<105> be used to contain information about the SAP
// interface filters.
type SAPInterfaceFilters struct {
	// SupplyFilterAction: This MUST be set to 0x00000001 to permit data and to 0x00000002
	// to deny data.
	//
	//	+------------+-------------+
	//	|            |             |
	//	|   VALUE    |   MEANING   |
	//	|            |             |
	//	+------------+-------------+
	//	+------------+-------------+
	//	| 0x00000001 | Permit data |
	//	+------------+-------------+
	//	| 0x00000002 | Deny data   |
	//	+------------+-------------+
	SupplyFilterAction uint32 `idl:"name:SupplyFilterAction" json:"supply_filter_action"`
	// SupplyFilterCount: The count of supply filters.
	SupplyFilterCount uint32 `idl:"name:SupplyFilterCount" json:"supply_filter_count"`
	// ListenFilterAction: This MUST be set to 0x00000001 to permit data and to 0x00000002
	// to deny data.
	//
	//	+------------+-------------+
	//	|            |             |
	//	|   VALUE    |   MEANING   |
	//	|            |             |
	//	+------------+-------------+
	//	+------------+-------------+
	//	| 0x00000001 | Permit data |
	//	+------------+-------------+
	//	| 0x00000002 | Deny data   |
	//	+------------+-------------+
	ListenFilterAction uint32 `idl:"name:ListenFilterAction" json:"listen_filter_action"`
	// ListenFilterCount: The count of listen filters.
	ListenFilterCount uint32 `idl:"name:ListenFilterCount" json:"listen_filter_count"`
	// ServiceFilter: This is a SAP_SERVICE_FILTER_INFO (section 2.2.1.2.112).
	ServiceFilter []*SAPServiceFilterInfo `idl:"name:ServiceFilter" json:"service_filter"`
}

func (o *SAPInterfaceFilters) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *SAPInterfaceFilters) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.SupplyFilterAction); err != nil {
		return err
	}
	if err := w.WriteData(o.SupplyFilterCount); err != nil {
		return err
	}
	if err := w.WriteData(o.ListenFilterAction); err != nil {
		return err
	}
	if err := w.WriteData(o.ListenFilterCount); err != nil {
		return err
	}
	for i1 := range o.ServiceFilter {
		i1 := i1
		if uint64(i1) >= 1 {
			break
		}
		if o.ServiceFilter[i1] != nil {
			if err := o.ServiceFilter[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&SAPServiceFilterInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.ServiceFilter); uint64(i1) < 1; i1++ {
		if err := (&SAPServiceFilterInfo{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteTrailingGap(4); err != nil {
		return err
	}
	return nil
}
func (o *SAPInterfaceFilters) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.SupplyFilterAction); err != nil {
		return err
	}
	if err := w.ReadData(&o.SupplyFilterCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.ListenFilterAction); err != nil {
		return err
	}
	if err := w.ReadData(&o.ListenFilterCount); err != nil {
		return err
	}
	o.ServiceFilter = make([]*SAPServiceFilterInfo, 1)
	for i1 := range o.ServiceFilter {
		i1 := i1
		if o.ServiceFilter[i1] == nil {
			o.ServiceFilter[i1] = &SAPServiceFilterInfo{}
		}
		if err := o.ServiceFilter[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.ReadTrailingGap(4); err != nil {
		return err
	}
	return nil
}

// SAPInterfaceInfo structure represents SAP_IF_INFO RPC structure.
//
// The SAP_IF_INFO structure MAY<113> be used to contain information about the SAP interface.
// This structure is returned as part of the following methods:
//
// * *RMIBEntryGet (section 3.1.4.30)* ( ebc5c709-36d8-4520-a0ac-6f36d2d6c0b2 )
//
// * *RMIBEntryGetFirst (section 3.1.4.31)* ( 9102e585-2f62-4408-bfb6-02a6460cc883 )
//
// * *RMIBEntryGetNext (section 3.1.4.32)* ( 50f78033-d248-4272-b4b9-a2519a0f304d )
//
// typedef struct _SAP_IF_INFO {
//
// ULONG AdminState;
//
// ULONG UpdateMode;
//
// ULONG PacketType;
//
// ULONG Supply;
//
// ULONG Listen;
//
// ULONG GetNearestServerReply;
//
// ULONG PeriodicUpdateInterval;
//
// ULONG AgeIntervalMultiplier;
//
// } SAP_IF_INFO,
type SAPInterfaceInfo struct {
	// AdminState: This MUST be the desired state of the interface. A value of 0x00000001
	// disables the SAP on the interface, and a value of 0x00000002 enables the SAP on the
	// interface.
	AdminState uint32 `idl:"name:AdminState" json:"admin_state"`
	// UpdateMode: This MUST be the SAP update mechanism used on the interface.
	UpdateMode uint32 `idl:"name:UpdateMode" json:"update_mode"`
	// PacketType: This MUST be the SAP packet type used on this interface.
	PacketType uint32 `idl:"name:PacketType" json:"packet_type"`
	// Supply: This MUST be set to a value of 0x00000001 to disable sending SAP updates
	// on this interface and to a value of 0x00000002 to enable.
	Supply uint32 `idl:"name:Supply" json:"supply"`
	// Listen: This MUST be set to a value of 0x00000001 to disable listening to SAP updates
	// on this interface and to a value of 0x00000002 to enable.
	Listen uint32 `idl:"name:Listen" json:"listen"`
	// GetNearestServerReply: Set to a value of 0x00000001 to disable GetNearestServer and
	// to a value of 0x00000002 to enable.
	GetNearestServerReply uint32 `idl:"name:GetNearestServerReply" json:"get_nearest_server_reply"`
	// PeriodicUpdateInterval: This MUST be the interval, in seconds, at which the information
	// is periodically updated. The default value is 60.
	PeriodicUpdateInterval uint32 `idl:"name:PeriodicUpdateInterval" json:"periodic_update_interval"`
	// AgeIntervalMultiplier: Each time a periodic update is done at the server, PeriodicUpdateInterval
	// is multiplied by AgeIntervalMultiplier. The default value is 3.
	AgeIntervalMultiplier uint32 `idl:"name:AgeIntervalMultiplier" json:"age_interval_multiplier"`
}

func (o *SAPInterfaceInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *SAPInterfaceInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.AdminState); err != nil {
		return err
	}
	if err := w.WriteData(o.UpdateMode); err != nil {
		return err
	}
	if err := w.WriteData(o.PacketType); err != nil {
		return err
	}
	if err := w.WriteData(o.Supply); err != nil {
		return err
	}
	if err := w.WriteData(o.Listen); err != nil {
		return err
	}
	if err := w.WriteData(o.GetNearestServerReply); err != nil {
		return err
	}
	if err := w.WriteData(o.PeriodicUpdateInterval); err != nil {
		return err
	}
	if err := w.WriteData(o.AgeIntervalMultiplier); err != nil {
		return err
	}
	return nil
}
func (o *SAPInterfaceInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.AdminState); err != nil {
		return err
	}
	if err := w.ReadData(&o.UpdateMode); err != nil {
		return err
	}
	if err := w.ReadData(&o.PacketType); err != nil {
		return err
	}
	if err := w.ReadData(&o.Supply); err != nil {
		return err
	}
	if err := w.ReadData(&o.Listen); err != nil {
		return err
	}
	if err := w.ReadData(&o.GetNearestServerReply); err != nil {
		return err
	}
	if err := w.ReadData(&o.PeriodicUpdateInterval); err != nil {
		return err
	}
	if err := w.ReadData(&o.AgeIntervalMultiplier); err != nil {
		return err
	}
	return nil
}

// SAPInterfaceConfig structure represents SAP_IF_CONFIG RPC structure.
//
// The SAP_IF_CONFIG structure MAY<106> be used to contain SAP InterfaceConfiguration
// Information. This structure MUST be used when the InfoType in RTR_TOC_ENTRY (section
// 2.2.1.2.4) is 0x00020001.
type SAPInterfaceConfig struct {
	// SapIfInfo: This MUST be a SAP_IF_INFO (section 2.2.1.2.121) structure.
	SAPInterfaceInfo *SAPInterfaceInfo `idl:"name:SapIfInfo" json:"sap_interface_info"`
	// SapIfFilters: This is a SAP_IF_FILTERS (section 2.2.1.2.113) structure.
	SAPInterfaceFilters *SAPInterfaceFilters `idl:"name:SapIfFilters" json:"sap_interface_filters"`
}

func (o *SAPInterfaceConfig) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *SAPInterfaceConfig) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if o.SAPInterfaceInfo != nil {
		if err := o.SAPInterfaceInfo.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&SAPInterfaceInfo{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.SAPInterfaceFilters != nil {
		if err := o.SAPInterfaceFilters.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&SAPInterfaceFilters{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *SAPInterfaceConfig) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if o.SAPInterfaceInfo == nil {
		o.SAPInterfaceInfo = &SAPInterfaceInfo{}
	}
	if err := o.SAPInterfaceInfo.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.SAPInterfaceFilters == nil {
		o.SAPInterfaceFilters = &SAPInterfaceFilters{}
	}
	if err := o.SAPInterfaceFilters.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// SAPMIBBase structure represents SAP_MIB_BASE RPC structure.
//
// The SAP_MIB_BASE structure MAY<107> be used to contain the operation status. This
// structure is returned as part of the following methods:
//
// * *RMIBEntryGet (section 3.1.4.30)* ( ebc5c709-36d8-4520-a0ac-6f36d2d6c0b2 )
//
// * *RMIBEntryGetFirst (section 3.1.4.31)* ( 9102e585-2f62-4408-bfb6-02a6460cc883 )
//
// * *RMIBEntryGetNext (section 3.1.4.32)* ( 50f78033-d248-4272-b4b9-a2519a0f304d )
//
// typedef struct _SAP_MIB_BASE {
//
// ULONG SapOperState;
//
// } SAP_MIB_BASE,
type SAPMIBBase struct {
	// SapOperState: Contains the operational status of the SAP. It MUST be one of the following
	// values.
	//
	//	+--------------------------------+-----------------------------------+
	//	|                                |                                   |
	//	|             VALUE              |              MEANING              |
	//	|                                |                                   |
	//	+--------------------------------+-----------------------------------+
	//	+--------------------------------+-----------------------------------+
	//	| OPER_STATE_DOWN 0x00000001     | Nonoperational.                   |
	//	+--------------------------------+-----------------------------------+
	//	| OPER_STATE_UP 0x00000002       | Operational and can pass packets. |
	//	+--------------------------------+-----------------------------------+
	//	| OPER_STATE_SLEEPING 0x00000003 | Sleeping.                         |
	//	+--------------------------------+-----------------------------------+
	//	| OPER_STATE_STARTING 0x00000004 | Starting the router.              |
	//	+--------------------------------+-----------------------------------+
	//	| OPER_STATE_STOPPING 0x00000005 | Stopping the router.              |
	//	+--------------------------------+-----------------------------------+
	SAPOperatorState uint32 `idl:"name:SapOperState" json:"sap_operator_state"`
}

func (o *SAPMIBBase) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *SAPMIBBase) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.SAPOperatorState); err != nil {
		return err
	}
	return nil
}
func (o *SAPMIBBase) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.SAPOperatorState); err != nil {
		return err
	}
	return nil
}

// SAPInterfaceStats structure represents SAP_IF_STATS RPC structure.
//
// The SAP_IF_STATS structure MAY<108> be used to contain the SAP MIB Interface Table
// Entry. This structure is returned as part of the following methods:
//
// * *RMIBEntryGet (section 3.1.4.30)* ( ebc5c709-36d8-4520-a0ac-6f36d2d6c0b2 )
//
// * *RMIBEntryGetFirst (section 3.1.4.31)* ( 9102e585-2f62-4408-bfb6-02a6460cc883 )
//
// * *RMIBEntryGetNext (section 3.1.4.32)* ( 50f78033-d248-4272-b4b9-a2519a0f304d )
//
// typedef struct _SAP_IF_STATS {
//
// ULONG SapIfOperState;
//
// ULONG SapIfInputPackets;
//
// ULONG SapIfOutputPackets;
//
// } SAP_IF_STATS,
type SAPInterfaceStats struct {
	// SapIfOperState: Indicates the operation status of the SAP on the interface. It MUST
	// be one of the following values.
	//
	//	+--------------------------------+-----------------------------------+
	//	|                                |                                   |
	//	|             VALUE              |              MEANING              |
	//	|                                |                                   |
	//	+--------------------------------+-----------------------------------+
	//	+--------------------------------+-----------------------------------+
	//	| OPER_STATE_DOWN 0x00000001     | Nonoperational.                   |
	//	+--------------------------------+-----------------------------------+
	//	| OPER_STATE_UP 0x00000002       | Operational and can pass packets. |
	//	+--------------------------------+-----------------------------------+
	//	| OPER_STATE_SLEEPING 0x00000003 | Sleeping.                         |
	//	+--------------------------------+-----------------------------------+
	SAPInterfaceOperatorState uint32 `idl:"name:SapIfOperState" json:"sap_interface_operator_state"`
	// SapIfInputPackets: Counts the SAP input packets on the interface.
	SAPInterfaceInputPackets uint32 `idl:"name:SapIfInputPackets" json:"sap_interface_input_packets"`
	// SapIfOutputPackets: Counts the SAP output packets on the interface.
	SAPInterfaceOutputPackets uint32 `idl:"name:SapIfOutputPackets" json:"sap_interface_output_packets"`
}

func (o *SAPInterfaceStats) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *SAPInterfaceStats) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.SAPInterfaceOperatorState); err != nil {
		return err
	}
	if err := w.WriteData(o.SAPInterfaceInputPackets); err != nil {
		return err
	}
	if err := w.WriteData(o.SAPInterfaceOutputPackets); err != nil {
		return err
	}
	return nil
}
func (o *SAPInterfaceStats) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.SAPInterfaceOperatorState); err != nil {
		return err
	}
	if err := w.ReadData(&o.SAPInterfaceInputPackets); err != nil {
		return err
	}
	if err := w.ReadData(&o.SAPInterfaceOutputPackets); err != nil {
		return err
	}
	return nil
}

// SAPInterface structure represents SAP_INTERFACE RPC structure.
//
// The SAP_INTERFACE structure MAY<109> be used to contain information about an SAP
// interface. This structure is returned as part of the following methods:
//
// * *RMIBEntryGet (section 3.1.4.30)* ( ebc5c709-36d8-4520-a0ac-6f36d2d6c0b2 )
//
// * *RMIBEntryGetFirst (section 3.1.4.31)* ( 9102e585-2f62-4408-bfb6-02a6460cc883 )
//
// * *RMIBEntryGetNext (section 3.1.4.32)* ( 50f78033-d248-4272-b4b9-a2519a0f304d )
//
// typedef struct _SAP_INTERFACE {
//
// ULONG InterfaceIndex;
//
// SAP_IF_INFO SapIfInfo;
//
// SAP_IF_STATS SapIfStats;
//
// } SAP_INTERFACE,
type SAPInterface struct {
	// InterfaceIndex: This MUST be the index of the interface.
	InterfaceIndex uint32 `idl:"name:InterfaceIndex" json:"interface_index"`
	// SapIfInfo: This MUST be a SAP_IF_INFO (section 2.2.1.2.121) structure.
	SAPInterfaceInfo *SAPInterfaceInfo `idl:"name:SapIfInfo" json:"sap_interface_info"`
	// SapIfStats: This MUST be a SAP_IF_STATS (section 2.2.1.2.116) structure.
	SAPInterfaceStats *SAPInterfaceStats `idl:"name:SapIfStats" json:"sap_interface_stats"`
}

func (o *SAPInterface) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *SAPInterface) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.InterfaceIndex); err != nil {
		return err
	}
	if o.SAPInterfaceInfo != nil {
		if err := o.SAPInterfaceInfo.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&SAPInterfaceInfo{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.SAPInterfaceStats != nil {
		if err := o.SAPInterfaceStats.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&SAPInterfaceStats{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *SAPInterface) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.InterfaceIndex); err != nil {
		return err
	}
	if o.SAPInterfaceInfo == nil {
		o.SAPInterfaceInfo = &SAPInterfaceInfo{}
	}
	if err := o.SAPInterfaceInfo.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.SAPInterfaceStats == nil {
		o.SAPInterfaceStats = &SAPInterfaceStats{}
	}
	if err := o.SAPInterfaceStats.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// SAPMIBGetInputData structure represents SAP_MIB_GET_INPUT_DATA RPC structure.
type SAPMIBGetInputData struct {
	// TableId: This MUST be set to 0x00000000 if the table refers to SAP_MIB_BASE (section
	// 2.2.1.2.115) or MUST be set to 0x00000001 if the table refers to SAP_INTERFACE (section
	// 2.2.1.2.117).
	TableID uint32 `idl:"name:TableId" json:"table_id"`
	// The SAP_MIB_GET_INPUT_DATA structure MAY<110> be used to retrieve the SAP MIB information.
	// This structure is used in the following methods to retrieve the MIB information of
	// the TableId and specified InterfaceIndex:
	//
	// * *RMIBEntryGet (section 3.1.4.30)* ( ebc5c709-36d8-4520-a0ac-6f36d2d6c0b2 )
	//
	// * *RMIBEntryGetFirst (section 3.1.4.31)* ( 9102e585-2f62-4408-bfb6-02a6460cc883 )
	//
	// * *RMIBEntryGetNext (section 3.1.4.32* ( 50f78033-d248-4272-b4b9-a2519a0f304d ) )
	//
	// typedef struct _SAP_MIB_GET_INPUT_DATA {
	//
	// ULONG TableId;
	//
	// ULONG InterfaceIndex;
	//
	// } SAP_MIB_GET_INPUT_DATA,
	InterfaceIndex uint32 `idl:"name:InterfaceIndex" json:"interface_index"`
}

func (o *SAPMIBGetInputData) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *SAPMIBGetInputData) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.TableID); err != nil {
		return err
	}
	if err := w.WriteData(o.InterfaceIndex); err != nil {
		return err
	}
	return nil
}
func (o *SAPMIBGetInputData) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.TableID); err != nil {
		return err
	}
	if err := w.ReadData(&o.InterfaceIndex); err != nil {
		return err
	}
	return nil
}

// SAPMIBSetInputData structure represents SAP_MIB_SET_INPUT_DATA RPC structure.
//
// The SAP_MIB_SET_INPUT_DATA structure MAY<111> be used in the RMIBEntrySet (section
// 3.1.4.29) method to set information corresponding to the TableId and the SapInterface.
type SAPMIBSetInputData struct {
	// TableId: This MUST be set to 0x00000001.
	TableID uint32 `idl:"name:TableId" json:"table_id"`
	// SapInterface: This MUST be a SAP_INTERFACE (section 2.2.1.2.117) structure.
	SAPInterface *SAPInterface `idl:"name:SapInterface" json:"sap_interface"`
}

func (o *SAPMIBSetInputData) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *SAPMIBSetInputData) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.TableID); err != nil {
		return err
	}
	if o.SAPInterface != nil {
		if err := o.SAPInterface.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&SAPInterface{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *SAPMIBSetInputData) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.TableID); err != nil {
		return err
	}
	if o.SAPInterface == nil {
		o.SAPInterface = &SAPInterface{}
	}
	if err := o.SAPInterface.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// RIPMIBBase structure represents RIPMIB_BASE RPC structure.
//
// The RIPMIB_BASE structure contains information about the RIP MIB base. This structure
// is returned as part of the following methods:
//
// * *RMIBEntryGet (section 3.1.4.30)* ( ebc5c709-36d8-4520-a0ac-6f36d2d6c0b2 )
//
// * *RMIBEntryGetFirst (section 3.1.4.31)* ( 9102e585-2f62-4408-bfb6-02a6460cc883 )
//
// * *RMIBEntryGetNext (section 3.1.4.32)* ( 50f78033-d248-4272-b4b9-a2519a0f304d )
//
// typedef struct _RIPMIB_BASE {
//
// ULONG RIPOperState;
//
// } RIPMIB_BASE,
type RIPMIBBase struct {
	// RIPOperState: RIPOperState MUST be one of the following values.
	//
	//	+--------------------------------+----------------------------------+
	//	|                                |                                  |
	//	|             VALUE              |             MEANING              |
	//	|                                |                                  |
	//	+--------------------------------+----------------------------------+
	//	+--------------------------------+----------------------------------+
	//	| OPER_STATE_DOWN 0x00000001     | Nonoperational                   |
	//	+--------------------------------+----------------------------------+
	//	| OPER_STATE_UP 0x00000002       | Operational and can pass packets |
	//	+--------------------------------+----------------------------------+
	//	| OPER_STATE_SLEEPING 0x00000003 | Sleeping                         |
	//	+--------------------------------+----------------------------------+
	//	| OPER_STATE_STARTING 0x00000004 | Starting the router              |
	//	+--------------------------------+----------------------------------+
	//	| OPER_STATE_STOPPING 0x00000005 | Stopping the router              |
	//	+--------------------------------+----------------------------------+
	RIPOperatorState uint32 `idl:"name:RIPOperState" json:"rip_operator_state"`
}

func (o *RIPMIBBase) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *RIPMIBBase) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.RIPOperatorState); err != nil {
		return err
	}
	return nil
}
func (o *RIPMIBBase) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.RIPOperatorState); err != nil {
		return err
	}
	return nil
}

// RIPInterfaceStats structure represents RIP_IF_STATS RPC structure.
//
// The RIP_IF_STATS structure contains the RIP interface statistics. This structure
// is returned as part of the following methods:
//
// * *RMIBEntryGet (section 3.1.4.30)* ( ebc5c709-36d8-4520-a0ac-6f36d2d6c0b2 )
//
// * *RMIBEntryGetFirst (section 3.1.4.31)* ( 9102e585-2f62-4408-bfb6-02a6460cc883 )
//
// * *RMIBEntryGetNext (section 3.1.4.32)* ( 50f78033-d248-4272-b4b9-a2519a0f304d )
//
// typedef struct _RIP_IF_STATS {
//
// ULONG RipIfOperState;
//
// ULONG RipIfInputPackets;
//
// ULONG RipIfOutputPackets;
//
// } RIP_IF_STATS,
type RIPInterfaceStats struct {
	// RipIfOperState: This MUST be one of the following values.
	//
	//	+--------------------------------+----------------------------------+
	//	|                                |                                  |
	//	|             VALUE              |             MEANING              |
	//	|                                |                                  |
	//	+--------------------------------+----------------------------------+
	//	+--------------------------------+----------------------------------+
	//	| OPER_STATE_DOWN 0x00000001     | Nonoperational                   |
	//	+--------------------------------+----------------------------------+
	//	| OPER_STATE_UP 0x00000002       | Operational and can pass packets |
	//	+--------------------------------+----------------------------------+
	//	| OPER_STATE_SLEEPING 0x00000003 | Sleeping                         |
	//	+--------------------------------+----------------------------------+
	RIPInterfaceOperatorState uint32 `idl:"name:RipIfOperState" json:"rip_interface_operator_state"`
	// RipIfInputPackets: The count of the RIP interface input packets.
	RIPInterfaceInputPackets uint32 `idl:"name:RipIfInputPackets" json:"rip_interface_input_packets"`
	// RipIfOutputPackets: The count of the RIP interface output packets.
	RIPInterfaceOutputPackets uint32 `idl:"name:RipIfOutputPackets" json:"rip_interface_output_packets"`
}

func (o *RIPInterfaceStats) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *RIPInterfaceStats) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.RIPInterfaceOperatorState); err != nil {
		return err
	}
	if err := w.WriteData(o.RIPInterfaceInputPackets); err != nil {
		return err
	}
	if err := w.WriteData(o.RIPInterfaceOutputPackets); err != nil {
		return err
	}
	return nil
}
func (o *RIPInterfaceStats) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.RIPInterfaceOperatorState); err != nil {
		return err
	}
	if err := w.ReadData(&o.RIPInterfaceInputPackets); err != nil {
		return err
	}
	if err := w.ReadData(&o.RIPInterfaceOutputPackets); err != nil {
		return err
	}
	return nil
}

// RIPInterfaceInfo structure represents RIP_IF_INFO RPC structure.
//
// The RIP_IF_INFO structure MAY<141> contain information about the RIP for IPX interface.
// This structure is used in RIP_IF_CONFIG (section 2.2.1.2.206) and RIP_INTERFACE (section
// 2.2.1.2.124) structures.
type RIPInterfaceInfo struct {
	// AdminState: This MUST be set to the desired state of the interface. A value of 0x00000001
	// disables the interface, and a value of 0x00000002 enables the interface.
	AdminState uint32 `idl:"name:AdminState" json:"admin_state"`
	// UpdateMode: This MUST be set to the RIP update mechanism used on the interface. It
	// can have one of the following values.
	//
	//	+------------+------------------------------+
	//	|            |                              |
	//	|   VALUE    |           MEANING            |
	//	|            |                              |
	//	+------------+------------------------------+
	//	+------------+------------------------------+
	//	| 0x00000001 | Periodic update.             |
	//	+------------+------------------------------+
	//	| 0x00000002 | No update.                   |
	//	+------------+------------------------------+
	//	| 0x00000003 | AutoStatic triggered update. |
	//	+------------+------------------------------+
	UpdateMode uint32 `idl:"name:UpdateMode" json:"update_mode"`
	// PacketType: Indicates the RIP packet type used on this interface and MUST be one
	// of the following values.
	//
	//	+----------------------------------------------+---------------------+
	//	|                                              |                     |
	//	|                    VALUE                     |       MEANING       |
	//	|                                              |                     |
	//	+----------------------------------------------+---------------------+
	//	+----------------------------------------------+---------------------+
	//	| IPX_STANDARD_PACKET_TYPE 0x00000001          | IPX standard packet |
	//	+----------------------------------------------+---------------------+
	//	| IPX_RELIABLE_DELIVERY_PACKET_TYPE 0x00000002 | IPX reliable packet |
	//	+----------------------------------------------+---------------------+
	PacketType uint32 `idl:"name:PacketType" json:"packet_type"`
	// Supply: Determines whether to send RIP updates on this interface. A value of 0x00000001
	// disables sending of a RIP updated on this interface, and a value of 0x00000002 enables
	// sending of a RIP updated on this interface.
	Supply uint32 `idl:"name:Supply" json:"supply"`
	// Listen: Determines whether to listen for RIP updates on this interface. A value of
	// 0x00000001 disables listening for a RIP updated on this interface, and a value of
	// 0x00000002 enables listening for a RIP updated on this interface.
	Listen uint32 `idl:"name:Listen" json:"listen"`
	// PeriodicUpdateInterval: This MUST be the interval at which the information is updated
	// periodically, in seconds. The default value is 60.
	PeriodicUpdateInterval uint32 `idl:"name:PeriodicUpdateInterval" json:"periodic_update_interval"`
	// AgeIntervalMultiplier: Each time a periodic update is done at the server, PeriodicUpdateInterval
	// is multiplied by AgeIntervalMultiplier. The default value is 3.
	AgeIntervalMultiplier uint32 `idl:"name:AgeIntervalMultiplier" json:"age_interval_multiplier"`
}

func (o *RIPInterfaceInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *RIPInterfaceInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.AdminState); err != nil {
		return err
	}
	if err := w.WriteData(o.UpdateMode); err != nil {
		return err
	}
	if err := w.WriteData(o.PacketType); err != nil {
		return err
	}
	if err := w.WriteData(o.Supply); err != nil {
		return err
	}
	if err := w.WriteData(o.Listen); err != nil {
		return err
	}
	if err := w.WriteData(o.PeriodicUpdateInterval); err != nil {
		return err
	}
	if err := w.WriteData(o.AgeIntervalMultiplier); err != nil {
		return err
	}
	return nil
}
func (o *RIPInterfaceInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.AdminState); err != nil {
		return err
	}
	if err := w.ReadData(&o.UpdateMode); err != nil {
		return err
	}
	if err := w.ReadData(&o.PacketType); err != nil {
		return err
	}
	if err := w.ReadData(&o.Supply); err != nil {
		return err
	}
	if err := w.ReadData(&o.Listen); err != nil {
		return err
	}
	if err := w.ReadData(&o.PeriodicUpdateInterval); err != nil {
		return err
	}
	if err := w.ReadData(&o.AgeIntervalMultiplier); err != nil {
		return err
	}
	return nil
}

// RIPInterface structure represents RIP_INTERFACE RPC structure.
//
// The RIP_INTERFACE structure contains information about a specific RIP interface.
// This structure is returned as part of the following methods:
//
// * *RMIBEntryGet (section 3.1.4.30)* ( ebc5c709-36d8-4520-a0ac-6f36d2d6c0b2 )
//
// * *RMIBEntryGetFirst (section 3.1.4.31)* ( 9102e585-2f62-4408-bfb6-02a6460cc883 )
//
// * *RMIBEntryGetNext (section 3.1.4.32)* ( 50f78033-d248-4272-b4b9-a2519a0f304d )
//
// typedef struct _RIP_INTERFACE {
//
// ULONG InterfaceIndex;
//
// RIP_IF_INFO RipIfInfo;
//
// RIP_IF_STATS RipIfStats;
//
// } RIP_INTERFACE,
type RIPInterface struct {
	// InterfaceIndex: This MUST be the interface index of the interface.
	InterfaceIndex uint32 `idl:"name:InterfaceIndex" json:"interface_index"`
	// RipIfInfo: This MUST be the RIP_IF_INFO (section 2.2.1.2.205) structure.
	RIPInterfaceInfo *RIPInterfaceInfo `idl:"name:RipIfInfo" json:"rip_interface_info"`
	// RipIfStats: This MUST be the RIP_IF_STATS (section 2.2.1.2.123) structure.
	RIPInterfaceStats *RIPInterfaceStats `idl:"name:RipIfStats" json:"rip_interface_stats"`
}

func (o *RIPInterface) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *RIPInterface) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.InterfaceIndex); err != nil {
		return err
	}
	if o.RIPInterfaceInfo != nil {
		if err := o.RIPInterfaceInfo.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&RIPInterfaceInfo{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.RIPInterfaceStats != nil {
		if err := o.RIPInterfaceStats.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&RIPInterfaceStats{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *RIPInterface) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.InterfaceIndex); err != nil {
		return err
	}
	if o.RIPInterfaceInfo == nil {
		o.RIPInterfaceInfo = &RIPInterfaceInfo{}
	}
	if err := o.RIPInterfaceInfo.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.RIPInterfaceStats == nil {
		o.RIPInterfaceStats = &RIPInterfaceStats{}
	}
	if err := o.RIPInterfaceStats.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// RIPMIBGetInputData structure represents RIP_MIB_GET_INPUT_DATA RPC structure.
//
// The RIP_MIB_GET_INPUT_DATA structure MAY<114> be used to retrieve information from
// the IPX RIP MIB.
type RIPMIBGetInputData struct {
	// TableId: This MUST contain 0x00000000 if the table refers to RIPMIB_BASE (section
	// 2.2.1.2.122) or it MUST contain 0x00000001 if the table refers to RIP_INTERFACE (section
	// 2.2.1.2.124).
	TableID uint32 `idl:"name:TableId" json:"table_id"`
	// InterfaceIndex: The interface index.
	InterfaceIndex uint32 `idl:"name:InterfaceIndex" json:"interface_index"`
}

func (o *RIPMIBGetInputData) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *RIPMIBGetInputData) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.TableID); err != nil {
		return err
	}
	if err := w.WriteData(o.InterfaceIndex); err != nil {
		return err
	}
	return nil
}
func (o *RIPMIBGetInputData) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.TableID); err != nil {
		return err
	}
	if err := w.ReadData(&o.InterfaceIndex); err != nil {
		return err
	}
	return nil
}

// RIPMIBSetInputData structure represents RIP_MIB_SET_INPUT_DATA RPC structure.
//
// The RIP_MIB_SET_INPUT_DATA structure MAY<115> be used to set information in the IPX
// RIP MIB.
type RIPMIBSetInputData struct {
	// TableId: This MUST contain 0x00000000 if the table refers to RIPMIB_BASE (section
	// 2.2.1.2.122) or it MUST contain 0x00000001 if the table refers to RIP_INTERFACE (section
	// 2.2.1.2.124).
	TableID uint32 `idl:"name:TableId" json:"table_id"`
	// RipInterface: This MUST be the RIP_INTERFACE structure.
	RIPInterface *RIPInterface `idl:"name:RipInterface" json:"rip_interface"`
}

func (o *RIPMIBSetInputData) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *RIPMIBSetInputData) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.TableID); err != nil {
		return err
	}
	if o.RIPInterface != nil {
		if err := o.RIPInterface.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&RIPInterface{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *RIPMIBSetInputData) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.TableID); err != nil {
		return err
	}
	if o.RIPInterface == nil {
		o.RIPInterface = &RIPInterface{}
	}
	if err := o.RIPInterface.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// EAPTLSHash structure represents EAPTLS_HASH RPC structure.
//
// The EAPTLS_HASH structure contains the certificate hash.
type EAPTLSHash struct {
	// cbHash: This MUST contain the number of bytes in the hash.
	HashLength uint32 `idl:"name:cbHash" json:"hash_length"`
	// pbHash: This MUST contain the hash of the certificate.
	Hash []byte `idl:"name:pbHash" json:"hash"`
}

func (o *EAPTLSHash) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *EAPTLSHash) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.HashLength); err != nil {
		return err
	}
	for i1 := range o.Hash {
		i1 := i1
		if uint64(i1) >= 20 {
			break
		}
		if err := w.WriteData(o.Hash[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Hash); uint64(i1) < 20; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteTrailingGap(4); err != nil {
		return err
	}
	return nil
}
func (o *EAPTLSHash) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.HashLength); err != nil {
		return err
	}
	o.Hash = make([]byte, 20)
	for i1 := range o.Hash {
		i1 := i1
		if err := w.ReadData(&o.Hash[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadTrailingGap(4); err != nil {
		return err
	}
	return nil
}

// EAPTLSUserProperties structure represents EAPTLS_USER_PROPERTIES RPC structure.
//
// The EAPTLS_USER_PROPERTIES structure is used to store the EAP Transport Layer Security
// (TLS) user properties.
//
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| reserved                                                                                                                      |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwVersion                                                                                                                     |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwSize                                                                                                                        |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| fFlags                                                                                                                        |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| Hash (24 bytes)                                                                                                               |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| pwszDiffUser                                                                                                                  |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwPinOffset                                                                                                                   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| pwszPin                                                                                                                       |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| usLength                                                      | usMaximumLength                                               |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ucSeed                        | awszString (variable)                                                                         |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
type EAPTLSUserProperties struct {
	// reserved (4 bytes): This MUST be 0x00000000.
	_ uint32 `idl:"name:reserved"`
	// dwVersion (4 bytes): This MUST be 0x00000001.
	Version uint32 `idl:"name:dwVersion" json:"version"`
	// dwSize (4 bytes): This MUST be the number of bytes in this structure.
	Size uint32 `idl:"name:dwSize" json:"size"`
	// fFlags (4 bytes): Unused; it MUST be set to 0x00000000.
	Flags uint32 `idl:"name:fFlags" json:"flags"`
	// Hash (24 bytes): An EAPTLS_HASH (section2.2.1.2.127) structure that MUST contain
	// the hash for the user certificate.
	Hash *EAPTLSHash `idl:"name:Hash" json:"hash"`
	// pwszDiffUser (4 bytes): Pointer to a null-terminated Unicode string that contains
	// the EAP identity to send. The string SHOULD be stored starting at awszString.
	DiffUser string `idl:"name:pwszDiffUser" json:"diff_user"`
	// dwPinOffset (4 bytes): Offset from the end of this structure to where the PIN is
	// stored. This SHOULD be set to sizeof(pwszDiffUser).
	PINOffset uint32 `idl:"name:dwPinOffset" json:"pin_offset"`
	// pwszPin (4 bytes): Pointer to a null-terminated Unicode string that contains the
	// smart card PIN.
	PIN string `idl:"name:pwszPin" json:"pin"`
	// usLength (2 bytes): Unused; it MUST be set to zero (0).
	Length uint16 `idl:"name:usLength" json:"length"`
	// usMaximumLength (2 bytes): Unused; it MUST be set to zero (0).
	MaximumLength uint16 `idl:"name:usMaximumLength" json:"maximum_length"`
	// ucSeed (1 byte): Unused; it MUST be set to zero (0).
	Seed uint8 `idl:"name:ucSeed" json:"seed"`
	// awszString (variable): Storage for pwszDiffUser and pwszPin.
	String []uint16 `idl:"name:awszString" json:"string"`
}

func (o *EAPTLSUserProperties) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *EAPTLSUserProperties) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	// reserved reserved
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	if err := w.WriteData(o.Version); err != nil {
		return err
	}
	if err := w.WriteData(o.Size); err != nil {
		return err
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	if o.Hash != nil {
		if err := o.Hash.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&EAPTLSHash{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.DiffUser != "" {
		_ptr_pwszDiffUser := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16String(ctx, w, o.DiffUser); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.DiffUser, _ptr_pwszDiffUser); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.PINOffset); err != nil {
		return err
	}
	if o.PIN != "" {
		_ptr_pwszPin := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16String(ctx, w, o.PIN); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.PIN, _ptr_pwszPin); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Length); err != nil {
		return err
	}
	if err := w.WriteData(o.MaximumLength); err != nil {
		return err
	}
	if err := w.WriteData(o.Seed); err != nil {
		return err
	}
	for i1 := range o.String {
		i1 := i1
		if uint64(i1) >= 1 {
			break
		}
		if err := w.WriteData(o.String[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.String); uint64(i1) < 1; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	if err := w.WriteTrailingGap(9); err != nil {
		return err
	}
	return nil
}
func (o *EAPTLSUserProperties) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	// reserved reserved
	var _reserved uint32
	if err := w.ReadData(&_reserved); err != nil {
		return err
	}
	if err := w.ReadData(&o.Version); err != nil {
		return err
	}
	if err := w.ReadData(&o.Size); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	if o.Hash == nil {
		o.Hash = &EAPTLSHash{}
	}
	if err := o.Hash.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_pwszDiffUser := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16String(ctx, w, &o.DiffUser); err != nil {
			return err
		}
		return nil
	})
	_s_pwszDiffUser := func(ptr interface{}) { o.DiffUser = *ptr.(*string) }
	if err := w.ReadPointer(&o.DiffUser, _s_pwszDiffUser, _ptr_pwszDiffUser); err != nil {
		return err
	}
	if err := w.ReadData(&o.PINOffset); err != nil {
		return err
	}
	_ptr_pwszPin := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16String(ctx, w, &o.PIN); err != nil {
			return err
		}
		return nil
	})
	_s_pwszPin := func(ptr interface{}) { o.PIN = *ptr.(*string) }
	if err := w.ReadPointer(&o.PIN, _s_pwszPin, _ptr_pwszPin); err != nil {
		return err
	}
	if err := w.ReadData(&o.Length); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaximumLength); err != nil {
		return err
	}
	if err := w.ReadData(&o.Seed); err != nil {
		return err
	}
	o.String = make([]uint16, 1)
	for i1 := range o.String {
		i1 := i1
		if err := w.ReadData(&o.String[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadTrailingGap(9); err != nil {
		return err
	}
	return nil
}

// IPBOOTPGlobalConfig structure represents IPBOOTP_GLOBAL_CONFIG RPC structure.
//
// The IPBOOTP_GLOBAL_CONFIG structure is used to set or retrieve global configuration
// for the IPBOOTP. This is used in the following methods:
//
// * *RRouterInterfaceTransportSetGlobalInfo (section 3.1.4.10)* ( 071439e7-a9fd-40e4-91f7-ab756108e82f
// )
//
// * *RRouterInterfaceTransportGetGlobalInfo (section 3.1.4.11)* ( 14ad8d26-d7d7-48dd-914d-da962d5d7049
// )
//
// typedef struct _IPBOOTP_GLOBAL_CONFIG {
//
// DWORD GC_LoggingLevel;
//
// DWORD GC_MaxRecvQueueSize;
//
// DWORD GC_ServerCount;
//
// } IPBOOTP_GLOBAL_CONFIG,
type IPBOOTPGlobalConfig struct {
	// GC_LoggingLevel: Specifies the logging level. It MUST be one of the following values.
	//
	//	+----------------------------------+-----------------------------------------------+
	//	|                                  |                                               |
	//	|              VALUE               |                    MEANING                    |
	//	|                                  |                                               |
	//	+----------------------------------+-----------------------------------------------+
	//	+----------------------------------+-----------------------------------------------+
	//	| IPBOOTP_GLOBAL_CONFIG 0x00000000 | No Logging is done.                           |
	//	+----------------------------------+-----------------------------------------------+
	//	| IPBOOTP_LOGGING_ERROR 0x00000001 | Only errors are logged.                       |
	//	+----------------------------------+-----------------------------------------------+
	//	| IPBOOTP_LOGGING_WARN 0x00000002  | Errors and warnings are logged.               |
	//	+----------------------------------+-----------------------------------------------+
	//	| IPBOOTP_LOGGING_INFO 0x00000003  | Errors, warnings, and information are logged. |
	//	+----------------------------------+-----------------------------------------------+
	LoggingLevel uint32 `idl:"name:GC_LoggingLevel" json:"logging_level"`
	// GC_MaxRecvQueueSize: Specifies the maximum size in bytes of messages in the receive
	// queue while processing.
	MaxRecvQueueSize uint32 `idl:"name:GC_MaxRecvQueueSize" json:"max_recv_queue_size"`
	// GC_ServerCount: The number of BOOTP server IP addresses.
	ServerCount uint32 `idl:"name:GC_ServerCount" json:"server_count"`
}

func (o *IPBOOTPGlobalConfig) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPBOOTPGlobalConfig) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.LoggingLevel); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxRecvQueueSize); err != nil {
		return err
	}
	if err := w.WriteData(o.ServerCount); err != nil {
		return err
	}
	return nil
}
func (o *IPBOOTPGlobalConfig) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.LoggingLevel); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxRecvQueueSize); err != nil {
		return err
	}
	if err := w.ReadData(&o.ServerCount); err != nil {
		return err
	}
	return nil
}

// IPBOOTPInterfaceConfig structure represents IPBOOTP_IF_CONFIG RPC structure.
//
// The IPBOOTP_IF_CONFIG structure is used to set or retrieve the per-interface configuration.
// This is used in the following methods:
//
// * *RRouterInterfaceTransportAdd (section 3.1.4.18)* ( 927c5bf1-ac91-4325-b945-0d96a58f609b
// )
//
// * *RRouterInterfaceTransportGetInfo (section 3.1.4.19)* ( ec9ba293-45e9-4f12-b9af-7e77ec96c90e
// )
//
// * *RRouterInterfaceTransportSetInfo (section 3.1.4.20)* ( 209ba5e7-876e-4406-a05c-65b7e5fb2380
// )
//
// All IP address are in network order.
type IPBOOTPInterfaceConfig struct {
	// IC_State: Contains the status of the IPBOOTP. This member is read only.
	//
	//	+----------------------------------+-----------------------------------------------------------------------+
	//	|                                  |                                                                       |
	//	|              VALUE               |                                MEANING                                |
	//	|                                  |                                                                       |
	//	+----------------------------------+-----------------------------------------------------------------------+
	//	+----------------------------------+-----------------------------------------------------------------------+
	//	| IPBOOTP_STATE_ENABLED 0x00000001 | The interface is enabled.                                             |
	//	+----------------------------------+-----------------------------------------------------------------------+
	//	| IPBOOTP_STATE_BOUND 0x00000002   | The socket is bound and can listen to the IP BOOTP packets [RFC1542]. |
	//	+----------------------------------+-----------------------------------------------------------------------+
	State uint32 `idl:"name:IC_State" json:"state"`
	// IC_RelayMode: Contains the IPBOOTP relay mode status. It MUST be one of the following
	// values.
	//
	//	+-----------------------------------+------------------------------+
	//	|                                   |                              |
	//	|               VALUE               |           MEANING            |
	//	|                                   |                              |
	//	+-----------------------------------+------------------------------+
	//	+-----------------------------------+------------------------------+
	//	| IPBOOTP_RELAY_DISABLED 0x00000000 | The relay is configured.     |
	//	+-----------------------------------+------------------------------+
	//	| IPBOOTP_RELAY_ENABLED 0x00000001  | The relay is not configured. |
	//	+-----------------------------------+------------------------------+
	RelayMode uint32 `idl:"name:IC_RelayMode" json:"relay_mode"`
	// IC_MaxHopCount: The maximum number of DHCP relay agents that will handle the DHCP
	// relayed traffic. It MUST be less than 17.
	MaxHopCount uint32 `idl:"name:IC_MaxHopCount" json:"max_hop_count"`
	// IC_MinSecondsSinceBoot: The number of seconds the relay agent waits before forwarding
	// the DHCP messages; no validation is done while setting this value.
	MinSecondsSinceBoot uint32 `idl:"name:IC_MinSecondsSinceBoot" json:"min_seconds_since_boot"`
}

func (o *IPBOOTPInterfaceConfig) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPBOOTPInterfaceConfig) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.State); err != nil {
		return err
	}
	if err := w.WriteData(o.RelayMode); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxHopCount); err != nil {
		return err
	}
	if err := w.WriteData(o.MinSecondsSinceBoot); err != nil {
		return err
	}
	return nil
}
func (o *IPBOOTPInterfaceConfig) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.State); err != nil {
		return err
	}
	if err := w.ReadData(&o.RelayMode); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxHopCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.MinSecondsSinceBoot); err != nil {
		return err
	}
	return nil
}

// IPBOOTPMIBGetInputData structure represents IPBOOTP_MIB_GET_INPUT_DATA RPC structure.
//
// The IPBOOTP_MIB_GET_INPUT_DATA structure is passed as input data for the following
// methods:
//
// * *RMIBEntryGet (section 3.1.4.30)* ( ebc5c709-36d8-4520-a0ac-6f36d2d6c0b2 )
//
// * *RMIBEntryGetFirst (section 3.1.4.31)* ( 9102e585-2f62-4408-bfb6-02a6460cc883 )
//
// * *RMIBEntryGetNext (section 3.1.4.32)* ( 50f78033-d248-4272-b4b9-a2519a0f304d )
//
// typedef struct _IPBOOTP_MIB_GET_INPUT_DATA {
//
// DWORD IMGID_TypeID;
//
// DWORD IMGID_IfIndex;
//
// } IPBOOTP_MIB_GET_INPUT_DATA,
type IPBOOTPMIBGetInputData struct {
	// IMGID_TypeID: This MUST be one of the following values.
	//
	//	+-------------------------------------+----------------------------------------------------+
	//	|                                     |                                                    |
	//	|                VALUE                |                      MEANING                       |
	//	|                                     |                                                    |
	//	+-------------------------------------+----------------------------------------------------+
	//	+-------------------------------------+----------------------------------------------------+
	//	| IPBOOTP_GLOBAL_CONFIG_ID 0x00000000 | The global configuration for the IPBOOTP.          |
	//	+-------------------------------------+----------------------------------------------------+
	//	| IPBOOTP_IF_STATS_ID 0x00000001      | The per-interface statistics.                      |
	//	+-------------------------------------+----------------------------------------------------+
	//	| IPBOOTP_IF_CONFIG_ID 0x00000002     | The per-interface configuration.                   |
	//	+-------------------------------------+----------------------------------------------------+
	//	| IPBOOTP_IF_BINDING_ID 0x00000003    | The IP addresses to which each interface is bound. |
	//	+-------------------------------------+----------------------------------------------------+
	TypeID uint32 `idl:"name:IMGID_TypeID" json:"type_id"`
	// IMGID_IfIndex: The index of the interface.
	InterfaceIndex uint32 `idl:"name:IMGID_IfIndex" json:"interface_index"`
}

func (o *IPBOOTPMIBGetInputData) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPBOOTPMIBGetInputData) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.TypeID); err != nil {
		return err
	}
	if err := w.WriteData(o.InterfaceIndex); err != nil {
		return err
	}
	return nil
}
func (o *IPBOOTPMIBGetInputData) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.TypeID); err != nil {
		return err
	}
	if err := w.ReadData(&o.InterfaceIndex); err != nil {
		return err
	}
	return nil
}

// IPBOOTPMIBGetOutputData structure represents IPBOOTP_MIB_GET_OUTPUT_DATA RPC structure.
//
// The IPBOOTP_MIB_GET_OUTPUT_DATA structure is passed as output data for the following
// methods:
//
// * *RMIBEntryGet (section 3.1.4.30)* ( ebc5c709-36d8-4520-a0ac-6f36d2d6c0b2 )
//
// * *RMIBEntryGetFirst (section 3.2.4.31)* ( 340672df-1018-44a6-b1b8-509348062857 )
//
// * *RMIBEntryGetNext (section 3.2.4.32)* ( 12830348-d502-4b45-adc3-e5853d42d0c9 )
//
// Note  At the end of a table RMIBEntryGetNext wraps to the next table.
type IPBOOTPMIBGetOutputData struct {
	// IMGOD_TypeID: It MUST be one of the following values.
	//
	//	+-------------------------------------+------------------------------------------------------------------------+
	//	|                                     |                                                                        |
	//	|                VALUE                |                                MEANING                                 |
	//	|                                     |                                                                        |
	//	+-------------------------------------+------------------------------------------------------------------------+
	//	+-------------------------------------+------------------------------------------------------------------------+
	//	| IPBOOTP_GLOBAL_CONFIG_ID 0x00000000 | The global configuration for the IPBOOTP, IPBOOTP_GLOBAL_CONFIG.       |
	//	+-------------------------------------+------------------------------------------------------------------------+
	//	| IPBOOTP_IF_STATS_ID 0x00000001      | The per interface statistics, IPBOOTP_IF_STATS.                        |
	//	+-------------------------------------+------------------------------------------------------------------------+
	//	| IPBOOTP_IF_CONFIG_ID 0x00000002     | The IPBOOTP_IF_CONFIG Identifier.                                      |
	//	+-------------------------------------+------------------------------------------------------------------------+
	//	| IPBOOTP_IF_BINDING_ID 0x00000003    | The IP addresses to which each interface is bound, IPBOOTP_IF_BINDING. |
	//	+-------------------------------------+------------------------------------------------------------------------+
	TypeID uint32 `idl:"name:IMGOD_TypeID" json:"type_id"`
	// IMGOD_IfIndex: The index of the interface.
	InterfaceIndex uint32 `idl:"name:IMGOD_IfIndex" json:"interface_index"`
	// IMGOD_Buffer: One of the structures in the previous table based on IMGOD_TypeID.
	Buffer []byte `idl:"name:IMGOD_Buffer" json:"buffer"`
}

func (o *IPBOOTPMIBGetOutputData) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPBOOTPMIBGetOutputData) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.TypeID); err != nil {
		return err
	}
	if err := w.WriteData(o.InterfaceIndex); err != nil {
		return err
	}
	for i1 := range o.Buffer {
		i1 := i1
		if uint64(i1) >= 1 {
			break
		}
		if err := w.WriteData(o.Buffer[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Buffer); uint64(i1) < 1; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteTrailingGap(4); err != nil {
		return err
	}
	return nil
}
func (o *IPBOOTPMIBGetOutputData) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.TypeID); err != nil {
		return err
	}
	if err := w.ReadData(&o.InterfaceIndex); err != nil {
		return err
	}
	o.Buffer = make([]byte, 1)
	for i1 := range o.Buffer {
		i1 := i1
		if err := w.ReadData(&o.Buffer[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadTrailingGap(4); err != nil {
		return err
	}
	return nil
}

// IPBOOTPInterfaceStats structure represents IPBOOTP_IF_STATS RPC structure.
//
// The IPBOOTP_IF_STATS structure is an MIB entry, stores per interface statistics for
// the IPBOOTP. All of the IP addresses are in network order. This structure is read-only.
type IPBOOTPInterfaceStats struct {
	// IS_State: Contains status of the IPBOOTP. This member is read-only.
	//
	//	+----------------------------------+----------------------------------------------------------------------+
	//	|                                  |                                                                      |
	//	|              VALUE               |                               MEANING                                |
	//	|                                  |                                                                      |
	//	+----------------------------------+----------------------------------------------------------------------+
	//	+----------------------------------+----------------------------------------------------------------------+
	//	| IPBOOTP_STATE_ENABLED 0x00000001 | The interface is enabled.                                            |
	//	+----------------------------------+----------------------------------------------------------------------+
	//	| IPBOOTP_STATE_BOUND 0x00000002   | The socket is bound and can listen to the IPBOOTP packets [RFC1542]. |
	//	+----------------------------------+----------------------------------------------------------------------+
	State uint32 `idl:"name:IS_State" json:"state"`
	// IS_SendFailures: The number of relay messages that could not be sent.
	SendFailures uint32 `idl:"name:IS_SendFailures" json:"send_failures"`
	// IS_ReceiveFailures: The number of times errors were encountered in receiving relay
	// messages.
	ReceiveFailures uint32 `idl:"name:IS_ReceiveFailures" json:"receive_failures"`
	// IS_ArpUpdateFailures: The number of times errors were encountered while updating
	// the ARP cache.
	ArpUpdateFailures uint32 `idl:"name:IS_ArpUpdateFailures" json:"arp_update_failures"`
	// IS_RequestsReceived: The number of IP BOOTP requests received.
	RequestsReceived uint32 `idl:"name:IS_RequestsReceived" json:"requests_received"`
	// IS_RequestsDiscarded: The number of IP BOOTP requests discarded.
	RequestsDiscarded uint32 `idl:"name:IS_RequestsDiscarded" json:"requests_discarded"`
	// IS_RepliesReceived: The number of IP BOOTP replies received.
	RepliesReceived uint32 `idl:"name:IS_RepliesReceived" json:"replies_received"`
	// IS_RepliesDiscarded: The number of IP BOOTP replies discarded.
	RepliesDiscarded uint32 `idl:"name:IS_RepliesDiscarded" json:"replies_discarded"`
}

func (o *IPBOOTPInterfaceStats) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPBOOTPInterfaceStats) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.State); err != nil {
		return err
	}
	if err := w.WriteData(o.SendFailures); err != nil {
		return err
	}
	if err := w.WriteData(o.ReceiveFailures); err != nil {
		return err
	}
	if err := w.WriteData(o.ArpUpdateFailures); err != nil {
		return err
	}
	if err := w.WriteData(o.RequestsReceived); err != nil {
		return err
	}
	if err := w.WriteData(o.RequestsDiscarded); err != nil {
		return err
	}
	if err := w.WriteData(o.RepliesReceived); err != nil {
		return err
	}
	if err := w.WriteData(o.RepliesDiscarded); err != nil {
		return err
	}
	return nil
}
func (o *IPBOOTPInterfaceStats) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.State); err != nil {
		return err
	}
	if err := w.ReadData(&o.SendFailures); err != nil {
		return err
	}
	if err := w.ReadData(&o.ReceiveFailures); err != nil {
		return err
	}
	if err := w.ReadData(&o.ArpUpdateFailures); err != nil {
		return err
	}
	if err := w.ReadData(&o.RequestsReceived); err != nil {
		return err
	}
	if err := w.ReadData(&o.RequestsDiscarded); err != nil {
		return err
	}
	if err := w.ReadData(&o.RepliesReceived); err != nil {
		return err
	}
	if err := w.ReadData(&o.RepliesDiscarded); err != nil {
		return err
	}
	return nil
}

// IPBOOTPInterfaceBinding structure represents IPBOOTP_IF_BINDING RPC structure.
//
// In the IPBOOTP_IF_BINDING structure, the MIB entry contains the table of IP addresses
// to which each interface is bound. All of the IP addresses are in network order. The
// base structure contains the field IB_AddrCount, which gives the number of IP addresses
// to which the indexed interface is bound. The IP addresses themselves follow the base
// structure and are given as IPBOOTP_IP_ADDRESS (section 2.2.1.2.155) structures.
type IPBOOTPInterfaceBinding struct {
	// IB_State: The state of the IPBOOTP. It MUST be one of the following values.
	//
	//	+----------------------------------+-----------------------------------------------------------------------+
	//	|                                  |                                                                       |
	//	|              VALUE               |                                MEANING                                |
	//	|                                  |                                                                       |
	//	+----------------------------------+-----------------------------------------------------------------------+
	//	+----------------------------------+-----------------------------------------------------------------------+
	//	| IPBOOTP_STATE_ENABLED 0x00000001 | The interface is enabled.                                             |
	//	+----------------------------------+-----------------------------------------------------------------------+
	//	| IPBOOTP_STATE_BOUND 0x00000002   | The socket is bound and can listen to the IP BOOTP packets [RFC1542]. |
	//	+----------------------------------+-----------------------------------------------------------------------+
	State uint32 `idl:"name:IB_State" json:"state"`
	// IB_AddrCount: The number of IP addresses to which the indexed interface is bound.
	AddrCount uint32 `idl:"name:IB_AddrCount" json:"addr_count"`
}

func (o *IPBOOTPInterfaceBinding) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPBOOTPInterfaceBinding) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.State); err != nil {
		return err
	}
	if err := w.WriteData(o.AddrCount); err != nil {
		return err
	}
	return nil
}
func (o *IPBOOTPInterfaceBinding) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.State); err != nil {
		return err
	}
	if err := w.ReadData(&o.AddrCount); err != nil {
		return err
	}
	return nil
}

// IPBOOTPIPAddress structure represents IPBOOTP_IP_ADDRESS RPC structure.
//
// The IPBOOTP_IP_ADDRESS structure is used for storing interface bindings. A series
// of structures of this type follows the IPBOOTP_IF_BINDING structure. Both fields
// are IP address fields in network order.
type IPBOOTPIPAddress struct {
	// IA_Address: The IP address in network byte order.
	Address uint32 `idl:"name:IA_Address" json:"address"`
	// IA_Netmask: The network mask in network byte order. See [RFC950].
	Netmask uint32 `idl:"name:IA_Netmask" json:"netmask"`
}

func (o *IPBOOTPIPAddress) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPBOOTPIPAddress) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Address); err != nil {
		return err
	}
	if err := w.WriteData(o.Netmask); err != nil {
		return err
	}
	return nil
}
func (o *IPBOOTPIPAddress) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Address); err != nil {
		return err
	}
	if err := w.ReadData(&o.Netmask); err != nil {
		return err
	}
	return nil
}

// DHCPV6RMIBGetOutputData structure represents DHCPV6R_MIB_GET_OUTPUT_DATA RPC structure.
//
// The DHCPV6R_MIB_GET_OUTPUT_DATA structure is passed as output data for the following
// methods:
//
// * *RMIBEntryGet (section 3.1.4.30)* ( ebc5c709-36d8-4520-a0ac-6f36d2d6c0b2 )
//
// * *RMIBEntryGetFirst (section 3.1.4.31)* ( 9102e585-2f62-4408-bfb6-02a6460cc883 )
//
// * *RMIBEntryGetNext (section 3.1.4.32)* ( 50f78033-d248-4272-b4b9-a2519a0f304d )
//
// typedef struct _DHCPV6R_MIB_GET_OUTPUT_DATA {
//
// DWORD IMGOD_TypeID;
//
// DWORD IMGOD_IfIndex;
//
// BYTE IMGOD_Buffer[1];
//
// } DHCPV6R_MIB_GET_OUTPUT_DATA,
type DHCPV6RMIBGetOutputData struct {
	// IMGOD_TypeID: It MUST be the following value.
	//
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	|                                |                                                                                  |
	//	|             VALUE              |                                     MEANING                                      |
	//	|                                |                                                                                  |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	| DHCPV6R_IF_STATS_ID 0x00000001 | The interface statistics data, DHCPV6R_IF_STATS (section 2.2.1.2.158), is        |
	//	|                                | specified in the location that starts with IMGOD_Buffer.                         |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	TypeID uint32 `idl:"name:IMGOD_TypeID" json:"type_id"`
	// IMGOD_IfIndex: The index of the interface.
	InterfaceIndex uint32 `idl:"name:IMGOD_IfIndex" json:"interface_index"`
	// IMGOD_Buffer: This specifies the output data corresponding to the type specified
	// by IMGOD_TypeID.
	Buffer []byte `idl:"name:IMGOD_Buffer" json:"buffer"`
}

func (o *DHCPV6RMIBGetOutputData) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *DHCPV6RMIBGetOutputData) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.TypeID); err != nil {
		return err
	}
	if err := w.WriteData(o.InterfaceIndex); err != nil {
		return err
	}
	for i1 := range o.Buffer {
		i1 := i1
		if uint64(i1) >= 1 {
			break
		}
		if err := w.WriteData(o.Buffer[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Buffer); uint64(i1) < 1; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteTrailingGap(4); err != nil {
		return err
	}
	return nil
}
func (o *DHCPV6RMIBGetOutputData) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.TypeID); err != nil {
		return err
	}
	if err := w.ReadData(&o.InterfaceIndex); err != nil {
		return err
	}
	o.Buffer = make([]byte, 1)
	for i1 := range o.Buffer {
		i1 := i1
		if err := w.ReadData(&o.Buffer[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadTrailingGap(4); err != nil {
		return err
	}
	return nil
}

// DHCPV6RInterfaceStats structure represents DHCPV6R_IF_STATS RPC structure.
//
// The DHCPV6R_IF_STATS structure stores per interface statistics for the DHCPv6 relay
// agent. This structure is read-only. This structure is part of the DHCPV6R_MIB_GET_OUTPUT_DATA
// (section 2.2.1.2.156) structure.
type DHCPV6RInterfaceStats struct {
	// IS_State: Contains the status of the DHCPv6 relay agent. This member is read-only
	// and MUST be a combination of one or more of the following values.
	//
	//	+----------------------------------+---------------------------------------------------------------------------------+
	//	|                                  |                                                                                 |
	//	|              VALUE               |                                     MEANING                                     |
	//	|                                  |                                                                                 |
	//	+----------------------------------+---------------------------------------------------------------------------------+
	//	+----------------------------------+---------------------------------------------------------------------------------+
	//	| DHCPV6R_STATE_ENABLED 0x00000001 | The interface is enabled.                                                       |
	//	+----------------------------------+---------------------------------------------------------------------------------+
	//	| DHCPV6R_STATE_BOUND 0x00000002   | The socket is bound and can listen to the DHCPv6 relay agent packets [RFC3315]. |
	//	+----------------------------------+---------------------------------------------------------------------------------+
	State uint32 `idl:"name:IS_State" json:"state"`
	// IS_SendFailures: The number of relay messages that could not be sent.
	SendFailures uint32 `idl:"name:IS_SendFailures" json:"send_failures"`
	// IS_ReceiveFailures: The number of times errors were encountered while receiving relay
	// messages.
	ReceiveFailures uint32 `idl:"name:IS_ReceiveFailures" json:"receive_failures"`
	// IS_RequestsReceived: The number of DHCPV6 relay requests received.
	RequestsReceived uint32 `idl:"name:IS_RequestsReceived" json:"requests_received"`
	// IS_RequestsDiscarded: The number of DHCPV6 relay requests discarded.
	RequestsDiscarded uint32 `idl:"name:IS_RequestsDiscarded" json:"requests_discarded"`
	// IS_RepliesReceived: The number of DHCPV6 relay replies received.
	RepliesReceived uint32 `idl:"name:IS_RepliesReceived" json:"replies_received"`
	// IS_RepliesDiscarded: The number of DHCPV6 relay replies discarded.
	RepliesDiscarded uint32 `idl:"name:IS_RepliesDiscarded" json:"replies_discarded"`
}

func (o *DHCPV6RInterfaceStats) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *DHCPV6RInterfaceStats) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.State); err != nil {
		return err
	}
	if err := w.WriteData(o.SendFailures); err != nil {
		return err
	}
	if err := w.WriteData(o.ReceiveFailures); err != nil {
		return err
	}
	if err := w.WriteData(o.RequestsReceived); err != nil {
		return err
	}
	if err := w.WriteData(o.RequestsDiscarded); err != nil {
		return err
	}
	if err := w.WriteData(o.RepliesReceived); err != nil {
		return err
	}
	if err := w.WriteData(o.RepliesDiscarded); err != nil {
		return err
	}
	return nil
}
func (o *DHCPV6RInterfaceStats) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.State); err != nil {
		return err
	}
	if err := w.ReadData(&o.SendFailures); err != nil {
		return err
	}
	if err := w.ReadData(&o.ReceiveFailures); err != nil {
		return err
	}
	if err := w.ReadData(&o.RequestsReceived); err != nil {
		return err
	}
	if err := w.ReadData(&o.RequestsDiscarded); err != nil {
		return err
	}
	if err := w.ReadData(&o.RepliesReceived); err != nil {
		return err
	}
	if err := w.ReadData(&o.RepliesDiscarded); err != nil {
		return err
	}
	return nil
}

// DHCPV6RMIBGetInputData structure represents DHCPV6R_MIB_GET_INPUT_DATA RPC structure.
//
// The DHCPV6R_MIB_GET_INPUT_DATA structure is passed as input for the following methods:
//
// * *RMIBEntryGet (section 3.1.4.30)* ( ebc5c709-36d8-4520-a0ac-6f36d2d6c0b2 )
//
// * *RMIBEntryGetFirst (section 3.1.4.31)* ( 9102e585-2f62-4408-bfb6-02a6460cc883 )
//
// * *RMIBEntryGetNext (section 3.1.4.32)* ( 50f78033-d248-4272-b4b9-a2519a0f304d )
//
// typedef struct _DHCPV6R_MIB_GET_INPUT_DATA {
//
// DWORD IMGID_TypeID;
//
// DWORD IMGID_IfIndex;
//
// } DHCPV6R_MIB_GET_INPUT_DATA,
type DHCPV6RMIBGetInputData struct {
	// IMGID_TypeID: This MUST be one of the following values.
	//
	//	+--------------------------------+---------------------------+
	//	|                                |                           |
	//	|             VALUE              |          MEANING          |
	//	|                                |                           |
	//	+--------------------------------+---------------------------+
	//	+--------------------------------+---------------------------+
	//	| DHCPV6R_IF_STATS_ID 0x00000001 | Interface statistics data |
	//	+--------------------------------+---------------------------+
	TypeID uint32 `idl:"name:IMGID_TypeID" json:"type_id"`
	// IMGID_IfIndex: The index of the interface for which Get has to be performed.
	InterfaceIndex uint32 `idl:"name:IMGID_IfIndex" json:"interface_index"`
}

func (o *DHCPV6RMIBGetInputData) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *DHCPV6RMIBGetInputData) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.TypeID); err != nil {
		return err
	}
	if err := w.WriteData(o.InterfaceIndex); err != nil {
		return err
	}
	return nil
}
func (o *DHCPV6RMIBGetInputData) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.TypeID); err != nil {
		return err
	}
	if err := w.ReadData(&o.InterfaceIndex); err != nil {
		return err
	}
	return nil
}

// DHCPV6RGlobalConfig structure represents DHCPV6R_GLOBAL_CONFIG RPC structure.
//
// The DHCPV6R_GLOBAL_CONFIG structure contains the global configuration of the DHCPV6
// Relay Agent. This structure is used in the following methods:
//
// * *RRouterInterfaceTransportSetGlobalInfo (section 3.1.4.10)* ( 071439e7-a9fd-40e4-91f7-ab756108e82f
// )
//
// * *RRouterInterfaceTransportGetGlobalInfo (section 3.1.4.11)* ( 14ad8d26-d7d7-48dd-914d-da962d5d7049
// )
//
// This structure is variable length, after the base structure there will be an array
// of GC_ServerCount in6_addr structures, each of which contains an IPv6 address of
// a DHCP server to which packets will be sent. All IPv6 address fields MUST be in network
// order.
type DHCPV6RGlobalConfig struct {
	// GC_LoggingLevel: Specifies the logging level. It MUST be one of the following values.
	//
	//	+----------------------------------+-----------------------------------------------+
	//	|                                  |                                               |
	//	|              VALUE               |                    MEANING                    |
	//	|                                  |                                               |
	//	+----------------------------------+-----------------------------------------------+
	//	+----------------------------------+-----------------------------------------------+
	//	| DHCPV6R_LOGGING_NONE 0x00000000  | No logging is done.                           |
	//	+----------------------------------+-----------------------------------------------+
	//	| DHCPV6R_LOGGING_ERROR 0x00000001 | Only errors are logged.                       |
	//	+----------------------------------+-----------------------------------------------+
	//	| DHCPV6R_LOGGING_WARN 0x00000002  | Errors and warnings are logged.               |
	//	+----------------------------------+-----------------------------------------------+
	//	| DHCPV6R_LOGGING_INFO 0x00000003  | Errors, warnings, and information are logged. |
	//	+----------------------------------+-----------------------------------------------+
	LoggingLevel uint32 `idl:"name:GC_LoggingLevel" json:"logging_level"`
	// GC_MaxRecvQueueSize: Specifies the maximum size in bytes of messages in the receive
	// queue while processing
	MaxRecvQueueSize uint32 `idl:"name:GC_MaxRecvQueueSize" json:"max_recv_queue_size"`
	// GC_ServerCount: The number of the IPv6 addresses of DHCP servers.
	ServerCount uint32 `idl:"name:GC_ServerCount" json:"server_count"`
}

func (o *DHCPV6RGlobalConfig) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *DHCPV6RGlobalConfig) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.LoggingLevel); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxRecvQueueSize); err != nil {
		return err
	}
	if err := w.WriteData(o.ServerCount); err != nil {
		return err
	}
	return nil
}
func (o *DHCPV6RGlobalConfig) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.LoggingLevel); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxRecvQueueSize); err != nil {
		return err
	}
	if err := w.ReadData(&o.ServerCount); err != nil {
		return err
	}
	return nil
}

// DHCPV6RInterfaceConfig structure represents DHCPV6R_IF_CONFIG RPC structure.
//
// The DHCPV6R_IF_CONFIG structure is an MIB entry and describes the per-interface configuration.
// This structure is used in DHCPV6R_MIB_GET_INPUT_DATA (section 2.2.1.2.160) and DHCPV6R_MIB_GET_OUTPUT_DATA
// (section 2.2.1.2.156) structures.
type DHCPV6RInterfaceConfig struct {
	// IC_State: Contains the status of the DHCPV6 relay. This member is read-only and MUST
	// be a combination of one or more of the following values.
	//
	//	+----------------------------------+---------------------------------------------------------------------------------+
	//	|                                  |                                                                                 |
	//	|              VALUE               |                                     MEANING                                     |
	//	|                                  |                                                                                 |
	//	+----------------------------------+---------------------------------------------------------------------------------+
	//	+----------------------------------+---------------------------------------------------------------------------------+
	//	| DHCPV6R_STATE_ENABLED 0x00000001 | The interface is enabled                                                        |
	//	+----------------------------------+---------------------------------------------------------------------------------+
	//	| DHCPV6R_STATE_BOUND 0x00000002   | The socket is bound and can listen to the DHCPv6 relay agent packets [RFC3315]. |
	//	+----------------------------------+---------------------------------------------------------------------------------+
	State uint32 `idl:"name:IC_State" json:"state"`
	// IC_RelayMode: Contains the DHCPV6 relay mode status. It MUST be one of the following
	// values.
	//
	//	+-----------------------------------+------------------------------+
	//	|                                   |                              |
	//	|               VALUE               |           MEANING            |
	//	|                                   |                              |
	//	+-----------------------------------+------------------------------+
	//	+-----------------------------------+------------------------------+
	//	| DHCPV6R_RELAY_DISABLED 0x00000000 | The relay is configured.     |
	//	+-----------------------------------+------------------------------+
	//	| DHCPV6R_RELAY_ENABLED 0x00000001  | The relay is not configured. |
	//	+-----------------------------------+------------------------------+
	RelayMode uint32 `idl:"name:IC_RelayMode" json:"relay_mode"`
	// IC_MaxHopCount: The maximum number of DHCPv6 relay agents that will handle the DHCPv6
	// relayed traffic. It MUST be less than 33.
	MaxHopCount uint32 `idl:"name:IC_MaxHopCount" json:"max_hop_count"`
	// IC_MinElapsedTime: The number of seconds the relay agent waits before forwarding
	// the DHCPv6 messages.
	MinElapsedTime uint32 `idl:"name:IC_MinElapsedTime" json:"min_elapsed_time"`
}

func (o *DHCPV6RInterfaceConfig) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *DHCPV6RInterfaceConfig) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.State); err != nil {
		return err
	}
	if err := w.WriteData(o.RelayMode); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxHopCount); err != nil {
		return err
	}
	if err := w.WriteData(o.MinElapsedTime); err != nil {
		return err
	}
	return nil
}
func (o *DHCPV6RInterfaceConfig) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.State); err != nil {
		return err
	}
	if err := w.ReadData(&o.RelayMode); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxHopCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.MinElapsedTime); err != nil {
		return err
	}
	return nil
}

// IPRIPMIBGetInputData structure represents IPRIP_MIB_GET_INPUT_DATA RPC structure.
//
// The IPRIP_MIB_GET_INPUT_DATA structure is passed as input data for the following
// methods:
//
// * *RMIBEntryGet (section 3.1.4.30)* ( ebc5c709-36d8-4520-a0ac-6f36d2d6c0b2 )
//
// * *RMIBEntryGetFirst (section 3.1.4.31)* ( 9102e585-2f62-4408-bfb6-02a6460cc883 )
//
// * *RMIBEntryGetNext (section 3.1.4.32)* ( 50f78033-d248-4272-b4b9-a2519a0f304d )
//
// All the IP addresses MUST be in network order.
type IPRIPMIBGetInputData struct {
	// IMGID_TypeID: This MUST be one of the following values.
	//
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	|                                   |                                                                                  |
	//	|               VALUE               |                                     MEANING                                      |
	//	|                                   |                                                                                  |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| IPRIP_GLOBAL_STATS_ID 0x00000000  | The global statistics for the Microsoft Internet Protocol Routing Information    |
	//	|                                   | Protocol (IPRIP).                                                                |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| IPRIP_GLOBAL_CONFIG_ID 0x00000001 | The global configuration for the IPRIP.                                          |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| IPRIP_IF_STATS_ID 0x00000002      | The per-interface statistics for the IPRIP.                                      |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| IPRIP_IF_CONFIG_ID 0x00000003     | The per-interface configuration.                                                 |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| IPRIP_IF_BINDING_ID 0x00000004    | The table of IP addresses to which each interface is bound.                      |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| IPRIP_PEER_STATS_ID 0x00000005    | The statistics kept about neighboring routers.                                   |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//
	// (unnamed union): The interface index or peer IP address for which data specified
	// by IMGID_TypeID needs to be retrieved.
	TypeID uint32                       `idl:"name:IMGID_TypeID" json:"type_id"`
	Field2 *IPRIPMIBGetInputData_Field2 `idl:"name:" json:""`
}

func (o *IPRIPMIBGetInputData) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPRIPMIBGetInputData) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.TypeID); err != nil {
		return err
	}
	// FIXME unknown type
	return nil
}
func (o *IPRIPMIBGetInputData) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.TypeID); err != nil {
		return err
	}
	// FIXME: unknown type
	return nil
}

type IPRIPMIBGetInputData_Field2 struct {
	InterfaceIndex uint32 `idl:"name:IMGID_IfIndex" json:"interface_index"`
	PeerAddress    uint32 `idl:"name:IMGID_PeerAddress" json:"peer_address"`
}

// IPRIPMIBGetOutputData structure represents IPRIP_MIB_GET_OUTPUT_DATA RPC structure.
//
// The IPRIP_MIB_GET_OUTPUT_DATA structure is populated by the following methods:
//
// * *RMIBEntryGet (section 3.1.4.30)* ( ebc5c709-36d8-4520-a0ac-6f36d2d6c0b2 )
//
// * *RMIBEntryGetFirst (section 3.1.4.31)* ( 9102e585-2f62-4408-bfb6-02a6460cc883 )
//
// * *RMIBEntryGetNext (section 3.1.4.32)* ( 50f78033-d248-4272-b4b9-a2519a0f304d )
//
// typedef struct _IPRIP_MIB_GET_OUTPUT_DATA {
//
// DWORD IMGOD_TypeID;
//
// union {
//
// DWORD IMGOD_IfIndex;
//
// DWORD IMGOD_PeerAddress;
//
// };
//
// BYTE IMGOD_Buffer[1];
//
// } IPRIP_MIB_GET_OUTPUT_DATA,
type IPRIPMIBGetOutputData struct {
	// IMGOD_TypeID: This MUST be one of the following values.
	//
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	|                                   |                                                                                  |
	//	|               VALUE               |                                     MEANING                                      |
	//	|                                   |                                                                                  |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| IPRIP_GLOBAL_STATS_ID 0x00000000  | The global statistics for the IP RIP, IPRIP_GLOBAL_STATS (section 2.2.1.2.163).  |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| IPRIP_GLOBAL_CONFIG_ID 0x00000001 | The global configuration for the IP RIP, IPRIP_GLOBAL_CONFIG (section            |
	//	|                                   | 2.2.1.2.164).                                                                    |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| IPRIP_IF_STATS_ID 0x00000002      | The per-interface statistics for the IP RIP, IPRIP_IF_STATS (section             |
	//	|                                   | 2.2.1.2.165).                                                                    |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| IPRIP_IF_CONFIG_ID 0x00000003     | The per-interface configuration, IPRIP_IF_CONFIG (section 2.2.1.2.166).          |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| IPRIP_IF_BINDING_ID 0x00000004    | The table of IP addresses to which each interface is bound, IPRIP_IF_BINDING     |
	//	|                                   | (section 2.2.1.2.168).                                                           |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| IPRIP_PEER_STATS_ID 0x00000005    | The statistics kept about neighboring routers, IPRIP_PEER_STATS (section         |
	//	|                                   | 2.2.1.2.170).                                                                    |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//
	// (unnamed union): The interface index or peer IP address for which data specified
	// by IMGOD_TypeID needs to be retrieved.
	TypeID uint32                        `idl:"name:IMGOD_TypeID" json:"type_id"`
	Field2 *IPRIPMIBGetOutputData_Field2 `idl:"name:" json:""`
	// IMGOD_Buffer: One of the structures in the previous table based on the IMGOD_TypeID.
	Buffer []byte `idl:"name:IMGOD_Buffer" json:"buffer"`
}

func (o *IPRIPMIBGetOutputData) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPRIPMIBGetOutputData) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.TypeID); err != nil {
		return err
	}
	// FIXME unknown type
	for i1 := range o.Buffer {
		i1 := i1
		if uint64(i1) >= 1 {
			break
		}
		if err := w.WriteData(o.Buffer[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Buffer); uint64(i1) < 1; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteTrailingGap(4); err != nil {
		return err
	}
	return nil
}
func (o *IPRIPMIBGetOutputData) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.TypeID); err != nil {
		return err
	}
	// FIXME: unknown type
	o.Buffer = make([]byte, 1)
	for i1 := range o.Buffer {
		i1 := i1
		if err := w.ReadData(&o.Buffer[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadTrailingGap(4); err != nil {
		return err
	}
	return nil
}

type IPRIPMIBGetOutputData_Field2 struct {
	InterfaceIndex uint32 `idl:"name:IMGOD_IfIndex" json:"interface_index"`
	PeerAddress    uint32 `idl:"name:IMGOD_PeerAddress" json:"peer_address"`
}

// IPRIPGlobalStats structure represents IPRIP_GLOBAL_STATS RPC structure.
//
// The IPRIP_GLOBAL_STATS structure contains global statistics for the IP RIP. There
// is only one instance, so this entry has no index. This structure is read-only. This
// structure is used in IPRIP_MIB_GET_INPUT_DATA (section 2.2.1.2.161) and IPRIP_MIB_GET_OUTPUT_DATA
// (section 2.2.1.2.162) structures.
type IPRIPGlobalStats struct {
	// GS_SystemRouteChanges: The number of global route changes due to the IPRIP.
	GsSystemRouteChanges uint32 `idl:"name:GS_SystemRouteChanges" json:"gs_system_route_changes"`
	// GS_TotalResponsesSent: The count of global RIP responses sent.
	GsTotalResponsesSent uint32 `idl:"name:GS_TotalResponsesSent" json:"gs_total_responses_sent"`
}

func (o *IPRIPGlobalStats) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPRIPGlobalStats) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.GsSystemRouteChanges); err != nil {
		return err
	}
	if err := w.WriteData(o.GsTotalResponsesSent); err != nil {
		return err
	}
	return nil
}
func (o *IPRIPGlobalStats) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.GsSystemRouteChanges); err != nil {
		return err
	}
	if err := w.ReadData(&o.GsTotalResponsesSent); err != nil {
		return err
	}
	return nil
}

// IPRIPGlobalConfig structure represents IPRIP_GLOBAL_CONFIG RPC structure.
//
// The IPRIP_GLOBAL_CONFIG structure contains global configuration for the IPRIP. This
// structure is used in structures IPRIP_MIB_GET_INPUT_DATA (section 2.2.1.2.161), IPRIP_MIB_GET_OUTPUT_DATA
// (section 2.2.1.2.162), and in the following methods:
//
// * *RRouterInterfaceTransportSetGlobalInfo* ( 071439e7-a9fd-40e4-91f7-ab756108e82f
// ) ( section 3.1.4.10 )
//
// * *RRouterInterfaceTransportGetGlobalInfo* ( 14ad8d26-d7d7-48dd-914d-da962d5d7049
// ) ( section 3.1.4.11 )
//
// There is only one instance of this entry in the MIB. Following it is an array of
// GC_PeerFilterCount DWORDs, each of which contains an IP address which is a peer which
// will be accepted or rejected depending on the value of GC_PeerFilterMode. If the
// GC_PeerFilterMode is set to IPRIP_FILTER_EXCLUDE, routes will be rejected which come
// from the routers whose addresses are in the peer array, and all other routers will
// be accepted.
//
// Likewise, if the GC_PeerFilterMode is set to IPRIP_FILTER_INCLUDE, routes will only
// be accepted if they are from the routers in the peer array.
type IPRIPGlobalConfig struct {
	// GC_LoggingLevel: Specifies the logging level. This MUST be one of the following values.
	//
	//	+--------------------------------+----------------------------------------------+
	//	|                                |                                              |
	//	|             VALUE              |                   MEANING                    |
	//	|                                |                                              |
	//	+--------------------------------+----------------------------------------------+
	//	+--------------------------------+----------------------------------------------+
	//	| IPRIP_LOGGING_NONE 0x00000000  | No logging is done.                          |
	//	+--------------------------------+----------------------------------------------+
	//	| IPRIP_LOGGING_ERROR 0x00000001 | Only errors are logged.                      |
	//	+--------------------------------+----------------------------------------------+
	//	| IPRIP_LOGGING_WARN 0x00000002  | Errors and warnings are logged.              |
	//	+--------------------------------+----------------------------------------------+
	//	| IPRIP_LOGGING_INFO 0x00000003  | Errors, warnings, and information is logged. |
	//	+--------------------------------+----------------------------------------------+
	LoggingLevel uint32 `idl:"name:GC_LoggingLevel" json:"logging_level"`
	// GC_MaxRecvQueueSize: The maximum queue size of outstanding RIP messages that need
	// to be processed.
	MaxRecvQueueSize uint32 `idl:"name:GC_MaxRecvQueueSize" json:"max_recv_queue_size"`
	// GC_MaxSendQueueSize: The maximum queue size for outstanding RIP messages that have
	// been sent out.
	MaxSendQueueSize uint32 `idl:"name:GC_MaxSendQueueSize" json:"max_send_queue_size"`
	// GC_MinTriggeredUpdateInterval: The minimum amount of time router waits before it
	// sends triggered updates.
	MinTriggeredUpdateInterval uint32 `idl:"name:GC_MinTriggeredUpdateInterval" json:"min_triggered_update_interval"`
	// GC_PeerFilterMode: Specifies whether route changes from all the IP addresses are
	// accepted. It MUST be one of the following values.
	//
	//	+----------------------------------+----------------------------------------------------------------------------------+
	//	|                                  |                                                                                  |
	//	|              VALUE               |                                     MEANING                                      |
	//	|                                  |                                                                                  |
	//	+----------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------+----------------------------------------------------------------------------------+
	//	| IPRIP_FILTER_DISABLED 0x00000000 | Updates from all the IP addresses are accepted.                                  |
	//	+----------------------------------+----------------------------------------------------------------------------------+
	//	| IPRIP_FILTER_INCLUDE 0x00000001  | Updates only from the IP addresses specified in this structure after             |
	//	|                                  | GC_PeerFilterCount are accepted.                                                 |
	//	+----------------------------------+----------------------------------------------------------------------------------+
	//	| IPRIP_FILTER_EXCLUDE 0x00000002  | Ignores updates from the IP addresses specified in this structure after          |
	//	|                                  | GC_PeerFilterCount.                                                              |
	//	+----------------------------------+----------------------------------------------------------------------------------+
	PeerFilterMode uint32 `idl:"name:GC_PeerFilterMode" json:"peer_filter_mode"`
	// GC_PeerFilterCount: The number of IP addresses in this structure after this field.
	PeerFilterCount uint32 `idl:"name:GC_PeerFilterCount" json:"peer_filter_count"`
}

func (o *IPRIPGlobalConfig) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPRIPGlobalConfig) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.LoggingLevel); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxRecvQueueSize); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxSendQueueSize); err != nil {
		return err
	}
	if err := w.WriteData(o.MinTriggeredUpdateInterval); err != nil {
		return err
	}
	if err := w.WriteData(o.PeerFilterMode); err != nil {
		return err
	}
	if err := w.WriteData(o.PeerFilterCount); err != nil {
		return err
	}
	return nil
}
func (o *IPRIPGlobalConfig) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.LoggingLevel); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxRecvQueueSize); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxSendQueueSize); err != nil {
		return err
	}
	if err := w.ReadData(&o.MinTriggeredUpdateInterval); err != nil {
		return err
	}
	if err := w.ReadData(&o.PeerFilterMode); err != nil {
		return err
	}
	if err := w.ReadData(&o.PeerFilterCount); err != nil {
		return err
	}
	return nil
}

// IPRIPInterfaceStats structure represents IPRIP_IF_STATS RPC structure.
//
// The IPRIP_IF_STATS structure contains per-interface statistics for the IPRIP. This
// structure is read-only. This structure is used in IPRIP_MIB_GET_INPUT_DATA (section
// 2.2.1.2.161) and IPRIP_MIB_GET_OUTPUT_DATA (section 2.2.1.2.162).
type IPRIPInterfaceStats struct {
	// IS_State: The IP RIP state on the interface. It MUST be a combination of one or more
	// of the following values.
	//
	//	+--------------------------------+----------------------+
	//	|                                |                      |
	//	|             VALUE              |       MEANING        |
	//	|                                |                      |
	//	+--------------------------------+----------------------+
	//	+--------------------------------+----------------------+
	//	| IPRIP_STATE_ENABLED 0x00000001 | IP RIP is enabled.   |
	//	+--------------------------------+----------------------+
	//	| IPRIP_STATE_BOUND 0x00000002   | The socket is bound. |
	//	+--------------------------------+----------------------+
	State uint32 `idl:"name:IS_State" json:"state"`
	// IS_SendFailures: The number of send failures on the interface.
	SendFailures uint32 `idl:"name:IS_SendFailures" json:"send_failures"`
	// IS_ReceiveFailures: The number of receive failures on the interface.
	ReceiveFailures uint32 `idl:"name:IS_ReceiveFailures" json:"receive_failures"`
	// IS_RequestsSent: The number of requests sent on the interface.
	RequestsSent uint32 `idl:"name:IS_RequestsSent" json:"requests_sent"`
	// IS_RequestsReceived: The number of requests received on the interface.
	RequestsReceived uint32 `idl:"name:IS_RequestsReceived" json:"requests_received"`
	// IS_ResponsesSent: The number of responses sent on the interface.
	ResponsesSent uint32 `idl:"name:IS_ResponsesSent" json:"responses_sent"`
	// IS_ResponsesReceived: The number of responses received on the interface.
	ResponsesReceived uint32 `idl:"name:IS_ResponsesReceived" json:"responses_received"`
	// IS_BadResponsePacketsReceived: The number of bad response packets received.
	BadResponsePacketsReceived uint32 `idl:"name:IS_BadResponsePacketsReceived" json:"bad_response_packets_received"`
	// IS_BadResponseEntriesReceived: The number of bad response entries received.
	BadResponseEntriesReceived uint32 `idl:"name:IS_BadResponseEntriesReceived" json:"bad_response_entries_received"`
	// IS_TriggeredUpdatesSent: The number of triggered updates sent.
	TriggeredUpdatesSent uint32 `idl:"name:IS_TriggeredUpdatesSent" json:"triggered_updates_sent"`
}

func (o *IPRIPInterfaceStats) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPRIPInterfaceStats) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.State); err != nil {
		return err
	}
	if err := w.WriteData(o.SendFailures); err != nil {
		return err
	}
	if err := w.WriteData(o.ReceiveFailures); err != nil {
		return err
	}
	if err := w.WriteData(o.RequestsSent); err != nil {
		return err
	}
	if err := w.WriteData(o.RequestsReceived); err != nil {
		return err
	}
	if err := w.WriteData(o.ResponsesSent); err != nil {
		return err
	}
	if err := w.WriteData(o.ResponsesReceived); err != nil {
		return err
	}
	if err := w.WriteData(o.BadResponsePacketsReceived); err != nil {
		return err
	}
	if err := w.WriteData(o.BadResponseEntriesReceived); err != nil {
		return err
	}
	if err := w.WriteData(o.TriggeredUpdatesSent); err != nil {
		return err
	}
	return nil
}
func (o *IPRIPInterfaceStats) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.State); err != nil {
		return err
	}
	if err := w.ReadData(&o.SendFailures); err != nil {
		return err
	}
	if err := w.ReadData(&o.ReceiveFailures); err != nil {
		return err
	}
	if err := w.ReadData(&o.RequestsSent); err != nil {
		return err
	}
	if err := w.ReadData(&o.RequestsReceived); err != nil {
		return err
	}
	if err := w.ReadData(&o.ResponsesSent); err != nil {
		return err
	}
	if err := w.ReadData(&o.ResponsesReceived); err != nil {
		return err
	}
	if err := w.ReadData(&o.BadResponsePacketsReceived); err != nil {
		return err
	}
	if err := w.ReadData(&o.BadResponseEntriesReceived); err != nil {
		return err
	}
	if err := w.ReadData(&o.TriggeredUpdatesSent); err != nil {
		return err
	}
	return nil
}

// IPRIPInterfaceConfig structure represents IPRIP_IF_CONFIG RPC structure.
//
// The IPRIP_IF_CONFIG structure contains the per-interface configuration. This structure
// is used in structures IPRIP_MIB_GET_INPUT_DATA (section 2.2.1.2.161), IPRIP_MIB_GET_OUTPUT_DATA
// (section 2.2.1.2.162), and in the following methods:
//
// * *RRouterInterfaceTransportAdd (section 3.1.4.18)* ( 927c5bf1-ac91-4325-b945-0d96a58f609b
// )
//
// * *RRouterInterfaceTransportGetInfo (section 3.2.4.19)* ( 2c0f9b0e-1f3e-4436-a534-cb30fe0f887f
// )
//
// * *RRouterInterfaceTransportSetInfo (section 3.1.4.20)* ( 209ba5e7-876e-4406-a05c-65b7e5fb2380
// )
//
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| IC_State                                                                                                                      |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| IC_Metric                                                                                                                     |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| IC_UpdateMode                                                                                                                 |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| IC_AcceptMode                                                                                                                 |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| IC_AnnounceMode                                                                                                               |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| IC_ProtocolFlags                                                                                                              |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| IC_RouteExpirationInterval                                                                                                    |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| IC_RouteRemovalInterval                                                                                                       |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| IC_FullUpdateInterval                                                                                                         |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| IC_AuthenticationType                                                                                                         |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| IC_AuthenticationKey (16 bytes)                                                                                               |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| IC_RouteTag                                                   | IC_Padding                                                    |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| IC_UnicastPeerMode                                                                                                            |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| IC_AcceptFilterMode                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| IC_AnnounceFilterMode                                                                                                         |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| IC_UnicastPeerCount                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| IC_AcceptFilterCount                                                                                                          |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| IC_AnnounceFilterCount                                                                                                        |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| IC_UnicastPeer (variable)                                                                                                     |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| IC_AcceptFilter (variable)                                                                                                    |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| IC_AnnounceFilter (variable)                                                                                                  |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
type IPRIPInterfaceConfig struct {
	// IC_State (4 bytes): Specifies the IP RIP state on the interface. This field MUST
	// be read-only and MUST be ignored if modified. It MUST be a combination of one or
	// more of the following values.
	//
	//	+--------------------------------+------------------------+
	//	|                                |                        |
	//	|             VALUE              |        MEANING         |
	//	|                                |                        |
	//	+--------------------------------+------------------------+
	//	+--------------------------------+------------------------+
	//	| IPRIP_STATE_ENABLED 0x00000001 | The IP RIP is enabled. |
	//	+--------------------------------+------------------------+
	//	| IPRIP_STATE_BOUND 0x00000002   | The socket is bound.   |
	//	+--------------------------------+------------------------+
	State uint32 `idl:"name:IC_State" json:"state"`
	// IC_Metric (4 bytes): Specifies the metric of the interface.
	Metric uint32 `idl:"name:IC_Metric" json:"metric"`
	// IC_UpdateMode (4 bytes): Specifies whether the update mode is periodic or on demand.
	//
	//	+----------------------------------+-----------------------------------------------------+
	//	|                                  |                                                     |
	//	|              VALUE               |                       MEANING                       |
	//	|                                  |                                                     |
	//	+----------------------------------+-----------------------------------------------------+
	//	+----------------------------------+-----------------------------------------------------+
	//	| IPRIP_UPDATE_PERIODIC 0x00000000 | The RIP updates are done periodically.              |
	//	+----------------------------------+-----------------------------------------------------+
	//	| IPRIP_UPDATE_DEMAND 0x00000001   | The RIP updates are done only when there is change. |
	//	+----------------------------------+-----------------------------------------------------+
	UpdateMode uint32 `idl:"name:IC_UpdateMode" json:"update_mode"`
	// IC_AcceptMode (4 bytes): Specifies the type of routes that are accepted.
	//
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	|                                     |                                                                                  |
	//	|                VALUE                |                                     MEANING                                      |
	//	|                                     |                                                                                  |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| IPRIP_ACCEPT_DISABLED 0x00000000    | Does not accept routes.                                                          |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| IPRIP_ACCEPT_RIP1 0x00000001        | Accepts RIPv1 routes.                                                            |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| IPRIP_ACCEPT_RIP1_COMPAT 0x00000002 | Accepts RIPv1 compatible routes (RIPv1 was designed to be compatible with future |
	//	|                                     | versions of the RIP. If a RIPv1 router receives a message and if the RIP version |
	//	|                                     | indicated in the RIP header is not 1, the RIPv1 router does not discard the RIP  |
	//	|                                     | announcement, but instead processes only the RIPv1 defined fields.)              |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| IPRIP_ACCEPT_RIP2 0x00000003        | Accepts RIPv2 routes. See [RFC1723].                                             |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	AcceptMode uint32 `idl:"name:IC_AcceptMode" json:"accept_mode"`
	// IC_AnnounceMode (4 bytes): Specifies the type of routes that are announced.
	//
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	|                                       |                                                                                  |
	//	|                 VALUE                 |                                     MEANING                                      |
	//	|                                       |                                                                                  |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| IPRIP_ANNOUNCE_DISABLED 0x00000000    | Does not announce routes.                                                        |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| IPRIP_ANNOUNCE_RIP1 0x00000001        | Announces RIPv1 routes.                                                          |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| IPRIP_ANNOUNCE_RIP1_COMPAT 0x00000002 | Accepts RIPv1 compatible routes. (RIPv1 was designed to be compatible with       |
	//	|                                       | future versions of the RIP. If a RIPv1 router receives a message and if the RIP  |
	//	|                                       | version indicated in the RIP header is not 1, the RIPv1 router does not discard  |
	//	|                                       | the RIP announcement, but instead processes only the RIPv1 defined fields.)      |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| IPRIP_ANNOUNCE_RIP2 0x00000003        | Announces RIPv2 routes. See [RFC1723].                                           |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	AnnounceMode uint32 `idl:"name:IC_AnnounceMode" json:"announce_mode"`
	// IC_ProtocolFlags (4 bytes): Specifies which routes are included or excluded from
	// RIP announcements.
	//
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                               |                                                                                  |
	//	|                     VALUE                     |                                     MEANING                                      |
	//	|                                               |                                                                                  |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| IPRIP_FLAG_ACCEPT_HOST_ROUTES 0x00000000      | Specifies whether host routes in received RIP announcements are accepted.        |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| IPRIP_FLAG_ANNOUNCE_HOST_ROUTES 0x00000002    | Specifies whether host routes are included in RIP announcements.                 |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| IPRIP_FLAG_ACCEPT_DEFAULT_ROUTES 0x00000004   | Specifies whether host routes are included in RIP announcements.                 |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| IPRIP_FLAG_ANNOUNCE_DEFAULT_ROUTES 0x00000008 | Specifies whether default routes are included in RIP announcements.              |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| IPRIP_FLAG_SPLIT_HORIZON 0x00000010           | Enables split-horizon processing. Specifies whether routes learned on a network  |
	//	|                                               | are not announced in RIP announcements sent on that network.                     |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| IPRIP_FLAG_POISON_REVERSE 0x00000020          | Enables the poison-reverse processing. Specifies whether routes learned on a     |
	//	|                                               | network are announced with a metric of 16 (unreachable) in RIP announcements     |
	//	|                                               | sent on that network.                                                            |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| IPRIP_FLAG_GRACEFUL_SHUTDOWN 0x00000040       | Sends cleanup updates when shutting down. Specifies whether, if the RIP is       |
	//	|                                               | stopping on this interface, the RIP sends an announcement with all routes that   |
	//	|                                               | are marked with a metric of 15. This enables neighboring routers to immediately  |
	//	|                                               | update their routing tables to indicate that the routes available through the    |
	//	|                                               | router that is stopping are no longer reachable.                                 |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| IPRIP_FLAG_TRIGGERED_UPDATES 0x00000080       | Enables triggered updates processing. Specifies whether new routes and metric    |
	//	|                                               | changes trigger an immediate update that includes only the changes. This is      |
	//	|                                               | called a triggered update.                                                       |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| IPRIP_FLAG_OVERWRITE_STATIC_ROUTES 0x00000100 | Overwrites the static routes on the interface.                                   |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| IPRIP_FLAG_NO_SUBNET_SUMMARY 0x00000200       | Specifies that subnet routes are not summarized in the form of the class-based   |
	//	|                                               | network ID when announced on a network that is not a subnet of the class-based   |
	//	|                                               | network ID. By default, subnet summarization is disabled.                        |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	ProtocolFlags uint32 `idl:"name:IC_ProtocolFlags" json:"protocol_flags"`
	// IC_RouteExpirationInterval (4 bytes): The lifetime (in seconds) of a route that is
	// learned through the RIP before it expires.
	RouteExpirationInterval uint32 `idl:"name:IC_RouteExpirationInterval" json:"route_expiration_interval"`
	// IC_RouteRemovalInterval (4 bytes): The amount of time (in seconds) after which a
	// RIP-learned route that has expired is removed from the routing table.
	RouteRemovalInterval uint32 `idl:"name:IC_RouteRemovalInterval" json:"route_removal_interval"`
	// IC_FullUpdateInterval (4 bytes): The number of seconds between full RIP updates.
	FullUpdateInterval uint32 `idl:"name:IC_FullUpdateInterval" json:"full_update_interval"`
	// IC_AuthenticationType (4 bytes): One of the following values.
	//
	//	+-------------------------------------------+--------------------------------------------------------------------+
	//	|                                           |                                                                    |
	//	|                   VALUE                   |                              MEANING                               |
	//	|                                           |                                                                    |
	//	+-------------------------------------------+--------------------------------------------------------------------+
	//	+-------------------------------------------+--------------------------------------------------------------------+
	//	| IPRIP_AUTHTYPE_NONE 0x00000001            | No authentication is used.                                         |
	//	+-------------------------------------------+--------------------------------------------------------------------+
	//	| IPRIP_AUTHTYPE_SIMPLE_PASSWORD 0x00000002 | Password authentication is used. Plain comparison of text is made. |
	//	+-------------------------------------------+--------------------------------------------------------------------+
	//	| IPRIP_AUTHTYPE_MD5 0x00000003             | This is unused.                                                    |
	//	+-------------------------------------------+--------------------------------------------------------------------+
	AuthenticationType uint32 `idl:"name:IC_AuthenticationType" json:"authentication_type"`
	// IC_AuthenticationKey (16 bytes): The authentication data being sent depending on
	// IC_AuthenticationType. This MUST be a write-only field and MUST be ignored on receive.
	AuthenticationKey []byte `idl:"name:IC_AuthenticationKey" json:"authentication_key"`
	// IC_RouteTag (2 bytes): A tag number for the routes advertised on this interface.
	// Use this option if to have all packets sent over this interface to include a tag
	// in RIP version 2 announcements. See [RFC1723].
	RouteTag uint16 `idl:"name:IC_RouteTag" json:"route_tag"`
	// IC_UnicastPeerMode (4 bytes): This MUST be one of the following values.
	//
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	|                                |                                                                                  |
	//	|             VALUE              |                                     MEANING                                      |
	//	|                                |                                                                                  |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	| IPRIP_PEER_DISABLED 0x00000000 | RIP packets will not be sent to peers.                                           |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	| IPRIP_PEER_ALSO 0x00000001     | RIP packets will be sent to peers, as well as being sent via broadcast or        |
	//	|                                | multicast.                                                                       |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	| IPRIP_PEER_ONLY 0x00000002     | RIP packets will only be sent to the peers specified in the structure.           |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	UnicastPeerMode uint32 `idl:"name:IC_UnicastPeerMode" json:"unicast_peer_mode"`
	// IC_AcceptFilterMode (4 bytes): This MUST be one of the following values.
	//
	//	+----------------------------------+----------------------------------------------------------------------------------+
	//	|                                  |                                                                                  |
	//	|              VALUE               |                                     MEANING                                      |
	//	|                                  |                                                                                  |
	//	+----------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------+----------------------------------------------------------------------------------+
	//	| IPRIP_FILTER_DISABLED 0x00000000 | Updates from all IP addresses are accepted.                                      |
	//	+----------------------------------+----------------------------------------------------------------------------------+
	//	| IPRIP_FILTER_INCLUDE 0x00000001  | Updates are only accepted from the IP addresses specified by the                 |
	//	|                                  | IC_AcceptFilter.                                                                 |
	//	+----------------------------------+----------------------------------------------------------------------------------+
	//	| IPRIP_FILTER_EXCLUDE 0x00000002  | Ignores updates from the IP addresses specified by the IC_AcceptFilter.          |
	//	+----------------------------------+----------------------------------------------------------------------------------+
	AcceptFilterMode uint32 `idl:"name:IC_AcceptFilterMode" json:"accept_filter_mode"`
	// IC_AnnounceFilterMode (4 bytes): This MUST be one of the following values.
	//
	//	+----------------------------------+---------------------------------------------------------------------------------+
	//	|                                  |                                                                                 |
	//	|              VALUE               |                                     MEANING                                     |
	//	|                                  |                                                                                 |
	//	+----------------------------------+---------------------------------------------------------------------------------+
	//	+----------------------------------+---------------------------------------------------------------------------------+
	//	| IPRIP_FILTER_DISABLED 0x00000000 | Updates from all IP addresses are accepted.                                     |
	//	+----------------------------------+---------------------------------------------------------------------------------+
	//	| IPRIP_FILTER_INCLUDE 0x00000001  | Updates are only accepted from IP addresses specified by the IC_AnnounceFilter. |
	//	+----------------------------------+---------------------------------------------------------------------------------+
	//	| IPRIP_FILTER_EXCLUDE 0x00000002  | Ignores updates from the IP addresses specified by the IC_AnnounceFilter.       |
	//	+----------------------------------+---------------------------------------------------------------------------------+
	AnnounceFilterMode uint32 `idl:"name:IC_AnnounceFilterMode" json:"announce_filter_mode"`
	// IC_UnicastPeerCount (4 bytes): The number of peer IP addresses specified in IC_UnicastPeer
	// array.
	UnicastPeerCount uint32 `idl:"name:IC_UnicastPeerCount" json:"unicast_peer_count"`
	// IC_AcceptFilterCount (4 bytes): The number of accept filters specified in IC_AcceptFilter.
	AcceptFilterCount uint32 `idl:"name:IC_AcceptFilterCount" json:"accept_filter_count"`
	// IC_AnnounceFilterCount (4 bytes): The number of announce filters specified in IC_AnnounceFilter.
	AnnounceFilterCount uint32 `idl:"name:IC_AnnounceFilterCount" json:"announce_filter_count"`
}

func (o *IPRIPInterfaceConfig) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPRIPInterfaceConfig) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.State); err != nil {
		return err
	}
	if err := w.WriteData(o.Metric); err != nil {
		return err
	}
	if err := w.WriteData(o.UpdateMode); err != nil {
		return err
	}
	if err := w.WriteData(o.AcceptMode); err != nil {
		return err
	}
	if err := w.WriteData(o.AnnounceMode); err != nil {
		return err
	}
	if err := w.WriteData(o.ProtocolFlags); err != nil {
		return err
	}
	if err := w.WriteData(o.RouteExpirationInterval); err != nil {
		return err
	}
	if err := w.WriteData(o.RouteRemovalInterval); err != nil {
		return err
	}
	if err := w.WriteData(o.FullUpdateInterval); err != nil {
		return err
	}
	if err := w.WriteData(o.AuthenticationType); err != nil {
		return err
	}
	for i1 := range o.AuthenticationKey {
		i1 := i1
		if uint64(i1) >= 16 {
			break
		}
		if err := w.WriteData(o.AuthenticationKey[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.AuthenticationKey); uint64(i1) < 16; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.RouteTag); err != nil {
		return err
	}
	if err := w.WriteData(o.UnicastPeerMode); err != nil {
		return err
	}
	if err := w.WriteData(o.AcceptFilterMode); err != nil {
		return err
	}
	if err := w.WriteData(o.AnnounceFilterMode); err != nil {
		return err
	}
	if err := w.WriteData(o.UnicastPeerCount); err != nil {
		return err
	}
	if err := w.WriteData(o.AcceptFilterCount); err != nil {
		return err
	}
	if err := w.WriteData(o.AnnounceFilterCount); err != nil {
		return err
	}
	return nil
}
func (o *IPRIPInterfaceConfig) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.State); err != nil {
		return err
	}
	if err := w.ReadData(&o.Metric); err != nil {
		return err
	}
	if err := w.ReadData(&o.UpdateMode); err != nil {
		return err
	}
	if err := w.ReadData(&o.AcceptMode); err != nil {
		return err
	}
	if err := w.ReadData(&o.AnnounceMode); err != nil {
		return err
	}
	if err := w.ReadData(&o.ProtocolFlags); err != nil {
		return err
	}
	if err := w.ReadData(&o.RouteExpirationInterval); err != nil {
		return err
	}
	if err := w.ReadData(&o.RouteRemovalInterval); err != nil {
		return err
	}
	if err := w.ReadData(&o.FullUpdateInterval); err != nil {
		return err
	}
	if err := w.ReadData(&o.AuthenticationType); err != nil {
		return err
	}
	o.AuthenticationKey = make([]byte, 16)
	for i1 := range o.AuthenticationKey {
		i1 := i1
		if err := w.ReadData(&o.AuthenticationKey[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.RouteTag); err != nil {
		return err
	}
	if err := w.ReadData(&o.UnicastPeerMode); err != nil {
		return err
	}
	if err := w.ReadData(&o.AcceptFilterMode); err != nil {
		return err
	}
	if err := w.ReadData(&o.AnnounceFilterMode); err != nil {
		return err
	}
	if err := w.ReadData(&o.UnicastPeerCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.AcceptFilterCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.AnnounceFilterCount); err != nil {
		return err
	}
	return nil
}

// IPRIPRouteFilter structure represents IPRIP_ROUTE_FILTER RPC structure.
//
// The IPRIP_ROUTE_FILTER structure is used to specify a route filter for use in the
// IC_AcceptFilter and IC_AnnounceFilter fields of the IPRIP_IF_CONFIG (section 2.2.1.2.166)
// structure.
type IPRIPRouteFilter struct {
	// RF_LoAddress: The starting IPv4 address of the route filter specified in network
	// byte order.
	RfLoAddress uint32 `idl:"name:RF_LoAddress" json:"rf_lo_address"`
	// RF_HiAddress: The ending IPv4 address of the route filter specified in network byte
	// order.
	RfHiAddress uint32 `idl:"name:RF_HiAddress" json:"rf_hi_address"`
}

func (o *IPRIPRouteFilter) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPRIPRouteFilter) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.RfLoAddress); err != nil {
		return err
	}
	if err := w.WriteData(o.RfHiAddress); err != nil {
		return err
	}
	return nil
}
func (o *IPRIPRouteFilter) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.RfLoAddress); err != nil {
		return err
	}
	if err := w.ReadData(&o.RfHiAddress); err != nil {
		return err
	}
	return nil
}

// IPRIPInterfaceBinding structure represents IPRIP_IF_BINDING RPC structure.
//
// The IPRIP_IF_BINDING structure is an MIB entry that contains the table of IP addresses
// to which each interface is bound. This structure is used in IPRIP_MIB_GET_INPUT_DATA
// (section 2.2.1.2.161) and IPRIP_MIB_GET_OUTPUT_DATA (section 2.2.1.2.162) structures.
//
// All IP addresses are in network order. This structure is variable length.
//
// The base structure contains the field IB_AddrCount, which gives the number of IP
// addresses to which the indexed interface is bound. The IP addresses themselves follow
// the base structure and are given as IPRIP_IP_ADDRESS (section 2.2.1.2.169) structures.
// This MIB entry is read-only.
type IPRIPInterfaceBinding struct {
	// IB_State: The IP RIP state on the interface. It MUST be a combination of one or more
	// of the following values.
	//
	//	+--------------------------------+------------------------+
	//	|                                |                        |
	//	|             VALUE              |        MEANING         |
	//	|                                |                        |
	//	+--------------------------------+------------------------+
	//	+--------------------------------+------------------------+
	//	| IPRIP_STATE_ENABLED 0x00000001 | The IP RIP is enabled. |
	//	+--------------------------------+------------------------+
	//	| IPRIP_STATE_BOUND 0x00000002   | The socket is bound.   |
	//	+--------------------------------+------------------------+
	State uint32 `idl:"name:IB_State" json:"state"`
	// IB_AddrCount: The number of IPRIP_IP_ADDRESS structures present at the end of this
	// structure.
	AddrCount uint32 `idl:"name:IB_AddrCount" json:"addr_count"`
}

func (o *IPRIPInterfaceBinding) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPRIPInterfaceBinding) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.State); err != nil {
		return err
	}
	if err := w.WriteData(o.AddrCount); err != nil {
		return err
	}
	return nil
}
func (o *IPRIPInterfaceBinding) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.State); err != nil {
		return err
	}
	if err := w.ReadData(&o.AddrCount); err != nil {
		return err
	}
	return nil
}

// IPRIPIPAddress structure represents IPRIP_IP_ADDRESS RPC structure.
//
// The IPRIP_IP_ADDRESS structure is used for storing interface bindings. A series of
// structures of this type follows the IPRIP_IF_BINDING (section 2.2.1.2.168) structure.
// This structure is used in IPRIP_IF_BINDING. Both fields are IP address fields in
// network-order.
type IPRIPIPAddress struct {
	// IA_Address: The IP address.
	Address uint32 `idl:"name:IA_Address" json:"address"`
	// IA_Netmask: The net mask. See [RFC950].
	Netmask uint32 `idl:"name:IA_Netmask" json:"netmask"`
}

func (o *IPRIPIPAddress) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPRIPIPAddress) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Address); err != nil {
		return err
	}
	if err := w.WriteData(o.Netmask); err != nil {
		return err
	}
	return nil
}
func (o *IPRIPIPAddress) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Address); err != nil {
		return err
	}
	if err := w.ReadData(&o.Netmask); err != nil {
		return err
	}
	return nil
}

// IPRIPPeerStats structure represents IPRIP_PEER_STATS RPC structure.
//
// The IPRIP_PEER_STATS structure is an MIB entry that describes the statistics kept
// about neighboring routers. All IP addresses are in network order. This structure
// is read-only. This structure is used in IPRIP_MIB_GET_INPUT_DATA (section 2.2.1.2.161)
// and IPRIP_MIB_GET_OUTPUT_DATA (section 2.2.1.2.162) structures.
type IPRIPPeerStats struct {
	// PS_LastPeerRouteTag: The route tag last received from the peer.
	PsLastPeerRouteTag uint32 `idl:"name:PS_LastPeerRouteTag" json:"ps_last_peer_route_tag"`
	// PS_LastPeerUpdateTickCount: The number of updates received from peer.
	PsLastPeerUpdateTickCount uint32 `idl:"name:PS_LastPeerUpdateTickCount" json:"ps_last_peer_update_tick_count"`
	// PS_LastPeerUpdateVersion: The RIP version of the last update received from peer.
	PsLastPeerUpdateVersion uint32 `idl:"name:PS_LastPeerUpdateVersion" json:"ps_last_peer_update_version"`
	// PS_BadResponsePacketsFromPeer: The number of bad response packets received from peer.
	PsBadResponsePacketsFromPeer uint32 `idl:"name:PS_BadResponsePacketsFromPeer" json:"ps_bad_response_packets_from_peer"`
	// PS_BadResponseEntriesFromPeer: The number of bad entries in responses received from
	// peer.
	PsBadResponseEntriesFromPeer uint32 `idl:"name:PS_BadResponseEntriesFromPeer" json:"ps_bad_response_entries_from_peer"`
}

func (o *IPRIPPeerStats) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPRIPPeerStats) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.PsLastPeerRouteTag); err != nil {
		return err
	}
	if err := w.WriteData(o.PsLastPeerUpdateTickCount); err != nil {
		return err
	}
	if err := w.WriteData(o.PsLastPeerUpdateVersion); err != nil {
		return err
	}
	if err := w.WriteData(o.PsBadResponsePacketsFromPeer); err != nil {
		return err
	}
	if err := w.WriteData(o.PsBadResponseEntriesFromPeer); err != nil {
		return err
	}
	return nil
}
func (o *IPRIPPeerStats) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.PsLastPeerRouteTag); err != nil {
		return err
	}
	if err := w.ReadData(&o.PsLastPeerUpdateTickCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.PsLastPeerUpdateVersion); err != nil {
		return err
	}
	if err := w.ReadData(&o.PsBadResponsePacketsFromPeer); err != nil {
		return err
	}
	if err := w.ReadData(&o.PsBadResponseEntriesFromPeer); err != nil {
		return err
	}
	return nil
}

// IGMPMIBGetInputData structure represents IGMP_MIB_GET_INPUT_DATA RPC structure.
//
// The IGMP_MIB_GET_INPUT_DATA structure is passed as input data for the following methods:
//
// * *RMIBEntryGet (section 3.1.4.30)* ( ebc5c709-36d8-4520-a0ac-6f36d2d6c0b2 )
//
// * *RMIBEntryGetFirst (section 3.1.4.31)* ( 9102e585-2f62-4408-bfb6-02a6460cc883 )
//
// * *RMIBEntryGetNext (section 3.1.4.32)* ( 50f78033-d248-4272-b4b9-a2519a0f304d )
//
// All IP addresses MUST be in network order.
type IGMPMIBGetInputData struct {
	TypeID uint32 `idl:"name:TypeId" json:"type_id"`
	// Flags: This MUST be one of the following combinations, otherwise an error is returned.
	//
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                            |                                                                                  |
	//	|                   VALUE                    |                                     MEANING                                      |
	//	|                                            |                                                                                  |
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_ENUM_FOR_RAS_CLIENTS 0x00000001       | Enumerate for RAS clients only.                                                  |
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_ENUM_ONE_ENTRY 0x00000002             | Return only one interface group entry.                                           |
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_ENUM_ALL_INTERFACES_GROUPS 0x00000004 | Enumerate all interfaces. If enumeration reaches end of an interface, it will go |
	//	|                                            | to the next interface.                                                           |
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_ENUM_ALL_TABLES 0x00000010            | Enumerate all tables.                                                            |
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_ENUM_SUPPORT_FORMAT_IGMPV3 0x00000010 | Set if IGMPv3 is supported.                                                      |
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	Flags uint16 `idl:"name:Flags" json:"flags"`
	// Signature: This MUST be set to zero (0).
	Signature uint16 `idl:"name:Signature" json:"signature"`
	// IfIndex: The index of the interface for which information needs to be retrieved.
	InterfaceIndex uint32 `idl:"name:IfIndex" json:"interface_index"`
	// RasClientAddr: The address of the RAS client for which information needs to be retrieved.
	RASClientAddr uint32 `idl:"name:RasClientAddr" json:"ras_client_addr"`
	// GroupAddr: The IGMP group address for which information needs to be retrieved.
	GroupAddr uint32 `idl:"name:GroupAddr" json:"group_addr"`
	// Count: The count of entries that need to be retrieved.
	Count uint32 `idl:"name:Count" json:"count"`
}

func (o *IGMPMIBGetInputData) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IGMPMIBGetInputData) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.TypeID); err != nil {
		return err
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	if err := w.WriteData(o.Signature); err != nil {
		return err
	}
	if err := w.WriteData(o.InterfaceIndex); err != nil {
		return err
	}
	if err := w.WriteData(o.RASClientAddr); err != nil {
		return err
	}
	if err := w.WriteData(o.GroupAddr); err != nil {
		return err
	}
	if err := w.WriteData(o.Count); err != nil {
		return err
	}
	return nil
}
func (o *IGMPMIBGetInputData) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.TypeID); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	if err := w.ReadData(&o.Signature); err != nil {
		return err
	}
	if err := w.ReadData(&o.InterfaceIndex); err != nil {
		return err
	}
	if err := w.ReadData(&o.RASClientAddr); err != nil {
		return err
	}
	if err := w.ReadData(&o.GroupAddr); err != nil {
		return err
	}
	if err := w.ReadData(&o.Count); err != nil {
		return err
	}
	return nil
}

// IGMPMIBGetOutputData structure represents IGMP_MIB_GET_OUTPUT_DATA RPC structure.
//
// The IGMP_MIB_GET_OUTPUT_DATA structure is written into the output data on calling
// the following methods:
//
// * *RMIBEntryGet (section 3.1.4.30)* ( ebc5c709-36d8-4520-a0ac-6f36d2d6c0b2 )
//
// * *RMIBEntryGetFirst (section 3.1.4.31)* ( 9102e585-2f62-4408-bfb6-02a6460cc883 )
//
// * *RMIBEntryGetNext (section 3.1.4.32)* ( 50f78033-d248-4272-b4b9-a2519a0f304d )
//
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| TypeID                                                                                                                        |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| Flags                                                                                                                         |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| Count                                                                                                                         |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| Buffer (variable)                                                                                                             |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
type IGMPMIBGetOutputData struct {
	TypeID uint32 `idl:"name:TypeId" json:"type_id"`
	// Flags (4 bytes): This MUST be a combination of the following flags.
	//
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                               |                                                                                  |
	//	|                     VALUE                     |                                     MEANING                                      |
	//	|                                               |                                                                                  |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_ENUM_FOR_RAS_CLIENTS 0x00000001          | Enumerate for RAS clients only.                                                  |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_ENUM_ONE_ENTRY 0x00000002                | Returns only one interface group entry.                                          |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_ENUM_ALL_INTERFACES_GROUPS 0x00000004    | Enumerate all interfaces. If the enumeration reaches the end of an interface, it |
	//	|                                               | will go to the next interface.                                                   |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_ENUM_ALL_TABLES 0x00000010               | Enumerate all tables.                                                            |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_ENUM_SUPPORT_FORMAT_IGMPV3 0x00000010    | Set if IGMPv3 is supported.                                                      |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_ENUM_INTERFACE_TABLE_BEGIN 0x00000100    | Indicates the beginning of the table.                                            |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_ENUM_INTERFACE_TABLE_CONTINUE 0x00000200 | The enumeration for the interface has to continue.                               |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_ENUM_INTERFACE_TABLE_END 0x00000400      | End of the enumeration for the interface.                                        |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_ENUM_FORMAT_IGMPV3 0x00001000            | A set of IGMPv3 information is present.                                          |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	Flags uint32 `idl:"name:Flags" json:"flags"`
	// Count (4 bytes): The number of entries being returned.
	Count uint32 `idl:"name:Count" json:"count"`
	// Buffer (variable): One of the structures specified previously depending on the TypeId.
	Buffer []byte `idl:"name:Buffer" json:"buffer"`
}

func (o *IGMPMIBGetOutputData) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IGMPMIBGetOutputData) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.TypeID); err != nil {
		return err
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	if err := w.WriteData(o.Count); err != nil {
		return err
	}
	for i1 := range o.Buffer {
		i1 := i1
		if uint64(i1) >= 1 {
			break
		}
		if err := w.WriteData(o.Buffer[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Buffer); uint64(i1) < 1; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteTrailingGap(4); err != nil {
		return err
	}
	return nil
}
func (o *IGMPMIBGetOutputData) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.TypeID); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	if err := w.ReadData(&o.Count); err != nil {
		return err
	}
	o.Buffer = make([]byte, 1)
	for i1 := range o.Buffer {
		i1 := i1
		if err := w.ReadData(&o.Buffer[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadTrailingGap(4); err != nil {
		return err
	}
	return nil
}

// IGMPMIBGlobalConfig structure represents IGMP_MIB_GLOBAL_CONFIG RPC structure.
//
// The IGMP_MIB_GLOBAL_CONFIG structure contains the global configuration for the IGMP.
// This structure is used in the following methods:
//
// * *RRouterInterfaceTransportSetGlobalInfo (section 3.1.4.10)* ( 071439e7-a9fd-40e4-91f7-ab756108e82f
// )
//
// * *RRouterInterfaceTransportGetGlobalInfo (section 3.1.4.11)* ( 14ad8d26-d7d7-48dd-914d-da962d5d7049
// )
//
// typedef struct _IGMP_MIB_GLOBAL_CONFIG {
//
// DWORD Version;
//
// DWORD LoggingLevel;
//
// DWORD RasClientStats;
//
// } IGMP_MIB_GLOBAL_CONFIG,
type IGMPMIBGlobalConfig struct {
	// Version: It MUST be one of the following.
	//
	//	+-----------------------------+------------------+
	//	|                             |                  |
	//	|            VALUE            |     MEANING      |
	//	|                             |                  |
	//	+-----------------------------+------------------+
	//	+-----------------------------+------------------+
	//	| IGMP_VERSION_1_2 0x00000201 | IGMPv1 or IGMPv2 |
	//	+-----------------------------+------------------+
	//	| IGMP_VERSION_3 0x00000301   | IGMPv3           |
	//	+-----------------------------+------------------+
	Version uint32 `idl:"name:Version" json:"version"`
	// LoggingLevel: Specifies the logging level. It MUST be one of the following values.
	//
	//	+-------------------------------+----------------------------------------------+
	//	|                               |                                              |
	//	|             VALUE             |                   MEANING                    |
	//	|                               |                                              |
	//	+-------------------------------+----------------------------------------------+
	//	+-------------------------------+----------------------------------------------+
	//	| IGMP_LOGGING_NONE 0x00000000  | No logging is done.                          |
	//	+-------------------------------+----------------------------------------------+
	//	| IGMP_LOGGING_ERROR 0x00000001 | Only errors are logged.                      |
	//	+-------------------------------+----------------------------------------------+
	//	| IGMP_LOGGING_WARN 0x00000002  | Errors and warnings are logged.              |
	//	+-------------------------------+----------------------------------------------+
	//	| IGMP_LOGGING_INFO 0x00000003  | Errors, warnings, and information is logged. |
	//	+-------------------------------+----------------------------------------------+
	LoggingLevel uint32 `idl:"name:LoggingLevel" json:"logging_level"`
	// RasClientStats: If RASClientStats is nonzero, then per RAS client statistics are
	// maintained.
	RASClientStats uint32 `idl:"name:RasClientStats" json:"ras_client_stats"`
}

func (o *IGMPMIBGlobalConfig) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IGMPMIBGlobalConfig) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Version); err != nil {
		return err
	}
	if err := w.WriteData(o.LoggingLevel); err != nil {
		return err
	}
	if err := w.WriteData(o.RASClientStats); err != nil {
		return err
	}
	return nil
}
func (o *IGMPMIBGlobalConfig) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Version); err != nil {
		return err
	}
	if err := w.ReadData(&o.LoggingLevel); err != nil {
		return err
	}
	if err := w.ReadData(&o.RASClientStats); err != nil {
		return err
	}
	return nil
}

// IGMPMIBGlobalStats structure represents IGMP_MIB_GLOBAL_STATS RPC structure.
type IGMPMIBGlobalStats struct {
	CurrentGroupMemberships uint32 `idl:"name:CurrentGroupMemberships" json:"current_group_memberships"`
	GroupMembershipsAdded   uint32 `idl:"name:GroupMembershipsAdded" json:"group_memberships_added"`
}

func (o *IGMPMIBGlobalStats) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IGMPMIBGlobalStats) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.CurrentGroupMemberships); err != nil {
		return err
	}
	if err := w.WriteData(o.GroupMembershipsAdded); err != nil {
		return err
	}
	return nil
}
func (o *IGMPMIBGlobalStats) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.CurrentGroupMemberships); err != nil {
		return err
	}
	if err := w.ReadData(&o.GroupMembershipsAdded); err != nil {
		return err
	}
	return nil
}

// IGMPMIBInterfaceBinding structure represents IGMP_MIB_IF_BINDING RPC structure.
type IGMPMIBInterfaceBinding struct {
	InterfaceIndex uint32 `idl:"name:IfIndex" json:"interface_index"`
	InterfaceType  uint32 `idl:"name:IfType" json:"interface_type"`
	State          uint32 `idl:"name:State" json:"state"`
	AddrCount      uint32 `idl:"name:AddrCount" json:"addr_count"`
}

func (o *IGMPMIBInterfaceBinding) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IGMPMIBInterfaceBinding) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.InterfaceIndex); err != nil {
		return err
	}
	if err := w.WriteData(o.InterfaceType); err != nil {
		return err
	}
	if err := w.WriteData(o.State); err != nil {
		return err
	}
	if err := w.WriteData(o.AddrCount); err != nil {
		return err
	}
	return nil
}
func (o *IGMPMIBInterfaceBinding) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.InterfaceIndex); err != nil {
		return err
	}
	if err := w.ReadData(&o.InterfaceType); err != nil {
		return err
	}
	if err := w.ReadData(&o.State); err != nil {
		return err
	}
	if err := w.ReadData(&o.AddrCount); err != nil {
		return err
	}
	return nil
}

// IGMPMIBInterfaceConfig structure represents IGMP_MIB_IF_CONFIG RPC structure.
//
// The IGMP_MIB_IF_CONFIG structure contains per-interface configuration. This structure
// is used in the following methods:
//
// * *RRouterInterfaceTransportAdd (section 3.1.4.18)* ( 927c5bf1-ac91-4325-b945-0d96a58f609b
// )
//
// * *RRouterInterfaceTransportGetInfo (section 3.2.4.19)* ( 2c0f9b0e-1f3e-4436-a534-cb30fe0f887f
// )
//
// * *RRouterInterfaceTransportSetInfo (section 3.1.4.20)* ( 209ba5e7-876e-4406-a05c-65b7e5fb2380
// )
//
// All IP address fields MUST be in network order.
type IGMPMIBInterfaceConfig struct {
	// Version: It MUST be one of the following values.
	//
	//	+-----------------------------+------------------+
	//	|                             |                  |
	//	|            VALUE            |     MEANING      |
	//	|                             |                  |
	//	+-----------------------------+------------------+
	//	+-----------------------------+------------------+
	//	| IGMP_VERSION_1_2 0x00000201 | IGMPv1 or IGMPv2 |
	//	+-----------------------------+------------------+
	//	| IGMP_VERSION_3 0x00000301   | IGMPv3           |
	//	+-----------------------------+------------------+
	Version uint32 `idl:"name:Version" json:"version"`
	// IfIndex: The index of the interface, it is read-only.
	InterfaceIndex uint32 `idl:"name:IfIndex" json:"interface_index"`
	// IpAddr: The IP address of the interface, it is read-only.
	IPAddr uint32 `idl:"name:IpAddr" json:"ip_addr"`
	// IfType: The type of the interface, it is read-only. It MUST be one of the following
	// values.
	//
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	|                               |                                                                                  |
	//	|             VALUE             |                                     MEANING                                      |
	//	|                               |                                                                                  |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_IF_NOT_RAS 0x00000001    | The interface is connected to a LAN.                                             |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_IF_RAS_ROUTER 0x00000002 | The interface is connected to another router over RAS.                           |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_IF_RAS_SERVER 0x00000003 | The entry corresponds to a RAS server if it contains statistics, then it         |
	//	|                               | represents summarized statistics.                                                |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_IF_RAS_CLIENT 0x00000004 | The entry corresponds to a RAS client.                                           |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_IF_PROXY 0x00000008      | One of the first four flags will still be set to enable the switch from the      |
	//	|                               | proxy to an IGMP router.                                                         |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	InterfaceType uint32 `idl:"name:IfType" json:"interface_type"`
	// Flags: It MUST be one of the following values.
	//
	//	+----------------------------------------------+-------------------------------------------------+
	//	|                                              |                                                 |
	//	|                    VALUE                     |                     MEANING                     |
	//	|                                              |                                                 |
	//	+----------------------------------------------+-------------------------------------------------+
	//	+----------------------------------------------+-------------------------------------------------+
	//	| IGMP_INTERFACE_ENABLED_IN_CONFIG 0x00000001  | The interface is enabled in this configuration. |
	//	+----------------------------------------------+-------------------------------------------------+
	//	| IGMP_ACCEPT_RTRALERT_PACKETS_ONLY 0x00000002 | Can accept only router alerts.                  |
	//	+----------------------------------------------+-------------------------------------------------+
	Flags uint32 `idl:"name:Flags" json:"flags"`
	// IgmpProtocolType: Takes one of the following values.
	//
	//	+---------------------------+------------------------------------+
	//	|                           |                                    |
	//	|           VALUE           |              MEANING               |
	//	|                           |                                    |
	//	+---------------------------+------------------------------------+
	//	+---------------------------+------------------------------------+
	//	| IGMP_PROXY 0x00000000     | The interface is an IGMPv2 proxy.  |
	//	+---------------------------+------------------------------------+
	//	| IGMP_ROUTER_V1 0x00000001 | The interface is an IGMPv1 router. |
	//	+---------------------------+------------------------------------+
	//	| IGMP_ROUTER_V2 0x00000002 | The interface is an IGMPv2 router. |
	//	+---------------------------+------------------------------------+
	//	| IGMP_ROUTER_V3 0x00000003 | The interface is an IGMPv3 router. |
	//	+---------------------------+------------------------------------+
	//	| IGMP_PROXY_V3 0x00000010  | The interface is an IGMPv3 proxy.  |
	//	+---------------------------+------------------------------------+
	IGMPProtocolType uint32 `idl:"name:IgmpProtocolType" json:"igmp_protocol_type"`
	// RobustnessVariable: The robustness variable is a way of indicating the lossy nature
	// of the subnet to which this interface is attached. The IGMP can recover from lost
	// IGMP packets (robustness variable is set to 1). The robustness variable SHOULD be
	// set to a value of 2 or greater.
	RobustnessVariable uint32 `idl:"name:RobustnessVariable" json:"robustness_variable"`
	// StartupQueryInterval: The startup query interval is the amount of time in seconds
	// between successive general query messages sent by a querier during startup.
	StartupQueryInterval uint32 `idl:"name:StartupQueryInterval" json:"startup_query_interval"`
	// StartupQueryCount: The startup query count is the number of general query messages
	// sent at startup.
	StartupQueryCount uint32 `idl:"name:StartupQueryCount" json:"startup_query_count"`
	// GenQueryInterval: The query interval is the amount of time, in seconds, between the
	// IGMP general query messages sent by the router (if the router is the querier on this
	// subnet).
	GenQueryInterval uint32 `idl:"name:GenQueryInterval" json:"gen_query_interval"`
	// GenQueryMaxResponseTime: The query response interval is the maximum amount of time,
	// in seconds, that the IGMP router waits to receive a response to a general query message.
	GenQueryMaxResponseTime uint32 `idl:"name:GenQueryMaxResponseTime" json:"gen_query_max_response_time"`
	// LastMemQueryInterval: The last member query interval is the amount of time, in milliseconds,
	// that the IGMP router waits to receive a response to a group-specific query message.
	// The last member query interval is also the amount of time, in seconds, between successive
	// group-specific query messages.
	LastMemQueryInterval uint32 `idl:"name:LastMemQueryInterval" json:"last_mem_query_interval"`
	// LastMemQueryCount: The last member query count is the number of group-specific query
	// messages sent before the router assumes there are no members of the host group being
	// queried on this interface.
	LastMemQueryCount uint32 `idl:"name:LastMemQueryCount" json:"last_mem_query_count"`
	// OtherQuerierPresentInterval: Displays the calculated other querier present interval.
	// The other querier present interval is the number of seconds that MUST pass before
	// a multicast router determines that there is no other multicast router that can be
	// the querier. The other querier present interval is (robustness variable) * (query
	// interval) + (query response interval)/2.
	OtherQuerierPresentInterval uint32 `idl:"name:OtherQuerierPresentInterval" json:"other_querier_present_interval"`
	// GroupMembershipTimeout: Displays the calculated group membership interval. The group
	// membership interval is the number of seconds that MUST pass before a multicast router
	// determines that there are no more members of a host group on a subnet. The group
	// membership interval is (robustness variable) * (query interval) + (query response
	// interval).
	GroupMembershipTimeout uint32 `idl:"name:GroupMembershipTimeout" json:"group_membership_timeout"`
	// NumStaticGroups: The number of static groups. This value MUST be zero (0) when calling
	// RRouterInterfaceTransportAdd and RRouterInterfaceTransportSetInfo.
	StaticGroupsLength uint32 `idl:"name:NumStaticGroups" json:"static_groups_length"`
}

func (o *IGMPMIBInterfaceConfig) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IGMPMIBInterfaceConfig) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Version); err != nil {
		return err
	}
	if err := w.WriteData(o.InterfaceIndex); err != nil {
		return err
	}
	if err := w.WriteData(o.IPAddr); err != nil {
		return err
	}
	if err := w.WriteData(o.InterfaceType); err != nil {
		return err
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	if err := w.WriteData(o.IGMPProtocolType); err != nil {
		return err
	}
	if err := w.WriteData(o.RobustnessVariable); err != nil {
		return err
	}
	if err := w.WriteData(o.StartupQueryInterval); err != nil {
		return err
	}
	if err := w.WriteData(o.StartupQueryCount); err != nil {
		return err
	}
	if err := w.WriteData(o.GenQueryInterval); err != nil {
		return err
	}
	if err := w.WriteData(o.GenQueryMaxResponseTime); err != nil {
		return err
	}
	if err := w.WriteData(o.LastMemQueryInterval); err != nil {
		return err
	}
	if err := w.WriteData(o.LastMemQueryCount); err != nil {
		return err
	}
	if err := w.WriteData(o.OtherQuerierPresentInterval); err != nil {
		return err
	}
	if err := w.WriteData(o.GroupMembershipTimeout); err != nil {
		return err
	}
	if err := w.WriteData(o.StaticGroupsLength); err != nil {
		return err
	}
	return nil
}
func (o *IGMPMIBInterfaceConfig) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Version); err != nil {
		return err
	}
	if err := w.ReadData(&o.InterfaceIndex); err != nil {
		return err
	}
	if err := w.ReadData(&o.IPAddr); err != nil {
		return err
	}
	if err := w.ReadData(&o.InterfaceType); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	if err := w.ReadData(&o.IGMPProtocolType); err != nil {
		return err
	}
	if err := w.ReadData(&o.RobustnessVariable); err != nil {
		return err
	}
	if err := w.ReadData(&o.StartupQueryInterval); err != nil {
		return err
	}
	if err := w.ReadData(&o.StartupQueryCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.GenQueryInterval); err != nil {
		return err
	}
	if err := w.ReadData(&o.GenQueryMaxResponseTime); err != nil {
		return err
	}
	if err := w.ReadData(&o.LastMemQueryInterval); err != nil {
		return err
	}
	if err := w.ReadData(&o.LastMemQueryCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.OtherQuerierPresentInterval); err != nil {
		return err
	}
	if err := w.ReadData(&o.GroupMembershipTimeout); err != nil {
		return err
	}
	if err := w.ReadData(&o.StaticGroupsLength); err != nil {
		return err
	}
	return nil
}

// IGMPMIBInterfaceGroupsList structure represents IGMP_MIB_IF_GROUPS_LIST RPC structure.
//
// The IGMP_MIB_IF_GROUPS_LIST structure is an MIB entry that stores the list of multicast
// groups that are members of that interface. This structure has variable length. The
// structure is followed by NumGroups number of IGMP_MIB_GROUP_INFO (section 2.2.1.2.176)
// structures.
type IGMPMIBInterfaceGroupsList struct {
	// IfIndex: Index of the interface
	InterfaceIndex uint32 `idl:"name:IfIndex" json:"interface_index"`
	// IpAddr: IP address of the interface
	IPAddr uint32 `idl:"name:IpAddr" json:"ip_addr"`
	// IfType: Type of the interface, MUST be one of the following values.
	//
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	|                               |                                                                                  |
	//	|             VALUE             |                                     MEANING                                      |
	//	|                               |                                                                                  |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_IF_NOT_RAS 0x00000001    | The interface is connected to a LAN                                              |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_IF_RAS_ROUTER 0x00000002 | The interface is connected to another router over RAS                            |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_IF_RAS_SERVER 0x00000003 | The entry corresponds to a RAS server if it contains stats, then it represents   |
	//	|                               | summarized stats                                                                 |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_IF_RAS_CLIENT 0x00000004 | The entry corresponds to a RAS client                                            |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_IF_PROXY 0x00000008      | then one of the 1st 4 flags still will be set to enable switch from proxy to     |
	//	|                               | IGMP router                                                                      |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	InterfaceType uint32 `idl:"name:IfType" json:"interface_type"`
	// NumGroups: Number of IGMP_MIB_GROUP_INFO structures
	GroupsLength uint32 `idl:"name:NumGroups" json:"groups_length"`
	// Buffer: MUST point to IGMP_MIB_GROUP_INFO.
	Buffer []byte `idl:"name:Buffer" json:"buffer"`
}

func (o *IGMPMIBInterfaceGroupsList) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IGMPMIBInterfaceGroupsList) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.InterfaceIndex); err != nil {
		return err
	}
	if err := w.WriteData(o.IPAddr); err != nil {
		return err
	}
	if err := w.WriteData(o.InterfaceType); err != nil {
		return err
	}
	if err := w.WriteData(o.GroupsLength); err != nil {
		return err
	}
	for i1 := range o.Buffer {
		i1 := i1
		if uint64(i1) >= 1 {
			break
		}
		if err := w.WriteData(o.Buffer[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Buffer); uint64(i1) < 1; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteTrailingGap(4); err != nil {
		return err
	}
	return nil
}
func (o *IGMPMIBInterfaceGroupsList) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.InterfaceIndex); err != nil {
		return err
	}
	if err := w.ReadData(&o.IPAddr); err != nil {
		return err
	}
	if err := w.ReadData(&o.InterfaceType); err != nil {
		return err
	}
	if err := w.ReadData(&o.GroupsLength); err != nil {
		return err
	}
	o.Buffer = make([]byte, 1)
	for i1 := range o.Buffer {
		i1 := i1
		if err := w.ReadData(&o.Buffer[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadTrailingGap(4); err != nil {
		return err
	}
	return nil
}

// IGMPMIBGroupInfo structure represents IGMP_MIB_GROUP_INFO RPC structure.
//
// The IGMP_MIB_GROUP_INFO structure is used in the IGMP_MIB_IF_GROUPS_LIST (section
// 2.2.1.2.175) structure. If the interface is of type IGMP_IF_RAS_SERVER then the group
// membership of all the RAS clients is summarized, and the GroupUpTime and GroupExpiryTime
// is the maximum over all member RAS clients, while the V1HostPresentTimeLeft is set
// to 0. If the interface is of type IGMP_IF_RAS_CLIENT, the IpAddr is the next hop
// IP address of the RAS client.
type IGMPMIBGroupInfo struct {
	Field1 *IGMPMIBGroupInfo_Field1 `idl:"name:" json:""`
	// IpAddr: The IP address of the interface.
	IPAddr uint32 `idl:"name:IpAddr" json:"ip_addr"`
	// GroupUpTime: The time, in seconds, since the group is up.
	GroupUpTime uint32 `idl:"name:GroupUpTime" json:"group_up_time"`
	// GroupExpiryTime: The time, in seconds, before the group expires.
	GroupExpiryTime uint32 `idl:"name:GroupExpiryTime" json:"group_expiry_time"`
	// LastReporter: The IP address of the last reporter.
	LastReporter uint32 `idl:"name:LastReporter" json:"last_reporter"`
	// V1HostPresentTimeLeft: The time left for the present IGMPv1 hosts.
	V1HostPresentTimeLeft uint32 `idl:"name:V1HostPresentTimeLeft" json:"v1_host_present_time_left"`
	// Flags: It MUST be one of the following values.
	//
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	|                                       |                                                                                  |
	//	|                 VALUE                 |                                     MEANING                                      |
	//	|                                       |                                                                                  |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_GROUP_TYPE_NON_STATIC 0x00000001 | The IGMP group is not static.                                                    |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_GROUP_TYPE_STATIC 0x00000002     | The IGMP group is static.                                                        |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_GROUP_FWD_TO_MGM 0x00000004      | The IGMP group needs to be forwarded to the multiple multicast routing           |
	//	|                                       | protocols.                                                                       |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_GROUP_ALLOW 0x00000010           | Allows IGMP groups.                                                              |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_GROUP_BLOCK 0x00000020           | Blocks IGMP groups.                                                              |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_GROUP_NO_STATE 0x00000040        | There is no IGMP group state.                                                    |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	Flags uint32 `idl:"name:Flags" json:"flags"`
}

func (o *IGMPMIBGroupInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IGMPMIBGroupInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	// FIXME unknown type
	if err := w.WriteData(o.IPAddr); err != nil {
		return err
	}
	if err := w.WriteData(o.GroupUpTime); err != nil {
		return err
	}
	if err := w.WriteData(o.GroupExpiryTime); err != nil {
		return err
	}
	if err := w.WriteData(o.LastReporter); err != nil {
		return err
	}
	if err := w.WriteData(o.V1HostPresentTimeLeft); err != nil {
		return err
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	return nil
}
func (o *IGMPMIBGroupInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	// FIXME: unknown type
	if err := w.ReadData(&o.IPAddr); err != nil {
		return err
	}
	if err := w.ReadData(&o.GroupUpTime); err != nil {
		return err
	}
	if err := w.ReadData(&o.GroupExpiryTime); err != nil {
		return err
	}
	if err := w.ReadData(&o.LastReporter); err != nil {
		return err
	}
	if err := w.ReadData(&o.V1HostPresentTimeLeft); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	return nil
}

type IGMPMIBGroupInfo_Field1 struct {
	InterfaceIndex uint32 `idl:"name:IfIndex" json:"interface_index"`
	// IfIndex/ GroupAddr: The index of the interface or group address.
	GroupAddr uint32 `idl:"name:GroupAddr" json:"group_addr"`
}

// IGMPMIBInterfaceStats structure represents IGMP_MIB_IF_STATS RPC structure.
//
// The IGMP_MIB_IF_STATS structure contains statistics about an interface.
type IGMPMIBInterfaceStats struct {
	// IfIndex: The index of the interface.
	InterfaceIndex uint32 `idl:"name:IfIndex" json:"interface_index"`
	// IpAddr: The IP address of the interface. If the interface is a RAS interface, then
	// the IpAddr is set to the NextHopAddress of the RAS client.
	IPAddr uint32 `idl:"name:IpAddr" json:"ip_addr"`
	// IfType: The type of the interface. It MUST be one of the following values.
	//
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	|                               |                                                                                  |
	//	|             VALUE             |                                     MEANING                                      |
	//	|                               |                                                                                  |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_IF_NOT_RAS 0x00000001    | The interface is connected to a LAN.                                             |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_IF_RAS_ROUTER 0x00000002 | The interface is connected to another router over RAS.                           |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_IF_RAS_SERVER 0x00000003 | The entry corresponds to a RAS server if it contains statistics and it           |
	//	|                               | represents summary statistics.                                                   |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_IF_RAS_CLIENT 0x00000004 | The entry corresponds to a RAS client.                                           |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_IF_PROXY 0x00000008      | The interface is an IGMP PROXY. One of the first four flags will still be set to |
	//	|                               | enable the switch from the proxy to the IGMP router.                             |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	InterfaceType uint32 `idl:"name:IfType" json:"interface_type"`
	// State: It MUST be a combination of one or more of the following values.
	//
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	|                                   |                                                                                  |
	//	|               VALUE               |                                     MEANING                                      |
	//	|                                   |                                                                                  |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_STATE_BOUND 0x01             | The socket is bound.                                                             |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_STATE_ENABLED_BY_RTRMGR 0x02 | The interface is enabled by router.                                              |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_STATE_ENABLED_IN_CONFIG 0x04 | The interface is enabled in the configuration.                                   |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_STATE_ENABLED_BY_MGM 0x08    | The interface is enabled by component that aggregates multiple routing           |
	//	|                                   | protocols.                                                                       |
	//	+-----------------------------------+----------------------------------------------------------------------------------+
	State uint8 `idl:"name:State" json:"state"`
	// QuerierState: It MUST be one of the following.
	//
	//	+----------------------+----------------------------------------+
	//	|                      |                                        |
	//	|        VALUE         |                MEANING                 |
	//	|                      |                                        |
	//	+----------------------+----------------------------------------+
	//	+----------------------+----------------------------------------+
	//	| RTR_QUERIER 0x10     | The interface is the IGMP querier.     |
	//	+----------------------+----------------------------------------+
	//	| RTR_NOT_QUERIER 0x00 | The interface is not the IGMP querier. |
	//	+----------------------+----------------------------------------+
	QuerierState uint8 `idl:"name:QuerierState" json:"querier_state"`
	// IgmpProtocolType: Takes one of the following values.
	//
	//	+---------------------------+----------------------------------------------------------------------------------+
	//	|                           |                                                                                  |
	//	|           VALUE           |                                     MEANING                                      |
	//	|                           |                                                                                  |
	//	+---------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_PROXY 0x00000000     | The interface is an IGMPv2 proxy. Specifies that the IGMPv2 proxy mode is        |
	//	|                           | enabled on this interface. An interface in IGMP proxy mode acts as a host,       |
	//	|                           | forwarding the IGMP host membership messages for all the IGMP host membership    |
	//	|                           | messages received on all other interfaces on which the IGMP router mode is       |
	//	|                           | enabled. Additionally, all nonlocal multicast traffic received on all other      |
	//	|                           | interfaces (on which the IGMP router mode is enabled) is forwarded over the IGMP |
	//	|                           | proxy mode interface.                                                            |
	//	+---------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_ROUTER_V1 0x00000001 | The interface is an IGMPv1 router. Specifies that IGMPv1 router mode is enabled  |
	//	|                           | on this interface. An interface in IGMP router mode listens for IGMP messages    |
	//	|                           | from hosts and updates the TCP/IP multicast forwarding table.                    |
	//	+---------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_ROUTER_V2 0x00000002 | The interface is an IGMPv2 router. Specifies that IGMPv2 router mode is enabled  |
	//	|                           | on this interface. An interface in IGMP router mode listens for IGMP messages    |
	//	|                           | from hosts and updates the TCP/IP multicast forwarding table.                    |
	//	+---------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_ROUTER_V3 0x00000003 | The interface is an IGMPv3 router. Specifies that IGMPv3 router mode is enabled  |
	//	|                           | on this interface. An interface in IGMP router mode listens for IGMP messages    |
	//	|                           | from hosts and updates the TCP/IP multicast forwarding table.                    |
	//	+---------------------------+----------------------------------------------------------------------------------+
	//	| IGMP_PROXY_V3 0x00000010  | The interface is an IGMPv3 proxy. Specifies that IGMPv3 proxy mode is enabled    |
	//	|                           | on this interface. An interface in IGMP proxy mode acts as a host, forwarding    |
	//	|                           | IGMP host membership messages for all IGMP host membership messages received     |
	//	|                           | on all other interfaces on which IGMP router mode is enabled. Additionally,      |
	//	|                           | all nonlocal multicast traffic received on all other interfaces (on which IGMP   |
	//	|                           | router mode is enabled) is forwarded over the IGMP proxy mode interface.         |
	//	+---------------------------+----------------------------------------------------------------------------------+
	IGMPProtocolType uint32 `idl:"name:IgmpProtocolType" json:"igmp_protocol_type"`
	// QuerierIpAddr: The IP address of the querier.
	QuerierIPAddr uint32 `idl:"name:QuerierIpAddr" json:"querier_ip_addr"`
	// ProxyIfIndex: The IfIndex of the IGMP proxy.
	ProxyInterfaceIndex uint32 `idl:"name:ProxyIfIndex" json:"proxy_interface_index"`
	// QuerierPresentTimeLeft: If no IGMPv2 queries are heard on this interface within this
	// interval, the local router will take over the querier on the IP subnet to which this
	// interface is attached.
	QuerierPresentTimeLeft uint32 `idl:"name:QuerierPresentTimeLeft" json:"querier_present_time_left"`
	// LastQuerierChangeTime: The number of seconds since QuerierIpAddr was last changed.
	LastQuerierChangeTime uint32 `idl:"name:LastQuerierChangeTime" json:"last_querier_change_time"`
	// V1QuerierPresentTimeLeft: The time remaining until the host assumes that there are
	// no IGMPv1 routers present on the interface. While this is nonzero, the host will
	// reply to all queries with version 1 membership reports.
	V1QuerierPresentTimeLeft uint32 `idl:"name:V1QuerierPresentTimeLeft" json:"v1_querier_present_time_left"`
	// Uptime: The time, in seconds, the interface has been activated.
	UpTime uint32 `idl:"name:Uptime" json:"up_time"`
	// TotalIgmpPacketsReceived: The total IGMP packets received.
	TotalIGMPPacketsReceived uint32 `idl:"name:TotalIgmpPacketsReceived" json:"total_igmp_packets_received"`
	// TotalIgmpPacketsForRouter: The total IGMP packets received for a router.
	TotalIGMPPacketsForRouter uint32 `idl:"name:TotalIgmpPacketsForRouter" json:"total_igmp_packets_for_router"`
	// GeneralQueriesReceived: The total queries received.
	GeneralQueriesReceived uint32 `idl:"name:GeneralQueriesReceived" json:"general_queries_received"`
	// WrongVersionQueries: The count of wrong version queries received.
	WrongVersionQueries uint32 `idl:"name:WrongVersionQueries" json:"wrong_version_queries"`
	// JoinsReceived: The count of IGMP joins received.
	JoinsReceived uint32 `idl:"name:JoinsReceived" json:"joins_received"`
	// LeavesReceived: The count of IGMP leaved received.
	LeavesReceived uint32 `idl:"name:LeavesReceived" json:"leaves_received"`
	// CurrentGroupMemberships: The count of current group memberships.
	CurrentGroupMemberships uint32 `idl:"name:CurrentGroupMemberships" json:"current_group_memberships"`
	// GroupMembershipsAdded: The count of group memberships received.
	GroupMembershipsAdded uint32 `idl:"name:GroupMembershipsAdded" json:"group_memberships_added"`
	// WrongChecksumPackets: The count of packets with wrong checksum received.
	WrongChecksumPackets uint32 `idl:"name:WrongChecksumPackets" json:"wrong_checksum_packets"`
	// ShortPacketsReceived: The count of short packets received.
	ShortPacketsReceived uint32 `idl:"name:ShortPacketsReceived" json:"short_packets_received"`
	// LongPacketsReceived: The count of long packets received.
	LongPacketsReceived uint32 `idl:"name:LongPacketsReceived" json:"long_packets_received"`
	// PacketsWithoutRtrAlert: The count of packets with router alerts received.
	PacketsWithoutRouterAlert uint32 `idl:"name:PacketsWithoutRtrAlert" json:"packets_without_router_alert"`
}

func (o *IGMPMIBInterfaceStats) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IGMPMIBInterfaceStats) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.InterfaceIndex); err != nil {
		return err
	}
	if err := w.WriteData(o.IPAddr); err != nil {
		return err
	}
	if err := w.WriteData(o.InterfaceType); err != nil {
		return err
	}
	if err := w.WriteData(o.State); err != nil {
		return err
	}
	if err := w.WriteData(o.QuerierState); err != nil {
		return err
	}
	if err := w.WriteData(o.IGMPProtocolType); err != nil {
		return err
	}
	if err := w.WriteData(o.QuerierIPAddr); err != nil {
		return err
	}
	if err := w.WriteData(o.ProxyInterfaceIndex); err != nil {
		return err
	}
	if err := w.WriteData(o.QuerierPresentTimeLeft); err != nil {
		return err
	}
	if err := w.WriteData(o.LastQuerierChangeTime); err != nil {
		return err
	}
	if err := w.WriteData(o.V1QuerierPresentTimeLeft); err != nil {
		return err
	}
	if err := w.WriteData(o.UpTime); err != nil {
		return err
	}
	if err := w.WriteData(o.TotalIGMPPacketsReceived); err != nil {
		return err
	}
	if err := w.WriteData(o.TotalIGMPPacketsForRouter); err != nil {
		return err
	}
	if err := w.WriteData(o.GeneralQueriesReceived); err != nil {
		return err
	}
	if err := w.WriteData(o.WrongVersionQueries); err != nil {
		return err
	}
	if err := w.WriteData(o.JoinsReceived); err != nil {
		return err
	}
	if err := w.WriteData(o.LeavesReceived); err != nil {
		return err
	}
	if err := w.WriteData(o.CurrentGroupMemberships); err != nil {
		return err
	}
	if err := w.WriteData(o.GroupMembershipsAdded); err != nil {
		return err
	}
	if err := w.WriteData(o.WrongChecksumPackets); err != nil {
		return err
	}
	if err := w.WriteData(o.ShortPacketsReceived); err != nil {
		return err
	}
	if err := w.WriteData(o.LongPacketsReceived); err != nil {
		return err
	}
	if err := w.WriteData(o.PacketsWithoutRouterAlert); err != nil {
		return err
	}
	return nil
}
func (o *IGMPMIBInterfaceStats) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.InterfaceIndex); err != nil {
		return err
	}
	if err := w.ReadData(&o.IPAddr); err != nil {
		return err
	}
	if err := w.ReadData(&o.InterfaceType); err != nil {
		return err
	}
	if err := w.ReadData(&o.State); err != nil {
		return err
	}
	if err := w.ReadData(&o.QuerierState); err != nil {
		return err
	}
	if err := w.ReadData(&o.IGMPProtocolType); err != nil {
		return err
	}
	if err := w.ReadData(&o.QuerierIPAddr); err != nil {
		return err
	}
	if err := w.ReadData(&o.ProxyInterfaceIndex); err != nil {
		return err
	}
	if err := w.ReadData(&o.QuerierPresentTimeLeft); err != nil {
		return err
	}
	if err := w.ReadData(&o.LastQuerierChangeTime); err != nil {
		return err
	}
	if err := w.ReadData(&o.V1QuerierPresentTimeLeft); err != nil {
		return err
	}
	if err := w.ReadData(&o.UpTime); err != nil {
		return err
	}
	if err := w.ReadData(&o.TotalIGMPPacketsReceived); err != nil {
		return err
	}
	if err := w.ReadData(&o.TotalIGMPPacketsForRouter); err != nil {
		return err
	}
	if err := w.ReadData(&o.GeneralQueriesReceived); err != nil {
		return err
	}
	if err := w.ReadData(&o.WrongVersionQueries); err != nil {
		return err
	}
	if err := w.ReadData(&o.JoinsReceived); err != nil {
		return err
	}
	if err := w.ReadData(&o.LeavesReceived); err != nil {
		return err
	}
	if err := w.ReadData(&o.CurrentGroupMemberships); err != nil {
		return err
	}
	if err := w.ReadData(&o.GroupMembershipsAdded); err != nil {
		return err
	}
	if err := w.ReadData(&o.WrongChecksumPackets); err != nil {
		return err
	}
	if err := w.ReadData(&o.ShortPacketsReceived); err != nil {
		return err
	}
	if err := w.ReadData(&o.LongPacketsReceived); err != nil {
		return err
	}
	if err := w.ReadData(&o.PacketsWithoutRouterAlert); err != nil {
		return err
	}
	return nil
}

// IGMPMIBGroupInterfacesList structure represents IGMP_MIB_GROUP_IFS_LIST RPC structure.
//
// The IGMP_MIB_GROUP_IFS_LIST structure is an MIB entry and stores the list of interfaces
// that have received joins for that group. This structure has variable length. The
// structure is followed by the NumInterfaces number of structures of type IGMP_MIB_GROUP_INFO
// or IGMP_MIB_GROUP_INFO_V3.
//
// This structure is read only.
//
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| GroupAddr                                                                                                                     |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| NumInterfaces                                                                                                                 |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| Buffer (variable)                                                                                                             |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
type IGMPMIBGroupInterfacesList struct {
	// GroupAddr (4 bytes): The address of the IGMP group.
	GroupAddr uint32 `idl:"name:GroupAddr" json:"group_addr"`
	// NumInterfaces (4 bytes): The number of structures in the buffer.
	InterfacesLength uint32 `idl:"name:NumInterfaces" json:"interfaces_length"`
	// Buffer (variable): If IGMP_ENUM_FORMAT_IGMPV3 is set, then Flags of IGMP_MIB_GET_OUTPUT_DATA
	// contains IGMP_MIB_GROUP_INFO_V3 structures. Otherwise, it contains IGMP_MIB_GROUP_INFO
	// structures.
	Buffer []byte `idl:"name:Buffer" json:"buffer"`
}

func (o *IGMPMIBGroupInterfacesList) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IGMPMIBGroupInterfacesList) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.GroupAddr); err != nil {
		return err
	}
	if err := w.WriteData(o.InterfacesLength); err != nil {
		return err
	}
	for i1 := range o.Buffer {
		i1 := i1
		if uint64(i1) >= 1 {
			break
		}
		if err := w.WriteData(o.Buffer[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Buffer); uint64(i1) < 1; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteTrailingGap(4); err != nil {
		return err
	}
	return nil
}
func (o *IGMPMIBGroupInterfacesList) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.GroupAddr); err != nil {
		return err
	}
	if err := w.ReadData(&o.InterfacesLength); err != nil {
		return err
	}
	o.Buffer = make([]byte, 1)
	for i1 := range o.Buffer {
		i1 := i1
		if err := w.ReadData(&o.Buffer[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadTrailingGap(4); err != nil {
		return err
	}
	return nil
}

// IGMPMIBGroupSourceInfoV3 structure represents IGMP_MIB_GROUP_SOURCE_INFO_V3 RPC structure.
//
// The IGMP_MIB_GROUP_SOURCE_INFO_V3 structure provides information about each source
// IP endpoint.
type IGMPMIBGroupSourceInfoV3 struct {
	// Source: IP endpoint address of a source.
	Source uint32 `idl:"name:Source" json:"source"`
	// SourceExpiryTime: The time, in seconds, that remains before source expires. Not valid
	// for exclusion mode.
	SourceExpiryTime uint32 `idl:"name:SourceExpiryTime" json:"source_expiry_time"`
	// SourceUpTime: The time, in seconds since the source was up.
	SourceUpTime uint32 `idl:"name:SourceUpTime" json:"source_up_time"`
	// Flags: Reserved. This is unused and SHOULD be NULL, or MAY be set to 0x00000000.
	Flags uint32 `idl:"name:Flags" json:"flags"`
}

func (o *IGMPMIBGroupSourceInfoV3) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IGMPMIBGroupSourceInfoV3) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Source); err != nil {
		return err
	}
	if err := w.WriteData(o.SourceExpiryTime); err != nil {
		return err
	}
	if err := w.WriteData(o.SourceUpTime); err != nil {
		return err
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	return nil
}
func (o *IGMPMIBGroupSourceInfoV3) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Source); err != nil {
		return err
	}
	if err := w.ReadData(&o.SourceExpiryTime); err != nil {
		return err
	}
	if err := w.ReadData(&o.SourceUpTime); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	return nil
}

// IGMPMIBGroupInfoV3 structure represents IGMP_MIB_GROUP_INFO_V3 RPC structure.
//
// The IGMP_MIB_GROUP_INFO_V3 provides information about a group.
type IGMPMIBGroupInfoV3 struct {
	Field1 *IGMPMIBGroupInfoV3_Field1 `idl:"name:" json:""`
	// IpAddr: The IP address of the interface.
	IPAddr uint32 `idl:"name:IpAddr" json:"ip_addr"`
	// GroupUpTime: The time, in seconds, since the group membership was up.
	GroupUpTime uint32 `idl:"name:GroupUpTime" json:"group_up_time"`
	// GroupExpiryTime: The time, in seconds, before the group membership expires.
	GroupExpiryTime uint32 `idl:"name:GroupExpiryTime" json:"group_expiry_time"`
	// LastReporter: The IP address of the source of the last membership report received
	// for this IP multicast group address on this interface. If no membership report has
	// been received, this object has the value 0.0.0.0.
	LastReporter uint32 `idl:"name:LastReporter" json:"last_reporter"`
	// V1HostPresentTimeLeft: The time remaining until the local router will assume that
	// there are no longer any IGMP version 1 members on the IP subnet attached to this
	// interface. Upon hearing any IGMPv1 membership report, this value is reset to the
	// group membership timer. While this time remaining is nonzero, the local router ignores
	// any IGMPv1 leave messages for this group that it receives on this interface.
	V1HostPresentTimeLeft uint32 `idl:"name:V1HostPresentTimeLeft" json:"v1_host_present_time_left"`
	// Flags: This MUST be 0x1000 if IGMPv3 information is available and a IGMP_MIB_GROUP_INFO_V3
	// structure MUST be used. All other values have no meaning.
	Flags uint32 `idl:"name:Flags" json:"flags"`
	// Version: The IGMP version. It MUST be 3.
	Version uint32 `idl:"name:Version" json:"version"`
	// Size: The size of the structure.
	Size uint32 `idl:"name:Size" json:"size"`
	// FilterType: Indicates whether the sources specified need to be included or excluded.
	// It MUST be either EXCLUSION (0x00000000) or INCLUSION (0x00000001).
	FilterType uint32 `idl:"name:FilterType" json:"filter_type"`
	// V2HostPresentTimeLeft: The time remaining until the local router will assume that
	// there are no longer any IGMP version 2 members on the IP subnet attached to this
	// interface. Upon hearing any IGMPv2 membership report, this value is reset to the
	// group membership timer. While this time remaining is nonzero, the local router ignores
	// any IGMPv2 leave messages for this group that it receives on this interface.
	V2HostPresentTimeLeft uint32 `idl:"name:V2HostPresentTimeLeft" json:"v2_host_present_time_left"`
	// NumSources: The number of entries of IGMP_MIB_GROUP_SOURCE_INFO_V3.
	SourcesLength uint32 `idl:"name:NumSources" json:"sources_length"`
}

func (o *IGMPMIBGroupInfoV3) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IGMPMIBGroupInfoV3) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	// FIXME unknown type
	if err := w.WriteData(o.IPAddr); err != nil {
		return err
	}
	if err := w.WriteData(o.GroupUpTime); err != nil {
		return err
	}
	if err := w.WriteData(o.GroupExpiryTime); err != nil {
		return err
	}
	if err := w.WriteData(o.LastReporter); err != nil {
		return err
	}
	if err := w.WriteData(o.V1HostPresentTimeLeft); err != nil {
		return err
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	if err := w.WriteData(o.Version); err != nil {
		return err
	}
	if err := w.WriteData(o.Size); err != nil {
		return err
	}
	if err := w.WriteData(o.FilterType); err != nil {
		return err
	}
	if err := w.WriteData(o.V2HostPresentTimeLeft); err != nil {
		return err
	}
	if err := w.WriteData(o.SourcesLength); err != nil {
		return err
	}
	return nil
}
func (o *IGMPMIBGroupInfoV3) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	// FIXME: unknown type
	if err := w.ReadData(&o.IPAddr); err != nil {
		return err
	}
	if err := w.ReadData(&o.GroupUpTime); err != nil {
		return err
	}
	if err := w.ReadData(&o.GroupExpiryTime); err != nil {
		return err
	}
	if err := w.ReadData(&o.LastReporter); err != nil {
		return err
	}
	if err := w.ReadData(&o.V1HostPresentTimeLeft); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	if err := w.ReadData(&o.Version); err != nil {
		return err
	}
	if err := w.ReadData(&o.Size); err != nil {
		return err
	}
	if err := w.ReadData(&o.FilterType); err != nil {
		return err
	}
	if err := w.ReadData(&o.V2HostPresentTimeLeft); err != nil {
		return err
	}
	if err := w.ReadData(&o.SourcesLength); err != nil {
		return err
	}
	return nil
}

type IGMPMIBGroupInfoV3_Field1 struct {
	// IfIndex: The interface for which this entry contains information for an IP multicast
	// group address.
	InterfaceIndex uint32 `idl:"name:IfIndex" json:"interface_index"`
	// GroupAddr: The IP multicast group address for which this entry contains information.
	GroupAddr uint32 `idl:"name:GroupAddr" json:"group_addr"`
}

// InterfaceRouteEntry structure represents INTERFACE_ROUTE_ENTRY RPC structure.
//
// The INTERFACE_ROUTE_ENTRY structure is used to store and retrieve entries of the
// IPv6 ForwardRow based on the dwIndex.
type InterfaceRouteEntry struct {
	// dwIndex: The index to the table of INTERFACE_ROUTE_INFO structures defined on RRAS.
	Index uint32 `idl:"name:dwIndex" json:"index"`
	// routeInfo: This MUST be INTERFACE_ROUTE_INFO.
	RouteInfo *InterfaceRouteInfo `idl:"name:routeInfo" json:"route_info"`
}

func (o *InterfaceRouteEntry) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *InterfaceRouteEntry) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Index); err != nil {
		return err
	}
	if o.RouteInfo != nil {
		if err := o.RouteInfo.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&InterfaceRouteInfo{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *InterfaceRouteEntry) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Index); err != nil {
		return err
	}
	if o.RouteInfo == nil {
		o.RouteInfo = &InterfaceRouteInfo{}
	}
	if err := o.RouteInfo.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// IPNATMIBQuery structure represents IP_NAT_MIB_QUERY RPC structure.
//
// The IP_NAT_MIB_QUERY structure is used to retrieve Network Address Translator (NAT)
// information and is passed to the following methods:
//
// * *RMIBEntryGet (section 3.1.4.30)* ( ebc5c709-36d8-4520-a0ac-6f36d2d6c0b2 )
//
// * *RMIBEntryGetFirst* (section 3.1.4.31 ( 9102e585-2f62-4408-bfb6-02a6460cc883 )
// )
//
// * *RMIBEntryGetNext (section 3.1.4.32)* ( 50f78033-d248-4272-b4b9-a2519a0f304d )
//
// typedef struct _IP_NAT_MIB_QUERY {
//
// ULONG Oid;
//
// union {
//
// ULONG Index;
//
// UCHAR Data;
//
// };
//
// } IP_NAT_MIB_QUERY,
type IPNATMIBQuery struct {
	// Oid: This is an index of the NAT MIB. It MUST be one of the following values.
	//
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                               |                                                                                  |
	//	|                     VALUE                     |                                     MEANING                                      |
	//	|                                               |                                                                                  |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_NAT_INTERFACE_STATISTICS_OID 0x00000000    | NAT interface statistics information is retrieved. When RMIBEntryGet,            |
	//	|                                               | RMIBEntryGetFirst, and RMIBEntryGetNext return pMibOutEntry or pInfoStruct it    |
	//	|                                               | MUST be typecast to IP_NAT_INTERFACE_STATISTICS (section 2.2.1.2.185).           |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_NAT_INTERFACE_MAPPING_TABLE_OID 0x00000001 | NAT interface mapping table information. When RMIBEntryGet, RMIBEntryGetFirst,   |
	//	|                                               | and RMIBEntryGetNext return pMibOutEntry or pInfoStruct it MUST be typecast to   |
	//	|                                               | IP_NAT_ENUMERATE_SESSION_MAPPINGS (section 2.2.1.2.183).                         |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_NAT_MAPPING_TABLE_OID 0x00000002           | NAT mapping table information. Retrieves the session mappings of an interface.   |
	//	|                                               | When RMIBEntryGet, RMIBEntryGetFirst, and RMIBEntryGetNext return pMibOutEntry   |
	//	|                                               | or pInfoStruct it MUST be typecast to IP_NAT_ENUMERATE_SESSION_MAPPINGS.         |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	OID    uint32                `idl:"name:Oid" json:"oid"`
	Field2 *IPNATMIBQuery_Field2 `idl:"name:" json:""`
}

func (o *IPNATMIBQuery) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPNATMIBQuery) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.OID); err != nil {
		return err
	}
	// FIXME unknown type
	return nil
}
func (o *IPNATMIBQuery) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.OID); err != nil {
		return err
	}
	// FIXME: unknown type
	return nil
}

type IPNATMIBQuery_Field2 struct {
	// Index: This MUST be the index of the interface when Oid is 0x00000000.
	Index uint32 `idl:"name:Index" json:"index"`
	// Data: This MUST be IP_NAT_ENUMERATE_SESSION_MAPPINGS if Oid is not 0x00000000.
	Data uint8 `idl:"name:Data" json:"data"`
}

// IPNATDirection type represents IP_NAT_DIRECTION RPC enumeration.
//
// The IP_NAT_DIRECTION enumeration contains Network Address Translator (NAT) directions.
type IPNATDirection uint16

var (
	// NatInboundDirection: The packet was received from a public address and is to be sent
	// to private address.
	IpnatDirectionNATInboundDirection IPNATDirection = 0
	// NatOutboundDirection: The packet was received from a private address and is to be
	// sent to public address.
	IpnatDirectionNATOutboundDirection IPNATDirection = 1
)

func (o IPNATDirection) String() string {
	switch o {
	case IpnatDirectionNATInboundDirection:
		return "IpnatDirectionNATInboundDirection"
	case IpnatDirectionNATOutboundDirection:
		return "IpnatDirectionNATOutboundDirection"
	}
	return "Invalid"
}

// IPNATSessionMapping structure represents IP_NAT_SESSION_MAPPING RPC structure.
//
// The IP_NAT_SESSION_MAPPING structure holds information for a single NAT mapping and
// is part of IP_NAT_ENUMERATE_SESSION_MAPPINGS (section 2.2.1.2.183).
type IPNATSessionMapping struct {
	// Protocol: This MUST be one of the following.
	//
	//	+-----------------------------+---------------+
	//	|                             |               |
	//	|            VALUE            |    MEANING    |
	//	|                             |               |
	//	+-----------------------------+---------------+
	//	+-----------------------------+---------------+
	//	| NAT_PROTOCOL_ICMP 0x01      | ICMP Protocol |
	//	+-----------------------------+---------------+
	//	| NAT_PROTOCOL_IGMP 0x02      | IGMP Protocol |
	//	+-----------------------------+---------------+
	//	| NAT_PROTOCOL_TCP 0x06       | TCP Protocol  |
	//	+-----------------------------+---------------+
	//	| NAT_PROTOCOL_UDP 0x11       | UDP Protocol  |
	//	+-----------------------------+---------------+
	//	| NAT_PROTOCOL_IP6IN4 0x29    | IPv6 in IPv4  |
	//	+-----------------------------+---------------+
	//	| NAT_PROTOCOL_PPTP 0x2F      | PPTP Protocol |
	//	+-----------------------------+---------------+
	//	| NAT_PROTOCOL_IPSEC_ESP 0x32 | IPSec ESP     |
	//	+-----------------------------+---------------+
	//	| NAT_PROTOCOL_IPSEC_AH 0x33  | IPSec AH      |
	//	+-----------------------------+---------------+
	//	| NAT_PROTOCOL_PGM 0x71       | PGM           |
	//	+-----------------------------+---------------+
	Protocol uint8 `idl:"name:Protocol" json:"protocol"`
	// PrivateAddress: The private address of the NAT entry.
	PrivateAddress uint32 `idl:"name:PrivateAddress" json:"private_address"`
	// PrivatePort: The private port of the NAT entry.
	PrivatePort uint16 `idl:"name:PrivatePort" json:"private_port"`
	// PublicAddress: The public address of the NAT entry.
	PublicAddress uint32 `idl:"name:PublicAddress" json:"public_address"`
	// PublicPort: The public port of the NAT entry
	PublicPort uint16 `idl:"name:PublicPort" json:"public_port"`
	// RemoteAddress: The remote address of the NAT entry.
	RemoteAddress uint32 `idl:"name:RemoteAddress" json:"remote_address"`
	// RemotePort: The remote port of the NAT entry.
	RemotePort uint16 `idl:"name:RemotePort" json:"remote_port"`
	// Direction: This MUST be IP_NAT_DIRECTION.
	Direction IPNATDirection `idl:"name:Direction" json:"direction"`
	// IdleTime: The time, in seconds, since the last packet matching this entry was sent
	// or received.
	IdleTime uint32 `idl:"name:IdleTime" json:"idle_time"`
}

func (o *IPNATSessionMapping) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPNATSessionMapping) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Protocol); err != nil {
		return err
	}
	if err := w.WriteData(o.PrivateAddress); err != nil {
		return err
	}
	if err := w.WriteData(o.PrivatePort); err != nil {
		return err
	}
	if err := w.WriteData(o.PublicAddress); err != nil {
		return err
	}
	if err := w.WriteData(o.PublicPort); err != nil {
		return err
	}
	if err := w.WriteData(o.RemoteAddress); err != nil {
		return err
	}
	if err := w.WriteData(o.RemotePort); err != nil {
		return err
	}
	if err := w.WriteEnum(uint16(o.Direction)); err != nil {
		return err
	}
	if err := w.WriteData(o.IdleTime); err != nil {
		return err
	}
	return nil
}
func (o *IPNATSessionMapping) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Protocol); err != nil {
		return err
	}
	if err := w.ReadData(&o.PrivateAddress); err != nil {
		return err
	}
	if err := w.ReadData(&o.PrivatePort); err != nil {
		return err
	}
	if err := w.ReadData(&o.PublicAddress); err != nil {
		return err
	}
	if err := w.ReadData(&o.PublicPort); err != nil {
		return err
	}
	if err := w.ReadData(&o.RemoteAddress); err != nil {
		return err
	}
	if err := w.ReadData(&o.RemotePort); err != nil {
		return err
	}
	if err := w.ReadEnum((*uint16)(&o.Direction)); err != nil {
		return err
	}
	if err := w.ReadData(&o.IdleTime); err != nil {
		return err
	}
	return nil
}

// IPNATEnumerateSessionMappings structure represents IP_NAT_ENUMERATE_SESSION_MAPPINGS RPC structure.
//
// The IP_NAT_ENUMERATE_SESSION_MAPPINGS structure is used for enumerating NAT session
// mappings and is part of the IP_NAT_MIB_QUERY (section 2.2.1.2.182) structure.
//
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| Index                                                                                                                         |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| EnumerateContext (16 bytes)                                                                                                   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| EnumerateCount                                                                                                                |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| EnumerateTotalHint                                                                                                            |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| EnumerateTable (variable)                                                                                                     |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
type IPNATEnumerateSessionMappings struct {
	// Index (4 bytes): This MUST be the index of the interface.
	Index uint32 `idl:"name:Index" json:"index"`
	// EnumerateContext (16 bytes): This is represented by an array of 4 ULONG values. On
	// the first call to RMIBEntryGet (section 3.1.4.30) or RMIBEntryGetFirst (section 3.1.4.31)
	// methods EnumerateContext is zeroed out. It will be filled by the NAT with the information
	// to be passed back down as the enumeration continues. To indicate there are no items
	// remaining, the NAT will set EnumerateContext[0] to 0. In RMIBEntryGetNext (section
	// 3.2.4.32) method, EnumerateContext MUST be returned to the value returned in the
	// previous calls.
	EnumerateContext []uint32 `idl:"name:EnumerateContext" json:"enumerate_context"`
	// EnumerateCount (4 bytes): Contains the number of enumerations returned and the number
	// of IP_NAT_SESSION_MAPPING (section 2.2.1.2.184) structures being returned.
	EnumerateCount uint32 `idl:"name:EnumerateCount" json:"enumerate_count"`
	// EnumerateTotalHint (4 bytes): Count of the total number of entries.
	EnumerateTotalHint uint32 `idl:"name:EnumerateTotalHint" json:"enumerate_total_hint"`
	// EnumerateTable (variable): This MUST be IP_NAT_SESSION_MAPPING structures.
	EnumerateTable []*IPNATSessionMapping `idl:"name:EnumerateTable" json:"enumerate_table"`
}

func (o *IPNATEnumerateSessionMappings) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPNATEnumerateSessionMappings) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Index); err != nil {
		return err
	}
	for i1 := range o.EnumerateContext {
		i1 := i1
		if uint64(i1) >= 4 {
			break
		}
		if err := w.WriteData(o.EnumerateContext[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.EnumerateContext); uint64(i1) < 4; i1++ {
		if err := w.WriteData(uint32(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.EnumerateCount); err != nil {
		return err
	}
	if err := w.WriteData(o.EnumerateTotalHint); err != nil {
		return err
	}
	for i1 := range o.EnumerateTable {
		i1 := i1
		if uint64(i1) >= 1 {
			break
		}
		if o.EnumerateTable[i1] != nil {
			if err := o.EnumerateTable[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&IPNATSessionMapping{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.EnumerateTable); uint64(i1) < 1; i1++ {
		if err := (&IPNATSessionMapping{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *IPNATEnumerateSessionMappings) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Index); err != nil {
		return err
	}
	o.EnumerateContext = make([]uint32, 4)
	for i1 := range o.EnumerateContext {
		i1 := i1
		if err := w.ReadData(&o.EnumerateContext[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.EnumerateCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.EnumerateTotalHint); err != nil {
		return err
	}
	o.EnumerateTable = make([]*IPNATSessionMapping, 1)
	for i1 := range o.EnumerateTable {
		i1 := i1
		if o.EnumerateTable[i1] == nil {
			o.EnumerateTable[i1] = &IPNATSessionMapping{}
		}
		if err := o.EnumerateTable[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// IPNATInterfaceStatistics structure represents IP_NAT_INTERFACE_STATISTICS RPC structure.
//
// The IP_NAT_INTERFACE_STATISTICS structure holds statistics for an interface and is
// part of IP_NAT_MIB_QUERY (section 2.2.1.2.182) structure.
type IPNATInterfaceStatistics struct {
	// TotalMappings: The count of the total number of mappings present in the NAT table.
	TotalMappings uint32 `idl:"name:TotalMappings" json:"total_mappings"`
	// InboundMappings: The count of the total number of inbound mappings present in the
	// NAT table.
	InboundMappings uint32 `idl:"name:InboundMappings" json:"inbound_mappings"`
	// BytesForward: The count of the total bytes forwarded.
	BytesForward uint64 `idl:"name:BytesForward" json:"bytes_forward"`
	// BytesReverse: The count of the total bytes reversed.
	BytesReverse uint64 `idl:"name:BytesReverse" json:"bytes_reverse"`
	// PacketsForward: The count of the packets forwarded.
	PacketsForward uint64 `idl:"name:PacketsForward" json:"packets_forward"`
	// PacketsReverse: The count of the packets reversed.
	PacketsReverse uint64 `idl:"name:PacketsReverse" json:"packets_reverse"`
	// RejectsForward: The count of the forward packets rejected.
	RejectsForward uint64 `idl:"name:RejectsForward" json:"rejects_forward"`
	// RejectsReverse: The count of the reverse packets rejected.
	RejectsReverse uint64 `idl:"name:RejectsReverse" json:"rejects_reverse"`
}

func (o *IPNATInterfaceStatistics) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPNATInterfaceStatistics) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if err := w.WriteData(o.TotalMappings); err != nil {
		return err
	}
	if err := w.WriteData(o.InboundMappings); err != nil {
		return err
	}
	if err := w.WriteData(o.BytesForward); err != nil {
		return err
	}
	if err := w.WriteData(o.BytesReverse); err != nil {
		return err
	}
	if err := w.WriteData(o.PacketsForward); err != nil {
		return err
	}
	if err := w.WriteData(o.PacketsReverse); err != nil {
		return err
	}
	if err := w.WriteData(o.RejectsForward); err != nil {
		return err
	}
	if err := w.WriteData(o.RejectsReverse); err != nil {
		return err
	}
	return nil
}
func (o *IPNATInterfaceStatistics) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if err := w.ReadData(&o.TotalMappings); err != nil {
		return err
	}
	if err := w.ReadData(&o.InboundMappings); err != nil {
		return err
	}
	if err := w.ReadData(&o.BytesForward); err != nil {
		return err
	}
	if err := w.ReadData(&o.BytesReverse); err != nil {
		return err
	}
	if err := w.ReadData(&o.PacketsForward); err != nil {
		return err
	}
	if err := w.ReadData(&o.PacketsReverse); err != nil {
		return err
	}
	if err := w.ReadData(&o.RejectsForward); err != nil {
		return err
	}
	if err := w.ReadData(&o.RejectsReverse); err != nil {
		return err
	}
	return nil
}

// IPDNSProxyMIBQuery structure represents IP_DNS_PROXY_MIB_QUERY RPC structure.
//
// The IP_DNS_PROXY_MIB_QUERY structure is passed to RMIBEntryGet (section 3.1.4.30)
// method to retrieve the DNS proxy information.
//
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| Oid                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| Index                                                                                                                         |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| Data (variable)                                                                                                               |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
type IPDNSProxyMIBQuery struct {
	// Oid (4 bytes): This MUST be set to 0x00000000.
	OID    uint32                     `idl:"name:Oid" json:"oid"`
	Field2 *IPDNSProxyMIBQuery_Field2 `idl:"name:" json:""`
}

func (o *IPDNSProxyMIBQuery) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPDNSProxyMIBQuery) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.OID); err != nil {
		return err
	}
	// FIXME unknown type
	return nil
}
func (o *IPDNSProxyMIBQuery) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.OID); err != nil {
		return err
	}
	// FIXME: unknown type
	return nil
}

type IPDNSProxyMIBQuery_Field2 struct {
	// Index (4 bytes): This MUST be the index of the interface.
	Index uint32 `idl:"name:Index" json:"index"`
	// Data (variable): This MUST be an IP_DNS_PROXY_STATISTICS structure.
	Data uint8 `idl:"name:Data" json:"data"`
}

// IPDNSProxyStatistics structure represents IP_DNS_PROXY_STATISTICS RPC structure.
//
// The IP_DNS_PROXY_STATISTICS structure contains the IP DNS proxy statistics.
type IPDNSProxyStatistics struct {
	// MessagesIgnored: The count of the DNS proxy messages ignored.
	MessagesIgnored uint32 `idl:"name:MessagesIgnored" json:"messages_ignored"`
	// QueriesReceived: The count of the DNS proxy queries received.
	QueriesReceived uint32 `idl:"name:QueriesReceived" json:"queries_received"`
	// ResponsesReceived: The count of the DNS proxy responses received.
	ResponsesReceived uint32 `idl:"name:ResponsesReceived" json:"responses_received"`
	// QueriesSent: The count of the DNS proxy queries sent.
	QueriesSent uint32 `idl:"name:QueriesSent" json:"queries_sent"`
	// ResponsesSent: The count of the DNS proxy responses sent.
	ResponsesSent uint32 `idl:"name:ResponsesSent" json:"responses_sent"`
}

func (o *IPDNSProxyStatistics) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPDNSProxyStatistics) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.MessagesIgnored); err != nil {
		return err
	}
	if err := w.WriteData(o.QueriesReceived); err != nil {
		return err
	}
	if err := w.WriteData(o.ResponsesReceived); err != nil {
		return err
	}
	if err := w.WriteData(o.QueriesSent); err != nil {
		return err
	}
	if err := w.WriteData(o.ResponsesSent); err != nil {
		return err
	}
	return nil
}
func (o *IPDNSProxyStatistics) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.MessagesIgnored); err != nil {
		return err
	}
	if err := w.ReadData(&o.QueriesReceived); err != nil {
		return err
	}
	if err := w.ReadData(&o.ResponsesReceived); err != nil {
		return err
	}
	if err := w.ReadData(&o.QueriesSent); err != nil {
		return err
	}
	if err := w.ReadData(&o.ResponsesSent); err != nil {
		return err
	}
	return nil
}

// IPAutoDHCPMIBQuery structure represents IP_AUTO_DHCP_MIB_QUERY RPC structure.
//
// The IP_AUTO_DHCP_MIB_QUERY structure is used to retrieve the DNS proxy information
// and is passed to the following methods:
//
// * *RMIBEntryGet (section 3.1.4.30)* ( ebc5c709-36d8-4520-a0ac-6f36d2d6c0b2 )
//
// * *RMIBEntryGetFirst (section 3.1.4.31)* ( 9102e585-2f62-4408-bfb6-02a6460cc883 )
//
// * *RMIBEntryGetNext (section 3.1.4.32)* ( 50f78033-d248-4272-b4b9-a2519a0f304d )
//
// typedef struct _IP_AUTO_DHCP_MIB_QUERY {
//
// ULONG Oid;
//
// union {
//
// ULONG Index;
//
// UCHAR Data;
//
// };
//
// ULONG Reserved;
//
// } IP_AUTO_DHCP_MIB_QUERY,
type IPAutoDHCPMIBQuery struct {
	// Oid: This MUST be set to 0x00000000.
	OID    uint32                     `idl:"name:Oid" json:"oid"`
	Field2 *IPAutoDHCPMIBQuery_Field2 `idl:"name:" json:""`
	// Reserved: MUST be set to zero (0) when sent and MUST be ignored on receipt.
	_ uint32 `idl:"name:Reserved"`
}

func (o *IPAutoDHCPMIBQuery) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPAutoDHCPMIBQuery) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.OID); err != nil {
		return err
	}
	// FIXME unknown type
	// reserved Reserved
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	return nil
}
func (o *IPAutoDHCPMIBQuery) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.OID); err != nil {
		return err
	}
	// FIXME: unknown type
	// reserved Reserved
	var _Reserved uint32
	if err := w.ReadData(&_Reserved); err != nil {
		return err
	}
	return nil
}

type IPAutoDHCPMIBQuery_Field2 struct {
	// Index: This MUST be index of the interface.
	Index uint32 `idl:"name:Index" json:"index"`
	// Data: This MUST be an IP_AUTO_DHCP_STATISTICS structure.
	Data uint8 `idl:"name:Data" json:"data"`
}

// IPAutoDHCPStatistics structure represents IP_AUTO_DHCP_STATISTICS RPC structure.
//
// The IP_AUTO_DHCP_STATISTICS structure contains the DHCP auto-discovery statistics.
// This structure defines the statistics kept by the DHCP allocator, and is accessible
// to the following methods:
//
// * *RMIBEntryGet (section 3.2.4.30)* ( 077dbddb-b09f-4384-bc7e-612a7b044999 )
//
// * *RMIBEntryGetFirst (section 3.2.4.31)* ( 340672df-1018-44a6-b1b8-509348062857 )
//
// * *RMIBEntryGetNext (section 3.2.4.32)* ( 12830348-d502-4b45-adc3-e5853d42d0c9 )
//
// typedef struct _IP_AUTO_DHCP_STATISTICS {
//
// ULONG MessagesIgnored;
//
// ULONG BootpOffersSent;
//
// ULONG DiscoversReceived;
//
// ULONG InformsReceived;
//
// ULONG OffersSent;
//
// ULONG RequestsReceived;
//
// ULONG AcksSent;
//
// ULONG NaksSent;
//
// ULONG DeclinesReceived;
//
// ULONG ReleasesReceived;
//
// } IP_AUTO_DHCP_STATISTICS,
type IPAutoDHCPStatistics struct {
	// MessagesIgnored: The count of the messages ignored.
	MessagesIgnored uint32 `idl:"name:MessagesIgnored" json:"messages_ignored"`
	// BootpOffersSent: The count of the IPBOOTP offers sent.
	BOOTPOffersSent uint32 `idl:"name:BootpOffersSent" json:"bootp_offers_sent"`
	// DiscoversReceived: The count of the discover messages received.
	DiscoversReceived uint32 `idl:"name:DiscoversReceived" json:"discovers_received"`
	// InformsReceived: The count of the INFORM messages received.
	InformsReceived uint32 `idl:"name:InformsReceived" json:"informs_received"`
	// OffersSent: The count of the OFFER messages sent.
	OffersSent uint32 `idl:"name:OffersSent" json:"offers_sent"`
	// RequestsReceived: The count of the REQUEST messages received.
	RequestsReceived uint32 `idl:"name:RequestsReceived" json:"requests_received"`
	// AcksSent: The count of the acknowledge control packets (ACKs) sent.
	ACKsSent uint32 `idl:"name:AcksSent" json:"acks_sent"`
	// NaksSent: The count of the negative acknowledge (NAK) messages sent.
	NAKsSent uint32 `idl:"name:NaksSent" json:"naks_sent"`
	// DeclinesReceived: The count of the DECLINE messages received.
	DeclinesReceived uint32 `idl:"name:DeclinesReceived" json:"declines_received"`
	ReleasesReceived uint32 `idl:"name:ReleasesReceived" json:"releases_received"`
}

func (o *IPAutoDHCPStatistics) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPAutoDHCPStatistics) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.MessagesIgnored); err != nil {
		return err
	}
	if err := w.WriteData(o.BOOTPOffersSent); err != nil {
		return err
	}
	if err := w.WriteData(o.DiscoversReceived); err != nil {
		return err
	}
	if err := w.WriteData(o.InformsReceived); err != nil {
		return err
	}
	if err := w.WriteData(o.OffersSent); err != nil {
		return err
	}
	if err := w.WriteData(o.RequestsReceived); err != nil {
		return err
	}
	if err := w.WriteData(o.ACKsSent); err != nil {
		return err
	}
	if err := w.WriteData(o.NAKsSent); err != nil {
		return err
	}
	if err := w.WriteData(o.DeclinesReceived); err != nil {
		return err
	}
	if err := w.WriteData(o.ReleasesReceived); err != nil {
		return err
	}
	return nil
}
func (o *IPAutoDHCPStatistics) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.MessagesIgnored); err != nil {
		return err
	}
	if err := w.ReadData(&o.BOOTPOffersSent); err != nil {
		return err
	}
	if err := w.ReadData(&o.DiscoversReceived); err != nil {
		return err
	}
	if err := w.ReadData(&o.InformsReceived); err != nil {
		return err
	}
	if err := w.ReadData(&o.OffersSent); err != nil {
		return err
	}
	if err := w.ReadData(&o.RequestsReceived); err != nil {
		return err
	}
	if err := w.ReadData(&o.ACKsSent); err != nil {
		return err
	}
	if err := w.ReadData(&o.NAKsSent); err != nil {
		return err
	}
	if err := w.ReadData(&o.DeclinesReceived); err != nil {
		return err
	}
	if err := w.ReadData(&o.ReleasesReceived); err != nil {
		return err
	}
	return nil
}

// MIBDaMessage structure represents MIB_DA_MSG RPC structure.
//
// The MIB_DA_MSG structure MAY<137> be used for retrieving OSPF MIB entries in the
// following methods:
//
// * *RMIBEntryGet (section 3.1.4.30)* ( ebc5c709-36d8-4520-a0ac-6f36d2d6c0b2 )
//
// * *RMIBEntryGetFirst (section 3.1.4.31)* ( 9102e585-2f62-4408-bfb6-02a6460cc883 )
//
// * *RMIBEntryGetNext (section 3.1.4.32)* ( 50f78033-d248-4272-b4b9-a2519a0f304d )
//
// typedef struct _MIB_DA_MSG {
//
// UINT32 op_code;
//
// UINT32 ret_code;
//
// UINT32 in_snmp_id[44];
//
// UINT32 obj_id[17];
//
// UINT32 attr_id;
//
// UINT32 inst_id[23];
//
// UINT32 next_snmp_id[44];
//
// UINT32 creator;
//
// UINT32 attr_type;
//
// UINT32 inst_cnt;
//
// UINT32 map_flag;
//
// ULONG_PTR data[32];
//
// } MIB_DA_MSG;
type MIBDaMessage struct {
	// op_code: This MUST have one of the following values.
	//
	//	+---------------------------------------+-----------------------------------------------------------+
	//	|                                       |                                                           |
	//	|                 VALUE                 |                          MEANING                          |
	//	|                                       |                                                           |
	//	+---------------------------------------+-----------------------------------------------------------+
	//	+---------------------------------------+-----------------------------------------------------------+
	//	| ASN_RFC1157_GETREQUEST 0x000000A0     | MIB get request: RMIBEntryGet (section 3.1.4.30)          |
	//	+---------------------------------------+-----------------------------------------------------------+
	//	| ASN_RFC1157_GETNEXTREQUEST 0x000000A1 | MIB get next request: RMIBEntryGetNext (section 3.1.4.32) |
	//	+---------------------------------------+-----------------------------------------------------------+
	//	| ASN_RFC1157_SETREQUEST 0x000000A3     | MIB set request: RMIBEntrySet (section 3.1.4.29)          |
	//	+---------------------------------------+-----------------------------------------------------------+
	OperationCode uint32 `idl:"name:op_code" json:"operation_code"`
	// ret_code: This contains a return value which MUST be one of the following values.
	//
	//	+-------------------+------------------------------+
	//	|                   |                              |
	//	|       VALUE       |           MEANING            |
	//	|                   |                              |
	//	+-------------------+------------------------------+
	//	+-------------------+------------------------------+
	//	| MIB_OK 0x00000000 | The call was successful.     |
	//	+-------------------+------------------------------+
	//	| All other values  | The call was not successful. |
	//	+-------------------+------------------------------+
	ReturnCode uint32 `idl:"name:ret_code" json:"return_code"`
	// in_snmp_id: Contains the index of the entry that needs to be retrieved.
	//
	// in_snmp_id[0] contains the length (excluding the zeroth element) of the data passed
	// in in_snmp_id. in_snmp_id[1] onwards contains the MIB object identifier [RFC1850].
	//
	//	+------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	|                     VALUE IN SNMP ID[1] AND                      |                                   MEANING [RFC                                   |
	//	|                              BEYOND                              |                                      1850]                                       |
	//	+------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| g_oidOspfAreaEntry { 4, 1, 18, 3, 5, 3, 2, 3, 2, 1 }             | Open Shortest Path First (OSPF) area entry. See ospfAreaEntry, section 3.2       |
	//	|                                                                  | in [RFC1850]. Information describing the configured parameters and cumulative    |
	//	|                                                                  | statistics of one of the router's attached areas.                                |
	//	+------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| g_oidOspfLsdbEntry { 4, 1, 18, 3, 5, 3, 2, 3, 3, 1 }             | A single link state advertisement. See ospfLsdbEntry, section 3.4 in [RFC1850].  |
	//	+------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| g_oidOspfNbrEntry { 4, 1, 18, 3, 5, 3, 2, 3, 7, 1 }              | The information regarding a single neighbor. See OspfNbrEntry, section 3.10 in   |
	//	|                                                                  | [RFC1850].                                                                       |
	//	+------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| g_oidOspfVIEntry { 4, 1, 18, 3, 5, 3, 2, 3, 6, 1 }               | The information about a single Virtual Interface. See OspfVirtIfEntry, section   |
	//	|                                                                  | 3.9 in [RFC1850].                                                                |
	//	+------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| g_oidOspfAreaState { 4, 1, 18, 3, 5, 3, 2, 3, 2, 1, 3 }          | Retrieves the state. This value indicates the state of the OSPF Area, either     |
	//	|                                                                  | up(0x00000001), or down(0x00000002). See ospfAreaStatus, section 3.2 in          |
	//	|                                                                  | [RFC1850].                                                                       |
	//	+------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| g_oidOspfAreaSpfCount { 4, 1, 18, 3, 5, 3, 2, 3, 2, 1, 9 }       | Retrieves the number of times the SPF algorithm has run for the area. See        |
	//	|                                                                  | ospfSpfRuns, section 3.2 in [RFC1850].                                           |
	//	+------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| g_oidOspfLsdbAge { 4, 1, 18, 3, 5, 3, 2, 3, 3, 1, 6 }            | Retrieves the age of the link state advertisement in seconds. See ospfLsdbAge,   |
	//	|                                                                  | section 3.4 in [RFC1850] and section 12.1.1 LS age in [RFC2328].                 |
	//	+------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| g_oidOspfLsdbSequence { 4, 1, 18, 3, 5, 3, 2, 3, 3, 1, 5 }       | Retrieves the sequence. The OSPF Sequence Number is a 32-bit signed integer.     |
	//	|                                                                  | It starts with the value '80000001'h, or '7FFFFFFF'h, and increments until       |
	//	|                                                                  | '7FFFFFFF'h. Thus, a typical sequence number will be very negative. The          |
	//	|                                                                  | sequence number field is a signed 32-bit integer. It is used to detect old and   |
	//	|                                                                  | duplicate link state advertisements. The space of sequence numbers is linearly   |
	//	|                                                                  | ordered. The larger the sequence number the more recent the advertisement.       |
	//	|                                                                  | See ospfLsdbSequence, section 3.4 of [RFC1850] and LS sequence number, section   |
	//	|                                                                  | 12.1.6 in [RFC2328].                                                             |
	//	+------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| g_oidOspfNbrRtrId { 4, 1, 18, 3, 5, 3, 2, 3, 7, 1, 7 }           | Retrieves the router ID. A 32-bit integer uniquely identifying the neighboring   |
	//	|                                                                  | router in the autonomous system. See ospfNbrRtrId, section 3.10 in [RFC1850].    |
	//	+------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| g_oidOspfNbrState { 4, 1, 18, 3, 5, 3, 2, 3, 7, 1, 3 }           | Retrieves the state. The state of the Virtual Neighbor Relationship. It can be   |
	//	|                                                                  | down (0x00000001), attempt (0x00000002), init (0x00000003), twoWay (0x00000004), |
	//	|                                                                  | exchangeStart (0x00000005), exchange (0x00000006), loading (0x00000007), and     |
	//	|                                                                  | full (0x00000008) See ospfNbrState, section 3.10 in [RFC1850].                   |
	//	+------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| g_oidOspfNbrPriority { 4, 1, 18, 3, 5, 3, 2, 3, 7, 1, 9 }        | Retrieves the priority. The priority of this neighbor in the designated router   |
	//	|                                                                  | election algorithm. The value 0 signifies that the neighbor is not eligible to   |
	//	|                                                                  | become the designated router on this particular network. See ospfNbrPriority,    |
	//	|                                                                  | section 3.10 in [RFC1850].                                                       |
	//	+------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| g_oidOspfNbrEvents { 4, 1, 18, 3, 5, 3, 2, 3, 7, 1, 10 }         | Retrieves the event count. The number of times this neighbor relationship has    |
	//	|                                                                  | changed state, or that an error has occurred. See ospfNbrEvents, section 3.10 in |
	//	|                                                                  | [RFC1850].                                                                       |
	//	+------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| g_oidOspfNbrLSRetransQLen { 4, 1, 18, 3, 5, 3, 2, 3, 7, 1, 11 }  | Retrieves the queue length. See ospfNbrLsRetransQLen, section 3.10 in [RFC1850]. |
	//	+------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| g_oidOspfVIState { 4, 1, 18, 3, 5, 3, 2, 3, 6, 1, 3 }            | Retrieves the state. See ospfVirtIfState, section 3.9 in [RFC1850].              |
	//	+------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| g_oidOspfVIDrops { 4, 1, 18, 3, 5, 3, 2, 3, 6, 1, 21}            | The number of OSPF packets dropped on Virtual Interfaces. The data returned is a |
	//	|                                                                  | 32-bit integer.                                                                  |
	//	+------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| g_oidOspfVIRxHellos { 4, 1, 18, 3, 5, 3, 2, 3, 6, 1, 16 }        | The number of OSPF Hello packets received on Virtual Interfaces. Data returned   |
	//	|                                                                  | is a 32-bit integer.                                                             |
	//	+------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| g_oidOspfVITxHellos { 4, 1, 18, 3, 5, 3, 2, 3, 6, 1, 11 }        | The number of OSPF Hello packets transmitted on the Virtual Interfaces. The data |
	//	|                                                                  | returned is a 32-bit integer.                                                    |
	//	+------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| g_oidOspfIfArea { 4, 1, 18, 3, 5, 3, 2, 3, 5, 1, 6 }             | See ospfIfAreaId, section 3.7 in [RFC1850].                                      |
	//	+------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| g_oidOspfIfType { 4, 1, 18, 3, 5, 3, 2, 3, 5, 1, 7 }             | See ospfIfType, section 3.7 in [RFC1850].                                        |
	//	+------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| g_oidOspfIfState { 4, 1, 18, 3, 5, 3, 2, 3, 5, 1, 3 }            | See ospfIfState, section 3.7 in [RFC1850].                                       |
	//	+------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| g_oidOspfIfRxDBDescripts { 4, 1, 18, 3, 5, 3, 2, 3, 5, 1, 24 }   | The number of OSPF DataBase Description packets received. The data returned is a |
	//	|                                                                  | 32-bit integer.                                                                  |
	//	+------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| g_oidOspfIfRxLinkStateAcks { 4, 1, 18, 3, 5, 3, 2, 3, 5, 1, 27 } | The number of OSPF Link State Acknowledgements received. The data returned is a  |
	//	|                                                                  | 32-bit integer.                                                                  |
	//	+------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| g_oidOspfIfRxLinkStateReqs { 4, 1, 18, 3, 5, 3, 2, 3, 5, 1, 25 } | The number of OSPF Link State Requests received. The data returned is a 32-bit   |
	//	|                                                                  | integer.                                                                         |
	//	+------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| g_oidOspfIfRxLinkStateUpds { 4, 1, 18, 3, 5, 3, 2, 3, 5, 1, 26 } | The number of OSPF Link State Updates received. The ata returned is a 32-bit     |
	//	|                                                                  | integer.                                                                         |
	//	+------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| g_oidOspfIfTxDBDescripts { 4, 1, 18, 3, 5, 3, 2, 3, 5, 1, 19 }   | The number of OSPF DataBase Description packets transmitted. The data returned   |
	//	|                                                                  | is a 32-bit integer.                                                             |
	//	+------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| g_oidOspfIfTxLinkStateAcks { 4, 1, 18, 3, 5, 3, 2, 3, 5, 1, 22 } | The number of OSPF Link State Update packets transmitted. The data returned is a |
	//	|                                                                  | 32-bit integer.                                                                  |
	//	+------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| g_oidOspfIfTxLinkStateReqs { 4, 1, 18, 3, 5, 3, 2, 3, 5, 1, 20 } | The number of OSPF Link State Request packets transmitted. The data returned is  |
	//	|                                                                  | a 32-bit integer.                                                                |
	//	+------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| g_oidOspfIfTxLinkStateUpds { 4, 1, 18, 3, 5, 3, 2, 3, 5, 1, 21 } | The number of OSPF Link State Update packets transmitted. The data returned is a |
	//	|                                                                  | 32-bit integer.                                                                  |
	//	+------------------------------------------------------------------+----------------------------------------------------------------------------------+
	//	| g_oidOspfIfDrops { 4, 1, 18, 3, 5, 3, 2, 3, 5, 1, 28 }           | The number of OSPF packets dropped because of invalid information in the packet. |
	//	|                                                                  | The data returned is a 32-bit integer.                                           |
	//	+------------------------------------------------------------------+----------------------------------------------------------------------------------+
	InSNMPID []uint32 `idl:"name:in_snmp_id" json:"in_snmp_id"`
	// obj_id: Unused and MUST be set to zero (0).
	ObjectID []uint32 `idl:"name:obj_id" json:"object_id"`
	// attr_id: Unused and MUST be set to zero (0).
	AttributeID uint32 `idl:"name:attr_id" json:"attribute_id"`
	// inst_id: Unused and MUST be set to zero (0).
	InstanceID []uint32 `idl:"name:inst_id" json:"instance_id"`
	// next_snmp_id: Unused and MUST be set to zero (0).
	NextSNMPID []uint32 `idl:"name:next_snmp_id" json:"next_snmp_id"`
	// creator: Unused and MUST be set to zero (0).
	Creator uint32 `idl:"name:creator" json:"creator"`
	// attr_type: Unused and MUST be set to zero (0).
	AttributeType uint32 `idl:"name:attr_type" json:"attribute_type"`
	// inst_cnt: Unused and MUST be set to zero (0).
	InstanceCnt uint32 `idl:"name:inst_cnt" json:"instance_cnt"`
	// map_flag: Unused and MUST be set to zero (0).
	MapFlag uint32 `idl:"name:map_flag" json:"map_flag"`
	// data: Contains the data returned by the OSPF MIB based on the entry requested in
	// the previous table. See [RFC1850] for more information about how to interpret the
	// returned data. The length of the data returned is specified in dwMibOutEntrySize
	// of pInfoStruct in the call to RMIBEntryGet, RMIBEntryGetFirst, and RMIBEntryGetNext.
	Data []uint64 `idl:"name:data" json:"data"`
}

func (o *MIBDaMessage) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *MIBDaMessage) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.OperationCode); err != nil {
		return err
	}
	if err := w.WriteData(o.ReturnCode); err != nil {
		return err
	}
	for i1 := range o.InSNMPID {
		i1 := i1
		if uint64(i1) >= 44 {
			break
		}
		if err := w.WriteData(o.InSNMPID[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.InSNMPID); uint64(i1) < 44; i1++ {
		if err := w.WriteData(uint32(0)); err != nil {
			return err
		}
	}
	for i1 := range o.ObjectID {
		i1 := i1
		if uint64(i1) >= 17 {
			break
		}
		if err := w.WriteData(o.ObjectID[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.ObjectID); uint64(i1) < 17; i1++ {
		if err := w.WriteData(uint32(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.AttributeID); err != nil {
		return err
	}
	for i1 := range o.InstanceID {
		i1 := i1
		if uint64(i1) >= 23 {
			break
		}
		if err := w.WriteData(o.InstanceID[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.InstanceID); uint64(i1) < 23; i1++ {
		if err := w.WriteData(uint32(0)); err != nil {
			return err
		}
	}
	for i1 := range o.NextSNMPID {
		i1 := i1
		if uint64(i1) >= 44 {
			break
		}
		if err := w.WriteData(o.NextSNMPID[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.NextSNMPID); uint64(i1) < 44; i1++ {
		if err := w.WriteData(uint32(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Creator); err != nil {
		return err
	}
	if err := w.WriteData(o.AttributeType); err != nil {
		return err
	}
	if err := w.WriteData(o.InstanceCnt); err != nil {
		return err
	}
	if err := w.WriteData(o.MapFlag); err != nil {
		return err
	}
	for i1 := range o.Data {
		i1 := i1
		if uint64(i1) >= 32 {
			break
		}
		if err := w.WriteData(ndr.Uint3264(o.Data[i1])); err != nil {
			return err
		}
	}
	for i1 := len(o.Data); uint64(i1) < 32; i1++ {
		if err := w.WriteData(uint64(0)); err != nil {
			return err
		}
	}
	return nil
}
func (o *MIBDaMessage) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.OperationCode); err != nil {
		return err
	}
	if err := w.ReadData(&o.ReturnCode); err != nil {
		return err
	}
	o.InSNMPID = make([]uint32, 44)
	for i1 := range o.InSNMPID {
		i1 := i1
		if err := w.ReadData(&o.InSNMPID[i1]); err != nil {
			return err
		}
	}
	o.ObjectID = make([]uint32, 17)
	for i1 := range o.ObjectID {
		i1 := i1
		if err := w.ReadData(&o.ObjectID[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.AttributeID); err != nil {
		return err
	}
	o.InstanceID = make([]uint32, 23)
	for i1 := range o.InstanceID {
		i1 := i1
		if err := w.ReadData(&o.InstanceID[i1]); err != nil {
			return err
		}
	}
	o.NextSNMPID = make([]uint32, 44)
	for i1 := range o.NextSNMPID {
		i1 := i1
		if err := w.ReadData(&o.NextSNMPID[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.Creator); err != nil {
		return err
	}
	if err := w.ReadData(&o.AttributeType); err != nil {
		return err
	}
	if err := w.ReadData(&o.InstanceCnt); err != nil {
		return err
	}
	if err := w.ReadData(&o.MapFlag); err != nil {
		return err
	}
	o.Data = make([]uint64, 32)
	for i1 := range o.Data {
		i1 := i1
		if err := w.ReadData((*ndr.Uint3264)(&o.Data[i1])); err != nil {
			return err
		}
	}
	return nil
}

// IPAutoDHCPGlobalInfo structure represents IP_AUTO_DHCP_GLOBAL_INFO RPC structure.
//
// The IP_AUTO_DHCP_GLOBAL_INFO structure holds the global configuration for the DHCP
// allocator and is used in the following methods:
//
// * *RRouterInterfaceTransportSetGlobalInfo (section 3.1.4.10)* ( 071439e7-a9fd-40e4-91f7-ab756108e82f
// )
//
// * *RRouterInterfaceTransportGetGlobalInfo (section 3.1.4.11)* ( 14ad8d26-d7d7-48dd-914d-da962d5d7049
// )
//
// The configuration consists of two things:
//
// *
//
// The network and mask from which addresses are to be allocated.
//
// *
//
// An optional list of addresses to be excluded from allocation. Thus, this structure
// is of variable length.
//
//  typedef struct _IP_AUTO_DHCP_GLOBAL_INFO {
//    ULONG LoggingLevel;
//    ULONG Flags;
//    ULONG LeaseTime;
//    ULONG ScopeNetwork;
//    ULONG ScopeMask;
//    ULONG ExclusionCount;
//    ULONG ExclusionArray;
//  } IP_AUTO_DHCP_GLOBAL_INFO,
//   *PIP_AUTO_DHCP_GLOBAL_INFO;
type IPAutoDHCPGlobalInfo struct {
	// LoggingLevel: Specifies the logging level. It MUST be one of the following values.
	//
	//	+-----------------------------------+----------------------------------------------+
	//	|                                   |                                              |
	//	|               VALUE               |                   MEANING                    |
	//	|                                   |                                              |
	//	+-----------------------------------+----------------------------------------------+
	//	+-----------------------------------+----------------------------------------------+
	//	| IPNATHLP_LOGGING_NONE 0x00000000  | No logging is done.                          |
	//	+-----------------------------------+----------------------------------------------+
	//	| IPNATHLP_LOGGING_ERROR 0x00000001 | Only errors are logged.                      |
	//	+-----------------------------------+----------------------------------------------+
	//	| IPNATHLP_LOGGING_WARN 0x00000002  | Errors and warnings are logged.              |
	//	+-----------------------------------+----------------------------------------------+
	//	| IPNATHLP_LOGGING_INFO 0x00000003  | Errors, warnings, and information is logged. |
	//	+-----------------------------------+----------------------------------------------+
	LoggingLevel uint32 `idl:"name:LoggingLevel" json:"logging_level"`
	// Flags: This MUST be set to 0.
	Flags uint32 `idl:"name:Flags" json:"flags"`
	// LeaseTime: The lease time, in minutes.
	LeaseTime uint32 `idl:"name:LeaseTime" json:"lease_time"`
	// ScopeNetwork: The scope of the network from which addresses are to be allocated.
	ScopeNetwork uint32 `idl:"name:ScopeNetwork" json:"scope_network"`
	// ScopeMask: The mask used to identify the subnet portion of the address. See [RFC950].
	// The value obtained by logically ANDing ScopeMask and ScopeNetwork MUST equal ScopeNetwork.
	// Any ScopeMask that produces a different ANDed result is invalid.
	ScopeMask uint32 `idl:"name:ScopeMask" json:"scope_mask"`
	// ExclusionCount: The number of IP addresses that need to be excluded from being allocated.
	// This is also indicates the size of the ExclusionArray.
	ExclusionCount uint32 `idl:"name:ExclusionCount" json:"exclusion_count"`
	// ExclusionArray: An array of IP addresses that need to be excluded. The size of the
	// array is given by ExclusionCount.
	ExclusionArray uint32 `idl:"name:ExclusionArray" json:"exclusion_array"`
}

func (o *IPAutoDHCPGlobalInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPAutoDHCPGlobalInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.LoggingLevel); err != nil {
		return err
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	if err := w.WriteData(o.LeaseTime); err != nil {
		return err
	}
	if err := w.WriteData(o.ScopeNetwork); err != nil {
		return err
	}
	if err := w.WriteData(o.ScopeMask); err != nil {
		return err
	}
	if err := w.WriteData(o.ExclusionCount); err != nil {
		return err
	}
	if err := w.WriteData(o.ExclusionArray); err != nil {
		return err
	}
	return nil
}
func (o *IPAutoDHCPGlobalInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.LoggingLevel); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	if err := w.ReadData(&o.LeaseTime); err != nil {
		return err
	}
	if err := w.ReadData(&o.ScopeNetwork); err != nil {
		return err
	}
	if err := w.ReadData(&o.ScopeMask); err != nil {
		return err
	}
	if err := w.ReadData(&o.ExclusionCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.ExclusionArray); err != nil {
		return err
	}
	return nil
}

// IPAutoDHCPInterfaceInfo structure represents IP_AUTO_DHCP_INTERFACE_INFO RPC structure.
//
// The IP_AUTO_DHCP_INTERFACE_INFO structure holds per-interface configuration for the
// DHCP allocator. This structure is used in the following methods:
//
// * *RRouterInterfaceTransportAdd (section 3.1.4.18)* ( 927c5bf1-ac91-4325-b945-0d96a58f609b
// )
//
// * *RRouterInterfaceTransportGetInfo (section 3.1.4.19)* ( ec9ba293-45e9-4f12-b9af-7e77ec96c90e
// )
//
// * *RRouterInterfaceTransportSetInfo (section 3.1.4.20)* ( 209ba5e7-876e-4406-a05c-65b7e5fb2380
// )
//
// The configuration only allows the DHCP allocator to be disabled on the given interface.
// Since the allocator runs in promiscuous-interface mode, it is enabled by default
// on all interfaces. Thus, the only interfaces that require any configuration are those
// on which the allocator is to be disabled.
type IPAutoDHCPInterfaceInfo struct {
	// Flags: Specifies whether or not the DHCP allocator is enabled.
	//
	//	+---------------------------------------------+---------------------------------+
	//	|                                             |                                 |
	//	|                    VALUE                    |             MEANING             |
	//	|                                             |                                 |
	//	+---------------------------------------------+---------------------------------+
	//	+---------------------------------------------+---------------------------------+
	//	| 0x00000000                                  | The DHCP allocator is enabled.  |
	//	+---------------------------------------------+---------------------------------+
	//	| IPNATHLP_INTERFACE_FLAG_DISABLED 0x00000001 | The DHCP allocator is disabled. |
	//	+---------------------------------------------+---------------------------------+
	Flags uint32 `idl:"name:Flags" json:"flags"`
}

func (o *IPAutoDHCPInterfaceInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPAutoDHCPInterfaceInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	return nil
}
func (o *IPAutoDHCPInterfaceInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	return nil
}

// IPDNSProxyGlobalInfo structure represents IP_DNS_PROXY_GLOBAL_INFO RPC structure.
//
// The IP_DNS_PROXY_GLOBAL_INFO structure holds global configuration for the DNS proxy
// and is used in the following methods:
//
// * *RRouterInterfaceTransportSetGlobalInfo (section 3.1.4.10)* ( 071439e7-a9fd-40e4-91f7-ab756108e82f
// )
//
// * *RRouterInterfaceTransportGetGlobalInfo (section 3.1.4.11)* ( 14ad8d26-d7d7-48dd-914d-da962d5d7049
// )
//
// typedef struct _IP_DNS_PROXY_GLOBAL_INFO {
//
// ULONG LoggingLevel;
//
// ULONG Flags;
//
// ULONG TimeoutSeconds;
type IPDNSProxyGlobalInfo struct {
	// LoggingLevel: Specifies the logging level. It MUST be one of the following values.
	//
	//	+-----------------------------------+----------------------------------------------+
	//	|                                   |                                              |
	//	|               VALUE               |                   MEANING                    |
	//	|                                   |                                              |
	//	+-----------------------------------+----------------------------------------------+
	//	+-----------------------------------+----------------------------------------------+
	//	| IPNATHLP_LOGGING_NONE 0x00000000  | No logging is done.                          |
	//	+-----------------------------------+----------------------------------------------+
	//	| IPNATHLP_LOGGING_ERROR 0x00000001 | Only errors are logged.                      |
	//	+-----------------------------------+----------------------------------------------+
	//	| IPNATHLP_LOGGING_WARN 0x00000002  | Errors and warnings are logged.              |
	//	+-----------------------------------+----------------------------------------------+
	//	| IPNATHLP_LOGGING_INFO 0x00000003  | Errors, warnings, and information is logged. |
	//	+-----------------------------------+----------------------------------------------+
	LoggingLevel uint32 `idl:"name:LoggingLevel" json:"logging_level"`
	// Flags: It MUST be one of the following values.
	//
	//	+------------------------------------------+------------------+
	//	|                                          |                  |
	//	|                  VALUE                   |     MEANING      |
	//	|                                          |                  |
	//	+------------------------------------------+------------------+
	//	+------------------------------------------+------------------+
	//	| IP_DNS_PROXY_FLAG_ENABLE_DNS 0x00000001  | DNS is enabled.  |
	//	+------------------------------------------+------------------+
	//	| IP_DNS_PROXY_FLAG_ENABLE_WINS 0x00000002 | WINS is enabled. |
	//	+------------------------------------------+------------------+
	Flags uint32 `idl:"name:Flags" json:"flags"`
	// TimeoutSeconds: This MUST be the number of seconds that entry is maintained in the
	// cache.
	TimeoutSeconds uint32 `idl:"name:TimeoutSeconds" json:"timeout_seconds"`
}

func (o *IPDNSProxyGlobalInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPDNSProxyGlobalInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.LoggingLevel); err != nil {
		return err
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	if err := w.WriteData(o.TimeoutSeconds); err != nil {
		return err
	}
	return nil
}
func (o *IPDNSProxyGlobalInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.LoggingLevel); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	if err := w.ReadData(&o.TimeoutSeconds); err != nil {
		return err
	}
	return nil
}

// IPDNSProxyInterfaceInfo structure represents IP_DNS_PROXY_INTERFACE_INFO RPC structure.
//
// The IP_DNS_PROXY_INTERFACE_INFO structure holds per-interface configuration for the
// DNS proxy. The configuration currently only allows the proxy to be disabled on a
// given interface. The proxy runs in promiscuous-interface mode so that all interfaces
// are added to it and it is enabled on all of them by default. Hence, the configuration
// need only be present for those interfaces on which the proxy is not to be run.
type IPDNSProxyInterfaceInfo struct {
	// Flags: It MUST be a combination of the following values.
	//
	//	+-------------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                                 |                                                                                  |
	//	|                      VALUE                      |                                     MEANING                                      |
	//	|                                                 |                                                                                  |
	//	+-------------------------------------------------+----------------------------------------------------------------------------------+
	//	+-------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_DNS_PROXY_INTERFACE_FLAG_DISABLED 0x00000001 | The DNS proxy is disabled on the interface. This flag overrides the rest of the  |
	//	|                                                 | flags. The DNS proxy will not be enabled on this interface regardless of other   |
	//	|                                                 | flags being present.                                                             |
	//	+-------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_DNS_PROXY_INTERFACE_FLAG_DEFAULT 0x00000002  | The interface is marked as the default DNS proxy. All DNS queries will be sent   |
	//	|                                                 | over this interface.                                                             |
	//	+-------------------------------------------------+----------------------------------------------------------------------------------+
	//	| DNS_INTERFACE_FLAG_DELETED 0x80000000           | The DNS proxy is disabled on the interface.                                      |
	//	+-------------------------------------------------+----------------------------------------------------------------------------------+
	//	| DNS_INTERFACE_FLAG_BOUND 0x40000000             | The DNS proxy socket is bound on the interface.                                  |
	//	+-------------------------------------------------+----------------------------------------------------------------------------------+
	//	| DNS_INTERFACE_FLAG_ENABLED 0x20000000           | The DNS proxy is enabled on the interface.                                       |
	//	+-------------------------------------------------+----------------------------------------------------------------------------------+
	//	| DNS_INTERFACE_FLAG_CONFIGURED 0x10000000        | The DNS proxy is configured on the interface.                                    |
	//	+-------------------------------------------------+----------------------------------------------------------------------------------+
	Flags uint32 `idl:"name:Flags" json:"flags"`
}

func (o *IPDNSProxyInterfaceInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPDNSProxyInterfaceInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	return nil
}
func (o *IPDNSProxyInterfaceInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	return nil
}

// IPNATGlobalInfo structure represents IP_NAT_GLOBAL_INFO RPC structure.
//
// The IP_NAT_GLOBAL_INFO structure holds the global configuration information for NAT.
// This structure is used in the following methods:
//
// * *RRouterInterfaceTransportSetGlobalInfo (section 3.1.4.10)* ( 071439e7-a9fd-40e4-91f7-ab756108e82f
// )
//
// * *RRouterInterfaceTransportGetGlobalInfo (section 3.1.4.11)* ( 14ad8d26-d7d7-48dd-914d-da962d5d7049
// )
//
// typedef struct _IP_NAT_GLOBAL_INFO {
//
// ULONG LoggingLevel;
//
// ULONG Flags;
//
// RTR_INFO_BLOCK_HEADER Header;
type IPNATGlobalInfo struct {
	// LoggingLevel: Specifies the logging level. It MUST be one of the following values.
	//
	//	+-----------------------------------+----------------------------------------------+
	//	|                                   |                                              |
	//	|               VALUE               |                   MEANING                    |
	//	|                                   |                                              |
	//	+-----------------------------------+----------------------------------------------+
	//	+-----------------------------------+----------------------------------------------+
	//	| IPNATHLP_LOGGING_NONE 0x00000000  | No logging is done.                          |
	//	+-----------------------------------+----------------------------------------------+
	//	| IPNATHLP_LOGGING_ERROR 0x00000001 | Only errors are logged.                      |
	//	+-----------------------------------+----------------------------------------------+
	//	| IPNATHLP_LOGGING_WARN 0x00000002  | Errors and warnings are logged.              |
	//	+-----------------------------------+----------------------------------------------+
	//	| IPNATHLP_LOGGING_INFO 0x00000003  | Errors, warnings, and information is logged. |
	//	+-----------------------------------+----------------------------------------------+
	LoggingLevel uint32 `idl:"name:LoggingLevel" json:"logging_level"`
	// Flags: This MUST be set to 0.
	Flags uint32 `idl:"name:Flags" json:"flags"`
	// Header: This MUST be RTR_INFO_BLOCK_HEADER (section 2.2.1.2.3). The InfoType field
	// of header MUST be either 0x00000000 or 0xFFFF0001. If it is 0x0000000, there is no
	// other information beyond the header and the rest of the fields MUST be zero. If the
	// InfoType is 0xFFFF0001, the Offset MUST point to a structure of type IP_NAT_TIMEOUT
	// (section 2.2.1.2.196).
	Header *RouterInfoBlockHeader `idl:"name:Header" json:"header"`
}

func (o *IPNATGlobalInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPNATGlobalInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.LoggingLevel); err != nil {
		return err
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	if o.Header != nil {
		if err := o.Header.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&RouterInfoBlockHeader{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *IPNATGlobalInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.LoggingLevel); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	if o.Header == nil {
		o.Header = &RouterInfoBlockHeader{}
	}
	if err := o.Header.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// IPNATTimeout structure represents IP_NAT_TIMEOUT RPC structure.
//
// The IP_NAT_TIMEOUT structure is used to amend the default timeouts for TCP and UDP
// session mappings.
type IPNATTimeout struct {
	// TCPTimeoutSeconds: The number of seconds that a dynamic mapping for a TCP session
	// remains in the translation table.
	TCPTimeoutSeconds uint32 `idl:"name:TCPTimeoutSeconds" json:"tcp_timeout_seconds"`
	// UDPTimeoutSeconds: The number of seconds that a dynamic mapping for a UDP session
	// remains in the translation table.
	UDPTimeoutSeconds uint32 `idl:"name:UDPTimeoutSeconds" json:"udp_timeout_seconds"`
}

func (o *IPNATTimeout) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPNATTimeout) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.TCPTimeoutSeconds); err != nil {
		return err
	}
	if err := w.WriteData(o.UDPTimeoutSeconds); err != nil {
		return err
	}
	return nil
}
func (o *IPNATTimeout) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.TCPTimeoutSeconds); err != nil {
		return err
	}
	if err := w.ReadData(&o.UDPTimeoutSeconds); err != nil {
		return err
	}
	return nil
}

// IPNATInterfaceInfo structure represents IP_NAT_INTERFACE_INFO RPC structure.
//
// The IP_NAT_INTERFACE_INFO structure is used to configure the NAT on an interface.
// This structure is used in the following methods:
//
// * *RRouterInterfaceTransportAdd (section 3.1.4.18)* ( 927c5bf1-ac91-4325-b945-0d96a58f609b
// )
//
// * *RRouterInterfaceTransportSetGlobalInfo (section 3.1.4.10)* ( 071439e7-a9fd-40e4-91f7-ab756108e82f
// )
//
// * *RRouterInterfaceTransportGetGlobalInfo (section 3.1.4.11)* ( 14ad8d26-d7d7-48dd-914d-da962d5d7049
// )
//
// The configuration information uses the RTR_INFO_BLOCK_HEADER (section 2.2.1.2.3)
// structure.
type IPNATInterfaceInfo struct {
	// Index: This MUST be set to the interface index that identifies the interface to be
	// configured.
	Index uint32 `idl:"name:Index" json:"index"`
	// Flags: This specifies the logging level. It MUST be a combination of one or more
	// of the following values.
	//
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                                |                                                                                  |
	//	|                     VALUE                      |                                     MEANING                                      |
	//	|                                                |                                                                                  |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_NAT_INTERFACE_FLAGS_BOUNDARY 0x00000001     | Set to mark the interface as a boundary-interface.                               |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_NAT_INTERFACE_FLAGS_NAPT 0x00000002         | Set to enable address-sharing via port-translation.                              |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_NAT_INTERFACE_FLAGS_DISABLE_PPTP 0x00000004 | The PPTP is disabled.                                                            |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_NAT_INTERFACE_FLAGS_FW 0x00000010           | Set to enable the firewall mode on the interface. This works with all other      |
	//	|                                                | flags. An interface in the firewall mode is much more strict on what inbound     |
	//	|                                                | packets it will allow to propagate up the stack; in general, it will only allow  |
	//	|                                                | packets that are part of a locally initiated connection flow (for example,       |
	//	|                                                | packets for which a mapping or ticket exists).                                   |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_NAT_INTERFACE_FLAGS_DIALUP 0x00000040       | This is a dial-up interface.                                                     |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_NAT_INTERFACE_FLAGS_ALL 0x0000007F          | All of the above.                                                                |
	//	+------------------------------------------------+----------------------------------------------------------------------------------+
	Flags uint32 `idl:"name:Flags" json:"flags"`
	// Header: This MUST be RTR_INFO_BLOCK_HEADER. The InfoType field of the header MUST
	// be one of the following and the offset MUST point to a structure specified in the
	// following table.
	//
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	|                                        |                                                                                  |
	//	|                 VALUE                  |                                     MEANING                                      |
	//	|                                        |                                                                                  |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_NAT_PORT_MAPPING_TYPE 0xFFFF0003    | IP_NAT_PORT_MAPPING (section 2.2.1.2.199).                                       |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_NAT_ADDRESS_RANGE_TYPE 0xFFFF0002   | IP_NAT_ADDRESS_RANGE (section 2.2.1.2.198).                                      |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_NAT_ADDRESS_MAPPING_TYPE 0xFFFF0004 | IP_NAT_ADDRESS_MAPPING (section 2.2.1.2.200).                                    |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_NAT_ICMP_CONFIG_TYPE 0xFFFF0005     | There is no structure for IP_NAT_ICMP_CONFIG; it's just a ULONG. The flags in    |
	//	|                                        | the following table define the behavior.                                         |
	//	+----------------------------------------+----------------------------------------------------------------------------------+
	//
	// The values for IP_NAT_ICMP_CONFIG_TYPE are as follows:
	//
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                               |                                                                                  |
	//	|                     VALUE                     |                                     MEANING                                      |
	//	|                                               |                                                                                  |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_NAT_ICMP_ALLOW_OB_DEST_UNREACH 0x00000008  | The data sent over the Internet that fails to reach this computer due to an      |
	//	|                                               | error will be discarded and acknowledged with a destination unreachable message  |
	//	|                                               | explaining the failure.                                                          |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_NAT_ICMP_ALLOW_OB_SOURCE_QUENCH 0x00000010 | When this computer's ability to process incoming data cannot keep up with the    |
	//	|                                               | rate of a transmission, data will be dropped and the sender will be asked to     |
	//	|                                               | slow down.                                                                       |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_NAT_ICMP_ALLOW_REDIRECT 0x00000020         | The data sent from this computer will be rerouted if the default path changes.   |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_NAT_ICMP_ALLOW_IB_ECHO 0x00000100          | The messages sent to this computer will be repeated back to the sender. This is  |
	//	|                                               | commonly used for troubleshooting, for example, to ping a machine.               |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_NAT_ICMP_ALLOW_IB_ROUTER 0x00000200        | This computer will respond to requests for information about the routes it       |
	//	|                                               | recognizes.                                                                      |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_NAT_ICMP_ALLOW_OB_TIME_EXCEEDED 0x00000800 | When this computer discards an incomplete data transmission because the entire   |
	//	|                                               | transmission required more time than allowed, it will reply to the sender with a |
	//	|                                               | time-expired message.                                                            |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_NAT_ICMP_ALLOW_OB_PARAM_PROBLEM 0x00001000 | When this computer discards data it has received due to a problematic header, it |
	//	|                                               | will reply to the sender with a bad-header error message.                        |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_NAT_ICMP_ALLOW_IB_TIMESTAMP 0x00002000     | The data sent to this computer can be acknowledged with a confirmation message   |
	//	|                                               | indicating the time that the data was received.                                  |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| IP_NAT_ICMP_ALLOW_IB_MASK 0x00020000          | This computer will listen for and respond to requests for more information about |
	//	|                                               | the public network to which it is attached.                                      |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	Header *RouterInfoBlockHeader `idl:"name:Header" json:"header"`
}

func (o *IPNATInterfaceInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPNATInterfaceInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Index); err != nil {
		return err
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	if o.Header != nil {
		if err := o.Header.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&RouterInfoBlockHeader{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *IPNATInterfaceInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Index); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	if o.Header == nil {
		o.Header = &RouterInfoBlockHeader{}
	}
	if err := o.Header.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// IPNATAddressRange structure represents IP_NAT_ADDRESS_RANGE RPC structure.
//
// The IP_NAT_ADDRESS_RANGE structure holds a range of addresses that are part of the
// address-pool for a boundary interface. An address pool consists of a list of these
// structures. Overlapping address ranges are not supported. Noncontiguous subnet masks
// are also unsupported.
type IPNATAddressRange struct {
	// StartAddress: The starting IP address of the address pool.
	StartAddress uint32 `idl:"name:StartAddress" json:"start_address"`
	// EndAddress: The end IP address of the address pool.
	EndAddress uint32 `idl:"name:EndAddress" json:"end_address"`
	// SubnetMask: The subnet mask of the address pool; see [RFC950].
	SubnetMask uint32 `idl:"name:SubnetMask" json:"subnet_mask"`
}

func (o *IPNATAddressRange) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPNATAddressRange) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.StartAddress); err != nil {
		return err
	}
	if err := w.WriteData(o.EndAddress); err != nil {
		return err
	}
	if err := w.WriteData(o.SubnetMask); err != nil {
		return err
	}
	return nil
}
func (o *IPNATAddressRange) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.StartAddress); err != nil {
		return err
	}
	if err := w.ReadData(&o.EndAddress); err != nil {
		return err
	}
	if err := w.ReadData(&o.SubnetMask); err != nil {
		return err
	}
	return nil
}

// IPNATPortMapping structure represents IP_NAT_PORT_MAPPING RPC structure.
//
// The IP_NAT_PORT_MAPPING structure holds a static mapping that ties a public-side
// port on this NAT interface to a specific private machine's address or port. In the
// case of an interface with a pool of addresses, the "PublicAddress" specifies which
// of those addresses this static mapping applies to.
type IPNATPortMapping struct {
	// Protocol: Specifies the protocol used for data reception and transmission.
	Protocol uint8 `idl:"name:Protocol" json:"protocol"`
	// PublicPort: Specifies the destination port number of incoming public traffic.
	PublicPort uint16 `idl:"name:PublicPort" json:"public_port"`
	// PublicAddress: Specifies the public IPv4 address.
	PublicAddress uint32 `idl:"name:PublicAddress" json:"public_address"`
	// PrivatePort: The destination port number of the private traffic.
	PrivatePort uint16 `idl:"name:PrivatePort" json:"private_port"`
	// PrivateAddress: Specifies the private IPv4 address.
	PrivateAddress uint32 `idl:"name:PrivateAddress" json:"private_address"`
}

func (o *IPNATPortMapping) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPNATPortMapping) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Protocol); err != nil {
		return err
	}
	if err := w.WriteData(o.PublicPort); err != nil {
		return err
	}
	if err := w.WriteData(o.PublicAddress); err != nil {
		return err
	}
	if err := w.WriteData(o.PrivatePort); err != nil {
		return err
	}
	if err := w.WriteData(o.PrivateAddress); err != nil {
		return err
	}
	return nil
}
func (o *IPNATPortMapping) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Protocol); err != nil {
		return err
	}
	if err := w.ReadData(&o.PublicPort); err != nil {
		return err
	}
	if err := w.ReadData(&o.PublicAddress); err != nil {
		return err
	}
	if err := w.ReadData(&o.PrivatePort); err != nil {
		return err
	}
	if err := w.ReadData(&o.PrivateAddress); err != nil {
		return err
	}
	return nil
}

// IPNATAddressMapping structure represents IP_NAT_ADDRESS_MAPPING RPC structure.
//
// The IP_NAT_ADDRESS_MAPPING structure holds a static mapping that ties an address
// from this NAT interface's address pool to a specific private-machine's address.
//
// Note  This address MUST fall within one of the ranges comprising the pool as specified
// by the IP_NAT_ADDRESS_RANGE structures.
type IPNATAddressMapping struct {
	// PrivateAddress: The private IP address of the translation.
	PrivateAddress uint32 `idl:"name:PrivateAddress" json:"private_address"`
	// PublicAddress: The public IP address of the translation.
	PublicAddress uint32 `idl:"name:PublicAddress" json:"public_address"`
	// AllowInboundSessions: This is of type BOOLEAN ([MS-DTYP] section 2.2.4). Specifies
	// whether sessions from public networks are allowed.
	AllowInboundSessions bool `idl:"name:AllowInboundSessions" json:"allow_inbound_sessions"`
}

func (o *IPNATAddressMapping) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPNATAddressMapping) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.PrivateAddress); err != nil {
		return err
	}
	if err := w.WriteData(o.PublicAddress); err != nil {
		return err
	}
	if err := w.WriteData(o.AllowInboundSessions); err != nil {
		return err
	}
	if err := w.WriteTrailingGap(4); err != nil {
		return err
	}
	return nil
}
func (o *IPNATAddressMapping) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.PrivateAddress); err != nil {
		return err
	}
	if err := w.ReadData(&o.PublicAddress); err != nil {
		return err
	}
	if err := w.ReadData(&o.AllowInboundSessions); err != nil {
		return err
	}
	if err := w.ReadTrailingGap(4); err != nil {
		return err
	}
	return nil
}

// IPAlgorithmGlobalInfo structure represents IP_ALG_GLOBAL_INFO RPC structure.
//
// The IP_ALG_GLOBAL_INFO structure<138> be used to hold the global configuration for
// the Application Layer Gateway transparent proxy and is used in the following methods:
//
// * *RRouterInterfaceTransportSetGlobalInfo (section 3.1.4.10)* ( 071439e7-a9fd-40e4-91f7-ab756108e82f
// )
//
// * *RRouterInterfaceTransportGetGlobalInfo (section 3.1.4.11)* ( 14ad8d26-d7d7-48dd-914d-da962d5d7049
// )
//
// typedef struct IP_ALG_GLOBAL_INFO {
//
// ULONG LoggingLevel;
//
// ULONG Flags;
type IPAlgorithmGlobalInfo struct {
	// LoggingLevel: Specifies the logging level. It MUST be one of the following values.
	//
	//	+-----------------------------------+----------------------------------------------+
	//	|                                   |                                              |
	//	|               VALUE               |                   MEANING                    |
	//	|                                   |                                              |
	//	+-----------------------------------+----------------------------------------------+
	//	+-----------------------------------+----------------------------------------------+
	//	| IPNATHLP_LOGGING_NONE 0x00000000  | No logging is done.                          |
	//	+-----------------------------------+----------------------------------------------+
	//	| IPNATHLP_LOGGING_ERROR 0x00000001 | Only errors are logged.                      |
	//	+-----------------------------------+----------------------------------------------+
	//	| IPNATHLP_LOGGING_WARN 0x00000002  | Errors and warnings are logged.              |
	//	+-----------------------------------+----------------------------------------------+
	//	| IPNATHLP_LOGGING_INFO 0x00000003  | Errors, warnings, and information is logged. |
	//	+-----------------------------------+----------------------------------------------+
	LoggingLevel uint32 `idl:"name:LoggingLevel" json:"logging_level"`
	// Flags: This MUST be set to 0.
	Flags uint32 `idl:"name:Flags" json:"flags"`
}

func (o *IPAlgorithmGlobalInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *IPAlgorithmGlobalInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.LoggingLevel); err != nil {
		return err
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	return nil
}
func (o *IPAlgorithmGlobalInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.LoggingLevel); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	return nil
}

// RIPGlobalInfo structure represents RIP_GLOBAL_INFO RPC structure.
//
// The RIP_GLOBAL_INFO structure<139> be used to give the global IPX RIP information
// for the RRAS server. When this structure is encapsulated in RTR_TOC_ENTRY (section
// 2.2.1.2.4), the InfoType value used MUST be set to 0x00020000. This structure is
// used in the following methods:
//
// * *RRouterInterfaceTransportSetGlobalInfo (section 3.1.4.10)* ( 071439e7-a9fd-40e4-91f7-ab756108e82f
// )
//
// * *RRouterInterfaceTransportGetGlobalInfo (section 3.1.4.11)* ( 14ad8d26-d7d7-48dd-914d-da962d5d7049
// )
//
// typedef struct _RIP_GLOBAL_INFO {
//
// DWORD EventLogMask;
type RIPGlobalInfo struct {
	// EventLogMask: The mask to manage event logging on the RIP interface on the RRAS server.
	// This MUST be set as combination of one or more of the following flags.
	//
	//	+----------------------------------+----------------------------------+
	//	|                                  |                                  |
	//	|              VALUE               |             MEANING              |
	//	|                                  |                                  |
	//	+----------------------------------+----------------------------------+
	//	+----------------------------------+----------------------------------+
	//	| 0x0000                           | Nothing will be logged.          |
	//	+----------------------------------+----------------------------------+
	//	| EVENTLOG_ERROR_TYPE (0x0001)     | Only errors will be logged.      |
	//	+----------------------------------+----------------------------------+
	//	| EVENTLOG_WARNING_TYPE 0x0002     | Only warnings will be logged.    |
	//	+----------------------------------+----------------------------------+
	//	| EVENTLOG_INFORMATION_TYPE 0x0004 | Only information will be logged. |
	//	+----------------------------------+----------------------------------+
	EventLogMask uint32 `idl:"name:EventLogMask" json:"event_log_mask"`
}

func (o *RIPGlobalInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *RIPGlobalInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.EventLogMask); err != nil {
		return err
	}
	return nil
}
func (o *RIPGlobalInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.EventLogMask); err != nil {
		return err
	}
	return nil
}

// RIPRouteFilterInfo structure represents RIP_ROUTE_FILTER_INFO RPC structure.
//
// The RIP_ROUTE_FILTER_INFO structure contains the information about a route filter
// to which the filter actions specified in RIP_IF_FILTERS (section 2.2.1.2.204) are
// applied. This structure is used in RIP_IF_FILTERS.
type RIPRouteFilterInfo struct {
	// Network: The network to which this filter is to be applied.
	Network []byte `idl:"name:Network" json:"network"`
	// Mask: The mask that MUST be ANDed with the network and with the IP address of the
	// packet to establish a filter match. See [RFC950].
	Mask []byte `idl:"name:Mask" json:"mask"`
}

func (o *RIPRouteFilterInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *RIPRouteFilterInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	for i1 := range o.Network {
		i1 := i1
		if uint64(i1) >= 4 {
			break
		}
		if err := w.WriteData(o.Network[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Network); uint64(i1) < 4; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	for i1 := range o.Mask {
		i1 := i1
		if uint64(i1) >= 4 {
			break
		}
		if err := w.WriteData(o.Mask[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Mask); uint64(i1) < 4; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	return nil
}
func (o *RIPRouteFilterInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	o.Network = make([]byte, 4)
	for i1 := range o.Network {
		i1 := i1
		if err := w.ReadData(&o.Network[i1]); err != nil {
			return err
		}
	}
	o.Mask = make([]byte, 4)
	for i1 := range o.Mask {
		i1 := i1
		if err := w.ReadData(&o.Mask[i1]); err != nil {
			return err
		}
	}
	return nil
}

// RIPInterfaceFilters structure represents RIP_IF_FILTERS RPC structure.
//
// The RIP_IF_FILTERS structure<140> specify the filter data for a RIP for IPX interface.
// This structure is used in RIP_IF_CONFIG (section 2.2.1.2.206). Supply filters are
// applied to the RIP updates supplied by the interface, while the listening filters
// are applied to the RIP updates being listened to by the interface.
type RIPInterfaceFilters struct {
	// SupplyFilterAction: This MUST be set to 0x00000001 to permit data and to 0x00000002
	// to deny data.
	//
	//	+------------+--------------+
	//	|            |              |
	//	|   VALUE    |   MEANING    |
	//	|            |              |
	//	+------------+--------------+
	//	+------------+--------------+
	//	| 0x00000001 | Permit data. |
	//	+------------+--------------+
	//	| 0x00000002 | Deny data.   |
	//	+------------+--------------+
	SupplyFilterAction uint32 `idl:"name:SupplyFilterAction" json:"supply_filter_action"`
	// SupplyFilterCount: The count of supply filters.
	SupplyFilterCount uint32 `idl:"name:SupplyFilterCount" json:"supply_filter_count"`
	// ListenFilterAction: This MUST be set to 0x00000001 to permit data and to 0x00000002
	// to deny data.
	//
	//	+------------+--------------+
	//	|            |              |
	//	|   VALUE    |   MEANING    |
	//	|            |              |
	//	+------------+--------------+
	//	+------------+--------------+
	//	| 0x00000001 | Permit data. |
	//	+------------+--------------+
	//	| 0x00000002 | Deny data.   |
	//	+------------+--------------+
	ListenFilterAction uint32 `idl:"name:ListenFilterAction" json:"listen_filter_action"`
	// ListenFilterCount: The count of listen filters.
	ListenFilterCount uint32 `idl:"name:ListenFilterCount" json:"listen_filter_count"`
	// RouteFilter: This is a RIP_ROUTE_FILTER_INFO (section 2.2.1.2.203).
	RouteFilter []*RIPRouteFilterInfo `idl:"name:RouteFilter" json:"route_filter"`
}

func (o *RIPInterfaceFilters) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *RIPInterfaceFilters) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.SupplyFilterAction); err != nil {
		return err
	}
	if err := w.WriteData(o.SupplyFilterCount); err != nil {
		return err
	}
	if err := w.WriteData(o.ListenFilterAction); err != nil {
		return err
	}
	if err := w.WriteData(o.ListenFilterCount); err != nil {
		return err
	}
	for i1 := range o.RouteFilter {
		i1 := i1
		if uint64(i1) >= 1 {
			break
		}
		if o.RouteFilter[i1] != nil {
			if err := o.RouteFilter[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&RIPRouteFilterInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.RouteFilter); uint64(i1) < 1; i1++ {
		if err := (&RIPRouteFilterInfo{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteTrailingGap(4); err != nil {
		return err
	}
	return nil
}
func (o *RIPInterfaceFilters) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.SupplyFilterAction); err != nil {
		return err
	}
	if err := w.ReadData(&o.SupplyFilterCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.ListenFilterAction); err != nil {
		return err
	}
	if err := w.ReadData(&o.ListenFilterCount); err != nil {
		return err
	}
	o.RouteFilter = make([]*RIPRouteFilterInfo, 1)
	for i1 := range o.RouteFilter {
		i1 := i1
		if o.RouteFilter[i1] == nil {
			o.RouteFilter[i1] = &RIPRouteFilterInfo{}
		}
		if err := o.RouteFilter[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.ReadTrailingGap(4); err != nil {
		return err
	}
	return nil
}

// RIPInterfaceConfig structure represents RIP_IF_CONFIG RPC structure.
//
// The RIP_IF_CONFIG structure<142> be used to specify the configuration information
// of a RIP for IPX interface. When this structure is encapsulated in RTR_TOC_ENTRY
// (section 2.2.1.2.4), the InfoType value used MUST be set to 0x00020000 and the transport
// MUST be PID_IPX.
type RIPInterfaceConfig struct {
	// RipIfInfo: This MUST be a RIP_IF_INFO (section 2.2.1.2.205) structure.
	RIPInterfaceInfo *RIPInterfaceInfo `idl:"name:RipIfInfo" json:"rip_interface_info"`
	// RipIfFilters: This MUST be a RIP_IF_FILTERS (section 2.2.1.2.204) structure.
	RIPInterfaceFilters *RIPInterfaceFilters `idl:"name:RipIfFilters" json:"rip_interface_filters"`
}

func (o *RIPInterfaceConfig) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *RIPInterfaceConfig) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if o.RIPInterfaceInfo != nil {
		if err := o.RIPInterfaceInfo.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&RIPInterfaceInfo{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.RIPInterfaceFilters != nil {
		if err := o.RIPInterfaceFilters.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&RIPInterfaceFilters{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *RIPInterfaceConfig) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if o.RIPInterfaceInfo == nil {
		o.RIPInterfaceInfo = &RIPInterfaceInfo{}
	}
	if err := o.RIPInterfaceInfo.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.RIPInterfaceFilters == nil {
		o.RIPInterfaceFilters = &RIPInterfaceFilters{}
	}
	if err := o.RIPInterfaceFilters.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// SAPGlobalInfo structure represents SAP_GLOBAL_INFO RPC structure.
//
// The SAP_GLOBAL_INFO structure<143>  be used to give the global SAP information for
// the RRAS server. When this structure is encapsulated in RTR_TOC_ENTRY (section 2.2.1.2.4),
// the InfoType value used MUST be set to 0x00020001 and the transport MUST be PID_IPX.
type SAPGlobalInfo struct {
	// EventLogMask: The mask to manage event logging on the SAP interface on the RRAS server.
	// This MUST be set as combination of one or more following flags.
	//
	//	+----------------------------------+----------------------------------+
	//	|                                  |                                  |
	//	|              VALUE               |             MEANING              |
	//	|                                  |                                  |
	//	+----------------------------------+----------------------------------+
	//	+----------------------------------+----------------------------------+
	//	| 0x0000                           | Nothing will be logged.          |
	//	+----------------------------------+----------------------------------+
	//	| EVENTLOG_ERROR_TYPE (0x0001)     | Only errors will be logged.      |
	//	+----------------------------------+----------------------------------+
	//	| EVENTLOG_WARNING_TYPE 0x0002     | Only warnings will be logged.    |
	//	+----------------------------------+----------------------------------+
	//	| EVENTLOG_INFORMATION_TYPE 0x0004 | Only information will be logged. |
	//	+----------------------------------+----------------------------------+
	EventLogMask uint32 `idl:"name:EventLogMask" json:"event_log_mask"`
}

func (o *SAPGlobalInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *SAPGlobalInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.EventLogMask); err != nil {
		return err
	}
	return nil
}
func (o *SAPGlobalInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.EventLogMask); err != nil {
		return err
	}
	return nil
}

// OSPFRouteFilter structure represents OSPF_ROUTE_FILTER RPC structure.
//
// The OSPF_ROUTE_FILTER structure MAY<144> be used as part of OSPF_ROUTE_FILTER_INFO
// (section 2.2.1.2.209) structure.
type OSPFRouteFilter struct {
	// dwAddress: The IPV4 address or subnet.
	Address uint32 `idl:"name:dwAddress" json:"address"`
	// dwMask: The IP subnet mask. See [RFC950].
	Mask uint32 `idl:"name:dwMask" json:"mask"`
}

func (o *OSPFRouteFilter) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *OSPFRouteFilter) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Address); err != nil {
		return err
	}
	if err := w.WriteData(o.Mask); err != nil {
		return err
	}
	return nil
}
func (o *OSPFRouteFilter) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Address); err != nil {
		return err
	}
	if err := w.ReadData(&o.Mask); err != nil {
		return err
	}
	return nil
}

// OSPFFilterAction type represents OSPF_FILTER_ACTION RPC enumeration.
//
// The OSPF_FILTER_ACTION enumeration is used to determine whether or not a route is
// added to the OSPF database.
type OSPFFilterAction uint16

var (
	// ACTION_DROP: The route is not added to the OSPF database.
	OSPFFilterActionDrop OSPFFilterAction = 0
	// ACTION_ACCEPT: The route is added to the OSPF database.
	OSPFFilterActionAccept OSPFFilterAction = 1
)

func (o OSPFFilterAction) String() string {
	switch o {
	case OSPFFilterActionDrop:
		return "OSPFFilterActionDrop"
	case OSPFFilterActionAccept:
		return "OSPFFilterActionAccept"
	}
	return "Invalid"
}

// OSPFRouteFilterInfo structure represents OSPF_ROUTE_FILTER_INFO RPC structure.
//
// The OSPF_ROUTE_FILTER_INFO structure MAY<145> be used to contain OSPF route filter
// information and is used by the following methods:
//
// * *RRouterInterfaceTransportSetGlobalInfo (section 3.1.4.10)* ( 071439e7-a9fd-40e4-91f7-ab756108e82f
// )
//
// * *RRouterInterfaceTransportGetGlobalInfo (section 3.1.4.11)* ( 14ad8d26-d7d7-48dd-914d-da962d5d7049
// )
//
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| type                                                                                                                          |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ofaActionOnMatch                                                                                                              |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwNumFilters                                                                                                                  |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| pFilters (variable)                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
type OSPFRouteFilterInfo struct {
	// type (4 bytes): This MUST be set to OSPF_ROUTE_FILTER_PARAM_TYPE.
	Type uint32 `idl:"name:type" json:"type"`
	// ofaActionOnMatch (4 bytes): Set to 0 or 1 as mentioned in OSPF_FILTER_ACTION (section
	// 2.2.1.1.15).
	ActionOnMatch OSPFFilterAction `idl:"name:ofaActionOnMatch" json:"action_on_match"`
	// dwNumFilters (4 bytes): Set to the number of route filters present in the pFilters
	// field.
	FiltersLength uint32 `idl:"name:dwNumFilters" json:"filters_length"`
	// pFilters (variable): List of route filters. This points to a buffer that contains
	// a list of structures of type OSPF_ROUTE_FILTER (section 2.2.1.2.208).
	Filters []*OSPFRouteFilter `idl:"name:pFilters" json:"filters"`
}

func (o *OSPFRouteFilterInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *OSPFRouteFilterInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Type); err != nil {
		return err
	}
	if err := w.WriteEnum(uint16(o.ActionOnMatch)); err != nil {
		return err
	}
	if err := w.WriteData(o.FiltersLength); err != nil {
		return err
	}
	for i1 := range o.Filters {
		i1 := i1
		if uint64(i1) >= 1 {
			break
		}
		if o.Filters[i1] != nil {
			if err := o.Filters[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&OSPFRouteFilter{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.Filters); uint64(i1) < 1; i1++ {
		if err := (&OSPFRouteFilter{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *OSPFRouteFilterInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Type); err != nil {
		return err
	}
	if err := w.ReadEnum((*uint16)(&o.ActionOnMatch)); err != nil {
		return err
	}
	if err := w.ReadData(&o.FiltersLength); err != nil {
		return err
	}
	o.Filters = make([]*OSPFRouteFilter, 1)
	for i1 := range o.Filters {
		i1 := i1
		if o.Filters[i1] == nil {
			o.Filters[i1] = &OSPFRouteFilter{}
		}
		if err := o.Filters[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// OSPFProtoFilterInfo structure represents OSPF_PROTO_FILTER_INFO RPC structure.
//
// The OSPF_PROTO_FILTER_INFO structure MAY<146> be used to contain the OSPF protocol
// filter information and is used by the following methods:
//
// * *RRouterInterfaceTransportSetGlobalInfo (section 3.1.4.10)* ( 071439e7-a9fd-40e4-91f7-ab756108e82f
// )
//
// * *RRouterInterfaceTransportGetGlobalInfo (section 3.1.4.11)* ( 14ad8d26-d7d7-48dd-914d-da962d5d7049
// )
//
// typedef struct _OSPF_PROTO_FILTER_INFO {
//
// DWORD type;
//
// OSPF_FILTER_ACTION ofaActionOnMatch;
//
// DWORD dwNumProtoIds;
//
// DWORD pdwProtoId[1];
type OSPFProtoFilterInfo struct {
	// type: This MUST be set to OSPF_PROTO_FILTER_INFO_TYPE.
	Type uint32 `idl:"name:type" json:"type"`
	// ofaActionOnMatch: Set to 0 or 1 as mentioned in OSPF_FILTER_ACTION (section 2.2.1.1.15).
	ActionOnMatch OSPFFilterAction `idl:"name:ofaActionOnMatch" json:"action_on_match"`
	// dwNumProtoIds: The number of protocol IDs present in the pdwProtoId field.
	ProtoIDsLength uint32 `idl:"name:dwNumProtoIds" json:"proto_ids_length"`
	// pdwProtoId: A list of protocol IDs. This list MUST contain one or more values defined
	// in MIB_IPFORWARD_PROTO (section 2.2.1.1.9). All other values are ignored.
	ProtoID []uint32 `idl:"name:pdwProtoId" json:"proto_id"`
}

func (o *OSPFProtoFilterInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *OSPFProtoFilterInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Type); err != nil {
		return err
	}
	if err := w.WriteEnum(uint16(o.ActionOnMatch)); err != nil {
		return err
	}
	if err := w.WriteData(o.ProtoIDsLength); err != nil {
		return err
	}
	for i1 := range o.ProtoID {
		i1 := i1
		if uint64(i1) >= 1 {
			break
		}
		if err := w.WriteData(o.ProtoID[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.ProtoID); uint64(i1) < 1; i1++ {
		if err := w.WriteData(uint32(0)); err != nil {
			return err
		}
	}
	return nil
}
func (o *OSPFProtoFilterInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Type); err != nil {
		return err
	}
	if err := w.ReadEnum((*uint16)(&o.ActionOnMatch)); err != nil {
		return err
	}
	if err := w.ReadData(&o.ProtoIDsLength); err != nil {
		return err
	}
	o.ProtoID = make([]uint32, 1)
	for i1 := range o.ProtoID {
		i1 := i1
		if err := w.ReadData(&o.ProtoID[i1]); err != nil {
			return err
		}
	}
	return nil
}

// OSPFGlobalParam structure represents OSPF_GLOBAL_PARAM RPC structure.
//
// The OSPF_GLOBAL_PARAM structure MAY<147> be used to contain the OPSF global parameters
// and is used by the following methods:
//
// * *RRouterInterfaceTransportSetGlobalInfo (section 3.1.4.10)* ( 071439e7-a9fd-40e4-91f7-ab756108e82f
// )
//
// * *RRouterInterfaceTransportGetGlobalInfo (section 3.1.4.11)* ( 14ad8d26-d7d7-48dd-914d-da962d5d7049
// )
//
// typedef struct _OSPF_GLOBAL_PARAM {
//
// DWORD type;
//
// DWORD create;
//
// DWORD enable;
//
// DWORD routerId;
//
// DWORD ASBrdrRtr;
//
// DWORD logLevel;
type OSPFGlobalParam struct {
	// type: This MUST be set to OSPF_GLOBAL_PARAM_TYPE.
	Type uint32 `idl:"name:type" json:"type"`
	// create: Set to 1 if the configuration needs to be created or set to 2 if it needs
	// to be deleted.
	Create uint32 `idl:"name:create" json:"create"`
	// enable: Set to 1 if the configuration needs to be enabled or set to 2 if it needs
	// to be deleted.
	Enable uint32 `idl:"name:enable" json:"enable"`
	// routerId: This can be any value, or the IP address of the router, and MUST NOT be
	// zero.
	RouterID uint32 `idl:"name:routerId" json:"router_id"`
	// ASBrdrRtr: If it is the boundary router set to 1, otherwise set to 2.
	ASBorderRouter uint32 `idl:"name:ASBrdrRtr" json:"as_border_router"`
	// logLevel: Set to 0 if no logging, 1 if an error, 2 if a warning, and 3 if information.
	LogLevel uint32 `idl:"name:logLevel" json:"log_level"`
}

func (o *OSPFGlobalParam) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *OSPFGlobalParam) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Type); err != nil {
		return err
	}
	if err := w.WriteData(o.Create); err != nil {
		return err
	}
	if err := w.WriteData(o.Enable); err != nil {
		return err
	}
	if err := w.WriteData(o.RouterID); err != nil {
		return err
	}
	if err := w.WriteData(o.ASBorderRouter); err != nil {
		return err
	}
	if err := w.WriteData(o.LogLevel); err != nil {
		return err
	}
	return nil
}
func (o *OSPFGlobalParam) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Type); err != nil {
		return err
	}
	if err := w.ReadData(&o.Create); err != nil {
		return err
	}
	if err := w.ReadData(&o.Enable); err != nil {
		return err
	}
	if err := w.ReadData(&o.RouterID); err != nil {
		return err
	}
	if err := w.ReadData(&o.ASBorderRouter); err != nil {
		return err
	}
	if err := w.ReadData(&o.LogLevel); err != nil {
		return err
	}
	return nil
}

// OSPFAreaParam structure represents OSPF_AREA_PARAM RPC structure.
//
// The OSPF_AREA_PARAM structure MAY<148> be used to contain the OSPF area parameters
// and is used by the following methods:
//
// * *RRouterInterfaceTransportSetGlobalInfo (section 3.1.4.10)* ( 071439e7-a9fd-40e4-91f7-ab756108e82f
// )
//
// * *RRouterInterfaceTransportGetGlobalInfo (section 3.1.4.11)* ( 14ad8d26-d7d7-48dd-914d-da962d5d7049
// )
//
// When calling RRouterInterfaceTransportSetGlobalInfo you MUST NOT delete the area
// with the areaId set to 0.0.0.0, which works as the backbone area for the OSPF, otherwise
// the method will return a failure.
type OSPFAreaParam struct {
	// type: This MUST be set to OSPF_AREA_PARAM_TYPE.
	Type uint32 `idl:"name:type" json:"type"`
	// create: Set to 1 if the configuration needs to be created or set to 2 if it needs
	// to be deleted.
	Create uint32 `idl:"name:create" json:"create"`
	// enable: Set to 1 if the configuration needs to be enabled or set to 2 if it needs
	// to be deleted.
	Enable uint32 `idl:"name:enable" json:"enable"`
	// areaId: Set to 0 if it is border. Otherwise, set to any nonzero value.
	AreaID uint32 `idl:"name:areaId" json:"area_id"`
	// authType: Set to 1 if there is no password or set to 2 for a simple password.
	AuthType uint32 `idl:"name:authType" json:"auth_type"`
	// importASExtern: Set to 1 if yes, 2 for no.
	ImportAsExtern uint32 `idl:"name:importASExtern" json:"import_as_extern"`
	// stubMetric: Stub area metric. It MUST be set to a value between 1 and USHORTMAX/2.
	StubMetric uint32 `idl:"name:stubMetric" json:"stub_metric"`
	// importSumAdv: The import summary advertisement. Set to 1 if yes, 2 for no.
	ImportSumAdv uint32 `idl:"name:importSumAdv" json:"import_sum_adv"`
}

func (o *OSPFAreaParam) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *OSPFAreaParam) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Type); err != nil {
		return err
	}
	if err := w.WriteData(o.Create); err != nil {
		return err
	}
	if err := w.WriteData(o.Enable); err != nil {
		return err
	}
	if err := w.WriteData(o.AreaID); err != nil {
		return err
	}
	if err := w.WriteData(o.AuthType); err != nil {
		return err
	}
	if err := w.WriteData(o.ImportAsExtern); err != nil {
		return err
	}
	if err := w.WriteData(o.StubMetric); err != nil {
		return err
	}
	if err := w.WriteData(o.ImportSumAdv); err != nil {
		return err
	}
	return nil
}
func (o *OSPFAreaParam) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Type); err != nil {
		return err
	}
	if err := w.ReadData(&o.Create); err != nil {
		return err
	}
	if err := w.ReadData(&o.Enable); err != nil {
		return err
	}
	if err := w.ReadData(&o.AreaID); err != nil {
		return err
	}
	if err := w.ReadData(&o.AuthType); err != nil {
		return err
	}
	if err := w.ReadData(&o.ImportAsExtern); err != nil {
		return err
	}
	if err := w.ReadData(&o.StubMetric); err != nil {
		return err
	}
	if err := w.ReadData(&o.ImportSumAdv); err != nil {
		return err
	}
	return nil
}

// OSPFAreaRangeParam structure represents OSPF_AREA_RANGE_PARAM RPC structure.
//
// The OSPF_AREA_RANGE_PARAM structure MAY<149> be used to contain the OSPF area range
// parameters. This structure is used by the following methods:
//
// * *RRouterInterfaceTransportSetGlobalInfo (section 3.1.4.10)* ( 071439e7-a9fd-40e4-91f7-ab756108e82f
// )
//
// * *RRouterInterfaceTransportGetGlobalInfo (section 3.1.4.11)* ( 14ad8d26-d7d7-48dd-914d-da962d5d7049
// )
//
// typedef struct _OSPF_AREA_RANGE_PARAM {
//
// DWORD type;
//
// DWORD create;
//
// DWORD enable;
//
// DWORD areaId;
//
// DWORD rangeNet;
//
// DWORD rangeMask;
type OSPFAreaRangeParam struct {
	// type: This MUST be set to OSPF_AREA_RANGE_PARAM_TYPE.
	Type uint32 `idl:"name:type" json:"type"`
	// create: Set to 1 if the configuration needs to be created or set to 2 if it needs
	// to be deleted.
	Create uint32 `idl:"name:create" json:"create"`
	// enable: Set to 1 if the configuration needs to be enabled or set to 2 if it needs
	// to be deleted.
	Enable uint32 `idl:"name:enable" json:"enable"`
	// areaId: Set to 0 if it is a border. Otherwise, set it to any nonzero value.
	AreaID uint32 `idl:"name:areaId" json:"area_id"`
	// rangeNet: The IP address of the subnet.
	RangeNet uint32 `idl:"name:rangeNet" json:"range_net"`
	// rangeMask: The mask of the IP address subnet.
	RangeMask uint32 `idl:"name:rangeMask" json:"range_mask"`
}

func (o *OSPFAreaRangeParam) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *OSPFAreaRangeParam) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Type); err != nil {
		return err
	}
	if err := w.WriteData(o.Create); err != nil {
		return err
	}
	if err := w.WriteData(o.Enable); err != nil {
		return err
	}
	if err := w.WriteData(o.AreaID); err != nil {
		return err
	}
	if err := w.WriteData(o.RangeNet); err != nil {
		return err
	}
	if err := w.WriteData(o.RangeMask); err != nil {
		return err
	}
	return nil
}
func (o *OSPFAreaRangeParam) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Type); err != nil {
		return err
	}
	if err := w.ReadData(&o.Create); err != nil {
		return err
	}
	if err := w.ReadData(&o.Enable); err != nil {
		return err
	}
	if err := w.ReadData(&o.AreaID); err != nil {
		return err
	}
	if err := w.ReadData(&o.RangeNet); err != nil {
		return err
	}
	if err := w.ReadData(&o.RangeMask); err != nil {
		return err
	}
	return nil
}

// OSPFVirtualInterfaceParam structure represents OSPF_VIRT_INTERFACE_PARAM RPC structure.
//
// The OSPF_VIRT_INTERFACE_PARAM structure MAY<150> be used to contain the OSPF virtual
// interface parameters and is used by the following methods:
//
// * *RRouterInterfaceTransportSetGlobalInfo (section 3.1.4.10)* ( 071439e7-a9fd-40e4-91f7-ab756108e82f
// )
//
// * *RRouterInterfaceTransportGetGlobalInfo (section 3.1.4.11)* ( 14ad8d26-d7d7-48dd-914d-da962d5d7049
// )
//
// typedef struct _OSPF_VIRT_INTERFACE_PARAM {
//
// DWORD type;
//
// DWORD create;
//
// DWORD enable;
//
// DWORD transitAreaId;
//
// DWORD virtNeighborRouterId;
//
// DWORD transitDelay;
//
// DWORD retransInterval;
//
// DWORD helloInterval;
//
// DWORD deadInterval;
//
// BYTE password[8];
type OSPFVirtualInterfaceParam struct {
	// type: This MUST be set to OSPF_VIRT_INTF_PARAM_TYPE.
	Type uint32 `idl:"name:type" json:"type"`
	// create: Set to 1 if the configuration needs to be created or set to 2 if it needs
	// to be deleted.
	Create uint32 `idl:"name:create" json:"create"`
	// enable: Set to 1 if the configuration needs to be enabled or set to 2 if it needs
	// to be deleted.
	Enable uint32 `idl:"name:enable" json:"enable"`
	// transitAreaId: The transit area ID. It MUST not be set to 0; it MUST be set to an
	// IP address.
	TransitAreaID uint32 `idl:"name:transitAreaId" json:"transit_area_id"`
	// virtNeighborRouterId: The virtual neighbor router ID (for example, the IP address).
	VirtualNeighborRouterID uint32 `idl:"name:virtNeighborRouterId" json:"virtual_neighbor_router_id"`
	// transitDelay: This MUST be set to a value a value between 1 and 3600.
	TransitDelay uint32 `idl:"name:transitDelay" json:"transit_delay"`
	// retransInterval: This MUST be set to a value between 1 and 3600.
	RetransimitInterval uint32 `idl:"name:retransInterval" json:"retransimit_interval"`
	// helloInterval: This MUST be set to a value between 1 and USHORTMAX/2.
	HelloInterval uint32 `idl:"name:helloInterval" json:"hello_interval"`
	// deadInterval: This MUST be set to a value between 1 and USHORTMAX/2.
	DeadInterval uint32 `idl:"name:deadInterval" json:"dead_interval"`
	// password: The password.
	Password []byte `idl:"name:password" json:"password"`
}

func (o *OSPFVirtualInterfaceParam) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *OSPFVirtualInterfaceParam) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Type); err != nil {
		return err
	}
	if err := w.WriteData(o.Create); err != nil {
		return err
	}
	if err := w.WriteData(o.Enable); err != nil {
		return err
	}
	if err := w.WriteData(o.TransitAreaID); err != nil {
		return err
	}
	if err := w.WriteData(o.VirtualNeighborRouterID); err != nil {
		return err
	}
	if err := w.WriteData(o.TransitDelay); err != nil {
		return err
	}
	if err := w.WriteData(o.RetransimitInterval); err != nil {
		return err
	}
	if err := w.WriteData(o.HelloInterval); err != nil {
		return err
	}
	if err := w.WriteData(o.DeadInterval); err != nil {
		return err
	}
	for i1 := range o.Password {
		i1 := i1
		if uint64(i1) >= 8 {
			break
		}
		if err := w.WriteData(o.Password[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Password); uint64(i1) < 8; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteTrailingGap(4); err != nil {
		return err
	}
	return nil
}
func (o *OSPFVirtualInterfaceParam) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Type); err != nil {
		return err
	}
	if err := w.ReadData(&o.Create); err != nil {
		return err
	}
	if err := w.ReadData(&o.Enable); err != nil {
		return err
	}
	if err := w.ReadData(&o.TransitAreaID); err != nil {
		return err
	}
	if err := w.ReadData(&o.VirtualNeighborRouterID); err != nil {
		return err
	}
	if err := w.ReadData(&o.TransitDelay); err != nil {
		return err
	}
	if err := w.ReadData(&o.RetransimitInterval); err != nil {
		return err
	}
	if err := w.ReadData(&o.HelloInterval); err != nil {
		return err
	}
	if err := w.ReadData(&o.DeadInterval); err != nil {
		return err
	}
	o.Password = make([]byte, 8)
	for i1 := range o.Password {
		i1 := i1
		if err := w.ReadData(&o.Password[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadTrailingGap(4); err != nil {
		return err
	}
	return nil
}

// OSPFInterfaceParam structure represents OSPF_INTERFACE_PARAM RPC structure.
//
// The OSPF_INTERFACE_PARAM structure MAY<151> be used to contain the OSPF Non-Broadcast
// Multiple Access (NBMA) neighbor parameters and is used in the following methods:
//
// * *RRouterInterfaceTransportAdd (section 3.1.4.18)* ( 927c5bf1-ac91-4325-b945-0d96a58f609b
// )
//
// * *RRouterInterfaceTransportGetInfo (section 3.1.4.19)* ( ec9ba293-45e9-4f12-b9af-7e77ec96c90e
// )
//
// * *RRouterInterfaceTransportSetInfo (section 3.1.4.20)* ( 209ba5e7-876e-4406-a05c-65b7e5fb2380
// )
//
// typedef struct _OSPF_INTERFACE_PARAM {
//
// DWORD type;
//
// DWORD create;
//
// DWORD enable;
//
// DWORD intfIpAddr;
//
// DWORD intfSubnetMask;
//
// DWORD areaId;
//
// DWORD intfType;
//
// DWORD routerPriority;
//
// DWORD transitDelay;
//
// DWORD retransInterval;
//
// DWORD helloInterval;
//
// DWORD deadInterval;
//
// DWORD pollInterval;
//
// DWORD metricCost;
//
// BYTE password[8];
//
// DWORD mtuSize;
type OSPFInterfaceParam struct {
	// type: This MUST be set to OSPF_INTF_PARAM_TYPE.
	Type uint32 `idl:"name:type" json:"type"`
	// create: This MUST be set to 1 if the configuration needs to be created or set to
	// 2 if it needs to be deleted.
	Create uint32 `idl:"name:create" json:"create"`
	// enable: This MUST set to 1 if the configuration needs to be enabled or set to 2 if
	// it needs to be deleted.
	Enable uint32 `idl:"name:enable" json:"enable"`
	// intfIpAddr: The interface address on which the OSPF is enabled.
	InterfaceIPAddr uint32 `idl:"name:intfIpAddr" json:"interface_ip_addr"`
	// intfSubnetMask: The interface subnet address on which the OSPF is enabled. See [RFC950].
	InterfaceSubnetMask uint32 `idl:"name:intfSubnetMask" json:"interface_subnet_mask"`
	// areaId: The area ID of the OSPF area of which the interface is a part.
	AreaID uint32 `idl:"name:areaId" json:"area_id"`
	// intfType: Set to 1 for broadcast, set to 2 for NBMA, and set to 3 for point-to-point.
	InterfaceType uint32 `idl:"name:intfType" json:"interface_type"`
	// routerPriority: This MUST be set to a value between 1 and 255.
	RouterPriority uint32 `idl:"name:routerPriority" json:"router_priority"`
	// transitDelay: This MUST be set to a value between 1 and 3600.
	TransitDelay uint32 `idl:"name:transitDelay" json:"transit_delay"`
	// retransInterval: This MUST be set to a value between 1 and 3600.
	RetransimitInterval uint32 `idl:"name:retransInterval" json:"retransimit_interval"`
	// helloInterval: This MUST be set to a value between 1 and USHORTMAX/2.
	HelloInterval uint32 `idl:"name:helloInterval" json:"hello_interval"`
	// deadInterval: This MUST be set to a value between 1 and USHORTMAX/2.
	DeadInterval uint32 `idl:"name:deadInterval" json:"dead_interval"`
	// pollInterval: This MUST be set to a value between 1 and USHORTMAX/2.
	PollInterval uint32 `idl:"name:pollInterval" json:"poll_interval"`
	// metricCost: This MUST be set to a value between 1 and USHORTMAX/2.
	//
	// password[8]: The password.
	MetricCost uint32 `idl:"name:metricCost" json:"metric_cost"`
	Password   []byte `idl:"name:password" json:"password"`
	// mtuSize: This MUST be set to a value between 1 and 10000.
	MTUSize uint32 `idl:"name:mtuSize" json:"mtu_size"`
}

func (o *OSPFInterfaceParam) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *OSPFInterfaceParam) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Type); err != nil {
		return err
	}
	if err := w.WriteData(o.Create); err != nil {
		return err
	}
	if err := w.WriteData(o.Enable); err != nil {
		return err
	}
	if err := w.WriteData(o.InterfaceIPAddr); err != nil {
		return err
	}
	if err := w.WriteData(o.InterfaceSubnetMask); err != nil {
		return err
	}
	if err := w.WriteData(o.AreaID); err != nil {
		return err
	}
	if err := w.WriteData(o.InterfaceType); err != nil {
		return err
	}
	if err := w.WriteData(o.RouterPriority); err != nil {
		return err
	}
	if err := w.WriteData(o.TransitDelay); err != nil {
		return err
	}
	if err := w.WriteData(o.RetransimitInterval); err != nil {
		return err
	}
	if err := w.WriteData(o.HelloInterval); err != nil {
		return err
	}
	if err := w.WriteData(o.DeadInterval); err != nil {
		return err
	}
	if err := w.WriteData(o.PollInterval); err != nil {
		return err
	}
	if err := w.WriteData(o.MetricCost); err != nil {
		return err
	}
	for i1 := range o.Password {
		i1 := i1
		if uint64(i1) >= 8 {
			break
		}
		if err := w.WriteData(o.Password[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Password); uint64(i1) < 8; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.MTUSize); err != nil {
		return err
	}
	return nil
}
func (o *OSPFInterfaceParam) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Type); err != nil {
		return err
	}
	if err := w.ReadData(&o.Create); err != nil {
		return err
	}
	if err := w.ReadData(&o.Enable); err != nil {
		return err
	}
	if err := w.ReadData(&o.InterfaceIPAddr); err != nil {
		return err
	}
	if err := w.ReadData(&o.InterfaceSubnetMask); err != nil {
		return err
	}
	if err := w.ReadData(&o.AreaID); err != nil {
		return err
	}
	if err := w.ReadData(&o.InterfaceType); err != nil {
		return err
	}
	if err := w.ReadData(&o.RouterPriority); err != nil {
		return err
	}
	if err := w.ReadData(&o.TransitDelay); err != nil {
		return err
	}
	if err := w.ReadData(&o.RetransimitInterval); err != nil {
		return err
	}
	if err := w.ReadData(&o.HelloInterval); err != nil {
		return err
	}
	if err := w.ReadData(&o.DeadInterval); err != nil {
		return err
	}
	if err := w.ReadData(&o.PollInterval); err != nil {
		return err
	}
	if err := w.ReadData(&o.MetricCost); err != nil {
		return err
	}
	o.Password = make([]byte, 8)
	for i1 := range o.Password {
		i1 := i1
		if err := w.ReadData(&o.Password[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.MTUSize); err != nil {
		return err
	}
	return nil
}

// OSPFNBMANeighborParam structure represents OSPF_NBMA_NEIGHBOR_PARAM RPC structure.
//
// The OSPF_NBMA_NEIGHBOR_PARAM structure MAY<152> be used to contain the OSPF NBMA
// neighbor parameters and is used in the following methods:
//
// * *RRouterInterfaceTransportAdd (section 3.1.4.18)* ( 927c5bf1-ac91-4325-b945-0d96a58f609b
// )
//
// * *RRouterInterfaceTransportGetInfo (section 3.1.4.19)* ( ec9ba293-45e9-4f12-b9af-7e77ec96c90e
// )
//
// * *RRouterInterfaceTransportSetInfo (section 3.1.4.20)* ( 209ba5e7-876e-4406-a05c-65b7e5fb2380
// )
//
// typedef struct _OSPF_NBMA_NEIGHBOR_PARAM {
//
// DWORD type;
//
// DWORD create;
//
// DWORD enable;
//
// DWORD neighborIpAddr;
//
// DWORD intfIpAddr;
//
// DWORD neighborPriority;
type OSPFNBMANeighborParam struct {
	// type: This MUST be set to OSPF_NEIGHBOR_PARAM_TYPE.
	Type uint32 `idl:"name:type" json:"type"`
	// create: Set to 1 if the configuration needs to be created or set to 2 if it needs
	// to be deleted.
	Create uint32 `idl:"name:create" json:"create"`
	// enable: Set to 1 if the configuration needs to be created or set to 2 if it needs
	// to be deleted.
	Enable uint32 `idl:"name:enable" json:"enable"`
	// neighborIpAddr: The neighbor IP address.
	NeighborIPAddr uint32 `idl:"name:neighborIpAddr" json:"neighbor_ip_addr"`
	// intfIpAddr: The interface IP address.
	InterfaceIPAddr uint32 `idl:"name:intfIpAddr" json:"interface_ip_addr"`
	// neighborPriority: The priority of the neighbor.
	NeighborPriority uint32 `idl:"name:neighborPriority" json:"neighbor_priority"`
}

func (o *OSPFNBMANeighborParam) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *OSPFNBMANeighborParam) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Type); err != nil {
		return err
	}
	if err := w.WriteData(o.Create); err != nil {
		return err
	}
	if err := w.WriteData(o.Enable); err != nil {
		return err
	}
	if err := w.WriteData(o.NeighborIPAddr); err != nil {
		return err
	}
	if err := w.WriteData(o.InterfaceIPAddr); err != nil {
		return err
	}
	if err := w.WriteData(o.NeighborPriority); err != nil {
		return err
	}
	return nil
}
func (o *OSPFNBMANeighborParam) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Type); err != nil {
		return err
	}
	if err := w.ReadData(&o.Create); err != nil {
		return err
	}
	if err := w.ReadData(&o.Enable); err != nil {
		return err
	}
	if err := w.ReadData(&o.NeighborIPAddr); err != nil {
		return err
	}
	if err := w.ReadData(&o.InterfaceIPAddr); err != nil {
		return err
	}
	if err := w.ReadData(&o.NeighborPriority); err != nil {
		return err
	}
	return nil
}

// RASDeviceType type represents RASDEVICETYPE RPC enumeration.
//
// The RASDEVICETYPE type enumeration defines the different device types on the RRAS
// server.
type RASDeviceType uint32

var (
	// RDT_Modem: Modem device
	RASDeviceTypeModem RASDeviceType = 0
	// RDT_X25: X.25 device
	RASDeviceTypeX25 RASDeviceType = 1
	// RDT_Isdn: ISDN device
	RASDeviceTypeISDN RASDeviceType = 2
	// RDT_Serial: Serial port device
	RASDeviceTypeSerial RASDeviceType = 3
	// RDT_FrameRelay: Frame relay device
	RASDeviceTypeFrameRelay RASDeviceType = 4
	// RDT_Atm: Asynchronous transfer mode (ATM) device
	RASDeviceTypeATM RASDeviceType = 5
	// RDT_Sonet: Sonet device
	RASDeviceTypeSONET RASDeviceType = 6
	// RDT_Sw56: Switched 56K access device
	RASDeviceTypeSW56 RASDeviceType = 7
	// RDT_Tunnel_Pptp: PPTP device
	RASDeviceTypeTunnelPPTP RASDeviceType = 8
	// RDT_Tunnel_L2tp: L2TP device
	RASDeviceTypeTunnelL2TP RASDeviceType = 9
	// RDT_Irda: Infrared Data Association (IrDA) device.
	RASDeviceTypeIRDA RASDeviceType = 10
	// RDT_Parallel: Parallel port device.
	RASDeviceTypeParallel RASDeviceType = 11
	// RDT_Other: Any other device.
	RASDeviceTypeOther RASDeviceType = 12
	// RDT_PPPoE: PPPoE device.<10>
	RASDeviceTypePPPoE RASDeviceType = 13
	// RDT_Tunnel_Sstp: SSTP device.<11>
	RASDeviceTypeTunnelSSTP RASDeviceType = 14
	// RDT_Tunnel_Ikev2: IKEv2 device.<12>
	RASDeviceTypeTunnelIKEv2 RASDeviceType = 15
	// RDT_Tunnel: Specifies the tunnel device class like PPTP, L2TP, SSTP, IKEv2.
	RASDeviceTypeTunnel RASDeviceType = 65536
	// RDT_Direct: Specifies the direct device class like Serial, Parallel.
	RASDeviceTypeDirect RASDeviceType = 131072
	// RDT_Null_Modem: Specifies modem device class like Modem, Isdn, Irda.
	RASDeviceTypeNullModem RASDeviceType = 262144
	// RDT_Broadband: Specifies broadband device class like PPPoE.<13>
	RASDeviceTypeBroadband RASDeviceType = 524288
)

func (o RASDeviceType) String() string {
	switch o {
	case RASDeviceTypeModem:
		return "RASDeviceTypeModem"
	case RASDeviceTypeX25:
		return "RASDeviceTypeX25"
	case RASDeviceTypeISDN:
		return "RASDeviceTypeISDN"
	case RASDeviceTypeSerial:
		return "RASDeviceTypeSerial"
	case RASDeviceTypeFrameRelay:
		return "RASDeviceTypeFrameRelay"
	case RASDeviceTypeATM:
		return "RASDeviceTypeATM"
	case RASDeviceTypeSONET:
		return "RASDeviceTypeSONET"
	case RASDeviceTypeSW56:
		return "RASDeviceTypeSW56"
	case RASDeviceTypeTunnelPPTP:
		return "RASDeviceTypeTunnelPPTP"
	case RASDeviceTypeTunnelL2TP:
		return "RASDeviceTypeTunnelL2TP"
	case RASDeviceTypeIRDA:
		return "RASDeviceTypeIRDA"
	case RASDeviceTypeParallel:
		return "RASDeviceTypeParallel"
	case RASDeviceTypeOther:
		return "RASDeviceTypeOther"
	case RASDeviceTypePPPoE:
		return "RASDeviceTypePPPoE"
	case RASDeviceTypeTunnelSSTP:
		return "RASDeviceTypeTunnelSSTP"
	case RASDeviceTypeTunnelIKEv2:
		return "RASDeviceTypeTunnelIKEv2"
	case RASDeviceTypeTunnel:
		return "RASDeviceTypeTunnel"
	case RASDeviceTypeDirect:
		return "RASDeviceTypeDirect"
	case RASDeviceTypeNullModem:
		return "RASDeviceTypeNullModem"
	case RASDeviceTypeBroadband:
		return "RASDeviceTypeBroadband"
	}
	return "Invalid"
}

// RASMANStatus type represents RASMAN_STATUS RPC enumeration.
//
// The RASMAN_STATUS type enumerates the status of the Port.
type RASMANStatus uint16

var (
	// OPEN: Port is in open state for a connection.
	RASMANStatusOpen RASMANStatus = 0
	// CLOSED: Port is in closed state and is available for connection.
	RASMANStatusClosed RASMANStatus = 1
	// UNAVAILABLE: Port is in the process of being removed and is not available for connection.
	RASMANStatusUnavailable RASMANStatus = 2
	// REMOVED: Port is removed and is not available for connection.
	RASMANStatusRemoved RASMANStatus = 3
)

func (o RASMANStatus) String() string {
	switch o {
	case RASMANStatusOpen:
		return "RASMANStatusOpen"
	case RASMANStatusClosed:
		return "RASMANStatusClosed"
	case RASMANStatusUnavailable:
		return "RASMANStatusUnavailable"
	case RASMANStatusRemoved:
		return "RASMANStatusRemoved"
	}
	return "Invalid"
}

// RequestTypes type represents ReqTypes RPC enumeration.
//
// The ReqTypes enumeration indicates the different types of message requests that can
// be passed in the RB_ReqType field of RequestBuffer structure.
type RequestTypes uint16

var (
	// REQTYPE_PORTENUM: Request to enumerate all the port information on the RRAS.
	RequestTypesPortEnum RequestTypes = 21
	// REQTYPE_GETINFO: Request to get information about a specific port on the RRAS.
	RequestTypesGetInfo RequestTypes = 22
	// REQTYPE_GETDEVCONFIG: Request to get device information on the RRAS.
	RequestTypesGetDeviceConfig RequestTypes = 73
	// REQTYPE_SETDEVICECONFIGINFO: Request to set device configuration information on RRAS.
	RequestTypesSetDeviceConfigInfo RequestTypes = 94
	// REQTYPE_GETDEVICECONFIGINFO: Request to get device configuration information on RRAS.
	RequestTypesGetDeviceConfigInfo RequestTypes = 95
	// REQTYPE_GETCALLEDID: Request to get CalledId information for a specific device on
	// RRAS.
	RequestTypesGetCalledID RequestTypes = 105
	// REQTYPE_SETCALLEDID: Request to set CalledId information for a specific device on
	// RRAS.
	RequestTypesSetCalledID RequestTypes = 106
	// REQTYPE_GETNDISWANDRIVERCAPS: Request to get the encryption capabilities of the RRAS.
	RequestTypesGetNDISWANDriverCaps RequestTypes = 111
)

func (o RequestTypes) String() string {
	switch o {
	case RequestTypesPortEnum:
		return "RequestTypesPortEnum"
	case RequestTypesGetInfo:
		return "RequestTypesGetInfo"
	case RequestTypesGetDeviceConfig:
		return "RequestTypesGetDeviceConfig"
	case RequestTypesSetDeviceConfigInfo:
		return "RequestTypesSetDeviceConfigInfo"
	case RequestTypesGetDeviceConfigInfo:
		return "RequestTypesGetDeviceConfigInfo"
	case RequestTypesGetCalledID:
		return "RequestTypesGetCalledID"
	case RequestTypesSetCalledID:
		return "RequestTypesSetCalledID"
	case RequestTypesGetNDISWANDriverCaps:
		return "RequestTypesGetNDISWANDriverCaps"
	}
	return "Invalid"
}

// RASMANState type represents RASMAN_STATE RPC enumeration.
//
// The RASMAN_STATE enumeration indicates the connection condition of a given RAS port.
type RASMANState uint16

var (
	// CONNECTING: The port is in the process of connecting.
	RASMANStateConnecting RASMANState = 0
	// LISTENING: The port is listening for connection requests.
	RASMANStateListening RASMANState = 1
	// CONNECTED: The port is connected.
	RASMANStateConnected RASMANState = 2
	// DISCONNECTING: The port is in the process of disconnecting.
	RASMANStateDisconnecting RASMANState = 3
	// DISCONNECTED: The port is disconnected.
	RASMANStateDisconnected RASMANState = 4
	// LISTENCOMPLETED: The port has completed listening for connection requests.
	RASMANStateListenCompleted RASMANState = 5
)

func (o RASMANState) String() string {
	switch o {
	case RASMANStateConnecting:
		return "RASMANStateConnecting"
	case RASMANStateListening:
		return "RASMANStateListening"
	case RASMANStateConnected:
		return "RASMANStateConnected"
	case RASMANStateDisconnecting:
		return "RASMANStateDisconnecting"
	case RASMANStateDisconnected:
		return "RASMANStateDisconnected"
	case RASMANStateListenCompleted:
		return "RASMANStateListenCompleted"
	}
	return "Invalid"
}

// RASMANDisconnectType type represents RASMAN_DISCONNECT_TYPE RPC enumeration.
//
// The RASMAN_DISCONNECT_TYPE enumeration indicates different types of disconnection
// requests for a given RAS port.
type RASMANDisconnectType uint16

var (
	// USER_REQUESTED: The local user requested the disconnect action.
	RASMANDisconnectTypeUserRequested RASMANDisconnectType = 0
	// REMOTE_DISCONNECTION: The remote dial-up or VPN client requested the disconnect action.
	RASMANDisconnectTypeRemoteDisconnection RASMANDisconnectType = 1
	// HARDWARE_FAILURE: The hardware attached to this RAS port has failed.
	RASMANDisconnectTypeHardwareFailure RASMANDisconnectType = 2
	// NOT_DISCONNECTED: The port is not disconnected.
	RASMANDisconnectTypeNotDisconnected RASMANDisconnectType = 3
)

func (o RASMANDisconnectType) String() string {
	switch o {
	case RASMANDisconnectTypeUserRequested:
		return "RASMANDisconnectTypeUserRequested"
	case RASMANDisconnectTypeRemoteDisconnection:
		return "RASMANDisconnectTypeRemoteDisconnection"
	case RASMANDisconnectTypeHardwareFailure:
		return "RASMANDisconnectTypeHardwareFailure"
	case RASMANDisconnectTypeNotDisconnected:
		return "RASMANDisconnectTypeNotDisconnected"
	}
	return "Invalid"
}

// RASMANUsage type represents RASMAN_USAGE RPC enumeration.
//
// The RASMAN_USAGE enumerates the usage for a port. It can be any combination of the
// following values.
type RASMANUsage uint16

var (
	// CALL_NONE: Port is not configured for any usage.
	RASMANUsageCallNone RASMANUsage = 0
	// CALL_IN: Port is configured for incoming connection requests.
	RASMANUsageCallIn RASMANUsage = 1
	// CALL_OUT: Port is configured for outgoing connection requests
	RASMANUsageCallOut RASMANUsage = 2
	// CALL_ROUTER: Port is configured for demand-dial connection requests.
	RASMANUsageCallRouter RASMANUsage = 4
	// CALL_LOGON: Port is configured for connection during logon.
	RASMANUsageCallLogon RASMANUsage = 8
	// CALL_OUT_ONLY: Port is configured only for outgoing connection requests.
	RASMANUsageCallOutOnly RASMANUsage = 16
	// CALL_IN_ONLY: Port is configured only for incoming connection requests.
	RASMANUsageCallInOnly RASMANUsage = 32
	// CALL_OUTBOUND_ROUTER: Port is configured for outgoing demand-dial connection requests.
	RASMANUsageCallOutboundRouter RASMANUsage = 64
)

func (o RASMANUsage) String() string {
	switch o {
	case RASMANUsageCallNone:
		return "RASMANUsageCallNone"
	case RASMANUsageCallIn:
		return "RASMANUsageCallIn"
	case RASMANUsageCallOut:
		return "RASMANUsageCallOut"
	case RASMANUsageCallRouter:
		return "RASMANUsageCallRouter"
	case RASMANUsageCallLogon:
		return "RASMANUsageCallLogon"
	case RASMANUsageCallOutOnly:
		return "RASMANUsageCallOutOnly"
	case RASMANUsageCallInOnly:
		return "RASMANUsageCallInOnly"
	case RASMANUsageCallOutboundRouter:
		return "RASMANUsageCallOutboundRouter"
	}
	return "Invalid"
}

// RequestBuffer structure represents RequestBuffer RPC structure.
//
// The RequestBuffer structure is a generic information container used by the RasRpcSubmitRequest
// (section 3.4.4.5) method to set or retrieve information on RRAS server.
//
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| RB_PCBIndex                                                                                                                   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| RB_Reqtype                                                                                                                    |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| RB_Dummy (optional)                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| RB_Done                                                                                                                       |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| Alignment                                                                                                                     |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| RB_Buffer (variable)                                                                                                          |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
type RequestBuffer struct {
	// RB_PCBIndex (4 bytes): A unique identifier for the port.
	Index uint32 `idl:"name:RB_PCBIndex" json:"index"`
	// RB_Reqtype (4 bytes): A ReqTypes (section 2.2.1.1.18) enumeration value indicating
	// the request type sent to the server.
	RequestType RequestTypes `idl:"name:RB_Reqtype" json:"request_type"`
	// RB_Dummy (4 bytes): SHOULD<153> be set to the size of the ULONG_PTR on the client.
	_ uint32 `idl:"name:RB_Dummy"`
	// RB_Done (4 bytes): MUST be set to zero (0) when sent and MUST be ignored on receipt.
	Done uint32 `idl:"name:RB_Done" json:"done"`
	// Alignment (8 bytes): MUST be set to zero (0) when sent and MUST be ignored on receipt.
	Alignment int64 `idl:"name:Alignment" json:"alignment"`
	// RB_Buffer (variable): A pointer to the buffer that contains the information specific
	// to the RB_Reqtype request type. This information MUST be one of the following structures
	// depending upon the RB_Reqtype ReqTypes.
	//
	//	+------------------------------+--------------------------------------------------+
	//	|                              |                                                  |
	//	|           REQTYPES           |                    STRUCTURE                     |
	//	|                              |                                                  |
	//	+------------------------------+--------------------------------------------------+
	//	+------------------------------+--------------------------------------------------+
	//	| REQTYPE_SETDEVICECONFIGINFO  | DeviceConfigInfo (section 2.2.1.2.218)           |
	//	+------------------------------+--------------------------------------------------+
	//	| REQTYPE_GETDEVICECONFIGINFO  | DeviceConfigInfo (section 2.2.1.2.218)           |
	//	+------------------------------+--------------------------------------------------+
	//	| REQTYPE_GETCALLEDID          | GetSetCalledId (section 2.2.1.2.220)             |
	//	+------------------------------+--------------------------------------------------+
	//	| REQTYPE_SETCALLEDID          | GetSetCalledId (section 2.2.1.2.220)             |
	//	+------------------------------+--------------------------------------------------+
	//	| REQTYPE_GETNDISWANDRIVERCAPS | GetNdiswanDriverCapsStruct (section 2.2.1.2.222) |
	//	+------------------------------+--------------------------------------------------+
	//	| REQTYPE_GETDEVCONFIG         | GetDevConfigStruct (section 2.2.1.2.224)         |
	//	+------------------------------+--------------------------------------------------+
	//	| REQTYPE_PORTENUM             | Enum (section 2.2.1.2.225)                       |
	//	+------------------------------+--------------------------------------------------+
	//	| REQTYPE_GETINFO              | Info (section 2.2.1.2.227)                       |
	//	+------------------------------+--------------------------------------------------+
	Buffer []byte `idl:"name:RB_Buffer" json:"buffer"`
}

func (o *RequestBuffer) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *RequestBuffer) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if err := w.WriteData(o.Index); err != nil {
		return err
	}
	if err := w.WriteEnum(uint16(o.RequestType)); err != nil {
		return err
	}
	// reserved RB_Dummy
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	if err := w.WriteData(o.Done); err != nil {
		return err
	}
	if err := w.WriteData(o.Alignment); err != nil {
		return err
	}
	for i1 := range o.Buffer {
		i1 := i1
		if uint64(i1) >= 1 {
			break
		}
		if err := w.WriteData(o.Buffer[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Buffer); uint64(i1) < 1; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteTrailingGap(8); err != nil {
		return err
	}
	return nil
}
func (o *RequestBuffer) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if err := w.ReadData(&o.Index); err != nil {
		return err
	}
	if err := w.ReadEnum((*uint16)(&o.RequestType)); err != nil {
		return err
	}
	// reserved RB_Dummy
	var _RB_Dummy uint32
	if err := w.ReadData(&_RB_Dummy); err != nil {
		return err
	}
	if err := w.ReadData(&o.Done); err != nil {
		return err
	}
	if err := w.ReadData(&o.Alignment); err != nil {
		return err
	}
	o.Buffer = make([]byte, 1)
	for i1 := range o.Buffer {
		i1 := i1
		if err := w.ReadData(&o.Buffer[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadTrailingGap(8); err != nil {
		return err
	}
	return nil
}

// DeviceConfigInfo structure represents DeviceConfigInfo RPC structure.
//
// The DeviceConfigInfo structure contains information specific to the REQTYPE_SETDEVICECONFIGINFO
// and REQTYPE_GETDEVICECONFIGINFO in the ReqTypes (section 2.2.1.1.18) enumeration.
//
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| retcode                                                                                                                       |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwVersion                                                                                                                     |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| cbBuffer                                                                                                                      |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| cEntries                                                                                                                      |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| abdata (variable)                                                                                                             |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
type DeviceConfigInfo struct {
	// retcode (4 bytes): A 32-bit, unsigned integer value that indicates return status.
	// A return value ERROR_SUCCESS (0x00000000) indicates that the operation was completed
	// successfully; otherwise it contains an error code, specified in [MS-ERREF] or in
	// section 2.2.4.
	ReturnCode uint32 `idl:"name:retcode" json:"return_code"`
	// dwVersion (4 bytes): Specifies the version of the server.<154>
	Version uint32 `idl:"name:dwVersion" json:"version"`
	// cbBuffer (4 bytes): This MUST be set to the size, in bytes, of the buffer passed
	// in abdata.
	BufferLength uint32 `idl:"name:cbBuffer" json:"buffer_length"`
	// cEntries (4 bytes): Specifies the number of device entries as returned by the server.
	EntriesCount uint32 `idl:"name:cEntries" json:"entries_count"`
	// abdata (variable): This refers to the buffer that contains the array of RAS_DEVICE_INFO
	// (section 2.2.1.2.219) structures as returned by the server.
	Data []byte `idl:"name:abdata" json:"data"`
}

func (o *DeviceConfigInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *DeviceConfigInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.ReturnCode); err != nil {
		return err
	}
	if err := w.WriteData(o.Version); err != nil {
		return err
	}
	if err := w.WriteData(o.BufferLength); err != nil {
		return err
	}
	if err := w.WriteData(o.EntriesCount); err != nil {
		return err
	}
	for i1 := range o.Data {
		i1 := i1
		if uint64(i1) >= 1 {
			break
		}
		if err := w.WriteData(o.Data[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Data); uint64(i1) < 1; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteTrailingGap(4); err != nil {
		return err
	}
	return nil
}
func (o *DeviceConfigInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.ReturnCode); err != nil {
		return err
	}
	if err := w.ReadData(&o.Version); err != nil {
		return err
	}
	if err := w.ReadData(&o.BufferLength); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntriesCount); err != nil {
		return err
	}
	o.Data = make([]byte, 1)
	for i1 := range o.Data {
		i1 := i1
		if err := w.ReadData(&o.Data[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadTrailingGap(4); err != nil {
		return err
	}
	return nil
}

// RASDeviceInfo structure represents RAS_DEVICE_INFO RPC structure.
//
// The RAS_DEVICE_INFO structure contains device information.
type RASDeviceInfo struct {
	// dwVersion: Specifies the version of the Rasrpc server.<155>
	Version uint32 `idl:"name:dwVersion" json:"version"`
	// fWrite: If set to 1, specifies that device information needs to be stored on RRAS.
	// If set to 0, specifies that the device information does not need to be stored.
	Write bool `idl:"name:fWrite" json:"write"`
	// fRasEnabled: If set to 1, specifies that the device is enabled for incoming connections.
	// If set to 0, specifies that the device is not enabled for incoming connections.
	RASEnabled bool `idl:"name:fRasEnabled" json:"ras_enabled"`
	// fRouterEnabled: If set to 1, specifies that the device is enabled for both incoming
	// and outgoing demand-dial connection. If set to 0, specifies that the device is not
	// enabled for both incoming and outgoing demand-dial connection.
	RouterEnabled bool `idl:"name:fRouterEnabled" json:"router_enabled"`
	// fRouterOutboundEnabled: If set to 1, specifies that the device is enabled for outgoing
	// Demand dial connection. This can be set to 1 only when fRouterEnabled is set to 0.<156>
	RouterOutboundEnabled bool `idl:"name:fRouterOutboundEnabled" json:"router_outbound_enabled"`
	// dwTapiLineId: Unique TAPI identifier for the device.
	TAPILineID uint32 `idl:"name:dwTapiLineId" json:"tapi_line_id"`
	// dwError: Specifies the return status as explained in section 2.2.1.2.218 for the
	// retcode field.
	Error uint32 `idl:"name:dwError" json:"error"`
	// dwNumEndPoints: Specifies the number of WAN end points available for the device.
	EndpointsLength uint32 `idl:"name:dwNumEndPoints" json:"endpoints_length"`
	// dwMaxOutCalls: Specifies the maximum number of outgoing connections allowed on the
	// device.
	MaxOutCalls uint32 `idl:"name:dwMaxOutCalls" json:"max_out_calls"`
	// dwMaxInCalls: Specifies the maximum number of incoming connections allowed on the
	// device.
	MaxInCalls uint32 `idl:"name:dwMaxInCalls" json:"max_in_calls"`
	// dwMinWanEndPoints: Specifies the minimum number of WAN end points allowed on the
	// device.
	MinWANEndpoints uint32 `idl:"name:dwMinWanEndPoints" json:"min_wan_endpoints"`
	// dwMaxWanEndPoints: Specifies the maximum number of WAN end points allowed on the
	// device.
	MaxWANEndpoints uint32 `idl:"name:dwMaxWanEndPoints" json:"max_wan_endpoints"`
	// eDeviceType: Specifies the RASDEVICETYPE enumeration type.
	DeviceType RASDeviceType `idl:"name:eDeviceType" json:"device_type"`
	// guidDevice: A GUID uniquely identifying the device. This value MUST NOT be used when
	// eDeviceType is RDT_Modem.
	Device *dtyp.GUID `idl:"name:guidDevice" json:"device"`
	// szPortName: Specifies a null-terminated ASCII string specifying the Port Name.
	PortName []byte `idl:"name:szPortName" json:"port_name"`
	// szDeviceName: Specifies a null-terminated ASCII string specifying the Device Name.
	DeviceName        []byte   `idl:"name:szDeviceName" json:"device_name"`
	UnicodeDeviceName []uint16 `idl:"name:wszUnicodeDeviceName" json:"unicode_device_name"`
}

func (o *RASDeviceInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *RASDeviceInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Version); err != nil {
		return err
	}
	if !o.Write {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if !o.RASEnabled {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if !o.RouterEnabled {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if !o.RouterOutboundEnabled {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.TAPILineID); err != nil {
		return err
	}
	if err := w.WriteData(o.Error); err != nil {
		return err
	}
	if err := w.WriteData(o.EndpointsLength); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxOutCalls); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxInCalls); err != nil {
		return err
	}
	if err := w.WriteData(o.MinWANEndpoints); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxWANEndpoints); err != nil {
		return err
	}
	if err := w.WriteEnum(uint16(o.DeviceType)); err != nil {
		return err
	}
	if o.Device != nil {
		if err := o.Device.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	for i1 := range o.PortName {
		i1 := i1
		if uint64(i1) >= 17 {
			break
		}
		if err := w.WriteData(o.PortName[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.PortName); uint64(i1) < 17; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	for i1 := range o.DeviceName {
		i1 := i1
		if uint64(i1) >= 129 {
			break
		}
		if err := w.WriteData(o.DeviceName[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.DeviceName); uint64(i1) < 129; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	for i1 := range o.UnicodeDeviceName {
		i1 := i1
		if uint64(i1) >= 129 {
			break
		}
		if err := w.WriteData(o.UnicodeDeviceName[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.UnicodeDeviceName); uint64(i1) < 129; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	if err := w.WriteTrailingGap(4); err != nil {
		return err
	}
	return nil
}
func (o *RASDeviceInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Version); err != nil {
		return err
	}
	var _bWrite int32
	if err := w.ReadData(&_bWrite); err != nil {
		return err
	}
	o.Write = _bWrite != 0
	var _bRASEnabled int32
	if err := w.ReadData(&_bRASEnabled); err != nil {
		return err
	}
	o.RASEnabled = _bRASEnabled != 0
	var _bRouterEnabled int32
	if err := w.ReadData(&_bRouterEnabled); err != nil {
		return err
	}
	o.RouterEnabled = _bRouterEnabled != 0
	var _bRouterOutboundEnabled int32
	if err := w.ReadData(&_bRouterOutboundEnabled); err != nil {
		return err
	}
	o.RouterOutboundEnabled = _bRouterOutboundEnabled != 0
	if err := w.ReadData(&o.TAPILineID); err != nil {
		return err
	}
	if err := w.ReadData(&o.Error); err != nil {
		return err
	}
	if err := w.ReadData(&o.EndpointsLength); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxOutCalls); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxInCalls); err != nil {
		return err
	}
	if err := w.ReadData(&o.MinWANEndpoints); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxWANEndpoints); err != nil {
		return err
	}
	_eDeviceType := uint16(o.DeviceType)
	if err := w.ReadEnum(&_eDeviceType); err != nil {
		return err
	}
	o.DeviceType = RASDeviceType(_eDeviceType)
	if o.Device == nil {
		o.Device = &dtyp.GUID{}
	}
	if err := o.Device.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	o.PortName = make([]byte, 17)
	for i1 := range o.PortName {
		i1 := i1
		if err := w.ReadData(&o.PortName[i1]); err != nil {
			return err
		}
	}
	o.DeviceName = make([]byte, 129)
	for i1 := range o.DeviceName {
		i1 := i1
		if err := w.ReadData(&o.DeviceName[i1]); err != nil {
			return err
		}
	}
	o.UnicodeDeviceName = make([]uint16, 129)
	for i1 := range o.UnicodeDeviceName {
		i1 := i1
		if err := w.ReadData(&o.UnicodeDeviceName[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadTrailingGap(4); err != nil {
		return err
	}
	return nil
}

// RASCalledidInfo structure represents RAS_CALLEDID_INFO RPC structure.
//
// The RAS_CALLEDID_INFO structure contains the TAPI CalledId information.
//
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwSize                                                                                                                        |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| bCalledId (variable)                                                                                                          |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
type RASCalledidInfo struct {
	// dwSize (4 bytes): Specifies the size in bytes of the bCalledId buffer.
	Size uint32 `idl:"name:dwSize" json:"size"`
	// bCalledId (variable): Specifies the buffer that contains the null-terminated Unicode
	// string representing the called device phonenumber information.
	CalledID []byte `idl:"name:bCalledId" json:"called_id"`
}

func (o *RASCalledidInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *RASCalledidInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Size); err != nil {
		return err
	}
	for i1 := range o.CalledID {
		i1 := i1
		if uint64(i1) >= 1 {
			break
		}
		if err := w.WriteData(o.CalledID[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.CalledID); uint64(i1) < 1; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteTrailingGap(4); err != nil {
		return err
	}
	return nil
}
func (o *RASCalledidInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Size); err != nil {
		return err
	}
	o.CalledID = make([]byte, 1)
	for i1 := range o.CalledID {
		i1 := i1
		if err := w.ReadData(&o.CalledID[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadTrailingGap(4); err != nil {
		return err
	}
	return nil
}

// GetSetCalledID structure represents GetSetCalledId RPC structure.
//
// The GetSetCalledId structure contains information specific to the REQTYPE_GETCALLEDID
// and REQTYPE_SETCALLEDID in the ReqTypes (section 2.2.1.1.18) enumeration.
//
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| retcode                                                                                                                       |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| fWrite                                                                                                                        |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| dwSize                                                                                                                        |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| guidDevice (16 bytes)                                                                                                         |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| rdi (472 bytes)                                                                                                               |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| rciInfo (variable)                                                                                                            |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
type GetSetCalledID struct {
	// retcode (4 bytes): Specifies the return status as explained in section 2.2.1.2.218
	// for the retcode field.
	ReturnCode uint32 `idl:"name:retcode" json:"return_code"`
	// fWrite (4 bytes): If set to 1, specifies that CalledId information MUST be stored
	// on RRAS. If set to 0, CalledId information MUST not be stored.
	Write bool `idl:"name:fWrite" json:"write"`
	// dwSize (4 bytes): Specifies the size, in bytes, of the rciInfo structure, including
	// the rciInfo.bCalledId buffer, which is specified by the dwSize member of the RAS_CALLEDID_INFO
	// structure.
	Size uint32 `idl:"name:dwSize" json:"size"`
	// guidDevice (16 bytes): This value MUST be set to 0 when sent and ignored on receipt.
	Device *dtyp.GUID `idl:"name:guidDevice" json:"device"`
	// rdi (472 bytes): Specifies the RAS_DEVICE_INFO structure as defined in section 2.2.1.2.219.
	RASDeviceInfo *RASDeviceInfo `idl:"name:rdi" json:"ras_device_info"`
	// rciInfo (variable): Specifies the RAS_CALLEDID_INFO structure as defined in section
	// 2.2.1.2.221.
	Info *RASCalledidInfo `idl:"name:rciInfo" json:"info"`
}

func (o *GetSetCalledID) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *GetSetCalledID) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.ReturnCode); err != nil {
		return err
	}
	if !o.Write {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Size); err != nil {
		return err
	}
	if o.Device != nil {
		if err := o.Device.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.RASDeviceInfo != nil {
		if err := o.RASDeviceInfo.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&RASDeviceInfo{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.Info != nil {
		if err := o.Info.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&RASCalledidInfo{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *GetSetCalledID) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.ReturnCode); err != nil {
		return err
	}
	var _bWrite int32
	if err := w.ReadData(&_bWrite); err != nil {
		return err
	}
	o.Write = _bWrite != 0
	if err := w.ReadData(&o.Size); err != nil {
		return err
	}
	if o.Device == nil {
		o.Device = &dtyp.GUID{}
	}
	if err := o.Device.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.RASDeviceInfo == nil {
		o.RASDeviceInfo = &RASDeviceInfo{}
	}
	if err := o.RASDeviceInfo.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.Info == nil {
		o.Info = &RASCalledidInfo{}
	}
	if err := o.Info.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// RASNDISWANDriverInfo structure represents RAS_NDISWAN_DRIVER_INFO RPC structure.
//
// The RAS_NDISWAN_DRIVER_INFO structure contains the encryption capabilities of the
// RRAS server.
type RASNDISWANDriverInfo struct {
	// DriverCaps: Specifies the encryption capabilities of the RRAS. It MUST be one of
	// the following values.
	//
	//	+---------------------------------------+------------------------------+
	//	|                                       |                              |
	//	|                 VALUE                 |           MEANING            |
	//	|                                       |                              |
	//	+---------------------------------------+------------------------------+
	//	+---------------------------------------+------------------------------+
	//	| RAS_NDISWAN_40BIT_ENABLED 0x00000000  | 40-bit encryption supported  |
	//	+---------------------------------------+------------------------------+
	//	| RAS_NDISWAN_128BIT_ENABLED 0x00000001 | 128-bit encryption supported |
	//	+---------------------------------------+------------------------------+
	DriverCaps uint32 `idl:"name:DriverCaps" json:"driver_caps"`
	// Reserved: MUST be set to zero (0) when sent and MUST be ignored on receipt.
	_ uint32 `idl:"name:Reserved"`
}

func (o *RASNDISWANDriverInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *RASNDISWANDriverInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.DriverCaps); err != nil {
		return err
	}
	// reserved Reserved
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	return nil
}
func (o *RASNDISWANDriverInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.DriverCaps); err != nil {
		return err
	}
	// reserved Reserved
	var _Reserved uint32
	if err := w.ReadData(&_Reserved); err != nil {
		return err
	}
	return nil
}

// GetNDISWANDriverCaps structure represents GetNdiswanDriverCapsStruct RPC structure.
//
// The GetNdiswanDriverCapsStruct structure contains the information specific to the
// REQTYPE_GETNDISWANDRIVERCAPS in the ReqTypes (section 2.2.1.1.18) enumeration.
type GetNDISWANDriverCaps struct {
	// retcode: Specifies the return status as explained in section 2.2.1.2.218 for retcode
	// field.
	ReturnCode uint32 `idl:"name:retcode" json:"return_code"`
	// NdiswanDriverInfo: The RAS_NDISWAN_DRIVER_INFO structure.
	NDISWANDriverInfo *RASNDISWANDriverInfo `idl:"name:NdiswanDriverInfo" json:"ndiswan_driver_info"`
}

func (o *GetNDISWANDriverCaps) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *GetNDISWANDriverCaps) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.ReturnCode); err != nil {
		return err
	}
	if o.NDISWANDriverInfo != nil {
		if err := o.NDISWANDriverInfo.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&RASNDISWANDriverInfo{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *GetNDISWANDriverCaps) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.ReturnCode); err != nil {
		return err
	}
	if o.NDISWANDriverInfo == nil {
		o.NDISWANDriverInfo = &RASNDISWANDriverInfo{}
	}
	if err := o.NDISWANDriverInfo.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// GetDevConfig structure represents GetDevConfigStruct RPC structure.
//
// The GetDevConfigStruct structure contains information specific to the REQTYPE_GETDEVCONFIG
// in the ReqTypes (section 2.2.1.1.18) enumeration.
//
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| retcode                                                                                                                       |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| devicetype (17 bytes)                                                                                                         |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                           | size                                                                                          |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                           | config (variable)                                                                             |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
type GetDevConfig struct {
	// retcode (4 bytes): Specifies the return status as explained in section 2.2.1.2.218
	// for retcode field.
	ReturnCode uint32 `idl:"name:retcode" json:"return_code"`
	// devicetype (17 bytes): Specifies a null-terminated ASCII string that indicates the
	// RRAS server device type as specified for the wszDeviceType field in the RASI_PORT_0
	// (section 2.2.1.2.75) structure.
	DeviceType []byte `idl:"name:devicetype" json:"device_type"`
	// size (4 bytes): Specifies the size in bytes of the configuration data as specified
	// by config.
	Size uint32 `idl:"name:size" json:"size"`
	// config (variable): Tapi device configuration blob as specified by GetDevConfig.lpDeviceConfig
	// in section 2.2.4.1.3.33 of [MS-TRP].
	Config []byte `idl:"name:config" json:"config"`
}

func (o *GetDevConfig) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *GetDevConfig) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.ReturnCode); err != nil {
		return err
	}
	for i1 := range o.DeviceType {
		i1 := i1
		if uint64(i1) >= 17 {
			break
		}
		if err := w.WriteData(o.DeviceType[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.DeviceType); uint64(i1) < 17; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Size); err != nil {
		return err
	}
	for i1 := range o.Config {
		i1 := i1
		if uint64(i1) >= 1 {
			break
		}
		if err := w.WriteData(o.Config[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Config); uint64(i1) < 1; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteTrailingGap(4); err != nil {
		return err
	}
	return nil
}
func (o *GetDevConfig) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.ReturnCode); err != nil {
		return err
	}
	o.DeviceType = make([]byte, 17)
	for i1 := range o.DeviceType {
		i1 := i1
		if err := w.ReadData(&o.DeviceType[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.Size); err != nil {
		return err
	}
	o.Config = make([]byte, 1)
	for i1 := range o.Config {
		i1 := i1
		if err := w.ReadData(&o.Config[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadTrailingGap(4); err != nil {
		return err
	}
	return nil
}

// Enum structure represents Enum RPC structure.
//
// The Enum structure contains information specific to the REQTYPE_PORTENUM ReqTypes
// (section 2.2.1.1.18) value.
//
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| retcode                                                                                                                       |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| size                                                                                                                          |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| entries                                                                                                                       |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| buffer (variable)                                                                                                             |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//	| ...                                                                                                                           |
//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
type Enum struct {
	// retcode (4 bytes): Specifies the return status as explained in section 2.2.1.2.218
	// for the retcode field.
	ReturnCode uint32 `idl:"name:retcode" json:"return_code"`
	// size (4 bytes): Specifies the size in bytes of the buffer.
	Size uint32 `idl:"name:size" json:"size"`
	// entries (4 bytes): Specifies the number of port entries as pointed by the buffer.
	Entries uint32 `idl:"name:entries" json:"entries"`
	// buffer (variable): Points to the array of RASMAN_PORT_32 (section 2.2.1.2.226) structures.
	Buffer []byte `idl:"name:buffer" json:"buffer"`
}

func (o *Enum) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *Enum) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.ReturnCode); err != nil {
		return err
	}
	if err := w.WriteData(o.Size); err != nil {
		return err
	}
	if err := w.WriteData(o.Entries); err != nil {
		return err
	}
	for i1 := range o.Buffer {
		i1 := i1
		if uint64(i1) >= 1 {
			break
		}
		if err := w.WriteData(o.Buffer[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Buffer); uint64(i1) < 1; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteTrailingGap(4); err != nil {
		return err
	}
	return nil
}
func (o *Enum) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.ReturnCode); err != nil {
		return err
	}
	if err := w.ReadData(&o.Size); err != nil {
		return err
	}
	if err := w.ReadData(&o.Entries); err != nil {
		return err
	}
	o.Buffer = make([]byte, 1)
	for i1 := range o.Buffer {
		i1 := i1
		if err := w.ReadData(&o.Buffer[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadTrailingGap(4); err != nil {
		return err
	}
	return nil
}

// RASMANPort32 structure represents RASMAN_PORT_32 RPC structure.
//
// The RASMAN_PORT_32 structure contains information regarding a specific RAS port,
// such as port status and port name.
type RASMANPort32 struct {
	// P_Port: A unique identifier for the port.
	Port uint32 `idl:"name:P_Port" json:"port"`
	// P_PortName: Specifies a null-terminated ASCII string specifying the port name.
	PortName []byte `idl:"name:P_PortName" json:"port_name"`
	// P_Status: Specifies the status of the port as defined in the RASMAN_STATUS (section
	// 2.2.1.1.17) enumeration type.
	Status RASMANStatus `idl:"name:P_Status" json:"status"`
	// P_rdtDeviceType: Specifies the device type of the port as defined in the RASDEVICETYPE
	// (section 2.2.1.1.16) enumeration type.
	RASDeviceType RASDeviceType `idl:"name:P_rdtDeviceType" json:"ras_device_type"`
	// P_ConfiguredUsage: Specifies the configured usage of the port as defined in section
	// 2.2.1.1.21.
	ConfiguredUsage RASMANUsage `idl:"name:P_ConfiguredUsage" json:"configured_usage"`
	// P_CurrentUsage: Specifies the usage for the port currently being used as defined
	// in section 2.2.1.1.21.
	CurrentUsage RASMANUsage `idl:"name:P_CurrentUsage" json:"current_usage"`
	// P_MediaName: A null-terminated ASCII string specifying the name of the media associated
	// with the port.
	MediaName []byte `idl:"name:P_MediaName" json:"media_name"`
	// P_DeviceType: Specifies a null-terminated ASCII string that indicates the RRAS server
	// device type as specified for the wszDeviceType field of the RASI_PORT_0 (section
	// 2.2.1.2.75) structure.
	DeviceType []byte `idl:"name:P_DeviceType" json:"device_type"`
	// P_DeviceName: A null-terminated ASCII string specifying the name of the device associated
	// with the port.
	DeviceName []byte `idl:"name:P_DeviceName" json:"device_name"`
	// P_LineDeviceId: Specifies a unique identifier for the device.
	LineDeviceID uint32 `idl:"name:P_LineDeviceId" json:"line_device_id"`
	// P_AddressId: MUST be set to zero (0) when sent and ignored on receipt.
	AddressID uint32 `idl:"name:P_AddressId" json:"address_id"`
}

func (o *RASMANPort32) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *RASMANPort32) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Port); err != nil {
		return err
	}
	for i1 := range o.PortName {
		i1 := i1
		if uint64(i1) >= 16 {
			break
		}
		if err := w.WriteData(o.PortName[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.PortName); uint64(i1) < 16; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteEnum(uint16(o.Status)); err != nil {
		return err
	}
	if err := w.WriteEnum(uint16(o.RASDeviceType)); err != nil {
		return err
	}
	if err := w.WriteEnum(uint16(o.ConfiguredUsage)); err != nil {
		return err
	}
	if err := w.WriteEnum(uint16(o.CurrentUsage)); err != nil {
		return err
	}
	for i1 := range o.MediaName {
		i1 := i1
		if uint64(i1) >= 16 {
			break
		}
		if err := w.WriteData(o.MediaName[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.MediaName); uint64(i1) < 16; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	for i1 := range o.DeviceType {
		i1 := i1
		if uint64(i1) >= 16 {
			break
		}
		if err := w.WriteData(o.DeviceType[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.DeviceType); uint64(i1) < 16; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	for i1 := range o.DeviceName {
		i1 := i1
		if uint64(i1) >= 129 {
			break
		}
		if err := w.WriteData(o.DeviceName[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.DeviceName); uint64(i1) < 129; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.LineDeviceID); err != nil {
		return err
	}
	if err := w.WriteData(o.AddressID); err != nil {
		return err
	}
	return nil
}
func (o *RASMANPort32) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Port); err != nil {
		return err
	}
	o.PortName = make([]byte, 16)
	for i1 := range o.PortName {
		i1 := i1
		if err := w.ReadData(&o.PortName[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadEnum((*uint16)(&o.Status)); err != nil {
		return err
	}
	_eRASDeviceType := uint16(o.RASDeviceType)
	if err := w.ReadEnum(&_eRASDeviceType); err != nil {
		return err
	}
	o.RASDeviceType = RASDeviceType(_eRASDeviceType)
	if err := w.ReadEnum((*uint16)(&o.ConfiguredUsage)); err != nil {
		return err
	}
	if err := w.ReadEnum((*uint16)(&o.CurrentUsage)); err != nil {
		return err
	}
	o.MediaName = make([]byte, 16)
	for i1 := range o.MediaName {
		i1 := i1
		if err := w.ReadData(&o.MediaName[i1]); err != nil {
			return err
		}
	}
	o.DeviceType = make([]byte, 16)
	for i1 := range o.DeviceType {
		i1 := i1
		if err := w.ReadData(&o.DeviceType[i1]); err != nil {
			return err
		}
	}
	o.DeviceName = make([]byte, 129)
	for i1 := range o.DeviceName {
		i1 := i1
		if err := w.ReadData(&o.DeviceName[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.LineDeviceID); err != nil {
		return err
	}
	if err := w.ReadData(&o.AddressID); err != nil {
		return err
	}
	return nil
}

// RASMANInfo structure represents RASMAN_INFO RPC structure.
//
// The RASMAN_INFO structure contains general information regarding a specific RRAS
// port, such as port status and port name.
type RASMANInfo struct {
	// RI_PortStatus: Specifies the status of the port as defined in RASMAN_STATUS (section
	// 2.2.1.1.17) enumeration type.
	PortStatus RASMANStatus `idl:"name:RI_PortStatus" json:"port_status"`
	// RI_ConnState: Specifies the connection state of the port as defined in RASMAN_STATE
	// (section 2.2.1.1.19).
	ConnState RASMANState `idl:"name:RI_ConnState" json:"conn_state"`
	// RI_LinkSpeed: Specifies the link speed in bits per second (bps) of the connection
	// using port as specified by RI_szPortName.
	LinkSpeed uint32 `idl:"name:RI_LinkSpeed" json:"link_speed"`
	// RI_LastError: Specifies the return status as explained in section 2.2.1.2.218 for
	// retcode field.
	LastError uint32 `idl:"name:RI_LastError" json:"last_error"`
	// RI_CurrentUsage: Specifies the current usage of the port as defined in section 2.2.1.1.21.
	CurrentUsage RASMANUsage `idl:"name:RI_CurrentUsage" json:"current_usage"`
	// RI_DeviceTypeConnecting: Specifies a null-terminated ASCII string that indicates
	// the RRAS server device type as specified for the wszDeviceType field of a RASI_PORT_0
	// (section 2.2.1.2.75) structure.
	DeviceTypeConnecting []byte `idl:"name:RI_DeviceTypeConnecting" json:"device_type_connecting"`
	// RI_DeviceConnecting: Specifies a null-terminated ASCII string that contains the name
	// of the device associated with the port.
	DeviceConnecting []byte `idl:"name:RI_DeviceConnecting" json:"device_connecting"`
	// RI_szDeviceType: Specifies a null-terminated ASCII string that contains the RRAS
	// server device type as specified for the wszDeviceType field of RASI_PORT_0 structure.
	DeviceType []byte `idl:"name:RI_szDeviceType" json:"device_type"`
	// RI_szDeviceName: Specifies a null-terminated ASCII string that contains the name
	// of the device associated with the port.
	DeviceName []byte `idl:"name:RI_szDeviceName" json:"device_name"`
	// RI_szPortName: Specifies a null-terminated ASCII string that contains the port name.
	PortName []byte `idl:"name:RI_szPortName" json:"port_name"`
	// RI_DisconnectType: Specifies the disconnect type of the port as defined by the RASMAN_DISCONNECT_TYPE
	// (section 2.2.1.1.20) enumeration type.
	DisconnectType RASMANDisconnectType `idl:"name:RI_DisconnectType" json:"disconnect_type"`
	// RI_OwnershipFlag: Specifies the process identifier (PID) of the client application
	// that has opened the port.
	OwnershipFlag uint32 `idl:"name:RI_OwnershipFlag" json:"ownership_flag"`
	// RI_ConnectDuration: Specifies the duration of the current connection on this port,
	// in milliseconds.
	ConnectDuration uint32 `idl:"name:RI_ConnectDuration" json:"connect_duration"`
	// RI_BytesReceived: Specifies the number of bytes received on this port.
	BytesReceived uint32 `idl:"name:RI_BytesReceived" json:"bytes_received"`
	// RI_Phonebook: Specifies the RRAS Phonebook path for the connection associated with
	// this port.
	Phonebook []byte `idl:"name:RI_Phonebook" json:"phonebook"`
	// RI_PhoneEntry: Specifies the RRAS Phonebook entry name for the connection associated
	// with this port.
	PhoneEntry []byte `idl:"name:RI_PhoneEntry" json:"phone_entry"`
	// RI_ConnectionHandle: Specifies a unique 32-bit unsigned integer identifying the connection
	// associated with this port.
	ConnectionHandle []byte `idl:"name:RI_ConnectionHandle" json:"connection_handle"`
	// RI_SubEntry: Specifies an index to the multilink subentry associated with this port.
	SubEntry uint32 `idl:"name:RI_SubEntry" json:"sub_entry"`
	// RI_rdtDeviceType: Specifies a value giving the RASDEVICETYPE (section 2.2.1.1.16)
	// enumeration type.
	RASDeviceType RASDeviceType `idl:"name:RI_rdtDeviceType" json:"ras_device_type"`
	// RI_GuidEntry: Specifies a GUID uniquely identifying the connection associated with
	// the port.
	GUIDEntry *dtyp.GUID `idl:"name:RI_GuidEntry" json:"guid_entry"`
	// RI_dwSessionId: Specifies the unique session ID associated with the port.<158>
	SessionID uint32 `idl:"name:RI_dwSessionId" json:"session_id"`
	// RI_dwFlags: Specifies the configuration option of the connection associated with
	// this port.<159>
	//
	// The value MUST be one of the following values or a bit-wise OR combination of the
	// following values.
	//
	//	+------------+----------------------------------------------------------------------------------+
	//	|            |                                                                                  |
	//	|   VALUE    |                                     MEANING                                      |
	//	|            |                                                                                  |
	//	+------------+----------------------------------------------------------------------------------+
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00000001 | Connection associated with this port is configured to store the credentials for  |
	//	|            | everyone.                                                                        |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00000002 | Connection associated with this port is configured as outgoing connection.       |
	//	+------------+----------------------------------------------------------------------------------+
	Flags uint32 `idl:"name:RI_dwFlags" json:"flags"`
	// RI_CorrelationGuid: Specifies a GUID that uniquely identifies the connection associated
	// with this port.<160>
	CorrelationGUID *dtyp.GUID `idl:"name:RI_CorrelationGuid" json:"correlation_guid"`
}

func (o *RASMANInfo) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *RASMANInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteEnum(uint16(o.PortStatus)); err != nil {
		return err
	}
	if err := w.WriteEnum(uint16(o.ConnState)); err != nil {
		return err
	}
	if err := w.WriteData(o.LinkSpeed); err != nil {
		return err
	}
	if err := w.WriteData(o.LastError); err != nil {
		return err
	}
	if err := w.WriteEnum(uint16(o.CurrentUsage)); err != nil {
		return err
	}
	for i1 := range o.DeviceTypeConnecting {
		i1 := i1
		if uint64(i1) >= 16 {
			break
		}
		if err := w.WriteData(o.DeviceTypeConnecting[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.DeviceTypeConnecting); uint64(i1) < 16; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	for i1 := range o.DeviceConnecting {
		i1 := i1
		if uint64(i1) >= 129 {
			break
		}
		if err := w.WriteData(o.DeviceConnecting[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.DeviceConnecting); uint64(i1) < 129; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	for i1 := range o.DeviceType {
		i1 := i1
		if uint64(i1) >= 16 {
			break
		}
		if err := w.WriteData(o.DeviceType[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.DeviceType); uint64(i1) < 16; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	for i1 := range o.DeviceName {
		i1 := i1
		if uint64(i1) >= 129 {
			break
		}
		if err := w.WriteData(o.DeviceName[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.DeviceName); uint64(i1) < 129; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	for i1 := range o.PortName {
		i1 := i1
		if uint64(i1) >= 17 {
			break
		}
		if err := w.WriteData(o.PortName[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.PortName); uint64(i1) < 17; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteEnum(uint16(o.DisconnectType)); err != nil {
		return err
	}
	if err := w.WriteData(o.OwnershipFlag); err != nil {
		return err
	}
	if err := w.WriteData(o.ConnectDuration); err != nil {
		return err
	}
	if err := w.WriteData(o.BytesReceived); err != nil {
		return err
	}
	for i1 := range o.Phonebook {
		i1 := i1
		if uint64(i1) >= 261 {
			break
		}
		if err := w.WriteData(o.Phonebook[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Phonebook); uint64(i1) < 261; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	for i1 := range o.PhoneEntry {
		i1 := i1
		if uint64(i1) >= 257 {
			break
		}
		if err := w.WriteData(o.PhoneEntry[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.PhoneEntry); uint64(i1) < 257; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if o.ConnectionHandle != nil {
		_ptr_RI_ConnectionHandle := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			// FIXME unknown type RI_ConnectionHandle
			return nil
		})
		if err := w.WritePointer(&o.ConnectionHandle, _ptr_RI_ConnectionHandle); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.SubEntry); err != nil {
		return err
	}
	if err := w.WriteEnum(uint16(o.RASDeviceType)); err != nil {
		return err
	}
	if o.GUIDEntry != nil {
		if err := o.GUIDEntry.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.SessionID); err != nil {
		return err
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	if o.CorrelationGUID != nil {
		if err := o.CorrelationGUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteTrailingGap(9); err != nil {
		return err
	}
	return nil
}
func (o *RASMANInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadEnum((*uint16)(&o.PortStatus)); err != nil {
		return err
	}
	if err := w.ReadEnum((*uint16)(&o.ConnState)); err != nil {
		return err
	}
	if err := w.ReadData(&o.LinkSpeed); err != nil {
		return err
	}
	if err := w.ReadData(&o.LastError); err != nil {
		return err
	}
	if err := w.ReadEnum((*uint16)(&o.CurrentUsage)); err != nil {
		return err
	}
	o.DeviceTypeConnecting = make([]byte, 16)
	for i1 := range o.DeviceTypeConnecting {
		i1 := i1
		if err := w.ReadData(&o.DeviceTypeConnecting[i1]); err != nil {
			return err
		}
	}
	o.DeviceConnecting = make([]byte, 129)
	for i1 := range o.DeviceConnecting {
		i1 := i1
		if err := w.ReadData(&o.DeviceConnecting[i1]); err != nil {
			return err
		}
	}
	o.DeviceType = make([]byte, 16)
	for i1 := range o.DeviceType {
		i1 := i1
		if err := w.ReadData(&o.DeviceType[i1]); err != nil {
			return err
		}
	}
	o.DeviceName = make([]byte, 129)
	for i1 := range o.DeviceName {
		i1 := i1
		if err := w.ReadData(&o.DeviceName[i1]); err != nil {
			return err
		}
	}
	o.PortName = make([]byte, 17)
	for i1 := range o.PortName {
		i1 := i1
		if err := w.ReadData(&o.PortName[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadEnum((*uint16)(&o.DisconnectType)); err != nil {
		return err
	}
	if err := w.ReadData(&o.OwnershipFlag); err != nil {
		return err
	}
	if err := w.ReadData(&o.ConnectDuration); err != nil {
		return err
	}
	if err := w.ReadData(&o.BytesReceived); err != nil {
		return err
	}
	o.Phonebook = make([]byte, 261)
	for i1 := range o.Phonebook {
		i1 := i1
		if err := w.ReadData(&o.Phonebook[i1]); err != nil {
			return err
		}
	}
	o.PhoneEntry = make([]byte, 257)
	for i1 := range o.PhoneEntry {
		i1 := i1
		if err := w.ReadData(&o.PhoneEntry[i1]); err != nil {
			return err
		}
	}
	_ptr_RI_ConnectionHandle := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		// FIXME: unknown type RI_ConnectionHandle
		return nil
	})
	_s_RI_ConnectionHandle := func(ptr interface{}) { o.ConnectionHandle = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.ConnectionHandle, _s_RI_ConnectionHandle, _ptr_RI_ConnectionHandle); err != nil {
		return err
	}
	if err := w.ReadData(&o.SubEntry); err != nil {
		return err
	}
	_eRASDeviceType := uint16(o.RASDeviceType)
	if err := w.ReadEnum(&_eRASDeviceType); err != nil {
		return err
	}
	o.RASDeviceType = RASDeviceType(_eRASDeviceType)
	if o.GUIDEntry == nil {
		o.GUIDEntry = &dtyp.GUID{}
	}
	if err := o.GUIDEntry.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.SessionID); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	if o.CorrelationGUID == nil {
		o.CorrelationGUID = &dtyp.GUID{}
	}
	if err := o.CorrelationGUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadTrailingGap(9); err != nil {
		return err
	}
	return nil
}

// Info structure represents Info RPC structure.
//
// The Info structure contains information specific to the REQTYPE_GETINFO ReqTypes
// (section 2.2.1.1.18) value.
type Info struct {
	Field1 *Info_Field1 `idl:"name:" json:""`
	// info: Specifies the port information as defined in the RASMAN_INFO (section 2.2.1.2.228)
	// structure.
	Info *RASMANInfo `idl:"name:info" json:"info"`
}

func (o *Info) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *Info) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	// FIXME unknown type
	if o.Info != nil {
		if err := o.Info.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&RASMANInfo{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *Info) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	// FIXME: unknown type
	if o.Info == nil {
		o.Info = &RASMANInfo{}
	}
	if err := o.Info.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

type Info_Field1 struct {
	// retcode: Specifies the return status as explained in section 2.2.1.2.218 for the
	// retcode field.
	ReturnCode uint32 `idl:"name:retcode" json:"return_code"`
	// paddingField: Reserved field to provide proper alignment of the structure.
	PaddingField []byte `idl:"name:paddingField" json:"padding_field"`
}

// CallbackList structure represents RASRPC_CALLBACKLIST RPC structure.
//
// The RASRPC_CALLBACKLIST structure specifies the callback information such as the
// callback device name and the callback phonenumber.
type CallbackList struct {
	// pszPortName: A null-terminated Unicode string specifying the port name on which callback
	// is made.
	PortName []uint16 `idl:"name:pszPortName" json:"port_name"`
	// pszDeviceName: A null-terminated Unicode string specifying the device name on which
	// callback is be made.
	DeviceName []uint16 `idl:"name:pszDeviceName" json:"device_name"`
	// pszNumber: A null-terminated Unicode string specifying the phone number to which
	// callback is be made.
	Number []uint16 `idl:"name:pszNumber" json:"number"`
	// dwDeviceType: Specifies the device type to which callback is to be made.
	//
	// This MUST take one of the following values:<161>
	//
	//	+--------------------+-------------------------------------------------------+
	//	|                    |                                                       |
	//	|       VALUE        |                        MEANING                        |
	//	|                    |                                                       |
	//	+--------------------+-------------------------------------------------------+
	//	+--------------------+-------------------------------------------------------+
	//	| PBDT_None 0        | No device.                                            |
	//	+--------------------+-------------------------------------------------------+
	//	| PBDT_Null 1        | Serial or parallel port device.                       |
	//	+--------------------+-------------------------------------------------------+
	//	| PBDT_Other 2       | Device other than mentioned in the table.             |
	//	+--------------------+-------------------------------------------------------+
	//	| PBDT_Modem 3       | A modem device.                                       |
	//	+--------------------+-------------------------------------------------------+
	//	| PBDT_Pad 4         | An X.25 [X.25] packet assembler/disassembler.         |
	//	+--------------------+-------------------------------------------------------+
	//	| PBDT_Switch 5      | Switch device.                                        |
	//	+--------------------+-------------------------------------------------------+
	//	| PBDT_Isdn 6        | An ISDN device.                                       |
	//	+--------------------+-------------------------------------------------------+
	//	| PBDT_X25 7         | An X.25 [X.25] device.                                |
	//	+--------------------+-------------------------------------------------------+
	//	| PBDT_ComPort 8     | Generic COM port device.                              |
	//	+--------------------+-------------------------------------------------------+
	//	| PBDT_Irda 10       | An Infrared Data Association (IrDA)-compliant device. |
	//	+--------------------+-------------------------------------------------------+
	//	| PBDT_Vpn 11        | A virtual private networking (VPN) device             |
	//	+--------------------+-------------------------------------------------------+
	//	| PBDT_Serial 12     | Serial port device.                                   |
	//	+--------------------+-------------------------------------------------------+
	//	| PBDT_Atm 13        | Asynchronous Transfer Mode (ATM) device.              |
	//	+--------------------+-------------------------------------------------------+
	//	| PBDT_Parallel 14   | Parallel port device.                                 |
	//	+--------------------+-------------------------------------------------------+
	//	| PBDT_Sonet 15      | Sonet device.                                         |
	//	+--------------------+-------------------------------------------------------+
	//	| PBDT_Sw56 16       | Switched 56K Access.                                  |
	//	+--------------------+-------------------------------------------------------+
	//	| PBDT_FrameRelay 17 | Frame Relay device.                                   |
	//	+--------------------+-------------------------------------------------------+
	//	| PBDT_PPPoE 18      | PPPoE device.                                         |
	//	+--------------------+-------------------------------------------------------+
	DeviceType uint32 `idl:"name:dwDeviceType" json:"device_type"`
	// pNext: Specifies the pointer to the next RASRPC_CALLBACKLIST structure. The last
	// member of the linked list of RASRPC_CALLBACKLIST structures MUST have the pNext field
	// set to NULL.
	Next *CallbackList `idl:"name:pNext;pointer:unique" json:"next"`
}

func (o *CallbackList) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *CallbackList) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	for i1 := range o.PortName {
		i1 := i1
		if uint64(i1) >= 17 {
			break
		}
		if err := w.WriteData(o.PortName[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.PortName); uint64(i1) < 17; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	for i1 := range o.DeviceName {
		i1 := i1
		if uint64(i1) >= 129 {
			break
		}
		if err := w.WriteData(o.DeviceName[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.DeviceName); uint64(i1) < 129; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	for i1 := range o.Number {
		i1 := i1
		if uint64(i1) >= 129 {
			break
		}
		if err := w.WriteData(o.Number[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Number); uint64(i1) < 129; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.DeviceType); err != nil {
		return err
	}
	if o.Next != nil {
		_ptr_pNext := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Next != nil {
				if err := o.Next.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&CallbackList{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Next, _ptr_pNext); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *CallbackList) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	o.PortName = make([]uint16, 17)
	for i1 := range o.PortName {
		i1 := i1
		if err := w.ReadData(&o.PortName[i1]); err != nil {
			return err
		}
	}
	o.DeviceName = make([]uint16, 129)
	for i1 := range o.DeviceName {
		i1 := i1
		if err := w.ReadData(&o.DeviceName[i1]); err != nil {
			return err
		}
	}
	o.Number = make([]uint16, 129)
	for i1 := range o.Number {
		i1 := i1
		if err := w.ReadData(&o.Number[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.DeviceType); err != nil {
		return err
	}
	_ptr_pNext := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Next == nil {
			o.Next = &CallbackList{}
		}
		if err := o.Next.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pNext := func(ptr interface{}) { o.Next = *ptr.(**CallbackList) }
	if err := w.ReadPointer(&o.Next, _s_pNext, _ptr_pNext); err != nil {
		return err
	}
	return nil
}

// StringList structure represents RASRPC_STRINGLIST RPC structure.
//
// The RASRPC_STRINGLIST structure contains a null-terminated Unicode string.
type StringList struct {
	// psz: Specifies a null-terminated Unicode string.
	String []uint16 `idl:"name:psz" json:"string"`
	// pNext: Specifies the pointer to the next RASRPC_STRINGLIST structure.
	Next *StringList `idl:"name:pNext;pointer:unique" json:"next"`
}

func (o *StringList) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *StringList) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(7); err != nil {
		return err
	}
	for i1 := range o.String {
		i1 := i1
		if uint64(i1) >= 256 {
			break
		}
		if err := w.WriteData(o.String[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.String); uint64(i1) < 256; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	if o.Next != nil {
		_ptr_pNext := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Next != nil {
				if err := o.Next.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&StringList{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Next, _ptr_pNext); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *StringList) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(7); err != nil {
		return err
	}
	o.String = make([]uint16, 256)
	for i1 := range o.String {
		i1 := i1
		if err := w.ReadData(&o.String[i1]); err != nil {
			return err
		}
	}
	_ptr_pNext := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Next == nil {
			o.Next = &StringList{}
		}
		if err := o.Next.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pNext := func(ptr interface{}) { o.Next = *ptr.(**StringList) }
	if err := w.ReadPointer(&o.Next, _s_pNext, _ptr_pNext); err != nil {
		return err
	}
	return nil
}

// Locationlist structure represents RASRPC_LOCATIONLIST RPC structure.
//
// The RASRPC_LOCATIONLIST structure contains information related to the TAPI location
// identifier.
type Locationlist struct {
	// dwLocationId: Specifies the TAPI location id.
	LocationID uint32 `idl:"name:dwLocationId" json:"location_id"`
	// iPrefix: It is unused and if set MUST be ignored by RRAS.
	Prefix uint32 `idl:"name:iPrefix" json:"prefix"`
	// iSuffix: It is unused and if set MUST be ignored by RRAS.
	Suffix uint32 `idl:"name:iSuffix" json:"suffix"`
	// pNext: Specifies the pointer to the next RASRPC_LOCATIONLIST structure.
	Next *Locationlist `idl:"name:pNext;pointer:unique" json:"next"`
}

func (o *Locationlist) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *Locationlist) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.LocationID); err != nil {
		return err
	}
	if err := w.WriteData(o.Prefix); err != nil {
		return err
	}
	if err := w.WriteData(o.Suffix); err != nil {
		return err
	}
	if o.Next != nil {
		_ptr_pNext := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Next != nil {
				if err := o.Next.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&Locationlist{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Next, _ptr_pNext); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *Locationlist) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.LocationID); err != nil {
		return err
	}
	if err := w.ReadData(&o.Prefix); err != nil {
		return err
	}
	if err := w.ReadData(&o.Suffix); err != nil {
		return err
	}
	_ptr_pNext := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Next == nil {
			o.Next = &Locationlist{}
		}
		if err := o.Next.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pNext := func(ptr interface{}) { o.Next = *ptr.(**Locationlist) }
	if err := w.ReadPointer(&o.Next, _s_pNext, _ptr_pNext); err != nil {
		return err
	}
	return nil
}

// User structure represents RASRPC_PBUSER RPC structure.
//
// The RASRPC_PBUSER structure contains configuration information of Demand Dial connection.
type User struct {
	// fOperatorDial: It is unused and can be set to any value.
	OperatorDial bool `idl:"name:fOperatorDial" json:"operator_dial"`
	// fPreviewPhoneNumber: It is unused and can be set to any value.
	PreviewPhoneNumber bool `idl:"name:fPreviewPhoneNumber" json:"preview_phone_number"`
	// fUseLocation: It is unused can be set to any value.
	UseLocation bool `idl:"name:fUseLocation" json:"use_location"`
	// fShowLights: It is unused and can be set to any value.
	ShowLights bool `idl:"name:fShowLights" json:"show_lights"`
	// fShowConnectStatus: It is unused and can be set to any value.
	ShowConnectStatus bool `idl:"name:fShowConnectStatus" json:"show_connect_status"`
	// fCloseOnDial: It is unused and can be set to any value.
	CloseOnDial bool `idl:"name:fCloseOnDial" json:"close_on_dial"`
	// fAllowLogonPhonebookEdits: It is unused and can be set to any value.
	AllowLogonPhonebookEdits bool `idl:"name:fAllowLogonPhonebookEdits" json:"allow_logon_phonebook_edits"`
	// fAllowLogonLocationEdits: It is unused and can be set to any value.
	AllowLogonLocationEdits bool `idl:"name:fAllowLogonLocationEdits" json:"allow_logon_location_edits"`
	// fSkipConnectComplete: It is unused and can be set to any value.
	SkipConnectComplete bool `idl:"name:fSkipConnectComplete" json:"skip_connect_complete"`
	// fNewEntryWizard: It is unused and can be set to any value.
	NewEntryWizard bool `idl:"name:fNewEntryWizard" json:"new_entry_wizard"`
	// dwRedialAttempts: It is unused and can be set to any value.
	RedialAttempts uint32 `idl:"name:dwRedialAttempts" json:"redial_attempts"`
	// dwRedialSeconds: It is unused and can be set to any value.
	RedialSeconds uint32 `idl:"name:dwRedialSeconds" json:"redial_seconds"`
	// dwIdleDisconnectSeconds: It is unused and can be set to any value.
	IdleDisconnectSeconds uint32 `idl:"name:dwIdleDisconnectSeconds" json:"idle_disconnect_seconds"`
	// fRedialOnLinkFailure: It is unused and can be set to any value.
	RedialOnLinkFailure bool `idl:"name:fRedialOnLinkFailure" json:"redial_on_link_failure"`
	// fPopupOnTopWhenRedialing: It is unused and can be set to any value.
	PopupOnTopWhenRedialing bool `idl:"name:fPopupOnTopWhenRedialing" json:"popup_on_top_when_redialing"`
	// fExpandAutoDialQuery: It is unused and can be set to any value.
	ExpandAutoDialQuery bool `idl:"name:fExpandAutoDialQuery" json:"expand_auto_dial_query"`
	// dwCallbackMode: It is unused and can be set to any value.
	CallbackMode uint32 `idl:"name:dwCallbackMode" json:"callback_mode"`
	// pCallbacks: A pointer to a linked list of callback information specified by RASRPC_CALLBACKLIST
	// (section 2.2.1.2.230) structures. Each member of the linked list specifies the callback
	// information for a particular port associated with a device.
	Callbacks *CallbackList `idl:"name:pCallbacks;pointer:unique" json:"callbacks"`
	// pszLastCallbackByCaller: A null-terminated Unicode string specifying the callback
	// phone number last used.
	LastCallbackByCaller []uint16 `idl:"name:pszLastCallbackByCaller" json:"last_callback_by_caller"`
	// dwPhonebookMode: It is unused and can be set to any value.
	PhonebookMode uint32 `idl:"name:dwPhonebookMode" json:"phonebook_mode"`
	// pszPersonalFile: It MUST be set to an empty string ("").
	PersonalFile []uint16 `idl:"name:pszPersonalFile" json:"personal_file"`
	// pszAlternatePath: It MUST be set to an empty string ("").
	AlternatePath []uint16 `idl:"name:pszAlternatePath" json:"alternate_path"`
	// pPhonebooks: It is not used and can be set to NULL.
	Phonebooks *StringList `idl:"name:pPhonebooks;pointer:unique" json:"phonebooks"`
	// pAreaCodes: It is not used and can be set to NULL.
	AreaCodes *StringList `idl:"name:pAreaCodes;pointer:unique" json:"area_codes"`
	// fUseAreaAndCountry: It is unused and can be set to any value.
	UseAreaAndCountry bool `idl:"name:fUseAreaAndCountry" json:"use_area_and_country"`
	// pPrefixes: It MUST be set to NULL.
	Prefixes *StringList `idl:"name:pPrefixes;pointer:unique" json:"prefixes"`
	// pSuffixes: It MUST be set to NULL.
	Suffixes *StringList `idl:"name:pSuffixes;pointer:unique" json:"suffixes"`
	// pLocations: It MUST be set to NULL.
	Locations *Locationlist `idl:"name:pLocations;pointer:unique" json:"locations"`
	// dwXPhonebook: It is unused and can be set to any value.
	XPhonebook uint32 `idl:"name:dwXPhonebook" json:"x_phonebook"`
	// dwYPhonebook: It is unused can be set to any value.
	YPhonebook uint32 `idl:"name:dwYPhonebook" json:"y_phonebook"`
	// pszDefaultEntry: It MUST be set to an empty string (").
	DefaultEntry []uint16 `idl:"name:pszDefaultEntry" json:"default_entry"`
	// fInitialized: If set to 1, specifies that the RASRPC_PBUSER structure is initialized
	// if set to 0 specifies that the RASRPC_PBUSER structure is not initialized.
	Initialized bool `idl:"name:fInitialized" json:"initialized"`
	// fDirty: If set to 1, specifies that the RASRPC_PBUSER structure needs to be stored
	// on server. If set to 0, specifies that the RASRPC_PBUSER structure need not be stored
	// on RRAS.
	Dirty bool `idl:"name:fDirty" json:"dirty"`
}

func (o *User) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *User) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if !o.OperatorDial {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if !o.PreviewPhoneNumber {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if !o.UseLocation {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if !o.ShowLights {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if !o.ShowConnectStatus {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if !o.CloseOnDial {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if !o.AllowLogonPhonebookEdits {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if !o.AllowLogonLocationEdits {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if !o.SkipConnectComplete {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if !o.NewEntryWizard {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.RedialAttempts); err != nil {
		return err
	}
	if err := w.WriteData(o.RedialSeconds); err != nil {
		return err
	}
	if err := w.WriteData(o.IdleDisconnectSeconds); err != nil {
		return err
	}
	if !o.RedialOnLinkFailure {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if !o.PopupOnTopWhenRedialing {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if !o.ExpandAutoDialQuery {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.CallbackMode); err != nil {
		return err
	}
	if o.Callbacks != nil {
		_ptr_pCallbacks := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Callbacks != nil {
				if err := o.Callbacks.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&CallbackList{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Callbacks, _ptr_pCallbacks); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	for i1 := range o.LastCallbackByCaller {
		i1 := i1
		if uint64(i1) >= 129 {
			break
		}
		if err := w.WriteData(o.LastCallbackByCaller[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.LastCallbackByCaller); uint64(i1) < 129; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.PhonebookMode); err != nil {
		return err
	}
	for i1 := range o.PersonalFile {
		i1 := i1
		if uint64(i1) >= 260 {
			break
		}
		if err := w.WriteData(o.PersonalFile[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.PersonalFile); uint64(i1) < 260; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	for i1 := range o.AlternatePath {
		i1 := i1
		if uint64(i1) >= 260 {
			break
		}
		if err := w.WriteData(o.AlternatePath[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.AlternatePath); uint64(i1) < 260; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	if o.Phonebooks != nil {
		_ptr_pPhonebooks := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Phonebooks != nil {
				if err := o.Phonebooks.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&StringList{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Phonebooks, _ptr_pPhonebooks); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.AreaCodes != nil {
		_ptr_pAreaCodes := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.AreaCodes != nil {
				if err := o.AreaCodes.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&StringList{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.AreaCodes, _ptr_pAreaCodes); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if !o.UseAreaAndCountry {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if o.Prefixes != nil {
		_ptr_pPrefixes := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Prefixes != nil {
				if err := o.Prefixes.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&StringList{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Prefixes, _ptr_pPrefixes); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.Suffixes != nil {
		_ptr_pSuffixes := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Suffixes != nil {
				if err := o.Suffixes.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&StringList{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Suffixes, _ptr_pSuffixes); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.Locations != nil {
		_ptr_pLocations := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Locations != nil {
				if err := o.Locations.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&Locationlist{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Locations, _ptr_pLocations); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.XPhonebook); err != nil {
		return err
	}
	if err := w.WriteData(o.YPhonebook); err != nil {
		return err
	}
	for i1 := range o.DefaultEntry {
		i1 := i1
		if uint64(i1) >= 257 {
			break
		}
		if err := w.WriteData(o.DefaultEntry[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.DefaultEntry); uint64(i1) < 257; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	if !o.Initialized {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if !o.Dirty {
		if err := w.WriteData(int32(0)); err != nil {
			return err
		}
	} else {
		if err := w.WriteData(int32(1)); err != nil {
			return err
		}
	}
	if err := w.WriteTrailingGap(9); err != nil {
		return err
	}
	return nil
}
func (o *User) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	var _bOperatorDial int32
	if err := w.ReadData(&_bOperatorDial); err != nil {
		return err
	}
	o.OperatorDial = _bOperatorDial != 0
	var _bPreviewPhoneNumber int32
	if err := w.ReadData(&_bPreviewPhoneNumber); err != nil {
		return err
	}
	o.PreviewPhoneNumber = _bPreviewPhoneNumber != 0
	var _bUseLocation int32
	if err := w.ReadData(&_bUseLocation); err != nil {
		return err
	}
	o.UseLocation = _bUseLocation != 0
	var _bShowLights int32
	if err := w.ReadData(&_bShowLights); err != nil {
		return err
	}
	o.ShowLights = _bShowLights != 0
	var _bShowConnectStatus int32
	if err := w.ReadData(&_bShowConnectStatus); err != nil {
		return err
	}
	o.ShowConnectStatus = _bShowConnectStatus != 0
	var _bCloseOnDial int32
	if err := w.ReadData(&_bCloseOnDial); err != nil {
		return err
	}
	o.CloseOnDial = _bCloseOnDial != 0
	var _bAllowLogonPhonebookEdits int32
	if err := w.ReadData(&_bAllowLogonPhonebookEdits); err != nil {
		return err
	}
	o.AllowLogonPhonebookEdits = _bAllowLogonPhonebookEdits != 0
	var _bAllowLogonLocationEdits int32
	if err := w.ReadData(&_bAllowLogonLocationEdits); err != nil {
		return err
	}
	o.AllowLogonLocationEdits = _bAllowLogonLocationEdits != 0
	var _bSkipConnectComplete int32
	if err := w.ReadData(&_bSkipConnectComplete); err != nil {
		return err
	}
	o.SkipConnectComplete = _bSkipConnectComplete != 0
	var _bNewEntryWizard int32
	if err := w.ReadData(&_bNewEntryWizard); err != nil {
		return err
	}
	o.NewEntryWizard = _bNewEntryWizard != 0
	if err := w.ReadData(&o.RedialAttempts); err != nil {
		return err
	}
	if err := w.ReadData(&o.RedialSeconds); err != nil {
		return err
	}
	if err := w.ReadData(&o.IdleDisconnectSeconds); err != nil {
		return err
	}
	var _bRedialOnLinkFailure int32
	if err := w.ReadData(&_bRedialOnLinkFailure); err != nil {
		return err
	}
	o.RedialOnLinkFailure = _bRedialOnLinkFailure != 0
	var _bPopupOnTopWhenRedialing int32
	if err := w.ReadData(&_bPopupOnTopWhenRedialing); err != nil {
		return err
	}
	o.PopupOnTopWhenRedialing = _bPopupOnTopWhenRedialing != 0
	var _bExpandAutoDialQuery int32
	if err := w.ReadData(&_bExpandAutoDialQuery); err != nil {
		return err
	}
	o.ExpandAutoDialQuery = _bExpandAutoDialQuery != 0
	if err := w.ReadData(&o.CallbackMode); err != nil {
		return err
	}
	_ptr_pCallbacks := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Callbacks == nil {
			o.Callbacks = &CallbackList{}
		}
		if err := o.Callbacks.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pCallbacks := func(ptr interface{}) { o.Callbacks = *ptr.(**CallbackList) }
	if err := w.ReadPointer(&o.Callbacks, _s_pCallbacks, _ptr_pCallbacks); err != nil {
		return err
	}
	o.LastCallbackByCaller = make([]uint16, 129)
	for i1 := range o.LastCallbackByCaller {
		i1 := i1
		if err := w.ReadData(&o.LastCallbackByCaller[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.PhonebookMode); err != nil {
		return err
	}
	o.PersonalFile = make([]uint16, 260)
	for i1 := range o.PersonalFile {
		i1 := i1
		if err := w.ReadData(&o.PersonalFile[i1]); err != nil {
			return err
		}
	}
	o.AlternatePath = make([]uint16, 260)
	for i1 := range o.AlternatePath {
		i1 := i1
		if err := w.ReadData(&o.AlternatePath[i1]); err != nil {
			return err
		}
	}
	_ptr_pPhonebooks := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Phonebooks == nil {
			o.Phonebooks = &StringList{}
		}
		if err := o.Phonebooks.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pPhonebooks := func(ptr interface{}) { o.Phonebooks = *ptr.(**StringList) }
	if err := w.ReadPointer(&o.Phonebooks, _s_pPhonebooks, _ptr_pPhonebooks); err != nil {
		return err
	}
	_ptr_pAreaCodes := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.AreaCodes == nil {
			o.AreaCodes = &StringList{}
		}
		if err := o.AreaCodes.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pAreaCodes := func(ptr interface{}) { o.AreaCodes = *ptr.(**StringList) }
	if err := w.ReadPointer(&o.AreaCodes, _s_pAreaCodes, _ptr_pAreaCodes); err != nil {
		return err
	}
	var _bUseAreaAndCountry int32
	if err := w.ReadData(&_bUseAreaAndCountry); err != nil {
		return err
	}
	o.UseAreaAndCountry = _bUseAreaAndCountry != 0
	_ptr_pPrefixes := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Prefixes == nil {
			o.Prefixes = &StringList{}
		}
		if err := o.Prefixes.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pPrefixes := func(ptr interface{}) { o.Prefixes = *ptr.(**StringList) }
	if err := w.ReadPointer(&o.Prefixes, _s_pPrefixes, _ptr_pPrefixes); err != nil {
		return err
	}
	_ptr_pSuffixes := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Suffixes == nil {
			o.Suffixes = &StringList{}
		}
		if err := o.Suffixes.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pSuffixes := func(ptr interface{}) { o.Suffixes = *ptr.(**StringList) }
	if err := w.ReadPointer(&o.Suffixes, _s_pSuffixes, _ptr_pSuffixes); err != nil {
		return err
	}
	_ptr_pLocations := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Locations == nil {
			o.Locations = &Locationlist{}
		}
		if err := o.Locations.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pLocations := func(ptr interface{}) { o.Locations = *ptr.(**Locationlist) }
	if err := w.ReadPointer(&o.Locations, _s_pLocations, _ptr_pLocations); err != nil {
		return err
	}
	if err := w.ReadData(&o.XPhonebook); err != nil {
		return err
	}
	if err := w.ReadData(&o.YPhonebook); err != nil {
		return err
	}
	o.DefaultEntry = make([]uint16, 257)
	for i1 := range o.DefaultEntry {
		i1 := i1
		if err := w.ReadData(&o.DefaultEntry[i1]); err != nil {
			return err
		}
	}
	var _bInitialized int32
	if err := w.ReadData(&_bInitialized); err != nil {
		return err
	}
	o.Initialized = _bInitialized != 0
	var _bDirty int32
	if err := w.ReadData(&_bDirty); err != nil {
		return err
	}
	o.Dirty = _bDirty != 0
	if err := w.ReadTrailingGap(9); err != nil {
		return err
	}
	return nil
}

// RemoteSetDNSConfig structure represents IRemoteSetDnsConfig RPC structure.
type RemoteSetDNSConfig dcom.InterfacePointer

func (o *RemoteSetDNSConfig) InterfacePointer() *dcom.InterfacePointer {
	return (*dcom.InterfacePointer)(o)
}

func (o *RemoteSetDNSConfig) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if o.Data != nil && o.DataCount == 0 {
		o.DataCount = uint32(len(o.Data))
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}

func (o *RemoteSetDNSConfig) NDRSizeInfo() []uint64 {
	dimSize1 := uint64(o.DataCount)
	return []uint64{
		dimSize1,
	}
}
func (o *RemoteSetDNSConfig) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for sz1 := range sizeInfo {
			if err := w.WriteSize(sizeInfo[sz1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.DataCount); err != nil {
		return err
	}
	for i1 := range o.Data {
		i1 := i1
		if uint64(i1) >= sizeInfo[0] {
			break
		}
		if err := w.WriteData(o.Data[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Data); uint64(i1) < sizeInfo[0]; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	return nil
}
func (o *RemoteSetDNSConfig) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for i1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[i1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.DataCount); err != nil {
		return err
	}
	// XXX: for opaque unmarshaling
	if o.DataCount > 0 && sizeInfo[0] == 0 {
		sizeInfo[0] = uint64(o.DataCount)
	}
	if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
		return fmt.Errorf("buffer overflow for size %d of array o.Data", sizeInfo[0])
	}
	o.Data = make([]byte, sizeInfo[0])
	for i1 := range o.Data {
		i1 := i1
		if err := w.ReadData(&o.Data[i1]); err != nil {
			return err
		}
	}
	return nil
}

// RemoteIPv6Config structure represents IRemoteIPV6Config RPC structure.
type RemoteIPv6Config dcom.InterfacePointer

func (o *RemoteIPv6Config) InterfacePointer() *dcom.InterfacePointer {
	return (*dcom.InterfacePointer)(o)
}

func (o *RemoteIPv6Config) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if o.Data != nil && o.DataCount == 0 {
		o.DataCount = uint32(len(o.Data))
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}

func (o *RemoteIPv6Config) NDRSizeInfo() []uint64 {
	dimSize1 := uint64(o.DataCount)
	return []uint64{
		dimSize1,
	}
}
func (o *RemoteIPv6Config) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for sz1 := range sizeInfo {
			if err := w.WriteSize(sizeInfo[sz1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.DataCount); err != nil {
		return err
	}
	for i1 := range o.Data {
		i1 := i1
		if uint64(i1) >= sizeInfo[0] {
			break
		}
		if err := w.WriteData(o.Data[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Data); uint64(i1) < sizeInfo[0]; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	return nil
}
func (o *RemoteIPv6Config) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for i1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[i1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.DataCount); err != nil {
		return err
	}
	// XXX: for opaque unmarshaling
	if o.DataCount > 0 && sizeInfo[0] == 0 {
		sizeInfo[0] = uint64(o.DataCount)
	}
	if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
		return fmt.Errorf("buffer overflow for size %d of array o.Data", sizeInfo[0])
	}
	o.Data = make([]byte, sizeInfo[0])
	for i1 := range o.Data {
		i1 := i1
		if err := w.ReadData(&o.Data[i1]); err != nil {
			return err
		}
	}
	return nil
}

// RemoteICFICSConfig structure represents IRemoteICFICSConfig RPC structure.
type RemoteICFICSConfig dcom.InterfacePointer

func (o *RemoteICFICSConfig) InterfacePointer() *dcom.InterfacePointer {
	return (*dcom.InterfacePointer)(o)
}

func (o *RemoteICFICSConfig) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if o.Data != nil && o.DataCount == 0 {
		o.DataCount = uint32(len(o.Data))
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}

func (o *RemoteICFICSConfig) NDRSizeInfo() []uint64 {
	dimSize1 := uint64(o.DataCount)
	return []uint64{
		dimSize1,
	}
}
func (o *RemoteICFICSConfig) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for sz1 := range sizeInfo {
			if err := w.WriteSize(sizeInfo[sz1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.DataCount); err != nil {
		return err
	}
	for i1 := range o.Data {
		i1 := i1
		if uint64(i1) >= sizeInfo[0] {
			break
		}
		if err := w.WriteData(o.Data[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Data); uint64(i1) < sizeInfo[0]; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	return nil
}
func (o *RemoteICFICSConfig) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for i1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[i1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.DataCount); err != nil {
		return err
	}
	// XXX: for opaque unmarshaling
	if o.DataCount > 0 && sizeInfo[0] == 0 {
		sizeInfo[0] = uint64(o.DataCount)
	}
	if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
		return fmt.Errorf("buffer overflow for size %d of array o.Data", sizeInfo[0])
	}
	o.Data = make([]byte, sizeInfo[0])
	for i1 := range o.Data {
		i1 := i1
		if err := w.ReadData(&o.Data[i1]); err != nil {
			return err
		}
	}
	return nil
}

// RemoteSSTPCertCheck structure represents IRemoteSstpCertCheck RPC structure.
type RemoteSSTPCertCheck dcom.InterfacePointer

func (o *RemoteSSTPCertCheck) InterfacePointer() *dcom.InterfacePointer {
	return (*dcom.InterfacePointer)(o)
}

func (o *RemoteSSTPCertCheck) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if o.Data != nil && o.DataCount == 0 {
		o.DataCount = uint32(len(o.Data))
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}

func (o *RemoteSSTPCertCheck) NDRSizeInfo() []uint64 {
	dimSize1 := uint64(o.DataCount)
	return []uint64{
		dimSize1,
	}
}
func (o *RemoteSSTPCertCheck) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for sz1 := range sizeInfo {
			if err := w.WriteSize(sizeInfo[sz1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.DataCount); err != nil {
		return err
	}
	for i1 := range o.Data {
		i1 := i1
		if uint64(i1) >= sizeInfo[0] {
			break
		}
		if err := w.WriteData(o.Data[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Data); uint64(i1) < sizeInfo[0]; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	return nil
}
func (o *RemoteSSTPCertCheck) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for i1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[i1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.DataCount); err != nil {
		return err
	}
	// XXX: for opaque unmarshaling
	if o.DataCount > 0 && sizeInfo[0] == 0 {
		sizeInfo[0] = uint64(o.DataCount)
	}
	if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
		return fmt.Errorf("buffer overflow for size %d of array o.Data", sizeInfo[0])
	}
	o.Data = make([]byte, sizeInfo[0])
	for i1 := range o.Data {
		i1 := i1
		if err := w.ReadData(&o.Data[i1]); err != nil {
			return err
		}
	}
	return nil
}

// RemoteNetworkConfig structure represents IRemoteNetworkConfig RPC structure.
type RemoteNetworkConfig dcom.InterfacePointer

func (o *RemoteNetworkConfig) InterfacePointer() *dcom.InterfacePointer {
	return (*dcom.InterfacePointer)(o)
}

func (o *RemoteNetworkConfig) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if o.Data != nil && o.DataCount == 0 {
		o.DataCount = uint32(len(o.Data))
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}

func (o *RemoteNetworkConfig) NDRSizeInfo() []uint64 {
	dimSize1 := uint64(o.DataCount)
	return []uint64{
		dimSize1,
	}
}
func (o *RemoteNetworkConfig) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for sz1 := range sizeInfo {
			if err := w.WriteSize(sizeInfo[sz1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.DataCount); err != nil {
		return err
	}
	for i1 := range o.Data {
		i1 := i1
		if uint64(i1) >= sizeInfo[0] {
			break
		}
		if err := w.WriteData(o.Data[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Data); uint64(i1) < sizeInfo[0]; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	return nil
}
func (o *RemoteNetworkConfig) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for i1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[i1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.DataCount); err != nil {
		return err
	}
	// XXX: for opaque unmarshaling
	if o.DataCount > 0 && sizeInfo[0] == 0 {
		sizeInfo[0] = uint64(o.DataCount)
	}
	if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
		return fmt.Errorf("buffer overflow for size %d of array o.Data", sizeInfo[0])
	}
	o.Data = make([]byte, sizeInfo[0])
	for i1 := range o.Data {
		i1 := i1
		if err := w.ReadData(&o.Data[i1]); err != nil {
			return err
		}
	}
	return nil
}

// RemoteStringIDConfig structure represents IRemoteStringIdConfig RPC structure.
type RemoteStringIDConfig dcom.InterfacePointer

func (o *RemoteStringIDConfig) InterfacePointer() *dcom.InterfacePointer {
	return (*dcom.InterfacePointer)(o)
}

func (o *RemoteStringIDConfig) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if o.Data != nil && o.DataCount == 0 {
		o.DataCount = uint32(len(o.Data))
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}

func (o *RemoteStringIDConfig) NDRSizeInfo() []uint64 {
	dimSize1 := uint64(o.DataCount)
	return []uint64{
		dimSize1,
	}
}
func (o *RemoteStringIDConfig) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for sz1 := range sizeInfo {
			if err := w.WriteSize(sizeInfo[sz1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.DataCount); err != nil {
		return err
	}
	for i1 := range o.Data {
		i1 := i1
		if uint64(i1) >= sizeInfo[0] {
			break
		}
		if err := w.WriteData(o.Data[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Data); uint64(i1) < sizeInfo[0]; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	return nil
}
func (o *RemoteStringIDConfig) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for i1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[i1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.DataCount); err != nil {
		return err
	}
	// XXX: for opaque unmarshaling
	if o.DataCount > 0 && sizeInfo[0] == 0 {
		sizeInfo[0] = uint64(o.DataCount)
	}
	if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
		return fmt.Errorf("buffer overflow for size %d of array o.Data", sizeInfo[0])
	}
	o.Data = make([]byte, sizeInfo[0])
	for i1 := range o.Data {
		i1 := i1
		if err := w.ReadData(&o.Data[i1]); err != nil {
			return err
		}
	}
	return nil
}

// RemoteRouterRestart structure represents IRemoteRouterRestart RPC structure.
type RemoteRouterRestart dcom.InterfacePointer

func (o *RemoteRouterRestart) InterfacePointer() *dcom.InterfacePointer {
	return (*dcom.InterfacePointer)(o)
}

func (o *RemoteRouterRestart) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if o.Data != nil && o.DataCount == 0 {
		o.DataCount = uint32(len(o.Data))
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}

func (o *RemoteRouterRestart) NDRSizeInfo() []uint64 {
	dimSize1 := uint64(o.DataCount)
	return []uint64{
		dimSize1,
	}
}
func (o *RemoteRouterRestart) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for sz1 := range sizeInfo {
			if err := w.WriteSize(sizeInfo[sz1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.DataCount); err != nil {
		return err
	}
	for i1 := range o.Data {
		i1 := i1
		if uint64(i1) >= sizeInfo[0] {
			break
		}
		if err := w.WriteData(o.Data[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Data); uint64(i1) < sizeInfo[0]; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	return nil
}
func (o *RemoteRouterRestart) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	sizeInfo, ok := ctx.Value(ndr.SizeInfo).([]uint64)
	if !ok {
		sizeInfo = o.NDRSizeInfo()
		for i1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[i1]); err != nil {
				return err
			}
		}
		ctx = context.WithValue(ctx, ndr.SizeInfo, sizeInfo)
	}
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.DataCount); err != nil {
		return err
	}
	// XXX: for opaque unmarshaling
	if o.DataCount > 0 && sizeInfo[0] == 0 {
		sizeInfo[0] = uint64(o.DataCount)
	}
	if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
		return fmt.Errorf("buffer overflow for size %d of array o.Data", sizeInfo[0])
	}
	o.Data = make([]byte, sizeInfo[0])
	for i1 := range o.Data {
		i1 := i1
		if err := w.ReadData(&o.Data[i1]); err != nil {
			return err
		}
	}
	return nil
}
