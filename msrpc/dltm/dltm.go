// The dltm package implements the DLTM client protocol.
//
// # Introduction
//
// This document specifies the Distributed Link Tracking: Central Manager Protocol.
//
// Distributed Link Tracking (DLT) consists of two protocols that work together to discover
// the new location of a file that has moved. DLT can determine whether the file has
// moved on a mass-storage device, within a computer, or between computers in a network.
// In addition to the Distributed Link Tracking: Central Manager Protocol, DLT includes
// the Distributed Link Tracking: Workstation Protocol, as specified in [MS-DLTW], which
// is used to determine a file's current location. Both DLT protocols are remote procedure
// call (RPC) interfaces.
//
// # Overview
//
// The Distributed Link Tracking: Central Manager Protocol is based on the Remote Procedure
// Call Protocol Extensions, as specified in [MS-RPCE]. The primary purpose of this
// protocol is to allow clients of the Distributed Link Tracking: Workstation Protocol
// to determine the correct server to contact when searching for a file. To accomplish
// this, the Distributed Link Tracking (DLT) Central Manager server accepts notifications
// of file and volume moves, in addition to other relevant information from participating
// computers. This information can be queried by clients to get the file's current location
// in UNC form.
//
// The following is a scenario of this protocol working together with the Distributed
// Link Tracking: Workstation Protocol:
//
// * A file is created on computer M1. M1 assigns identifiers, specifically FileID (
// a45c8c1a-fb81-4a65-a3f1-82d471da2197#gt_3b097896-b707-47b5-b1bb-384867a453ea ) and
// FileLocation ( a45c8c1a-fb81-4a65-a3f1-82d471da2197#gt_d0fe4e63-48a5-4d63-9d51-d4f99306046e
// ) , to the file.
//
// * Computer M0 makes note of the file, locally storing its identifiers.
//
// * The file is moved from computer M1 to M2 and from there to M3. In conjunction with
// these moves, the file maintains its FileID value, but a new FileLocation identifier
// is assigned.
//
// * To find the file in its new location, M0 contacts a DLT Central Manager server
// to query the current location of the file.
//
// * The DLT Central Manager server queries its tables, and determines that the file
// is currently on computer M3.
//
// * M0 contacts the Distributed Link Tracking: Central Manager Protocol on M3, and
// learns the file's new name and location.
//
// The following diagram shows the machine configuration for this example. The list
// after the diagram walks through the scenario, and describes in more detail how the
// Distributed Link Tracking: Central Manager Protocol is used.
package dltm

import (
	"context"
	"fmt"
	"strings"
	"unicode/utf16"

	dcerpc "github.com/oiweiwei/go-msrpc/dcerpc"
	errors "github.com/oiweiwei/go-msrpc/dcerpc/errors"
	uuid "github.com/oiweiwei/go-msrpc/midl/uuid"
	dltw "github.com/oiweiwei/go-msrpc/msrpc/dltw"
	dtyp "github.com/oiweiwei/go-msrpc/msrpc/dtyp"
	ndr "github.com/oiweiwei/go-msrpc/ndr"
)

var (
	_ = context.Background
	_ = fmt.Errorf
	_ = utf16.Encode
	_ = strings.TrimPrefix
	_ = ndr.ZeroString
	_ = (*uuid.UUID)(nil)
	_ = (*dcerpc.SyntaxID)(nil)
	_ = (*errors.Error)(nil)
	_ = dltw.GoPackage
	_ = dtyp.GoPackage
)

var (
	// import guard
	GoPackage = "dltm"
)

// VolumeSecret structure represents CVolumeSecret RPC structure.
//
// The CVolumeSecret type stores a VolumeSecret value, which is used to authenticate
// a VolumeOwner value. For an example, see section 3.1.4.4.1, which describes the processing
// of a CLAIM_VOLUME message.
type VolumeSecret struct {
	// _abSecret:  An 8-byte volume password. The content of these bytes is arbitrary and
	// is generated by the client. See section 3.2.5.3 for an example of where this value
	// is used.
	Secret []byte `idl:"name:_abSecret" json:"secret"`
}

func (o *VolumeSecret) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *VolumeSecret) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	for i1 := range o.Secret {
		i1 := i1
		if uint64(i1) >= 8 {
			break
		}
		if err := w.WriteData(o.Secret[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Secret); uint64(i1) < 8; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	return nil
}
func (o *VolumeSecret) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	o.Secret = make([]byte, 8)
	for i1 := range o.Secret {
		i1 := i1
		if err := w.ReadData(&o.Secret[i1]); err != nil {
			return err
		}
	}
	return nil
}

// OldFileTrackingInformation structure represents old_TRK_FILE_TRACKING_INFORMATION RPC structure.
//
// The old_TRK_FILE_TRACKING_INFORMATION structure is unused, but is included in this
// protocol because it affects the definition of the TRKSVR_MESSAGE_UNION, as defined
// in section 2.2.13.
type OldFileTrackingInformation struct {
	FilePath     []uint16                     `idl:"name:tszFilePath" json:"file_path"`
	Birth        *dltw.DomainRelativeObjectID `idl:"name:droidBirth" json:"birth"`
	LastObjectID *dltw.DomainRelativeObjectID `idl:"name:droidLast" json:"last_object_id"`
	HResult      int32                        `idl:"name:hr" json:"hresult"`
}

func (o *OldFileTrackingInformation) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *OldFileTrackingInformation) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	for i1 := range o.FilePath {
		i1 := i1
		if uint64(i1) >= 257 {
			break
		}
		if err := w.WriteData(o.FilePath[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.FilePath); uint64(i1) < 257; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	if o.Birth != nil {
		if err := o.Birth.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dltw.DomainRelativeObjectID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.LastObjectID != nil {
		if err := o.LastObjectID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dltw.DomainRelativeObjectID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.HResult); err != nil {
		return err
	}
	return nil
}
func (o *OldFileTrackingInformation) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	o.FilePath = make([]uint16, 257)
	for i1 := range o.FilePath {
		i1 := i1
		if err := w.ReadData(&o.FilePath[i1]); err != nil {
			return err
		}
	}
	if o.Birth == nil {
		o.Birth = &dltw.DomainRelativeObjectID{}
	}
	if err := o.Birth.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.LastObjectID == nil {
		o.LastObjectID = &dltw.DomainRelativeObjectID{}
	}
	if err := o.LastObjectID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.HResult); err != nil {
		return err
	}
	return nil
}

// FileTrackingInformation structure represents TRK_FILE_TRACKING_INFORMATION RPC structure.
//
// The TRK_FILE_TRACKING_INFORMATION structure is used in a SEARCH message of a LnkSvrMessage
// method call to search for the current location of a file. This structure contains
// information about a file that is being tracked. See section 2.2.11 for more information
// about the SEARCH message. See section 3.2.6.3 for an example of how the TRK_FILE_TRACKING_INFORMATION
// structure is used.
type FileTrackingInformation struct {
	// droidBirth:  The FileID of the file for which the location is being requested. For
	// details on this structure, see [MS-DLTW] section 2.2.3.
	Birth *dltw.DomainRelativeObjectID `idl:"name:droidBirth" json:"birth"`
	// droidLast:  On input, the last FileLocation that the client knew of for the file.
	// On output, this member contains the file's current FileLocation.
	LastObjectID *dltw.DomainRelativeObjectID `idl:"name:droidLast" json:"last_object_id"`
	// mcidLast:  On completion of the SEARCH request, this member is returned by the server
	// to indicate the MachineID of the VolumeOwner of the VolumeID component of the droidLast
	// field. The CMachineId type is specified in [MS-DLTW] section 2.2.2.
	LastMachineID *dltw.MachineID `idl:"name:mcidLast" json:"last_machine_id"`
	// hr:  Return value that indicates the success or failure of this message. The type
	// of this field is an HRESULT but, unlike the standard definition, only zero is a successful
	// return value for this field. Any nonzero value MUST be treated identically as a failure
	// value.
	HResult int32 `idl:"name:hr" json:"hresult"`
}

func (o *FileTrackingInformation) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *FileTrackingInformation) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if o.Birth != nil {
		if err := o.Birth.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dltw.DomainRelativeObjectID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.LastObjectID != nil {
		if err := o.LastObjectID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dltw.DomainRelativeObjectID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.LastMachineID != nil {
		if err := o.LastMachineID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dltw.MachineID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.HResult); err != nil {
		return err
	}
	return nil
}
func (o *FileTrackingInformation) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if o.Birth == nil {
		o.Birth = &dltw.DomainRelativeObjectID{}
	}
	if err := o.Birth.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.LastObjectID == nil {
		o.LastObjectID = &dltw.DomainRelativeObjectID{}
	}
	if err := o.LastObjectID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.LastMachineID == nil {
		o.LastMachineID = &dltw.MachineID{}
	}
	if err := o.LastMachineID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.HResult); err != nil {
		return err
	}
	return nil
}

// OldCallSearch structure represents old_TRKSVR_CALL_SEARCH RPC structure.
//
// The old_TRKSVR_CALL_SEARCH structure is unused but is included in this protocol because
// it affects the definition of the TRKSVR_MESSAGE_UNION, as defined in section 2.2.13.
type OldCallSearch struct {
	SearchCount uint32                        `idl:"name:cSearch" json:"search_count"`
	Searches    []*OldFileTrackingInformation `idl:"name:pSearches;size_is:(cSearch)" json:"searches"`
}

func (o *OldCallSearch) xxx_PreparePayload(ctx context.Context) error {
	if o.Searches != nil && o.SearchCount == 0 {
		o.SearchCount = uint32(len(o.Searches))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *OldCallSearch) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.SearchCount); err != nil {
		return err
	}
	if o.Searches != nil || o.SearchCount > 0 {
		_ptr_pSearches := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.SearchCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Searches {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Searches[i1] != nil {
					if err := o.Searches[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&OldFileTrackingInformation{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Searches); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&OldFileTrackingInformation{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Searches, _ptr_pSearches); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *OldCallSearch) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.SearchCount); err != nil {
		return err
	}
	_ptr_pSearches := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.SearchCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.SearchCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Searches", sizeInfo[0])
		}
		o.Searches = make([]*OldFileTrackingInformation, sizeInfo[0])
		for i1 := range o.Searches {
			i1 := i1
			if o.Searches[i1] == nil {
				o.Searches[i1] = &OldFileTrackingInformation{}
			}
			if err := o.Searches[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_pSearches := func(ptr interface{}) { o.Searches = *ptr.(*[]*OldFileTrackingInformation) }
	if err := w.ReadPointer(&o.Searches, _s_pSearches, _ptr_pSearches); err != nil {
		return err
	}
	return nil
}

// CallSearch structure represents TRKSVR_CALL_SEARCH RPC structure.
//
// The TRKSVR_CALL_SEARCH structure is used in LnkSvrMessage method calls that specify
// a SEARCH message (see section 2.2.11), to query the DLT Central Manager server for
// the location of a file. See section 3.2.6.3 for an example of client use of this
// structure.
type CallSearch struct {
	// cSearch:  This value MUST be set to one.
	SearchCount uint32 `idl:"name:cSearch" json:"search_count"`
	// pSearches:  A pointer to a single search request. See TRK_FILE_TRACKING_INFORMATION
	// (section 2.2.8).
	Searches []*FileTrackingInformation `idl:"name:pSearches;size_is:(cSearch)" json:"searches"`
}

func (o *CallSearch) xxx_PreparePayload(ctx context.Context) error {
	if o.Searches != nil && o.SearchCount == 0 {
		o.SearchCount = uint32(len(o.Searches))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *CallSearch) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.SearchCount); err != nil {
		return err
	}
	if o.Searches != nil || o.SearchCount > 0 {
		_ptr_pSearches := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.SearchCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Searches {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Searches[i1] != nil {
					if err := o.Searches[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&FileTrackingInformation{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Searches); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&FileTrackingInformation{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Searches, _ptr_pSearches); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *CallSearch) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.SearchCount); err != nil {
		return err
	}
	_ptr_pSearches := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.SearchCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.SearchCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Searches", sizeInfo[0])
		}
		o.Searches = make([]*FileTrackingInformation, sizeInfo[0])
		for i1 := range o.Searches {
			i1 := i1
			if o.Searches[i1] == nil {
				o.Searches[i1] = &FileTrackingInformation{}
			}
			if err := o.Searches[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_pSearches := func(ptr interface{}) { o.Searches = *ptr.(*[]*FileTrackingInformation) }
	if err := w.ReadPointer(&o.Searches, _s_pSearches, _ptr_pSearches); err != nil {
		return err
	}
	return nil
}

// CallMoveNotification structure represents TRKSVR_CALL_MOVE_NOTIFICATION RPC structure.
//
// The TRKSVR_CALL_MOVE_NOTIFICATION structure is used in LnkSvrMessage method calls
// that specify a MOVE_NOTIFICATION message (see section 2.2.11), to indicate when one
// or more files have been moved off a volume. See section 3.2.6.1 for an example of
// the client using this structure.
type CallMoveNotification struct {
	// cNotifications:  This field MUST contain the number of move notifications that were
	// received.
	NotificationsCount uint32 `idl:"name:cNotifications" json:"notifications_count"`
	// cProcessed:  On return to the client, this field MUST indicate the number of notifications
	// from the request message that were actually processed.
	ProcessedCount uint32 `idl:"name:cProcessed" json:"processed_count"`
	// seq:  This field MUST be set by the client to the VolumeSequenceNumber for this VolumeID.
	// This value is used by the client and server to detect whether or not notifications
	// have been lost. For information about sequence numbering, see sections 3.1.4.2 and
	// 3.2.4.2.
	Seq int32 `idl:"name:seq" json:"seq"`
	// fForceSeqNumber:  This field MUST be set by the client to indicate whether the seq
	// value is to be ignored. If set, seq MUST be ignored. Sequence numbering is as specified
	// in sections 3.1.4.2 and 3.2.4.2.
	ForceSeqNumber int32 `idl:"name:fForceSeqNumber" json:"force_seq_number"`
	// pvolid:  This field MUST contain the VolumeID, which indicates the volume from which
	// the files in this notification were moved. CVolumeId is as specified in [MS-DLTW]
	// section 2.2.4.
	Volume *dltw.VolumeID `idl:"name:pvolid" json:"volume"`
	// rgobjidCurrent:  This field MUST contain an array of ObjectIDs with the ObjectID
	// for each file that was moved. CObjId is as specified in [MS-DLTW] section 2.2.5.
	// Note that the previous FileLocation of each of the moved files MUST be determined
	// by composing the VolumeID from the pvolid value with each of the entries in the rgobjidCurrent
	// array.
	Current []*dltw.ObjectID `idl:"name:rgobjidCurrent;size_is:(cNotifications)" json:"current"`
	// rgdroidBirth:  This field MUST contain an array of FileIDs with the FileID for each
	// file that was moved in this request. Each element in the rgdroidBirth array corresponds
	// to the entry with the same index in the rgobjidCurrent array. CDomainRelativeObjId
	// is as specified in [MS-DLTW] section 2.2.3.
	Birth []*dltw.DomainRelativeObjectID `idl:"name:rgdroidBirth;size_is:(cNotifications)" json:"birth"`
	// rgdroidNew:  This field MUST contain an array of FileLocations, with the new FileLocation
	// for each file that was moved in this request. Each element in the rgdroidNew array
	// corresponds to the entry with the same index in the rgobjidCurrent and rgdroidBirth
	// arrays.
	New []*dltw.DomainRelativeObjectID `idl:"name:rgdroidNew;size_is:(cNotifications)" json:"new"`
}

func (o *CallMoveNotification) xxx_PreparePayload(ctx context.Context) error {
	if o.Current != nil && o.NotificationsCount == 0 {
		o.NotificationsCount = uint32(len(o.Current))
	}
	if o.Birth != nil && o.NotificationsCount == 0 {
		o.NotificationsCount = uint32(len(o.Birth))
	}
	if o.New != nil && o.NotificationsCount == 0 {
		o.NotificationsCount = uint32(len(o.New))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *CallMoveNotification) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.NotificationsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.ProcessedCount); err != nil {
		return err
	}
	if err := w.WriteData(o.Seq); err != nil {
		return err
	}
	if err := w.WriteData(o.ForceSeqNumber); err != nil {
		return err
	}
	if o.Volume != nil {
		_ptr_pvolid := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Volume != nil {
				if err := o.Volume.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&dltw.VolumeID{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Volume, _ptr_pvolid); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.Current != nil || o.NotificationsCount > 0 {
		_ptr_rgobjidCurrent := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.NotificationsCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Current {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Current[i1] != nil {
					if err := o.Current[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dltw.ObjectID{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Current); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&dltw.ObjectID{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Current, _ptr_rgobjidCurrent); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.Birth != nil || o.NotificationsCount > 0 {
		_ptr_rgdroidBirth := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.NotificationsCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Birth {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Birth[i1] != nil {
					if err := o.Birth[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dltw.DomainRelativeObjectID{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Birth); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&dltw.DomainRelativeObjectID{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Birth, _ptr_rgdroidBirth); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.New != nil || o.NotificationsCount > 0 {
		_ptr_rgdroidNew := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.NotificationsCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.New {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.New[i1] != nil {
					if err := o.New[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dltw.DomainRelativeObjectID{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.New); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&dltw.DomainRelativeObjectID{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.New, _ptr_rgdroidNew); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *CallMoveNotification) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.NotificationsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.ProcessedCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.Seq); err != nil {
		return err
	}
	if err := w.ReadData(&o.ForceSeqNumber); err != nil {
		return err
	}
	_ptr_pvolid := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Volume == nil {
			o.Volume = &dltw.VolumeID{}
		}
		if err := o.Volume.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_pvolid := func(ptr interface{}) { o.Volume = *ptr.(**dltw.VolumeID) }
	if err := w.ReadPointer(&o.Volume, _s_pvolid, _ptr_pvolid); err != nil {
		return err
	}
	_ptr_rgobjidCurrent := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.NotificationsCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.NotificationsCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Current", sizeInfo[0])
		}
		o.Current = make([]*dltw.ObjectID, sizeInfo[0])
		for i1 := range o.Current {
			i1 := i1
			if o.Current[i1] == nil {
				o.Current[i1] = &dltw.ObjectID{}
			}
			if err := o.Current[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_rgobjidCurrent := func(ptr interface{}) { o.Current = *ptr.(*[]*dltw.ObjectID) }
	if err := w.ReadPointer(&o.Current, _s_rgobjidCurrent, _ptr_rgobjidCurrent); err != nil {
		return err
	}
	_ptr_rgdroidBirth := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.NotificationsCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.NotificationsCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Birth", sizeInfo[0])
		}
		o.Birth = make([]*dltw.DomainRelativeObjectID, sizeInfo[0])
		for i1 := range o.Birth {
			i1 := i1
			if o.Birth[i1] == nil {
				o.Birth[i1] = &dltw.DomainRelativeObjectID{}
			}
			if err := o.Birth[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_rgdroidBirth := func(ptr interface{}) { o.Birth = *ptr.(*[]*dltw.DomainRelativeObjectID) }
	if err := w.ReadPointer(&o.Birth, _s_rgdroidBirth, _ptr_rgdroidBirth); err != nil {
		return err
	}
	_ptr_rgdroidNew := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.NotificationsCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.NotificationsCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.New", sizeInfo[0])
		}
		o.New = make([]*dltw.DomainRelativeObjectID, sizeInfo[0])
		for i1 := range o.New {
			i1 := i1
			if o.New[i1] == nil {
				o.New[i1] = &dltw.DomainRelativeObjectID{}
			}
			if err := o.New[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_rgdroidNew := func(ptr interface{}) { o.New = *ptr.(*[]*dltw.DomainRelativeObjectID) }
	if err := w.ReadPointer(&o.New, _s_rgdroidNew, _ptr_rgdroidNew); err != nil {
		return err
	}
	return nil
}

// CallRefresh structure represents TRKSVR_CALL_REFRESH RPC structure.
//
// The TRKSVR_CALL_REFRESH structure is used in LnkSvrMessage method calls that specify
// a REFRESH message (see section 2.2.11), to indicate to the server that a file or
// volume is still in use. The server uses this to determine when an entry in its tables
// is no longer in use and can be deleted. See section 3.2.5.2 for an example of client
// use of this structure.
type CallRefresh struct {
	// cSources:  This field MUST contain the number of elements in the adroidBirth array.
	SourcesCount uint32 `idl:"name:cSources" json:"sources_count"`
	// adroidBirth:  This field MUST contain an array of FileIDs, with the FileID for files
	// on the client computer for which the client is requesting a refresh. The type of
	// this field, CDomainRelativeObjId, is as specified in [MS-DLTW] section 2.2.3. If
	// this array is empty, it indicates that there are no FileIDs to be refreshed by this
	// request.
	Birth []*dltw.DomainRelativeObjectID `idl:"name:adroidBirth;size_is:(cSources)" json:"birth"`
	// cVolumes:  This field MUST contain the number of elements in the avolid array. Note
	// that this is independent of the cSources value.
	VolumesCount uint32 `idl:"name:cVolumes" json:"volumes_count"`
	// avolid:  This field MUST contain an array of VolumeIDs for volumes on the client
	// computer for which the client requests a refresh. CVolumeId is as specified in [MS-DLTW]
	// section 2.2.4. If this array is empty, it indicates that there are no VolumeIDs to
	// be refreshed by this request.
	Volumes []*dltw.VolumeID `idl:"name:avolid;size_is:(cVolumes)" json:"volumes"`
}

func (o *CallRefresh) xxx_PreparePayload(ctx context.Context) error {
	if o.Birth != nil && o.SourcesCount == 0 {
		o.SourcesCount = uint32(len(o.Birth))
	}
	if o.Volumes != nil && o.VolumesCount == 0 {
		o.VolumesCount = uint32(len(o.Volumes))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *CallRefresh) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.SourcesCount); err != nil {
		return err
	}
	if o.Birth != nil || o.SourcesCount > 0 {
		_ptr_adroidBirth := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.SourcesCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Birth {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Birth[i1] != nil {
					if err := o.Birth[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dltw.DomainRelativeObjectID{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Birth); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&dltw.DomainRelativeObjectID{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Birth, _ptr_adroidBirth); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.VolumesCount); err != nil {
		return err
	}
	if o.Volumes != nil || o.VolumesCount > 0 {
		_ptr_avolid := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.VolumesCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Volumes {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Volumes[i1] != nil {
					if err := o.Volumes[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dltw.VolumeID{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Volumes); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&dltw.VolumeID{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Volumes, _ptr_avolid); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *CallRefresh) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.SourcesCount); err != nil {
		return err
	}
	_ptr_adroidBirth := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.SourcesCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.SourcesCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Birth", sizeInfo[0])
		}
		o.Birth = make([]*dltw.DomainRelativeObjectID, sizeInfo[0])
		for i1 := range o.Birth {
			i1 := i1
			if o.Birth[i1] == nil {
				o.Birth[i1] = &dltw.DomainRelativeObjectID{}
			}
			if err := o.Birth[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_adroidBirth := func(ptr interface{}) { o.Birth = *ptr.(*[]*dltw.DomainRelativeObjectID) }
	if err := w.ReadPointer(&o.Birth, _s_adroidBirth, _ptr_adroidBirth); err != nil {
		return err
	}
	if err := w.ReadData(&o.VolumesCount); err != nil {
		return err
	}
	_ptr_avolid := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.VolumesCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.VolumesCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Volumes", sizeInfo[0])
		}
		o.Volumes = make([]*dltw.VolumeID, sizeInfo[0])
		for i1 := range o.Volumes {
			i1 := i1
			if o.Volumes[i1] == nil {
				o.Volumes[i1] = &dltw.VolumeID{}
			}
			if err := o.Volumes[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_avolid := func(ptr interface{}) { o.Volumes = *ptr.(*[]*dltw.VolumeID) }
	if err := w.ReadPointer(&o.Volumes, _s_avolid, _ptr_avolid); err != nil {
		return err
	}
	return nil
}

// CallDelete structure represents TRKSVR_CALL_DELETE RPC structure.
//
// The TRKSVR_CALL_DELETE structure is used in LnkSvrMessage method calls that specify
// a DELETE_NOTIFY message (see section 2.2.11), to indicate which files are to be removed
// from the FileTable. See section 3.2.6.2 for an example of the client using this structure.
type CallDelete struct {
	// cdroidBirth:  This field MUST contain the number of entries in the adroidBirth array.
	BirthCount uint32 `idl:"name:cdroidBirth" json:"birth_count"`
	// adroidBirth:  This field MUST contain an array of FileIDs of files that have been
	// deleted. CDomainRelativeObjId is as specified in [MS-DLTW] section 2.2.3.
	Birth []*dltw.DomainRelativeObjectID `idl:"name:adroidBirth;size_is:(cdroidBirth)" json:"birth"`
	// cVolumes:  This field is unused and MUST be zero.
	VolumesCount uint32 `idl:"name:cVolumes" json:"volumes_count"`
	// pVolumes:  This field is unused and MUST be set to zero.
	Volumes []*dltw.VolumeID `idl:"name:pVolumes;size_is:(cVolumes)" json:"volumes"`
}

func (o *CallDelete) xxx_PreparePayload(ctx context.Context) error {
	if o.Birth != nil && o.BirthCount == 0 {
		o.BirthCount = uint32(len(o.Birth))
	}
	if o.Volumes != nil && o.VolumesCount == 0 {
		o.VolumesCount = uint32(len(o.Volumes))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *CallDelete) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.BirthCount); err != nil {
		return err
	}
	if o.Birth != nil || o.BirthCount > 0 {
		_ptr_adroidBirth := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.BirthCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Birth {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Birth[i1] != nil {
					if err := o.Birth[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dltw.DomainRelativeObjectID{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Birth); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&dltw.DomainRelativeObjectID{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Birth, _ptr_adroidBirth); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.VolumesCount); err != nil {
		return err
	}
	if o.Volumes != nil || o.VolumesCount > 0 {
		_ptr_pVolumes := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.VolumesCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Volumes {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Volumes[i1] != nil {
					if err := o.Volumes[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dltw.VolumeID{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Volumes); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&dltw.VolumeID{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Volumes, _ptr_pVolumes); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *CallDelete) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.BirthCount); err != nil {
		return err
	}
	_ptr_adroidBirth := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.BirthCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.BirthCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Birth", sizeInfo[0])
		}
		o.Birth = make([]*dltw.DomainRelativeObjectID, sizeInfo[0])
		for i1 := range o.Birth {
			i1 := i1
			if o.Birth[i1] == nil {
				o.Birth[i1] = &dltw.DomainRelativeObjectID{}
			}
			if err := o.Birth[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_adroidBirth := func(ptr interface{}) { o.Birth = *ptr.(*[]*dltw.DomainRelativeObjectID) }
	if err := w.ReadPointer(&o.Birth, _s_adroidBirth, _ptr_adroidBirth); err != nil {
		return err
	}
	if err := w.ReadData(&o.VolumesCount); err != nil {
		return err
	}
	_ptr_pVolumes := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.VolumesCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.VolumesCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Volumes", sizeInfo[0])
		}
		o.Volumes = make([]*dltw.VolumeID, sizeInfo[0])
		for i1 := range o.Volumes {
			i1 := i1
			if o.Volumes[i1] == nil {
				o.Volumes[i1] = &dltw.VolumeID{}
			}
			if err := o.Volumes[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_pVolumes := func(ptr interface{}) { o.Volumes = *ptr.(*[]*dltw.VolumeID) }
	if err := w.ReadPointer(&o.Volumes, _s_pVolumes, _ptr_pVolumes); err != nil {
		return err
	}
	return nil
}

// SyncType type represents TRKSVR_SYNC_TYPE RPC enumeration.
//
// The TRKSVR_SYNC_TYPE enumeration specifies operations that can be handled during
// volume synchronization in a SYNC_VOLUMES message (see sections 2.2.11 and 2.2.12.3).
type SyncType uint32

var (
	// CREATE_VOLUME:  Requests that the server maintain a mapping from a VolumeID to a
	// VolumeSecret and MachineID. See section 3.2.5.3 for an example of this subrequest.
	SyncTypeCreateVolume SyncType = 0
	// QUERY_VOLUME:  Requests information about a VolumeID so that the client and server
	// can keep their volume tables synchronized. See section 3.2.6.4 for an example of
	// this subrequest.
	SyncTypeQueryVolume SyncType = 1
	// CLAIM_VOLUME:  Requests that a MachineID become recognized by the server as the
	// VolumeOwner for a VolumeID. See section 3.2.5.3 for an example of this subrequest.
	SyncTypeClaimVolume SyncType = 2
	// FIND_VOLUME:  Requests the MachineID for a VolumeID. See section 3.2.6.4 for an
	// example of this subrequest.
	SyncTypeFindVolume SyncType = 3
	// TEST_VOLUME:  Reserved; MUST NOT be sent. Unused.
	SyncTypeTestVolume SyncType = 4
	// DELETE_VOLUME:  Reserved; MUST NOT be sent. Unused.
	SyncTypeDeleteVolume SyncType = 5
)

func (o SyncType) String() string {
	switch o {
	case SyncTypeCreateVolume:
		return "SyncTypeCreateVolume"
	case SyncTypeQueryVolume:
		return "SyncTypeQueryVolume"
	case SyncTypeClaimVolume:
		return "SyncTypeClaimVolume"
	case SyncTypeFindVolume:
		return "SyncTypeFindVolume"
	case SyncTypeTestVolume:
		return "SyncTypeTestVolume"
	case SyncTypeDeleteVolume:
		return "SyncTypeDeleteVolume"
	}
	return "Invalid"
}

// SyncVolume structure represents TRKSVR_SYNC_VOLUME RPC structure.
//
// The TRKSVR_SYNC_VOLUME structure is used as an array in calls to the LnkSvrMessage
// method that specifies a SYNC_VOLUMES message (see section 2.2.11), which in turn
// synchronizes volume information between the client and the server. Each TRKSVR_SYNC_VOLUME
// structure is termed a subrequest in this protocol specification.
type SyncVolume struct {
	// hr:  A return value that indicates the success or failure of this TRKSVR_SYNC_VOLUME
	// subrequest. The type of this field is an HRESULT, but unlike the standard definition,
	// for this field, only zero is a successful return value. Except where otherwise specified,
	// this value MUST NOT be TRK_E_VOLUME_QUOTA_EXCEEDED, which is defined in section 3.1.4.1.
	// Any other nonzero value MUST be treated identically as a failure value.
	HResult int32 `idl:"name:hr" json:"hresult"`
	// SyncType:  This indicates the type of synchronization request. Valid values are specified
	// in section 2.2.13.
	SyncType SyncType `idl:"name:SyncType" json:"sync_type"`
	// volume:  The VolumeID to be synchronized. Whether this field is used depends on the
	// SyncType value. For details, see sections 3.2.6.5 and 3.1.4.4. The CVolumeId type
	// is as specified in [MS-DLTW] section 2.2.4.
	Volume *dltw.VolumeID `idl:"name:volume" json:"volume"`
	// secret:  The new VolumeSecret to be used for this VolumeID. Whether this field is
	// used depends on the SyncType value. For details, see sections 3.2.6.5 and 3.1.4.4.
	Secret *VolumeSecret `idl:"name:secret" json:"secret"`
	// secretOld:  A VolumeSecret that is used to authenticate a VolumeOwner. Whether this
	// field is used depends on the SyncType value. For details, see sections 3.2.6.5 and
	// 3.1.4.4.
	SecretOld *VolumeSecret `idl:"name:secretOld" json:"secret_old"`
	// seq:  A VolumeSequenceNumber that is used for synchronization of move notifications,
	// as specified in section 3.1.4.2. Whether this field is used depends on the SyncType
	// value. For details, see sections 3.2.6.5 and 3.1.4.4.
	Seq int32 `idl:"name:seq" json:"seq"`
	// ftLastRefresh:  The last time the server received a REFRESH notification from a client.
	// Whether this field is used depends on the SyncType value. For details, see sections
	// 3.2.6.5 and 3.1.4.4.
	LastRefresh *dtyp.Filetime `idl:"name:ftLastRefresh" json:"last_refresh"`
	// machine:  A MachineID of a VolumeOwner. This VolumeOwner is the VolumeOwner for the
	// VolumeID specified in the volume field. Whether this field is used depends on the
	// SyncType value. For details, see sections 3.2.6.5 and 3.1.4.4; the CMachineId type
	// is as specified in [MS-DLTW] section 2.2.2.
	Machine *dltw.MachineID `idl:"name:machine" json:"machine"`
}

func (o *SyncVolume) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *SyncVolume) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.HResult); err != nil {
		return err
	}
	if err := w.WriteEnum(uint32(o.SyncType)); err != nil {
		return err
	}
	if o.Volume != nil {
		if err := o.Volume.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dltw.VolumeID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.Secret != nil {
		if err := o.Secret.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&VolumeSecret{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.SecretOld != nil {
		if err := o.SecretOld.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&VolumeSecret{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Seq); err != nil {
		return err
	}
	if o.LastRefresh != nil {
		if err := o.LastRefresh.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.Filetime{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.Machine != nil {
		if err := o.Machine.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dltw.MachineID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *SyncVolume) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.HResult); err != nil {
		return err
	}
	if err := w.ReadEnum((*uint32)(&o.SyncType)); err != nil {
		return err
	}
	if o.Volume == nil {
		o.Volume = &dltw.VolumeID{}
	}
	if err := o.Volume.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.Secret == nil {
		o.Secret = &VolumeSecret{}
	}
	if err := o.Secret.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.SecretOld == nil {
		o.SecretOld = &VolumeSecret{}
	}
	if err := o.SecretOld.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.Seq); err != nil {
		return err
	}
	if o.LastRefresh == nil {
		o.LastRefresh = &dtyp.Filetime{}
	}
	if err := o.LastRefresh.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.Machine == nil {
		o.Machine = &dltw.MachineID{}
	}
	if err := o.Machine.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// CallSyncVolumes structure represents TRKSVR_CALL_SYNC_VOLUMES RPC structure.
//
// The TRKSVR_CALL_SYNC_VOLUMES structure is used in LnkSvrMessage method calls that
// specify a SYNC_VOLUMES message (see section 2.2.11), to synchronize volumes between
// the client and server. For example, this structure is used by the client to request
// that the server create an entry in its ServerVolumeTable.
//
// This structure holds an array of independent requests. Each of those individual requests
// is termed a subrequest in this protocol specification. See section 2.2.14 for more
// information about the individual subrequest data structures. See sections 3.2.5.3
// and 3.2.6.4 for examples of the client using this structure.
type CallSyncVolumes struct {
	// cVolumes:  On input, the number of subrequests in this message. On return, this is
	// the number of subrequests that the server processed. The details of this usage are
	// specified in sections 3.1.4.4 and 3.2.4.4.
	VolumesCount uint32 `idl:"name:cVolumes" json:"volumes_count"`
	// pVolumes:  An array of subrequests.
	Volumes []*SyncVolume `idl:"name:pVolumes;size_is:(cVolumes)" json:"volumes"`
}

func (o *CallSyncVolumes) xxx_PreparePayload(ctx context.Context) error {
	if o.Volumes != nil && o.VolumesCount == 0 {
		o.VolumesCount = uint32(len(o.Volumes))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *CallSyncVolumes) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.VolumesCount); err != nil {
		return err
	}
	if o.Volumes != nil || o.VolumesCount > 0 {
		_ptr_pVolumes := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.VolumesCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Volumes {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Volumes[i1] != nil {
					if err := o.Volumes[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&SyncVolume{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Volumes); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&SyncVolume{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Volumes, _ptr_pVolumes); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *CallSyncVolumes) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.VolumesCount); err != nil {
		return err
	}
	_ptr_pVolumes := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.VolumesCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.VolumesCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Volumes", sizeInfo[0])
		}
		o.Volumes = make([]*SyncVolume, sizeInfo[0])
		for i1 := range o.Volumes {
			i1 := i1
			if o.Volumes[i1] == nil {
				o.Volumes[i1] = &SyncVolume{}
			}
			if err := o.Volumes[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_pVolumes := func(ptr interface{}) { o.Volumes = *ptr.(*[]*SyncVolume) }
	if err := w.ReadPointer(&o.Volumes, _s_pVolumes, _ptr_pVolumes); err != nil {
		return err
	}
	return nil
}

// Statistics structure represents TRKSVR_STATISTICS RPC structure.
//
// The TRKSVR_STATISTICS structure was originally defined for use in LnkSvrMessage method
// calls that specify a STATISTICS message. The STATISTICS message type is not used
// in this protocol, but is included in this specification because it affects the size
// of the TRKSVR_MESSAGE_UNION structure as it is transmitted over the RPC Protocol.
type Statistics struct {
	SyncVolumeRequestsCount        uint32              `idl:"name:cSyncVolumeRequests" json:"sync_volume_requests_count"`
	SyncVolumeErrorsCount          uint32              `idl:"name:cSyncVolumeErrors" json:"sync_volume_errors_count"`
	SyncVolumeThreadsCount         uint32              `idl:"name:cSyncVolumeThreads" json:"sync_volume_threads_count"`
	CreateVolumeRequestsCount      uint32              `idl:"name:cCreateVolumeRequests" json:"create_volume_requests_count"`
	CreateVolumeErrorsCount        uint32              `idl:"name:cCreateVolumeErrors" json:"create_volume_errors_count"`
	ClaimVolumeRequestsCount       uint32              `idl:"name:cClaimVolumeRequests" json:"claim_volume_requests_count"`
	ClaimVolumeErrorsCount         uint32              `idl:"name:cClaimVolumeErrors" json:"claim_volume_errors_count"`
	QueryVolumeRequestsCount       uint32              `idl:"name:cQueryVolumeRequests" json:"query_volume_requests_count"`
	QueryVolumeErrorsCount         uint32              `idl:"name:cQueryVolumeErrors" json:"query_volume_errors_count"`
	FindVolumeRequestsCount        uint32              `idl:"name:cFindVolumeRequests" json:"find_volume_requests_count"`
	FindVolumeErrorsCount          uint32              `idl:"name:cFindVolumeErrors" json:"find_volume_errors_count"`
	TestVolumeRequestsCount        uint32              `idl:"name:cTestVolumeRequests" json:"test_volume_requests_count"`
	TestVolumeErrorsCount          uint32              `idl:"name:cTestVolumeErrors" json:"test_volume_errors_count"`
	SearchRequestsCount            uint32              `idl:"name:cSearchRequests" json:"search_requests_count"`
	SearchErrorsCount              uint32              `idl:"name:cSearchErrors" json:"search_errors_count"`
	SearchThreadsCount             uint32              `idl:"name:cSearchThreads" json:"search_threads_count"`
	MoveNotifyRequestsCount        uint32              `idl:"name:cMoveNotifyRequests" json:"move_notify_requests_count"`
	MoveNotifyErrorsCount          uint32              `idl:"name:cMoveNotifyErrors" json:"move_notify_errors_count"`
	MoveNotifyThreadsCount         uint32              `idl:"name:cMoveNotifyThreads" json:"move_notify_threads_count"`
	RefreshRequestsCount           uint32              `idl:"name:cRefreshRequests" json:"refresh_requests_count"`
	RefreshErrorsCount             uint32              `idl:"name:cRefreshErrors" json:"refresh_errors_count"`
	RefreshThreadsCount            uint32              `idl:"name:cRefreshThreads" json:"refresh_threads_count"`
	DeleteNotifyRequestsCount      uint32              `idl:"name:cDeleteNotifyRequests" json:"delete_notify_requests_count"`
	DeleteNotifyErrorsCount        uint32              `idl:"name:cDeleteNotifyErrors" json:"delete_notify_errors_count"`
	DeleteNotifyThreadsCount       uint32              `idl:"name:cDeleteNotifyThreads" json:"delete_notify_threads_count"`
	GCIterationPeriod              uint32              `idl:"name:ulGCIterationPeriod" json:"gc_iteration_period"`
	LastSuccessfulRequest          *dtyp.Filetime      `idl:"name:ftLastSuccessfulRequest" json:"last_successful_request"`
	LastError                      int32               `idl:"name:hrLastError" json:"last_error"`
	MoveLimit                      uint32              `idl:"name:dwMoveLimit" json:"move_limit"`
	RefreshCounter                 int32               `idl:"name:lRefreshCounter" json:"refresh_counter"`
	CachedVolumeTableCount         uint32              `idl:"name:dwCachedVolumeTableCount" json:"cached_volume_table_count"`
	CachedMoveTableCount           uint32              `idl:"name:dwCachedMoveTableCount" json:"cached_move_table_count"`
	CachedLastUpdated              *dtyp.Filetime      `idl:"name:ftCachedLastUpdated" json:"cached_last_updated"`
	IsDesignatedDC                 int32               `idl:"name:fIsDesignatedDc" json:"is_designated_dc"`
	NextGC                         *dtyp.Filetime      `idl:"name:ftNextGC" json:"next_gc"`
	ServiceStart                   *dtyp.Filetime      `idl:"name:ftServiceStart" json:"service_start"`
	MaxRPCThreadsCount             uint32              `idl:"name:cMaxRPCThreads" json:"max_rpc_threads_count"`
	AvailableRPCThreadsCount       uint32              `idl:"name:cAvailableRPCThreads" json:"available_rpc_threads_count"`
	LowestAvailableRPCThreadsCount uint32              `idl:"name:cLowestAvailableRPCThreads" json:"lowest_available_rpc_threads_count"`
	ThreadPoolThreadsCount         uint32              `idl:"name:cNumThreadPoolThreads" json:"thread_pool_threads_count"`
	MostThreadPoolThreadsCount     uint32              `idl:"name:cMostThreadPoolThreads" json:"most_thread_pool_threads_count"`
	EntriesToGCCount               int16               `idl:"name:cEntriesToGC" json:"entries_to_gc_count"`
	EntriesGCedCount               int16               `idl:"name:cEntriesGCed" json:"entries_g_ced_count"`
	MaxDSWriteEventsCount          int16               `idl:"name:cMaxDsWriteEvents" json:"max_ds_write_events_count"`
	CurrentFailedWritesCount       int16               `idl:"name:cCurrentFailedWrites" json:"current_failed_writes_count"`
	Version                        *Statistics_Version `idl:"name:Version" json:"version"`
}

func (o *Statistics) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *Statistics) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.SyncVolumeRequestsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.SyncVolumeErrorsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.SyncVolumeThreadsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.CreateVolumeRequestsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.CreateVolumeErrorsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.ClaimVolumeRequestsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.ClaimVolumeErrorsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.QueryVolumeRequestsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.QueryVolumeErrorsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.FindVolumeRequestsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.FindVolumeErrorsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.TestVolumeRequestsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.TestVolumeErrorsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.SearchRequestsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.SearchErrorsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.SearchThreadsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.MoveNotifyRequestsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.MoveNotifyErrorsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.MoveNotifyThreadsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.RefreshRequestsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.RefreshErrorsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.RefreshThreadsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.DeleteNotifyRequestsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.DeleteNotifyErrorsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.DeleteNotifyThreadsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.GCIterationPeriod); err != nil {
		return err
	}
	if o.LastSuccessfulRequest != nil {
		if err := o.LastSuccessfulRequest.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.Filetime{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.LastError); err != nil {
		return err
	}
	if err := w.WriteData(o.MoveLimit); err != nil {
		return err
	}
	if err := w.WriteData(o.RefreshCounter); err != nil {
		return err
	}
	if err := w.WriteData(o.CachedVolumeTableCount); err != nil {
		return err
	}
	if err := w.WriteData(o.CachedMoveTableCount); err != nil {
		return err
	}
	if o.CachedLastUpdated != nil {
		if err := o.CachedLastUpdated.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.Filetime{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.IsDesignatedDC); err != nil {
		return err
	}
	if o.NextGC != nil {
		if err := o.NextGC.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.Filetime{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.ServiceStart != nil {
		if err := o.ServiceStart.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.Filetime{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.MaxRPCThreadsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.AvailableRPCThreadsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.LowestAvailableRPCThreadsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.ThreadPoolThreadsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.MostThreadPoolThreadsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.EntriesToGCCount); err != nil {
		return err
	}
	if err := w.WriteData(o.EntriesGCedCount); err != nil {
		return err
	}
	if err := w.WriteData(o.MaxDSWriteEventsCount); err != nil {
		return err
	}
	if err := w.WriteData(o.CurrentFailedWritesCount); err != nil {
		return err
	}
	if o.Version != nil {
		if err := o.Version.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&Statistics_Version{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *Statistics) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.SyncVolumeRequestsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.SyncVolumeErrorsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.SyncVolumeThreadsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.CreateVolumeRequestsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.CreateVolumeErrorsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.ClaimVolumeRequestsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.ClaimVolumeErrorsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.QueryVolumeRequestsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.QueryVolumeErrorsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.FindVolumeRequestsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.FindVolumeErrorsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.TestVolumeRequestsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.TestVolumeErrorsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.SearchRequestsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.SearchErrorsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.SearchThreadsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.MoveNotifyRequestsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.MoveNotifyErrorsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.MoveNotifyThreadsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.RefreshRequestsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.RefreshErrorsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.RefreshThreadsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.DeleteNotifyRequestsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.DeleteNotifyErrorsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.DeleteNotifyThreadsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.GCIterationPeriod); err != nil {
		return err
	}
	if o.LastSuccessfulRequest == nil {
		o.LastSuccessfulRequest = &dtyp.Filetime{}
	}
	if err := o.LastSuccessfulRequest.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.LastError); err != nil {
		return err
	}
	if err := w.ReadData(&o.MoveLimit); err != nil {
		return err
	}
	if err := w.ReadData(&o.RefreshCounter); err != nil {
		return err
	}
	if err := w.ReadData(&o.CachedVolumeTableCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.CachedMoveTableCount); err != nil {
		return err
	}
	if o.CachedLastUpdated == nil {
		o.CachedLastUpdated = &dtyp.Filetime{}
	}
	if err := o.CachedLastUpdated.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.IsDesignatedDC); err != nil {
		return err
	}
	if o.NextGC == nil {
		o.NextGC = &dtyp.Filetime{}
	}
	if err := o.NextGC.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.ServiceStart == nil {
		o.ServiceStart = &dtyp.Filetime{}
	}
	if err := o.ServiceStart.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxRPCThreadsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.AvailableRPCThreadsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.LowestAvailableRPCThreadsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.ThreadPoolThreadsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.MostThreadPoolThreadsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntriesToGCCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntriesGCedCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaxDSWriteEventsCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.CurrentFailedWritesCount); err != nil {
		return err
	}
	if o.Version == nil {
		o.Version = &Statistics_Version{}
	}
	if err := o.Version.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// Statistics_Version structure represents TRKSVR_STATISTICS structure anonymous member.
//
// The TRKSVR_STATISTICS structure was originally defined for use in LnkSvrMessage method
// calls that specify a STATISTICS message. The STATISTICS message type is not used
// in this protocol, but is included in this specification because it affects the size
// of the TRKSVR_MESSAGE_UNION structure as it is transmitted over the RPC Protocol.
type Statistics_Version struct {
	Major       uint32 `idl:"name:dwMajor" json:"major"`
	Minor       uint32 `idl:"name:dwMinor" json:"minor"`
	BuildNumber uint32 `idl:"name:dwBuildNumber" json:"build_number"`
}

func (o *Statistics_Version) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *Statistics_Version) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Major); err != nil {
		return err
	}
	if err := w.WriteData(o.Minor); err != nil {
		return err
	}
	if err := w.WriteData(o.BuildNumber); err != nil {
		return err
	}
	return nil
}
func (o *Statistics_Version) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Major); err != nil {
		return err
	}
	if err := w.ReadData(&o.Minor); err != nil {
		return err
	}
	if err := w.ReadData(&o.BuildNumber); err != nil {
		return err
	}
	return nil
}

// Config structure represents TRKWKS_CONFIG RPC structure.
//
// The TRKWKS_CONFIG structure is unused but is included in this protocol because it
// affects the definition of the TRKSVR_MESSAGE_UNION, as defined in section 2.2.13.
type Config struct {
	Parameter uint32 `idl:"name:dwParameter" json:"parameter"`
	NewValue  uint32 `idl:"name:dwNewValue" json:"new_value"`
}

func (o *Config) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *Config) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Parameter); err != nil {
		return err
	}
	if err := w.WriteData(o.NewValue); err != nil {
		return err
	}
	return nil
}
func (o *Config) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Parameter); err != nil {
		return err
	}
	if err := w.ReadData(&o.NewValue); err != nil {
		return err
	}
	return nil
}

// MessageType type represents TRKSVR_MESSAGE_TYPE RPC enumeration.
//
// The TRKSVR_MESSAGE_TYPE enumeration defines the type of a message that is sent to
// the DLT Central Manager server by the LnkSvrMessage method. That is, the LnkSvrMessage
// method is defined such that the caller can send different messages in the form of
// different structures, and the TRKSVR_MESSAGE_TYPE enumeration is used in the TRKSVR_MESSAGE_UNION
// parameter of the LnkSvrMessage method to indicate which structure is being passed
// in a method call. See section 2.2.12 for information on TRKSVR_MESSAGE_UNION, and
// section 3.1.4.1 for more information on the LnkSvrMessage method.
type MessageType uint32

var (
	// old_SEARCH:  Unused.
	MessageTypeOldSearch MessageType = 0
	// MOVE_NOTIFICATION:  The message includes information about one or more files that
	// have been moved (see section 3.2.6.1). The message data in this method call is formatted
	// in the TRSVR_CALL_MOVE_NOTIFICATION structure (see section 2.2.12.1).
	MessageTypeMoveNotification MessageType = 1
	// REFRESH:  The message communicates the current status of the entries in the ClientVolumeTable,
	// so that the server can update its ServerVolumeTable (see section 3.2.5.2). The message
	// data in this method call is formatted in the TRKSVR_CALL_REFRESH structure (see section
	// 2.2.12.2).
	MessageTypeRefresh MessageType = 2
	// SYNC_VOLUMES:  The message is used to synchronize a volume (see sections 3.2.5.3,
	// 3.2.5.4, and 3.2.6.4). The message data in this method call is formatted in the TRKSVR_CALL_SYNC_VOLUMES
	// structure (see section 2.2.12.3).
	MessageTypeSyncVolumes MessageType = 3
	// DELETE_NOTIFY:  The message includes information about one or more files that have
	// been deleted (see section 3.2.5.5). The message data in this method call is formatted
	// in the TRKSVR_CALL_DELETE structure (see section 2.2.12.4).
	MessageTypeDeleteNotify MessageType = 4
	// STATISTICS:  The message is a request for usage statistics. This message type is
	// not used in this protocol, but is included in this specification because it affects
	// the size of the TRKSVR_MESSAGE_UNION structure as it is transmitted over the RPC
	// Protocol. See section 2.2.12 for more information on the TRKSVR_MESSAGE_UNION.
	MessageTypeStatistics MessageType = 5
	// SEARCH:  The message is a request for information about a moved file’s updated
	// location. (see section 3.2.6.3). The message data in this method call is formatted
	// in the TRKSVRidl_struct_page_CALL_SEARCH structure (see section 2.2.12.6).
	MessageTypeSearch MessageType = 6
	// WKS_CONFIG:  Unused.
	MessageTypeWKSConfig MessageType = 7
	// WKS_VOLUME_REFRESH:  Unused.
	MessageTypeWKSVolumeRefresh MessageType = 8
)

func (o MessageType) String() string {
	switch o {
	case MessageTypeOldSearch:
		return "MessageTypeOldSearch"
	case MessageTypeMoveNotification:
		return "MessageTypeMoveNotification"
	case MessageTypeRefresh:
		return "MessageTypeRefresh"
	case MessageTypeSyncVolumes:
		return "MessageTypeSyncVolumes"
	case MessageTypeDeleteNotify:
		return "MessageTypeDeleteNotify"
	case MessageTypeStatistics:
		return "MessageTypeStatistics"
	case MessageTypeSearch:
		return "MessageTypeSearch"
	case MessageTypeWKSConfig:
		return "MessageTypeWKSConfig"
	case MessageTypeWKSVolumeRefresh:
		return "MessageTypeWKSVolumeRefresh"
	}
	return "Invalid"
}

// MessagePriority type represents TRKSVR_MESSAGE_PRIORITY RPC enumeration.
//
// The TRKSVR_MESSAGE_PRIORITY enumeration contains constants that indicate the priority
// level of messages that can be sent by the LnkSvrMessage method. It is used in the
// TRKSVR_MESSAGE_UNION structure. See section 3.1.4.1 for more information on the LnkSvrMessage
// method.
type MessagePriority uint32

var (
	// PRI_0:  Priority 0, the highest priority.
	MessagePriorityP0 MessagePriority = 0
	// PRI_1:  Priority 1.
	MessagePriorityP1 MessagePriority = 1
	// PRI_2:  Priority 2.
	MessagePriorityP2 MessagePriority = 2
	// PRI_3:  Priority 3.
	MessagePriorityP3 MessagePriority = 3
	// PRI_4:  Priority 4.
	MessagePriorityP4 MessagePriority = 4
	// PRI_5:  Priority 5.
	MessagePriorityP5 MessagePriority = 5
	// PRI_6:  Priority 6.
	MessagePriorityP6 MessagePriority = 6
	// PRI_7:  Priority 7.
	MessagePriorityP7 MessagePriority = 7
	// PRI_8:  Priority 8.
	MessagePriorityP8 MessagePriority = 8
	// PRI_9:  Priority 9, the lowest priority.
	MessagePriorityP9 MessagePriority = 9
)

func (o MessagePriority) String() string {
	switch o {
	case MessagePriorityP0:
		return "MessagePriorityP0"
	case MessagePriorityP1:
		return "MessagePriorityP1"
	case MessagePriorityP2:
		return "MessagePriorityP2"
	case MessagePriorityP3:
		return "MessagePriorityP3"
	case MessagePriorityP4:
		return "MessagePriorityP4"
	case MessagePriorityP5:
		return "MessagePriorityP5"
	case MessagePriorityP6:
		return "MessagePriorityP6"
	case MessagePriorityP7:
		return "MessagePriorityP7"
	case MessagePriorityP8:
		return "MessagePriorityP8"
	case MessagePriorityP9:
		return "MessagePriorityP9"
	}
	return "Invalid"
}

// MessageUnion structure represents TRKSVR_MESSAGE_UNION RPC structure.
//
// The TRKSVR_MESSAGE_UNION structure is used in LnkSvrMessage method calls to request
// services. A single LnkSvrMessage method call can contain one type of message request,
// and the type-dependent data for a message request is stored in the TRKSVR_MESSAGE_UNION
// structure. The type of the message is indicated in the MessageType field, and the
// message data is stored in the MessageUnion field. The format of the MessageUnion
// field depends on the MessageType field. See section 2.2.11 for the definition of
// the TRKSVR_MESSAGE_TYPE enumeration used by the MessageType field. See section 3.1.4.1
// for more information on the LnkSvrMessage method.
type MessageUnion struct {
	// MessageType:  The type of message to be selected from the TRKSVR_MESSAGE_TYPE enumeration.
	// The value of this field indicates the format of the MessageUnion field.
	MessageType MessageType `idl:"name:MessageType" json:"message_type"`
	// Priority:  The priority level of the operation. Valid values are defined in TRKSVR_MESSAGE_PRIORITY.
	// Section 3.2.5.2 and 3.2.5.3, and subsections of section 3.2.6 specify how this field
	// is set for different events.
	//
	// (unnamed union):  The message data for this message request. The MessageType field
	// indicates which of these fields is used to format the data. (see section 2.2.11 for
	// more information on the TRKSVR_MESSAGE_TYPE enumeration used by the MessageType field).
	// The fields are defined as follows:
	Priority     MessagePriority            `idl:"name:Priority" json:"priority"`
	MessageUnion *MessageUnion_MessageUnion `idl:"name:MessageUnion;switch_is:MessageType" json:"message_union"`
	// ptszMachineID:  Unused. MUST be set to 0 and ignored on receipt.
	MachineID string `idl:"name:ptszMachineID;string" json:"machine_id"`
}

func (o *MessageUnion) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageUnion) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteEnum(uint32(o.MessageType)); err != nil {
		return err
	}
	if err := w.WriteEnum(uint32(o.Priority)); err != nil {
		return err
	}
	_swMessageUnion := uint32(o.MessageType)
	if o.MessageUnion != nil {
		if err := o.MessageUnion.MarshalUnionNDR(ctx, w, _swMessageUnion); err != nil {
			return err
		}
	} else {
		if err := (&MessageUnion_MessageUnion{}).MarshalUnionNDR(ctx, w, _swMessageUnion); err != nil {
			return err
		}
	}
	if o.MachineID != "" {
		_ptr_ptszMachineID := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.MachineID); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.MachineID, _ptr_ptszMachineID); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageUnion) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadEnum((*uint32)(&o.MessageType)); err != nil {
		return err
	}
	if err := w.ReadEnum((*uint32)(&o.Priority)); err != nil {
		return err
	}
	if o.MessageUnion == nil {
		o.MessageUnion = &MessageUnion_MessageUnion{}
	}
	_swMessageUnion := uint32(o.MessageType)
	if err := o.MessageUnion.UnmarshalUnionNDR(ctx, w, _swMessageUnion); err != nil {
		return err
	}
	_ptr_ptszMachineID := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.MachineID); err != nil {
			return err
		}
		return nil
	})
	_s_ptszMachineID := func(ptr interface{}) { o.MachineID = *ptr.(*string) }
	if err := w.ReadPointer(&o.MachineID, _s_ptszMachineID, _ptr_ptszMachineID); err != nil {
		return err
	}
	return nil
}

// MessageUnion_MessageUnion structure represents TRKSVR_MESSAGE_UNION union anonymous member.
//
// The TRKSVR_MESSAGE_UNION structure is used in LnkSvrMessage method calls to request
// services. A single LnkSvrMessage method call can contain one type of message request,
// and the type-dependent data for a message request is stored in the TRKSVR_MESSAGE_UNION
// structure. The type of the message is indicated in the MessageType field, and the
// message data is stored in the MessageUnion field. The format of the MessageUnion
// field depends on the MessageType field. See section 2.2.11 for the definition of
// the TRKSVR_MESSAGE_TYPE enumeration used by the MessageType field. See section 3.1.4.1
// for more information on the LnkSvrMessage method.
type MessageUnion_MessageUnion struct {
	// Types that are assignable to Value
	//
	// *MessageUnion_OldSearch
	// *MessageUnion_MoveNotification
	// *MessageUnion_Refresh
	// *MessageUnion_SyncVolumes
	// *MessageUnion_Delete
	// *MessageUnion_Statistics
	// *MessageUnion_Search
	// *MessageUnion_WKSConfig
	// *MessageUnion_WKSRefresh
	Value is_MessageUnion_MessageUnion `json:"value"`
}

func (o *MessageUnion_MessageUnion) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *MessageUnion_OldSearch:
		if value != nil {
			return value.OldSearch
		}
	case *MessageUnion_MoveNotification:
		if value != nil {
			return value.MoveNotification
		}
	case *MessageUnion_Refresh:
		if value != nil {
			return value.Refresh
		}
	case *MessageUnion_SyncVolumes:
		if value != nil {
			return value.SyncVolumes
		}
	case *MessageUnion_Delete:
		if value != nil {
			return value.Delete
		}
	case *MessageUnion_Statistics:
		if value != nil {
			return value.Statistics
		}
	case *MessageUnion_Search:
		if value != nil {
			return value.Search
		}
	case *MessageUnion_WKSConfig:
		if value != nil {
			return value.WKSConfig
		}
	case *MessageUnion_WKSRefresh:
		if value != nil {
			return value.WKSRefresh
		}
	}
	return nil
}

type is_MessageUnion_MessageUnion interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_MessageUnion_MessageUnion()
}

func (o *MessageUnion_MessageUnion) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *MessageUnion_OldSearch:
		return uint32(0)
	case *MessageUnion_MoveNotification:
		return uint32(1)
	case *MessageUnion_Refresh:
		return uint32(2)
	case *MessageUnion_SyncVolumes:
		return uint32(3)
	case *MessageUnion_Delete:
		return uint32(4)
	case *MessageUnion_Statistics:
		return uint32(5)
	case *MessageUnion_Search:
		return uint32(6)
	case *MessageUnion_WKSConfig:
		return uint32(7)
	case *MessageUnion_WKSRefresh:
		return uint32(8)
	}
	return uint32(0)
}

func (o *MessageUnion_MessageUnion) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(ndr.Enum(uint32(sw))); err != nil {
		return err
	}
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(0):
		_o, _ := o.Value.(*MessageUnion_OldSearch)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageUnion_OldSearch{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(1):
		_o, _ := o.Value.(*MessageUnion_MoveNotification)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageUnion_MoveNotification{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(2):
		_o, _ := o.Value.(*MessageUnion_Refresh)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageUnion_Refresh{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(3):
		_o, _ := o.Value.(*MessageUnion_SyncVolumes)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageUnion_SyncVolumes{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(4):
		_o, _ := o.Value.(*MessageUnion_Delete)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageUnion_Delete{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(5):
		_o, _ := o.Value.(*MessageUnion_Statistics)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageUnion_Statistics{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(6):
		_o, _ := o.Value.(*MessageUnion_Search)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageUnion_Search{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(7):
		_o, _ := o.Value.(*MessageUnion_WKSConfig)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageUnion_WKSConfig{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(8):
		_o, _ := o.Value.(*MessageUnion_WKSRefresh)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&MessageUnion_WKSRefresh{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *MessageUnion_MessageUnion) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch(ndr.Enum((*uint32)(&sw))); err != nil {
		return err
	}
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(0):
		o.Value = &MessageUnion_OldSearch{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(1):
		o.Value = &MessageUnion_MoveNotification{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(2):
		o.Value = &MessageUnion_Refresh{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(3):
		o.Value = &MessageUnion_SyncVolumes{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(4):
		o.Value = &MessageUnion_Delete{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(5):
		o.Value = &MessageUnion_Statistics{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(6):
		o.Value = &MessageUnion_Search{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(7):
		o.Value = &MessageUnion_WKSConfig{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(8):
		o.Value = &MessageUnion_WKSRefresh{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// MessageUnion_OldSearch structure represents MessageUnion_MessageUnion RPC union arm.
//
// It has following labels: 0
type MessageUnion_OldSearch struct {
	// old_Search:  Unused.
	OldSearch *OldCallSearch `idl:"name:old_Search" json:"old_search"`
}

func (*MessageUnion_OldSearch) is_MessageUnion_MessageUnion() {}

func (o *MessageUnion_OldSearch) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.OldSearch != nil {
		if err := o.OldSearch.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&OldCallSearch{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageUnion_OldSearch) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.OldSearch == nil {
		o.OldSearch = &OldCallSearch{}
	}
	if err := o.OldSearch.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageUnion_MoveNotification structure represents MessageUnion_MessageUnion RPC union arm.
//
// It has following labels: 1
type MessageUnion_MoveNotification struct {
	// MoveNotification:  If MessageType is MOVE_NOTIFICATION, this field contains message
	// data for a MOVE_NOTIFICATION message, with the data formatted in the TRKSVR_CALL_MOVE_NOTIFICATION
	// structure.
	MoveNotification *CallMoveNotification `idl:"name:MoveNotification" json:"move_notification"`
}

func (*MessageUnion_MoveNotification) is_MessageUnion_MessageUnion() {}

func (o *MessageUnion_MoveNotification) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.MoveNotification != nil {
		if err := o.MoveNotification.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&CallMoveNotification{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageUnion_MoveNotification) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.MoveNotification == nil {
		o.MoveNotification = &CallMoveNotification{}
	}
	if err := o.MoveNotification.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageUnion_Refresh structure represents MessageUnion_MessageUnion RPC union arm.
//
// It has following labels: 2
type MessageUnion_Refresh struct {
	// Refresh:  If MessageType is REFRESH, this field contains message data for a REFRESH
	// message, with the data formatted in the TRKSVR_CALL_REFRESH structure.
	Refresh *CallRefresh `idl:"name:Refresh" json:"refresh"`
}

func (*MessageUnion_Refresh) is_MessageUnion_MessageUnion() {}

func (o *MessageUnion_Refresh) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Refresh != nil {
		if err := o.Refresh.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&CallRefresh{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageUnion_Refresh) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.Refresh == nil {
		o.Refresh = &CallRefresh{}
	}
	if err := o.Refresh.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageUnion_SyncVolumes structure represents MessageUnion_MessageUnion RPC union arm.
//
// It has following labels: 3
type MessageUnion_SyncVolumes struct {
	// SyncVolumes:  If MessageType is SYNC_VOLUMES, this field contains message data for
	// a SYNC_VOLUMES message, with the data formatted in the TRKSVR_CALL_SYNC_VOLUMES structure.
	SyncVolumes *CallSyncVolumes `idl:"name:SyncVolumes" json:"sync_volumes"`
}

func (*MessageUnion_SyncVolumes) is_MessageUnion_MessageUnion() {}

func (o *MessageUnion_SyncVolumes) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.SyncVolumes != nil {
		if err := o.SyncVolumes.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&CallSyncVolumes{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageUnion_SyncVolumes) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.SyncVolumes == nil {
		o.SyncVolumes = &CallSyncVolumes{}
	}
	if err := o.SyncVolumes.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageUnion_Delete structure represents MessageUnion_MessageUnion RPC union arm.
//
// It has following labels: 4
type MessageUnion_Delete struct {
	// Delete:  If MessageType is DELETE_NOTIFY, this field contains message data for a
	// DELETE_NOTIFY message, with the data formatted in the TRKSVR_CALL_DELETE structure.
	Delete *CallDelete `idl:"name:Delete" json:"delete"`
}

func (*MessageUnion_Delete) is_MessageUnion_MessageUnion() {}

func (o *MessageUnion_Delete) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Delete != nil {
		if err := o.Delete.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&CallDelete{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageUnion_Delete) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.Delete == nil {
		o.Delete = &CallDelete{}
	}
	if err := o.Delete.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageUnion_Statistics structure represents MessageUnion_MessageUnion RPC union arm.
//
// It has following labels: 5
type MessageUnion_Statistics struct {
	// Statistics:  If MessageType is STATISTICS, this field contains message data for a
	// STATISTICS message, with the data formatted in a TRKSVR_STATISTICS structure. This
	// message type is not used in this protocol, but is included in this specification
	// because it affects the size of the TRKSVR_MESSAGE_UNION structure as it is transmitted
	// over the RPC Protocol.
	Statistics *Statistics `idl:"name:Statistics" json:"statistics"`
}

func (*MessageUnion_Statistics) is_MessageUnion_MessageUnion() {}

func (o *MessageUnion_Statistics) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Statistics != nil {
		if err := o.Statistics.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&Statistics{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageUnion_Statistics) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.Statistics == nil {
		o.Statistics = &Statistics{}
	}
	if err := o.Statistics.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageUnion_Search structure represents MessageUnion_MessageUnion RPC union arm.
//
// It has following labels: 6
type MessageUnion_Search struct {
	// Search:  If MessageType is SEARCH, this field contains message data for a SEARCH
	// message, with the data formatted in a TRKSVR_CALL_SEARCH structure.
	Search *CallSearch `idl:"name:Search" json:"search"`
}

func (*MessageUnion_Search) is_MessageUnion_MessageUnion() {}

func (o *MessageUnion_Search) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Search != nil {
		if err := o.Search.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&CallSearch{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageUnion_Search) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.Search == nil {
		o.Search = &CallSearch{}
	}
	if err := o.Search.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageUnion_WKSConfig structure represents MessageUnion_MessageUnion RPC union arm.
//
// It has following labels: 7
type MessageUnion_WKSConfig struct {
	// WksConfig:  Unused.
	WKSConfig *Config `idl:"name:WksConfig" json:"wks_config"`
}

func (*MessageUnion_WKSConfig) is_MessageUnion_MessageUnion() {}

func (o *MessageUnion_WKSConfig) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.WKSConfig != nil {
		if err := o.WKSConfig.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&Config{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *MessageUnion_WKSConfig) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.WKSConfig == nil {
		o.WKSConfig = &Config{}
	}
	if err := o.WKSConfig.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// MessageUnion_WKSRefresh structure represents MessageUnion_MessageUnion RPC union arm.
//
// It has following labels: 8
type MessageUnion_WKSRefresh struct {
	// WksRefresh:  Unused.
	WKSRefresh uint32 `idl:"name:WksRefresh" json:"wks_refresh"`
}

func (*MessageUnion_WKSRefresh) is_MessageUnion_MessageUnion() {}

func (o *MessageUnion_WKSRefresh) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := w.WriteData(o.WKSRefresh); err != nil {
		return err
	}
	return nil
}
func (o *MessageUnion_WKSRefresh) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadData(&o.WKSRefresh); err != nil {
		return err
	}
	return nil
}
