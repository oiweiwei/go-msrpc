package remotefw

import (
	"context"
	"fmt"
	"strings"
	"unicode/utf16"

	dcerpc "github.com/oiweiwei/go-msrpc/dcerpc"
	errors "github.com/oiweiwei/go-msrpc/dcerpc/errors"
	uuid "github.com/oiweiwei/go-msrpc/midl/uuid"
	dcetypes "github.com/oiweiwei/go-msrpc/msrpc/dcetypes"
	dtyp "github.com/oiweiwei/go-msrpc/msrpc/dtyp"
	fasp "github.com/oiweiwei/go-msrpc/msrpc/fasp"
	ndr "github.com/oiweiwei/go-msrpc/ndr"
)

var (
	_ = context.Background
	_ = fmt.Errorf
	_ = utf16.Encode
	_ = strings.TrimPrefix
	_ = ndr.ZeroString
	_ = (*uuid.UUID)(nil)
	_ = (*dcerpc.SyntaxID)(nil)
	_ = (*errors.Error)(nil)
	_ = dcetypes.GoPackage
	_ = dtyp.GoPackage
	_ = fasp.GoPackage
)

var (
	// import guard
	GoPackage = "fasp"
)

var (
	// Syntax UUID
	RemoteFwSyntaxUUID = &uuid.UUID{TimeLow: 0x6b5bdd1e, TimeMid: 0x528c, TimeHiAndVersion: 0x422c, ClockSeqHiAndReserved: 0xaf, ClockSeqLow: 0x8c, Node: [6]uint8{0xa4, 0x7, 0x9b, 0xe4, 0xfe, 0x48}}
	// Syntax ID
	RemoteFwSyntaxV1_0 = &dcerpc.SyntaxID{IfUUID: RemoteFwSyntaxUUID, IfVersionMajor: 1, IfVersionMinor: 0}
)

// RemoteFW interface.
type RemoteFwClient interface {

	// The RRPC_FWOpenPolicyStore method requests the server to open a specified policy
	// store. The store can be opened for reading or for editing the firewall policy. The
	// method also returns a handle to the opened store with which the client can then perform
	// operations on this policy store. The server allocates a PolicyStoreConnection object
	// to track the policy store type and the binary version associated with the handle.
	//
	// Return Values: The method returns 0 if successful; if failed, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	OpenPolicyStore(context.Context, *OpenPolicyStoreRequest, ...dcerpc.CallOption) (*OpenPolicyStoreResponse, error)

	// The RRPC_FWClosePolicyStore method receives an opened store handle, closes it, and
	// deallocates the corresponding PolicyStoreConnection object.
	//
	// Return Values: The method returns 0 if successful; if failed, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	ClosePolicyStore(context.Context, *ClosePolicyStoreRequest, ...dcerpc.CallOption) (*ClosePolicyStoreResponse, error)

	// The RRPC_FWRestoreDefaults method replaces the contents of LocalStore with the contents
	// of DefaultsStore.
	//
	// Return Values: The method returns 0 if successful; if failed, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	RestoreDefaults(context.Context, *RestoreDefaultsRequest, ...dcerpc.CallOption) (*RestoreDefaultsResponse, error)

	// The RRPC_FWGetGlobalConfig method retrieves the value of a global policy configuration
	// option. The client specifies to the server from what store this value MUST be retrieved
	// and in what specific configuration option it is interested.
	//
	// Return Values: The method returns 0 if successful; if failed, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The client does not have the required credentials to call the method.            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000002 ERROR_FILE_NOT_FOUND    | The specific configuration option is not found within the policy. This means     |
	//	|                                    | that it is not configured. If the option is not configured in any other store,   |
	//	|                                    | the firewall uses a default value.                                               |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The store type specified does not support this method.                           |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000000EA ERROR_MORE_DATA         | The buffer is not big enough to hold the configuration option value.             |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect, or is required and not        |
	//	|                                    | specified. This error can be returned because: The specific configuration option |
	//	|                                    | is not meant to be available in the specified store. The specified configuration |
	//	|                                    | option is not defined. One of the required values is not specified. The buffer   |
	//	|                                    | size is not enough to hold the specific value.                                   |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	GetGlobalConfig(context.Context, *GetGlobalConfigRequest, ...dcerpc.CallOption) (*GetGlobalConfigResponse, error)

	// The RRPC_FWSetGlobalConfig method modifies the value of a global policy configuration
	// option. The client specifies to the server in what store this value MUST be written
	// and what specific configuration option it is interested in modifying.
	//
	// Return Values: The method returns 0 if successful; if failed, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The client does not have the required credentials to call the method.            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The store type specified does not support this method.                           |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect, or is required and not        |
	//	|                                    | specified. This error can be returned because: The specific configuration option |
	//	|                                    | is not meant to be available in the specified store. The specified configuration |
	//	|                                    | option is not defined. One of the required values is not specified. The buffer   |
	//	|                                    | is null but dwBufSize says otherwise. The buffer size is not enough to hold the  |
	//	|                                    | specific value.                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	//
	// This method performs a merge operation of the resultant configuration values, as
	// defined in section 3.1.3. It then determines what modifications are necessary on
	// the rule objects to make sure the policy is enforced.
	SetGlobalConfig(context.Context, *SetGlobalConfigRequest, ...dcerpc.CallOption) (*SetGlobalConfigResponse, error)

	// The RRPC_FWAddFirewallRule method requests the server to add the specified firewall
	// rule in the policy contained in the policy store that is referenced by the handle
	// specified in the hPolicyStore parameter.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000000B7 ERROR_ALREADY_EXISTS    | The specified rule has a rule ID that already exists in the specified store.     |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The specified store does not support this method; the store might be read-only.  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicyStore handle was not opened with read/write access rights. The error  |
	//	|                                    | is also returned if the client does not have the required credentials to call    |
	//	|                                    | the method.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | A parameter of this method is incorrect, or is required and not specified. This  |
	//	|                                    | error can be returned because: The pRule object did not pass the firewall rule   |
	//	|                                    | validations that are specified in the definition of the FW_RULE data type. One   |
	//	|                                    | of the required values is not specified. A policy store does not support rules   |
	//	|                                    | with profile conditions other than ALL profiles. The wszLocalApplication field   |
	//	|                                    | of the rule contains a string that was determined to be an invalid path.<33>     |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	//
	// This method adds a firewall rule to the firewall linked list of the memory representation
	// of the store being modified. It also writes through and saves the rule in disk. If
	// called on an online store, the firewall rule is also enforced.
	AddFirewallRule(context.Context, *AddFirewallRuleRequest, ...dcerpc.CallOption) (*AddFirewallRuleResponse, error)

	// The RRPC_FWSetFirewallRule method requests the server to modify the specified firewall
	// rule in the policy contained in the policy store that is referenced by the handle
	// specified in the hPolicyStore parameter.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The specified store does not support this method; the store might be read-only.  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicyStore handle was not opened with read/write access rights. The error  |
	//	|                                    | is also returned if the client does not have the required credentials to call    |
	//	|                                    | the method.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000002 ERROR_FILE_NOT_FOUND    | The specified rule that is referenced by the wszRuleID member string of the      |
	//	|                                    | FW_RULE data type is not found in the policy store.                              |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | A parameter of this method is incorrect, or is required and not specified. This  |
	//	|                                    | error can be returned because: The pRule object did not pass the firewall rule   |
	//	|                                    | validations that are specified in the definition of the FW_RULE data type. One   |
	//	|                                    | of the required values is not specified. A policy store does not support rules   |
	//	|                                    | that have profile conditions other than ALL profiles. The wszLocalApplication    |
	//	|                                    | field of the rule contains a string that was determined to be an invalid path.   |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	SetFirewallRule(context.Context, *SetFirewallRuleRequest, ...dcerpc.CallOption) (*SetFirewallRuleResponse, error)

	// The RRPC_FWDeleteFirewallRule method requests the server to delete the specified
	// firewall rule in the policy contained in the policy store referenced by the handle
	// specified in the hPolicyStore parameter.
	//
	// Return Values: The method returns 0 if successful; if failed, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following are common.
	//
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	|             RETURN              |                                                                                  |
	//	|           VALUE/CODE            |                                   DESCRIPTION                                    |
	//	|                                 |                                                                                  |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED  | The specified store does not support this method; the store might be read-only.  |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED  | The hPolicyStore handle was not opened with read/write access rights. The error  |
	//	|                                 | is also returned if the client does not have the required credentials to call    |
	//	|                                 | the method.                                                                      |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000002 ERROR_FILE_NOT_FOUND | The specified rule referenced by the wszRuleID member string of the FW_RULE data |
	//	|                                 | type is not found in the policy store.                                           |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	//
	// This method deletes a firewall rule already stored in the firewall linked list of
	// the memory representation of the store being modified. It uses this list to determine
	// if the rule exists or not. It also writes through and deletes the rule from disk.
	// If called on an online store, the removal of the firewall rule is also enforced.
	DeleteFirewallRule(context.Context, *DeleteFirewallRuleRequest, ...dcerpc.CallOption) (*DeleteFirewallRuleResponse, error)

	// The RRPC_FWDeleteAllFirewallRules method deletes all firewall rules in the firewall
	// linked list of the memory representation of the store being modified. It also writes
	// through and deletes all rules from the disk representation. If called on an online
	// store, no firewall rules are enforced after the method returns.
	//
	// Return Values: The method returns 0 if successful; if failed, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following are common.
	//
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	|             RETURN             |                                                                                  |
	//	|           VALUE/CODE           |                                   DESCRIPTION                                    |
	//	|                                |                                                                                  |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED | The specified store does not support this method; the store might be read-only.  |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED | The hPolicyStore handle was not opened with read/write access rights. The error  |
	//	|                                | is also returned if the client does not have the required credentials to call    |
	//	|                                | the method.                                                                      |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	DeleteAllFirewallRules(context.Context, *DeleteAllFirewallRulesRequest, ...dcerpc.CallOption) (*DeleteAllFirewallRulesResponse, error)

	// The RRPC_FWEnumFirewallRules method requests the server to return all the firewall
	// rules contained in the store that is referenced by the hPolicyStore handle. The method
	// returns a linked list of all the firewall rule objects.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicyStore handle was not opened with read/write access rights. The error  |
	//	|                                    | is also returned if the client does not have the required credentials to call    |
	//	|                                    | the method.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | The dwProfileFilter parameter contains profiles that are not valid.              |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	EnumFirewallRules(context.Context, *EnumFirewallRulesRequest, ...dcerpc.CallOption) (*EnumFirewallRulesResponse, error)

	// The RRPC_FWGetConfig method retrieves the value of a profile configuration option.
	// The client specifies to the server from what store and profile this value MUST be
	// retrieved and in what specific configuration option it is interested.
	//
	// Return Values: The method returns 0 if successful; if failed, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The client does not have the required credentials to call the method.            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000002 ERROR_FILE_NOT_FOUND    | The specific configuration option is not found within the policy. This means     |
	//	|                                    | that it is not configured. If the option is not configured in any other store,   |
	//	|                                    | the firewall uses a default value.                                               |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The method does not support the specified combination of parameters. This        |
	//	|                                    | can be because: The store type specified does not support this method. The       |
	//	|                                    | configuration option is not supported in this store. The Profile parameter       |
	//	|                                    | contains a combination of profiles (instead of a single profile) or an unknown   |
	//	|                                    | profile.                                                                         |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000000EA ERROR_MORE_DATA         | The buffer is not big enough to hold the configuration option value.             |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect, or is required and not        |
	//	|                                    | specified. This error can be returned because: The specified configuration       |
	//	|                                    | option is not defined. One of the required values is not specified.              |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	GetConfig(context.Context, *GetConfigRequest, ...dcerpc.CallOption) (*GetConfigResponse, error)

	// The RRPC_FWSetConfig method modifies the value of a profile configuration option.
	// The client specifies to the server in what store and profile this value MUST be written
	// and what specific configuration option it is interested in modifying.
	//
	// Return Values: The method returns 0 if successful; if failed, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The method does not support the specified combination of parameters. This can    |
	//	|                                    | be because: The store type specified does not support this method. The Profile   |
	//	|                                    | parameter contains a combination of profiles (instead of a single profile) or an |
	//	|                                    | unknown profile.                                                                 |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicyStore handle was not opened with read/write access rights. The error  |
	//	|                                    | is also returned if the client does not have the required credentials to call    |
	//	|                                    | the method.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect, or is required and not        |
	//	|                                    | specified. This error can be returned because: The specific configuration        |
	//	|                                    | option is not meant to be available in the specified store. The specified        |
	//	|                                    | configuration option is not defined. The size of the buffer does not match the   |
	//	|                                    | size of the type of the configuration value. The buffer is null but dwBufSize    |
	//	|                                    | says otherwise. The caller wants to set a FW_PROFILE_CONFIG_LOG_MAX_FILE_SIZE    |
	//	|                                    | that is not within the valid values [min, max]. The default action               |
	//	|                                    | configuration value specifies a value that maps to neither allow nor block.      |
	//	|                                    | The FW_PROFILE_CONFIG_LOG_FILE_PATH configuration value contains the following   |
	//	|                                    | invalid characters: /,*,?,",<,>,|.                                               |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	//
	// This method performs a merge operation of the resultant configuration values, as
	// defined in section 3.1.3. It then determines what modifications are necessary on
	// the rule objects (for example, remove rule enforcement if firewall is off) to make
	// sure the policy is enforced.
	SetConfig(context.Context, *SetConfigRequest, ...dcerpc.CallOption) (*SetConfigResponse, error)

	// The RRPC_FWAddConnectionSecurityRule method requests the server to add the connection
	// security rule in the policy contained in the policy store that is referenced by the
	// specified opened policy store handle.
	//
	// Return Values: This method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000000B7 ERROR_ALREADY_EXISTS    | The specified rule has a rule ID that already exists in the specified store.     |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The specified store does not support this method; the store might be read-only.  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicy handle was not opened with read/write access rights. The error is    |
	//	|                                    | also returned if the client does not have the required credentials to call the   |
	//	|                                    | method.                                                                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | A parameter of this method is incorrect, or is required and not specified.       |
	//	|                                    | This error can be returned because: The pRule object did not pass the            |
	//	|                                    | connection security rule validations specified in the definition of the          |
	//	|                                    | FW_CS_RULE data type. The rule has a phase 2 crypto set that specified           |
	//	|                                    | FW_CRYPTO_PRPTOCOL_AUTH_NO_ENCAP (see section 2.2.69), and it is a tunnel mode   |
	//	|                                    | rule, or it also has an AuthSet structure (section 2.2.65) that specifies a      |
	//	|                                    | preshared key auth method. A required value is not specified.                    |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	//
	// This method adds a connection security rule in the connection security link list
	// of the memory representation of the store being modified. It also writes through
	// and saves the rule to disk. If called on an online store, the connection security
	// rule is also enforced.
	AddConnectionSecurityRule(context.Context, *AddConnectionSecurityRuleRequest, ...dcerpc.CallOption) (*AddConnectionSecurityRuleResponse, error)

	// The RRPC_FWSetConnectionSecurityRule method requests the server to modify the specified
	// connection security rule in the policy contained in the policy store that is referenced
	// by the handle specified in the hPolicy parameter.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The specified store does not support this method; the store might be read-only.  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicy handle was not opened with read/write access rights. This error is   |
	//	|                                    | also returned if the client does not have the required credentials to call the   |
	//	|                                    | method.                                                                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000002 ERROR_FILE_NOT_FOUND    | The specified rule that is referenced by the wszRuleID member string of the      |
	//	|                                    | FW_CS_RULE data type is not found in the policy store.                           |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | A parameter of this method is incorrect, or is required and not specified.       |
	//	|                                    | This error can be returned because: The pRule object did not pass the            |
	//	|                                    | connection security rule validations that are specified in the definition of     |
	//	|                                    | the FW_CS_RULE data type. The rule has a phase 2 crypto set that specified       |
	//	|                                    | FW_CRYPTO_PRPTOCOL_AUTH_NO_ENCAP (see section 2.2.69), and either it is a tunnel |
	//	|                                    | mode rule or it has an AuthSet that specifies a preshared key auth method. A     |
	//	|                                    | required value is not specified.                                                 |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	//
	// This method modifies a connection security rule already stored in the connection
	// security linked list of the memory representation of the store being modified. It
	// uses this list to determine whether the rule exists. It also writes through and saves
	// the rule in disk. If called on an online store, the connection security rule modifications
	// are also enforced.
	SetConnectionSecurityRule(context.Context, *SetConnectionSecurityRuleRequest, ...dcerpc.CallOption) (*SetConnectionSecurityRuleResponse, error)

	// The RRPC_FWDeleteConnectionSecurityRule method requests the server to delete the
	// specified connection security rule in the policy contained in the policy store referenced
	// by the handle specified in the hPolicy parameter.
	//
	// Return Values: The method returns 0 if successful; if failed, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	|             RETURN              |                                                                                  |
	//	|           VALUE/CODE            |                                   DESCRIPTION                                    |
	//	|                                 |                                                                                  |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED  | The specified store does not support this method; the store might be read-only.  |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED  | The hPolicy handle was not opened with read/write access rights. The error is    |
	//	|                                 | also returned if the client does not have the required credentials to call the   |
	//	|                                 | method.                                                                          |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000002 ERROR_FILE_NOT_FOUND | The specified rule referenced by the pRuleId member string is not found in the   |
	//	|                                 | policy store.                                                                    |
	//	+---------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	//
	// This method deletes a connection security rule already stored in the connection security
	// linked list of the memory representation of the store being modified. It uses this
	// list to determine if the rule exists or not. It also writes through and deletes the
	// rule from disk. If called on an online store, the removal of the connection security
	// rule is also enforced.
	DeleteConnectionSecurityRule(context.Context, *DeleteConnectionSecurityRuleRequest, ...dcerpc.CallOption) (*DeleteConnectionSecurityRuleResponse, error)

	// The RRPC_FWDeleteAllConnectionSecurityRules method requests the server to delete
	// all the connection security rules in the policy contained in the policy store referenced
	// by the handle specified in the hPolicy parameter.
	//
	// Return Values: The method returns 0 if successful; if failed, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	|             RETURN             |                                                                                  |
	//	|           VALUE/CODE           |                                   DESCRIPTION                                    |
	//	|                                |                                                                                  |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED | The specified store does not support this method; the store might be read-only.  |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED | The hPolicy handle was not opened with read/write access rights. The error is    |
	//	|                                | also returned if the client does not have the required credentials to call the   |
	//	|                                | method.                                                                          |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	//
	// This method deletes all connection security rules in the connection security linked
	// list of the memory representation of the store being modified. It also writes through
	// and deletes all rules from the disk representation. If called on an online store,
	// no connection security rules are enforced after the method returns.
	DeleteAllConnectionSecurityRules(context.Context, *DeleteAllConnectionSecurityRulesRequest, ...dcerpc.CallOption) (*DeleteAllConnectionSecurityRulesResponse, error)

	// The RRPC_FWEnumConnectionSecurityRules method requests the server to return all the
	// connection security rules contained in the store that is referenced by the hPolicy
	// handle. The method returns a linked list of all the connection security rule objects.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	|               RETURN               |                                                                       |
	//	|             VALUE/CODE             |                              DESCRIPTION                              |
	//	|                                    |                                                                       |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The client does not have the required credentials to call the method. |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | The dwProfileFilter parameter contains invalid profiles.              |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	EnumConnectionSecurityRules(context.Context, *EnumConnectionSecurityRulesRequest, ...dcerpc.CallOption) (*EnumConnectionSecurityRulesResponse, error)

	// The RRPC_FWAddAuthenticationSet method requests the server to add the authentication
	// set in the policy contained in the policy store referenced by the handle specified
	// in the hPolicy parameter.
	//
	// Return Values: The method returns 0 if successful; if failed, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000000B7 ERROR_ALREADY_EXISTS    | The specified set has a set ID that already exists in the specified store.       |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The specified store does not support this method; the store might be read-only.  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicy handle was not opened with read/write access rights. The error is    |
	//	|                                    | also returned if the client does not have the required credentials to call the   |
	//	|                                    | method.                                                                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect, or is required and not        |
	//	|                                    | specified. This error can be returned because: The pAuth object did not pass the |
	//	|                                    | authentication set validations specified in the definition of the FW_AUTH_SET    |
	//	|                                    | data type. One of the required values is not specified.                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	//
	// This method adds an authentication set in the authentication linked list of the memory
	// representation of the store being modified. It also writes through and saves the
	// set in disk. If called on an online store and the set is a primary set, the method
	// enumerates the connection security rule list and reapplies each rule referencing
	// this primary set to complete the enforcement of the policy.
	AddAuthenticationSet(context.Context, *AddAuthenticationSetRequest, ...dcerpc.CallOption) (*AddAuthenticationSetResponse, error)

	// The RRPC_FWSetAuthenticationSet method requests the server to modify the specified
	// authentication set in the policy contained in the policy store referenced by the
	// handle specified in the hPolicy parameter.
	//
	// Return Values: The method returns 0 if successful; if failed, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The specified store does not support this method; the store might be read-only.  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicy handle was not opened with read/write access rights. The error is    |
	//	|                                    | also returned if the client does not have the required credentials to call the   |
	//	|                                    | method.                                                                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000002 ERROR_FILE_NOT_FOUND    | The specified set referenced by the wszSetId member string of the FW_AUTH_SET    |
	//	|                                    | data type is not found in the policy store.                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect, or is required and not        |
	//	|                                    | specified. This error can be returned because: The pAuth object did not pass the |
	//	|                                    | authentication set validations specified in the definition of the FW_AUTH_SET    |
	//	|                                    | data type. One of the required values is not specified.                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	//
	// This method modifies an authentication set in the authentication linked list of the
	// memory representation of the store being modified. It also writes through and saves
	// the set in disk. If called on an online store, the method enumerates the connection
	// security rules list and reapplies each rule referencing this primary set to complete
	// the enforcement of the policy.
	SetAuthenticationSet(context.Context, *SetAuthenticationSetRequest, ...dcerpc.CallOption) (*SetAuthenticationSetResponse, error)

	// The RRPC_FWDeleteAuthenticationSet method requests the server to delete the specified
	// authentication set in the policy contained in the policy store referenced by the
	// handle specified in the hPolicy parameter.
	//
	// Return Values: The method returns 0 if successful; if failed, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN                |                                                                                  |
	//	|             VALUE/CODE              |                                   DESCRIPTION                                    |
	//	|                                     |                                                                                  |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000962 ERROR_ACTIVE_CONNECTIONS | The specified set is still referenced by connection security rules. This failure |
	//	|                                     | happens only when the set is not a primary set. There is always a primary set to |
	//	|                                     | use, either from other stores or a hard-coded one.                               |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED      | The specified store does not support this method; the store might be read-only.  |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED      | The hPolicy handle was not opened with read/write access rights. The error is    |
	//	|                                     | also returned if the client does not have the required credentials to call the   |
	//	|                                     | method.                                                                          |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000002 ERROR_FILE_NOT_FOUND     | The specified rule referenced by the wszSetId string is not found in the policy  |
	//	|                                     | store.                                                                           |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER  | The specified IPsec phase is not a valid one.                                    |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	//
	// This method deletes an authentication set in the authentication linked list of the
	// memory representation of the store being modified. It also writes through and saves
	// the set in disk. If called on an online store, and the set is not a primary set,
	// the method does not delete the specified set if any connection rule references this
	// set.
	DeleteAuthenticationSet(context.Context, *DeleteAuthenticationSetRequest, ...dcerpc.CallOption) (*DeleteAuthenticationSetResponse, error)

	// The RRPC_FWDeleteAllAuthenticationSets method requests the server to delete all the
	// authentication sets of a specific IPsec phase in the policy contained in the policy
	// store referenced by the handle specified in the hPolicy parameter.
	//
	// Return Values: The method returns 0 if successful; if failed, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN                |                                                                                  |
	//	|             VALUE/CODE              |                                   DESCRIPTION                                    |
	//	|                                     |                                                                                  |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000962 ERROR_ACTIVE_CONNECTIONS | The specified set is still referenced by connection security rules. This failure |
	//	|                                     | happens only when the set is not a primary set. There is always a primary set to |
	//	|                                     | use, either from other stores or a hard-coded one.                               |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED      | The specified store does not support this method; the store might be read-only.  |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED      | The hPolicy handle was not opened with read/write access rights. The error is    |
	//	|                                     | also returned if the client does not have the required credentials to call the   |
	//	|                                     | method.                                                                          |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000002 ERROR_FILE_NOT_FOUND     | The specified rule referenced by the wszSetId string is not found in the policy  |
	//	|                                     | store.                                                                           |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER  | The specified IPsec phase is not a valid one.                                    |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	//
	// This method deletes all the authentication sets in the authentication linked list
	// of the memory representation of the store being modified. It also writes through
	// and deletes the sets from disk. If called on an online store, the method does not
	// delete the sets if any nonprimary set is referenced by a connection security rule.
	DeleteAllAuthenticationSets(context.Context, *DeleteAllAuthenticationSetsRequest, ...dcerpc.CallOption) (*DeleteAllAuthenticationSetsResponse, error)

	// The RRPC_FWEnumAuthenticationSets method requests the server to return all the authentication
	// sets of the specified IPsec phase contained in the store referenced by the hPolicy
	// handle. The method returns a linked list of these objects.
	//
	// Return Values: The method returns 0 if successful; if failed, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The client does not have the required credentials to call the method.            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect, or is required and not        |
	//	|                                    | specified. This error can be returned because: The IpSecPhase parameter          |
	//	|                                    | specifies an invalid IPsec negotiation phase. One of the required values is not  |
	//	|                                    | specified.                                                                       |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	EnumAuthenticationSets(context.Context, *EnumAuthenticationSetsRequest, ...dcerpc.CallOption) (*EnumAuthenticationSetsResponse, error)

	// The RRPC_FWAddCryptoSet method adds a cryptographic set in the cryptographic linked
	// list of the memory representation of the store being modified. It also writes through
	// and saves the set to the disk. If called on an online store, and the set is a primary
	// set, the method enumerates the connection security rule list and reapplies each rule
	// referencing this primary set to complete the enforcement of the policy.
	//
	// Return Values: The method returns 0 if successful; if failed, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000000B7 ERROR_ALREADY_EXISTS    | The specified rule has a rule ID that already exists in the specified store.     |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The specified store does not support this method; the store might be read-only.  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicy handle was not opened with read/write access rights. The error is    |
	//	|                                    | also returned if the client does not have the required credentials to call the   |
	//	|                                    | method.                                                                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect, or is required and not        |
	//	|                                    | specified. This error can be returned because: The pCrypto object did not        |
	//	|                                    | pass the cryptographic set validations specified in the definition of the        |
	//	|                                    | FW_CRYPTO_SET data type. One of the required values is not specified.            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	AddCryptoSet(context.Context, *AddCryptoSetRequest, ...dcerpc.CallOption) (*AddCryptoSetResponse, error)

	// The RRPC_FWSetCryptoSet method requests the server to modify the specified cryptographic
	// set in the policy contained in the policy store referenced by the handle specified
	// in the hPolicy parameter.
	//
	// Return Values: The method returns 0 if successful; if failed, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The specified store does not support this method; the store might be read-only.  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicy handle was not opened with read/write access rights. The error is    |
	//	|                                    | also returned if the client does not have the required credentials to call the   |
	//	|                                    | method.                                                                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000002 ERROR_FILE_NOT_FOUND    | The specified set referenced by the wszSetId member string of the FW_CRYPTO_SET  |
	//	|                                    | data type is not found in the policy store.                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect, or is required and not        |
	//	|                                    | specified. This error can be returned because: The pCrypto object did not        |
	//	|                                    | pass the cryptographic set validations specified in the definition of the        |
	//	|                                    | FW_CRYPTO_SET data type. One of the required values is not specified.            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	//
	// This method modifies a cryptographic set in the cryptographic linked list of the
	// memory representation of the store being modified. It also writes through and saves
	// the set to the disk. If called on an online store, the method enumerates the connection
	// security rules list and reapplies each rule referencing this primary set to complete
	// the enforcement of the policy.
	SetCryptoSet(context.Context, *SetCryptoSetRequest, ...dcerpc.CallOption) (*SetCryptoSetResponse, error)

	// The RRPC_FWDeleteCryptoSet method requests the server to delete the specified cryptographic
	// set in the policy contained in the policy store that is referenced by the handle
	// specified in the hPolicy parameter.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN                |                                                                                  |
	//	|             VALUE/CODE              |                                   DESCRIPTION                                    |
	//	|                                     |                                                                                  |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000962 ERROR_ACTIVE_CONNECTIONS | The specified set is still referenced by connection security or main mode rules. |
	//	|                                     | This failure happens only when the set is not a primary set. There is always a   |
	//	|                                     | primary set to use, either from other stores or a hard-coded one.                |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED      | The specified store does not support this method; the store might be read-only.  |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED      | The hPolicy handle was not opened with read/write access rights. The error is    |
	//	|                                     | also returned if the client does not have the required credentials to call the   |
	//	|                                     | method.                                                                          |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000002 ERROR_FILE_NOT_FOUND     | The specified rule that is referenced by the wszSetId string is not found in the |
	//	|                                     | policy store.                                                                    |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER  | The specified IPsec phase is not a valid one.                                    |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	//
	// This method deletes a cryptographic set in the cryptographic linked list of the memory
	// representation of the store being modified. It also writes through and saves the
	// set to disk. If called on an online store and the set is not a primary set, the method
	// does not delete the specified set if any connection rule references this set.
	DeleteCryptoSet(context.Context, *DeleteCryptoSetRequest, ...dcerpc.CallOption) (*DeleteCryptoSetResponse, error)

	// The RRPC_FWDeleteAllCryptoSets method requests the server to delete all the cryptographic
	// sets of a specific IPsec phase in the policy contained in the policy store that is
	// referenced by the handle specified in the hPolicy parameter.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN                |                                                                                  |
	//	|             VALUE/CODE              |                                   DESCRIPTION                                    |
	//	|                                     |                                                                                  |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000962 ERROR_ACTIVE_CONNECTIONS | There are nonprimary sets still being referenced by connection security or main  |
	//	|                                     | mode rules. There is always a primary set to use, either from other stores or a  |
	//	|                                     | hard-coded one; therefore, this failure never occurs because of primary sets.    |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED      | The specified store does not support this method; the store might be read-only.  |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED      | The hPolicy handle was not opened with read/write access rights. The error is    |
	//	|                                     | also returned if the client does not have the required credentials to call the   |
	//	|                                     | method.                                                                          |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER  | The specified IPsec phase is not a valid one.                                    |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown except those that are thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	//
	// This method deletes all the cryptographic sets in the cryptographic linked list of
	// the memory representation of the store being modified. It also writes through and
	// deletes the sets from disk. If called on an online store, the method does not delete
	// the sets if any nonprimary set is referenced by a connection security rule.
	DeleteAllCryptoSets(context.Context, *DeleteAllCryptoSetsRequest, ...dcerpc.CallOption) (*DeleteAllCryptoSetsResponse, error)

	// The RRPC_FWEnumCryptoSets method requests the server to return all the cryptographic
	// sets of the specified IPsec phase contained in the store referenced by the hPolicy
	// handle. The method returns a linked list of all these cryptographic objects.
	//
	// Return Values: The method returns 0 if successful; if failed, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The client does not have the required credentials to call the method.            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect, or is required and not        |
	//	|                                    | specified. This error can be returned because: The IpSecPhase parameter          |
	//	|                                    | specifies an invalid IPsec negotiation phase. One of the required values is not  |
	//	|                                    | specified.                                                                       |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	EnumCryptoSets(context.Context, *EnumCryptoSetsRequest, ...dcerpc.CallOption) (*EnumCryptoSetsResponse, error)

	// The RRPC_FWEnumPhase1SAs method requests the server to return all the security associations
	// of the IPsec first negotiation phase contained in the store referenced by the hPolicy
	// handle. The method returns a linked list of all these security associations.
	//
	// Return Values: The method returns 0 if successful; if failed, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The client does not have the required credentials to call the method.            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The store handle is not of the dynamic store.                                    |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect, or is required and not        |
	//	|                                    | specified.                                                                       |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	EnumPhase1SAs(context.Context, *EnumPhase1SAsRequest, ...dcerpc.CallOption) (*EnumPhase1SAsResponse, error)

	// The RRPC_FWEnumPhase2SAs method requests the server to return all the security associations
	// of the IPsec second negotiation phase contained in the store referenced by the hPolicy
	// handle. The method returns a linked list of all these security associations.
	//
	// Return Values: The method returns 0 if successful; if failed, it returns a non-zero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The client does not have the required credentials to call the method.            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The store handle is not of the dynamic store.                                    |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect, or is required and not        |
	//	|                                    | specified.                                                                       |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	EnumPhase2SAs(context.Context, *EnumPhase2SAsRequest, ...dcerpc.CallOption) (*EnumPhase2SAsResponse, error)

	// The RRPC_FWDeletePhase1SAs method requests the server to delete all the IPsec first
	// negotiation phase security associations that match the specified endpoints.
	//
	// Return Values: The method returns 0 if successful; if failed, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The client does not have the required credentials to call the method.            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The store handle is not of the dynamic store.                                    |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect or is required and not         |
	//	|                                    | specified.                                                                       |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	DeletePhase1SAs(context.Context, *DeletePhase1SAsRequest, ...dcerpc.CallOption) (*DeletePhase1SAsResponse, error)

	// The RRPC_FWDeletePhase2SAs (Opnum 30) method requests the server to delete all the
	// IPsec second-negotiation-phase security associations that match the specified endpoints.
	//
	// Return Values: The method returns 0 if successful; if failed, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The client does not have the required credentials to call the method.            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The store handle is not of the dynamic store.                                    |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect, or is required and not        |
	//	|                                    | specified.                                                                       |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	DeletePhase2SAs(context.Context, *DeletePhase2SAsRequest, ...dcerpc.CallOption) (*DeletePhase2SAsResponse, error)

	// The RRPC_FWEnumProducts (Opnum 31) method requests the server to return all the registered
	// third-party software components registered with the firewall and advanced security
	// component. The only method supported is binary version 0x020A.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The client does not have the required credentials to call the method.            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The store handle is not of the dynamic store.                                    |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method either is incorrect or is required and not  |
	//	|                                    | specified.                                                                       |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	EnumProducts(context.Context, *EnumProductsRequest, ...dcerpc.CallOption) (*EnumProductsResponse, error)

	// The RRPC_FWAddMainModeRule (Opnum 32) method requests the server to add the main
	// mode rule in the policy contained in the policy store referenced by the specified
	// opened policy store handle. The only method supported is binary version 0x020A.
	//
	// Return Values: The method returns 0 if successful; if failed, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The client does not have the required credentials to call the method.            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000000B7 ERROR_ALREADY_EXISTS    | The specified rule has a rule ID that already exists in the specified store.     |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method either is incorrect or is required and not  |
	//	|                                    | specified.                                                                       |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	AddMainModeRule(context.Context, *AddMainModeRuleRequest, ...dcerpc.CallOption) (*AddMainModeRuleResponse, error)

	// The RRPC_FWSetMainModeRule (Opnum 33) method requests the server to modify the specified
	// main mode rule in the policy contained in the policy store referenced by the handle
	// specified in the hPolicy parameter. The only method supported is binary version 0x020A.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The client does not have the required credentials to call the method.            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000002 ERROR_FILE_NOT_FOUND    | The specified set referenced by the wszRuleID member STRING of the FW_MM_RULE    |
	//	|                                    | data type is not found in the policy store.                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method either is incorrect or is required and not  |
	//	|                                    | specified.                                                                       |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	SetMainModeRule(context.Context, *SetMainModeRuleRequest, ...dcerpc.CallOption) (*SetMainModeRuleResponse, error)

	// The RRPC_FWDeleteMainModeRule (Opnum 34) method requests the server to delete the
	// specified main mode rule in the policy contained in the policy store referenced by
	// the handle specified in the hPolicy parameter. The only method supported is binary
	// version 0x020A.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The client does not have the required credentials to call the method.            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000002 ERROR_FILE_NOT_FOUND    | The specified set referenced by the wszRuleID member string of the FW_MM_RULE    |
	//	|                                    | data type is not found in the policy store.                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method either is incorrect or is required and not  |
	//	|                                    | specified.                                                                       |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	DeleteMainModeRule(context.Context, *DeleteMainModeRuleRequest, ...dcerpc.CallOption) (*DeleteMainModeRuleResponse, error)

	// The RRPC_FWDeleteAllMainModeRules (Opnum 35) method requests the server to delete
	// all the main mode rules in the policy contained in the policy store referenced by
	// the handle specified in the hPolicy parameter. The only method supported is binary
	// version 0x020A.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	|             RETURN             |                                                                                  |
	//	|           VALUE/CODE           |                                   DESCRIPTION                                    |
	//	|                                |                                                                                  |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED | The specified store does not support this method; the store might be read-only.  |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED | The hPolicy handle was not opened with read/write access rights. The error is    |
	//	|                                | also returned if the client does not have the required credentials to call the   |
	//	|                                | method.                                                                          |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	DeleteAllMainModeRules(context.Context, *DeleteAllMainModeRulesRequest, ...dcerpc.CallOption) (*DeleteAllMainModeRulesResponse, error)

	// The RRPC_FWEnumMainModeRules (Opnum 36) method requests the server to return all
	// the main mode rules contained in the store referenced by the hPolicy handle. The
	// method returns a linked list of all the main mode rule objects. The only method supported
	// is binary version 0x020A.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The client does not have the required credentials to call the method.            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters for this method is incorrect or is required but not        |
	//	|                                    | specified. This error can be returned in the following cases: - One of the       |
	//	|                                    | parameters did not meet the required constraints. - The dwProfileFilter          |
	//	|                                    | parameter contains invalid profiles.                                             |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	EnumMainModeRules(context.Context, *EnumMainModeRulesRequest, ...dcerpc.CallOption) (*EnumMainModeRulesResponse, error)

	// The RRPC_FWQueryFirewallRules (Opnum 37) method requests the server to return all
	// the firewall rules that match the specified query object that are contained in the
	// store referenced by the hPolicy handle. The method returns a linked list of all the
	// firewall rule objects. The only method supported is binary version 0x020A.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The client does not have the required credentials to call the method.            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect or is required but not         |
	//	|                                    | specified. This error can be returned in the following cases: - One of the       |
	//	|                                    | parameters did not meet the required constraints. - The pQuery parameter         |
	//	|                                    | contains invalid profiles.                                                       |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	QueryFirewallRules(context.Context, *QueryFirewallRulesRequest, ...dcerpc.CallOption) (*QueryFirewallRulesResponse, error)

	// RRPC_FWQueryConnectionSecurityRules2_10 operation.
	QueryConnectionSecurityRules210(context.Context, *QueryConnectionSecurityRules210Request, ...dcerpc.CallOption) (*QueryConnectionSecurityRules210Response, error)

	// The RRPC_FWQueryMainModeRules (Opnum 39) method requests the server to return all
	// the main mode rules that match the specified query object that are contained in the
	// store referenced by the hPolicy handle. The method returns a linked list of all the
	// main mode rule objects. The only method supported is binary version 0x020A.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The client does not have the required credentials to call the method.            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect or is required but not         |
	//	|                                    | specified. This error can be returned in the following cases: - One of the       |
	//	|                                    | parameters did not meet the required constraints. - The pQuery parameter         |
	//	|                                    | contains invalid profiles.                                                       |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	QueryMainModeRules(context.Context, *QueryMainModeRulesRequest, ...dcerpc.CallOption) (*QueryMainModeRulesResponse, error)

	// The RRPC_FWQueryAuthenticationSets (Opnum 40) method requests the server to return
	// all the authentication sets that match the specified query object that are contained
	// in the store referenced by the hPolicy handle. The method returns a linked list of
	// all the authentication set objects. The only method supported is binary version 0x020A.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The client does not have the required credentials to call the method.            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect or is required but not         |
	//	|                                    | specified. This error can be returned in the following cases: - One of the       |
	//	|                                    | required values is not specified. - The dwProfileFilter parameter contains       |
	//	|                                    | invalid profiles.                                                                |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	QueryAuthenticationSets(context.Context, *QueryAuthenticationSetsRequest, ...dcerpc.CallOption) (*QueryAuthenticationSetsResponse, error)

	// The RRPC_FWQueryCryptoSets (Opnum 41) method requests the server to return all the
	// crypto sets that match the specified query object that are contained in the store
	// referenced by the hPolicy handle. The method returns a linked list of all the crypto
	// set objects. The only method supported is binary version 0x020A.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The client does not have the required credentials to call the method.            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect or is required but not         |
	//	|                                    | specified. This error can be returned in the following cases: - One of the       |
	//	|                                    | parameters did not meet the required constraints. - The pQuery parameter         |
	//	|                                    | contains invalid profiles.                                                       |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	QueryCryptoSets(context.Context, *QueryCryptoSetsRequest, ...dcerpc.CallOption) (*QueryCryptoSetsResponse, error)

	// The RRPC_FWEnumNetworks (Opnum 42) method requests the server to return all the networks
	// to which the host with the firewall and advanced security component is connected.
	// The only method supported is binary version 0x020A.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	|               RETURN               |                                                                       |
	//	|             VALUE/CODE             |                              DESCRIPTION                              |
	//	|                                    |                                                                       |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The client does not have the required credentials to call the method. |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | A parameter contains invalid profiles.                                |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	EnumNetworks(context.Context, *EnumNetworksRequest, ...dcerpc.CallOption) (*EnumNetworksResponse, error)

	// The RRPC_FWEnumAdapters (Opnum 43) method requests the server to return all the networks
	// interfaces that the host with the firewall and advanced security component has. The
	// only method supported is binary version 0x020A.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	|               RETURN               |                                                                       |
	//	|             VALUE/CODE             |                              DESCRIPTION                              |
	//	|                                    |                                                                       |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The client does not have the required credentials to call the method. |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | A parameter contains invalid profiles.                                |
	//	+------------------------------------+-----------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	EnumAdapters(context.Context, *EnumAdaptersRequest, ...dcerpc.CallOption) (*EnumAdaptersResponse, error)

	// The RRPC_FWGetGlobalConfig2_10 (Opnum 44) method retrieves the value of a global
	// policy configuration option. The client specifies to the server from which store
	// this value MUST be retrieved and in which specific configuration option it is interested.
	// The method is only supported for binary versions 0x020A and 0x0214.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The client does not have the required credentials to call the method.            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000002 ERROR_FILE_NOT_FOUND    | The specific configuration option is not found within the policy. This means     |
	//	|                                    | that it is not configured. If the option is not configured in any other store,   |
	//	|                                    | the firewall uses a default value.                                               |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The specified store type does not support this method.                           |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method either is incorrect or is required and not  |
	//	|                                    | specified. This error can be returned because: The specific configuration option |
	//	|                                    | is not meant to be available in the specified store. The specified configuration |
	//	|                                    | option is not defined. One of the required values is not specified. The buffer   |
	//	|                                    | is not big enough to hold the specific value.                                    |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	GetGlobalConfig210(context.Context, *GetGlobalConfig210Request, ...dcerpc.CallOption) (*GetGlobalConfig210Response, error)

	// The RRPC_FWGetConfig2_10 (Opnum 45) method retrieves the value of a profile configuration
	// option. The client specifies to the server from which store and profile this value
	// MUST be retrieved and in which specific configuration option it is interested. The
	// method is only supported for binary versions 0x020A and 0x0214.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The client does not have the required credentials to call the method.            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000002 ERROR_FILE_NOT_FOUND    | The specific configuration option is not found within the policy. This means     |
	//	|                                    | that it is not configured. If the option is not configured in any other store,   |
	//	|                                    | the firewall uses a default value.                                               |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The store type specified does not support this method.                           |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000000EA ERROR_MORE_DATA         | The buffer is not big enough to hold the configuration option value.             |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method either is incorrect or is required and not  |
	//	|                                    | specified. This error can be returned because: The specific configuration option |
	//	|                                    | is not meant to be available in the specified store. The specified configuration |
	//	|                                    | option is not defined. One of the required values is not specified. The buffer   |
	//	|                                    | is not big enough to hold the specific value.                                    |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	GetConfig210(context.Context, *GetConfig210Request, ...dcerpc.CallOption) (*GetConfig210Response, error)

	// The RRPC_FWAddFirewallRule2_10 (Opnum 46) method requests the server to add the specified
	// firewall rule in the policy contained in the policy store referenced by the handle
	// specified in the hPolicyStore parameter. The method is only supported for binary
	// versions 0x020A and 0x0214.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000000B7 ERROR_ALREADY_EXISTS    | The specified rule has a rule ID that already exists in the specified store.     |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The specified store does not support this method; the store might be read-only.  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicyStore handle was not opened with read/write access rights. The error  |
	//	|                                    | is also returned if the client does not have the required credentials to call    |
	//	|                                    | the method.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method either is incorrect or is required and not  |
	//	|                                    | specified. This error can be returned because: The pRule object did not pass the |
	//	|                                    | firewall rule validations specified in the definition of the FW_RULE data type.  |
	//	|                                    | One of the required values is not specified. A policy store does not support     |
	//	|                                    | rules with profile conditions other than ALL profiles. The wszLocalApplication   |
	//	|                                    | parameter contains a string that at enforcement time does not represent a valid  |
	//	|                                    | file path.<34>                                                                   |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	//
	// This method adds a firewall rule in the firewall linked list of the memory representation
	// of the store being modified. It also writes through and saves the rule on disk. If
	// called on an online store, the firewall rule is also enforced.
	AddFirewallRule210(context.Context, *AddFirewallRule210Request, ...dcerpc.CallOption) (*AddFirewallRule210Response, error)

	// The RRPC_FWSetFirewallRule2_10 (Opnum 47) method requests the server to modify the
	// specified firewall rule in the policy contained in the policy store referenced by
	// the handle specified in the hPolicyStore parameter. The method is only supported
	// for binary versions 0x020A and 0x0214.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The specified store does not support this method; the store might be read-only.  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicyStore handle was not opened with read/write access rights. The error  |
	//	|                                    | is also returned if the client does not have the required credentials to call    |
	//	|                                    | the method.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000002 ERROR_FILE_NOT_FOUND    | The specified rule referenced by the wszRuleID member string of the FW_RULE data |
	//	|                                    | type is not found in the policy store.                                           |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method either is incorrect or is required and not  |
	//	|                                    | specified. This error can be returned because: The pRule object did not pass the |
	//	|                                    | firewall rule validations specified in the definition of the FW_RULE data type.  |
	//	|                                    | One of the required values is not specified. A policy store does not support     |
	//	|                                    | rules with profile conditions other than ALL profiles.                           |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	SetFirewallRule210(context.Context, *SetFirewallRule210Request, ...dcerpc.CallOption) (*SetFirewallRule210Response, error)

	// The RRPC_FWEnumFirewallRules2_10 (Opnum 48) method requests the server to return
	// all the firewall rules contained in the store referenced by the hPolicyStore handle.
	// The method returns a linked list of all the firewall rule objects. The method is
	// only supported for binary versions 0x020A and 0x0214.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicyStore handle was not opened with read/write access rights. The error  |
	//	|                                    | is also returned if the client does not have the required credentials to call    |
	//	|                                    | the method.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect or is required but not         |
	//	|                                    | specified. This error can be returned in the following cases: - One of the       |
	//	|                                    | required values is not specified. - The dwProfileFilter parameter contains       |
	//	|                                    | invalid profiles.                                                                |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	EnumFirewallRules210(context.Context, *EnumFirewallRules210Request, ...dcerpc.CallOption) (*EnumFirewallRules210Response, error)

	// The RRPC_FWAddConnectionSecurityRule2_10 (Opnum 49) method requests the server to
	// add the specified connection security rule in the policy contained in the policy
	// store referenced by the handle specified in the hPolicyStore parameter. The method
	// is only supported for binary versions 0x020A and 0x0214.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000000B7 ERROR_ALREADY_EXISTS    | The specified rule has a rule ID that already exists in the specified store.     |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The specified store does not support this method; the store might be read-only.  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicyStore handle was not opened with read/write access rights. The error  |
	//	|                                    | is also returned if the client does not have the required credentials to call    |
	//	|                                    | the method.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method either is incorrect or is required and not  |
	//	|                                    | specified. This error can be returned because: The pRule object did not pass     |
	//	|                                    | the firewall rule validations specified in the definition of the FW_CS_RULE      |
	//	|                                    | data type. One of the required values is not specified. A policy store does not  |
	//	|                                    | support rules with profile conditions other than ALL profiles.                   |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	//
	// This method adds a firewall rule in the firewall linked list of the memory representation
	// of the store being modified. It also writes through and saves the rule on disk. If
	// called on an online store, the firewall rule is also enforced.
	AddConnectionSecurityRule210(context.Context, *AddConnectionSecurityRule210Request, ...dcerpc.CallOption) (*AddConnectionSecurityRule210Response, error)

	// The RRPC_FWSetConnectionSecurityRule2_10 (Opnum 50) method requests the server to
	// modify the specified connection security rule in the policy contained in the policy
	// store referenced by the handle specified in the hPolicyStore parameter. The method
	// is only supported for binary versions 0x020A and 0x0214.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The specified store does not support this method; the store might be read-only.  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicyStore handle was not opened with read/write access rights. The error  |
	//	|                                    | is also returned if the client does not have the required credentials to call    |
	//	|                                    | the method.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000002 ERROR_FILE_NOT_FOUND    | The specified rule referenced by the wszRuleID member string of the FW_CS_RULE   |
	//	|                                    | data type is not found in the policy store.                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method either is incorrect or is required and not  |
	//	|                                    | specified. This error can be returned because: The pRule object did not pass     |
	//	|                                    | the firewall rule validations specified in the definition of the FW_CS_RULE      |
	//	|                                    | data type. One of the required values is not specified. A policy store does not  |
	//	|                                    | support rules with profile conditions other than ALL profiles.                   |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	SetConnectionSecurityRule210(context.Context, *SetConnectionSecurityRule210Request, ...dcerpc.CallOption) (*SetConnectionSecurityRule210Response, error)

	// The RRPC_FWEnumConnectionSecurityRules2_10 (Opnum 51) method requests the server
	// to return all the connection security rules contained in the store referenced by
	// the hPolicyStore handle. The method returns a linked list of all the connection security
	// rule objects. The method is only supported for binary versions 0x020A and 0x0214.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicyStore handle was not opened with read/write access rights. The error  |
	//	|                                    | is also returned if the client does not have the required credentials to call    |
	//	|                                    | the method.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect or is required but not         |
	//	|                                    | specified. This error can be returned in the following cases: - One of the       |
	//	|                                    | required values is not specified. - The dwProfileFilter parameter contains       |
	//	|                                    | invalid profiles.                                                                |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	EnumConnectionSecurityRules210(context.Context, *EnumConnectionSecurityRules210Request, ...dcerpc.CallOption) (*EnumConnectionSecurityRules210Response, error)

	// The RRPC_FWAddAuthenticationSet2_10 (Opnum 52) method requests the server to add
	// the authentication set in the policy contained in the policy store referenced by
	// the handle specified in the hPolicy parameter. The method is only supported for binary
	// versions 0x020A and 0x0214.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000000B7 ERROR_ALREADY_EXISTS    | The specified rule has a rule ID that already exists in the specified store.     |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The specified store does not support this method; the store might be read-only.  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicy handle was not opened with read/write access rights. The error is    |
	//	|                                    | also returned if the client does not have the required credentials to call the   |
	//	|                                    | method.                                                                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method either is incorrect or is required and not  |
	//	|                                    | specified. This error can be returned because: The pAuth object did not pass the |
	//	|                                    | firewall rule validations specified in the definition of the FW_AUTH_SET data    |
	//	|                                    | type. One of the required values is not specified.                               |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	//
	// This method adds a firewall rule in the firewall linked list of the memory representation
	// of the store being modified. It also writes through and saves the rule on disk. If
	// the method is called on an online store, the firewall rule is also enforced.
	AddAuthenticationSet210(context.Context, *AddAuthenticationSet210Request, ...dcerpc.CallOption) (*AddAuthenticationSet210Response, error)

	// The RRPC_FWSetAuthenticationSet2_10 (Opnum 53) method requests the server to modify
	// the specified authentication set in the policy contained in the policy store referenced
	// by the handle specified in the hPolicy parameter. The method is only supported for
	// binary versions 0x020A and 0x0214.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The specified store does not support this method; the store might be read-only.  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicy handle was not opened with read/write access rights. The error is    |
	//	|                                    | also returned if the client does not have the required credentials to call the   |
	//	|                                    | method.                                                                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000002 ERROR_FILE_NOT_FOUND    | The specified rule referenced by the wszSetId member string of the FW_AUTH_SET   |
	//	|                                    | data type is not found in the policy store.                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method either is incorrect or is required and not  |
	//	|                                    | specified. This error can be returned because: The pAuth object did not pass the |
	//	|                                    | firewall rule validations specified in the definition of the FW_AUTH_SET data    |
	//	|                                    | type. One of the required values is not specified.                               |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	SetAuthenticationSet210(context.Context, *SetAuthenticationSet210Request, ...dcerpc.CallOption) (*SetAuthenticationSet210Response, error)

	// The RRPC_FWEnumAuthenticationSets2_10 (Opnum 54) method requests the server to return
	// all the authentication sets of the specified IPsec phase contained in the store referenced
	// by the hPolicyStore handle. The method returns a linked list of these objects. The
	// method is only supported for binary versions 0x020A and 0x0214.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicyStore handle was not opened with read/write access rights. The error  |
	//	|                                    | is also returned if the client does not have the required credentials to call    |
	//	|                                    | the method.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect or is required but not         |
	//	|                                    | specified. This error can be returned in the following cases: - One of the       |
	//	|                                    | required values is not specified. - The dwProfileFilter parameter contains       |
	//	|                                    | invalid profiles.                                                                |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	EnumAuthenticationSets210(context.Context, *EnumAuthenticationSets210Request, ...dcerpc.CallOption) (*EnumAuthenticationSets210Response, error)

	// The RRPC_FWAddCryptoSet2_10 (Opnum 55) method adds a cryptographic set in the cryptographic
	// linked list of the memory representation of the store being modified. The method
	// is only supported for binary versions 0x020A and 0x0214.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000000B7 ERROR_ALREADY_EXISTS    | The specified cryptographic set has a cryptographic set ID that already exists   |
	//	|                                    | in the specified store.                                                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The specified store does not support this method; the store might be read-only.  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicy handle was not opened with read/write access rights. The error is    |
	//	|                                    | also returned if the client does not have the required credentials to call the   |
	//	|                                    | method.                                                                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method either is incorrect or is required and not  |
	//	|                                    | specified. This error can be returned because: The pCrypto object did not pass   |
	//	|                                    | the crypto set validations specified in the definition of the FW_CRYPTO_SET data |
	//	|                                    | type. One of the required values is not specified.                               |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	//
	// This method adds a firewall rule in the firewall linked list of the memory representation
	// of the store being modified. It also writes through and saves the rule on disk. If
	// called on an online store, the firewall rule is also enforced.
	AddCryptoSet210(context.Context, *AddCryptoSet210Request, ...dcerpc.CallOption) (*AddCryptoSet210Response, error)

	// The RRPC_FWSetCryptoSet2_10 (Opnum 56) method requests the server to modify the specified
	// cryptographic set in the policy contained in the policy store referenced by the handle
	// specified in the hPolicy parameter. The method is only supported for binary versions
	// 0x020A and 0x0214.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The specified store does not support this method; the store might be read-only.  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicy handle was not opened with read/write access rights. The error is    |
	//	|                                    | also returned if the client does not have the required credentials to call the   |
	//	|                                    | method.                                                                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000002 ERROR_FILE_NOT_FOUND    | The specified rule referenced by the wszSetId member string of the FW_CRYPTO_SET |
	//	|                                    | data type is not found in the policy store.                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method either is incorrect or is required and not  |
	//	|                                    | specified. This error can be returned because: The pCrypto object did not pass   |
	//	|                                    | the crypto set validations specified in the definition of the FW_CRYPTO_SET data |
	//	|                                    | type. One of the required values is not specified.                               |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	SetCryptoSet210(context.Context, *SetCryptoSet210Request, ...dcerpc.CallOption) (*SetCryptoSet210Response, error)

	// The RRPC_FWEnumCryptoSets2_10 (Opnum 57) method requests the server to return all
	// the cryptographic sets of the specified IPsec phase contained in the store referenced
	// by the hPolicyStore handle. The method returns a linked list of these objects. The
	// method is only supported for binary versions 0x020A and 0x0214.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicyStore handle was not opened with read/write access rights. The error  |
	//	|                                    | is also returned if the client does not have the required credentials to call    |
	//	|                                    | the method.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect or is required but not         |
	//	|                                    | specified. This error can be returned in the following cases: - One of the       |
	//	|                                    | required values is not specified. - The dwProfileFilter parameter contains       |
	//	|                                    | invalid profiles.                                                                |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	EnumCryptoSets210(context.Context, *EnumCryptoSets210Request, ...dcerpc.CallOption) (*EnumCryptoSets210Response, error)

	// The RRPC_FWAddConnectionSecurityRule2_20 method requests the server to add the specified
	// connection security rule in the policy contained in the policy store referenced by
	// the handle specified in the hPolicyStore parameter. The method is only supported
	// for binary version 0x0214.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000000B7 ERROR_ALREADY_EXISTS    | The specified rule has a rule ID that already exists in the specified store.     |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The specified store does not support this method; the store might be read-only.  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicyStore handle was not opened with read/write access rights. The error  |
	//	|                                    | is also returned if the client does not have the required credentials to call    |
	//	|                                    | the method.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method either is incorrect or is required and not  |
	//	|                                    | specified. This error can be returned because: The pRule object did not pass     |
	//	|                                    | the firewall rule validations specified in the definition of the FW_CS_RULE      |
	//	|                                    | data type. One of the required values is not specified. A policy store does not  |
	//	|                                    | support rules with profile conditions other than ALL profiles.                   |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	//
	// This method adds a firewall rule in the firewall linked list of the memory representation
	// of the store being modified. It also writes through and saves the rule on disk. If
	// called on an online store, the firewall rule is also enforced.
	AddConnectionSecurityRule220(context.Context, *AddConnectionSecurityRule220Request, ...dcerpc.CallOption) (*AddConnectionSecurityRule220Response, error)

	// The RRPC_FWSetConnectionSecurityRule2_20 method requests the server to modify the
	// specified connection security rule in the policy contained in the policy store referenced
	// by the handle specified in the hPolicyStore parameter. The method is only supported
	// for binary version 0x0214.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The specified store does not support this method; the store might be read-only.  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicyStore handle was not opened with read/write access rights. The error  |
	//	|                                    | is also returned if the client does not have the required credentials to call    |
	//	|                                    | the method.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000002 ERROR_FILE_NOT_FOUND    | The specified rule referenced by the wszRuleID member string of the FW_CS_RULE   |
	//	|                                    | data type is not found in the policy store.                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method either is incorrect or is required and not  |
	//	|                                    | specified. This error can be returned because: The pRule object did not pass     |
	//	|                                    | the firewall rule validations specified in the definition of the FW_CS_RULE      |
	//	|                                    | data type. One of the required values is not specified. A policy store does not  |
	//	|                                    | support rules with profile conditions other than ALL profiles.                   |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	SetConnectionSecurityRule220(context.Context, *SetConnectionSecurityRule220Request, ...dcerpc.CallOption) (*SetConnectionSecurityRule220Response, error)

	// The RRPC_FWEnumConnectionSecurityRules2_20 (Opnum 60) method requests the server
	// to return all the connection security rules contained in the store referenced by
	// the hPolicyStore handle. The method returns a linked list of all the connection security
	// rule objects. The method is only supported for binary version 0x0214.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicyStore handle was not opened with read/write access rights. The error  |
	//	|                                    | is also returned if the client does not have the required credentials to call    |
	//	|                                    | the method.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | The dwProfileFilter parameter contains invalid profiles.                         |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	EnumConnectionSecurityRules220(context.Context, *EnumConnectionSecurityRules220Request, ...dcerpc.CallOption) (*EnumConnectionSecurityRules220Response, error)

	// The RRPC_FWQueryConnectionSecurityRules2_20 (Opnum 61) method requests the server
	// to return all the connection security rules that match the specified query object
	// that are contained in the store referenced by the hPolicy handle. The method returns
	// a linked list of all the connection security rule objects. The method is only supported
	// for binary version 0x0214.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The client does not have the required credentials to call the method.            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect or is required but not         |
	//	|                                    | specified. This error can be returned in the following cases: - One of the       |
	//	|                                    | required values is not specified. - The dwProfileFilter parameter contains       |
	//	|                                    | invalid profiles.                                                                |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	QueryConnectionSecurityRules220(context.Context, *QueryConnectionSecurityRules220Request, ...dcerpc.CallOption) (*QueryConnectionSecurityRules220Response, error)

	// The RRPC_FWAddAuthenticationSet2_20 method requests the server to add the authentication
	// set in the policy contained in the policy store referenced by the handle specified
	// in the hPolicy parameter. The method is only supported for binary version 0x0214.
	//
	// Return Values: The method returns 0 if successful; if failed, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000000B7 ERROR_ALREADY_EXISTS    | The specified set has a set ID that already exists in the specified store.       |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The specified store does not support this method; the store might be read-only.  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicy handle was not opened with read/write access rights. The error is    |
	//	|                                    | also returned if the client does not have the required credentials to call the   |
	//	|                                    | method.                                                                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect, or is required and not        |
	//	|                                    | specified. This error can be returned because: The pAuth object did not pass the |
	//	|                                    | firewall rule validations specified in the definition of the FW_AUTH_SET data    |
	//	|                                    | type. One of the required values is not specified.                               |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE].
	//
	// This method adds a firewall rule in the firewall linked list of the memory representation
	// of the store being modified. It also writes through and saves the rule in disk. If
	// the method is called on an online store, the firewall rule is also enforced.
	AddAuthenticationSet220(context.Context, *AddAuthenticationSet220Request, ...dcerpc.CallOption) (*AddAuthenticationSet220Response, error)

	// The RRPC_FWSetAuthenticationSet2_20 method requests the server to modify the specified
	// authentication set in the policy contained in the policy store referenced by the
	// handle specified in the hPolicy parameter. The method is only supported for binary
	// version 0x0214.
	//
	// Return Values: The method returns 0 if successful; if failed, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The specified store does not support this method; the store might be read-only.  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicy handle was not opened with read/write access rights. The error is    |
	//	|                                    | also returned if the client does not have the required credentials to call the   |
	//	|                                    | method.                                                                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0X00000002 ERROR_FILE_NOT_FOUND    | The specified rule referenced by the wszSetId member string of the FW_AUTH_SET   |
	//	|                                    | data type is not found in the policy store.                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect, or is required and not        |
	//	|                                    | specified. This error can be returned because: The pAuth object did not pass the |
	//	|                                    | firewall rule validations specified in the definition of the FW_AUTH_SET data    |
	//	|                                    | type. One of the required values is not specified.                               |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE].
	SetAuthenticationSet220(context.Context, *SetAuthenticationSet220Request, ...dcerpc.CallOption) (*SetAuthenticationSet220Response, error)

	// The RRPC_FWEnumAuthenticationSets2_20 method requests the server to return all the
	// authentication sets of the specified IPsec phase contained in the store referenced
	// in the hPolicy handle. The method returns a linked list of these objects. The method
	// is only supported for binary version 0x0214.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicy handle was not opened with read/write access rights. The error is    |
	//	|                                    | also returned if the client does not have the required credentials to call the   |
	//	|                                    | method.                                                                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | The dwProfileFilter parameter contains invalid profiles.                         |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE].
	EnumAuthenticationSets220(context.Context, *EnumAuthenticationSets220Request, ...dcerpc.CallOption) (*EnumAuthenticationSets220Response, error)

	// The RRPC_FWQueryAuthenticationSets2_20 method requests the server to return all the
	// authentication sets that match the specified query object that are contained in the
	// store referenced in the hPolicy handle. The method returns a linked list of all the
	// authentication set objects. The method is only supported for binary version 0x0214.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The client does not have the required credentials to call the method.            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect or is required but not         |
	//	|                                    | specified. This error can be returned in the following cases: - One of the       |
	//	|                                    | required values is not specified. - The dwProfileFilter parameter contains       |
	//	|                                    | invalid profiles.                                                                |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE].
	QueryAuthenticationSets220(context.Context, *QueryAuthenticationSets220Request, ...dcerpc.CallOption) (*QueryAuthenticationSets220Response, error)

	// The RRPC_FWAddFirewallRule2_20 method requests the server to add the specified firewall
	// rule in the policy contained in the policy store referenced by the handle specified
	// in the hPolicyStore parameter. The method is only supported for binary version 0x0214.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000000B7 ERROR_ALREADY_EXISTS    | The specified rule has a rule ID that already exists in the specified store.     |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The specified store does not support this method; the store might be read-only.  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicyStore handle was not opened with read/write access rights. The error  |
	//	|                                    | is also returned if the client does not have the required credentials to call    |
	//	|                                    | the method.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method either is incorrect or is required and not  |
	//	|                                    | specified. This error can be returned because: The pRule object did not pass the |
	//	|                                    | firewall rule validations specified in the definition of the FW_RULE data type.  |
	//	|                                    | One of the required values is not specified. A policy store does not support     |
	//	|                                    | rules with profile conditions other than ALL profiles. The wszLocalApplication   |
	//	|                                    | member contains a string that, at enforcement time, does not represent a valid   |
	//	|                                    | file path.                                                                       |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	//
	// This method adds a firewall rule in the firewall linked list of the memory representation
	// of the store being modified. It also writes through and saves the rule on disk. If
	// called on an online store, the firewall rule is also enforced.
	AddFirewallRule220(context.Context, *AddFirewallRule220Request, ...dcerpc.CallOption) (*AddFirewallRule220Response, error)

	// The RRPC_FWAddConnectionSecurityRule2_20 method requests the server to modify the
	// specified connection security rule in the policy contained in the policy store referenced
	// by the handle specified in the hPolicyStore parameter. The method is only supported
	// for binary version 0x0214.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The specified store does not support this method; the store might be read-only.  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicyStore handle was not opened with read/write access rights. The error  |
	//	|                                    | is also returned if the client does not have the required credentials to call    |
	//	|                                    | the method.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000002 ERROR_FILE_NOT_FOUND    | The specified rule referenced by the wszRuleID member string of the FW_RULE data |
	//	|                                    | type is not found in the policy store.                                           |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method either is incorrect or is required and not  |
	//	|                                    | specified. This error can be returned because: The pRule object did not pass the |
	//	|                                    | firewall rule validations specified in the definition of the FW_RULE data type.  |
	//	|                                    | One of the required values is not specified. A policy store does not support     |
	//	|                                    | rules with profile conditions other than ALL profiles.                           |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	SetFirewallRule220(context.Context, *SetFirewallRule220Request, ...dcerpc.CallOption) (*SetFirewallRule220Response, error)

	// The RRPC_FWEnumFirewallRules2_20 (Opnum 68) method requests the server to return
	// all the firewall rules contained in the store referenced by the hPolicyStore handle.
	// The method returns a linked list of all the firewall rule objects. The method is
	// only supported for binary version 0x0214.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicyStore handle was not opened with read/write access rights. The error  |
	//	|                                    | is also returned if the client does not have the required credentials to call    |
	//	|                                    | the method.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect or is required but not         |
	//	|                                    | specified. This error can be returned in the following cases: - One of the       |
	//	|                                    | required values is not specified. - The dwProfileFilter parameter contains       |
	//	|                                    | invalid profiles.                                                                |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	EnumFirewallRules220(context.Context, *EnumFirewallRules220Request, ...dcerpc.CallOption) (*EnumFirewallRules220Response, error)

	// The RRPC_FWQueryFirewallRules2_20 (Opnum 69) method requests the server to return
	// all the firewall rules that match the specified query object that are contained in
	// the store referenced by the hPolicy handle. The method returns a linked list of all
	// the connection security rule objects. The method is only supported for binary version
	// 0x0214.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The client does not have the required credentials to call the method.            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect or is required but not         |
	//	|                                    | specified. This error can be returned in the following cases: - One of the       |
	//	|                                    | required values is not specified. - The pQuery parameter contains invalid        |
	//	|                                    | profiles.                                                                        |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	QueryFirewallRules220(context.Context, *QueryFirewallRules220Request, ...dcerpc.CallOption) (*QueryFirewallRules220Response, error)

	// The RRPC_FWAddFirewallRule2_24 method requests the server to add the specified firewall
	// rule in the policy contained in the policy store that is referenced by the handle
	// specified in the hPolicyStore parameter. The method is only supported for binary
	// version 0x0218.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000000B7 ERROR_ALREADY_EXISTS    | The specified rule has a rule ID that already exists in the specified store.     |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The specified store does not support this method; the store might be read-only.  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicyStore handle was not opened with read/write access rights. This error |
	//	|                                    | is also returned if the client does not have the required credentials to call    |
	//	|                                    | the method.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect or is required but not         |
	//	|                                    | specified. This error can be returned in the following cases: - The pRule        |
	//	|                                    | object did not pass the firewall rule validations specified in the definition    |
	//	|                                    | of the FW_RULE data type. - One of the required values is not specified. -       |
	//	|                                    | A policy store does not support rules with profile conditions other than ALL     |
	//	|                                    | profiles. - The wszLocalApplication member of the rule contains a string that,   |
	//	|                                    | at enforcement time, does not represent a valid file path.                       |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	//
	// This method adds a firewall rule in the firewall linked list of the memory representation
	// of the store being modified. It also writes through and saves the rule on disk. If
	// called on an online store, the firewall rule is also enforced.
	AddFirewallRule224(context.Context, *AddFirewallRule224Request, ...dcerpc.CallOption) (*AddFirewallRule224Response, error)

	// The RRPC_FWSetFirewallRule2_24 method requests the server to modify the specified
	// connection security rule in the policy contained in the policy store that is referenced
	// by the handle specified in the hPolicyStore parameter. The method is only supported
	// for binary version 0x0218.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The specified store does not support this method; the store might be read-only.  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicyStore handle was not opened with read/write access rights. This error |
	//	|                                    | is also returned if the client does not have the required credentials to call    |
	//	|                                    | the method.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000002 ERROR_FILE_NOT_FOUND    | The specified rule referenced by the wszRuleID member string of the FW_RULE data |
	//	|                                    | type is not found in the policy store.                                           |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect or is required but not         |
	//	|                                    | specified. This error can be returned in the following cases: - The pRule object |
	//	|                                    | did not pass the firewall rule validations specified in the definition of the    |
	//	|                                    | FW_RULE data type. - One of the required values is not specified. - A policy     |
	//	|                                    | store does not support rules with profile conditions other than ALL profiles.    |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	SetFirewallRule224(context.Context, *SetFirewallRule224Request, ...dcerpc.CallOption) (*SetFirewallRule224Response, error)

	// The RRPC_FWEnumFirewallRules2_24 method requests the server to return all the firewall
	// rules contained in the store that is referenced by the hPolicyStore handle. The method
	// returns a linked list of all the firewall rule objects. The method is only supported
	// for binary version 0x0218.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicyStore handle was not opened with read/write access rights. This error |
	//	|                                    | is also returned if the client does not have the required credentials to call    |
	//	|                                    | the method.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect or is required but not         |
	//	|                                    | specified. This error can be returned in the following cases: - One of the       |
	//	|                                    | required values is not specified. - The dwProfileFilter parameter contains       |
	//	|                                    | invalid profiles.                                                                |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	EnumFirewallRules224(context.Context, *EnumFirewallRules224Request, ...dcerpc.CallOption) (*EnumFirewallRules224Response, error)

	// The RRPC_FWQueryFirewallRules2_24 method requests the server to return all the firewall
	// rules that match the specified query object that are contained in the store that
	// is referenced by the hPolicyStore handle. The method returns a linked list of all
	// the connection security rule objects. The method is only supported for binary version
	// 0x0218.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The client does not have the required credentials to call the method.            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect or is required but not         |
	//	|                                    | specified. This error can be returned in the following cases: - One of the       |
	//	|                                    | required values is not specified. - The pQuery parameter contains invalid        |
	//	|                                    | conditions.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	QueryFirewallRules224(context.Context, *QueryFirewallRules224Request, ...dcerpc.CallOption) (*QueryFirewallRules224Response, error)

	// The RRPC_FWAddFirewallRule2_25 method requests the server to add the specified firewall
	// rule in the policy contained in the policy store that is referenced by the handle
	// specified in the hPolicyStore parameter. The method is only supported for binary
	// version 0x0219.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000000B7 ERROR_ALREADY_EXISTS    | The specified rule has a rule ID that already exists in the specified store.     |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The specified store does not support this method; the store might be read-only.  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicyStore handle was not opened with read/write access rights. This error |
	//	|                                    | is also returned if the client does not have the required credentials to call    |
	//	|                                    | the method.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect or is required but not         |
	//	|                                    | specified. This error can be returned in the following cases: - The pRule        |
	//	|                                    | object did not pass the firewall rule validations specified in the definition    |
	//	|                                    | of the FW_RULE data type. - One of the required values is not specified. -       |
	//	|                                    | A policy store does not support rules with profile conditions other than ALL     |
	//	|                                    | profiles. - The wszLocalApplication member of the rule contains a string that,   |
	//	|                                    | at enforcement time, does not represent a valid file path.                       |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	//
	// This method adds a firewall rule in the firewall linked list of the memory representation
	// of the store being modified. It also writes through and saves the rule on disk. If
	// called on an online store, the firewall rule is also enforced.
	AddFirewallRule225(context.Context, *AddFirewallRule225Request, ...dcerpc.CallOption) (*AddFirewallRule225Response, error)

	// The RRPC_FWSetFirewallRule2_25 method requests the server to modify the specified
	// connection security rule in the policy contained in the policy store that is referenced
	// by the handle specified in the hPolicyStore parameter. The method is only supported
	// for binary version 0x0219.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The specified store does not support this method; the store might be read-only.  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicyStore handle was not opened with read/write access rights. This error |
	//	|                                    | is also returned if the client does not have the required credentials to call    |
	//	|                                    | the method.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000002 ERROR_FILE_NOT_FOUND    | The specified rule referenced by the wszRuleID member string of the FW_RULE data |
	//	|                                    | type is not found in the policy store.                                           |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect or is required but not         |
	//	|                                    | specified. This error can be returned in the following cases: - The pRule object |
	//	|                                    | did not pass the firewall rule validations specified in the definition of the    |
	//	|                                    | FW_RULE data type. - One of the required values is not specified. - A policy     |
	//	|                                    | store does not support rules with profile conditions other than ALL profiles.    |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	SetFirewallRule225(context.Context, *SetFirewallRule225Request, ...dcerpc.CallOption) (*SetFirewallRule225Response, error)

	// The RRPC_FWEnumFirewallRules2_25 method requests the server to return all the firewall
	// rules contained in the store that is referenced by the hPolicyStore handle. The method
	// returns a linked list of all the firewall rule objects. The method is only supported
	// for binary version 0x0219.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicyStore handle was not opened with read/write access rights. This error |
	//	|                                    | is also returned if the client does not have the required credentials to call    |
	//	|                                    | the method.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect or is required but not         |
	//	|                                    | specified. This error can be returned in the following cases: - One of the       |
	//	|                                    | required values is not specified. - The dwProfileFilter parameter contains       |
	//	|                                    | invalid profiles.                                                                |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	EnumFirewallRules225(context.Context, *EnumFirewallRules225Request, ...dcerpc.CallOption) (*EnumFirewallRules225Response, error)

	// The RRPC_FWQueryFirewallRules2_25 method requests the server to return all the firewall
	// rules that match the specified query object that are contained in the store that
	// is referenced by the hPolicyStore handle. The method returns a linked list of all
	// the connection security rule objects. The method is only supported for binary version
	// 0x0219.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The client does not have the required credentials to call the method.            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect or is required but not         |
	//	|                                    | specified. This error can be returned in the following cases: - One of the       |
	//	|                                    | required values is not specified. - The pQuery parameter contains invalid        |
	//	|                                    | conditions.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	QueryFirewallRules225(context.Context, *QueryFirewallRules225Request, ...dcerpc.CallOption) (*QueryFirewallRules225Response, error)

	// The RRPC_FWAddFirewallRule2_26 method requests the server to add the specified firewall
	// rule in the policy contained in the policy store that is referenced by the handle
	// specified in the hPolicyStore parameter. The method is only supported for binary
	// version 0x021A.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000000B7 ERROR_ALREADY_EXISTS    | The specified rule has a rule ID that already exists in the specified store.     |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The specified store does not support this method; the store might be read-only.  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicyStore handle was not opened with read/write access rights. This error |
	//	|                                    | is also returned if the client does not have the required credentials to call    |
	//	|                                    | the method.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect or is required but not         |
	//	|                                    | specified. This error can be returned in the following cases: - The pRule        |
	//	|                                    | object did not pass the firewall rule validations specified in the definition    |
	//	|                                    | of the FW_RULE data type. - One of the required values is not specified. -       |
	//	|                                    | A policy store does not support rules with profile conditions other than ALL     |
	//	|                                    | profiles. - The wszLocalApplication member of the rule contains a string that,   |
	//	|                                    | at enforcement time, does not represent a valid file path.                       |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	//
	// This method adds a firewall rule in the firewall linked list of the memory representation
	// of the store being modified. It also writes through and saves the rule on disk. If
	// called on an online store, the firewall rule is also enforced.
	AddFirewallRule226(context.Context, *AddFirewallRule226Request, ...dcerpc.CallOption) (*AddFirewallRule226Response, error)

	// The RRPC_FWSetFirewallRule2_26 method requests the server to modify the specified
	// connection security rule in the policy contained in the policy store that is referenced
	// by the handle specified in the hPolicyStore parameter. The method is only supported
	// for binary version 0x021A.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The specified store does not support this method; the store might be read-only.  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicyStore handle was not opened with read/write access rights. This error |
	//	|                                    | is also returned if the client does not have the required credentials to call    |
	//	|                                    | the method.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000002 ERROR_FILE_NOT_FOUND    | The specified rule referenced by the wszRuleID member string of the FW_RULE data |
	//	|                                    | type is not found in the policy store.                                           |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect or is required but not         |
	//	|                                    | specified. This error can be returned in the following cases: - The pRule object |
	//	|                                    | did not pass the firewall rule validations specified in the definition of the    |
	//	|                                    | FW_RULE data type. - One of the required values is not specified. - A policy     |
	//	|                                    | store does not support rules with profile conditions other than ALL profiles.    |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	SetFirewallRule226(context.Context, *SetFirewallRule226Request, ...dcerpc.CallOption) (*SetFirewallRule226Response, error)

	// The RRPC_FWEnumFirewallRules2_26 method requests the server to return all the firewall
	// rules contained in the store that is referenced by the hPolicyStore handle. The method
	// returns a linked list of all the firewall rule objects. The method is only supported
	// for binary version 0x021A.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicyStore handle was not opened with read/write access rights. This error |
	//	|                                    | is also returned if the client does not have the required credentials to call    |
	//	|                                    | the method.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect or is required but not         |
	//	|                                    | specified. This error can be returned in the following cases: - One of the       |
	//	|                                    | required values is not specified. - The dwProfileFilter parameter contains       |
	//	|                                    | invalid profiles.                                                                |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	EnumFirewallRules226(context.Context, *EnumFirewallRules226Request, ...dcerpc.CallOption) (*EnumFirewallRules226Response, error)

	// The RRPC_FWQueryFirewallRules2_26 method requests the server to return all the firewall
	// rules that match the specified query object that are contained in the store that
	// is referenced by the hPolicyStore handle. The method returns a linked list of all
	// the connection security rule objects. The method is only supported for binary version
	// 0x021A.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The client does not have the required credentials to call the method.            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect or is required but not         |
	//	|                                    | specified. This error can be returned in the following cases: - One of the       |
	//	|                                    | required values is not specified. - The pQuery parameter contains invalid        |
	//	|                                    | conditions.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	QueryFirewallRules226(context.Context, *QueryFirewallRules226Request, ...dcerpc.CallOption) (*QueryFirewallRules226Response, error)

	// The RRPC_FWAddFirewallRule2_27 method requests the server to add the specified firewall
	// rule to the policy contained in the policy store that is referenced by the handle
	// specified in the hPolicyStore parameter. The method is only supported for binary
	// version 0x021B.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000000B7 ERROR_ALREADY_EXISTS    | The specified rule has a rule ID that already exists in the specified store.     |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The specified store does not support this method; the store might be read-only.  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicyStore handle was not opened with read/write access rights. This error |
	//	|                                    | is also returned if the client does not have the required credentials to call    |
	//	|                                    | the method.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect or is required but not         |
	//	|                                    | specified. This error can be returned in the following cases: - The pRule        |
	//	|                                    | object did not pass the firewall rule validations specified in the definition    |
	//	|                                    | of the FW_RULE data type (section 2.2.37). - One of the required values is       |
	//	|                                    | not specified. - A policy store does not support rules with profile conditions   |
	//	|                                    | other than ALL profiles. - The wszLocalApplication member of the rule contains a |
	//	|                                    | string that, at enforcement time, does not represent a valid file path.          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	//
	// This method adds a firewall rule in the firewall linked list of the memory representation
	// of the store being modified. It also writes through and saves the rule on disk. If
	// called on an online store, the firewall rule is also enforced.
	AddFirewallRule227(context.Context, *AddFirewallRule227Request, ...dcerpc.CallOption) (*AddFirewallRule227Response, error)

	// The RRPC_FWSetFirewallRule2_27 method requests the server to modify the specified
	// connection security rule in the policy contained in the policy store that is referenced
	// by the handle specified in the hPolicyStore parameter. The method is only supported
	// for binary version 0x021B.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The specified store does not support this method; the store might be read-only.  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicyStore handle was not opened with read/write access rights. This error |
	//	|                                    | is also returned if the client does not have the required credentials to call    |
	//	|                                    | the method.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000002 ERROR_FILE_NOT_FOUND    | The specified rule referenced by the wszRuleID member string of the FW_RULE data |
	//	|                                    | type (section 2.2.37) is not found in the policy store.                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect or is required but not         |
	//	|                                    | specified. This error can be returned in the following cases: - The pRule        |
	//	|                                    | object did not pass the firewall rule validations specified in the definition    |
	//	|                                    | of the FW_RULE data type (section 2.2.37). - One of the required values is not   |
	//	|                                    | specified. - A policy store does not support rules with profile conditions other |
	//	|                                    | than ALL profiles.                                                               |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	SetFirewallRule227(context.Context, *SetFirewallRule227Request, ...dcerpc.CallOption) (*SetFirewallRule227Response, error)

	// The RRPC_FWEnumFirewallRules2_27 method requests the server to return all the firewall
	// rules contained in the store that is referenced by the hPolicyStore handle. The method
	// returns a linked list of all the firewall rule objects. The method is only supported
	// for binary version 0x021B.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicyStore handle was not opened with read/write access rights. This error |
	//	|                                    | is also returned if the client does not have the required credentials to call    |
	//	|                                    | the method.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect or is required but not         |
	//	|                                    | specified. This error can be returned in the following cases: - One of the       |
	//	|                                    | required values is not specified. - The dwProfileFilter parameter contains       |
	//	|                                    | invalid profiles.                                                                |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	EnumFirewallRules227(context.Context, *EnumFirewallRules227Request, ...dcerpc.CallOption) (*EnumFirewallRules227Response, error)

	// The RRPC_FWQueryFirewallRules2_27 method requests the server to return all the firewall
	// rules that match the specified query object that are contained in the store that
	// is referenced by the hPolicyStore handle. The method returns a linked list of all
	// the connection security rule objects. The method is only supported for binary version
	// 0x021B.
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The client does not have the required credentials to call the method.            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect or is required but not         |
	//	|                                    | specified. This error can be returned in the following cases: - One of the       |
	//	|                                    | required values is not specified. - The pQuery parameter contains invalid        |
	//	|                                    | conditions.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	QueryFirewallRules227(context.Context, *QueryFirewallRules227Request, ...dcerpc.CallOption) (*QueryFirewallRules227Response, error)

	// The RRPC_FWAddFirewallRule2_31 method requests the server to add the specified firewall
	// rule to the policy contained in the policy store that is referenced by the handle
	// specified in the hPolicyStore parameter. The method is only supported for policy
	// version 0x021F (section 2.2.42).
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000000B7 ERROR_ALREADY_EXISTS    | The specified rule has a rule ID that already exists in the specified store.     |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The specified store does not support this method; the store might be read-only.  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicyStore handle was not opened with read/write access rights. This error |
	//	|                                    | is also returned if the client does not have the required credentials to call    |
	//	|                                    | the method.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect or is required but not         |
	//	|                                    | specified. This error can be returned in the following cases: - The pRule        |
	//	|                                    | object did not pass the firewall rule validations specified in the definition    |
	//	|                                    | of the FW_RULE data type (section 2.2.37). - One of the required values is       |
	//	|                                    | not specified. - A policy store does not support rules with profile conditions   |
	//	|                                    | other than ALL profiles. - The wszLocalApplication member of the rule contains a |
	//	|                                    | string that, at enforcement time, does not represent a valid file path.          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	//
	// This method adds a firewall rule in the firewall linked list of the memory representation
	// of the store being modified. It also writes through and saves the rule on disk. If
	// called on an online store, the firewall rule is also enforced.
	AddFirewallRule231(context.Context, *AddFirewallRule231Request, ...dcerpc.CallOption) (*AddFirewallRule231Response, error)

	// The RRPC_FWSetFirewallRule2_31 method requests the server to modify the specified
	// connection security rule in the policy contained in the policy store that is referenced
	// by the handle specified in the hPolicyStore parameter. The method is only supported
	// for policy version 0x021F (section 2.2.42).
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED     | The specified store does not support this method; the store might be read-only.  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicyStore handle was not opened with read/write access rights. This error |
	//	|                                    | is also returned if the client does not have the required credentials to call    |
	//	|                                    | the method.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000002 ERROR_FILE_NOT_FOUND    | The specified rule referenced by the wszRuleID member string of the FW_RULE data |
	//	|                                    | type (section 2.2.37) is not found in the policy store.                          |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect or is required but not         |
	//	|                                    | specified. This error can be returned in the following cases: - The pRule        |
	//	|                                    | object did not pass the firewall rule validations specified in the definition    |
	//	|                                    | of the FW_RULE data type (section 2.2.37). - One of the required values is not   |
	//	|                                    | specified. - A policy store does not support rules with profile conditions other |
	//	|                                    | than ALL profiles.                                                               |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	SetFirewallRule231(context.Context, *SetFirewallRule231Request, ...dcerpc.CallOption) (*SetFirewallRule231Response, error)

	// The RRPC_FWEnumFirewallRules2_31 method requests the server to return the firewall
	// rules matching the input flags contained in the store that is referenced by the hPolicyStore
	// handle. The method returns a linked list of the corresponding firewall rule objects.
	// The method is only supported for policy version 0x021F (section 2.2.42).
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The hPolicyStore handle was not opened with read/write access rights. This error |
	//	|                                    | is also returned if the client does not have the required credentials to call    |
	//	|                                    | the method.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect or is required but not         |
	//	|                                    | specified. This error can be returned in the following cases: - One of the       |
	//	|                                    | required values is not specified. - The dwProfileFilter parameter contains       |
	//	|                                    | invalid profiles.                                                                |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	EnumFirewallRules231(context.Context, *EnumFirewallRules231Request, ...dcerpc.CallOption) (*EnumFirewallRules231Response, error)

	// The RRPC_FWQueryFirewallRules2_31 method requests the server to return all the firewall
	// rules that match the specified query object, as are contained in the store that is
	// referenced by the hPolicyStore handle. The method returns a linked list of all the
	// firewall rules that match the specified query object. The method is only supported
	// for policy version 0x021F (section 2.2.42).
	//
	// Return Values: The method returns 0 if successful; if it fails, it returns a nonzero
	// error code. The field can take any specific error code value, as specified in [MS-ERREF].
	// The following return values are common.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000005 ERROR_ACCESS_DENIED     | The client does not have the required credentials to call the method.            |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters of this method is incorrect or is required but not         |
	//	|                                    | specified. This error can be returned in the following cases: - One of the       |
	//	|                                    | required values is not specified. - The pQuery parameter contains invalid        |
	//	|                                    | conditions.                                                                      |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol, as specified in [MS-RPCE]. If any lower-layer errors are reported by
	// RPC exception, this exception is converted to an error code and reported to higher-layer
	// protocols via the return value.
	QueryFirewallRules231(context.Context, *QueryFirewallRules231Request, ...dcerpc.CallOption) (*QueryFirewallRules231Response, error)

	// AlterContext alters the client context.
	AlterContext(context.Context, ...dcerpc.Option) error

	// Conn returns the client connection (unsafe)
	Conn() dcerpc.Conn
}

// PolicyStore structure represents FW_POLICY_STORE_HANDLE RPC structure.
type PolicyStore dcetypes.ContextHandle

func (o *PolicyStore) ContextHandle() *dcetypes.ContextHandle { return (*dcetypes.ContextHandle)(o) }

func (o *PolicyStore) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *PolicyStore) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Attributes); err != nil {
		return err
	}
	if o.UUID != nil {
		if err := o.UUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *PolicyStore) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Attributes); err != nil {
		return err
	}
	if o.UUID == nil {
		o.UUID = &dtyp.GUID{}
	}
	if err := o.UUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// Product structure represents FW_PRODUCT_HANDLE RPC structure.
type Product dcetypes.ContextHandle

func (o *Product) ContextHandle() *dcetypes.ContextHandle { return (*dcetypes.ContextHandle)(o) }

func (o *Product) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *Product) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Attributes); err != nil {
		return err
	}
	if o.UUID != nil {
		if err := o.UUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *Product) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Attributes); err != nil {
		return err
	}
	if o.UUID == nil {
		o.UUID = &dtyp.GUID{}
	}
	if err := o.UUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

type xxx_DefaultRemoteFwClient struct {
	cc dcerpc.Conn
}

func (o *xxx_DefaultRemoteFwClient) OpenPolicyStore(ctx context.Context, in *OpenPolicyStoreRequest, opts ...dcerpc.CallOption) (*OpenPolicyStoreResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &OpenPolicyStoreResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) ClosePolicyStore(ctx context.Context, in *ClosePolicyStoreRequest, opts ...dcerpc.CallOption) (*ClosePolicyStoreResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ClosePolicyStoreResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) RestoreDefaults(ctx context.Context, in *RestoreDefaultsRequest, opts ...dcerpc.CallOption) (*RestoreDefaultsResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &RestoreDefaultsResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) GetGlobalConfig(ctx context.Context, in *GetGlobalConfigRequest, opts ...dcerpc.CallOption) (*GetGlobalConfigResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetGlobalConfigResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) SetGlobalConfig(ctx context.Context, in *SetGlobalConfigRequest, opts ...dcerpc.CallOption) (*SetGlobalConfigResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetGlobalConfigResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) AddFirewallRule(ctx context.Context, in *AddFirewallRuleRequest, opts ...dcerpc.CallOption) (*AddFirewallRuleResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddFirewallRuleResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) SetFirewallRule(ctx context.Context, in *SetFirewallRuleRequest, opts ...dcerpc.CallOption) (*SetFirewallRuleResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetFirewallRuleResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) DeleteFirewallRule(ctx context.Context, in *DeleteFirewallRuleRequest, opts ...dcerpc.CallOption) (*DeleteFirewallRuleResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &DeleteFirewallRuleResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) DeleteAllFirewallRules(ctx context.Context, in *DeleteAllFirewallRulesRequest, opts ...dcerpc.CallOption) (*DeleteAllFirewallRulesResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &DeleteAllFirewallRulesResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) EnumFirewallRules(ctx context.Context, in *EnumFirewallRulesRequest, opts ...dcerpc.CallOption) (*EnumFirewallRulesResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumFirewallRulesResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) GetConfig(ctx context.Context, in *GetConfigRequest, opts ...dcerpc.CallOption) (*GetConfigResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetConfigResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) SetConfig(ctx context.Context, in *SetConfigRequest, opts ...dcerpc.CallOption) (*SetConfigResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetConfigResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) AddConnectionSecurityRule(ctx context.Context, in *AddConnectionSecurityRuleRequest, opts ...dcerpc.CallOption) (*AddConnectionSecurityRuleResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddConnectionSecurityRuleResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) SetConnectionSecurityRule(ctx context.Context, in *SetConnectionSecurityRuleRequest, opts ...dcerpc.CallOption) (*SetConnectionSecurityRuleResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetConnectionSecurityRuleResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) DeleteConnectionSecurityRule(ctx context.Context, in *DeleteConnectionSecurityRuleRequest, opts ...dcerpc.CallOption) (*DeleteConnectionSecurityRuleResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &DeleteConnectionSecurityRuleResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) DeleteAllConnectionSecurityRules(ctx context.Context, in *DeleteAllConnectionSecurityRulesRequest, opts ...dcerpc.CallOption) (*DeleteAllConnectionSecurityRulesResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &DeleteAllConnectionSecurityRulesResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) EnumConnectionSecurityRules(ctx context.Context, in *EnumConnectionSecurityRulesRequest, opts ...dcerpc.CallOption) (*EnumConnectionSecurityRulesResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumConnectionSecurityRulesResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) AddAuthenticationSet(ctx context.Context, in *AddAuthenticationSetRequest, opts ...dcerpc.CallOption) (*AddAuthenticationSetResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddAuthenticationSetResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) SetAuthenticationSet(ctx context.Context, in *SetAuthenticationSetRequest, opts ...dcerpc.CallOption) (*SetAuthenticationSetResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetAuthenticationSetResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) DeleteAuthenticationSet(ctx context.Context, in *DeleteAuthenticationSetRequest, opts ...dcerpc.CallOption) (*DeleteAuthenticationSetResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &DeleteAuthenticationSetResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) DeleteAllAuthenticationSets(ctx context.Context, in *DeleteAllAuthenticationSetsRequest, opts ...dcerpc.CallOption) (*DeleteAllAuthenticationSetsResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &DeleteAllAuthenticationSetsResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) EnumAuthenticationSets(ctx context.Context, in *EnumAuthenticationSetsRequest, opts ...dcerpc.CallOption) (*EnumAuthenticationSetsResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumAuthenticationSetsResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) AddCryptoSet(ctx context.Context, in *AddCryptoSetRequest, opts ...dcerpc.CallOption) (*AddCryptoSetResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddCryptoSetResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) SetCryptoSet(ctx context.Context, in *SetCryptoSetRequest, opts ...dcerpc.CallOption) (*SetCryptoSetResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetCryptoSetResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) DeleteCryptoSet(ctx context.Context, in *DeleteCryptoSetRequest, opts ...dcerpc.CallOption) (*DeleteCryptoSetResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &DeleteCryptoSetResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) DeleteAllCryptoSets(ctx context.Context, in *DeleteAllCryptoSetsRequest, opts ...dcerpc.CallOption) (*DeleteAllCryptoSetsResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &DeleteAllCryptoSetsResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) EnumCryptoSets(ctx context.Context, in *EnumCryptoSetsRequest, opts ...dcerpc.CallOption) (*EnumCryptoSetsResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumCryptoSetsResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) EnumPhase1SAs(ctx context.Context, in *EnumPhase1SAsRequest, opts ...dcerpc.CallOption) (*EnumPhase1SAsResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumPhase1SAsResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) EnumPhase2SAs(ctx context.Context, in *EnumPhase2SAsRequest, opts ...dcerpc.CallOption) (*EnumPhase2SAsResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumPhase2SAsResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) DeletePhase1SAs(ctx context.Context, in *DeletePhase1SAsRequest, opts ...dcerpc.CallOption) (*DeletePhase1SAsResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &DeletePhase1SAsResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) DeletePhase2SAs(ctx context.Context, in *DeletePhase2SAsRequest, opts ...dcerpc.CallOption) (*DeletePhase2SAsResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &DeletePhase2SAsResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) EnumProducts(ctx context.Context, in *EnumProductsRequest, opts ...dcerpc.CallOption) (*EnumProductsResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumProductsResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) AddMainModeRule(ctx context.Context, in *AddMainModeRuleRequest, opts ...dcerpc.CallOption) (*AddMainModeRuleResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddMainModeRuleResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) SetMainModeRule(ctx context.Context, in *SetMainModeRuleRequest, opts ...dcerpc.CallOption) (*SetMainModeRuleResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetMainModeRuleResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) DeleteMainModeRule(ctx context.Context, in *DeleteMainModeRuleRequest, opts ...dcerpc.CallOption) (*DeleteMainModeRuleResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &DeleteMainModeRuleResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) DeleteAllMainModeRules(ctx context.Context, in *DeleteAllMainModeRulesRequest, opts ...dcerpc.CallOption) (*DeleteAllMainModeRulesResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &DeleteAllMainModeRulesResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) EnumMainModeRules(ctx context.Context, in *EnumMainModeRulesRequest, opts ...dcerpc.CallOption) (*EnumMainModeRulesResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumMainModeRulesResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) QueryFirewallRules(ctx context.Context, in *QueryFirewallRulesRequest, opts ...dcerpc.CallOption) (*QueryFirewallRulesResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &QueryFirewallRulesResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) QueryConnectionSecurityRules210(ctx context.Context, in *QueryConnectionSecurityRules210Request, opts ...dcerpc.CallOption) (*QueryConnectionSecurityRules210Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &QueryConnectionSecurityRules210Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) QueryMainModeRules(ctx context.Context, in *QueryMainModeRulesRequest, opts ...dcerpc.CallOption) (*QueryMainModeRulesResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &QueryMainModeRulesResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) QueryAuthenticationSets(ctx context.Context, in *QueryAuthenticationSetsRequest, opts ...dcerpc.CallOption) (*QueryAuthenticationSetsResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &QueryAuthenticationSetsResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) QueryCryptoSets(ctx context.Context, in *QueryCryptoSetsRequest, opts ...dcerpc.CallOption) (*QueryCryptoSetsResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &QueryCryptoSetsResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) EnumNetworks(ctx context.Context, in *EnumNetworksRequest, opts ...dcerpc.CallOption) (*EnumNetworksResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumNetworksResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) EnumAdapters(ctx context.Context, in *EnumAdaptersRequest, opts ...dcerpc.CallOption) (*EnumAdaptersResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumAdaptersResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) GetGlobalConfig210(ctx context.Context, in *GetGlobalConfig210Request, opts ...dcerpc.CallOption) (*GetGlobalConfig210Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetGlobalConfig210Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) GetConfig210(ctx context.Context, in *GetConfig210Request, opts ...dcerpc.CallOption) (*GetConfig210Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetConfig210Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) AddFirewallRule210(ctx context.Context, in *AddFirewallRule210Request, opts ...dcerpc.CallOption) (*AddFirewallRule210Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddFirewallRule210Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) SetFirewallRule210(ctx context.Context, in *SetFirewallRule210Request, opts ...dcerpc.CallOption) (*SetFirewallRule210Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetFirewallRule210Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) EnumFirewallRules210(ctx context.Context, in *EnumFirewallRules210Request, opts ...dcerpc.CallOption) (*EnumFirewallRules210Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumFirewallRules210Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) AddConnectionSecurityRule210(ctx context.Context, in *AddConnectionSecurityRule210Request, opts ...dcerpc.CallOption) (*AddConnectionSecurityRule210Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddConnectionSecurityRule210Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) SetConnectionSecurityRule210(ctx context.Context, in *SetConnectionSecurityRule210Request, opts ...dcerpc.CallOption) (*SetConnectionSecurityRule210Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetConnectionSecurityRule210Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) EnumConnectionSecurityRules210(ctx context.Context, in *EnumConnectionSecurityRules210Request, opts ...dcerpc.CallOption) (*EnumConnectionSecurityRules210Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumConnectionSecurityRules210Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) AddAuthenticationSet210(ctx context.Context, in *AddAuthenticationSet210Request, opts ...dcerpc.CallOption) (*AddAuthenticationSet210Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddAuthenticationSet210Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) SetAuthenticationSet210(ctx context.Context, in *SetAuthenticationSet210Request, opts ...dcerpc.CallOption) (*SetAuthenticationSet210Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetAuthenticationSet210Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) EnumAuthenticationSets210(ctx context.Context, in *EnumAuthenticationSets210Request, opts ...dcerpc.CallOption) (*EnumAuthenticationSets210Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumAuthenticationSets210Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) AddCryptoSet210(ctx context.Context, in *AddCryptoSet210Request, opts ...dcerpc.CallOption) (*AddCryptoSet210Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddCryptoSet210Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) SetCryptoSet210(ctx context.Context, in *SetCryptoSet210Request, opts ...dcerpc.CallOption) (*SetCryptoSet210Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetCryptoSet210Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) EnumCryptoSets210(ctx context.Context, in *EnumCryptoSets210Request, opts ...dcerpc.CallOption) (*EnumCryptoSets210Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumCryptoSets210Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) AddConnectionSecurityRule220(ctx context.Context, in *AddConnectionSecurityRule220Request, opts ...dcerpc.CallOption) (*AddConnectionSecurityRule220Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddConnectionSecurityRule220Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) SetConnectionSecurityRule220(ctx context.Context, in *SetConnectionSecurityRule220Request, opts ...dcerpc.CallOption) (*SetConnectionSecurityRule220Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetConnectionSecurityRule220Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) EnumConnectionSecurityRules220(ctx context.Context, in *EnumConnectionSecurityRules220Request, opts ...dcerpc.CallOption) (*EnumConnectionSecurityRules220Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumConnectionSecurityRules220Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) QueryConnectionSecurityRules220(ctx context.Context, in *QueryConnectionSecurityRules220Request, opts ...dcerpc.CallOption) (*QueryConnectionSecurityRules220Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &QueryConnectionSecurityRules220Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) AddAuthenticationSet220(ctx context.Context, in *AddAuthenticationSet220Request, opts ...dcerpc.CallOption) (*AddAuthenticationSet220Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddAuthenticationSet220Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) SetAuthenticationSet220(ctx context.Context, in *SetAuthenticationSet220Request, opts ...dcerpc.CallOption) (*SetAuthenticationSet220Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetAuthenticationSet220Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) EnumAuthenticationSets220(ctx context.Context, in *EnumAuthenticationSets220Request, opts ...dcerpc.CallOption) (*EnumAuthenticationSets220Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumAuthenticationSets220Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) QueryAuthenticationSets220(ctx context.Context, in *QueryAuthenticationSets220Request, opts ...dcerpc.CallOption) (*QueryAuthenticationSets220Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &QueryAuthenticationSets220Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) AddFirewallRule220(ctx context.Context, in *AddFirewallRule220Request, opts ...dcerpc.CallOption) (*AddFirewallRule220Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddFirewallRule220Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) SetFirewallRule220(ctx context.Context, in *SetFirewallRule220Request, opts ...dcerpc.CallOption) (*SetFirewallRule220Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetFirewallRule220Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) EnumFirewallRules220(ctx context.Context, in *EnumFirewallRules220Request, opts ...dcerpc.CallOption) (*EnumFirewallRules220Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumFirewallRules220Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) QueryFirewallRules220(ctx context.Context, in *QueryFirewallRules220Request, opts ...dcerpc.CallOption) (*QueryFirewallRules220Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &QueryFirewallRules220Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) AddFirewallRule224(ctx context.Context, in *AddFirewallRule224Request, opts ...dcerpc.CallOption) (*AddFirewallRule224Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddFirewallRule224Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) SetFirewallRule224(ctx context.Context, in *SetFirewallRule224Request, opts ...dcerpc.CallOption) (*SetFirewallRule224Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetFirewallRule224Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) EnumFirewallRules224(ctx context.Context, in *EnumFirewallRules224Request, opts ...dcerpc.CallOption) (*EnumFirewallRules224Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumFirewallRules224Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) QueryFirewallRules224(ctx context.Context, in *QueryFirewallRules224Request, opts ...dcerpc.CallOption) (*QueryFirewallRules224Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &QueryFirewallRules224Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) AddFirewallRule225(ctx context.Context, in *AddFirewallRule225Request, opts ...dcerpc.CallOption) (*AddFirewallRule225Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddFirewallRule225Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) SetFirewallRule225(ctx context.Context, in *SetFirewallRule225Request, opts ...dcerpc.CallOption) (*SetFirewallRule225Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetFirewallRule225Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) EnumFirewallRules225(ctx context.Context, in *EnumFirewallRules225Request, opts ...dcerpc.CallOption) (*EnumFirewallRules225Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumFirewallRules225Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) QueryFirewallRules225(ctx context.Context, in *QueryFirewallRules225Request, opts ...dcerpc.CallOption) (*QueryFirewallRules225Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &QueryFirewallRules225Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) AddFirewallRule226(ctx context.Context, in *AddFirewallRule226Request, opts ...dcerpc.CallOption) (*AddFirewallRule226Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddFirewallRule226Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) SetFirewallRule226(ctx context.Context, in *SetFirewallRule226Request, opts ...dcerpc.CallOption) (*SetFirewallRule226Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetFirewallRule226Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) EnumFirewallRules226(ctx context.Context, in *EnumFirewallRules226Request, opts ...dcerpc.CallOption) (*EnumFirewallRules226Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumFirewallRules226Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) QueryFirewallRules226(ctx context.Context, in *QueryFirewallRules226Request, opts ...dcerpc.CallOption) (*QueryFirewallRules226Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &QueryFirewallRules226Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) AddFirewallRule227(ctx context.Context, in *AddFirewallRule227Request, opts ...dcerpc.CallOption) (*AddFirewallRule227Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddFirewallRule227Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) SetFirewallRule227(ctx context.Context, in *SetFirewallRule227Request, opts ...dcerpc.CallOption) (*SetFirewallRule227Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetFirewallRule227Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) EnumFirewallRules227(ctx context.Context, in *EnumFirewallRules227Request, opts ...dcerpc.CallOption) (*EnumFirewallRules227Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumFirewallRules227Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) QueryFirewallRules227(ctx context.Context, in *QueryFirewallRules227Request, opts ...dcerpc.CallOption) (*QueryFirewallRules227Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &QueryFirewallRules227Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) AddFirewallRule231(ctx context.Context, in *AddFirewallRule231Request, opts ...dcerpc.CallOption) (*AddFirewallRule231Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddFirewallRule231Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) SetFirewallRule231(ctx context.Context, in *SetFirewallRule231Request, opts ...dcerpc.CallOption) (*SetFirewallRule231Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetFirewallRule231Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) EnumFirewallRules231(ctx context.Context, in *EnumFirewallRules231Request, opts ...dcerpc.CallOption) (*EnumFirewallRules231Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumFirewallRules231Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) QueryFirewallRules231(ctx context.Context, in *QueryFirewallRules231Request, opts ...dcerpc.CallOption) (*QueryFirewallRules231Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &QueryFirewallRules231Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultRemoteFwClient) AlterContext(ctx context.Context, opts ...dcerpc.Option) error {
	return o.cc.AlterContext(ctx, opts...)
}

func (o *xxx_DefaultRemoteFwClient) Conn() dcerpc.Conn {
	return o.cc
}

func NewRemoteFwClient(ctx context.Context, cc dcerpc.Conn, opts ...dcerpc.Option) (RemoteFwClient, error) {
	cc, err := cc.Bind(ctx, append(opts, dcerpc.WithAbstractSyntax(RemoteFwSyntaxV1_0))...)
	if err != nil {
		return nil, err
	}
	return &xxx_DefaultRemoteFwClient{cc: cc}, nil
}

// xxx_OpenPolicyStoreOperation structure represents the RRPC_FWOpenPolicyStore operation
type xxx_OpenPolicyStoreOperation struct {
	BinaryVersion uint16                 `idl:"name:BinaryVersion" json:"binary_version"`
	StoreType     fasp.StoreType         `idl:"name:StoreType" json:"store_type"`
	AccessRight   fasp.PolicyAccessRight `idl:"name:AccessRight" json:"access_right"`
	Flags         uint32                 `idl:"name:dwFlags" json:"flags"`
	PolicyStore   *PolicyStore           `idl:"name:phPolicyStore" json:"policy_store"`
	Return        uint32                 `idl:"name:Return" json:"return"`
}

func (o *xxx_OpenPolicyStoreOperation) OpNum() int { return 0 }

func (o *xxx_OpenPolicyStoreOperation) OpName() string { return "/RemoteFW/v1/RRPC_FWOpenPolicyStore" }

func (o *xxx_OpenPolicyStoreOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.StoreType < fasp.StoreType(1) || o.StoreType > fasp.StoreType(11) {
		return fmt.Errorf("StoreType is out of range")
	}
	if o.AccessRight < fasp.PolicyAccessRight(1) || o.AccessRight > fasp.PolicyAccessRight(2) {
		return fmt.Errorf("AccessRight is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenPolicyStoreOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// BinaryVersion {in} (1:{alias=WORD}(uint16))
	{
		if err := w.WriteData(o.BinaryVersion); err != nil {
			return err
		}
	}
	// StoreType {in} (1:{range=(1,11), alias=FW_STORE_TYPE}(enum))
	{
		if err := w.WriteEnum(uint16(o.StoreType)); err != nil {
			return err
		}
	}
	// AccessRight {in} (1:{range=(1,2), alias=FW_POLICY_ACCESS_RIGHT}(enum))
	{
		if err := w.WriteEnum(uint16(o.AccessRight)); err != nil {
			return err
		}
	}
	// dwFlags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenPolicyStoreOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// BinaryVersion {in} (1:{alias=WORD}(uint16))
	{
		if err := w.ReadData(&o.BinaryVersion); err != nil {
			return err
		}
	}
	// StoreType {in} (1:{range=(1,11), alias=FW_STORE_TYPE}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.StoreType)); err != nil {
			return err
		}
	}
	// AccessRight {in} (1:{range=(1,2), alias=FW_POLICY_ACCESS_RIGHT}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.AccessRight)); err != nil {
			return err
		}
	}
	// dwFlags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenPolicyStoreOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenPolicyStoreOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// phPolicyStore {out} (1:{pointer=ref, alias=PFW_POLICY_STORE_HANDLE}*(1))(2:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_OpenPolicyStoreOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// phPolicyStore {out} (1:{pointer=ref, alias=PFW_POLICY_STORE_HANDLE}*(1))(2:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// OpenPolicyStoreRequest structure represents the RRPC_FWOpenPolicyStore operation request
type OpenPolicyStoreRequest struct {
	// BinaryVersion: This parameter specifies the RPC interface binary version. This implies
	// versions of the methods and versions of the structures. This value MUST be a valid
	// protocol Version (see section 1.7 for capability negotiation details and section
	// 2.2.42 for translating Protocol versions to binary and schema versions).
	BinaryVersion uint16 `idl:"name:BinaryVersion" json:"binary_version"`
	// StoreType: This parameter specifies the policy store type that the client wants to
	// open.
	StoreType fasp.StoreType `idl:"name:StoreType" json:"store_type"`
	// AccessRight: This parameter specifies the read or read/write access rights that the
	// client is requesting on the store.
	AccessRight fasp.PolicyAccessRight `idl:"name:AccessRight" json:"access_right"`
	// dwFlags: This parameter is not used. The server MUST ignore this parameter. The client
	// SHOULD pass a value of zero.
	Flags uint32 `idl:"name:dwFlags" json:"flags"`
}

func (o *OpenPolicyStoreRequest) xxx_ToOp(ctx context.Context, op *xxx_OpenPolicyStoreOperation) *xxx_OpenPolicyStoreOperation {
	if op == nil {
		op = &xxx_OpenPolicyStoreOperation{}
	}
	if o == nil {
		return op
	}
	op.BinaryVersion = o.BinaryVersion
	op.StoreType = o.StoreType
	op.AccessRight = o.AccessRight
	op.Flags = o.Flags
	return op
}

func (o *OpenPolicyStoreRequest) xxx_FromOp(ctx context.Context, op *xxx_OpenPolicyStoreOperation) {
	if o == nil {
		return
	}
	o.BinaryVersion = op.BinaryVersion
	o.StoreType = op.StoreType
	o.AccessRight = op.AccessRight
	o.Flags = op.Flags
}
func (o *OpenPolicyStoreRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *OpenPolicyStoreRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenPolicyStoreOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// OpenPolicyStoreResponse structure represents the RRPC_FWOpenPolicyStore operation response
type OpenPolicyStoreResponse struct {
	// phPolicyStore: This is an output parameter that provides a pointer to an FW_POLICY_STORE_HANDLE
	// data type. If successful, this parameter contains a handle to the opened store.
	PolicyStore *PolicyStore `idl:"name:phPolicyStore" json:"policy_store"`
	// Return: The RRPC_FWOpenPolicyStore return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *OpenPolicyStoreResponse) xxx_ToOp(ctx context.Context, op *xxx_OpenPolicyStoreOperation) *xxx_OpenPolicyStoreOperation {
	if op == nil {
		op = &xxx_OpenPolicyStoreOperation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Return = o.Return
	return op
}

func (o *OpenPolicyStoreResponse) xxx_FromOp(ctx context.Context, op *xxx_OpenPolicyStoreOperation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Return = op.Return
}
func (o *OpenPolicyStoreResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *OpenPolicyStoreResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_OpenPolicyStoreOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ClosePolicyStoreOperation structure represents the RRPC_FWClosePolicyStore operation
type xxx_ClosePolicyStoreOperation struct {
	PolicyStore *PolicyStore `idl:"name:phPolicyStore" json:"policy_store"`
	Return      uint32       `idl:"name:Return" json:"return"`
}

func (o *xxx_ClosePolicyStoreOperation) OpNum() int { return 1 }

func (o *xxx_ClosePolicyStoreOperation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWClosePolicyStore"
}

func (o *xxx_ClosePolicyStoreOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ClosePolicyStoreOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// phPolicyStore {in, out} (1:{pointer=ref, alias=PFW_POLICY_STORE_HANDLE}*(1))(2:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_ClosePolicyStoreOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// phPolicyStore {in, out} (1:{pointer=ref, alias=PFW_POLICY_STORE_HANDLE}*(1))(2:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ClosePolicyStoreOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ClosePolicyStoreOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// phPolicyStore {in, out} (1:{pointer=ref, alias=PFW_POLICY_STORE_HANDLE}*(1))(2:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ClosePolicyStoreOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// phPolicyStore {in, out} (1:{pointer=ref, alias=PFW_POLICY_STORE_HANDLE}*(1))(2:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ClosePolicyStoreRequest structure represents the RRPC_FWClosePolicyStore operation request
type ClosePolicyStoreRequest struct {
	// phPolicyStore: This is an input and output parameter that provides a pointer to an
	// FW_POLICY_STORE_HANDLE data type. The data type MUST contain an opened policy store
	// handle, successfully opened with the RRPC_FWOpenPolicyStore (Opnum 0) method, which
	// the client intends to stop using and close.
	PolicyStore *PolicyStore `idl:"name:phPolicyStore" json:"policy_store"`
}

func (o *ClosePolicyStoreRequest) xxx_ToOp(ctx context.Context, op *xxx_ClosePolicyStoreOperation) *xxx_ClosePolicyStoreOperation {
	if op == nil {
		op = &xxx_ClosePolicyStoreOperation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	return op
}

func (o *ClosePolicyStoreRequest) xxx_FromOp(ctx context.Context, op *xxx_ClosePolicyStoreOperation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
}
func (o *ClosePolicyStoreRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *ClosePolicyStoreRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ClosePolicyStoreOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ClosePolicyStoreResponse structure represents the RRPC_FWClosePolicyStore operation response
type ClosePolicyStoreResponse struct {
	// phPolicyStore: This is an input and output parameter that provides a pointer to an
	// FW_POLICY_STORE_HANDLE data type. The data type MUST contain an opened policy store
	// handle, successfully opened with the RRPC_FWOpenPolicyStore (Opnum 0) method, which
	// the client intends to stop using and close.
	PolicyStore *PolicyStore `idl:"name:phPolicyStore" json:"policy_store"`
	// Return: The RRPC_FWClosePolicyStore return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ClosePolicyStoreResponse) xxx_ToOp(ctx context.Context, op *xxx_ClosePolicyStoreOperation) *xxx_ClosePolicyStoreOperation {
	if op == nil {
		op = &xxx_ClosePolicyStoreOperation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Return = o.Return
	return op
}

func (o *ClosePolicyStoreResponse) xxx_FromOp(ctx context.Context, op *xxx_ClosePolicyStoreOperation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Return = op.Return
}
func (o *ClosePolicyStoreResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *ClosePolicyStoreResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ClosePolicyStoreOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_RestoreDefaultsOperation structure represents the RRPC_FWRestoreDefaults operation
type xxx_RestoreDefaultsOperation struct {
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_RestoreDefaultsOperation) OpNum() int { return 2 }

func (o *xxx_RestoreDefaultsOperation) OpName() string { return "/RemoteFW/v1/RRPC_FWRestoreDefaults" }

func (o *xxx_RestoreDefaultsOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RestoreDefaultsOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	return nil
}

func (o *xxx_RestoreDefaultsOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	return nil
}

func (o *xxx_RestoreDefaultsOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RestoreDefaultsOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RestoreDefaultsOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// RestoreDefaultsRequest structure represents the RRPC_FWRestoreDefaults operation request
type RestoreDefaultsRequest struct {
}

func (o *RestoreDefaultsRequest) xxx_ToOp(ctx context.Context, op *xxx_RestoreDefaultsOperation) *xxx_RestoreDefaultsOperation {
	if op == nil {
		op = &xxx_RestoreDefaultsOperation{}
	}
	if o == nil {
		return op
	}
	return op
}

func (o *RestoreDefaultsRequest) xxx_FromOp(ctx context.Context, op *xxx_RestoreDefaultsOperation) {
	if o == nil {
		return
	}
}
func (o *RestoreDefaultsRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *RestoreDefaultsRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RestoreDefaultsOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// RestoreDefaultsResponse structure represents the RRPC_FWRestoreDefaults operation response
type RestoreDefaultsResponse struct {
	// Return: The RRPC_FWRestoreDefaults return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *RestoreDefaultsResponse) xxx_ToOp(ctx context.Context, op *xxx_RestoreDefaultsOperation) *xxx_RestoreDefaultsOperation {
	if op == nil {
		op = &xxx_RestoreDefaultsOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *RestoreDefaultsResponse) xxx_FromOp(ctx context.Context, op *xxx_RestoreDefaultsOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *RestoreDefaultsResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *RestoreDefaultsResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RestoreDefaultsOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetGlobalConfigOperation structure represents the RRPC_FWGetGlobalConfig operation
type xxx_GetGlobalConfigOperation struct {
	BinaryVersion     uint16            `idl:"name:BinaryVersion" json:"binary_version"`
	StoreType         fasp.StoreType    `idl:"name:StoreType" json:"store_type"`
	ConfigID          fasp.GlobalConfig `idl:"name:configID" json:"config_id"`
	Flags             uint32            `idl:"name:dwFlags" json:"flags"`
	Buffer            []byte            `idl:"name:pBuffer;size_is:(cbData);length_is:(pcbTransmittedLen);pointer:unique" json:"buffer"`
	DataLength        uint32            `idl:"name:cbData" json:"data_length"`
	TransmittedLength uint32            `idl:"name:pcbTransmittedLen" json:"transmitted_length"`
	RequiredLength    uint32            `idl:"name:pcbRequired" json:"required_length"`
	Return            uint32            `idl:"name:Return" json:"return"`
}

func (o *xxx_GetGlobalConfigOperation) OpNum() int { return 3 }

func (o *xxx_GetGlobalConfigOperation) OpName() string { return "/RemoteFW/v1/RRPC_FWGetGlobalConfig" }

func (o *xxx_GetGlobalConfigOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.Buffer != nil && o.DataLength == 0 {
		o.DataLength = uint32(len(o.Buffer))
	}
	if o.Buffer != nil && o.TransmittedLength == 0 {
		o.TransmittedLength = uint32(len(o.Buffer))
	}
	if o.ConfigID < fasp.GlobalConfig(1) || o.ConfigID > fasp.GlobalConfig(17) {
		return fmt.Errorf("ConfigID is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetGlobalConfigOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// BinaryVersion {in} (1:{alias=WORD}(uint16))
	{
		if err := w.WriteData(o.BinaryVersion); err != nil {
			return err
		}
	}
	// StoreType {in} (1:{alias=FW_STORE_TYPE}(enum))
	{
		if err := w.WriteEnum(uint16(o.StoreType)); err != nil {
			return err
		}
	}
	// configID {in} (1:{range=(1,17), alias=FW_GLOBAL_CONFIG}(enum))
	{
		if err := w.WriteEnum(uint16(o.ConfigID)); err != nil {
			return err
		}
	}
	// dwFlags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	// pBuffer {in, out} (1:{pointer=unique}*(1))(2:{alias=BYTE}[dim:0,size_is=cbData,length_is=pcbTransmittedLen](uchar))
	{
		if o.Buffer != nil || o.DataLength > 0 {
			_ptr_pBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.DataLength)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				dimLength1 := uint64(o.TransmittedLength)
				if dimLength1 > sizeInfo[0] {
					dimLength1 = sizeInfo[0]
				} else {
					sizeInfo[0] = dimLength1
				}
				if err := w.WriteSize(0); err != nil {
					return err
				}
				if err := w.WriteSize(dimLength1); err != nil {
					return err
				}
				for i1 := range o.Buffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Buffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Buffer, _ptr_pBuffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// cbData {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DataLength); err != nil {
			return err
		}
	}
	// pcbTransmittedLen {in, out} (1:{alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.TransmittedLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetGlobalConfigOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// BinaryVersion {in} (1:{alias=WORD}(uint16))
	{
		if err := w.ReadData(&o.BinaryVersion); err != nil {
			return err
		}
	}
	// StoreType {in} (1:{alias=FW_STORE_TYPE}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.StoreType)); err != nil {
			return err
		}
	}
	// configID {in} (1:{range=(1,17), alias=FW_GLOBAL_CONFIG}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.ConfigID)); err != nil {
			return err
		}
	}
	// dwFlags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	// pBuffer {in, out} (1:{pointer=unique}*(1))(2:{alias=BYTE}[dim:0,size_is=cbData,length_is=pcbTransmittedLen](uchar))
	{
		_ptr_pBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
			}
			o.Buffer = make([]byte, sizeInfo[0])
			for i1 := range o.Buffer {
				i1 := i1
				if err := w.ReadData(&o.Buffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_pBuffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Buffer, _s_pBuffer, _ptr_pBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// cbData {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DataLength); err != nil {
			return err
		}
	}
	// pcbTransmittedLen {in, out} (1:{alias=LPDWORD,pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.TransmittedLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetGlobalConfigOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Buffer != nil && o.TransmittedLength == 0 {
		o.TransmittedLength = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetGlobalConfigOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pBuffer {in, out} (1:{pointer=unique}*(1))(2:{alias=BYTE}[dim:0,size_is=cbData,length_is=pcbTransmittedLen](uchar))
	{
		if o.Buffer != nil || o.DataLength > 0 {
			_ptr_pBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.DataLength)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				dimLength1 := uint64(o.TransmittedLength)
				if dimLength1 > sizeInfo[0] {
					dimLength1 = sizeInfo[0]
				} else {
					sizeInfo[0] = dimLength1
				}
				if err := w.WriteSize(0); err != nil {
					return err
				}
				if err := w.WriteSize(dimLength1); err != nil {
					return err
				}
				for i1 := range o.Buffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Buffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Buffer, _ptr_pBuffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// pcbTransmittedLen {in, out} (1:{alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.TransmittedLength); err != nil {
			return err
		}
	}
	// pcbRequired {out} (1:{alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RequiredLength); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetGlobalConfigOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pBuffer {in, out} (1:{pointer=unique}*(1))(2:{alias=BYTE}[dim:0,size_is=cbData,length_is=pcbTransmittedLen](uchar))
	{
		_ptr_pBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
			}
			o.Buffer = make([]byte, sizeInfo[0])
			for i1 := range o.Buffer {
				i1 := i1
				if err := w.ReadData(&o.Buffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_pBuffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Buffer, _s_pBuffer, _ptr_pBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// pcbTransmittedLen {in, out} (1:{alias=LPDWORD,pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.TransmittedLength); err != nil {
			return err
		}
	}
	// pcbRequired {out} (1:{alias=LPDWORD,pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RequiredLength); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetGlobalConfigRequest structure represents the RRPC_FWGetGlobalConfig operation request
type GetGlobalConfigRequest struct {
	// BinaryVersion: This parameter specifies the RPC interface binary version. This implies
	// versions of the methods and versions of the structures.
	BinaryVersion uint16 `idl:"name:BinaryVersion" json:"binary_version"`
	// StoreType: This parameter specifies the policy store from which the client wants
	// to retrieve the configuration option value.
	StoreType fasp.StoreType `idl:"name:StoreType" json:"store_type"`
	// configID: This parameter specifies the specific global policy configuration option
	// the client is interested in retrieving.
	ConfigID fasp.GlobalConfig `idl:"name:configID" json:"config_id"`
	// dwFlags: This parameter is a combination of flags from the FW_CONFIG_FLAGS enumeration,
	// which modifies the behavior of this method, as specified in the definition of the
	// enumeration.
	Flags uint32 `idl:"name:dwFlags" json:"flags"`
	// pBuffer: This is an input/output parameter. This parameter is a pointer to the buffer
	// that the client provides to contain the value of the profile configuration option
	// being requested.
	Buffer []byte `idl:"name:pBuffer;size_is:(cbData);length_is:(pcbTransmittedLen);pointer:unique" json:"buffer"`
	// cbData: This parameter is the size of the buffer that the pBuffer parameter points
	// to.
	DataLength uint32 `idl:"name:cbData" json:"data_length"`
	// pcbTransmittedLen: This is a pointer to an input and output parameter that specifies
	// the length of the transmitted data within the buffer.
	TransmittedLength uint32 `idl:"name:pcbTransmittedLen" json:"transmitted_length"`
}

func (o *GetGlobalConfigRequest) xxx_ToOp(ctx context.Context, op *xxx_GetGlobalConfigOperation) *xxx_GetGlobalConfigOperation {
	if op == nil {
		op = &xxx_GetGlobalConfigOperation{}
	}
	if o == nil {
		return op
	}
	op.BinaryVersion = o.BinaryVersion
	op.StoreType = o.StoreType
	op.ConfigID = o.ConfigID
	op.Flags = o.Flags
	op.Buffer = o.Buffer
	op.DataLength = o.DataLength
	op.TransmittedLength = o.TransmittedLength
	return op
}

func (o *GetGlobalConfigRequest) xxx_FromOp(ctx context.Context, op *xxx_GetGlobalConfigOperation) {
	if o == nil {
		return
	}
	o.BinaryVersion = op.BinaryVersion
	o.StoreType = op.StoreType
	o.ConfigID = op.ConfigID
	o.Flags = op.Flags
	o.Buffer = op.Buffer
	o.DataLength = op.DataLength
	o.TransmittedLength = op.TransmittedLength
}
func (o *GetGlobalConfigRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetGlobalConfigRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetGlobalConfigOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetGlobalConfigResponse structure represents the RRPC_FWGetGlobalConfig operation response
type GetGlobalConfigResponse struct {
	// XXX: cbData is an implicit input depedency for output parameters
	DataLength uint32 `idl:"name:cbData" json:"data_length"`

	// pBuffer: This is an input/output parameter. This parameter is a pointer to the buffer
	// that the client provides to contain the value of the profile configuration option
	// being requested.
	Buffer []byte `idl:"name:pBuffer;size_is:(cbData);length_is:(pcbTransmittedLen);pointer:unique" json:"buffer"`
	// pcbTransmittedLen: This is a pointer to an input and output parameter that specifies
	// the length of the transmitted data within the buffer.
	TransmittedLength uint32 `idl:"name:pcbTransmittedLen" json:"transmitted_length"`
	// pcbRequired: This is a pointer to an output parameter that specifies the required
	// minimum buffer size in octets in order for the method to be able to return the configuration
	// value. This output parameter is nonzero only if the buffer (pointed to by pBuffer
	// and whose size is cbData) was not big enough to contain the value.
	RequiredLength uint32 `idl:"name:pcbRequired" json:"required_length"`
	// Return: The RRPC_FWGetGlobalConfig return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetGlobalConfigResponse) xxx_ToOp(ctx context.Context, op *xxx_GetGlobalConfigOperation) *xxx_GetGlobalConfigOperation {
	if op == nil {
		op = &xxx_GetGlobalConfigOperation{}
	}
	if o == nil {
		return op
	}
	// XXX: implicit input dependencies for output parameters
	if op.DataLength == uint32(0) {
		op.DataLength = o.DataLength
	}

	op.Buffer = o.Buffer
	op.TransmittedLength = o.TransmittedLength
	op.RequiredLength = o.RequiredLength
	op.Return = o.Return
	return op
}

func (o *GetGlobalConfigResponse) xxx_FromOp(ctx context.Context, op *xxx_GetGlobalConfigOperation) {
	if o == nil {
		return
	}
	// XXX: implicit input dependencies for output parameters
	o.DataLength = op.DataLength

	o.Buffer = op.Buffer
	o.TransmittedLength = op.TransmittedLength
	o.RequiredLength = op.RequiredLength
	o.Return = op.Return
}
func (o *GetGlobalConfigResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetGlobalConfigResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetGlobalConfigOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetGlobalConfigOperation structure represents the RRPC_FWSetGlobalConfig operation
type xxx_SetGlobalConfigOperation struct {
	BinaryVersion uint16            `idl:"name:BinaryVersion" json:"binary_version"`
	StoreType     fasp.StoreType    `idl:"name:StoreType" json:"store_type"`
	ConfigID      fasp.GlobalConfig `idl:"name:configID" json:"config_id"`
	Buffer        []byte            `idl:"name:lpBuffer;size_is:(dwBufSize);pointer:unique" json:"buffer"`
	BufferSize    uint32            `idl:"name:dwBufSize" json:"buffer_size"`
	Return        uint32            `idl:"name:Return" json:"return"`
}

func (o *xxx_SetGlobalConfigOperation) OpNum() int { return 4 }

func (o *xxx_SetGlobalConfigOperation) OpName() string { return "/RemoteFW/v1/RRPC_FWSetGlobalConfig" }

func (o *xxx_SetGlobalConfigOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.Buffer != nil && o.BufferSize == 0 {
		o.BufferSize = uint32(len(o.Buffer))
	}
	if o.ConfigID < fasp.GlobalConfig(1) || o.ConfigID > fasp.GlobalConfig(17) {
		return fmt.Errorf("ConfigID is out of range")
	}
	if o.BufferSize > uint32(10240) {
		return fmt.Errorf("BufferSize is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetGlobalConfigOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// BinaryVersion {in} (1:{alias=WORD}(uint16))
	{
		if err := w.WriteData(o.BinaryVersion); err != nil {
			return err
		}
	}
	// StoreType {in} (1:{alias=FW_STORE_TYPE}(enum))
	{
		if err := w.WriteEnum(uint16(o.StoreType)); err != nil {
			return err
		}
	}
	// configID {in} (1:{range=(1,17), alias=FW_GLOBAL_CONFIG}(enum))
	{
		if err := w.WriteEnum(uint16(o.ConfigID)); err != nil {
			return err
		}
	}
	// lpBuffer {in} (1:{pointer=unique}*(1))(2:{alias=BYTE}[dim:0,size_is=dwBufSize](uchar))
	{
		if o.Buffer != nil || o.BufferSize > 0 {
			_ptr_lpBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.BufferSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Buffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Buffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Buffer, _ptr_lpBuffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// dwBufSize {in} (1:{range=(0,10240), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetGlobalConfigOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// BinaryVersion {in} (1:{alias=WORD}(uint16))
	{
		if err := w.ReadData(&o.BinaryVersion); err != nil {
			return err
		}
	}
	// StoreType {in} (1:{alias=FW_STORE_TYPE}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.StoreType)); err != nil {
			return err
		}
	}
	// configID {in} (1:{range=(1,17), alias=FW_GLOBAL_CONFIG}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.ConfigID)); err != nil {
			return err
		}
	}
	// lpBuffer {in} (1:{pointer=unique}*(1))(2:{alias=BYTE}[dim:0,size_is=dwBufSize](uchar))
	{
		_ptr_lpBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
			}
			o.Buffer = make([]byte, sizeInfo[0])
			for i1 := range o.Buffer {
				i1 := i1
				if err := w.ReadData(&o.Buffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_lpBuffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Buffer, _s_lpBuffer, _ptr_lpBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// dwBufSize {in} (1:{range=(0,10240), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetGlobalConfigOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetGlobalConfigOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetGlobalConfigOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetGlobalConfigRequest structure represents the RRPC_FWSetGlobalConfig operation request
type SetGlobalConfigRequest struct {
	// BinaryVersion: This parameter specifies the RPC interface binary version. This implies
	// versions of the methods and versions of the structures.
	BinaryVersion uint16 `idl:"name:BinaryVersion" json:"binary_version"`
	// StoreType: This parameter specifies the policy store in which the client wants to
	// modify this configuration option.
	StoreType fasp.StoreType `idl:"name:StoreType" json:"store_type"`
	// configID: This parameter specifies the specific global policy configuration option
	// the client wants to modify.
	ConfigID fasp.GlobalConfig `idl:"name:configID" json:"config_id"`
	// lpBuffer: This is an input parameter. This parameter is a pointer to the buffer that
	// the client provides containing the value to write on the configuration option specified.
	// If the buffer is NULL, this method deletes the configuration option.
	Buffer []byte `idl:"name:lpBuffer;size_is:(dwBufSize);pointer:unique" json:"buffer"`
	// dwBufSize: This parameter is the size of the buffer to which the lpBuffer parameter
	// points.
	BufferSize uint32 `idl:"name:dwBufSize" json:"buffer_size"`
}

func (o *SetGlobalConfigRequest) xxx_ToOp(ctx context.Context, op *xxx_SetGlobalConfigOperation) *xxx_SetGlobalConfigOperation {
	if op == nil {
		op = &xxx_SetGlobalConfigOperation{}
	}
	if o == nil {
		return op
	}
	op.BinaryVersion = o.BinaryVersion
	op.StoreType = o.StoreType
	op.ConfigID = o.ConfigID
	op.Buffer = o.Buffer
	op.BufferSize = o.BufferSize
	return op
}

func (o *SetGlobalConfigRequest) xxx_FromOp(ctx context.Context, op *xxx_SetGlobalConfigOperation) {
	if o == nil {
		return
	}
	o.BinaryVersion = op.BinaryVersion
	o.StoreType = op.StoreType
	o.ConfigID = op.ConfigID
	o.Buffer = op.Buffer
	o.BufferSize = op.BufferSize
}
func (o *SetGlobalConfigRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetGlobalConfigRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetGlobalConfigOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetGlobalConfigResponse structure represents the RRPC_FWSetGlobalConfig operation response
type SetGlobalConfigResponse struct {
	// Return: The RRPC_FWSetGlobalConfig return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetGlobalConfigResponse) xxx_ToOp(ctx context.Context, op *xxx_SetGlobalConfigOperation) *xxx_SetGlobalConfigOperation {
	if op == nil {
		op = &xxx_SetGlobalConfigOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetGlobalConfigResponse) xxx_FromOp(ctx context.Context, op *xxx_SetGlobalConfigOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetGlobalConfigResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetGlobalConfigResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetGlobalConfigOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddFirewallRuleOperation structure represents the RRPC_FWAddFirewallRule operation
type xxx_AddFirewallRuleOperation struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	Rule        *fasp.Rule20 `idl:"name:pRule" json:"rule"`
	Return      uint32       `idl:"name:Return" json:"return"`
}

func (o *xxx_AddFirewallRuleOperation) OpNum() int { return 5 }

func (o *xxx_AddFirewallRuleOperation) OpName() string { return "/RemoteFW/v1/RRPC_FWAddFirewallRule" }

func (o *xxx_AddFirewallRuleOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFirewallRuleOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pRule {in} (1:{alias=PFW_RULE2_0}*(1))(2:{alias=FW_RULE2_0}(struct))
	{
		if o.Rule != nil {
			if err := o.Rule.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.Rule20{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFirewallRuleOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pRule {in} (1:{alias=PFW_RULE2_0,pointer=ref}*(1))(2:{alias=FW_RULE2_0}(struct))
	{
		if o.Rule == nil {
			o.Rule = &fasp.Rule20{}
		}
		if err := o.Rule.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFirewallRuleOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFirewallRuleOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFirewallRuleOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddFirewallRuleRequest structure represents the RRPC_FWAddFirewallRule operation request
type AddFirewallRuleRequest struct {
	// hPolicyStore: This input parameter is an FW_POLICY_STORE_HANDLE data type. The data
	// type MUST contain an opened policy store handle that is successfully opened by using
	// the RRPC_FWOpenPolicyStore (Opnum 0) method. The handle MUST have read/write access
	// rights.
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pRule: This parameter represents the firewall rule that the client wants to add to
	// the store. The rule MUST be a valid rule, as specified in the definition of the FW_RULE2_0
	// data type.
	Rule *fasp.Rule20 `idl:"name:pRule" json:"rule"`
}

func (o *AddFirewallRuleRequest) xxx_ToOp(ctx context.Context, op *xxx_AddFirewallRuleOperation) *xxx_AddFirewallRuleOperation {
	if op == nil {
		op = &xxx_AddFirewallRuleOperation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Rule = o.Rule
	return op
}

func (o *AddFirewallRuleRequest) xxx_FromOp(ctx context.Context, op *xxx_AddFirewallRuleOperation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Rule = op.Rule
}
func (o *AddFirewallRuleRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *AddFirewallRuleRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddFirewallRuleOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddFirewallRuleResponse structure represents the RRPC_FWAddFirewallRule operation response
type AddFirewallRuleResponse struct {
	// Return: The RRPC_FWAddFirewallRule return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddFirewallRuleResponse) xxx_ToOp(ctx context.Context, op *xxx_AddFirewallRuleOperation) *xxx_AddFirewallRuleOperation {
	if op == nil {
		op = &xxx_AddFirewallRuleOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *AddFirewallRuleResponse) xxx_FromOp(ctx context.Context, op *xxx_AddFirewallRuleOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *AddFirewallRuleResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *AddFirewallRuleResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddFirewallRuleOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetFirewallRuleOperation structure represents the RRPC_FWSetFirewallRule operation
type xxx_SetFirewallRuleOperation struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	Rule        *fasp.Rule20 `idl:"name:pRule" json:"rule"`
	Return      uint32       `idl:"name:Return" json:"return"`
}

func (o *xxx_SetFirewallRuleOperation) OpNum() int { return 6 }

func (o *xxx_SetFirewallRuleOperation) OpName() string { return "/RemoteFW/v1/RRPC_FWSetFirewallRule" }

func (o *xxx_SetFirewallRuleOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFirewallRuleOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pRule {in} (1:{alias=PFW_RULE2_0}*(1))(2:{alias=FW_RULE2_0}(struct))
	{
		if o.Rule != nil {
			if err := o.Rule.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.Rule20{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFirewallRuleOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pRule {in} (1:{alias=PFW_RULE2_0,pointer=ref}*(1))(2:{alias=FW_RULE2_0}(struct))
	{
		if o.Rule == nil {
			o.Rule = &fasp.Rule20{}
		}
		if err := o.Rule.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFirewallRuleOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFirewallRuleOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFirewallRuleOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetFirewallRuleRequest structure represents the RRPC_FWSetFirewallRule operation request
type SetFirewallRuleRequest struct {
	// hPolicyStore: This input parameter is an FW_POLICY_STORE_HANDLE data type. The data
	// type MUST contain an opened policy store handle that is successfully opened by using
	// the RRPC_FWOpenPolicyStore (Opnum 0) method. The handle MUST have read/write access
	// rights.
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pRule: This parameter represents the firewall rule that the client wants to modify
	// in the store. The rule MUST be a valid rule, as specified in the definition of the
	// FW_RULE2_0 data type.
	Rule *fasp.Rule20 `idl:"name:pRule" json:"rule"`
}

func (o *SetFirewallRuleRequest) xxx_ToOp(ctx context.Context, op *xxx_SetFirewallRuleOperation) *xxx_SetFirewallRuleOperation {
	if op == nil {
		op = &xxx_SetFirewallRuleOperation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Rule = o.Rule
	return op
}

func (o *SetFirewallRuleRequest) xxx_FromOp(ctx context.Context, op *xxx_SetFirewallRuleOperation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Rule = op.Rule
}
func (o *SetFirewallRuleRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetFirewallRuleRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetFirewallRuleOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetFirewallRuleResponse structure represents the RRPC_FWSetFirewallRule operation response
type SetFirewallRuleResponse struct {
	// Return: The RRPC_FWSetFirewallRule return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetFirewallRuleResponse) xxx_ToOp(ctx context.Context, op *xxx_SetFirewallRuleOperation) *xxx_SetFirewallRuleOperation {
	if op == nil {
		op = &xxx_SetFirewallRuleOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetFirewallRuleResponse) xxx_FromOp(ctx context.Context, op *xxx_SetFirewallRuleOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetFirewallRuleResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetFirewallRuleResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetFirewallRuleOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_DeleteFirewallRuleOperation structure represents the RRPC_FWDeleteFirewallRule operation
type xxx_DeleteFirewallRuleOperation struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	RuleID      string       `idl:"name:wszRuleID;string;pointer:ref" json:"rule_id"`
	Return      uint32       `idl:"name:Return" json:"return"`
}

func (o *xxx_DeleteFirewallRuleOperation) OpNum() int { return 7 }

func (o *xxx_DeleteFirewallRuleOperation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWDeleteFirewallRule"
}

func (o *xxx_DeleteFirewallRuleOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteFirewallRuleOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// wszRuleID {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.RuleID); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteFirewallRuleOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// wszRuleID {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.RuleID); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteFirewallRuleOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteFirewallRuleOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteFirewallRuleOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// DeleteFirewallRuleRequest structure represents the RRPC_FWDeleteFirewallRule operation request
type DeleteFirewallRuleRequest struct {
	// hPolicyStore: This input parameter is an FW_POLICY_STORE_HANDLE data type. The data
	// type MUST contain an opened policy store handle, successfully opened with the RRPC_FWOpenPolicyStore
	// (Opnum 0) method. The handle MUST have read/write access rights.
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// wszRuleID: This parameter is the pointer to a string that is the ID of the firewall
	// rule the client wants to delete from the specified store.
	RuleID string `idl:"name:wszRuleID;string;pointer:ref" json:"rule_id"`
}

func (o *DeleteFirewallRuleRequest) xxx_ToOp(ctx context.Context, op *xxx_DeleteFirewallRuleOperation) *xxx_DeleteFirewallRuleOperation {
	if op == nil {
		op = &xxx_DeleteFirewallRuleOperation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.RuleID = o.RuleID
	return op
}

func (o *DeleteFirewallRuleRequest) xxx_FromOp(ctx context.Context, op *xxx_DeleteFirewallRuleOperation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.RuleID = op.RuleID
}
func (o *DeleteFirewallRuleRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *DeleteFirewallRuleRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteFirewallRuleOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// DeleteFirewallRuleResponse structure represents the RRPC_FWDeleteFirewallRule operation response
type DeleteFirewallRuleResponse struct {
	// Return: The RRPC_FWDeleteFirewallRule return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *DeleteFirewallRuleResponse) xxx_ToOp(ctx context.Context, op *xxx_DeleteFirewallRuleOperation) *xxx_DeleteFirewallRuleOperation {
	if op == nil {
		op = &xxx_DeleteFirewallRuleOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *DeleteFirewallRuleResponse) xxx_FromOp(ctx context.Context, op *xxx_DeleteFirewallRuleOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *DeleteFirewallRuleResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *DeleteFirewallRuleResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteFirewallRuleOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_DeleteAllFirewallRulesOperation structure represents the RRPC_FWDeleteAllFirewallRules operation
type xxx_DeleteAllFirewallRulesOperation struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	Return      uint32       `idl:"name:Return" json:"return"`
}

func (o *xxx_DeleteAllFirewallRulesOperation) OpNum() int { return 8 }

func (o *xxx_DeleteAllFirewallRulesOperation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWDeleteAllFirewallRules"
}

func (o *xxx_DeleteAllFirewallRulesOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteAllFirewallRulesOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_DeleteAllFirewallRulesOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteAllFirewallRulesOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteAllFirewallRulesOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteAllFirewallRulesOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// DeleteAllFirewallRulesRequest structure represents the RRPC_FWDeleteAllFirewallRules operation request
type DeleteAllFirewallRulesRequest struct {
	// hPolicyStore: This input parameter is an FW_POLICY_STORE_HANDLE data type. The data
	// type MUST contain an opened policy store handle, successfully opened with the RRPC_FWOpenPolicyStore
	// (Opnum 0) method. The handle MUST have read/write access rights.
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
}

func (o *DeleteAllFirewallRulesRequest) xxx_ToOp(ctx context.Context, op *xxx_DeleteAllFirewallRulesOperation) *xxx_DeleteAllFirewallRulesOperation {
	if op == nil {
		op = &xxx_DeleteAllFirewallRulesOperation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	return op
}

func (o *DeleteAllFirewallRulesRequest) xxx_FromOp(ctx context.Context, op *xxx_DeleteAllFirewallRulesOperation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
}
func (o *DeleteAllFirewallRulesRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *DeleteAllFirewallRulesRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteAllFirewallRulesOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// DeleteAllFirewallRulesResponse structure represents the RRPC_FWDeleteAllFirewallRules operation response
type DeleteAllFirewallRulesResponse struct {
	// Return: The RRPC_FWDeleteAllFirewallRules return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *DeleteAllFirewallRulesResponse) xxx_ToOp(ctx context.Context, op *xxx_DeleteAllFirewallRulesOperation) *xxx_DeleteAllFirewallRulesOperation {
	if op == nil {
		op = &xxx_DeleteAllFirewallRulesOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *DeleteAllFirewallRulesResponse) xxx_FromOp(ctx context.Context, op *xxx_DeleteAllFirewallRulesOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *DeleteAllFirewallRulesResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *DeleteAllFirewallRulesResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteAllFirewallRulesOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumFirewallRulesOperation structure represents the RRPC_FWEnumFirewallRules operation
type xxx_EnumFirewallRulesOperation struct {
	PolicyStore      *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	FilteredByStatus uint32       `idl:"name:dwFilteredByStatus" json:"filtered_by_status"`
	ProfileFilter    uint32       `idl:"name:dwProfileFilter" json:"profile_filter"`
	Flags            uint16       `idl:"name:wFlags" json:"flags"`
	RulesLength      uint32       `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	Rules            *fasp.Rule20 `idl:"name:ppRules" json:"rules"`
	Return           uint32       `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumFirewallRulesOperation) OpNum() int { return 9 }

func (o *xxx_EnumFirewallRulesOperation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWEnumFirewallRules"
}

func (o *xxx_EnumFirewallRulesOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFirewallRulesOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwFilteredByStatus {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.FilteredByStatus); err != nil {
			return err
		}
	}
	// dwProfileFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ProfileFilter); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFirewallRulesOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwFilteredByStatus {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.FilteredByStatus); err != nil {
			return err
		}
	}
	// dwProfileFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ProfileFilter); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFirewallRulesOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFirewallRulesOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RulesLength); err != nil {
			return err
		}
	}
	// ppRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_RULE2_0}*(1))(3:{alias=FW_RULE2_0}(struct))
	{
		if o.Rules != nil {
			_ptr_ppRules := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Rules != nil {
					if err := o.Rules.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&fasp.Rule20{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Rules, _ptr_ppRules); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFirewallRulesOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RulesLength); err != nil {
			return err
		}
	}
	// ppRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_RULE2_0,pointer=ref}*(1))(3:{alias=FW_RULE2_0}(struct))
	{
		_ptr_ppRules := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Rules == nil {
				o.Rules = &fasp.Rule20{}
			}
			if err := o.Rules.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ppRules := func(ptr interface{}) { o.Rules = *ptr.(**fasp.Rule20) }
		if err := w.ReadPointer(&o.Rules, _s_ppRules, _ptr_ppRules); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumFirewallRulesRequest structure represents the RRPC_FWEnumFirewallRules operation request
type EnumFirewallRulesRequest struct {
	// hPolicyStore: This input parameter is an FW_POLICY_STORE_HANDLE data type. The data
	// type MUST contain an opened policy store handle that is successfully opened by using
	// the RRPC_FWOpenPolicyStore (Opnum 0) method. The handle MUST have read or read/write
	// access rights.
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// dwFilteredByStatus: This parameter is a combination of flags from the FW_RULE_STATUS_CLASS
	// enumeration. This method uses this bitmask to determine which rules will be returned.
	// Rules that contain a status code from the class specified by this parameter will
	// be returned in the linked list.
	FilteredByStatus uint32 `idl:"name:dwFilteredByStatus" json:"filtered_by_status"`
	// dwProfileFilter: This parameter is a combination of flags from the FW_PROFILE_TYPE
	// enumeration. This method also uses this parameter to determine which rules will be
	// returned. Rules that contain a profile specified by this parameter will be returned
	// in the linked list.
	ProfileFilter uint32 `idl:"name:dwProfileFilter" json:"profile_filter"`
	// wFlags: This parameter is a combination of flags from the FW_ENUM_RULES_FLAGS enumeration,
	// which modifies the behavior of the method and performs operations on the rules before
	// returning them in the linked list.
	Flags uint16 `idl:"name:wFlags" json:"flags"`
}

func (o *EnumFirewallRulesRequest) xxx_ToOp(ctx context.Context, op *xxx_EnumFirewallRulesOperation) *xxx_EnumFirewallRulesOperation {
	if op == nil {
		op = &xxx_EnumFirewallRulesOperation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.FilteredByStatus = o.FilteredByStatus
	op.ProfileFilter = o.ProfileFilter
	op.Flags = o.Flags
	return op
}

func (o *EnumFirewallRulesRequest) xxx_FromOp(ctx context.Context, op *xxx_EnumFirewallRulesOperation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.FilteredByStatus = op.FilteredByStatus
	o.ProfileFilter = op.ProfileFilter
	o.Flags = op.Flags
}
func (o *EnumFirewallRulesRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumFirewallRulesRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumFirewallRulesOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumFirewallRulesResponse structure represents the RRPC_FWEnumFirewallRules operation response
type EnumFirewallRulesResponse struct {
	// pdwNumRules: This output parameter, if successful, MUST be equal to the number of
	// rules returned.
	RulesLength uint32 `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	// ppRules: This output parameter, if successful, contains a linked list of FW_RULE2_0
	// data types.
	Rules *fasp.Rule20 `idl:"name:ppRules" json:"rules"`
	// Return: The RRPC_FWEnumFirewallRules return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumFirewallRulesResponse) xxx_ToOp(ctx context.Context, op *xxx_EnumFirewallRulesOperation) *xxx_EnumFirewallRulesOperation {
	if op == nil {
		op = &xxx_EnumFirewallRulesOperation{}
	}
	if o == nil {
		return op
	}
	op.RulesLength = o.RulesLength
	op.Rules = o.Rules
	op.Return = o.Return
	return op
}

func (o *EnumFirewallRulesResponse) xxx_FromOp(ctx context.Context, op *xxx_EnumFirewallRulesOperation) {
	if o == nil {
		return
	}
	o.RulesLength = op.RulesLength
	o.Rules = op.Rules
	o.Return = op.Return
}
func (o *EnumFirewallRulesResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumFirewallRulesResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumFirewallRulesOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetConfigOperation structure represents the RRPC_FWGetConfig operation
type xxx_GetConfigOperation struct {
	PolicyStore       *PolicyStore       `idl:"name:hPolicyStore" json:"policy_store"`
	ConfigID          fasp.ProfileConfig `idl:"name:configID" json:"config_id"`
	Profile           fasp.ProfileType   `idl:"name:Profile" json:"profile"`
	Flags             uint32             `idl:"name:dwFlags" json:"flags"`
	Buffer            []byte             `idl:"name:pBuffer;size_is:(cbData);length_is:(pcbTransmittedLen);pointer:unique" json:"buffer"`
	DataLength        uint32             `idl:"name:cbData" json:"data_length"`
	TransmittedLength uint32             `idl:"name:pcbTransmittedLen" json:"transmitted_length"`
	RequiredLength    uint32             `idl:"name:pcbRequired" json:"required_length"`
	Return            uint32             `idl:"name:Return" json:"return"`
}

func (o *xxx_GetConfigOperation) OpNum() int { return 10 }

func (o *xxx_GetConfigOperation) OpName() string { return "/RemoteFW/v1/RRPC_FWGetConfig" }

func (o *xxx_GetConfigOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.Buffer != nil && o.DataLength == 0 {
		o.DataLength = uint32(len(o.Buffer))
	}
	if o.Buffer != nil && o.TransmittedLength == 0 {
		o.TransmittedLength = uint32(len(o.Buffer))
	}
	if o.ConfigID < fasp.ProfileConfig(1) || o.ConfigID > fasp.ProfileConfig(18) {
		return fmt.Errorf("ConfigID is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetConfigOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// configID {in} (1:{range=(1,18), alias=FW_PROFILE_CONFIG}(enum))
	{
		if err := w.WriteEnum(uint16(o.ConfigID)); err != nil {
			return err
		}
	}
	// Profile {in} (1:{v1_enum, alias=FW_PROFILE_TYPE}(enum))
	{
		if err := w.WriteEnum(uint32(o.Profile)); err != nil {
			return err
		}
	}
	// dwFlags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	// pBuffer {in, out} (1:{pointer=unique}*(1))(2:{alias=BYTE}[dim:0,size_is=cbData,length_is=pcbTransmittedLen](uchar))
	{
		if o.Buffer != nil || o.DataLength > 0 {
			_ptr_pBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.DataLength)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				dimLength1 := uint64(o.TransmittedLength)
				if dimLength1 > sizeInfo[0] {
					dimLength1 = sizeInfo[0]
				} else {
					sizeInfo[0] = dimLength1
				}
				if err := w.WriteSize(0); err != nil {
					return err
				}
				if err := w.WriteSize(dimLength1); err != nil {
					return err
				}
				for i1 := range o.Buffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Buffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Buffer, _ptr_pBuffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// cbData {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DataLength); err != nil {
			return err
		}
	}
	// pcbTransmittedLen {in, out} (1:{alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.TransmittedLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetConfigOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// configID {in} (1:{range=(1,18), alias=FW_PROFILE_CONFIG}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.ConfigID)); err != nil {
			return err
		}
	}
	// Profile {in} (1:{v1_enum, alias=FW_PROFILE_TYPE}(enum))
	{
		if err := w.ReadEnum((*uint32)(&o.Profile)); err != nil {
			return err
		}
	}
	// dwFlags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	// pBuffer {in, out} (1:{pointer=unique}*(1))(2:{alias=BYTE}[dim:0,size_is=cbData,length_is=pcbTransmittedLen](uchar))
	{
		_ptr_pBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
			}
			o.Buffer = make([]byte, sizeInfo[0])
			for i1 := range o.Buffer {
				i1 := i1
				if err := w.ReadData(&o.Buffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_pBuffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Buffer, _s_pBuffer, _ptr_pBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// cbData {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DataLength); err != nil {
			return err
		}
	}
	// pcbTransmittedLen {in, out} (1:{alias=LPDWORD,pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.TransmittedLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetConfigOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Buffer != nil && o.TransmittedLength == 0 {
		o.TransmittedLength = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetConfigOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pBuffer {in, out} (1:{pointer=unique}*(1))(2:{alias=BYTE}[dim:0,size_is=cbData,length_is=pcbTransmittedLen](uchar))
	{
		if o.Buffer != nil || o.DataLength > 0 {
			_ptr_pBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.DataLength)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				dimLength1 := uint64(o.TransmittedLength)
				if dimLength1 > sizeInfo[0] {
					dimLength1 = sizeInfo[0]
				} else {
					sizeInfo[0] = dimLength1
				}
				if err := w.WriteSize(0); err != nil {
					return err
				}
				if err := w.WriteSize(dimLength1); err != nil {
					return err
				}
				for i1 := range o.Buffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Buffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Buffer, _ptr_pBuffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// pcbTransmittedLen {in, out} (1:{alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.TransmittedLength); err != nil {
			return err
		}
	}
	// pcbRequired {out} (1:{alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RequiredLength); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetConfigOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pBuffer {in, out} (1:{pointer=unique}*(1))(2:{alias=BYTE}[dim:0,size_is=cbData,length_is=pcbTransmittedLen](uchar))
	{
		_ptr_pBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
			}
			o.Buffer = make([]byte, sizeInfo[0])
			for i1 := range o.Buffer {
				i1 := i1
				if err := w.ReadData(&o.Buffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_pBuffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Buffer, _s_pBuffer, _ptr_pBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// pcbTransmittedLen {in, out} (1:{alias=LPDWORD,pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.TransmittedLength); err != nil {
			return err
		}
	}
	// pcbRequired {out} (1:{alias=LPDWORD,pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RequiredLength); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetConfigRequest structure represents the RRPC_FWGetConfig operation request
type GetConfigRequest struct {
	// hPolicyStore: This input parameter is an FW_POLICY_STORE_HANDLE data type. The data
	// type MUST contain an opened policy store handle, successfully opened with the RRPC_FWOpenPolicyStore
	// (Opnum 0) method. The handle MUST have read/write access rights.
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// configID: This parameter specifies the specific profile configuration option the
	// client is interested in retrieving.
	ConfigID fasp.ProfileConfig `idl:"name:configID" json:"config_id"`
	// Profile: This parameter specifies from which specific profile this value MUST be
	// retrieved.
	Profile fasp.ProfileType `idl:"name:Profile" json:"profile"`
	// dwFlags: This parameter is a combination of flags from the FW_CONFIG_FLAGS enumeration,
	// which modifies the behavior of this method, as specified in the definition of the
	// enumeration.
	Flags uint32 `idl:"name:dwFlags" json:"flags"`
	// pBuffer: This is an input/output parameter. This parameter is a pointer to the buffer
	// that the client provides to contain the value of the profile configuration option
	// being requested.
	Buffer []byte `idl:"name:pBuffer;size_is:(cbData);length_is:(pcbTransmittedLen);pointer:unique" json:"buffer"`
	// cbData: This parameter is the size of the buffer that the pBuffer parameter points
	// to.
	DataLength uint32 `idl:"name:cbData" json:"data_length"`
	// pcbTransmittedLen: This is a pointer to an input and output parameter that specifies
	// the length of the transmitted data within the buffer.
	TransmittedLength uint32 `idl:"name:pcbTransmittedLen" json:"transmitted_length"`
}

func (o *GetConfigRequest) xxx_ToOp(ctx context.Context, op *xxx_GetConfigOperation) *xxx_GetConfigOperation {
	if op == nil {
		op = &xxx_GetConfigOperation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.ConfigID = o.ConfigID
	op.Profile = o.Profile
	op.Flags = o.Flags
	op.Buffer = o.Buffer
	op.DataLength = o.DataLength
	op.TransmittedLength = o.TransmittedLength
	return op
}

func (o *GetConfigRequest) xxx_FromOp(ctx context.Context, op *xxx_GetConfigOperation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.ConfigID = op.ConfigID
	o.Profile = op.Profile
	o.Flags = op.Flags
	o.Buffer = op.Buffer
	o.DataLength = op.DataLength
	o.TransmittedLength = op.TransmittedLength
}
func (o *GetConfigRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetConfigRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetConfigOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetConfigResponse structure represents the RRPC_FWGetConfig operation response
type GetConfigResponse struct {
	// XXX: cbData is an implicit input depedency for output parameters
	DataLength uint32 `idl:"name:cbData" json:"data_length"`

	// pBuffer: This is an input/output parameter. This parameter is a pointer to the buffer
	// that the client provides to contain the value of the profile configuration option
	// being requested.
	Buffer []byte `idl:"name:pBuffer;size_is:(cbData);length_is:(pcbTransmittedLen);pointer:unique" json:"buffer"`
	// pcbTransmittedLen: This is a pointer to an input and output parameter that specifies
	// the length of the transmitted data within the buffer.
	TransmittedLength uint32 `idl:"name:pcbTransmittedLen" json:"transmitted_length"`
	// pcbRequired: This is a pointer to an output parameter that specifies the required
	// minimum buffer size in octets for the method to be able to return the configuration
	// value. This output parameter is nonzero only if the buffer (pointed to by pBuffer
	// and whose size is cbData) was not big enough to contain the value.
	RequiredLength uint32 `idl:"name:pcbRequired" json:"required_length"`
	// Return: The RRPC_FWGetConfig return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetConfigResponse) xxx_ToOp(ctx context.Context, op *xxx_GetConfigOperation) *xxx_GetConfigOperation {
	if op == nil {
		op = &xxx_GetConfigOperation{}
	}
	if o == nil {
		return op
	}
	// XXX: implicit input dependencies for output parameters
	if op.DataLength == uint32(0) {
		op.DataLength = o.DataLength
	}

	op.Buffer = o.Buffer
	op.TransmittedLength = o.TransmittedLength
	op.RequiredLength = o.RequiredLength
	op.Return = o.Return
	return op
}

func (o *GetConfigResponse) xxx_FromOp(ctx context.Context, op *xxx_GetConfigOperation) {
	if o == nil {
		return
	}
	// XXX: implicit input dependencies for output parameters
	o.DataLength = op.DataLength

	o.Buffer = op.Buffer
	o.TransmittedLength = op.TransmittedLength
	o.RequiredLength = op.RequiredLength
	o.Return = op.Return
}
func (o *GetConfigResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetConfigResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetConfigOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetConfigOperation structure represents the RRPC_FWSetConfig operation
type xxx_SetConfigOperation struct {
	PolicyStore *PolicyStore             `idl:"name:hPolicyStore" json:"policy_store"`
	ConfigID    fasp.ProfileConfig       `idl:"name:configID" json:"config_id"`
	Profile     fasp.ProfileType         `idl:"name:Profile" json:"profile"`
	Config      *fasp.ProfileConfigValue `idl:"name:pConfig;switch_is:configID" json:"config"`
	BufferSize  uint32                   `idl:"name:dwBufSize" json:"buffer_size"`
	Return      uint32                   `idl:"name:Return" json:"return"`
}

func (o *xxx_SetConfigOperation) OpNum() int { return 11 }

func (o *xxx_SetConfigOperation) OpName() string { return "/RemoteFW/v1/RRPC_FWSetConfig" }

func (o *xxx_SetConfigOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.ConfigID < fasp.ProfileConfig(1) || o.ConfigID > fasp.ProfileConfig(18) {
		return fmt.Errorf("ConfigID is out of range")
	}
	if o.BufferSize > uint32(10240) {
		return fmt.Errorf("BufferSize is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetConfigOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// configID {in} (1:{range=(1,18), alias=FW_PROFILE_CONFIG}(enum))
	{
		if err := w.WriteEnum(uint16(o.ConfigID)); err != nil {
			return err
		}
	}
	// Profile {in} (1:{v1_enum, alias=FW_PROFILE_TYPE}(enum))
	{
		if err := w.WriteEnum(uint32(o.Profile)); err != nil {
			return err
		}
	}
	// pConfig {in} (1:{switch_type={alias=FW_PROFILE_CONFIG}(enum), alias=FW_PROFILE_CONFIG_VALUE}(union))
	{
		_swConfig := uint16(o.ConfigID)
		if o.Config != nil {
			if err := o.Config.MarshalUnionNDR(ctx, w, _swConfig); err != nil {
				return err
			}
		} else {
			if err := (&fasp.ProfileConfigValue{}).MarshalUnionNDR(ctx, w, _swConfig); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// dwBufSize {in} (1:{range=(0,10240), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetConfigOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// configID {in} (1:{range=(1,18), alias=FW_PROFILE_CONFIG}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.ConfigID)); err != nil {
			return err
		}
	}
	// Profile {in} (1:{v1_enum, alias=FW_PROFILE_TYPE}(enum))
	{
		if err := w.ReadEnum((*uint32)(&o.Profile)); err != nil {
			return err
		}
	}
	// pConfig {in} (1:{switch_type={alias=FW_PROFILE_CONFIG}(enum), alias=FW_PROFILE_CONFIG_VALUE}(union))
	{
		if o.Config == nil {
			o.Config = &fasp.ProfileConfigValue{}
		}
		_swConfig := uint16(o.ConfigID)
		if err := o.Config.UnmarshalUnionNDR(ctx, w, _swConfig); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// dwBufSize {in} (1:{range=(0,10240), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetConfigOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetConfigOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetConfigOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetConfigRequest structure represents the RRPC_FWSetConfig operation request
type SetConfigRequest struct {
	// hPolicyStore: This input parameter is an FW_POLICY_STORE_HANDLE data type. The data
	// type MUST contain an opened policy store handle, successfully opened with the RRPC_FWOpenPolicyStore
	// (Opnum 0) method. The handle MUST have read/write access rights.
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// configID: This parameter specifies the specific profile configuration option the
	// client wants to modify.
	ConfigID fasp.ProfileConfig `idl:"name:configID" json:"config_id"`
	// Profile: This parameter specifies in which specific profile this value MUST be written.
	Profile fasp.ProfileType `idl:"name:Profile" json:"profile"`
	// pConfig: This is an input parameter. This parameter is a pointer to the buffer that
	// the client provides containing the value to write on the configuration option specified.
	// If the buffer is NULL, this method deletes the configuration option. The buffer is
	// of type FW_PROFILE_CONFIG_VALUE.
	Config *fasp.ProfileConfigValue `idl:"name:pConfig;switch_is:configID" json:"config"`
	// dwBufSize: This parameter is the size of the buffer that the pConfig parameter points
	// to.
	BufferSize uint32 `idl:"name:dwBufSize" json:"buffer_size"`
}

func (o *SetConfigRequest) xxx_ToOp(ctx context.Context, op *xxx_SetConfigOperation) *xxx_SetConfigOperation {
	if op == nil {
		op = &xxx_SetConfigOperation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.ConfigID = o.ConfigID
	op.Profile = o.Profile
	op.Config = o.Config
	op.BufferSize = o.BufferSize
	return op
}

func (o *SetConfigRequest) xxx_FromOp(ctx context.Context, op *xxx_SetConfigOperation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.ConfigID = op.ConfigID
	o.Profile = op.Profile
	o.Config = op.Config
	o.BufferSize = op.BufferSize
}
func (o *SetConfigRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetConfigRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetConfigOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetConfigResponse structure represents the RRPC_FWSetConfig operation response
type SetConfigResponse struct {
	// Return: The RRPC_FWSetConfig return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetConfigResponse) xxx_ToOp(ctx context.Context, op *xxx_SetConfigOperation) *xxx_SetConfigOperation {
	if op == nil {
		op = &xxx_SetConfigOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetConfigResponse) xxx_FromOp(ctx context.Context, op *xxx_SetConfigOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetConfigResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetConfigResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetConfigOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddConnectionSecurityRuleOperation structure represents the RRPC_FWAddConnectionSecurityRule operation
type xxx_AddConnectionSecurityRuleOperation struct {
	PolicyStore *PolicyStore   `idl:"name:hPolicyStore" json:"policy_store"`
	Rule        *fasp.CSRule20 `idl:"name:pRule" json:"rule"`
	Return      uint32         `idl:"name:Return" json:"return"`
}

func (o *xxx_AddConnectionSecurityRuleOperation) OpNum() int { return 12 }

func (o *xxx_AddConnectionSecurityRuleOperation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWAddConnectionSecurityRule"
}

func (o *xxx_AddConnectionSecurityRuleOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddConnectionSecurityRuleOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pRule {in} (1:{alias=PFW_CS_RULE2_0}*(1))(2:{alias=FW_CS_RULE2_0}(struct))
	{
		if o.Rule != nil {
			if err := o.Rule.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.CSRule20{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddConnectionSecurityRuleOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pRule {in} (1:{alias=PFW_CS_RULE2_0,pointer=ref}*(1))(2:{alias=FW_CS_RULE2_0}(struct))
	{
		if o.Rule == nil {
			o.Rule = &fasp.CSRule20{}
		}
		if err := o.Rule.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddConnectionSecurityRuleOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddConnectionSecurityRuleOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddConnectionSecurityRuleOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddConnectionSecurityRuleRequest structure represents the RRPC_FWAddConnectionSecurityRule operation request
type AddConnectionSecurityRuleRequest struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pRule: This parameter represents the connection security rule that the client wants
	// to add to the store. The rule MUST be a valid rule, as specified in the definition
	// of the FW_CS_RULE2_0 data type.
	Rule *fasp.CSRule20 `idl:"name:pRule" json:"rule"`
}

func (o *AddConnectionSecurityRuleRequest) xxx_ToOp(ctx context.Context, op *xxx_AddConnectionSecurityRuleOperation) *xxx_AddConnectionSecurityRuleOperation {
	if op == nil {
		op = &xxx_AddConnectionSecurityRuleOperation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Rule = o.Rule
	return op
}

func (o *AddConnectionSecurityRuleRequest) xxx_FromOp(ctx context.Context, op *xxx_AddConnectionSecurityRuleOperation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Rule = op.Rule
}
func (o *AddConnectionSecurityRuleRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *AddConnectionSecurityRuleRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddConnectionSecurityRuleOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddConnectionSecurityRuleResponse structure represents the RRPC_FWAddConnectionSecurityRule operation response
type AddConnectionSecurityRuleResponse struct {
	// Return: The RRPC_FWAddConnectionSecurityRule return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddConnectionSecurityRuleResponse) xxx_ToOp(ctx context.Context, op *xxx_AddConnectionSecurityRuleOperation) *xxx_AddConnectionSecurityRuleOperation {
	if op == nil {
		op = &xxx_AddConnectionSecurityRuleOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *AddConnectionSecurityRuleResponse) xxx_FromOp(ctx context.Context, op *xxx_AddConnectionSecurityRuleOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *AddConnectionSecurityRuleResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *AddConnectionSecurityRuleResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddConnectionSecurityRuleOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetConnectionSecurityRuleOperation structure represents the RRPC_FWSetConnectionSecurityRule operation
type xxx_SetConnectionSecurityRuleOperation struct {
	PolicyStore *PolicyStore   `idl:"name:hPolicyStore" json:"policy_store"`
	Rule        *fasp.CSRule20 `idl:"name:pRule" json:"rule"`
	Return      uint32         `idl:"name:Return" json:"return"`
}

func (o *xxx_SetConnectionSecurityRuleOperation) OpNum() int { return 13 }

func (o *xxx_SetConnectionSecurityRuleOperation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWSetConnectionSecurityRule"
}

func (o *xxx_SetConnectionSecurityRuleOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetConnectionSecurityRuleOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pRule {in} (1:{alias=PFW_CS_RULE2_0}*(1))(2:{alias=FW_CS_RULE2_0}(struct))
	{
		if o.Rule != nil {
			if err := o.Rule.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.CSRule20{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetConnectionSecurityRuleOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pRule {in} (1:{alias=PFW_CS_RULE2_0,pointer=ref}*(1))(2:{alias=FW_CS_RULE2_0}(struct))
	{
		if o.Rule == nil {
			o.Rule = &fasp.CSRule20{}
		}
		if err := o.Rule.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetConnectionSecurityRuleOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetConnectionSecurityRuleOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetConnectionSecurityRuleOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetConnectionSecurityRuleRequest structure represents the RRPC_FWSetConnectionSecurityRule operation request
type SetConnectionSecurityRuleRequest struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pRule: This parameter represents the connection security rule that the client wants
	// to modify in the store. The rule MUST be a valid rule, as specified in the definition
	// of the FW_CS_RULE2_0 data type.
	Rule *fasp.CSRule20 `idl:"name:pRule" json:"rule"`
}

func (o *SetConnectionSecurityRuleRequest) xxx_ToOp(ctx context.Context, op *xxx_SetConnectionSecurityRuleOperation) *xxx_SetConnectionSecurityRuleOperation {
	if op == nil {
		op = &xxx_SetConnectionSecurityRuleOperation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Rule = o.Rule
	return op
}

func (o *SetConnectionSecurityRuleRequest) xxx_FromOp(ctx context.Context, op *xxx_SetConnectionSecurityRuleOperation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Rule = op.Rule
}
func (o *SetConnectionSecurityRuleRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetConnectionSecurityRuleRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetConnectionSecurityRuleOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetConnectionSecurityRuleResponse structure represents the RRPC_FWSetConnectionSecurityRule operation response
type SetConnectionSecurityRuleResponse struct {
	// Return: The RRPC_FWSetConnectionSecurityRule return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetConnectionSecurityRuleResponse) xxx_ToOp(ctx context.Context, op *xxx_SetConnectionSecurityRuleOperation) *xxx_SetConnectionSecurityRuleOperation {
	if op == nil {
		op = &xxx_SetConnectionSecurityRuleOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetConnectionSecurityRuleResponse) xxx_FromOp(ctx context.Context, op *xxx_SetConnectionSecurityRuleOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetConnectionSecurityRuleResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetConnectionSecurityRuleResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetConnectionSecurityRuleOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_DeleteConnectionSecurityRuleOperation structure represents the RRPC_FWDeleteConnectionSecurityRule operation
type xxx_DeleteConnectionSecurityRuleOperation struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	RuleID      string       `idl:"name:pRuleId;string;pointer:ref" json:"rule_id"`
	Return      uint32       `idl:"name:Return" json:"return"`
}

func (o *xxx_DeleteConnectionSecurityRuleOperation) OpNum() int { return 14 }

func (o *xxx_DeleteConnectionSecurityRuleOperation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWDeleteConnectionSecurityRule"
}

func (o *xxx_DeleteConnectionSecurityRuleOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteConnectionSecurityRuleOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pRuleId {in} (1:{string, pointer=ref, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.RuleID); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteConnectionSecurityRuleOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pRuleId {in} (1:{string, pointer=ref, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.RuleID); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteConnectionSecurityRuleOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteConnectionSecurityRuleOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteConnectionSecurityRuleOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// DeleteConnectionSecurityRuleRequest structure represents the RRPC_FWDeleteConnectionSecurityRule operation request
type DeleteConnectionSecurityRuleRequest struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pRuleId: This parameter is the pointer to a string that is the ID of the connection
	// security rule the client wants to delete from the specified store.
	RuleID string `idl:"name:pRuleId;string;pointer:ref" json:"rule_id"`
}

func (o *DeleteConnectionSecurityRuleRequest) xxx_ToOp(ctx context.Context, op *xxx_DeleteConnectionSecurityRuleOperation) *xxx_DeleteConnectionSecurityRuleOperation {
	if op == nil {
		op = &xxx_DeleteConnectionSecurityRuleOperation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.RuleID = o.RuleID
	return op
}

func (o *DeleteConnectionSecurityRuleRequest) xxx_FromOp(ctx context.Context, op *xxx_DeleteConnectionSecurityRuleOperation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.RuleID = op.RuleID
}
func (o *DeleteConnectionSecurityRuleRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *DeleteConnectionSecurityRuleRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteConnectionSecurityRuleOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// DeleteConnectionSecurityRuleResponse structure represents the RRPC_FWDeleteConnectionSecurityRule operation response
type DeleteConnectionSecurityRuleResponse struct {
	// Return: The RRPC_FWDeleteConnectionSecurityRule return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *DeleteConnectionSecurityRuleResponse) xxx_ToOp(ctx context.Context, op *xxx_DeleteConnectionSecurityRuleOperation) *xxx_DeleteConnectionSecurityRuleOperation {
	if op == nil {
		op = &xxx_DeleteConnectionSecurityRuleOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *DeleteConnectionSecurityRuleResponse) xxx_FromOp(ctx context.Context, op *xxx_DeleteConnectionSecurityRuleOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *DeleteConnectionSecurityRuleResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *DeleteConnectionSecurityRuleResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteConnectionSecurityRuleOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_DeleteAllConnectionSecurityRulesOperation structure represents the RRPC_FWDeleteAllConnectionSecurityRules operation
type xxx_DeleteAllConnectionSecurityRulesOperation struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	Return      uint32       `idl:"name:Return" json:"return"`
}

func (o *xxx_DeleteAllConnectionSecurityRulesOperation) OpNum() int { return 15 }

func (o *xxx_DeleteAllConnectionSecurityRulesOperation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWDeleteAllConnectionSecurityRules"
}

func (o *xxx_DeleteAllConnectionSecurityRulesOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteAllConnectionSecurityRulesOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_DeleteAllConnectionSecurityRulesOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteAllConnectionSecurityRulesOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteAllConnectionSecurityRulesOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteAllConnectionSecurityRulesOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// DeleteAllConnectionSecurityRulesRequest structure represents the RRPC_FWDeleteAllConnectionSecurityRules operation request
type DeleteAllConnectionSecurityRulesRequest struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
}

func (o *DeleteAllConnectionSecurityRulesRequest) xxx_ToOp(ctx context.Context, op *xxx_DeleteAllConnectionSecurityRulesOperation) *xxx_DeleteAllConnectionSecurityRulesOperation {
	if op == nil {
		op = &xxx_DeleteAllConnectionSecurityRulesOperation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	return op
}

func (o *DeleteAllConnectionSecurityRulesRequest) xxx_FromOp(ctx context.Context, op *xxx_DeleteAllConnectionSecurityRulesOperation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
}
func (o *DeleteAllConnectionSecurityRulesRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *DeleteAllConnectionSecurityRulesRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteAllConnectionSecurityRulesOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// DeleteAllConnectionSecurityRulesResponse structure represents the RRPC_FWDeleteAllConnectionSecurityRules operation response
type DeleteAllConnectionSecurityRulesResponse struct {
	// Return: The RRPC_FWDeleteAllConnectionSecurityRules return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *DeleteAllConnectionSecurityRulesResponse) xxx_ToOp(ctx context.Context, op *xxx_DeleteAllConnectionSecurityRulesOperation) *xxx_DeleteAllConnectionSecurityRulesOperation {
	if op == nil {
		op = &xxx_DeleteAllConnectionSecurityRulesOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *DeleteAllConnectionSecurityRulesResponse) xxx_FromOp(ctx context.Context, op *xxx_DeleteAllConnectionSecurityRulesOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *DeleteAllConnectionSecurityRulesResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *DeleteAllConnectionSecurityRulesResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteAllConnectionSecurityRulesOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumConnectionSecurityRulesOperation structure represents the RRPC_FWEnumConnectionSecurityRules operation
type xxx_EnumConnectionSecurityRulesOperation struct {
	PolicyStore      *PolicyStore   `idl:"name:hPolicyStore" json:"policy_store"`
	FilteredByStatus uint32         `idl:"name:dwFilteredByStatus" json:"filtered_by_status"`
	ProfileFilter    uint32         `idl:"name:dwProfileFilter" json:"profile_filter"`
	Flags            uint16         `idl:"name:wFlags" json:"flags"`
	RulesLength      uint32         `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	Rules            *fasp.CSRule20 `idl:"name:ppRules" json:"rules"`
	Return           uint32         `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumConnectionSecurityRulesOperation) OpNum() int { return 16 }

func (o *xxx_EnumConnectionSecurityRulesOperation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWEnumConnectionSecurityRules"
}

func (o *xxx_EnumConnectionSecurityRulesOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumConnectionSecurityRulesOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwFilteredByStatus {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.FilteredByStatus); err != nil {
			return err
		}
	}
	// dwProfileFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ProfileFilter); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumConnectionSecurityRulesOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwFilteredByStatus {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.FilteredByStatus); err != nil {
			return err
		}
	}
	// dwProfileFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ProfileFilter); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumConnectionSecurityRulesOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumConnectionSecurityRulesOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RulesLength); err != nil {
			return err
		}
	}
	// ppRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_CS_RULE2_0}*(1))(3:{alias=FW_CS_RULE2_0}(struct))
	{
		if o.Rules != nil {
			_ptr_ppRules := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Rules != nil {
					if err := o.Rules.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&fasp.CSRule20{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Rules, _ptr_ppRules); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumConnectionSecurityRulesOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RulesLength); err != nil {
			return err
		}
	}
	// ppRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_CS_RULE2_0,pointer=ref}*(1))(3:{alias=FW_CS_RULE2_0}(struct))
	{
		_ptr_ppRules := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Rules == nil {
				o.Rules = &fasp.CSRule20{}
			}
			if err := o.Rules.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ppRules := func(ptr interface{}) { o.Rules = *ptr.(**fasp.CSRule20) }
		if err := w.ReadPointer(&o.Rules, _s_ppRules, _ptr_ppRules); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumConnectionSecurityRulesRequest structure represents the RRPC_FWEnumConnectionSecurityRules operation request
type EnumConnectionSecurityRulesRequest struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// dwFilteredByStatus: This parameter is a combination of flags from the FW_RULE_STATUS_CLASS
	// enumeration. This method uses this bitmask to determine which rules will be returned.
	// Rules that contain a status code from the class that is specified by this parameter
	// will be returned in the linked list.
	FilteredByStatus uint32 `idl:"name:dwFilteredByStatus" json:"filtered_by_status"`
	// dwProfileFilter: This parameter is a combination of flags from the FW_PROFILE_TYPE
	// enumeration. This method also uses this parameter to determine which rules will be
	// returned. Rules that contain a profile that is specified by this parameter will be
	// returned in the linked list.
	ProfileFilter uint32 `idl:"name:dwProfileFilter" json:"profile_filter"`
	// wFlags: This parameter is a combination of flags from the FW_ENUM_RULES_FLAGS enumeration,
	// which modifies the behavior of the method and performs operations on the rules before
	// returning them in the linked list.
	Flags uint16 `idl:"name:wFlags" json:"flags"`
}

func (o *EnumConnectionSecurityRulesRequest) xxx_ToOp(ctx context.Context, op *xxx_EnumConnectionSecurityRulesOperation) *xxx_EnumConnectionSecurityRulesOperation {
	if op == nil {
		op = &xxx_EnumConnectionSecurityRulesOperation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.FilteredByStatus = o.FilteredByStatus
	op.ProfileFilter = o.ProfileFilter
	op.Flags = o.Flags
	return op
}

func (o *EnumConnectionSecurityRulesRequest) xxx_FromOp(ctx context.Context, op *xxx_EnumConnectionSecurityRulesOperation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.FilteredByStatus = op.FilteredByStatus
	o.ProfileFilter = op.ProfileFilter
	o.Flags = op.Flags
}
func (o *EnumConnectionSecurityRulesRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumConnectionSecurityRulesRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumConnectionSecurityRulesOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumConnectionSecurityRulesResponse structure represents the RRPC_FWEnumConnectionSecurityRules operation response
type EnumConnectionSecurityRulesResponse struct {
	// pdwNumRules: This output parameter, if successful, MUST be equal to the number of
	// rules returned.
	RulesLength uint32 `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	// ppRules: This output parameter, if successful, contains a linked list of FW_CS_RULE2_0
	// data types.
	Rules *fasp.CSRule20 `idl:"name:ppRules" json:"rules"`
	// Return: The RRPC_FWEnumConnectionSecurityRules return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumConnectionSecurityRulesResponse) xxx_ToOp(ctx context.Context, op *xxx_EnumConnectionSecurityRulesOperation) *xxx_EnumConnectionSecurityRulesOperation {
	if op == nil {
		op = &xxx_EnumConnectionSecurityRulesOperation{}
	}
	if o == nil {
		return op
	}
	op.RulesLength = o.RulesLength
	op.Rules = o.Rules
	op.Return = o.Return
	return op
}

func (o *EnumConnectionSecurityRulesResponse) xxx_FromOp(ctx context.Context, op *xxx_EnumConnectionSecurityRulesOperation) {
	if o == nil {
		return
	}
	o.RulesLength = op.RulesLength
	o.Rules = op.Rules
	o.Return = op.Return
}
func (o *EnumConnectionSecurityRulesResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumConnectionSecurityRulesResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumConnectionSecurityRulesOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddAuthenticationSetOperation structure represents the RRPC_FWAddAuthenticationSet operation
type xxx_AddAuthenticationSetOperation struct {
	PolicyStore *PolicyStore     `idl:"name:hPolicyStore" json:"policy_store"`
	Auth        *fasp.AuthSet210 `idl:"name:pAuth" json:"auth"`
	Return      uint32           `idl:"name:Return" json:"return"`
}

func (o *xxx_AddAuthenticationSetOperation) OpNum() int { return 17 }

func (o *xxx_AddAuthenticationSetOperation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWAddAuthenticationSet"
}

func (o *xxx_AddAuthenticationSetOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddAuthenticationSetOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pAuth {in} (1:{alias=PFW_AUTH_SET2_10}*(1))(2:{alias=FW_AUTH_SET2_10}(struct))
	{
		if o.Auth != nil {
			if err := o.Auth.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.AuthSet210{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddAuthenticationSetOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pAuth {in} (1:{alias=PFW_AUTH_SET2_10,pointer=ref}*(1))(2:{alias=FW_AUTH_SET2_10}(struct))
	{
		if o.Auth == nil {
			o.Auth = &fasp.AuthSet210{}
		}
		if err := o.Auth.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddAuthenticationSetOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddAuthenticationSetOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddAuthenticationSetOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddAuthenticationSetRequest structure represents the RRPC_FWAddAuthenticationSet operation request
type AddAuthenticationSetRequest struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pAuth: This parameter represents the authentication set the client wants to add to
	// the store. The set MUST be valid, as specified in the definition of the FW_AUTH_SET2_10
	// data type.
	Auth *fasp.AuthSet210 `idl:"name:pAuth" json:"auth"`
}

func (o *AddAuthenticationSetRequest) xxx_ToOp(ctx context.Context, op *xxx_AddAuthenticationSetOperation) *xxx_AddAuthenticationSetOperation {
	if op == nil {
		op = &xxx_AddAuthenticationSetOperation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Auth = o.Auth
	return op
}

func (o *AddAuthenticationSetRequest) xxx_FromOp(ctx context.Context, op *xxx_AddAuthenticationSetOperation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Auth = op.Auth
}
func (o *AddAuthenticationSetRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *AddAuthenticationSetRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddAuthenticationSetOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddAuthenticationSetResponse structure represents the RRPC_FWAddAuthenticationSet operation response
type AddAuthenticationSetResponse struct {
	// Return: The RRPC_FWAddAuthenticationSet return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddAuthenticationSetResponse) xxx_ToOp(ctx context.Context, op *xxx_AddAuthenticationSetOperation) *xxx_AddAuthenticationSetOperation {
	if op == nil {
		op = &xxx_AddAuthenticationSetOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *AddAuthenticationSetResponse) xxx_FromOp(ctx context.Context, op *xxx_AddAuthenticationSetOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *AddAuthenticationSetResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *AddAuthenticationSetResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddAuthenticationSetOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetAuthenticationSetOperation structure represents the RRPC_FWSetAuthenticationSet operation
type xxx_SetAuthenticationSetOperation struct {
	PolicyStore *PolicyStore     `idl:"name:hPolicyStore" json:"policy_store"`
	Auth        *fasp.AuthSet210 `idl:"name:pAuth" json:"auth"`
	Return      uint32           `idl:"name:Return" json:"return"`
}

func (o *xxx_SetAuthenticationSetOperation) OpNum() int { return 18 }

func (o *xxx_SetAuthenticationSetOperation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWSetAuthenticationSet"
}

func (o *xxx_SetAuthenticationSetOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetAuthenticationSetOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pAuth {in} (1:{alias=PFW_AUTH_SET2_10}*(1))(2:{alias=FW_AUTH_SET2_10}(struct))
	{
		if o.Auth != nil {
			if err := o.Auth.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.AuthSet210{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetAuthenticationSetOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pAuth {in} (1:{alias=PFW_AUTH_SET2_10,pointer=ref}*(1))(2:{alias=FW_AUTH_SET2_10}(struct))
	{
		if o.Auth == nil {
			o.Auth = &fasp.AuthSet210{}
		}
		if err := o.Auth.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetAuthenticationSetOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetAuthenticationSetOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetAuthenticationSetOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetAuthenticationSetRequest structure represents the RRPC_FWSetAuthenticationSet operation request
type SetAuthenticationSetRequest struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pAuth: This parameter represents the authentication set the client wants to modify
	// in the store. The set MUST be valid, as specified in the definition of the FW_AUTH_SET2_10
	// data type.
	Auth *fasp.AuthSet210 `idl:"name:pAuth" json:"auth"`
}

func (o *SetAuthenticationSetRequest) xxx_ToOp(ctx context.Context, op *xxx_SetAuthenticationSetOperation) *xxx_SetAuthenticationSetOperation {
	if op == nil {
		op = &xxx_SetAuthenticationSetOperation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Auth = o.Auth
	return op
}

func (o *SetAuthenticationSetRequest) xxx_FromOp(ctx context.Context, op *xxx_SetAuthenticationSetOperation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Auth = op.Auth
}
func (o *SetAuthenticationSetRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetAuthenticationSetRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetAuthenticationSetOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetAuthenticationSetResponse structure represents the RRPC_FWSetAuthenticationSet operation response
type SetAuthenticationSetResponse struct {
	// Return: The RRPC_FWSetAuthenticationSet return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetAuthenticationSetResponse) xxx_ToOp(ctx context.Context, op *xxx_SetAuthenticationSetOperation) *xxx_SetAuthenticationSetOperation {
	if op == nil {
		op = &xxx_SetAuthenticationSetOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetAuthenticationSetResponse) xxx_FromOp(ctx context.Context, op *xxx_SetAuthenticationSetOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetAuthenticationSetResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetAuthenticationSetResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetAuthenticationSetOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_DeleteAuthenticationSetOperation structure represents the RRPC_FWDeleteAuthenticationSet operation
type xxx_DeleteAuthenticationSetOperation struct {
	PolicyStore *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	IPsecPhase  fasp.IPsecPhase `idl:"name:IpSecPhase" json:"ipsec_phase"`
	SetID       string          `idl:"name:wszSetId;string;pointer:ref" json:"set_id"`
	Return      uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_DeleteAuthenticationSetOperation) OpNum() int { return 19 }

func (o *xxx_DeleteAuthenticationSetOperation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWDeleteAuthenticationSet"
}

func (o *xxx_DeleteAuthenticationSetOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.IPsecPhase < fasp.IPsecPhase(1) || o.IPsecPhase > fasp.IPsecPhase(2) {
		return fmt.Errorf("IPsecPhase is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteAuthenticationSetOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// IpSecPhase {in} (1:{range=(1,2), alias=FW_IPSEC_PHASE}(enum))
	{
		if err := w.WriteEnum(uint16(o.IPsecPhase)); err != nil {
			return err
		}
	}
	// wszSetId {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.SetID); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteAuthenticationSetOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// IpSecPhase {in} (1:{range=(1,2), alias=FW_IPSEC_PHASE}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.IPsecPhase)); err != nil {
			return err
		}
	}
	// wszSetId {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.SetID); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteAuthenticationSetOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteAuthenticationSetOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteAuthenticationSetOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// DeleteAuthenticationSetRequest structure represents the RRPC_FWDeleteAuthenticationSet operation request
type DeleteAuthenticationSetRequest struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// IpSecPhase: This parameter specifies the IPsec negotiation phase type this set is
	// used in.
	IPsecPhase fasp.IPsecPhase `idl:"name:IpSecPhase" json:"ipsec_phase"`
	// wszSetId: This parameter is the pointer to a string that is the ID of the authentication
	// set the client wants to delete from the specified store.
	SetID string `idl:"name:wszSetId;string;pointer:ref" json:"set_id"`
}

func (o *DeleteAuthenticationSetRequest) xxx_ToOp(ctx context.Context, op *xxx_DeleteAuthenticationSetOperation) *xxx_DeleteAuthenticationSetOperation {
	if op == nil {
		op = &xxx_DeleteAuthenticationSetOperation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.IPsecPhase = o.IPsecPhase
	op.SetID = o.SetID
	return op
}

func (o *DeleteAuthenticationSetRequest) xxx_FromOp(ctx context.Context, op *xxx_DeleteAuthenticationSetOperation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.IPsecPhase = op.IPsecPhase
	o.SetID = op.SetID
}
func (o *DeleteAuthenticationSetRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *DeleteAuthenticationSetRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteAuthenticationSetOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// DeleteAuthenticationSetResponse structure represents the RRPC_FWDeleteAuthenticationSet operation response
type DeleteAuthenticationSetResponse struct {
	// Return: The RRPC_FWDeleteAuthenticationSet return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *DeleteAuthenticationSetResponse) xxx_ToOp(ctx context.Context, op *xxx_DeleteAuthenticationSetOperation) *xxx_DeleteAuthenticationSetOperation {
	if op == nil {
		op = &xxx_DeleteAuthenticationSetOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *DeleteAuthenticationSetResponse) xxx_FromOp(ctx context.Context, op *xxx_DeleteAuthenticationSetOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *DeleteAuthenticationSetResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *DeleteAuthenticationSetResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteAuthenticationSetOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_DeleteAllAuthenticationSetsOperation structure represents the RRPC_FWDeleteAllAuthenticationSets operation
type xxx_DeleteAllAuthenticationSetsOperation struct {
	PolicyStore *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	IPsecPhase  fasp.IPsecPhase `idl:"name:IpSecPhase" json:"ipsec_phase"`
	Return      uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_DeleteAllAuthenticationSetsOperation) OpNum() int { return 20 }

func (o *xxx_DeleteAllAuthenticationSetsOperation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWDeleteAllAuthenticationSets"
}

func (o *xxx_DeleteAllAuthenticationSetsOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.IPsecPhase < fasp.IPsecPhase(1) || o.IPsecPhase > fasp.IPsecPhase(2) {
		return fmt.Errorf("IPsecPhase is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteAllAuthenticationSetsOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// IpSecPhase {in} (1:{range=(1,2), alias=FW_IPSEC_PHASE}(enum))
	{
		if err := w.WriteEnum(uint16(o.IPsecPhase)); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteAllAuthenticationSetsOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// IpSecPhase {in} (1:{range=(1,2), alias=FW_IPSEC_PHASE}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.IPsecPhase)); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteAllAuthenticationSetsOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteAllAuthenticationSetsOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteAllAuthenticationSetsOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// DeleteAllAuthenticationSetsRequest structure represents the RRPC_FWDeleteAllAuthenticationSets operation request
type DeleteAllAuthenticationSetsRequest struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// IpSecPhase: This parameter specifies the IPsec negotiation phase type in which this
	// set is used.
	IPsecPhase fasp.IPsecPhase `idl:"name:IpSecPhase" json:"ipsec_phase"`
}

func (o *DeleteAllAuthenticationSetsRequest) xxx_ToOp(ctx context.Context, op *xxx_DeleteAllAuthenticationSetsOperation) *xxx_DeleteAllAuthenticationSetsOperation {
	if op == nil {
		op = &xxx_DeleteAllAuthenticationSetsOperation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.IPsecPhase = o.IPsecPhase
	return op
}

func (o *DeleteAllAuthenticationSetsRequest) xxx_FromOp(ctx context.Context, op *xxx_DeleteAllAuthenticationSetsOperation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.IPsecPhase = op.IPsecPhase
}
func (o *DeleteAllAuthenticationSetsRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *DeleteAllAuthenticationSetsRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteAllAuthenticationSetsOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// DeleteAllAuthenticationSetsResponse structure represents the RRPC_FWDeleteAllAuthenticationSets operation response
type DeleteAllAuthenticationSetsResponse struct {
	// Return: The RRPC_FWDeleteAllAuthenticationSets return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *DeleteAllAuthenticationSetsResponse) xxx_ToOp(ctx context.Context, op *xxx_DeleteAllAuthenticationSetsOperation) *xxx_DeleteAllAuthenticationSetsOperation {
	if op == nil {
		op = &xxx_DeleteAllAuthenticationSetsOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *DeleteAllAuthenticationSetsResponse) xxx_FromOp(ctx context.Context, op *xxx_DeleteAllAuthenticationSetsOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *DeleteAllAuthenticationSetsResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *DeleteAllAuthenticationSetsResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteAllAuthenticationSetsOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumAuthenticationSetsOperation structure represents the RRPC_FWEnumAuthenticationSets operation
type xxx_EnumAuthenticationSetsOperation struct {
	PolicyStore      *PolicyStore     `idl:"name:hPolicyStore" json:"policy_store"`
	IPsecPhase       fasp.IPsecPhase  `idl:"name:IpSecPhase" json:"ipsec_phase"`
	FilteredByStatus uint32           `idl:"name:dwFilteredByStatus" json:"filtered_by_status"`
	Flags            uint16           `idl:"name:wFlags" json:"flags"`
	AuthSetsLength   uint32           `idl:"name:pdwNumAuthSets" json:"auth_sets_length"`
	Auth             *fasp.AuthSet210 `idl:"name:ppAuth" json:"auth"`
	Return           uint32           `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumAuthenticationSetsOperation) OpNum() int { return 21 }

func (o *xxx_EnumAuthenticationSetsOperation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWEnumAuthenticationSets"
}

func (o *xxx_EnumAuthenticationSetsOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.IPsecPhase < fasp.IPsecPhase(1) || o.IPsecPhase > fasp.IPsecPhase(2) {
		return fmt.Errorf("IPsecPhase is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumAuthenticationSetsOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// IpSecPhase {in} (1:{range=(1,2), alias=FW_IPSEC_PHASE}(enum))
	{
		if err := w.WriteEnum(uint16(o.IPsecPhase)); err != nil {
			return err
		}
	}
	// dwFilteredByStatus {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.FilteredByStatus); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumAuthenticationSetsOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// IpSecPhase {in} (1:{range=(1,2), alias=FW_IPSEC_PHASE}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.IPsecPhase)); err != nil {
			return err
		}
	}
	// dwFilteredByStatus {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.FilteredByStatus); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumAuthenticationSetsOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumAuthenticationSetsOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwNumAuthSets {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.AuthSetsLength); err != nil {
			return err
		}
	}
	// ppAuth {out} (1:{pointer=ref}*(2))(2:{alias=PFW_AUTH_SET2_10}*(1))(3:{alias=FW_AUTH_SET2_10}(struct))
	{
		if o.Auth != nil {
			_ptr_ppAuth := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Auth != nil {
					if err := o.Auth.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&fasp.AuthSet210{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Auth, _ptr_ppAuth); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumAuthenticationSetsOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwNumAuthSets {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.AuthSetsLength); err != nil {
			return err
		}
	}
	// ppAuth {out} (1:{pointer=ref}*(2))(2:{alias=PFW_AUTH_SET2_10,pointer=ref}*(1))(3:{alias=FW_AUTH_SET2_10}(struct))
	{
		_ptr_ppAuth := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Auth == nil {
				o.Auth = &fasp.AuthSet210{}
			}
			if err := o.Auth.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ppAuth := func(ptr interface{}) { o.Auth = *ptr.(**fasp.AuthSet210) }
		if err := w.ReadPointer(&o.Auth, _s_ppAuth, _ptr_ppAuth); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumAuthenticationSetsRequest structure represents the RRPC_FWEnumAuthenticationSets operation request
type EnumAuthenticationSetsRequest struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// IpSecPhase: This parameter specifies the specific IPsec negotiation phase to which
	// this set applies.
	IPsecPhase fasp.IPsecPhase `idl:"name:IpSecPhase" json:"ipsec_phase"`
	// dwFilteredByStatus: This parameter is a combination of flags from the FW_RULE_STATUS_CLASS
	// enumeration. This method uses this bitmask to determine which rules will be returned.
	// Sets that contain a status code of the class specified by this parameter will be
	// returned in the linked list.
	FilteredByStatus uint32 `idl:"name:dwFilteredByStatus" json:"filtered_by_status"`
	// wFlags: This parameter is a combination of flags from the FW_ENUM_RULES_FLAGS that
	// modifies the behavior of the method and performs operations on the sets before returning
	// them in the linked list.
	Flags uint16 `idl:"name:wFlags" json:"flags"`
}

func (o *EnumAuthenticationSetsRequest) xxx_ToOp(ctx context.Context, op *xxx_EnumAuthenticationSetsOperation) *xxx_EnumAuthenticationSetsOperation {
	if op == nil {
		op = &xxx_EnumAuthenticationSetsOperation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.IPsecPhase = o.IPsecPhase
	op.FilteredByStatus = o.FilteredByStatus
	op.Flags = o.Flags
	return op
}

func (o *EnumAuthenticationSetsRequest) xxx_FromOp(ctx context.Context, op *xxx_EnumAuthenticationSetsOperation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.IPsecPhase = op.IPsecPhase
	o.FilteredByStatus = op.FilteredByStatus
	o.Flags = op.Flags
}
func (o *EnumAuthenticationSetsRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumAuthenticationSetsRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumAuthenticationSetsOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumAuthenticationSetsResponse structure represents the RRPC_FWEnumAuthenticationSets operation response
type EnumAuthenticationSetsResponse struct {
	// pdwNumAuthSets: This is an output parameter that on success MUST be equal to the
	// number of sets returned.
	AuthSetsLength uint32 `idl:"name:pdwNumAuthSets" json:"auth_sets_length"`
	// ppAuth: This is an output parameter that on success contains a linked list of FW_AUTH_SET2_10
	// data types.
	Auth *fasp.AuthSet210 `idl:"name:ppAuth" json:"auth"`
	// Return: The RRPC_FWEnumAuthenticationSets return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumAuthenticationSetsResponse) xxx_ToOp(ctx context.Context, op *xxx_EnumAuthenticationSetsOperation) *xxx_EnumAuthenticationSetsOperation {
	if op == nil {
		op = &xxx_EnumAuthenticationSetsOperation{}
	}
	if o == nil {
		return op
	}
	op.AuthSetsLength = o.AuthSetsLength
	op.Auth = o.Auth
	op.Return = o.Return
	return op
}

func (o *EnumAuthenticationSetsResponse) xxx_FromOp(ctx context.Context, op *xxx_EnumAuthenticationSetsOperation) {
	if o == nil {
		return
	}
	o.AuthSetsLength = op.AuthSetsLength
	o.Auth = op.Auth
	o.Return = op.Return
}
func (o *EnumAuthenticationSetsResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumAuthenticationSetsResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumAuthenticationSetsOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddCryptoSetOperation structure represents the RRPC_FWAddCryptoSet operation
type xxx_AddCryptoSetOperation struct {
	PolicyStore *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	Crypto      *fasp.CryptoSet `idl:"name:pCrypto" json:"crypto"`
	Return      uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_AddCryptoSetOperation) OpNum() int { return 22 }

func (o *xxx_AddCryptoSetOperation) OpName() string { return "/RemoteFW/v1/RRPC_FWAddCryptoSet" }

func (o *xxx_AddCryptoSetOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddCryptoSetOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pCrypto {in} (1:{alias=PFW_CRYPTO_SET}*(1))(2:{alias=FW_CRYPTO_SET}(struct))
	{
		if o.Crypto != nil {
			if err := o.Crypto.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.CryptoSet{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddCryptoSetOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pCrypto {in} (1:{alias=PFW_CRYPTO_SET,pointer=ref}*(1))(2:{alias=FW_CRYPTO_SET}(struct))
	{
		if o.Crypto == nil {
			o.Crypto = &fasp.CryptoSet{}
		}
		if err := o.Crypto.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddCryptoSetOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddCryptoSetOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddCryptoSetOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddCryptoSetRequest structure represents the RRPC_FWAddCryptoSet operation request
type AddCryptoSetRequest struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pCrypto: This parameter represents the cryptographic set the client wants to add
	// to the store. The set MUST be valid, as specified in the definition of the FW_CRYPTO_SET
	// data type.
	Crypto *fasp.CryptoSet `idl:"name:pCrypto" json:"crypto"`
}

func (o *AddCryptoSetRequest) xxx_ToOp(ctx context.Context, op *xxx_AddCryptoSetOperation) *xxx_AddCryptoSetOperation {
	if op == nil {
		op = &xxx_AddCryptoSetOperation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Crypto = o.Crypto
	return op
}

func (o *AddCryptoSetRequest) xxx_FromOp(ctx context.Context, op *xxx_AddCryptoSetOperation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Crypto = op.Crypto
}
func (o *AddCryptoSetRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *AddCryptoSetRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddCryptoSetOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddCryptoSetResponse structure represents the RRPC_FWAddCryptoSet operation response
type AddCryptoSetResponse struct {
	// Return: The RRPC_FWAddCryptoSet return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddCryptoSetResponse) xxx_ToOp(ctx context.Context, op *xxx_AddCryptoSetOperation) *xxx_AddCryptoSetOperation {
	if op == nil {
		op = &xxx_AddCryptoSetOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *AddCryptoSetResponse) xxx_FromOp(ctx context.Context, op *xxx_AddCryptoSetOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *AddCryptoSetResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *AddCryptoSetResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddCryptoSetOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetCryptoSetOperation structure represents the RRPC_FWSetCryptoSet operation
type xxx_SetCryptoSetOperation struct {
	PolicyStore *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	Crypto      *fasp.CryptoSet `idl:"name:pCrypto" json:"crypto"`
	Return      uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_SetCryptoSetOperation) OpNum() int { return 23 }

func (o *xxx_SetCryptoSetOperation) OpName() string { return "/RemoteFW/v1/RRPC_FWSetCryptoSet" }

func (o *xxx_SetCryptoSetOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetCryptoSetOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pCrypto {in} (1:{alias=PFW_CRYPTO_SET}*(1))(2:{alias=FW_CRYPTO_SET}(struct))
	{
		if o.Crypto != nil {
			if err := o.Crypto.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.CryptoSet{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetCryptoSetOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pCrypto {in} (1:{alias=PFW_CRYPTO_SET,pointer=ref}*(1))(2:{alias=FW_CRYPTO_SET}(struct))
	{
		if o.Crypto == nil {
			o.Crypto = &fasp.CryptoSet{}
		}
		if err := o.Crypto.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetCryptoSetOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetCryptoSetOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetCryptoSetOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetCryptoSetRequest structure represents the RRPC_FWSetCryptoSet operation request
type SetCryptoSetRequest struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pCrypto: This parameter represents the cryptographic set the client wants to modify
	// in the store. The set MUST be valid, as specified in the definition of the FW_CRYPTO_SET
	// data type.
	Crypto *fasp.CryptoSet `idl:"name:pCrypto" json:"crypto"`
}

func (o *SetCryptoSetRequest) xxx_ToOp(ctx context.Context, op *xxx_SetCryptoSetOperation) *xxx_SetCryptoSetOperation {
	if op == nil {
		op = &xxx_SetCryptoSetOperation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Crypto = o.Crypto
	return op
}

func (o *SetCryptoSetRequest) xxx_FromOp(ctx context.Context, op *xxx_SetCryptoSetOperation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Crypto = op.Crypto
}
func (o *SetCryptoSetRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetCryptoSetRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetCryptoSetOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetCryptoSetResponse structure represents the RRPC_FWSetCryptoSet operation response
type SetCryptoSetResponse struct {
	// Return: The RRPC_FWSetCryptoSet return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetCryptoSetResponse) xxx_ToOp(ctx context.Context, op *xxx_SetCryptoSetOperation) *xxx_SetCryptoSetOperation {
	if op == nil {
		op = &xxx_SetCryptoSetOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetCryptoSetResponse) xxx_FromOp(ctx context.Context, op *xxx_SetCryptoSetOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetCryptoSetResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetCryptoSetResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetCryptoSetOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_DeleteCryptoSetOperation structure represents the RRPC_FWDeleteCryptoSet operation
type xxx_DeleteCryptoSetOperation struct {
	PolicyStore *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	IPsecPhase  fasp.IPsecPhase `idl:"name:IpSecPhase" json:"ipsec_phase"`
	SetID       string          `idl:"name:wszSetId;string;pointer:ref" json:"set_id"`
	Return      uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_DeleteCryptoSetOperation) OpNum() int { return 24 }

func (o *xxx_DeleteCryptoSetOperation) OpName() string { return "/RemoteFW/v1/RRPC_FWDeleteCryptoSet" }

func (o *xxx_DeleteCryptoSetOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.IPsecPhase < fasp.IPsecPhase(1) || o.IPsecPhase > fasp.IPsecPhase(2) {
		return fmt.Errorf("IPsecPhase is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteCryptoSetOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// IpSecPhase {in} (1:{range=(1,2), alias=FW_IPSEC_PHASE}(enum))
	{
		if err := w.WriteEnum(uint16(o.IPsecPhase)); err != nil {
			return err
		}
	}
	// wszSetId {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.SetID); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteCryptoSetOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// IpSecPhase {in} (1:{range=(1,2), alias=FW_IPSEC_PHASE}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.IPsecPhase)); err != nil {
			return err
		}
	}
	// wszSetId {in} (1:{string, pointer=ref, alias=LPCWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.SetID); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteCryptoSetOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteCryptoSetOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteCryptoSetOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// DeleteCryptoSetRequest structure represents the RRPC_FWDeleteCryptoSet operation request
type DeleteCryptoSetRequest struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// IpSecPhase: This parameter specifies the IPsec negotiation phase type in which this
	// set is used.
	IPsecPhase fasp.IPsecPhase `idl:"name:IpSecPhase" json:"ipsec_phase"`
	// wszSetId: This parameter is the pointer to a string that is the ID of the cryptographic
	// set that the client wants to delete from the specified store.
	SetID string `idl:"name:wszSetId;string;pointer:ref" json:"set_id"`
}

func (o *DeleteCryptoSetRequest) xxx_ToOp(ctx context.Context, op *xxx_DeleteCryptoSetOperation) *xxx_DeleteCryptoSetOperation {
	if op == nil {
		op = &xxx_DeleteCryptoSetOperation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.IPsecPhase = o.IPsecPhase
	op.SetID = o.SetID
	return op
}

func (o *DeleteCryptoSetRequest) xxx_FromOp(ctx context.Context, op *xxx_DeleteCryptoSetOperation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.IPsecPhase = op.IPsecPhase
	o.SetID = op.SetID
}
func (o *DeleteCryptoSetRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *DeleteCryptoSetRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteCryptoSetOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// DeleteCryptoSetResponse structure represents the RRPC_FWDeleteCryptoSet operation response
type DeleteCryptoSetResponse struct {
	// Return: The RRPC_FWDeleteCryptoSet return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *DeleteCryptoSetResponse) xxx_ToOp(ctx context.Context, op *xxx_DeleteCryptoSetOperation) *xxx_DeleteCryptoSetOperation {
	if op == nil {
		op = &xxx_DeleteCryptoSetOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *DeleteCryptoSetResponse) xxx_FromOp(ctx context.Context, op *xxx_DeleteCryptoSetOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *DeleteCryptoSetResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *DeleteCryptoSetResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteCryptoSetOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_DeleteAllCryptoSetsOperation structure represents the RRPC_FWDeleteAllCryptoSets operation
type xxx_DeleteAllCryptoSetsOperation struct {
	PolicyStore *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	IPsecPhase  fasp.IPsecPhase `idl:"name:IpSecPhase" json:"ipsec_phase"`
	Return      uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_DeleteAllCryptoSetsOperation) OpNum() int { return 25 }

func (o *xxx_DeleteAllCryptoSetsOperation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWDeleteAllCryptoSets"
}

func (o *xxx_DeleteAllCryptoSetsOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.IPsecPhase < fasp.IPsecPhase(1) || o.IPsecPhase > fasp.IPsecPhase(2) {
		return fmt.Errorf("IPsecPhase is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteAllCryptoSetsOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// IpSecPhase {in} (1:{range=(1,2), alias=FW_IPSEC_PHASE}(enum))
	{
		if err := w.WriteEnum(uint16(o.IPsecPhase)); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteAllCryptoSetsOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// IpSecPhase {in} (1:{range=(1,2), alias=FW_IPSEC_PHASE}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.IPsecPhase)); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteAllCryptoSetsOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteAllCryptoSetsOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteAllCryptoSetsOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// DeleteAllCryptoSetsRequest structure represents the RRPC_FWDeleteAllCryptoSets operation request
type DeleteAllCryptoSetsRequest struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// IpSecPhase: This parameter specifies the IPsec negotiation phase type in which this
	// set is used.
	IPsecPhase fasp.IPsecPhase `idl:"name:IpSecPhase" json:"ipsec_phase"`
}

func (o *DeleteAllCryptoSetsRequest) xxx_ToOp(ctx context.Context, op *xxx_DeleteAllCryptoSetsOperation) *xxx_DeleteAllCryptoSetsOperation {
	if op == nil {
		op = &xxx_DeleteAllCryptoSetsOperation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.IPsecPhase = o.IPsecPhase
	return op
}

func (o *DeleteAllCryptoSetsRequest) xxx_FromOp(ctx context.Context, op *xxx_DeleteAllCryptoSetsOperation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.IPsecPhase = op.IPsecPhase
}
func (o *DeleteAllCryptoSetsRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *DeleteAllCryptoSetsRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteAllCryptoSetsOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// DeleteAllCryptoSetsResponse structure represents the RRPC_FWDeleteAllCryptoSets operation response
type DeleteAllCryptoSetsResponse struct {
	// Return: The RRPC_FWDeleteAllCryptoSets return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *DeleteAllCryptoSetsResponse) xxx_ToOp(ctx context.Context, op *xxx_DeleteAllCryptoSetsOperation) *xxx_DeleteAllCryptoSetsOperation {
	if op == nil {
		op = &xxx_DeleteAllCryptoSetsOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *DeleteAllCryptoSetsResponse) xxx_FromOp(ctx context.Context, op *xxx_DeleteAllCryptoSetsOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *DeleteAllCryptoSetsResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *DeleteAllCryptoSetsResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteAllCryptoSetsOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumCryptoSetsOperation structure represents the RRPC_FWEnumCryptoSets operation
type xxx_EnumCryptoSetsOperation struct {
	PolicyStore      *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	IPsecPhase       fasp.IPsecPhase `idl:"name:IpSecPhase" json:"ipsec_phase"`
	FilteredByStatus uint32          `idl:"name:dwFilteredByStatus" json:"filtered_by_status"`
	Flags            uint16          `idl:"name:wFlags" json:"flags"`
	SetsLength       uint32          `idl:"name:pdwNumSets;pointer:ref" json:"sets_length"`
	CryptoSets       *fasp.CryptoSet `idl:"name:ppCryptoSets" json:"crypto_sets"`
	Return           uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumCryptoSetsOperation) OpNum() int { return 26 }

func (o *xxx_EnumCryptoSetsOperation) OpName() string { return "/RemoteFW/v1/RRPC_FWEnumCryptoSets" }

func (o *xxx_EnumCryptoSetsOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.IPsecPhase < fasp.IPsecPhase(1) || o.IPsecPhase > fasp.IPsecPhase(2) {
		return fmt.Errorf("IPsecPhase is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumCryptoSetsOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// IpSecPhase {in} (1:{range=(1,2), alias=FW_IPSEC_PHASE}(enum))
	{
		if err := w.WriteEnum(uint16(o.IPsecPhase)); err != nil {
			return err
		}
	}
	// dwFilteredByStatus {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.FilteredByStatus); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumCryptoSetsOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// IpSecPhase {in} (1:{range=(1,2), alias=FW_IPSEC_PHASE}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.IPsecPhase)); err != nil {
			return err
		}
	}
	// dwFilteredByStatus {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.FilteredByStatus); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumCryptoSetsOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumCryptoSetsOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwNumSets {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.SetsLength); err != nil {
			return err
		}
	}
	// ppCryptoSets {out} (1:{pointer=ref}*(2))(2:{alias=PFW_CRYPTO_SET}*(1))(3:{alias=FW_CRYPTO_SET}(struct))
	{
		if o.CryptoSets != nil {
			_ptr_ppCryptoSets := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.CryptoSets != nil {
					if err := o.CryptoSets.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&fasp.CryptoSet{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.CryptoSets, _ptr_ppCryptoSets); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumCryptoSetsOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwNumSets {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.SetsLength); err != nil {
			return err
		}
	}
	// ppCryptoSets {out} (1:{pointer=ref}*(2))(2:{alias=PFW_CRYPTO_SET,pointer=ref}*(1))(3:{alias=FW_CRYPTO_SET}(struct))
	{
		_ptr_ppCryptoSets := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.CryptoSets == nil {
				o.CryptoSets = &fasp.CryptoSet{}
			}
			if err := o.CryptoSets.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ppCryptoSets := func(ptr interface{}) { o.CryptoSets = *ptr.(**fasp.CryptoSet) }
		if err := w.ReadPointer(&o.CryptoSets, _s_ppCryptoSets, _ptr_ppCryptoSets); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumCryptoSetsRequest structure represents the RRPC_FWEnumCryptoSets operation request
type EnumCryptoSetsRequest struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// IpSecPhase: This parameter specifies the specific IPsec negotiation phase to which
	// this set applies.
	IPsecPhase fasp.IPsecPhase `idl:"name:IpSecPhase" json:"ipsec_phase"`
	// dwFilteredByStatus: This parameter is a combination of flags from the FW_RULE_STATUS_CLASS
	// enumeration. This method uses this bitmask to determine which rules will be returned.
	// Sets that contain a status code of the class specified by matches to this parameter
	// will be returned in the linked list.
	FilteredByStatus uint32 `idl:"name:dwFilteredByStatus" json:"filtered_by_status"`
	// wFlags: This parameter is a combination of flags from the FW_ENUM_RULES_FLAGS that
	// modifies the behavior of the method and performs operations on the sets before returning
	// them in the linked list.
	Flags uint16 `idl:"name:wFlags" json:"flags"`
}

func (o *EnumCryptoSetsRequest) xxx_ToOp(ctx context.Context, op *xxx_EnumCryptoSetsOperation) *xxx_EnumCryptoSetsOperation {
	if op == nil {
		op = &xxx_EnumCryptoSetsOperation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.IPsecPhase = o.IPsecPhase
	op.FilteredByStatus = o.FilteredByStatus
	op.Flags = o.Flags
	return op
}

func (o *EnumCryptoSetsRequest) xxx_FromOp(ctx context.Context, op *xxx_EnumCryptoSetsOperation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.IPsecPhase = op.IPsecPhase
	o.FilteredByStatus = op.FilteredByStatus
	o.Flags = op.Flags
}
func (o *EnumCryptoSetsRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumCryptoSetsRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumCryptoSetsOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumCryptoSetsResponse structure represents the RRPC_FWEnumCryptoSets operation response
type EnumCryptoSetsResponse struct {
	// pdwNumSets: This is an output parameter that on success MUST be equal to the number
	// of sets returned.
	SetsLength uint32 `idl:"name:pdwNumSets;pointer:ref" json:"sets_length"`
	// ppCryptoSets: This is an output parameter that on success contains a linked list
	// of FW_CRYPTO_SET data types.
	CryptoSets *fasp.CryptoSet `idl:"name:ppCryptoSets" json:"crypto_sets"`
	// Return: The RRPC_FWEnumCryptoSets return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumCryptoSetsResponse) xxx_ToOp(ctx context.Context, op *xxx_EnumCryptoSetsOperation) *xxx_EnumCryptoSetsOperation {
	if op == nil {
		op = &xxx_EnumCryptoSetsOperation{}
	}
	if o == nil {
		return op
	}
	op.SetsLength = o.SetsLength
	op.CryptoSets = o.CryptoSets
	op.Return = o.Return
	return op
}

func (o *EnumCryptoSetsResponse) xxx_FromOp(ctx context.Context, op *xxx_EnumCryptoSetsOperation) {
	if o == nil {
		return
	}
	o.SetsLength = op.SetsLength
	o.CryptoSets = op.CryptoSets
	o.Return = op.Return
}
func (o *EnumCryptoSetsResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumCryptoSetsResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumCryptoSetsOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumPhase1SAsOperation structure represents the RRPC_FWEnumPhase1SAs operation
type xxx_EnumPhase1SAsOperation struct {
	PolicyStore *PolicyStore            `idl:"name:hPolicyStore" json:"policy_store"`
	Endpoints   *fasp.Endpoints         `idl:"name:pEndpoints;pointer:unique" json:"endpoints"`
	SAsLength   uint32                  `idl:"name:pdwNumSAs;pointer:ref" json:"s_as_length"`
	SAs         []*fasp.Phase1SADetails `idl:"name:ppSAs;size_is:(, pdwNumSAs)" json:"s_as"`
	Return      uint32                  `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumPhase1SAsOperation) OpNum() int { return 27 }

func (o *xxx_EnumPhase1SAsOperation) OpName() string { return "/RemoteFW/v1/RRPC_FWEnumPhase1SAs" }

func (o *xxx_EnumPhase1SAsOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumPhase1SAsOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pEndpoints {in} (1:{pointer=unique, alias=PFW_ENDPOINTS}*(1))(2:{alias=FW_ENDPOINTS}(struct))
	{
		if o.Endpoints != nil {
			_ptr_pEndpoints := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Endpoints != nil {
					if err := o.Endpoints.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&fasp.Endpoints{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Endpoints, _ptr_pEndpoints); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumPhase1SAsOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pEndpoints {in} (1:{pointer=unique, alias=PFW_ENDPOINTS}*(1))(2:{alias=FW_ENDPOINTS}(struct))
	{
		_ptr_pEndpoints := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Endpoints == nil {
				o.Endpoints = &fasp.Endpoints{}
			}
			if err := o.Endpoints.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_pEndpoints := func(ptr interface{}) { o.Endpoints = *ptr.(**fasp.Endpoints) }
		if err := w.ReadPointer(&o.Endpoints, _s_pEndpoints, _ptr_pEndpoints); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumPhase1SAsOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.SAs != nil && o.SAsLength == 0 {
		o.SAsLength = uint32(len(o.SAs))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumPhase1SAsOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwNumSAs {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.SAsLength); err != nil {
			return err
		}
	}
	// ppSAs {out} (1:{pointer=ref}*(2))(2:{alias=PFW_PHASE1_SA_DETAILS}*(1))(3:{alias=FW_PHASE1_SA_DETAILS}[dim:0,size_is=pdwNumSAs](struct))
	{
		if o.SAs != nil || o.SAsLength > 0 {
			_ptr_ppSAs := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.SAsLength)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.SAs {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if o.SAs[i1] != nil {
						if err := o.SAs[i1].MarshalNDR(ctx, w); err != nil {
							return err
						}
					} else {
						if err := (&fasp.Phase1SADetails{}).MarshalNDR(ctx, w); err != nil {
							return err
						}
					}
				}
				for i1 := len(o.SAs); uint64(i1) < sizeInfo[0]; i1++ {
					if err := (&fasp.Phase1SADetails{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.SAs, _ptr_ppSAs); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumPhase1SAsOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwNumSAs {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.SAsLength); err != nil {
			return err
		}
	}
	// ppSAs {out} (1:{pointer=ref}*(2))(2:{alias=PFW_PHASE1_SA_DETAILS,pointer=ref}*(1))(3:{alias=FW_PHASE1_SA_DETAILS}[dim:0,size_is=pdwNumSAs](struct))
	{
		_ptr_ppSAs := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.SAs", sizeInfo[0])
			}
			o.SAs = make([]*fasp.Phase1SADetails, sizeInfo[0])
			for i1 := range o.SAs {
				i1 := i1
				if o.SAs[i1] == nil {
					o.SAs[i1] = &fasp.Phase1SADetails{}
				}
				if err := o.SAs[i1].UnmarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		_s_ppSAs := func(ptr interface{}) { o.SAs = *ptr.(*[]*fasp.Phase1SADetails) }
		if err := w.ReadPointer(&o.SAs, _s_ppSAs, _ptr_ppSAs); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumPhase1SAsRequest structure represents the RRPC_FWEnumPhase1SAs operation request
type EnumPhase1SAsRequest struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pEndpoints: This parameter is a pointer to an FW_ENDPOINTS data type that can hold
	// the addresses of the destination and source host. These addresses are used to match
	// the security associations that will be returned. If this parameter is NULL, the method
	// returns all IPsec first-phase security associations.
	Endpoints *fasp.Endpoints `idl:"name:pEndpoints;pointer:unique" json:"endpoints"`
}

func (o *EnumPhase1SAsRequest) xxx_ToOp(ctx context.Context, op *xxx_EnumPhase1SAsOperation) *xxx_EnumPhase1SAsOperation {
	if op == nil {
		op = &xxx_EnumPhase1SAsOperation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Endpoints = o.Endpoints
	return op
}

func (o *EnumPhase1SAsRequest) xxx_FromOp(ctx context.Context, op *xxx_EnumPhase1SAsOperation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Endpoints = op.Endpoints
}
func (o *EnumPhase1SAsRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumPhase1SAsRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumPhase1SAsOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumPhase1SAsResponse structure represents the RRPC_FWEnumPhase1SAs operation response
type EnumPhase1SAsResponse struct {
	// pdwNumSAs: This is an output parameter that on success MUST be equal to the number
	// of security associations returned.
	SAsLength uint32 `idl:"name:pdwNumSAs;pointer:ref" json:"s_as_length"`
	// ppSAs: This is an output parameter that on success contains a linked list of FW_PHASE1_SA_DETAILS
	// data types, each of which represents the first-phase security association.
	SAs []*fasp.Phase1SADetails `idl:"name:ppSAs;size_is:(, pdwNumSAs)" json:"s_as"`
	// Return: The RRPC_FWEnumPhase1SAs return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumPhase1SAsResponse) xxx_ToOp(ctx context.Context, op *xxx_EnumPhase1SAsOperation) *xxx_EnumPhase1SAsOperation {
	if op == nil {
		op = &xxx_EnumPhase1SAsOperation{}
	}
	if o == nil {
		return op
	}
	op.SAsLength = o.SAsLength
	op.SAs = o.SAs
	op.Return = o.Return
	return op
}

func (o *EnumPhase1SAsResponse) xxx_FromOp(ctx context.Context, op *xxx_EnumPhase1SAsOperation) {
	if o == nil {
		return
	}
	o.SAsLength = op.SAsLength
	o.SAs = op.SAs
	o.Return = op.Return
}
func (o *EnumPhase1SAsResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumPhase1SAsResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumPhase1SAsOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumPhase2SAsOperation structure represents the RRPC_FWEnumPhase2SAs operation
type xxx_EnumPhase2SAsOperation struct {
	PolicyStore *PolicyStore            `idl:"name:hPolicyStore" json:"policy_store"`
	Endpoints   *fasp.Endpoints         `idl:"name:pEndpoints;pointer:unique" json:"endpoints"`
	SAsLength   uint32                  `idl:"name:pdwNumSAs;pointer:ref" json:"s_as_length"`
	SAs         []*fasp.Phase2SADetails `idl:"name:ppSAs;size_is:(, pdwNumSAs)" json:"s_as"`
	Return      uint32                  `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumPhase2SAsOperation) OpNum() int { return 28 }

func (o *xxx_EnumPhase2SAsOperation) OpName() string { return "/RemoteFW/v1/RRPC_FWEnumPhase2SAs" }

func (o *xxx_EnumPhase2SAsOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumPhase2SAsOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pEndpoints {in} (1:{pointer=unique, alias=PFW_ENDPOINTS}*(1))(2:{alias=FW_ENDPOINTS}(struct))
	{
		if o.Endpoints != nil {
			_ptr_pEndpoints := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Endpoints != nil {
					if err := o.Endpoints.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&fasp.Endpoints{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Endpoints, _ptr_pEndpoints); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumPhase2SAsOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pEndpoints {in} (1:{pointer=unique, alias=PFW_ENDPOINTS}*(1))(2:{alias=FW_ENDPOINTS}(struct))
	{
		_ptr_pEndpoints := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Endpoints == nil {
				o.Endpoints = &fasp.Endpoints{}
			}
			if err := o.Endpoints.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_pEndpoints := func(ptr interface{}) { o.Endpoints = *ptr.(**fasp.Endpoints) }
		if err := w.ReadPointer(&o.Endpoints, _s_pEndpoints, _ptr_pEndpoints); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumPhase2SAsOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.SAs != nil && o.SAsLength == 0 {
		o.SAsLength = uint32(len(o.SAs))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumPhase2SAsOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwNumSAs {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.SAsLength); err != nil {
			return err
		}
	}
	// ppSAs {out} (1:{pointer=ref}*(2))(2:{alias=PFW_PHASE2_SA_DETAILS}*(1))(3:{alias=FW_PHASE2_SA_DETAILS}[dim:0,size_is=pdwNumSAs](struct))
	{
		if o.SAs != nil || o.SAsLength > 0 {
			_ptr_ppSAs := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.SAsLength)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.SAs {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if o.SAs[i1] != nil {
						if err := o.SAs[i1].MarshalNDR(ctx, w); err != nil {
							return err
						}
					} else {
						if err := (&fasp.Phase2SADetails{}).MarshalNDR(ctx, w); err != nil {
							return err
						}
					}
				}
				for i1 := len(o.SAs); uint64(i1) < sizeInfo[0]; i1++ {
					if err := (&fasp.Phase2SADetails{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.SAs, _ptr_ppSAs); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumPhase2SAsOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwNumSAs {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.SAsLength); err != nil {
			return err
		}
	}
	// ppSAs {out} (1:{pointer=ref}*(2))(2:{alias=PFW_PHASE2_SA_DETAILS,pointer=ref}*(1))(3:{alias=FW_PHASE2_SA_DETAILS}[dim:0,size_is=pdwNumSAs](struct))
	{
		_ptr_ppSAs := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.SAs", sizeInfo[0])
			}
			o.SAs = make([]*fasp.Phase2SADetails, sizeInfo[0])
			for i1 := range o.SAs {
				i1 := i1
				if o.SAs[i1] == nil {
					o.SAs[i1] = &fasp.Phase2SADetails{}
				}
				if err := o.SAs[i1].UnmarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		_s_ppSAs := func(ptr interface{}) { o.SAs = *ptr.(*[]*fasp.Phase2SADetails) }
		if err := w.ReadPointer(&o.SAs, _s_ppSAs, _ptr_ppSAs); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumPhase2SAsRequest structure represents the RRPC_FWEnumPhase2SAs operation request
type EnumPhase2SAsRequest struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pEndpoints: This parameter is a pointer to an FW_ENDPOINTS data type that can hold
	// the addresses of the destination and source host. These addresses are used to match
	// the security associations that will be returned. If this parameter is NULL, the method
	// will return all IPsec second phase security associations. If an endpoint is empty
	// (that is, equal to 0), the endpoint matches any address.
	Endpoints *fasp.Endpoints `idl:"name:pEndpoints;pointer:unique" json:"endpoints"`
}

func (o *EnumPhase2SAsRequest) xxx_ToOp(ctx context.Context, op *xxx_EnumPhase2SAsOperation) *xxx_EnumPhase2SAsOperation {
	if op == nil {
		op = &xxx_EnumPhase2SAsOperation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Endpoints = o.Endpoints
	return op
}

func (o *EnumPhase2SAsRequest) xxx_FromOp(ctx context.Context, op *xxx_EnumPhase2SAsOperation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Endpoints = op.Endpoints
}
func (o *EnumPhase2SAsRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumPhase2SAsRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumPhase2SAsOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumPhase2SAsResponse structure represents the RRPC_FWEnumPhase2SAs operation response
type EnumPhase2SAsResponse struct {
	// pdwNumSAs: This is an output parameter that on success MUST be equal to the number
	// of security associations returned.
	SAsLength uint32 `idl:"name:pdwNumSAs;pointer:ref" json:"s_as_length"`
	// ppSAs: This is an output parameter that on success contains a linked list of FW_PHASE2_SA_DETAILS
	// data types, each of which represents a second phase security association.
	SAs []*fasp.Phase2SADetails `idl:"name:ppSAs;size_is:(, pdwNumSAs)" json:"s_as"`
	// Return: The RRPC_FWEnumPhase2SAs return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumPhase2SAsResponse) xxx_ToOp(ctx context.Context, op *xxx_EnumPhase2SAsOperation) *xxx_EnumPhase2SAsOperation {
	if op == nil {
		op = &xxx_EnumPhase2SAsOperation{}
	}
	if o == nil {
		return op
	}
	op.SAsLength = o.SAsLength
	op.SAs = o.SAs
	op.Return = o.Return
	return op
}

func (o *EnumPhase2SAsResponse) xxx_FromOp(ctx context.Context, op *xxx_EnumPhase2SAsOperation) {
	if o == nil {
		return
	}
	o.SAsLength = op.SAsLength
	o.SAs = op.SAs
	o.Return = op.Return
}
func (o *EnumPhase2SAsResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumPhase2SAsResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumPhase2SAsOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_DeletePhase1SAsOperation structure represents the RRPC_FWDeletePhase1SAs operation
type xxx_DeletePhase1SAsOperation struct {
	PolicyStore *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	Endpoints   *fasp.Endpoints `idl:"name:pEndpoints;pointer:unique" json:"endpoints"`
	Return      uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_DeletePhase1SAsOperation) OpNum() int { return 29 }

func (o *xxx_DeletePhase1SAsOperation) OpName() string { return "/RemoteFW/v1/RRPC_FWDeletePhase1SAs" }

func (o *xxx_DeletePhase1SAsOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeletePhase1SAsOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pEndpoints {in} (1:{pointer=unique, alias=PFW_ENDPOINTS}*(1))(2:{alias=FW_ENDPOINTS}(struct))
	{
		if o.Endpoints != nil {
			_ptr_pEndpoints := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Endpoints != nil {
					if err := o.Endpoints.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&fasp.Endpoints{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Endpoints, _ptr_pEndpoints); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeletePhase1SAsOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pEndpoints {in} (1:{pointer=unique, alias=PFW_ENDPOINTS}*(1))(2:{alias=FW_ENDPOINTS}(struct))
	{
		_ptr_pEndpoints := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Endpoints == nil {
				o.Endpoints = &fasp.Endpoints{}
			}
			if err := o.Endpoints.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_pEndpoints := func(ptr interface{}) { o.Endpoints = *ptr.(**fasp.Endpoints) }
		if err := w.ReadPointer(&o.Endpoints, _s_pEndpoints, _ptr_pEndpoints); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeletePhase1SAsOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeletePhase1SAsOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeletePhase1SAsOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// DeletePhase1SAsRequest structure represents the RRPC_FWDeletePhase1SAs operation request
type DeletePhase1SAsRequest struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pEndpoints: This parameter is a pointer to an FW_ENDPOINTS data type that can hold
	// the addresses of the destination and source host. These addresses are used to match
	// the security associations that will be deleted. If this parameter is NULL, the method
	// deletes all IPsec first-phase security associations. If an endpoint is empty (that
	// is, equal to 0), the endpoint matches any address.
	Endpoints *fasp.Endpoints `idl:"name:pEndpoints;pointer:unique" json:"endpoints"`
}

func (o *DeletePhase1SAsRequest) xxx_ToOp(ctx context.Context, op *xxx_DeletePhase1SAsOperation) *xxx_DeletePhase1SAsOperation {
	if op == nil {
		op = &xxx_DeletePhase1SAsOperation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Endpoints = o.Endpoints
	return op
}

func (o *DeletePhase1SAsRequest) xxx_FromOp(ctx context.Context, op *xxx_DeletePhase1SAsOperation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Endpoints = op.Endpoints
}
func (o *DeletePhase1SAsRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *DeletePhase1SAsRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeletePhase1SAsOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// DeletePhase1SAsResponse structure represents the RRPC_FWDeletePhase1SAs operation response
type DeletePhase1SAsResponse struct {
	// Return: The RRPC_FWDeletePhase1SAs return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *DeletePhase1SAsResponse) xxx_ToOp(ctx context.Context, op *xxx_DeletePhase1SAsOperation) *xxx_DeletePhase1SAsOperation {
	if op == nil {
		op = &xxx_DeletePhase1SAsOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *DeletePhase1SAsResponse) xxx_FromOp(ctx context.Context, op *xxx_DeletePhase1SAsOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *DeletePhase1SAsResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *DeletePhase1SAsResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeletePhase1SAsOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_DeletePhase2SAsOperation structure represents the RRPC_FWDeletePhase2SAs operation
type xxx_DeletePhase2SAsOperation struct {
	PolicyStore *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	Endpoints   *fasp.Endpoints `idl:"name:pEndpoints;pointer:unique" json:"endpoints"`
	Return      uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_DeletePhase2SAsOperation) OpNum() int { return 30 }

func (o *xxx_DeletePhase2SAsOperation) OpName() string { return "/RemoteFW/v1/RRPC_FWDeletePhase2SAs" }

func (o *xxx_DeletePhase2SAsOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeletePhase2SAsOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pEndpoints {in} (1:{pointer=unique, alias=PFW_ENDPOINTS}*(1))(2:{alias=FW_ENDPOINTS}(struct))
	{
		if o.Endpoints != nil {
			_ptr_pEndpoints := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Endpoints != nil {
					if err := o.Endpoints.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&fasp.Endpoints{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Endpoints, _ptr_pEndpoints); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeletePhase2SAsOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pEndpoints {in} (1:{pointer=unique, alias=PFW_ENDPOINTS}*(1))(2:{alias=FW_ENDPOINTS}(struct))
	{
		_ptr_pEndpoints := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Endpoints == nil {
				o.Endpoints = &fasp.Endpoints{}
			}
			if err := o.Endpoints.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_pEndpoints := func(ptr interface{}) { o.Endpoints = *ptr.(**fasp.Endpoints) }
		if err := w.ReadPointer(&o.Endpoints, _s_pEndpoints, _ptr_pEndpoints); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeletePhase2SAsOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeletePhase2SAsOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeletePhase2SAsOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// DeletePhase2SAsRequest structure represents the RRPC_FWDeletePhase2SAs operation request
type DeletePhase2SAsRequest struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pEndpoints: This parameter is a pointer to an FW_ENDPOINTS data type that can hold
	// the addresses of the destination and source host. These addresses are used to match
	// the security associations that will be deleted. If this parameter is NULL, the method
	// deletes all IPsec second-phase security associations. If an endpoint is empty (that
	// is, equal to 0), the endpoint matches any address.
	Endpoints *fasp.Endpoints `idl:"name:pEndpoints;pointer:unique" json:"endpoints"`
}

func (o *DeletePhase2SAsRequest) xxx_ToOp(ctx context.Context, op *xxx_DeletePhase2SAsOperation) *xxx_DeletePhase2SAsOperation {
	if op == nil {
		op = &xxx_DeletePhase2SAsOperation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Endpoints = o.Endpoints
	return op
}

func (o *DeletePhase2SAsRequest) xxx_FromOp(ctx context.Context, op *xxx_DeletePhase2SAsOperation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Endpoints = op.Endpoints
}
func (o *DeletePhase2SAsRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *DeletePhase2SAsRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeletePhase2SAsOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// DeletePhase2SAsResponse structure represents the RRPC_FWDeletePhase2SAs operation response
type DeletePhase2SAsResponse struct {
	// Return: The RRPC_FWDeletePhase2SAs return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *DeletePhase2SAsResponse) xxx_ToOp(ctx context.Context, op *xxx_DeletePhase2SAsOperation) *xxx_DeletePhase2SAsOperation {
	if op == nil {
		op = &xxx_DeletePhase2SAsOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *DeletePhase2SAsResponse) xxx_FromOp(ctx context.Context, op *xxx_DeletePhase2SAsOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *DeletePhase2SAsResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *DeletePhase2SAsResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeletePhase2SAsOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumProductsOperation structure represents the RRPC_FWEnumProducts operation
type xxx_EnumProductsOperation struct {
	PolicyStore    *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	ProductsLength uint32          `idl:"name:pdwNumProducts" json:"products_length"`
	Products       []*fasp.Product `idl:"name:ppProducts;size_is:(, pdwNumProducts)" json:"products"`
	Return         uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumProductsOperation) OpNum() int { return 31 }

func (o *xxx_EnumProductsOperation) OpName() string { return "/RemoteFW/v1/RRPC_FWEnumProducts" }

func (o *xxx_EnumProductsOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumProductsOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_EnumProductsOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumProductsOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Products != nil && o.ProductsLength == 0 {
		o.ProductsLength = uint32(len(o.Products))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumProductsOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwNumProducts {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ProductsLength); err != nil {
			return err
		}
	}
	// ppProducts {out} (1:{pointer=ref}*(2))(2:{alias=PFW_PRODUCT}*(1))(3:{alias=FW_PRODUCT}[dim:0,size_is=pdwNumProducts](struct))
	{
		if o.Products != nil || o.ProductsLength > 0 {
			_ptr_ppProducts := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.ProductsLength)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Products {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if o.Products[i1] != nil {
						if err := o.Products[i1].MarshalNDR(ctx, w); err != nil {
							return err
						}
					} else {
						if err := (&fasp.Product{}).MarshalNDR(ctx, w); err != nil {
							return err
						}
					}
				}
				for i1 := len(o.Products); uint64(i1) < sizeInfo[0]; i1++ {
					if err := (&fasp.Product{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Products, _ptr_ppProducts); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumProductsOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwNumProducts {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ProductsLength); err != nil {
			return err
		}
	}
	// ppProducts {out} (1:{pointer=ref}*(2))(2:{alias=PFW_PRODUCT,pointer=ref}*(1))(3:{alias=FW_PRODUCT}[dim:0,size_is=pdwNumProducts](struct))
	{
		_ptr_ppProducts := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Products", sizeInfo[0])
			}
			o.Products = make([]*fasp.Product, sizeInfo[0])
			for i1 := range o.Products {
				i1 := i1
				if o.Products[i1] == nil {
					o.Products[i1] = &fasp.Product{}
				}
				if err := o.Products[i1].UnmarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		_s_ppProducts := func(ptr interface{}) { o.Products = *ptr.(*[]*fasp.Product) }
		if err := w.ReadPointer(&o.Products, _s_ppProducts, _ptr_ppProducts); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumProductsRequest structure represents the RRPC_FWEnumProducts operation request
type EnumProductsRequest struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
}

func (o *EnumProductsRequest) xxx_ToOp(ctx context.Context, op *xxx_EnumProductsOperation) *xxx_EnumProductsOperation {
	if op == nil {
		op = &xxx_EnumProductsOperation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	return op
}

func (o *EnumProductsRequest) xxx_FromOp(ctx context.Context, op *xxx_EnumProductsOperation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
}
func (o *EnumProductsRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumProductsRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumProductsOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumProductsResponse structure represents the RRPC_FWEnumProducts operation response
type EnumProductsResponse struct {
	// pdwNumProducts: This is an output parameter that on success MUST be equal to the
	// number of products returned.
	ProductsLength uint32 `idl:"name:pdwNumProducts" json:"products_length"`
	// ppProducts: An array of FW_PRODUCT data types, representing the registration of third-party
	// software components.
	Products []*fasp.Product `idl:"name:ppProducts;size_is:(, pdwNumProducts)" json:"products"`
	// Return: The RRPC_FWEnumProducts return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumProductsResponse) xxx_ToOp(ctx context.Context, op *xxx_EnumProductsOperation) *xxx_EnumProductsOperation {
	if op == nil {
		op = &xxx_EnumProductsOperation{}
	}
	if o == nil {
		return op
	}
	op.ProductsLength = o.ProductsLength
	op.Products = o.Products
	op.Return = o.Return
	return op
}

func (o *EnumProductsResponse) xxx_FromOp(ctx context.Context, op *xxx_EnumProductsOperation) {
	if o == nil {
		return
	}
	o.ProductsLength = op.ProductsLength
	o.Products = op.Products
	o.Return = op.Return
}
func (o *EnumProductsResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumProductsResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumProductsOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddMainModeRuleOperation structure represents the RRPC_FWAddMainModeRule operation
type xxx_AddMainModeRuleOperation struct {
	PolicyStore *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	MMRule      *fasp.MMRule    `idl:"name:pMMRule" json:"mm_rule"`
	Status      fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	Return      uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_AddMainModeRuleOperation) OpNum() int { return 32 }

func (o *xxx_AddMainModeRuleOperation) OpName() string { return "/RemoteFW/v1/RRPC_FWAddMainModeRule" }

func (o *xxx_AddMainModeRuleOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddMainModeRuleOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pMMRule {in} (1:{alias=PFW_MM_RULE}*(1))(2:{alias=FW_MM_RULE}(struct))
	{
		if o.MMRule != nil {
			if err := o.MMRule.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.MMRule{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddMainModeRuleOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pMMRule {in} (1:{alias=PFW_MM_RULE,pointer=ref}*(1))(2:{alias=FW_MM_RULE}(struct))
	{
		if o.MMRule == nil {
			o.MMRule = &fasp.MMRule{}
		}
		if err := o.MMRule.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddMainModeRuleOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddMainModeRuleOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.WriteEnum(uint32(o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddMainModeRuleOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.ReadEnum((*uint32)(&o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddMainModeRuleRequest structure represents the RRPC_FWAddMainModeRule operation request
type AddMainModeRuleRequest struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pMMRule: This parameter represents the main mode rule that the client adds in the
	// store. The rule MUST be valid, as specified in the definition of the FW_MM_RULE data
	// type.
	MMRule *fasp.MMRule `idl:"name:pMMRule" json:"mm_rule"`
}

func (o *AddMainModeRuleRequest) xxx_ToOp(ctx context.Context, op *xxx_AddMainModeRuleOperation) *xxx_AddMainModeRuleOperation {
	if op == nil {
		op = &xxx_AddMainModeRuleOperation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.MMRule = o.MMRule
	return op
}

func (o *AddMainModeRuleRequest) xxx_FromOp(ctx context.Context, op *xxx_AddMainModeRuleOperation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.MMRule = op.MMRule
}
func (o *AddMainModeRuleRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *AddMainModeRuleRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddMainModeRuleOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddMainModeRuleResponse structure represents the RRPC_FWAddMainModeRule operation response
type AddMainModeRuleResponse struct {
	// pStatus: This is an output parameter that on return will have the status code of
	// the rule.
	Status fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	// Return: The RRPC_FWAddMainModeRule return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddMainModeRuleResponse) xxx_ToOp(ctx context.Context, op *xxx_AddMainModeRuleOperation) *xxx_AddMainModeRuleOperation {
	if op == nil {
		op = &xxx_AddMainModeRuleOperation{}
	}
	if o == nil {
		return op
	}
	op.Status = o.Status
	op.Return = o.Return
	return op
}

func (o *AddMainModeRuleResponse) xxx_FromOp(ctx context.Context, op *xxx_AddMainModeRuleOperation) {
	if o == nil {
		return
	}
	o.Status = op.Status
	o.Return = op.Return
}
func (o *AddMainModeRuleResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *AddMainModeRuleResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddMainModeRuleOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetMainModeRuleOperation structure represents the RRPC_FWSetMainModeRule operation
type xxx_SetMainModeRuleOperation struct {
	PolicyStore *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	MMRule      *fasp.MMRule    `idl:"name:pMMRule" json:"mm_rule"`
	Status      fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	Return      uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_SetMainModeRuleOperation) OpNum() int { return 33 }

func (o *xxx_SetMainModeRuleOperation) OpName() string { return "/RemoteFW/v1/RRPC_FWSetMainModeRule" }

func (o *xxx_SetMainModeRuleOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetMainModeRuleOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pMMRule {in} (1:{alias=PFW_MM_RULE}*(1))(2:{alias=FW_MM_RULE}(struct))
	{
		if o.MMRule != nil {
			if err := o.MMRule.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.MMRule{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetMainModeRuleOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pMMRule {in} (1:{alias=PFW_MM_RULE,pointer=ref}*(1))(2:{alias=FW_MM_RULE}(struct))
	{
		if o.MMRule == nil {
			o.MMRule = &fasp.MMRule{}
		}
		if err := o.MMRule.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetMainModeRuleOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetMainModeRuleOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.WriteEnum(uint32(o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetMainModeRuleOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.ReadEnum((*uint32)(&o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetMainModeRuleRequest structure represents the RRPC_FWSetMainModeRule operation request
type SetMainModeRuleRequest struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pMMRule: This parameter represents the main mode rule the client modifies in the
	// store. The rule MUST be valid, as specified in the definition of the FW_MM_RULE data
	// type.
	MMRule *fasp.MMRule `idl:"name:pMMRule" json:"mm_rule"`
}

func (o *SetMainModeRuleRequest) xxx_ToOp(ctx context.Context, op *xxx_SetMainModeRuleOperation) *xxx_SetMainModeRuleOperation {
	if op == nil {
		op = &xxx_SetMainModeRuleOperation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.MMRule = o.MMRule
	return op
}

func (o *SetMainModeRuleRequest) xxx_FromOp(ctx context.Context, op *xxx_SetMainModeRuleOperation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.MMRule = op.MMRule
}
func (o *SetMainModeRuleRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetMainModeRuleRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetMainModeRuleOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetMainModeRuleResponse structure represents the RRPC_FWSetMainModeRule operation response
type SetMainModeRuleResponse struct {
	// pStatus: This is an output parameter that on return will have the status code of
	// the rule.
	Status fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	// Return: The RRPC_FWSetMainModeRule return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetMainModeRuleResponse) xxx_ToOp(ctx context.Context, op *xxx_SetMainModeRuleOperation) *xxx_SetMainModeRuleOperation {
	if op == nil {
		op = &xxx_SetMainModeRuleOperation{}
	}
	if o == nil {
		return op
	}
	op.Status = o.Status
	op.Return = o.Return
	return op
}

func (o *SetMainModeRuleResponse) xxx_FromOp(ctx context.Context, op *xxx_SetMainModeRuleOperation) {
	if o == nil {
		return
	}
	o.Status = op.Status
	o.Return = op.Return
}
func (o *SetMainModeRuleResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetMainModeRuleResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetMainModeRuleOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_DeleteMainModeRuleOperation structure represents the RRPC_FWDeleteMainModeRule operation
type xxx_DeleteMainModeRuleOperation struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	RuleID      string       `idl:"name:pRuleId;string;pointer:ref" json:"rule_id"`
	Return      uint32       `idl:"name:Return" json:"return"`
}

func (o *xxx_DeleteMainModeRuleOperation) OpNum() int { return 34 }

func (o *xxx_DeleteMainModeRuleOperation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWDeleteMainModeRule"
}

func (o *xxx_DeleteMainModeRuleOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteMainModeRuleOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pRuleId {in} (1:{string, pointer=ref, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.RuleID); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteMainModeRuleOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pRuleId {in} (1:{string, pointer=ref, alias=LPWSTR}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.RuleID); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteMainModeRuleOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteMainModeRuleOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteMainModeRuleOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// DeleteMainModeRuleRequest structure represents the RRPC_FWDeleteMainModeRule operation request
type DeleteMainModeRuleRequest struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pRuleId: This parameter is the pointer to a STRING that is the ID of the main mode
	// rule the client deletes from the specified store.
	RuleID string `idl:"name:pRuleId;string;pointer:ref" json:"rule_id"`
}

func (o *DeleteMainModeRuleRequest) xxx_ToOp(ctx context.Context, op *xxx_DeleteMainModeRuleOperation) *xxx_DeleteMainModeRuleOperation {
	if op == nil {
		op = &xxx_DeleteMainModeRuleOperation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.RuleID = o.RuleID
	return op
}

func (o *DeleteMainModeRuleRequest) xxx_FromOp(ctx context.Context, op *xxx_DeleteMainModeRuleOperation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.RuleID = op.RuleID
}
func (o *DeleteMainModeRuleRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *DeleteMainModeRuleRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteMainModeRuleOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// DeleteMainModeRuleResponse structure represents the RRPC_FWDeleteMainModeRule operation response
type DeleteMainModeRuleResponse struct {
	// Return: The RRPC_FWDeleteMainModeRule return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *DeleteMainModeRuleResponse) xxx_ToOp(ctx context.Context, op *xxx_DeleteMainModeRuleOperation) *xxx_DeleteMainModeRuleOperation {
	if op == nil {
		op = &xxx_DeleteMainModeRuleOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *DeleteMainModeRuleResponse) xxx_FromOp(ctx context.Context, op *xxx_DeleteMainModeRuleOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *DeleteMainModeRuleResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *DeleteMainModeRuleResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteMainModeRuleOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_DeleteAllMainModeRulesOperation structure represents the RRPC_FWDeleteAllMainModeRules operation
type xxx_DeleteAllMainModeRulesOperation struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	Return      uint32       `idl:"name:Return" json:"return"`
}

func (o *xxx_DeleteAllMainModeRulesOperation) OpNum() int { return 35 }

func (o *xxx_DeleteAllMainModeRulesOperation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWDeleteAllMainModeRules"
}

func (o *xxx_DeleteAllMainModeRulesOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteAllMainModeRulesOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_DeleteAllMainModeRulesOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteAllMainModeRulesOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteAllMainModeRulesOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeleteAllMainModeRulesOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// DeleteAllMainModeRulesRequest structure represents the RRPC_FWDeleteAllMainModeRules operation request
type DeleteAllMainModeRulesRequest struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
}

func (o *DeleteAllMainModeRulesRequest) xxx_ToOp(ctx context.Context, op *xxx_DeleteAllMainModeRulesOperation) *xxx_DeleteAllMainModeRulesOperation {
	if op == nil {
		op = &xxx_DeleteAllMainModeRulesOperation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	return op
}

func (o *DeleteAllMainModeRulesRequest) xxx_FromOp(ctx context.Context, op *xxx_DeleteAllMainModeRulesOperation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
}
func (o *DeleteAllMainModeRulesRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *DeleteAllMainModeRulesRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteAllMainModeRulesOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// DeleteAllMainModeRulesResponse structure represents the RRPC_FWDeleteAllMainModeRules operation response
type DeleteAllMainModeRulesResponse struct {
	// Return: The RRPC_FWDeleteAllMainModeRules return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *DeleteAllMainModeRulesResponse) xxx_ToOp(ctx context.Context, op *xxx_DeleteAllMainModeRulesOperation) *xxx_DeleteAllMainModeRulesOperation {
	if op == nil {
		op = &xxx_DeleteAllMainModeRulesOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *DeleteAllMainModeRulesResponse) xxx_FromOp(ctx context.Context, op *xxx_DeleteAllMainModeRulesOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *DeleteAllMainModeRulesResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *DeleteAllMainModeRulesResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeleteAllMainModeRulesOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumMainModeRulesOperation structure represents the RRPC_FWEnumMainModeRules operation
type xxx_EnumMainModeRulesOperation struct {
	PolicyStore      *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	FilteredByStatus uint32       `idl:"name:dwFilteredByStatus" json:"filtered_by_status"`
	ProfileFilter    uint32       `idl:"name:dwProfileFilter" json:"profile_filter"`
	Flags            uint16       `idl:"name:wFlags" json:"flags"`
	RulesLength      uint32       `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	MMRules          *fasp.MMRule `idl:"name:ppMMRules" json:"mm_rules"`
	Return           uint32       `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumMainModeRulesOperation) OpNum() int { return 36 }

func (o *xxx_EnumMainModeRulesOperation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWEnumMainModeRules"
}

func (o *xxx_EnumMainModeRulesOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumMainModeRulesOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwFilteredByStatus {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.FilteredByStatus); err != nil {
			return err
		}
	}
	// dwProfileFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ProfileFilter); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumMainModeRulesOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwFilteredByStatus {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.FilteredByStatus); err != nil {
			return err
		}
	}
	// dwProfileFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ProfileFilter); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumMainModeRulesOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumMainModeRulesOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RulesLength); err != nil {
			return err
		}
	}
	// ppMMRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_MM_RULE}*(1))(3:{alias=FW_MM_RULE}(struct))
	{
		if o.MMRules != nil {
			_ptr_ppMMRules := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.MMRules != nil {
					if err := o.MMRules.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&fasp.MMRule{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.MMRules, _ptr_ppMMRules); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumMainModeRulesOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RulesLength); err != nil {
			return err
		}
	}
	// ppMMRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_MM_RULE,pointer=ref}*(1))(3:{alias=FW_MM_RULE}(struct))
	{
		_ptr_ppMMRules := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.MMRules == nil {
				o.MMRules = &fasp.MMRule{}
			}
			if err := o.MMRules.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ppMMRules := func(ptr interface{}) { o.MMRules = *ptr.(**fasp.MMRule) }
		if err := w.ReadPointer(&o.MMRules, _s_ppMMRules, _ptr_ppMMRules); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumMainModeRulesRequest structure represents the RRPC_FWEnumMainModeRules operation request
type EnumMainModeRulesRequest struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// dwFilteredByStatus: This parameter is a combination of flags from the FW_RULE_STATUS_CLASS
	// enumeration. This method uses this bitmask to determine which rules will be returned.
	// Rules that contain a status code of the class specified by this parameter will be
	// returned in the linked list.
	FilteredByStatus uint32 `idl:"name:dwFilteredByStatus" json:"filtered_by_status"`
	// dwProfileFilter: This parameter is a combination of flags from the FW_PROFILE_TYPE
	// enumeration. This method also uses this parameter to determine which rules will be
	// returned. Rules that contain a profile specified by this parameter will be returned
	// in the linked list.
	ProfileFilter uint32 `idl:"name:dwProfileFilter" json:"profile_filter"`
	// wFlags: This parameter is a combination of flags from the FW_ENUM_RULES_FLAGS enumeration,
	// which modifies the behavior of the method and performs operations on the rules before
	// returning them in the linked list.
	Flags uint16 `idl:"name:wFlags" json:"flags"`
}

func (o *EnumMainModeRulesRequest) xxx_ToOp(ctx context.Context, op *xxx_EnumMainModeRulesOperation) *xxx_EnumMainModeRulesOperation {
	if op == nil {
		op = &xxx_EnumMainModeRulesOperation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.FilteredByStatus = o.FilteredByStatus
	op.ProfileFilter = o.ProfileFilter
	op.Flags = o.Flags
	return op
}

func (o *EnumMainModeRulesRequest) xxx_FromOp(ctx context.Context, op *xxx_EnumMainModeRulesOperation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.FilteredByStatus = op.FilteredByStatus
	o.ProfileFilter = op.ProfileFilter
	o.Flags = op.Flags
}
func (o *EnumMainModeRulesRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumMainModeRulesRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumMainModeRulesOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumMainModeRulesResponse structure represents the RRPC_FWEnumMainModeRules operation response
type EnumMainModeRulesResponse struct {
	// pdwNumRules: This is an output parameter that on success MUST be equal to the number
	// of rules returned.
	RulesLength uint32 `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	// ppMMRules: This is an output parameter that on success contains a linked list of
	// FW_MM_RULE data types.
	MMRules *fasp.MMRule `idl:"name:ppMMRules" json:"mm_rules"`
	// Return: The RRPC_FWEnumMainModeRules return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumMainModeRulesResponse) xxx_ToOp(ctx context.Context, op *xxx_EnumMainModeRulesOperation) *xxx_EnumMainModeRulesOperation {
	if op == nil {
		op = &xxx_EnumMainModeRulesOperation{}
	}
	if o == nil {
		return op
	}
	op.RulesLength = o.RulesLength
	op.MMRules = o.MMRules
	op.Return = o.Return
	return op
}

func (o *EnumMainModeRulesResponse) xxx_FromOp(ctx context.Context, op *xxx_EnumMainModeRulesOperation) {
	if o == nil {
		return
	}
	o.RulesLength = op.RulesLength
	o.MMRules = op.MMRules
	o.Return = op.Return
}
func (o *EnumMainModeRulesResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumMainModeRulesResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumMainModeRulesOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_QueryFirewallRulesOperation structure represents the RRPC_FWQueryFirewallRules operation
type xxx_QueryFirewallRulesOperation struct {
	PolicyStore *PolicyStore  `idl:"name:hPolicyStore" json:"policy_store"`
	Query       *fasp.Query   `idl:"name:pQuery" json:"query"`
	Flags       uint16        `idl:"name:wFlags" json:"flags"`
	RulesLength uint32        `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	Rules       *fasp.Rule210 `idl:"name:ppRules" json:"rules"`
	Return      uint32        `idl:"name:Return" json:"return"`
}

func (o *xxx_QueryFirewallRulesOperation) OpNum() int { return 37 }

func (o *xxx_QueryFirewallRulesOperation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWQueryFirewallRules"
}

func (o *xxx_QueryFirewallRulesOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryFirewallRulesOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pQuery {in} (1:{alias=PFW_QUERY}*(1))(2:{alias=FW_QUERY}(struct))
	{
		if o.Query != nil {
			if err := o.Query.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.Query{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryFirewallRulesOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pQuery {in} (1:{alias=PFW_QUERY,pointer=ref}*(1))(2:{alias=FW_QUERY}(struct))
	{
		if o.Query == nil {
			o.Query = &fasp.Query{}
		}
		if err := o.Query.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryFirewallRulesOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryFirewallRulesOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RulesLength); err != nil {
			return err
		}
	}
	// ppRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_RULE2_10}*(1))(3:{alias=FW_RULE2_10}(struct))
	{
		if o.Rules != nil {
			_ptr_ppRules := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Rules != nil {
					if err := o.Rules.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&fasp.Rule210{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Rules, _ptr_ppRules); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryFirewallRulesOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RulesLength); err != nil {
			return err
		}
	}
	// ppRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_RULE2_10,pointer=ref}*(1))(3:{alias=FW_RULE2_10}(struct))
	{
		_ptr_ppRules := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Rules == nil {
				o.Rules = &fasp.Rule210{}
			}
			if err := o.Rules.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ppRules := func(ptr interface{}) { o.Rules = *ptr.(**fasp.Rule210) }
		if err := w.ReadPointer(&o.Rules, _s_ppRules, _ptr_ppRules); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// QueryFirewallRulesRequest structure represents the RRPC_FWQueryFirewallRules operation request
type QueryFirewallRulesRequest struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pQuery: This parameter represents the query object that the client uses to specify
	// which main mode rules MUST be retrieved from the store. The query object MUST be
	// valid, as specified in the definition of the FW_QUERY data type.
	Query *fasp.Query `idl:"name:pQuery" json:"query"`
	// wFlags: This parameter is a combination of flags from the FW_ENUM_RULES_FLAGS enumeration,
	// which modifies the behavior of the method and performs operations on the rules before
	// returning them in the linked list.
	Flags uint16 `idl:"name:wFlags" json:"flags"`
}

func (o *QueryFirewallRulesRequest) xxx_ToOp(ctx context.Context, op *xxx_QueryFirewallRulesOperation) *xxx_QueryFirewallRulesOperation {
	if op == nil {
		op = &xxx_QueryFirewallRulesOperation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Query = o.Query
	op.Flags = o.Flags
	return op
}

func (o *QueryFirewallRulesRequest) xxx_FromOp(ctx context.Context, op *xxx_QueryFirewallRulesOperation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Query = op.Query
	o.Flags = op.Flags
}
func (o *QueryFirewallRulesRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *QueryFirewallRulesRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryFirewallRulesOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// QueryFirewallRulesResponse structure represents the RRPC_FWQueryFirewallRules operation response
type QueryFirewallRulesResponse struct {
	// pdwNumRules: This is an output parameter that on success MUST be equal to the number
	// of rules returned.
	RulesLength uint32        `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	Rules       *fasp.Rule210 `idl:"name:ppRules" json:"rules"`
	// Return: The RRPC_FWQueryFirewallRules return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *QueryFirewallRulesResponse) xxx_ToOp(ctx context.Context, op *xxx_QueryFirewallRulesOperation) *xxx_QueryFirewallRulesOperation {
	if op == nil {
		op = &xxx_QueryFirewallRulesOperation{}
	}
	if o == nil {
		return op
	}
	op.RulesLength = o.RulesLength
	op.Rules = o.Rules
	op.Return = o.Return
	return op
}

func (o *QueryFirewallRulesResponse) xxx_FromOp(ctx context.Context, op *xxx_QueryFirewallRulesOperation) {
	if o == nil {
		return
	}
	o.RulesLength = op.RulesLength
	o.Rules = op.Rules
	o.Return = op.Return
}
func (o *QueryFirewallRulesResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *QueryFirewallRulesResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryFirewallRulesOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_QueryConnectionSecurityRules210Operation structure represents the RRPC_FWQueryConnectionSecurityRules2_10 operation
type xxx_QueryConnectionSecurityRules210Operation struct {
	PolicyStore *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	Query       *fasp.Query     `idl:"name:pQuery" json:"query"`
	Flags       uint16          `idl:"name:wFlags" json:"flags"`
	RulesLength uint32          `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	Rules       *fasp.CSRule210 `idl:"name:ppRules" json:"rules"`
	Return      uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_QueryConnectionSecurityRules210Operation) OpNum() int { return 38 }

func (o *xxx_QueryConnectionSecurityRules210Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWQueryConnectionSecurityRules2_10"
}

func (o *xxx_QueryConnectionSecurityRules210Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryConnectionSecurityRules210Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pQuery {in} (1:{alias=PFW_QUERY}*(1))(2:{alias=FW_QUERY}(struct))
	{
		if o.Query != nil {
			if err := o.Query.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.Query{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryConnectionSecurityRules210Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pQuery {in} (1:{alias=PFW_QUERY,pointer=ref}*(1))(2:{alias=FW_QUERY}(struct))
	{
		if o.Query == nil {
			o.Query = &fasp.Query{}
		}
		if err := o.Query.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryConnectionSecurityRules210Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryConnectionSecurityRules210Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RulesLength); err != nil {
			return err
		}
	}
	// ppRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_CS_RULE2_10}*(1))(3:{alias=FW_CS_RULE2_10}(struct))
	{
		if o.Rules != nil {
			_ptr_ppRules := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Rules != nil {
					if err := o.Rules.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&fasp.CSRule210{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Rules, _ptr_ppRules); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryConnectionSecurityRules210Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RulesLength); err != nil {
			return err
		}
	}
	// ppRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_CS_RULE2_10,pointer=ref}*(1))(3:{alias=FW_CS_RULE2_10}(struct))
	{
		_ptr_ppRules := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Rules == nil {
				o.Rules = &fasp.CSRule210{}
			}
			if err := o.Rules.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ppRules := func(ptr interface{}) { o.Rules = *ptr.(**fasp.CSRule210) }
		if err := w.ReadPointer(&o.Rules, _s_ppRules, _ptr_ppRules); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// QueryConnectionSecurityRules210Request structure represents the RRPC_FWQueryConnectionSecurityRules2_10 operation request
type QueryConnectionSecurityRules210Request struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	Query       *fasp.Query  `idl:"name:pQuery" json:"query"`
	Flags       uint16       `idl:"name:wFlags" json:"flags"`
}

func (o *QueryConnectionSecurityRules210Request) xxx_ToOp(ctx context.Context, op *xxx_QueryConnectionSecurityRules210Operation) *xxx_QueryConnectionSecurityRules210Operation {
	if op == nil {
		op = &xxx_QueryConnectionSecurityRules210Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Query = o.Query
	op.Flags = o.Flags
	return op
}

func (o *QueryConnectionSecurityRules210Request) xxx_FromOp(ctx context.Context, op *xxx_QueryConnectionSecurityRules210Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Query = op.Query
	o.Flags = op.Flags
}
func (o *QueryConnectionSecurityRules210Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *QueryConnectionSecurityRules210Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryConnectionSecurityRules210Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// QueryConnectionSecurityRules210Response structure represents the RRPC_FWQueryConnectionSecurityRules2_10 operation response
type QueryConnectionSecurityRules210Response struct {
	RulesLength uint32          `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	Rules       *fasp.CSRule210 `idl:"name:ppRules" json:"rules"`
	// Return: The RRPC_FWQueryConnectionSecurityRules2_10 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *QueryConnectionSecurityRules210Response) xxx_ToOp(ctx context.Context, op *xxx_QueryConnectionSecurityRules210Operation) *xxx_QueryConnectionSecurityRules210Operation {
	if op == nil {
		op = &xxx_QueryConnectionSecurityRules210Operation{}
	}
	if o == nil {
		return op
	}
	op.RulesLength = o.RulesLength
	op.Rules = o.Rules
	op.Return = o.Return
	return op
}

func (o *QueryConnectionSecurityRules210Response) xxx_FromOp(ctx context.Context, op *xxx_QueryConnectionSecurityRules210Operation) {
	if o == nil {
		return
	}
	o.RulesLength = op.RulesLength
	o.Rules = op.Rules
	o.Return = op.Return
}
func (o *QueryConnectionSecurityRules210Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *QueryConnectionSecurityRules210Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryConnectionSecurityRules210Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_QueryMainModeRulesOperation structure represents the RRPC_FWQueryMainModeRules operation
type xxx_QueryMainModeRulesOperation struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	Query       *fasp.Query  `idl:"name:pQuery" json:"query"`
	Flags       uint16       `idl:"name:wFlags" json:"flags"`
	RulesLength uint32       `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	MMRules     *fasp.MMRule `idl:"name:ppMMRules" json:"mm_rules"`
	Return      uint32       `idl:"name:Return" json:"return"`
}

func (o *xxx_QueryMainModeRulesOperation) OpNum() int { return 39 }

func (o *xxx_QueryMainModeRulesOperation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWQueryMainModeRules"
}

func (o *xxx_QueryMainModeRulesOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryMainModeRulesOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pQuery {in} (1:{alias=PFW_QUERY}*(1))(2:{alias=FW_QUERY}(struct))
	{
		if o.Query != nil {
			if err := o.Query.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.Query{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryMainModeRulesOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pQuery {in} (1:{alias=PFW_QUERY,pointer=ref}*(1))(2:{alias=FW_QUERY}(struct))
	{
		if o.Query == nil {
			o.Query = &fasp.Query{}
		}
		if err := o.Query.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryMainModeRulesOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryMainModeRulesOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RulesLength); err != nil {
			return err
		}
	}
	// ppMMRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_MM_RULE}*(1))(3:{alias=FW_MM_RULE}(struct))
	{
		if o.MMRules != nil {
			_ptr_ppMMRules := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.MMRules != nil {
					if err := o.MMRules.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&fasp.MMRule{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.MMRules, _ptr_ppMMRules); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryMainModeRulesOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RulesLength); err != nil {
			return err
		}
	}
	// ppMMRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_MM_RULE,pointer=ref}*(1))(3:{alias=FW_MM_RULE}(struct))
	{
		_ptr_ppMMRules := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.MMRules == nil {
				o.MMRules = &fasp.MMRule{}
			}
			if err := o.MMRules.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ppMMRules := func(ptr interface{}) { o.MMRules = *ptr.(**fasp.MMRule) }
		if err := w.ReadPointer(&o.MMRules, _s_ppMMRules, _ptr_ppMMRules); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// QueryMainModeRulesRequest structure represents the RRPC_FWQueryMainModeRules operation request
type QueryMainModeRulesRequest struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pQuery: This parameter represents the query object that the client uses to specify
	// which main mode rules MUST be retrieved from the store. The query object MUST be
	// valid, as specified in the definition of the FW_QUERY data type.
	Query *fasp.Query `idl:"name:pQuery" json:"query"`
	// wFlags: This parameter is a combination of flags from the FW_ENUM_RULES_FLAGS enumeration,
	// which modifies the behavior of the method and performs operations on the rules before
	// returning them in the linked list.
	Flags uint16 `idl:"name:wFlags" json:"flags"`
}

func (o *QueryMainModeRulesRequest) xxx_ToOp(ctx context.Context, op *xxx_QueryMainModeRulesOperation) *xxx_QueryMainModeRulesOperation {
	if op == nil {
		op = &xxx_QueryMainModeRulesOperation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Query = o.Query
	op.Flags = o.Flags
	return op
}

func (o *QueryMainModeRulesRequest) xxx_FromOp(ctx context.Context, op *xxx_QueryMainModeRulesOperation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Query = op.Query
	o.Flags = op.Flags
}
func (o *QueryMainModeRulesRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *QueryMainModeRulesRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryMainModeRulesOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// QueryMainModeRulesResponse structure represents the RRPC_FWQueryMainModeRules operation response
type QueryMainModeRulesResponse struct {
	// pdwNumRules: This is an output parameter that on success MUST be equal to the number
	// of rules returned.
	RulesLength uint32 `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	// ppMMRules: This is an output parameter that on success contains a linked list of
	// FW_MM_RULE data types.
	MMRules *fasp.MMRule `idl:"name:ppMMRules" json:"mm_rules"`
	// Return: The RRPC_FWQueryMainModeRules return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *QueryMainModeRulesResponse) xxx_ToOp(ctx context.Context, op *xxx_QueryMainModeRulesOperation) *xxx_QueryMainModeRulesOperation {
	if op == nil {
		op = &xxx_QueryMainModeRulesOperation{}
	}
	if o == nil {
		return op
	}
	op.RulesLength = o.RulesLength
	op.MMRules = o.MMRules
	op.Return = o.Return
	return op
}

func (o *QueryMainModeRulesResponse) xxx_FromOp(ctx context.Context, op *xxx_QueryMainModeRulesOperation) {
	if o == nil {
		return
	}
	o.RulesLength = op.RulesLength
	o.MMRules = op.MMRules
	o.Return = op.Return
}
func (o *QueryMainModeRulesResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *QueryMainModeRulesResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryMainModeRulesOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_QueryAuthenticationSetsOperation structure represents the RRPC_FWQueryAuthenticationSets operation
type xxx_QueryAuthenticationSetsOperation struct {
	PolicyStore *PolicyStore     `idl:"name:hPolicyStore" json:"policy_store"`
	IPsecPhase  fasp.IPsecPhase  `idl:"name:IPsecPhase" json:"ipsec_phase"`
	Query       *fasp.Query      `idl:"name:pQuery" json:"query"`
	Flags       uint16           `idl:"name:wFlags" json:"flags"`
	SetsLength  uint32           `idl:"name:pdwNumSets;pointer:ref" json:"sets_length"`
	AuthSets    *fasp.AuthSet210 `idl:"name:ppAuthSets" json:"auth_sets"`
	Return      uint32           `idl:"name:Return" json:"return"`
}

func (o *xxx_QueryAuthenticationSetsOperation) OpNum() int { return 40 }

func (o *xxx_QueryAuthenticationSetsOperation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWQueryAuthenticationSets"
}

func (o *xxx_QueryAuthenticationSetsOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.IPsecPhase < fasp.IPsecPhase(1) || o.IPsecPhase > fasp.IPsecPhase(2) {
		return fmt.Errorf("IPsecPhase is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryAuthenticationSetsOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// IPsecPhase {in} (1:{range=(1,2), alias=FW_IPSEC_PHASE}(enum))
	{
		if err := w.WriteEnum(uint16(o.IPsecPhase)); err != nil {
			return err
		}
	}
	// pQuery {in} (1:{alias=PFW_QUERY}*(1))(2:{alias=FW_QUERY}(struct))
	{
		if o.Query != nil {
			if err := o.Query.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.Query{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryAuthenticationSetsOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// IPsecPhase {in} (1:{range=(1,2), alias=FW_IPSEC_PHASE}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.IPsecPhase)); err != nil {
			return err
		}
	}
	// pQuery {in} (1:{alias=PFW_QUERY,pointer=ref}*(1))(2:{alias=FW_QUERY}(struct))
	{
		if o.Query == nil {
			o.Query = &fasp.Query{}
		}
		if err := o.Query.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryAuthenticationSetsOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryAuthenticationSetsOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwNumSets {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.SetsLength); err != nil {
			return err
		}
	}
	// ppAuthSets {out} (1:{pointer=ref}*(2))(2:{alias=PFW_AUTH_SET2_10}*(1))(3:{alias=FW_AUTH_SET2_10}(struct))
	{
		if o.AuthSets != nil {
			_ptr_ppAuthSets := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.AuthSets != nil {
					if err := o.AuthSets.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&fasp.AuthSet210{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.AuthSets, _ptr_ppAuthSets); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryAuthenticationSetsOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwNumSets {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.SetsLength); err != nil {
			return err
		}
	}
	// ppAuthSets {out} (1:{pointer=ref}*(2))(2:{alias=PFW_AUTH_SET2_10,pointer=ref}*(1))(3:{alias=FW_AUTH_SET2_10}(struct))
	{
		_ptr_ppAuthSets := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.AuthSets == nil {
				o.AuthSets = &fasp.AuthSet210{}
			}
			if err := o.AuthSets.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ppAuthSets := func(ptr interface{}) { o.AuthSets = *ptr.(**fasp.AuthSet210) }
		if err := w.ReadPointer(&o.AuthSets, _s_ppAuthSets, _ptr_ppAuthSets); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// QueryAuthenticationSetsRequest structure represents the RRPC_FWQueryAuthenticationSets operation request
type QueryAuthenticationSetsRequest struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// IPsecPhase: This parameter specifies the specific IPsec negotiation phase to which
	// this set applies.
	IPsecPhase fasp.IPsecPhase `idl:"name:IPsecPhase" json:"ipsec_phase"`
	// pQuery: This parameter represents the query object that the client wants to use to
	// specify which main mode rules MUST be retrieved from the store. The query object
	// MUST be valid, as specified in the definition of the FW_QUERY data type.
	Query *fasp.Query `idl:"name:pQuery" json:"query"`
	// wFlags: This parameter is a combination of flags from the FW_ENUM_RULES_FLAGS enumeration,
	// which modifies the behavior of the method and performs operations on the rules before
	// returning them in the linked list.
	Flags uint16 `idl:"name:wFlags" json:"flags"`
}

func (o *QueryAuthenticationSetsRequest) xxx_ToOp(ctx context.Context, op *xxx_QueryAuthenticationSetsOperation) *xxx_QueryAuthenticationSetsOperation {
	if op == nil {
		op = &xxx_QueryAuthenticationSetsOperation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.IPsecPhase = o.IPsecPhase
	op.Query = o.Query
	op.Flags = o.Flags
	return op
}

func (o *QueryAuthenticationSetsRequest) xxx_FromOp(ctx context.Context, op *xxx_QueryAuthenticationSetsOperation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.IPsecPhase = op.IPsecPhase
	o.Query = op.Query
	o.Flags = op.Flags
}
func (o *QueryAuthenticationSetsRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *QueryAuthenticationSetsRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryAuthenticationSetsOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// QueryAuthenticationSetsResponse structure represents the RRPC_FWQueryAuthenticationSets operation response
type QueryAuthenticationSetsResponse struct {
	// pdwNumSets: This is an output parameter that, on success, MUST be equal to the number
	// of sets returned.
	SetsLength uint32 `idl:"name:pdwNumSets;pointer:ref" json:"sets_length"`
	// ppAuthSets: This is an output parameter that on success contains a linked list of
	// FW_AUTH_SET2_10 data types.
	AuthSets *fasp.AuthSet210 `idl:"name:ppAuthSets" json:"auth_sets"`
	// Return: The RRPC_FWQueryAuthenticationSets return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *QueryAuthenticationSetsResponse) xxx_ToOp(ctx context.Context, op *xxx_QueryAuthenticationSetsOperation) *xxx_QueryAuthenticationSetsOperation {
	if op == nil {
		op = &xxx_QueryAuthenticationSetsOperation{}
	}
	if o == nil {
		return op
	}
	op.SetsLength = o.SetsLength
	op.AuthSets = o.AuthSets
	op.Return = o.Return
	return op
}

func (o *QueryAuthenticationSetsResponse) xxx_FromOp(ctx context.Context, op *xxx_QueryAuthenticationSetsOperation) {
	if o == nil {
		return
	}
	o.SetsLength = op.SetsLength
	o.AuthSets = op.AuthSets
	o.Return = op.Return
}
func (o *QueryAuthenticationSetsResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *QueryAuthenticationSetsResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryAuthenticationSetsOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_QueryCryptoSetsOperation structure represents the RRPC_FWQueryCryptoSets operation
type xxx_QueryCryptoSetsOperation struct {
	PolicyStore *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	IPsecPhase  fasp.IPsecPhase `idl:"name:IPsecPhase" json:"ipsec_phase"`
	Query       *fasp.Query     `idl:"name:pQuery" json:"query"`
	Flags       uint16          `idl:"name:wFlags" json:"flags"`
	SetsLength  uint32          `idl:"name:pdwNumSets;pointer:ref" json:"sets_length"`
	CryptoSets  *fasp.CryptoSet `idl:"name:ppCryptoSets" json:"crypto_sets"`
	Return      uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_QueryCryptoSetsOperation) OpNum() int { return 41 }

func (o *xxx_QueryCryptoSetsOperation) OpName() string { return "/RemoteFW/v1/RRPC_FWQueryCryptoSets" }

func (o *xxx_QueryCryptoSetsOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.IPsecPhase < fasp.IPsecPhase(1) || o.IPsecPhase > fasp.IPsecPhase(2) {
		return fmt.Errorf("IPsecPhase is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryCryptoSetsOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// IPsecPhase {in} (1:{range=(1,2), alias=FW_IPSEC_PHASE}(enum))
	{
		if err := w.WriteEnum(uint16(o.IPsecPhase)); err != nil {
			return err
		}
	}
	// pQuery {in} (1:{alias=PFW_QUERY}*(1))(2:{alias=FW_QUERY}(struct))
	{
		if o.Query != nil {
			if err := o.Query.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.Query{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryCryptoSetsOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// IPsecPhase {in} (1:{range=(1,2), alias=FW_IPSEC_PHASE}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.IPsecPhase)); err != nil {
			return err
		}
	}
	// pQuery {in} (1:{alias=PFW_QUERY,pointer=ref}*(1))(2:{alias=FW_QUERY}(struct))
	{
		if o.Query == nil {
			o.Query = &fasp.Query{}
		}
		if err := o.Query.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryCryptoSetsOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryCryptoSetsOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwNumSets {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.SetsLength); err != nil {
			return err
		}
	}
	// ppCryptoSets {out} (1:{pointer=ref}*(2))(2:{alias=PFW_CRYPTO_SET}*(1))(3:{alias=FW_CRYPTO_SET}(struct))
	{
		if o.CryptoSets != nil {
			_ptr_ppCryptoSets := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.CryptoSets != nil {
					if err := o.CryptoSets.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&fasp.CryptoSet{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.CryptoSets, _ptr_ppCryptoSets); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryCryptoSetsOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwNumSets {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.SetsLength); err != nil {
			return err
		}
	}
	// ppCryptoSets {out} (1:{pointer=ref}*(2))(2:{alias=PFW_CRYPTO_SET,pointer=ref}*(1))(3:{alias=FW_CRYPTO_SET}(struct))
	{
		_ptr_ppCryptoSets := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.CryptoSets == nil {
				o.CryptoSets = &fasp.CryptoSet{}
			}
			if err := o.CryptoSets.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ppCryptoSets := func(ptr interface{}) { o.CryptoSets = *ptr.(**fasp.CryptoSet) }
		if err := w.ReadPointer(&o.CryptoSets, _s_ppCryptoSets, _ptr_ppCryptoSets); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// QueryCryptoSetsRequest structure represents the RRPC_FWQueryCryptoSets operation request
type QueryCryptoSetsRequest struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// IPsecPhase: This parameter specifies the specific IPsec negotiation phase to which
	// this set applies.
	IPsecPhase fasp.IPsecPhase `idl:"name:IPsecPhase" json:"ipsec_phase"`
	// pQuery: This parameter represents the query object that the client wants to use to
	// specify which main mode rules MUST be retrieved from the store. The query object
	// MUST be valid, as specified in the definition of the FW_QUERY data type.
	Query *fasp.Query `idl:"name:pQuery" json:"query"`
	// wFlags: This parameter is a combination of flags from the FW_ENUM_RULES_FLAGS enumeration,
	// which modifies the behavior of the method and performs operations on the rules before
	// returning them in the linked list.
	Flags uint16 `idl:"name:wFlags" json:"flags"`
}

func (o *QueryCryptoSetsRequest) xxx_ToOp(ctx context.Context, op *xxx_QueryCryptoSetsOperation) *xxx_QueryCryptoSetsOperation {
	if op == nil {
		op = &xxx_QueryCryptoSetsOperation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.IPsecPhase = o.IPsecPhase
	op.Query = o.Query
	op.Flags = o.Flags
	return op
}

func (o *QueryCryptoSetsRequest) xxx_FromOp(ctx context.Context, op *xxx_QueryCryptoSetsOperation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.IPsecPhase = op.IPsecPhase
	o.Query = op.Query
	o.Flags = op.Flags
}
func (o *QueryCryptoSetsRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *QueryCryptoSetsRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryCryptoSetsOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// QueryCryptoSetsResponse structure represents the RRPC_FWQueryCryptoSets operation response
type QueryCryptoSetsResponse struct {
	// pdwNumSets: This is an output parameter that, on success, MUST be equal to the number
	// of sets returned.
	SetsLength uint32 `idl:"name:pdwNumSets;pointer:ref" json:"sets_length"`
	// ppCryptoSets: This is an output parameter that, on success, contains a linked list
	// of FW_CRYPTO_SET data types.
	CryptoSets *fasp.CryptoSet `idl:"name:ppCryptoSets" json:"crypto_sets"`
	// Return: The RRPC_FWQueryCryptoSets return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *QueryCryptoSetsResponse) xxx_ToOp(ctx context.Context, op *xxx_QueryCryptoSetsOperation) *xxx_QueryCryptoSetsOperation {
	if op == nil {
		op = &xxx_QueryCryptoSetsOperation{}
	}
	if o == nil {
		return op
	}
	op.SetsLength = o.SetsLength
	op.CryptoSets = o.CryptoSets
	op.Return = o.Return
	return op
}

func (o *QueryCryptoSetsResponse) xxx_FromOp(ctx context.Context, op *xxx_QueryCryptoSetsOperation) {
	if o == nil {
		return
	}
	o.SetsLength = op.SetsLength
	o.CryptoSets = op.CryptoSets
	o.Return = op.Return
}
func (o *QueryCryptoSetsResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *QueryCryptoSetsResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryCryptoSetsOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumNetworksOperation structure represents the RRPC_FWEnumNetworks operation
type xxx_EnumNetworksOperation struct {
	PolicyStore    *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	NetworksLength uint32          `idl:"name:pdwNumNetworks" json:"networks_length"`
	Networks       []*fasp.Network `idl:"name:ppNetworks;size_is:(, pdwNumNetworks)" json:"networks"`
	Return         uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumNetworksOperation) OpNum() int { return 42 }

func (o *xxx_EnumNetworksOperation) OpName() string { return "/RemoteFW/v1/RRPC_FWEnumNetworks" }

func (o *xxx_EnumNetworksOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumNetworksOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_EnumNetworksOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumNetworksOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Networks != nil && o.NetworksLength == 0 {
		o.NetworksLength = uint32(len(o.Networks))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumNetworksOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwNumNetworks {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.NetworksLength); err != nil {
			return err
		}
	}
	// ppNetworks {out} (1:{pointer=ref}*(2))(2:{alias=PFW_NETWORK}*(1))(3:{alias=FW_NETWORK}[dim:0,size_is=pdwNumNetworks](struct))
	{
		if o.Networks != nil || o.NetworksLength > 0 {
			_ptr_ppNetworks := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.NetworksLength)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Networks {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if o.Networks[i1] != nil {
						if err := o.Networks[i1].MarshalNDR(ctx, w); err != nil {
							return err
						}
					} else {
						if err := (&fasp.Network{}).MarshalNDR(ctx, w); err != nil {
							return err
						}
					}
				}
				for i1 := len(o.Networks); uint64(i1) < sizeInfo[0]; i1++ {
					if err := (&fasp.Network{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Networks, _ptr_ppNetworks); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumNetworksOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwNumNetworks {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.NetworksLength); err != nil {
			return err
		}
	}
	// ppNetworks {out} (1:{pointer=ref}*(2))(2:{alias=PFW_NETWORK,pointer=ref}*(1))(3:{alias=FW_NETWORK}[dim:0,size_is=pdwNumNetworks](struct))
	{
		_ptr_ppNetworks := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Networks", sizeInfo[0])
			}
			o.Networks = make([]*fasp.Network, sizeInfo[0])
			for i1 := range o.Networks {
				i1 := i1
				if o.Networks[i1] == nil {
					o.Networks[i1] = &fasp.Network{}
				}
				if err := o.Networks[i1].UnmarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		_s_ppNetworks := func(ptr interface{}) { o.Networks = *ptr.(*[]*fasp.Network) }
		if err := w.ReadPointer(&o.Networks, _s_ppNetworks, _ptr_ppNetworks); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumNetworksRequest structure represents the RRPC_FWEnumNetworks operation request
type EnumNetworksRequest struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
}

func (o *EnumNetworksRequest) xxx_ToOp(ctx context.Context, op *xxx_EnumNetworksOperation) *xxx_EnumNetworksOperation {
	if op == nil {
		op = &xxx_EnumNetworksOperation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	return op
}

func (o *EnumNetworksRequest) xxx_FromOp(ctx context.Context, op *xxx_EnumNetworksOperation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
}
func (o *EnumNetworksRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumNetworksRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumNetworksOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumNetworksResponse structure represents the RRPC_FWEnumNetworks operation response
type EnumNetworksResponse struct {
	// pdwNumNetworks: This is an output parameter that, on success, MUST be equal to the
	// number of networks returned.
	NetworksLength uint32 `idl:"name:pdwNumNetworks" json:"networks_length"`
	// ppNetworks: This is an output parameter that, on success, contains an array of FW_NETWORK
	// data types.
	Networks []*fasp.Network `idl:"name:ppNetworks;size_is:(, pdwNumNetworks)" json:"networks"`
	// Return: The RRPC_FWEnumNetworks return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumNetworksResponse) xxx_ToOp(ctx context.Context, op *xxx_EnumNetworksOperation) *xxx_EnumNetworksOperation {
	if op == nil {
		op = &xxx_EnumNetworksOperation{}
	}
	if o == nil {
		return op
	}
	op.NetworksLength = o.NetworksLength
	op.Networks = o.Networks
	op.Return = o.Return
	return op
}

func (o *EnumNetworksResponse) xxx_FromOp(ctx context.Context, op *xxx_EnumNetworksOperation) {
	if o == nil {
		return
	}
	o.NetworksLength = op.NetworksLength
	o.Networks = op.Networks
	o.Return = op.Return
}
func (o *EnumNetworksResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumNetworksResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumNetworksOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumAdaptersOperation structure represents the RRPC_FWEnumAdapters operation
type xxx_EnumAdaptersOperation struct {
	PolicyStore    *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	AdaptersLength uint32          `idl:"name:pdwNumAdapters" json:"adapters_length"`
	Adapters       []*fasp.Adapter `idl:"name:ppAdapters;size_is:(, pdwNumAdapters)" json:"adapters"`
	Return         uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumAdaptersOperation) OpNum() int { return 43 }

func (o *xxx_EnumAdaptersOperation) OpName() string { return "/RemoteFW/v1/RRPC_FWEnumAdapters" }

func (o *xxx_EnumAdaptersOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumAdaptersOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_EnumAdaptersOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumAdaptersOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Adapters != nil && o.AdaptersLength == 0 {
		o.AdaptersLength = uint32(len(o.Adapters))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumAdaptersOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwNumAdapters {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.AdaptersLength); err != nil {
			return err
		}
	}
	// ppAdapters {out} (1:{pointer=ref}*(2))(2:{alias=PFW_ADAPTER}*(1))(3:{alias=FW_ADAPTER}[dim:0,size_is=pdwNumAdapters](struct))
	{
		if o.Adapters != nil || o.AdaptersLength > 0 {
			_ptr_ppAdapters := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.AdaptersLength)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.Adapters {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if o.Adapters[i1] != nil {
						if err := o.Adapters[i1].MarshalNDR(ctx, w); err != nil {
							return err
						}
					} else {
						if err := (&fasp.Adapter{}).MarshalNDR(ctx, w); err != nil {
							return err
						}
					}
				}
				for i1 := len(o.Adapters); uint64(i1) < sizeInfo[0]; i1++ {
					if err := (&fasp.Adapter{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Adapters, _ptr_ppAdapters); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumAdaptersOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwNumAdapters {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.AdaptersLength); err != nil {
			return err
		}
	}
	// ppAdapters {out} (1:{pointer=ref}*(2))(2:{alias=PFW_ADAPTER,pointer=ref}*(1))(3:{alias=FW_ADAPTER}[dim:0,size_is=pdwNumAdapters](struct))
	{
		_ptr_ppAdapters := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Adapters", sizeInfo[0])
			}
			o.Adapters = make([]*fasp.Adapter, sizeInfo[0])
			for i1 := range o.Adapters {
				i1 := i1
				if o.Adapters[i1] == nil {
					o.Adapters[i1] = &fasp.Adapter{}
				}
				if err := o.Adapters[i1].UnmarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		_s_ppAdapters := func(ptr interface{}) { o.Adapters = *ptr.(*[]*fasp.Adapter) }
		if err := w.ReadPointer(&o.Adapters, _s_ppAdapters, _ptr_ppAdapters); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumAdaptersRequest structure represents the RRPC_FWEnumAdapters operation request
type EnumAdaptersRequest struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
}

func (o *EnumAdaptersRequest) xxx_ToOp(ctx context.Context, op *xxx_EnumAdaptersOperation) *xxx_EnumAdaptersOperation {
	if op == nil {
		op = &xxx_EnumAdaptersOperation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	return op
}

func (o *EnumAdaptersRequest) xxx_FromOp(ctx context.Context, op *xxx_EnumAdaptersOperation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
}
func (o *EnumAdaptersRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumAdaptersRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumAdaptersOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumAdaptersResponse structure represents the RRPC_FWEnumAdapters operation response
type EnumAdaptersResponse struct {
	// pdwNumAdapters: This is an output parameter that, on success, MUST be equal to the
	// number of networks returned.
	AdaptersLength uint32 `idl:"name:pdwNumAdapters" json:"adapters_length"`
	// ppAdapters: This is an output parameter that, on success, contains an array of FW_ADAPTER
	// data types.
	Adapters []*fasp.Adapter `idl:"name:ppAdapters;size_is:(, pdwNumAdapters)" json:"adapters"`
	// Return: The RRPC_FWEnumAdapters return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumAdaptersResponse) xxx_ToOp(ctx context.Context, op *xxx_EnumAdaptersOperation) *xxx_EnumAdaptersOperation {
	if op == nil {
		op = &xxx_EnumAdaptersOperation{}
	}
	if o == nil {
		return op
	}
	op.AdaptersLength = o.AdaptersLength
	op.Adapters = o.Adapters
	op.Return = o.Return
	return op
}

func (o *EnumAdaptersResponse) xxx_FromOp(ctx context.Context, op *xxx_EnumAdaptersOperation) {
	if o == nil {
		return
	}
	o.AdaptersLength = op.AdaptersLength
	o.Adapters = op.Adapters
	o.Return = op.Return
}
func (o *EnumAdaptersResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumAdaptersResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumAdaptersOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetGlobalConfig210Operation structure represents the RRPC_FWGetGlobalConfig2_10 operation
type xxx_GetGlobalConfig210Operation struct {
	BinaryVersion     uint16              `idl:"name:BinaryVersion" json:"binary_version"`
	StoreType         fasp.StoreType      `idl:"name:StoreType" json:"store_type"`
	ConfigID          fasp.GlobalConfig   `idl:"name:configID" json:"config_id"`
	Flags             uint32              `idl:"name:dwFlags" json:"flags"`
	Buffer            []byte              `idl:"name:pBuffer;size_is:(cbData);length_is:(pcbTransmittedLen);pointer:unique" json:"buffer"`
	DataLength        uint32              `idl:"name:cbData" json:"data_length"`
	TransmittedLength uint32              `idl:"name:pcbTransmittedLen" json:"transmitted_length"`
	RequiredLength    uint32              `idl:"name:pcbRequired" json:"required_length"`
	Origin            fasp.RuleOriginType `idl:"name:pOrigin" json:"origin"`
	Return            uint32              `idl:"name:Return" json:"return"`
}

func (o *xxx_GetGlobalConfig210Operation) OpNum() int { return 44 }

func (o *xxx_GetGlobalConfig210Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWGetGlobalConfig2_10"
}

func (o *xxx_GetGlobalConfig210Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.Buffer != nil && o.DataLength == 0 {
		o.DataLength = uint32(len(o.Buffer))
	}
	if o.Buffer != nil && o.TransmittedLength == 0 {
		o.TransmittedLength = uint32(len(o.Buffer))
	}
	if o.ConfigID < fasp.GlobalConfig(1) || o.ConfigID > fasp.GlobalConfig(17) {
		return fmt.Errorf("ConfigID is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetGlobalConfig210Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// BinaryVersion {in} (1:{alias=WORD}(uint16))
	{
		if err := w.WriteData(o.BinaryVersion); err != nil {
			return err
		}
	}
	// StoreType {in} (1:{alias=FW_STORE_TYPE}(enum))
	{
		if err := w.WriteEnum(uint16(o.StoreType)); err != nil {
			return err
		}
	}
	// configID {in} (1:{range=(1,17), alias=FW_GLOBAL_CONFIG}(enum))
	{
		if err := w.WriteEnum(uint16(o.ConfigID)); err != nil {
			return err
		}
	}
	// dwFlags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	// pBuffer {in, out} (1:{pointer=unique}*(1))(2:{alias=BYTE}[dim:0,size_is=cbData,length_is=pcbTransmittedLen](uchar))
	{
		if o.Buffer != nil || o.DataLength > 0 {
			_ptr_pBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.DataLength)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				dimLength1 := uint64(o.TransmittedLength)
				if dimLength1 > sizeInfo[0] {
					dimLength1 = sizeInfo[0]
				} else {
					sizeInfo[0] = dimLength1
				}
				if err := w.WriteSize(0); err != nil {
					return err
				}
				if err := w.WriteSize(dimLength1); err != nil {
					return err
				}
				for i1 := range o.Buffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Buffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Buffer, _ptr_pBuffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// cbData {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DataLength); err != nil {
			return err
		}
	}
	// pcbTransmittedLen {in, out} (1:{alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.TransmittedLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetGlobalConfig210Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// BinaryVersion {in} (1:{alias=WORD}(uint16))
	{
		if err := w.ReadData(&o.BinaryVersion); err != nil {
			return err
		}
	}
	// StoreType {in} (1:{alias=FW_STORE_TYPE}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.StoreType)); err != nil {
			return err
		}
	}
	// configID {in} (1:{range=(1,17), alias=FW_GLOBAL_CONFIG}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.ConfigID)); err != nil {
			return err
		}
	}
	// dwFlags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	// pBuffer {in, out} (1:{pointer=unique}*(1))(2:{alias=BYTE}[dim:0,size_is=cbData,length_is=pcbTransmittedLen](uchar))
	{
		_ptr_pBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
			}
			o.Buffer = make([]byte, sizeInfo[0])
			for i1 := range o.Buffer {
				i1 := i1
				if err := w.ReadData(&o.Buffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_pBuffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Buffer, _s_pBuffer, _ptr_pBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// cbData {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DataLength); err != nil {
			return err
		}
	}
	// pcbTransmittedLen {in, out} (1:{alias=LPDWORD,pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.TransmittedLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetGlobalConfig210Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Buffer != nil && o.TransmittedLength == 0 {
		o.TransmittedLength = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetGlobalConfig210Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pBuffer {in, out} (1:{pointer=unique}*(1))(2:{alias=BYTE}[dim:0,size_is=cbData,length_is=pcbTransmittedLen](uchar))
	{
		if o.Buffer != nil || o.DataLength > 0 {
			_ptr_pBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.DataLength)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				dimLength1 := uint64(o.TransmittedLength)
				if dimLength1 > sizeInfo[0] {
					dimLength1 = sizeInfo[0]
				} else {
					sizeInfo[0] = dimLength1
				}
				if err := w.WriteSize(0); err != nil {
					return err
				}
				if err := w.WriteSize(dimLength1); err != nil {
					return err
				}
				for i1 := range o.Buffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Buffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Buffer, _ptr_pBuffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// pcbTransmittedLen {in, out} (1:{alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.TransmittedLength); err != nil {
			return err
		}
	}
	// pcbRequired {out} (1:{alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RequiredLength); err != nil {
			return err
		}
	}
	// pOrigin {out} (1:{pointer=ref}*(1))(2:{alias=FW_RULE_ORIGIN_TYPE}(enum))
	{
		if err := w.WriteEnum(uint16(o.Origin)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetGlobalConfig210Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pBuffer {in, out} (1:{pointer=unique}*(1))(2:{alias=BYTE}[dim:0,size_is=cbData,length_is=pcbTransmittedLen](uchar))
	{
		_ptr_pBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
			}
			o.Buffer = make([]byte, sizeInfo[0])
			for i1 := range o.Buffer {
				i1 := i1
				if err := w.ReadData(&o.Buffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_pBuffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Buffer, _s_pBuffer, _ptr_pBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// pcbTransmittedLen {in, out} (1:{alias=LPDWORD,pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.TransmittedLength); err != nil {
			return err
		}
	}
	// pcbRequired {out} (1:{alias=LPDWORD,pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RequiredLength); err != nil {
			return err
		}
	}
	// pOrigin {out} (1:{pointer=ref}*(1))(2:{alias=FW_RULE_ORIGIN_TYPE}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.Origin)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetGlobalConfig210Request structure represents the RRPC_FWGetGlobalConfig2_10 operation request
type GetGlobalConfig210Request struct {
	// BinaryVersion: This parameter specifies the RPC interface binary version. This implies
	// versions of the methods and versions of the structures.
	BinaryVersion uint16 `idl:"name:BinaryVersion" json:"binary_version"`
	// StoreType: This parameter specifies the policy store from which the client retrieves
	// the configuration option value.
	StoreType fasp.StoreType `idl:"name:StoreType" json:"store_type"`
	// configID: This parameter specifies the specific global policy configuration option
	// that the client is interested in retrieving.
	ConfigID fasp.GlobalConfig `idl:"name:configID" json:"config_id"`
	// dwFlags: This parameter is a combination of flags from the FW_CONFIG_FLAGS enumeration,
	// which modifies the behavior of this method, as specified in the definition of the
	// enumeration.
	Flags uint32 `idl:"name:dwFlags" json:"flags"`
	// pBuffer: This is an input/output parameter. This parameter is a pointer to the buffer
	// that the client provides to contain the value of the profile configuration option
	// that is being requested.
	Buffer []byte `idl:"name:pBuffer;size_is:(cbData);length_is:(pcbTransmittedLen);pointer:unique" json:"buffer"`
	// cbData: This parameter is the size of the buffer to which the pBuffer parameter points.
	DataLength uint32 `idl:"name:cbData" json:"data_length"`
	// pcbTransmittedLen: This is a pointer to an input and output parameter that specifies
	// the length of the transmitted data within the buffer.
	TransmittedLength uint32 `idl:"name:pcbTransmittedLen" json:"transmitted_length"`
}

func (o *GetGlobalConfig210Request) xxx_ToOp(ctx context.Context, op *xxx_GetGlobalConfig210Operation) *xxx_GetGlobalConfig210Operation {
	if op == nil {
		op = &xxx_GetGlobalConfig210Operation{}
	}
	if o == nil {
		return op
	}
	op.BinaryVersion = o.BinaryVersion
	op.StoreType = o.StoreType
	op.ConfigID = o.ConfigID
	op.Flags = o.Flags
	op.Buffer = o.Buffer
	op.DataLength = o.DataLength
	op.TransmittedLength = o.TransmittedLength
	return op
}

func (o *GetGlobalConfig210Request) xxx_FromOp(ctx context.Context, op *xxx_GetGlobalConfig210Operation) {
	if o == nil {
		return
	}
	o.BinaryVersion = op.BinaryVersion
	o.StoreType = op.StoreType
	o.ConfigID = op.ConfigID
	o.Flags = op.Flags
	o.Buffer = op.Buffer
	o.DataLength = op.DataLength
	o.TransmittedLength = op.TransmittedLength
}
func (o *GetGlobalConfig210Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetGlobalConfig210Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetGlobalConfig210Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetGlobalConfig210Response structure represents the RRPC_FWGetGlobalConfig2_10 operation response
type GetGlobalConfig210Response struct {
	// XXX: cbData is an implicit input depedency for output parameters
	DataLength uint32 `idl:"name:cbData" json:"data_length"`

	// pBuffer: This is an input/output parameter. This parameter is a pointer to the buffer
	// that the client provides to contain the value of the profile configuration option
	// that is being requested.
	Buffer []byte `idl:"name:pBuffer;size_is:(cbData);length_is:(pcbTransmittedLen);pointer:unique" json:"buffer"`
	// pcbTransmittedLen: This is a pointer to an input and output parameter that specifies
	// the length of the transmitted data within the buffer.
	TransmittedLength uint32 `idl:"name:pcbTransmittedLen" json:"transmitted_length"`
	// pcbRequired: This is a pointer to an output parameter that specifies the required
	// minimum buffer size, in octets, for the method to be able to return the configuration
	// value. This output parameter is nonzero only if the buffer (pointed to by pBuffer
	// and whose size is cbData) was not big enough to contain the value.
	RequiredLength uint32 `idl:"name:pcbRequired" json:"required_length"`
	// pOrigin: This field is the origin of the configuration option, as specified in the
	// FW_RULE_ORIGIN_TYPE enumeration. On success, it MUST be filled.
	Origin fasp.RuleOriginType `idl:"name:pOrigin" json:"origin"`
	// Return: The RRPC_FWGetGlobalConfig2_10 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetGlobalConfig210Response) xxx_ToOp(ctx context.Context, op *xxx_GetGlobalConfig210Operation) *xxx_GetGlobalConfig210Operation {
	if op == nil {
		op = &xxx_GetGlobalConfig210Operation{}
	}
	if o == nil {
		return op
	}
	// XXX: implicit input dependencies for output parameters
	if op.DataLength == uint32(0) {
		op.DataLength = o.DataLength
	}

	op.Buffer = o.Buffer
	op.TransmittedLength = o.TransmittedLength
	op.RequiredLength = o.RequiredLength
	op.Origin = o.Origin
	op.Return = o.Return
	return op
}

func (o *GetGlobalConfig210Response) xxx_FromOp(ctx context.Context, op *xxx_GetGlobalConfig210Operation) {
	if o == nil {
		return
	}
	// XXX: implicit input dependencies for output parameters
	o.DataLength = op.DataLength

	o.Buffer = op.Buffer
	o.TransmittedLength = op.TransmittedLength
	o.RequiredLength = op.RequiredLength
	o.Origin = op.Origin
	o.Return = op.Return
}
func (o *GetGlobalConfig210Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetGlobalConfig210Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetGlobalConfig210Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetConfig210Operation structure represents the RRPC_FWGetConfig2_10 operation
type xxx_GetConfig210Operation struct {
	PolicyStore       *PolicyStore        `idl:"name:hPolicyStore" json:"policy_store"`
	ConfigID          fasp.ProfileConfig  `idl:"name:configID" json:"config_id"`
	Profile           fasp.ProfileType    `idl:"name:Profile" json:"profile"`
	Flags             uint32              `idl:"name:dwFlags" json:"flags"`
	Buffer            []byte              `idl:"name:pBuffer;size_is:(cbData);length_is:(pcbTransmittedLen);pointer:unique" json:"buffer"`
	DataLength        uint32              `idl:"name:cbData" json:"data_length"`
	TransmittedLength uint32              `idl:"name:pcbTransmittedLen" json:"transmitted_length"`
	RequiredLength    uint32              `idl:"name:pcbRequired" json:"required_length"`
	Origin            fasp.RuleOriginType `idl:"name:pOrigin" json:"origin"`
	Return            uint32              `idl:"name:Return" json:"return"`
}

func (o *xxx_GetConfig210Operation) OpNum() int { return 45 }

func (o *xxx_GetConfig210Operation) OpName() string { return "/RemoteFW/v1/RRPC_FWGetConfig2_10" }

func (o *xxx_GetConfig210Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.Buffer != nil && o.DataLength == 0 {
		o.DataLength = uint32(len(o.Buffer))
	}
	if o.Buffer != nil && o.TransmittedLength == 0 {
		o.TransmittedLength = uint32(len(o.Buffer))
	}
	if o.ConfigID < fasp.ProfileConfig(1) || o.ConfigID > fasp.ProfileConfig(18) {
		return fmt.Errorf("ConfigID is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetConfig210Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// configID {in} (1:{range=(1,18), alias=FW_PROFILE_CONFIG}(enum))
	{
		if err := w.WriteEnum(uint16(o.ConfigID)); err != nil {
			return err
		}
	}
	// Profile {in} (1:{v1_enum, alias=FW_PROFILE_TYPE}(enum))
	{
		if err := w.WriteEnum(uint32(o.Profile)); err != nil {
			return err
		}
	}
	// dwFlags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	// pBuffer {in, out} (1:{pointer=unique}*(1))(2:{alias=BYTE}[dim:0,size_is=cbData,length_is=pcbTransmittedLen](uchar))
	{
		if o.Buffer != nil || o.DataLength > 0 {
			_ptr_pBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.DataLength)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				dimLength1 := uint64(o.TransmittedLength)
				if dimLength1 > sizeInfo[0] {
					dimLength1 = sizeInfo[0]
				} else {
					sizeInfo[0] = dimLength1
				}
				if err := w.WriteSize(0); err != nil {
					return err
				}
				if err := w.WriteSize(dimLength1); err != nil {
					return err
				}
				for i1 := range o.Buffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Buffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Buffer, _ptr_pBuffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// cbData {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DataLength); err != nil {
			return err
		}
	}
	// pcbTransmittedLen {in, out} (1:{alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.TransmittedLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetConfig210Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// configID {in} (1:{range=(1,18), alias=FW_PROFILE_CONFIG}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.ConfigID)); err != nil {
			return err
		}
	}
	// Profile {in} (1:{v1_enum, alias=FW_PROFILE_TYPE}(enum))
	{
		if err := w.ReadEnum((*uint32)(&o.Profile)); err != nil {
			return err
		}
	}
	// dwFlags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	// pBuffer {in, out} (1:{pointer=unique}*(1))(2:{alias=BYTE}[dim:0,size_is=cbData,length_is=pcbTransmittedLen](uchar))
	{
		_ptr_pBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
			}
			o.Buffer = make([]byte, sizeInfo[0])
			for i1 := range o.Buffer {
				i1 := i1
				if err := w.ReadData(&o.Buffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_pBuffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Buffer, _s_pBuffer, _ptr_pBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// cbData {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DataLength); err != nil {
			return err
		}
	}
	// pcbTransmittedLen {in, out} (1:{alias=LPDWORD,pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.TransmittedLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetConfig210Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if o.Buffer != nil && o.TransmittedLength == 0 {
		o.TransmittedLength = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetConfig210Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pBuffer {in, out} (1:{pointer=unique}*(1))(2:{alias=BYTE}[dim:0,size_is=cbData,length_is=pcbTransmittedLen](uchar))
	{
		if o.Buffer != nil || o.DataLength > 0 {
			_ptr_pBuffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.DataLength)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				dimLength1 := uint64(o.TransmittedLength)
				if dimLength1 > sizeInfo[0] {
					dimLength1 = sizeInfo[0]
				} else {
					sizeInfo[0] = dimLength1
				}
				if err := w.WriteSize(0); err != nil {
					return err
				}
				if err := w.WriteSize(dimLength1); err != nil {
					return err
				}
				for i1 := range o.Buffer {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.Buffer[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Buffer, _ptr_pBuffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// pcbTransmittedLen {in, out} (1:{alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.TransmittedLength); err != nil {
			return err
		}
	}
	// pcbRequired {out} (1:{alias=LPDWORD}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RequiredLength); err != nil {
			return err
		}
	}
	// pOrigin {out} (1:{pointer=ref}*(1))(2:{alias=FW_RULE_ORIGIN_TYPE}(enum))
	{
		if err := w.WriteEnum(uint16(o.Origin)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetConfig210Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pBuffer {in, out} (1:{pointer=unique}*(1))(2:{alias=BYTE}[dim:0,size_is=cbData,length_is=pcbTransmittedLen](uchar))
	{
		_ptr_pBuffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
			}
			o.Buffer = make([]byte, sizeInfo[0])
			for i1 := range o.Buffer {
				i1 := i1
				if err := w.ReadData(&o.Buffer[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_pBuffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.Buffer, _s_pBuffer, _ptr_pBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// pcbTransmittedLen {in, out} (1:{alias=LPDWORD,pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.TransmittedLength); err != nil {
			return err
		}
	}
	// pcbRequired {out} (1:{alias=LPDWORD,pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RequiredLength); err != nil {
			return err
		}
	}
	// pOrigin {out} (1:{pointer=ref}*(1))(2:{alias=FW_RULE_ORIGIN_TYPE}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.Origin)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetConfig210Request structure represents the RRPC_FWGetConfig2_10 operation request
type GetConfig210Request struct {
	// hPolicyStore: This input parameter is an FW_POLICY_STORE_HANDLE data type. The data
	// type MUST contain an opened policy store handle, successfully opened with the RRPC_FWOpenPolicyStore
	// (Opnum 0) method. The handle MUST have read/write access rights.
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// configID: This parameter specifies the specific global policy configuration option
	// that the client is interested in retrieving.
	ConfigID fasp.ProfileConfig `idl:"name:configID" json:"config_id"`
	// Profile: This parameter specifies from which specific profile this value MUST be
	// retrieved.
	Profile fasp.ProfileType `idl:"name:Profile" json:"profile"`
	// dwFlags: This parameter is a combination of flags from the FW_CONFIG_FLAGS enumeration,
	// which modifies the behavior of this method, as specified in the definition of the
	// enumeration.
	Flags uint32 `idl:"name:dwFlags" json:"flags"`
	// pBuffer: This is an input/output parameter. This parameter is a pointer to the buffer
	// that the client provides to contain the value of the profile configuration option
	// being requested.
	Buffer []byte `idl:"name:pBuffer;size_is:(cbData);length_is:(pcbTransmittedLen);pointer:unique" json:"buffer"`
	// cbData: This parameter is the size of the buffer to which the pBuffer parameter points.
	DataLength uint32 `idl:"name:cbData" json:"data_length"`
	// pcbTransmittedLen: This is a pointer to an input and output parameter that specifies
	// the length of the transmitted data within the buffer.
	TransmittedLength uint32 `idl:"name:pcbTransmittedLen" json:"transmitted_length"`
}

func (o *GetConfig210Request) xxx_ToOp(ctx context.Context, op *xxx_GetConfig210Operation) *xxx_GetConfig210Operation {
	if op == nil {
		op = &xxx_GetConfig210Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.ConfigID = o.ConfigID
	op.Profile = o.Profile
	op.Flags = o.Flags
	op.Buffer = o.Buffer
	op.DataLength = o.DataLength
	op.TransmittedLength = o.TransmittedLength
	return op
}

func (o *GetConfig210Request) xxx_FromOp(ctx context.Context, op *xxx_GetConfig210Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.ConfigID = op.ConfigID
	o.Profile = op.Profile
	o.Flags = op.Flags
	o.Buffer = op.Buffer
	o.DataLength = op.DataLength
	o.TransmittedLength = op.TransmittedLength
}
func (o *GetConfig210Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetConfig210Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetConfig210Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetConfig210Response structure represents the RRPC_FWGetConfig2_10 operation response
type GetConfig210Response struct {
	// XXX: cbData is an implicit input depedency for output parameters
	DataLength uint32 `idl:"name:cbData" json:"data_length"`

	// pBuffer: This is an input/output parameter. This parameter is a pointer to the buffer
	// that the client provides to contain the value of the profile configuration option
	// being requested.
	Buffer []byte `idl:"name:pBuffer;size_is:(cbData);length_is:(pcbTransmittedLen);pointer:unique" json:"buffer"`
	// pcbTransmittedLen: This is a pointer to an input and output parameter that specifies
	// the length of the transmitted data within the buffer.
	TransmittedLength uint32 `idl:"name:pcbTransmittedLen" json:"transmitted_length"`
	// pcbRequired: This is a pointer to an output parameter that specifies the required
	// minimum buffer size, in octets, for the method to be able to return the configuration
	// value. This output parameter is nonzero only if the buffer (pointed to by pBuffer
	// and whose size is cbData) was not big enough to contain the value.
	RequiredLength uint32 `idl:"name:pcbRequired" json:"required_length"`
	// pOrigin: This field is the origin of the configuration option, as specified in the
	// FW_RULE_ORIGIN_TYPE enumeration. On success, it MUST be filled.
	Origin fasp.RuleOriginType `idl:"name:pOrigin" json:"origin"`
	// Return: The RRPC_FWGetConfig2_10 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetConfig210Response) xxx_ToOp(ctx context.Context, op *xxx_GetConfig210Operation) *xxx_GetConfig210Operation {
	if op == nil {
		op = &xxx_GetConfig210Operation{}
	}
	if o == nil {
		return op
	}
	// XXX: implicit input dependencies for output parameters
	if op.DataLength == uint32(0) {
		op.DataLength = o.DataLength
	}

	op.Buffer = o.Buffer
	op.TransmittedLength = o.TransmittedLength
	op.RequiredLength = o.RequiredLength
	op.Origin = o.Origin
	op.Return = o.Return
	return op
}

func (o *GetConfig210Response) xxx_FromOp(ctx context.Context, op *xxx_GetConfig210Operation) {
	if o == nil {
		return
	}
	// XXX: implicit input dependencies for output parameters
	o.DataLength = op.DataLength

	o.Buffer = op.Buffer
	o.TransmittedLength = op.TransmittedLength
	o.RequiredLength = op.RequiredLength
	o.Origin = op.Origin
	o.Return = op.Return
}
func (o *GetConfig210Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetConfig210Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetConfig210Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddFirewallRule210Operation structure represents the RRPC_FWAddFirewallRule2_10 operation
type xxx_AddFirewallRule210Operation struct {
	PolicyStore *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	Rule        *fasp.Rule210   `idl:"name:pRule" json:"rule"`
	Status      fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	Return      uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_AddFirewallRule210Operation) OpNum() int { return 46 }

func (o *xxx_AddFirewallRule210Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWAddFirewallRule2_10"
}

func (o *xxx_AddFirewallRule210Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFirewallRule210Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pRule {in} (1:{alias=PFW_RULE2_10}*(1))(2:{alias=FW_RULE2_10}(struct))
	{
		if o.Rule != nil {
			if err := o.Rule.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.Rule210{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFirewallRule210Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pRule {in} (1:{alias=PFW_RULE2_10,pointer=ref}*(1))(2:{alias=FW_RULE2_10}(struct))
	{
		if o.Rule == nil {
			o.Rule = &fasp.Rule210{}
		}
		if err := o.Rule.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFirewallRule210Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFirewallRule210Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.WriteEnum(uint32(o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFirewallRule210Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.ReadEnum((*uint32)(&o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddFirewallRule210Request structure represents the RRPC_FWAddFirewallRule2_10 operation request
type AddFirewallRule210Request struct {
	// hPolicyStore: This input parameter is an FW_POLICY_STORE_HANDLE data type. The data
	// type MUST contain an opened policy store handle, successfully opened with the RRPC_FWOpenPolicyStore
	// (Opnum 0) method. The handle MUST have read/write access rights.
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pRule: This parameter represents the firewall rule that the client wants to add to
	// the store. The rule MUST be a valid rule, as specified in the definition of the FW_RULE2_10
	// data type.
	Rule *fasp.Rule210 `idl:"name:pRule" json:"rule"`
}

func (o *AddFirewallRule210Request) xxx_ToOp(ctx context.Context, op *xxx_AddFirewallRule210Operation) *xxx_AddFirewallRule210Operation {
	if op == nil {
		op = &xxx_AddFirewallRule210Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Rule = o.Rule
	return op
}

func (o *AddFirewallRule210Request) xxx_FromOp(ctx context.Context, op *xxx_AddFirewallRule210Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Rule = op.Rule
}
func (o *AddFirewallRule210Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *AddFirewallRule210Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddFirewallRule210Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddFirewallRule210Response structure represents the RRPC_FWAddFirewallRule2_10 operation response
type AddFirewallRule210Response struct {
	// pStatus: This output parameter is the status code of the rule as specified by the
	// FW_RULE_STATUS enumeration. This field is filled out on return.
	Status fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	// Return: The RRPC_FWAddFirewallRule2_10 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddFirewallRule210Response) xxx_ToOp(ctx context.Context, op *xxx_AddFirewallRule210Operation) *xxx_AddFirewallRule210Operation {
	if op == nil {
		op = &xxx_AddFirewallRule210Operation{}
	}
	if o == nil {
		return op
	}
	op.Status = o.Status
	op.Return = o.Return
	return op
}

func (o *AddFirewallRule210Response) xxx_FromOp(ctx context.Context, op *xxx_AddFirewallRule210Operation) {
	if o == nil {
		return
	}
	o.Status = op.Status
	o.Return = op.Return
}
func (o *AddFirewallRule210Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *AddFirewallRule210Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddFirewallRule210Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetFirewallRule210Operation structure represents the RRPC_FWSetFirewallRule2_10 operation
type xxx_SetFirewallRule210Operation struct {
	PolicyStore *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	Rule        *fasp.Rule210   `idl:"name:pRule" json:"rule"`
	Status      fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	Return      uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_SetFirewallRule210Operation) OpNum() int { return 47 }

func (o *xxx_SetFirewallRule210Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWSetFirewallRule2_10"
}

func (o *xxx_SetFirewallRule210Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFirewallRule210Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pRule {in} (1:{alias=PFW_RULE2_10}*(1))(2:{alias=FW_RULE2_10}(struct))
	{
		if o.Rule != nil {
			if err := o.Rule.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.Rule210{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFirewallRule210Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pRule {in} (1:{alias=PFW_RULE2_10,pointer=ref}*(1))(2:{alias=FW_RULE2_10}(struct))
	{
		if o.Rule == nil {
			o.Rule = &fasp.Rule210{}
		}
		if err := o.Rule.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFirewallRule210Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFirewallRule210Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.WriteEnum(uint32(o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFirewallRule210Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.ReadEnum((*uint32)(&o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetFirewallRule210Request structure represents the RRPC_FWSetFirewallRule2_10 operation request
type SetFirewallRule210Request struct {
	// hPolicyStore: This input parameter is an FW_POLICY_STORE_HANDLE data type. The data
	// type MUST contain an opened policy store handle, successfully opened with the RRPC_FWOpenPolicyStore
	// (Opnum 0) method. The handle MUST have read/write access rights.
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pRule: This parameter represents the firewall rule that the client wants to add to
	// the store. The rule MUST be a valid rule, as specified in the definition of the FW_RULE2_10
	// data type.
	Rule *fasp.Rule210 `idl:"name:pRule" json:"rule"`
}

func (o *SetFirewallRule210Request) xxx_ToOp(ctx context.Context, op *xxx_SetFirewallRule210Operation) *xxx_SetFirewallRule210Operation {
	if op == nil {
		op = &xxx_SetFirewallRule210Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Rule = o.Rule
	return op
}

func (o *SetFirewallRule210Request) xxx_FromOp(ctx context.Context, op *xxx_SetFirewallRule210Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Rule = op.Rule
}
func (o *SetFirewallRule210Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetFirewallRule210Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetFirewallRule210Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetFirewallRule210Response structure represents the RRPC_FWSetFirewallRule2_10 operation response
type SetFirewallRule210Response struct {
	// pStatus: This output parameter is the status code of the rule as specified by the
	// FW_RULE_STATUS enumeration. This field is filled out on return.
	Status fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	// Return: The RRPC_FWSetFirewallRule2_10 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetFirewallRule210Response) xxx_ToOp(ctx context.Context, op *xxx_SetFirewallRule210Operation) *xxx_SetFirewallRule210Operation {
	if op == nil {
		op = &xxx_SetFirewallRule210Operation{}
	}
	if o == nil {
		return op
	}
	op.Status = o.Status
	op.Return = o.Return
	return op
}

func (o *SetFirewallRule210Response) xxx_FromOp(ctx context.Context, op *xxx_SetFirewallRule210Operation) {
	if o == nil {
		return
	}
	o.Status = op.Status
	o.Return = op.Return
}
func (o *SetFirewallRule210Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetFirewallRule210Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetFirewallRule210Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumFirewallRules210Operation structure represents the RRPC_FWEnumFirewallRules2_10 operation
type xxx_EnumFirewallRules210Operation struct {
	PolicyStore      *PolicyStore  `idl:"name:hPolicyStore" json:"policy_store"`
	FilteredByStatus uint32        `idl:"name:dwFilteredByStatus" json:"filtered_by_status"`
	ProfileFilter    uint32        `idl:"name:dwProfileFilter" json:"profile_filter"`
	Flags            uint16        `idl:"name:wFlags" json:"flags"`
	RulesLength      uint32        `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	Rules            *fasp.Rule210 `idl:"name:ppRules" json:"rules"`
	Return           uint32        `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumFirewallRules210Operation) OpNum() int { return 48 }

func (o *xxx_EnumFirewallRules210Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWEnumFirewallRules2_10"
}

func (o *xxx_EnumFirewallRules210Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFirewallRules210Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwFilteredByStatus {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.FilteredByStatus); err != nil {
			return err
		}
	}
	// dwProfileFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ProfileFilter); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFirewallRules210Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwFilteredByStatus {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.FilteredByStatus); err != nil {
			return err
		}
	}
	// dwProfileFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ProfileFilter); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFirewallRules210Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFirewallRules210Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RulesLength); err != nil {
			return err
		}
	}
	// ppRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_RULE2_10}*(1))(3:{alias=FW_RULE2_10}(struct))
	{
		if o.Rules != nil {
			_ptr_ppRules := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Rules != nil {
					if err := o.Rules.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&fasp.Rule210{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Rules, _ptr_ppRules); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFirewallRules210Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RulesLength); err != nil {
			return err
		}
	}
	// ppRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_RULE2_10,pointer=ref}*(1))(3:{alias=FW_RULE2_10}(struct))
	{
		_ptr_ppRules := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Rules == nil {
				o.Rules = &fasp.Rule210{}
			}
			if err := o.Rules.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ppRules := func(ptr interface{}) { o.Rules = *ptr.(**fasp.Rule210) }
		if err := w.ReadPointer(&o.Rules, _s_ppRules, _ptr_ppRules); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumFirewallRules210Request structure represents the RRPC_FWEnumFirewallRules2_10 operation request
type EnumFirewallRules210Request struct {
	// hPolicyStore: This input parameter is an FW_POLICY_STORE_HANDLE data type. The data
	// type MUST contain an opened policy store handle, successfully opened with the RRPC_FWOpenPolicyStore
	// (Opnum 0) method. The handle MUST have read/write access rights.
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// dwFilteredByStatus: This parameter is a combination of flags from the FW_RULE_STATUS_CLASS
	// enumeration. This method uses this bitmask to determine which rules will be returned.
	// Rules that contain a status code of the specified class that match this parameter
	// will be returned in the linked list.
	FilteredByStatus uint32 `idl:"name:dwFilteredByStatus" json:"filtered_by_status"`
	// dwProfileFilter: This parameter is a combination of flags from the FW_PROFILE_TYPE
	// enumeration. This method also uses this parameter to determine which rules will be
	// returned. Rules that contain a profile specified by this parameter will be returned
	// in the linked list.
	ProfileFilter uint32 `idl:"name:dwProfileFilter" json:"profile_filter"`
	// wFlags: This parameter is a combination of flags from the FW_ENUM_RULES_FLAGS enumeration,
	// which modifies the behavior of the method and performs operations on the rules before
	// returning them in the linked list.
	Flags uint16 `idl:"name:wFlags" json:"flags"`
}

func (o *EnumFirewallRules210Request) xxx_ToOp(ctx context.Context, op *xxx_EnumFirewallRules210Operation) *xxx_EnumFirewallRules210Operation {
	if op == nil {
		op = &xxx_EnumFirewallRules210Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.FilteredByStatus = o.FilteredByStatus
	op.ProfileFilter = o.ProfileFilter
	op.Flags = o.Flags
	return op
}

func (o *EnumFirewallRules210Request) xxx_FromOp(ctx context.Context, op *xxx_EnumFirewallRules210Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.FilteredByStatus = op.FilteredByStatus
	o.ProfileFilter = op.ProfileFilter
	o.Flags = op.Flags
}
func (o *EnumFirewallRules210Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumFirewallRules210Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumFirewallRules210Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumFirewallRules210Response structure represents the RRPC_FWEnumFirewallRules2_10 operation response
type EnumFirewallRules210Response struct {
	// pdwNumRules: This is an output parameter that, on success, MUST be equal to the number
	// of rules returned.
	RulesLength uint32 `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	// ppRules: This is an output parameter that, on success, contains a linked list of
	// FW_RULE2_10 data types.
	Rules *fasp.Rule210 `idl:"name:ppRules" json:"rules"`
	// Return: The RRPC_FWEnumFirewallRules2_10 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumFirewallRules210Response) xxx_ToOp(ctx context.Context, op *xxx_EnumFirewallRules210Operation) *xxx_EnumFirewallRules210Operation {
	if op == nil {
		op = &xxx_EnumFirewallRules210Operation{}
	}
	if o == nil {
		return op
	}
	op.RulesLength = o.RulesLength
	op.Rules = o.Rules
	op.Return = o.Return
	return op
}

func (o *EnumFirewallRules210Response) xxx_FromOp(ctx context.Context, op *xxx_EnumFirewallRules210Operation) {
	if o == nil {
		return
	}
	o.RulesLength = op.RulesLength
	o.Rules = op.Rules
	o.Return = op.Return
}
func (o *EnumFirewallRules210Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumFirewallRules210Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumFirewallRules210Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddConnectionSecurityRule210Operation structure represents the RRPC_FWAddConnectionSecurityRule2_10 operation
type xxx_AddConnectionSecurityRule210Operation struct {
	PolicyStore *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	Rule        *fasp.CSRule210 `idl:"name:pRule" json:"rule"`
	Status      fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	Return      uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_AddConnectionSecurityRule210Operation) OpNum() int { return 49 }

func (o *xxx_AddConnectionSecurityRule210Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWAddConnectionSecurityRule2_10"
}

func (o *xxx_AddConnectionSecurityRule210Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddConnectionSecurityRule210Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pRule {in} (1:{alias=PFW_CS_RULE2_10}*(1))(2:{alias=FW_CS_RULE2_10}(struct))
	{
		if o.Rule != nil {
			if err := o.Rule.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.CSRule210{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddConnectionSecurityRule210Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pRule {in} (1:{alias=PFW_CS_RULE2_10,pointer=ref}*(1))(2:{alias=FW_CS_RULE2_10}(struct))
	{
		if o.Rule == nil {
			o.Rule = &fasp.CSRule210{}
		}
		if err := o.Rule.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddConnectionSecurityRule210Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddConnectionSecurityRule210Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.WriteEnum(uint32(o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddConnectionSecurityRule210Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.ReadEnum((*uint32)(&o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddConnectionSecurityRule210Request structure represents the RRPC_FWAddConnectionSecurityRule2_10 operation request
type AddConnectionSecurityRule210Request struct {
	// hPolicyStore: This input parameter is an FW_POLICY_STORE_HANDLE data type. The data
	// type MUST contain an opened policy store handle, successfully opened with the RRPC_FWOpenPolicyStore
	// (Opnum 0) method. The handle MUST have read/write access rights.
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pRule: This parameter represents the firewall rule that the client adds to the store.
	// The rule MUST be a valid rule, as specified in the definition of the FW_CS_RULE2_10
	// data type.
	Rule *fasp.CSRule210 `idl:"name:pRule" json:"rule"`
}

func (o *AddConnectionSecurityRule210Request) xxx_ToOp(ctx context.Context, op *xxx_AddConnectionSecurityRule210Operation) *xxx_AddConnectionSecurityRule210Operation {
	if op == nil {
		op = &xxx_AddConnectionSecurityRule210Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Rule = o.Rule
	return op
}

func (o *AddConnectionSecurityRule210Request) xxx_FromOp(ctx context.Context, op *xxx_AddConnectionSecurityRule210Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Rule = op.Rule
}
func (o *AddConnectionSecurityRule210Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *AddConnectionSecurityRule210Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddConnectionSecurityRule210Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddConnectionSecurityRule210Response structure represents the RRPC_FWAddConnectionSecurityRule2_10 operation response
type AddConnectionSecurityRule210Response struct {
	// pStatus: This output parameter is the status code of the rule as specified by the
	// FW_RULE_STATUS enumeration. This field is filled out on return.
	Status fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	// Return: The RRPC_FWAddConnectionSecurityRule2_10 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddConnectionSecurityRule210Response) xxx_ToOp(ctx context.Context, op *xxx_AddConnectionSecurityRule210Operation) *xxx_AddConnectionSecurityRule210Operation {
	if op == nil {
		op = &xxx_AddConnectionSecurityRule210Operation{}
	}
	if o == nil {
		return op
	}
	op.Status = o.Status
	op.Return = o.Return
	return op
}

func (o *AddConnectionSecurityRule210Response) xxx_FromOp(ctx context.Context, op *xxx_AddConnectionSecurityRule210Operation) {
	if o == nil {
		return
	}
	o.Status = op.Status
	o.Return = op.Return
}
func (o *AddConnectionSecurityRule210Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *AddConnectionSecurityRule210Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddConnectionSecurityRule210Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetConnectionSecurityRule210Operation structure represents the RRPC_FWSetConnectionSecurityRule2_10 operation
type xxx_SetConnectionSecurityRule210Operation struct {
	PolicyStore *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	Rule        *fasp.CSRule210 `idl:"name:pRule" json:"rule"`
	Status      fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	Return      uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_SetConnectionSecurityRule210Operation) OpNum() int { return 50 }

func (o *xxx_SetConnectionSecurityRule210Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWSetConnectionSecurityRule2_10"
}

func (o *xxx_SetConnectionSecurityRule210Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetConnectionSecurityRule210Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pRule {in} (1:{alias=PFW_CS_RULE2_10}*(1))(2:{alias=FW_CS_RULE2_10}(struct))
	{
		if o.Rule != nil {
			if err := o.Rule.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.CSRule210{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetConnectionSecurityRule210Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pRule {in} (1:{alias=PFW_CS_RULE2_10,pointer=ref}*(1))(2:{alias=FW_CS_RULE2_10}(struct))
	{
		if o.Rule == nil {
			o.Rule = &fasp.CSRule210{}
		}
		if err := o.Rule.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetConnectionSecurityRule210Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetConnectionSecurityRule210Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.WriteEnum(uint32(o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetConnectionSecurityRule210Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.ReadEnum((*uint32)(&o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetConnectionSecurityRule210Request structure represents the RRPC_FWSetConnectionSecurityRule2_10 operation request
type SetConnectionSecurityRule210Request struct {
	// hPolicyStore: This input parameter is an FW_POLICY_STORE_HANDLE data type. The data
	// type MUST contain an opened policy store handle, successfully opened with the RRPC_FWOpenPolicyStore
	// (Opnum 0) method. The handle MUST have read/write access rights.
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pRule: This parameter represents the connection security rule that the client wants
	// to add to the store. The rule MUST be a valid rule, as specified in the definition
	// of the FW_CS_RULE2_10 data type.
	Rule *fasp.CSRule210 `idl:"name:pRule" json:"rule"`
}

func (o *SetConnectionSecurityRule210Request) xxx_ToOp(ctx context.Context, op *xxx_SetConnectionSecurityRule210Operation) *xxx_SetConnectionSecurityRule210Operation {
	if op == nil {
		op = &xxx_SetConnectionSecurityRule210Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Rule = o.Rule
	return op
}

func (o *SetConnectionSecurityRule210Request) xxx_FromOp(ctx context.Context, op *xxx_SetConnectionSecurityRule210Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Rule = op.Rule
}
func (o *SetConnectionSecurityRule210Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetConnectionSecurityRule210Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetConnectionSecurityRule210Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetConnectionSecurityRule210Response structure represents the RRPC_FWSetConnectionSecurityRule2_10 operation response
type SetConnectionSecurityRule210Response struct {
	// pStatus: This output parameter is the status code of the rule as specified by the
	// FW_RULE_STATUS enumeration. This field is filled out on return.
	Status fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	// Return: The RRPC_FWSetConnectionSecurityRule2_10 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetConnectionSecurityRule210Response) xxx_ToOp(ctx context.Context, op *xxx_SetConnectionSecurityRule210Operation) *xxx_SetConnectionSecurityRule210Operation {
	if op == nil {
		op = &xxx_SetConnectionSecurityRule210Operation{}
	}
	if o == nil {
		return op
	}
	op.Status = o.Status
	op.Return = o.Return
	return op
}

func (o *SetConnectionSecurityRule210Response) xxx_FromOp(ctx context.Context, op *xxx_SetConnectionSecurityRule210Operation) {
	if o == nil {
		return
	}
	o.Status = op.Status
	o.Return = op.Return
}
func (o *SetConnectionSecurityRule210Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetConnectionSecurityRule210Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetConnectionSecurityRule210Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumConnectionSecurityRules210Operation structure represents the RRPC_FWEnumConnectionSecurityRules2_10 operation
type xxx_EnumConnectionSecurityRules210Operation struct {
	PolicyStore      *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	FilteredByStatus uint32          `idl:"name:dwFilteredByStatus" json:"filtered_by_status"`
	ProfileFilter    uint32          `idl:"name:dwProfileFilter" json:"profile_filter"`
	Flags            uint16          `idl:"name:wFlags" json:"flags"`
	RulesLength      uint32          `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	Rules            *fasp.CSRule210 `idl:"name:ppRules" json:"rules"`
	Return           uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumConnectionSecurityRules210Operation) OpNum() int { return 51 }

func (o *xxx_EnumConnectionSecurityRules210Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWEnumConnectionSecurityRules2_10"
}

func (o *xxx_EnumConnectionSecurityRules210Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumConnectionSecurityRules210Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwFilteredByStatus {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.FilteredByStatus); err != nil {
			return err
		}
	}
	// dwProfileFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ProfileFilter); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumConnectionSecurityRules210Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwFilteredByStatus {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.FilteredByStatus); err != nil {
			return err
		}
	}
	// dwProfileFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ProfileFilter); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumConnectionSecurityRules210Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumConnectionSecurityRules210Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RulesLength); err != nil {
			return err
		}
	}
	// ppRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_CS_RULE2_10}*(1))(3:{alias=FW_CS_RULE2_10}(struct))
	{
		if o.Rules != nil {
			_ptr_ppRules := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Rules != nil {
					if err := o.Rules.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&fasp.CSRule210{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Rules, _ptr_ppRules); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumConnectionSecurityRules210Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RulesLength); err != nil {
			return err
		}
	}
	// ppRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_CS_RULE2_10,pointer=ref}*(1))(3:{alias=FW_CS_RULE2_10}(struct))
	{
		_ptr_ppRules := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Rules == nil {
				o.Rules = &fasp.CSRule210{}
			}
			if err := o.Rules.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ppRules := func(ptr interface{}) { o.Rules = *ptr.(**fasp.CSRule210) }
		if err := w.ReadPointer(&o.Rules, _s_ppRules, _ptr_ppRules); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumConnectionSecurityRules210Request structure represents the RRPC_FWEnumConnectionSecurityRules2_10 operation request
type EnumConnectionSecurityRules210Request struct {
	// hPolicyStore: This input parameter is an FW_POLICY_STORE_HANDLE data type. The data
	// type MUST contain an opened policy store handle, successfully opened with the RRPC_FWOpenPolicyStore
	// (Opnum 0) method. The handle MUST have read/write access rights.
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// dwFilteredByStatus: This parameter is a combination of flags from the FW_RULE_STATUS_CLASS
	// enumeration. This method uses this bitmask to determine which rules will be returned.
	// Rules that contain a status code of the specified class that match this parameter
	// will be returned in the linked list.
	FilteredByStatus uint32 `idl:"name:dwFilteredByStatus" json:"filtered_by_status"`
	// dwProfileFilter: This parameter is a combination of flags from the FW_PROFILE_TYPE
	// enumeration. This method also uses this parameter to determine which rules will be
	// returned. Rules that contain a profile specified by this parameter will be returned
	// in the linked list.
	ProfileFilter uint32 `idl:"name:dwProfileFilter" json:"profile_filter"`
	// wFlags: This parameter is a combination of flags from the FW_ENUM_RULES_FLAGS enumeration,
	// which modifies the behavior of the method and performs operations on the rules before
	// returning them in the linked list.
	Flags uint16 `idl:"name:wFlags" json:"flags"`
}

func (o *EnumConnectionSecurityRules210Request) xxx_ToOp(ctx context.Context, op *xxx_EnumConnectionSecurityRules210Operation) *xxx_EnumConnectionSecurityRules210Operation {
	if op == nil {
		op = &xxx_EnumConnectionSecurityRules210Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.FilteredByStatus = o.FilteredByStatus
	op.ProfileFilter = o.ProfileFilter
	op.Flags = o.Flags
	return op
}

func (o *EnumConnectionSecurityRules210Request) xxx_FromOp(ctx context.Context, op *xxx_EnumConnectionSecurityRules210Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.FilteredByStatus = op.FilteredByStatus
	o.ProfileFilter = op.ProfileFilter
	o.Flags = op.Flags
}
func (o *EnumConnectionSecurityRules210Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumConnectionSecurityRules210Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumConnectionSecurityRules210Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumConnectionSecurityRules210Response structure represents the RRPC_FWEnumConnectionSecurityRules2_10 operation response
type EnumConnectionSecurityRules210Response struct {
	// pdwNumRules: This is an output parameter that on success MUST be equal to the number
	// of rules returned.
	RulesLength uint32 `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	// ppRules: This is an output parameter that on success contains a linked list of FW_CS_RULE2_10
	// data types.
	Rules *fasp.CSRule210 `idl:"name:ppRules" json:"rules"`
	// Return: The RRPC_FWEnumConnectionSecurityRules2_10 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumConnectionSecurityRules210Response) xxx_ToOp(ctx context.Context, op *xxx_EnumConnectionSecurityRules210Operation) *xxx_EnumConnectionSecurityRules210Operation {
	if op == nil {
		op = &xxx_EnumConnectionSecurityRules210Operation{}
	}
	if o == nil {
		return op
	}
	op.RulesLength = o.RulesLength
	op.Rules = o.Rules
	op.Return = o.Return
	return op
}

func (o *EnumConnectionSecurityRules210Response) xxx_FromOp(ctx context.Context, op *xxx_EnumConnectionSecurityRules210Operation) {
	if o == nil {
		return
	}
	o.RulesLength = op.RulesLength
	o.Rules = op.Rules
	o.Return = op.Return
}
func (o *EnumConnectionSecurityRules210Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumConnectionSecurityRules210Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumConnectionSecurityRules210Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddAuthenticationSet210Operation structure represents the RRPC_FWAddAuthenticationSet2_10 operation
type xxx_AddAuthenticationSet210Operation struct {
	PolicyStore *PolicyStore     `idl:"name:hPolicyStore" json:"policy_store"`
	Auth        *fasp.AuthSet210 `idl:"name:pAuth" json:"auth"`
	Status      fasp.RuleStatus  `idl:"name:pStatus" json:"status"`
	Return      uint32           `idl:"name:Return" json:"return"`
}

func (o *xxx_AddAuthenticationSet210Operation) OpNum() int { return 52 }

func (o *xxx_AddAuthenticationSet210Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWAddAuthenticationSet2_10"
}

func (o *xxx_AddAuthenticationSet210Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddAuthenticationSet210Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pAuth {in} (1:{alias=PFW_AUTH_SET2_10}*(1))(2:{alias=FW_AUTH_SET2_10}(struct))
	{
		if o.Auth != nil {
			if err := o.Auth.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.AuthSet210{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddAuthenticationSet210Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pAuth {in} (1:{alias=PFW_AUTH_SET2_10,pointer=ref}*(1))(2:{alias=FW_AUTH_SET2_10}(struct))
	{
		if o.Auth == nil {
			o.Auth = &fasp.AuthSet210{}
		}
		if err := o.Auth.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddAuthenticationSet210Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddAuthenticationSet210Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.WriteEnum(uint32(o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddAuthenticationSet210Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.ReadEnum((*uint32)(&o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddAuthenticationSet210Request structure represents the RRPC_FWAddAuthenticationSet2_10 operation request
type AddAuthenticationSet210Request struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pAuth: This parameter represents the authentication set that the client wants to
	// add to the store. The set MUST be valid, as specified in the definition of the FW_AUTH_SET2_10
	// data type.
	Auth *fasp.AuthSet210 `idl:"name:pAuth" json:"auth"`
}

func (o *AddAuthenticationSet210Request) xxx_ToOp(ctx context.Context, op *xxx_AddAuthenticationSet210Operation) *xxx_AddAuthenticationSet210Operation {
	if op == nil {
		op = &xxx_AddAuthenticationSet210Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Auth = o.Auth
	return op
}

func (o *AddAuthenticationSet210Request) xxx_FromOp(ctx context.Context, op *xxx_AddAuthenticationSet210Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Auth = op.Auth
}
func (o *AddAuthenticationSet210Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *AddAuthenticationSet210Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddAuthenticationSet210Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddAuthenticationSet210Response structure represents the RRPC_FWAddAuthenticationSet2_10 operation response
type AddAuthenticationSet210Response struct {
	// pStatus: This output parameter is the status code of the rule as specified by the
	// FW_RULE_STATUS enumeration. This field is filled out on return.
	Status fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	// Return: The RRPC_FWAddAuthenticationSet2_10 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddAuthenticationSet210Response) xxx_ToOp(ctx context.Context, op *xxx_AddAuthenticationSet210Operation) *xxx_AddAuthenticationSet210Operation {
	if op == nil {
		op = &xxx_AddAuthenticationSet210Operation{}
	}
	if o == nil {
		return op
	}
	op.Status = o.Status
	op.Return = o.Return
	return op
}

func (o *AddAuthenticationSet210Response) xxx_FromOp(ctx context.Context, op *xxx_AddAuthenticationSet210Operation) {
	if o == nil {
		return
	}
	o.Status = op.Status
	o.Return = op.Return
}
func (o *AddAuthenticationSet210Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *AddAuthenticationSet210Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddAuthenticationSet210Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetAuthenticationSet210Operation structure represents the RRPC_FWSetAuthenticationSet2_10 operation
type xxx_SetAuthenticationSet210Operation struct {
	PolicyStore *PolicyStore     `idl:"name:hPolicyStore" json:"policy_store"`
	Auth        *fasp.AuthSet210 `idl:"name:pAuth" json:"auth"`
	Status      fasp.RuleStatus  `idl:"name:pStatus" json:"status"`
	Return      uint32           `idl:"name:Return" json:"return"`
}

func (o *xxx_SetAuthenticationSet210Operation) OpNum() int { return 53 }

func (o *xxx_SetAuthenticationSet210Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWSetAuthenticationSet2_10"
}

func (o *xxx_SetAuthenticationSet210Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetAuthenticationSet210Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pAuth {in} (1:{alias=PFW_AUTH_SET2_10}*(1))(2:{alias=FW_AUTH_SET2_10}(struct))
	{
		if o.Auth != nil {
			if err := o.Auth.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.AuthSet210{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetAuthenticationSet210Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pAuth {in} (1:{alias=PFW_AUTH_SET2_10,pointer=ref}*(1))(2:{alias=FW_AUTH_SET2_10}(struct))
	{
		if o.Auth == nil {
			o.Auth = &fasp.AuthSet210{}
		}
		if err := o.Auth.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetAuthenticationSet210Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetAuthenticationSet210Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.WriteEnum(uint32(o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetAuthenticationSet210Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.ReadEnum((*uint32)(&o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetAuthenticationSet210Request structure represents the RRPC_FWSetAuthenticationSet2_10 operation request
type SetAuthenticationSet210Request struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pAuth: This parameter represents the authentication set that the client wants to
	// add to the store. The set MUST be valid, as specified in the definition of the FW_AUTH_SET2_10
	// data type.
	Auth *fasp.AuthSet210 `idl:"name:pAuth" json:"auth"`
}

func (o *SetAuthenticationSet210Request) xxx_ToOp(ctx context.Context, op *xxx_SetAuthenticationSet210Operation) *xxx_SetAuthenticationSet210Operation {
	if op == nil {
		op = &xxx_SetAuthenticationSet210Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Auth = o.Auth
	return op
}

func (o *SetAuthenticationSet210Request) xxx_FromOp(ctx context.Context, op *xxx_SetAuthenticationSet210Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Auth = op.Auth
}
func (o *SetAuthenticationSet210Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetAuthenticationSet210Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetAuthenticationSet210Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetAuthenticationSet210Response structure represents the RRPC_FWSetAuthenticationSet2_10 operation response
type SetAuthenticationSet210Response struct {
	// pStatus: This output parameter is the status code of the rule as specified by the
	// FW_RULE_STATUS enumeration. This field is filled out on return.
	Status fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	// Return: The RRPC_FWSetAuthenticationSet2_10 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetAuthenticationSet210Response) xxx_ToOp(ctx context.Context, op *xxx_SetAuthenticationSet210Operation) *xxx_SetAuthenticationSet210Operation {
	if op == nil {
		op = &xxx_SetAuthenticationSet210Operation{}
	}
	if o == nil {
		return op
	}
	op.Status = o.Status
	op.Return = o.Return
	return op
}

func (o *SetAuthenticationSet210Response) xxx_FromOp(ctx context.Context, op *xxx_SetAuthenticationSet210Operation) {
	if o == nil {
		return
	}
	o.Status = op.Status
	o.Return = op.Return
}
func (o *SetAuthenticationSet210Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetAuthenticationSet210Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetAuthenticationSet210Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumAuthenticationSets210Operation structure represents the RRPC_FWEnumAuthenticationSets2_10 operation
type xxx_EnumAuthenticationSets210Operation struct {
	PolicyStore      *PolicyStore     `idl:"name:hPolicyStore" json:"policy_store"`
	IPsecPhase       fasp.IPsecPhase  `idl:"name:IpSecPhase" json:"ipsec_phase"`
	FilteredByStatus uint32           `idl:"name:dwFilteredByStatus" json:"filtered_by_status"`
	Flags            uint16           `idl:"name:wFlags" json:"flags"`
	AuthSetsLength   uint32           `idl:"name:pdwNumAuthSets" json:"auth_sets_length"`
	Auth             *fasp.AuthSet210 `idl:"name:ppAuth" json:"auth"`
	Return           uint32           `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumAuthenticationSets210Operation) OpNum() int { return 54 }

func (o *xxx_EnumAuthenticationSets210Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWEnumAuthenticationSets2_10"
}

func (o *xxx_EnumAuthenticationSets210Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.IPsecPhase < fasp.IPsecPhase(1) || o.IPsecPhase > fasp.IPsecPhase(2) {
		return fmt.Errorf("IPsecPhase is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumAuthenticationSets210Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// IpSecPhase {in} (1:{range=(1,2), alias=FW_IPSEC_PHASE}(enum))
	{
		if err := w.WriteEnum(uint16(o.IPsecPhase)); err != nil {
			return err
		}
	}
	// dwFilteredByStatus {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.FilteredByStatus); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumAuthenticationSets210Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// IpSecPhase {in} (1:{range=(1,2), alias=FW_IPSEC_PHASE}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.IPsecPhase)); err != nil {
			return err
		}
	}
	// dwFilteredByStatus {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.FilteredByStatus); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumAuthenticationSets210Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumAuthenticationSets210Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwNumAuthSets {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.AuthSetsLength); err != nil {
			return err
		}
	}
	// ppAuth {out} (1:{pointer=ref}*(2))(2:{alias=PFW_AUTH_SET2_10}*(1))(3:{alias=FW_AUTH_SET2_10}(struct))
	{
		if o.Auth != nil {
			_ptr_ppAuth := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Auth != nil {
					if err := o.Auth.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&fasp.AuthSet210{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Auth, _ptr_ppAuth); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumAuthenticationSets210Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwNumAuthSets {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.AuthSetsLength); err != nil {
			return err
		}
	}
	// ppAuth {out} (1:{pointer=ref}*(2))(2:{alias=PFW_AUTH_SET2_10,pointer=ref}*(1))(3:{alias=FW_AUTH_SET2_10}(struct))
	{
		_ptr_ppAuth := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Auth == nil {
				o.Auth = &fasp.AuthSet210{}
			}
			if err := o.Auth.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ppAuth := func(ptr interface{}) { o.Auth = *ptr.(**fasp.AuthSet210) }
		if err := w.ReadPointer(&o.Auth, _s_ppAuth, _ptr_ppAuth); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumAuthenticationSets210Request structure represents the RRPC_FWEnumAuthenticationSets2_10 operation request
type EnumAuthenticationSets210Request struct {
	// hPolicyStore: This input parameter is an FW_POLICY_STORE_HANDLE data type. The data
	// type MUST contain an opened policy store handle, successfully opened with the RRPC_FWOpenPolicyStore
	// (Opnum 0) method. The handle MUST have read/write access rights.
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// IpSecPhase: This parameter specifies the specific IPsec negotiation phase to which
	// this set applies.
	IPsecPhase fasp.IPsecPhase `idl:"name:IpSecPhase" json:"ipsec_phase"`
	// dwFilteredByStatus: This parameter is a combination of flags from the FW_RULE_STATUS_CLASS
	// enumeration. This method uses this bitmask to determine which rules will be returned.
	// Rules that contain a status code of the specified class that match this parameter
	// will be returned in the linked list.
	FilteredByStatus uint32 `idl:"name:dwFilteredByStatus" json:"filtered_by_status"`
	// wFlags: This parameter is a combination of flags from the FW_ENUM_RULES_FLAGS enumeration,
	// which modifies the behavior of the method and performs operations on the rules before
	// returning them in the linked list.
	Flags uint16 `idl:"name:wFlags" json:"flags"`
}

func (o *EnumAuthenticationSets210Request) xxx_ToOp(ctx context.Context, op *xxx_EnumAuthenticationSets210Operation) *xxx_EnumAuthenticationSets210Operation {
	if op == nil {
		op = &xxx_EnumAuthenticationSets210Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.IPsecPhase = o.IPsecPhase
	op.FilteredByStatus = o.FilteredByStatus
	op.Flags = o.Flags
	return op
}

func (o *EnumAuthenticationSets210Request) xxx_FromOp(ctx context.Context, op *xxx_EnumAuthenticationSets210Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.IPsecPhase = op.IPsecPhase
	o.FilteredByStatus = op.FilteredByStatus
	o.Flags = op.Flags
}
func (o *EnumAuthenticationSets210Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumAuthenticationSets210Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumAuthenticationSets210Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumAuthenticationSets210Response structure represents the RRPC_FWEnumAuthenticationSets2_10 operation response
type EnumAuthenticationSets210Response struct {
	// pdwNumAuthSets: This is an output parameter that on success MUST be equal to the
	// number of sets returned.
	AuthSetsLength uint32 `idl:"name:pdwNumAuthSets" json:"auth_sets_length"`
	// ppAuth: This is an output parameter that, on success, contains a linked list of FW_AUTH_SET2_10
	// data types.
	Auth *fasp.AuthSet210 `idl:"name:ppAuth" json:"auth"`
	// Return: The RRPC_FWEnumAuthenticationSets2_10 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumAuthenticationSets210Response) xxx_ToOp(ctx context.Context, op *xxx_EnumAuthenticationSets210Operation) *xxx_EnumAuthenticationSets210Operation {
	if op == nil {
		op = &xxx_EnumAuthenticationSets210Operation{}
	}
	if o == nil {
		return op
	}
	op.AuthSetsLength = o.AuthSetsLength
	op.Auth = o.Auth
	op.Return = o.Return
	return op
}

func (o *EnumAuthenticationSets210Response) xxx_FromOp(ctx context.Context, op *xxx_EnumAuthenticationSets210Operation) {
	if o == nil {
		return
	}
	o.AuthSetsLength = op.AuthSetsLength
	o.Auth = op.Auth
	o.Return = op.Return
}
func (o *EnumAuthenticationSets210Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumAuthenticationSets210Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumAuthenticationSets210Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddCryptoSet210Operation structure represents the RRPC_FWAddCryptoSet2_10 operation
type xxx_AddCryptoSet210Operation struct {
	PolicyStore *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	Crypto      *fasp.CryptoSet `idl:"name:pCrypto" json:"crypto"`
	Status      fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	Return      uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_AddCryptoSet210Operation) OpNum() int { return 55 }

func (o *xxx_AddCryptoSet210Operation) OpName() string { return "/RemoteFW/v1/RRPC_FWAddCryptoSet2_10" }

func (o *xxx_AddCryptoSet210Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddCryptoSet210Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pCrypto {in} (1:{alias=PFW_CRYPTO_SET}*(1))(2:{alias=FW_CRYPTO_SET}(struct))
	{
		if o.Crypto != nil {
			if err := o.Crypto.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.CryptoSet{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddCryptoSet210Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pCrypto {in} (1:{alias=PFW_CRYPTO_SET,pointer=ref}*(1))(2:{alias=FW_CRYPTO_SET}(struct))
	{
		if o.Crypto == nil {
			o.Crypto = &fasp.CryptoSet{}
		}
		if err := o.Crypto.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddCryptoSet210Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddCryptoSet210Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.WriteEnum(uint32(o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddCryptoSet210Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.ReadEnum((*uint32)(&o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddCryptoSet210Request structure represents the RRPC_FWAddCryptoSet2_10 operation request
type AddCryptoSet210Request struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pCrypto: This parameter represents the cryptographic set that the client adds to
	// the store. The set MUST be valid, as specified in the definition of the FW_CRYPTO_SET
	// data type.
	Crypto *fasp.CryptoSet `idl:"name:pCrypto" json:"crypto"`
}

func (o *AddCryptoSet210Request) xxx_ToOp(ctx context.Context, op *xxx_AddCryptoSet210Operation) *xxx_AddCryptoSet210Operation {
	if op == nil {
		op = &xxx_AddCryptoSet210Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Crypto = o.Crypto
	return op
}

func (o *AddCryptoSet210Request) xxx_FromOp(ctx context.Context, op *xxx_AddCryptoSet210Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Crypto = op.Crypto
}
func (o *AddCryptoSet210Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *AddCryptoSet210Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddCryptoSet210Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddCryptoSet210Response structure represents the RRPC_FWAddCryptoSet2_10 operation response
type AddCryptoSet210Response struct {
	// pStatus: This output parameter is the status code of the rule as specified by the
	// FW_RULE_STATUS enumeration. This field is filled out on return.
	Status fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	// Return: The RRPC_FWAddCryptoSet2_10 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddCryptoSet210Response) xxx_ToOp(ctx context.Context, op *xxx_AddCryptoSet210Operation) *xxx_AddCryptoSet210Operation {
	if op == nil {
		op = &xxx_AddCryptoSet210Operation{}
	}
	if o == nil {
		return op
	}
	op.Status = o.Status
	op.Return = o.Return
	return op
}

func (o *AddCryptoSet210Response) xxx_FromOp(ctx context.Context, op *xxx_AddCryptoSet210Operation) {
	if o == nil {
		return
	}
	o.Status = op.Status
	o.Return = op.Return
}
func (o *AddCryptoSet210Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *AddCryptoSet210Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddCryptoSet210Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetCryptoSet210Operation structure represents the RRPC_FWSetCryptoSet2_10 operation
type xxx_SetCryptoSet210Operation struct {
	PolicyStore *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	Crypto      *fasp.CryptoSet `idl:"name:pCrypto" json:"crypto"`
	Status      fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	Return      uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_SetCryptoSet210Operation) OpNum() int { return 56 }

func (o *xxx_SetCryptoSet210Operation) OpName() string { return "/RemoteFW/v1/RRPC_FWSetCryptoSet2_10" }

func (o *xxx_SetCryptoSet210Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetCryptoSet210Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pCrypto {in} (1:{alias=PFW_CRYPTO_SET}*(1))(2:{alias=FW_CRYPTO_SET}(struct))
	{
		if o.Crypto != nil {
			if err := o.Crypto.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.CryptoSet{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetCryptoSet210Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pCrypto {in} (1:{alias=PFW_CRYPTO_SET,pointer=ref}*(1))(2:{alias=FW_CRYPTO_SET}(struct))
	{
		if o.Crypto == nil {
			o.Crypto = &fasp.CryptoSet{}
		}
		if err := o.Crypto.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetCryptoSet210Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetCryptoSet210Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.WriteEnum(uint32(o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetCryptoSet210Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.ReadEnum((*uint32)(&o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetCryptoSet210Request structure represents the RRPC_FWSetCryptoSet2_10 operation request
type SetCryptoSet210Request struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pCrypto: This parameter represents the cryptographic set that the client adds to
	// the store. The set MUST be valid, as specified in the definition of the FW_CRYPTO_SET
	// data type.
	Crypto *fasp.CryptoSet `idl:"name:pCrypto" json:"crypto"`
}

func (o *SetCryptoSet210Request) xxx_ToOp(ctx context.Context, op *xxx_SetCryptoSet210Operation) *xxx_SetCryptoSet210Operation {
	if op == nil {
		op = &xxx_SetCryptoSet210Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Crypto = o.Crypto
	return op
}

func (o *SetCryptoSet210Request) xxx_FromOp(ctx context.Context, op *xxx_SetCryptoSet210Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Crypto = op.Crypto
}
func (o *SetCryptoSet210Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetCryptoSet210Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetCryptoSet210Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetCryptoSet210Response structure represents the RRPC_FWSetCryptoSet2_10 operation response
type SetCryptoSet210Response struct {
	// pStatus: This output parameter is the status code of the rule as specified by the
	// FW_RULE_STATUS enumeration. This field is filled out on return.
	Status fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	// Return: The RRPC_FWSetCryptoSet2_10 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetCryptoSet210Response) xxx_ToOp(ctx context.Context, op *xxx_SetCryptoSet210Operation) *xxx_SetCryptoSet210Operation {
	if op == nil {
		op = &xxx_SetCryptoSet210Operation{}
	}
	if o == nil {
		return op
	}
	op.Status = o.Status
	op.Return = o.Return
	return op
}

func (o *SetCryptoSet210Response) xxx_FromOp(ctx context.Context, op *xxx_SetCryptoSet210Operation) {
	if o == nil {
		return
	}
	o.Status = op.Status
	o.Return = op.Return
}
func (o *SetCryptoSet210Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetCryptoSet210Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetCryptoSet210Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumCryptoSets210Operation structure represents the RRPC_FWEnumCryptoSets2_10 operation
type xxx_EnumCryptoSets210Operation struct {
	PolicyStore      *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	IPsecPhase       fasp.IPsecPhase `idl:"name:IpSecPhase" json:"ipsec_phase"`
	FilteredByStatus uint32          `idl:"name:dwFilteredByStatus" json:"filtered_by_status"`
	Flags            uint16          `idl:"name:wFlags" json:"flags"`
	SetsLength       uint32          `idl:"name:pdwNumSets;pointer:ref" json:"sets_length"`
	CryptoSets       *fasp.CryptoSet `idl:"name:ppCryptoSets" json:"crypto_sets"`
	Return           uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumCryptoSets210Operation) OpNum() int { return 57 }

func (o *xxx_EnumCryptoSets210Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWEnumCryptoSets2_10"
}

func (o *xxx_EnumCryptoSets210Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.IPsecPhase < fasp.IPsecPhase(1) || o.IPsecPhase > fasp.IPsecPhase(2) {
		return fmt.Errorf("IPsecPhase is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumCryptoSets210Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// IpSecPhase {in} (1:{range=(1,2), alias=FW_IPSEC_PHASE}(enum))
	{
		if err := w.WriteEnum(uint16(o.IPsecPhase)); err != nil {
			return err
		}
	}
	// dwFilteredByStatus {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.FilteredByStatus); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumCryptoSets210Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// IpSecPhase {in} (1:{range=(1,2), alias=FW_IPSEC_PHASE}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.IPsecPhase)); err != nil {
			return err
		}
	}
	// dwFilteredByStatus {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.FilteredByStatus); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumCryptoSets210Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumCryptoSets210Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwNumSets {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.SetsLength); err != nil {
			return err
		}
	}
	// ppCryptoSets {out} (1:{pointer=ref}*(2))(2:{alias=PFW_CRYPTO_SET}*(1))(3:{alias=FW_CRYPTO_SET}(struct))
	{
		if o.CryptoSets != nil {
			_ptr_ppCryptoSets := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.CryptoSets != nil {
					if err := o.CryptoSets.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&fasp.CryptoSet{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.CryptoSets, _ptr_ppCryptoSets); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumCryptoSets210Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwNumSets {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.SetsLength); err != nil {
			return err
		}
	}
	// ppCryptoSets {out} (1:{pointer=ref}*(2))(2:{alias=PFW_CRYPTO_SET,pointer=ref}*(1))(3:{alias=FW_CRYPTO_SET}(struct))
	{
		_ptr_ppCryptoSets := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.CryptoSets == nil {
				o.CryptoSets = &fasp.CryptoSet{}
			}
			if err := o.CryptoSets.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ppCryptoSets := func(ptr interface{}) { o.CryptoSets = *ptr.(**fasp.CryptoSet) }
		if err := w.ReadPointer(&o.CryptoSets, _s_ppCryptoSets, _ptr_ppCryptoSets); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumCryptoSets210Request structure represents the RRPC_FWEnumCryptoSets2_10 operation request
type EnumCryptoSets210Request struct {
	// hPolicyStore: This input parameter is an FW_POLICY_STORE_HANDLE data type. The data
	// type MUST contain an opened policy store handle, successfully opened with the RRPC_FWOpenPolicyStore
	// (Opnum 0) method. The handle MUST have read/write access rights.
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// IpSecPhase: This parameter specifies the specific IPsec negotiation phase to which
	// this set applies.
	IPsecPhase fasp.IPsecPhase `idl:"name:IpSecPhase" json:"ipsec_phase"`
	// dwFilteredByStatus: This parameter is a combination of flags from the FW_RULE_STATUS_CLASS
	// enumeration. This method uses this bitmask to determine which rules will be returned.
	// Rules that contain a status code of the class specified that match this parameter
	// will be returned in the linked list.
	FilteredByStatus uint32 `idl:"name:dwFilteredByStatus" json:"filtered_by_status"`
	// wFlags: This parameter is a combination of flags from the FW_ENUM_RULES_FLAGS enumeration,
	// which modifies the behavior of the method and performs operations on the rules before
	// returning them in the linked list.
	Flags uint16 `idl:"name:wFlags" json:"flags"`
}

func (o *EnumCryptoSets210Request) xxx_ToOp(ctx context.Context, op *xxx_EnumCryptoSets210Operation) *xxx_EnumCryptoSets210Operation {
	if op == nil {
		op = &xxx_EnumCryptoSets210Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.IPsecPhase = o.IPsecPhase
	op.FilteredByStatus = o.FilteredByStatus
	op.Flags = o.Flags
	return op
}

func (o *EnumCryptoSets210Request) xxx_FromOp(ctx context.Context, op *xxx_EnumCryptoSets210Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.IPsecPhase = op.IPsecPhase
	o.FilteredByStatus = op.FilteredByStatus
	o.Flags = op.Flags
}
func (o *EnumCryptoSets210Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumCryptoSets210Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumCryptoSets210Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumCryptoSets210Response structure represents the RRPC_FWEnumCryptoSets2_10 operation response
type EnumCryptoSets210Response struct {
	// pdwNumSets: This is an output parameter that, on success, MUST be equal to the number
	// of sets returned.
	SetsLength uint32 `idl:"name:pdwNumSets;pointer:ref" json:"sets_length"`
	// ppCryptoSets: This is an output parameter that, on success, contains a linked list
	// of FW_CRYPTO_SET data types.
	CryptoSets *fasp.CryptoSet `idl:"name:ppCryptoSets" json:"crypto_sets"`
	// Return: The RRPC_FWEnumCryptoSets2_10 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumCryptoSets210Response) xxx_ToOp(ctx context.Context, op *xxx_EnumCryptoSets210Operation) *xxx_EnumCryptoSets210Operation {
	if op == nil {
		op = &xxx_EnumCryptoSets210Operation{}
	}
	if o == nil {
		return op
	}
	op.SetsLength = o.SetsLength
	op.CryptoSets = o.CryptoSets
	op.Return = o.Return
	return op
}

func (o *EnumCryptoSets210Response) xxx_FromOp(ctx context.Context, op *xxx_EnumCryptoSets210Operation) {
	if o == nil {
		return
	}
	o.SetsLength = op.SetsLength
	o.CryptoSets = op.CryptoSets
	o.Return = op.Return
}
func (o *EnumCryptoSets210Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumCryptoSets210Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumCryptoSets210Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddConnectionSecurityRule220Operation structure represents the RRPC_FWAddConnectionSecurityRule2_20 operation
type xxx_AddConnectionSecurityRule220Operation struct {
	PolicyStore *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	Rule        *fasp.CSRule    `idl:"name:pRule" json:"rule"`
	Status      fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	Return      uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_AddConnectionSecurityRule220Operation) OpNum() int { return 58 }

func (o *xxx_AddConnectionSecurityRule220Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWAddConnectionSecurityRule2_20"
}

func (o *xxx_AddConnectionSecurityRule220Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddConnectionSecurityRule220Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pRule {in} (1:{alias=PFW_CS_RULE}*(1))(2:{alias=FW_CS_RULE}(struct))
	{
		if o.Rule != nil {
			if err := o.Rule.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.CSRule{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddConnectionSecurityRule220Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pRule {in} (1:{alias=PFW_CS_RULE,pointer=ref}*(1))(2:{alias=FW_CS_RULE}(struct))
	{
		if o.Rule == nil {
			o.Rule = &fasp.CSRule{}
		}
		if err := o.Rule.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddConnectionSecurityRule220Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddConnectionSecurityRule220Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.WriteEnum(uint32(o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddConnectionSecurityRule220Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.ReadEnum((*uint32)(&o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddConnectionSecurityRule220Request structure represents the RRPC_FWAddConnectionSecurityRule2_20 operation request
type AddConnectionSecurityRule220Request struct {
	// hPolicyStore: This input parameter is an FW_POLICY_STORE_HANDLE data type. The data
	// type MUST contain an opened policy store handle, successfully opened with the RRPC_FWOpenPolicyStore
	// (Opnum 0) method. The handle MUST have read/write access rights.
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pRule: This parameter represents the firewall rule that the client adds to the store.
	// The rule MUST be a valid rule, as specified in the definition of the FW_CS_RULE data
	// type.
	Rule *fasp.CSRule `idl:"name:pRule" json:"rule"`
}

func (o *AddConnectionSecurityRule220Request) xxx_ToOp(ctx context.Context, op *xxx_AddConnectionSecurityRule220Operation) *xxx_AddConnectionSecurityRule220Operation {
	if op == nil {
		op = &xxx_AddConnectionSecurityRule220Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Rule = o.Rule
	return op
}

func (o *AddConnectionSecurityRule220Request) xxx_FromOp(ctx context.Context, op *xxx_AddConnectionSecurityRule220Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Rule = op.Rule
}
func (o *AddConnectionSecurityRule220Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *AddConnectionSecurityRule220Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddConnectionSecurityRule220Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddConnectionSecurityRule220Response structure represents the RRPC_FWAddConnectionSecurityRule2_20 operation response
type AddConnectionSecurityRule220Response struct {
	// pStatus: This output parameter is the status code of the rule as specified by the
	// FW_RULE_STATUS enumeration. This field is filled out on return.
	Status fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	// Return: The RRPC_FWAddConnectionSecurityRule2_20 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddConnectionSecurityRule220Response) xxx_ToOp(ctx context.Context, op *xxx_AddConnectionSecurityRule220Operation) *xxx_AddConnectionSecurityRule220Operation {
	if op == nil {
		op = &xxx_AddConnectionSecurityRule220Operation{}
	}
	if o == nil {
		return op
	}
	op.Status = o.Status
	op.Return = o.Return
	return op
}

func (o *AddConnectionSecurityRule220Response) xxx_FromOp(ctx context.Context, op *xxx_AddConnectionSecurityRule220Operation) {
	if o == nil {
		return
	}
	o.Status = op.Status
	o.Return = op.Return
}
func (o *AddConnectionSecurityRule220Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *AddConnectionSecurityRule220Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddConnectionSecurityRule220Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetConnectionSecurityRule220Operation structure represents the RRPC_FWSetConnectionSecurityRule2_20 operation
type xxx_SetConnectionSecurityRule220Operation struct {
	PolicyStore *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	Rule        *fasp.CSRule    `idl:"name:pRule" json:"rule"`
	Status      fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	Return      uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_SetConnectionSecurityRule220Operation) OpNum() int { return 59 }

func (o *xxx_SetConnectionSecurityRule220Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWSetConnectionSecurityRule2_20"
}

func (o *xxx_SetConnectionSecurityRule220Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetConnectionSecurityRule220Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pRule {in} (1:{alias=PFW_CS_RULE}*(1))(2:{alias=FW_CS_RULE}(struct))
	{
		if o.Rule != nil {
			if err := o.Rule.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.CSRule{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetConnectionSecurityRule220Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pRule {in} (1:{alias=PFW_CS_RULE,pointer=ref}*(1))(2:{alias=FW_CS_RULE}(struct))
	{
		if o.Rule == nil {
			o.Rule = &fasp.CSRule{}
		}
		if err := o.Rule.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetConnectionSecurityRule220Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetConnectionSecurityRule220Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.WriteEnum(uint32(o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetConnectionSecurityRule220Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.ReadEnum((*uint32)(&o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetConnectionSecurityRule220Request structure represents the RRPC_FWSetConnectionSecurityRule2_20 operation request
type SetConnectionSecurityRule220Request struct {
	// hPolicyStore: This input parameter is an FW_POLICY_STORE_HANDLE data type. The data
	// type MUST contain an opened policy store handle, successfully opened with the RRPC_FWOpenPolicyStore
	// (Opnum 0) method. The handle MUST have read/write access rights.
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pRule: This parameter represents the firewall rule that the client wants to add to
	// the store. The rule MUST be a valid rule, as specified in the definition of the FW_CS_RULE
	// data type.
	Rule *fasp.CSRule `idl:"name:pRule" json:"rule"`
}

func (o *SetConnectionSecurityRule220Request) xxx_ToOp(ctx context.Context, op *xxx_SetConnectionSecurityRule220Operation) *xxx_SetConnectionSecurityRule220Operation {
	if op == nil {
		op = &xxx_SetConnectionSecurityRule220Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Rule = o.Rule
	return op
}

func (o *SetConnectionSecurityRule220Request) xxx_FromOp(ctx context.Context, op *xxx_SetConnectionSecurityRule220Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Rule = op.Rule
}
func (o *SetConnectionSecurityRule220Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetConnectionSecurityRule220Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetConnectionSecurityRule220Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetConnectionSecurityRule220Response structure represents the RRPC_FWSetConnectionSecurityRule2_20 operation response
type SetConnectionSecurityRule220Response struct {
	// pStatus: This output parameter is the status code of the rule as specified by the
	// FW_RULE_STATUS enumeration. This field is filled out on return.
	Status fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	// Return: The RRPC_FWSetConnectionSecurityRule2_20 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetConnectionSecurityRule220Response) xxx_ToOp(ctx context.Context, op *xxx_SetConnectionSecurityRule220Operation) *xxx_SetConnectionSecurityRule220Operation {
	if op == nil {
		op = &xxx_SetConnectionSecurityRule220Operation{}
	}
	if o == nil {
		return op
	}
	op.Status = o.Status
	op.Return = o.Return
	return op
}

func (o *SetConnectionSecurityRule220Response) xxx_FromOp(ctx context.Context, op *xxx_SetConnectionSecurityRule220Operation) {
	if o == nil {
		return
	}
	o.Status = op.Status
	o.Return = op.Return
}
func (o *SetConnectionSecurityRule220Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetConnectionSecurityRule220Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetConnectionSecurityRule220Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumConnectionSecurityRules220Operation structure represents the RRPC_FWEnumConnectionSecurityRules2_20 operation
type xxx_EnumConnectionSecurityRules220Operation struct {
	PolicyStore      *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	FilteredByStatus uint32       `idl:"name:dwFilteredByStatus" json:"filtered_by_status"`
	ProfileFilter    uint32       `idl:"name:dwProfileFilter" json:"profile_filter"`
	Flags            uint16       `idl:"name:wFlags" json:"flags"`
	RulesLength      uint32       `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	Rules            *fasp.CSRule `idl:"name:ppRules" json:"rules"`
	Return           uint32       `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumConnectionSecurityRules220Operation) OpNum() int { return 60 }

func (o *xxx_EnumConnectionSecurityRules220Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWEnumConnectionSecurityRules2_20"
}

func (o *xxx_EnumConnectionSecurityRules220Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumConnectionSecurityRules220Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwFilteredByStatus {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.FilteredByStatus); err != nil {
			return err
		}
	}
	// dwProfileFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ProfileFilter); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumConnectionSecurityRules220Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwFilteredByStatus {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.FilteredByStatus); err != nil {
			return err
		}
	}
	// dwProfileFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ProfileFilter); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumConnectionSecurityRules220Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumConnectionSecurityRules220Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RulesLength); err != nil {
			return err
		}
	}
	// ppRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_CS_RULE}*(1))(3:{alias=FW_CS_RULE}(struct))
	{
		if o.Rules != nil {
			_ptr_ppRules := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Rules != nil {
					if err := o.Rules.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&fasp.CSRule{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Rules, _ptr_ppRules); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumConnectionSecurityRules220Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RulesLength); err != nil {
			return err
		}
	}
	// ppRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_CS_RULE,pointer=ref}*(1))(3:{alias=FW_CS_RULE}(struct))
	{
		_ptr_ppRules := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Rules == nil {
				o.Rules = &fasp.CSRule{}
			}
			if err := o.Rules.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ppRules := func(ptr interface{}) { o.Rules = *ptr.(**fasp.CSRule) }
		if err := w.ReadPointer(&o.Rules, _s_ppRules, _ptr_ppRules); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumConnectionSecurityRules220Request structure represents the RRPC_FWEnumConnectionSecurityRules2_20 operation request
type EnumConnectionSecurityRules220Request struct {
	// hPolicyStore: This input parameter is an FW_POLICY_STORE_HANDLE data type. The data
	// type MUST contain an opened policy store handle, successfully opened with the RRPC_FWOpenPolicyStore
	// (Opnum 0) method. The handle MUST have read/write access rights.
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// dwFilteredByStatus: This parameter is a combination of flags from the FW_RULE_STATUS_CLASS
	// enumeration. This method uses this bitmask to determine which rules will be returned.
	// Rules that contain a status code of the specified class that match this parameter
	// will be returned in the linked list.
	FilteredByStatus uint32 `idl:"name:dwFilteredByStatus" json:"filtered_by_status"`
	// dwProfileFilter: This parameter is a combination of flags from the FW_PROFILE_TYPE
	// enumeration. This method also uses this parameter to determine which rules will be
	// returned. Rules that contain a profile specified by this parameter will be returned
	// in the linked list.
	ProfileFilter uint32 `idl:"name:dwProfileFilter" json:"profile_filter"`
	// wFlags: This parameter is a combination of flags from the FW_ENUM_RULES_FLAGS enumeration,
	// which modifies the behavior of the method and performs operations on the rules before
	// returning them in the linked list.
	Flags uint16 `idl:"name:wFlags" json:"flags"`
}

func (o *EnumConnectionSecurityRules220Request) xxx_ToOp(ctx context.Context, op *xxx_EnumConnectionSecurityRules220Operation) *xxx_EnumConnectionSecurityRules220Operation {
	if op == nil {
		op = &xxx_EnumConnectionSecurityRules220Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.FilteredByStatus = o.FilteredByStatus
	op.ProfileFilter = o.ProfileFilter
	op.Flags = o.Flags
	return op
}

func (o *EnumConnectionSecurityRules220Request) xxx_FromOp(ctx context.Context, op *xxx_EnumConnectionSecurityRules220Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.FilteredByStatus = op.FilteredByStatus
	o.ProfileFilter = op.ProfileFilter
	o.Flags = op.Flags
}
func (o *EnumConnectionSecurityRules220Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumConnectionSecurityRules220Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumConnectionSecurityRules220Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumConnectionSecurityRules220Response structure represents the RRPC_FWEnumConnectionSecurityRules2_20 operation response
type EnumConnectionSecurityRules220Response struct {
	// pdwNumRules: This is an output parameter that on success MUST be equal to the number
	// of rules returned.
	RulesLength uint32 `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	// ppRules: This is an output parameter that on success contains a linked list of FW_CS_RULE
	// data types.
	Rules *fasp.CSRule `idl:"name:ppRules" json:"rules"`
	// Return: The RRPC_FWEnumConnectionSecurityRules2_20 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumConnectionSecurityRules220Response) xxx_ToOp(ctx context.Context, op *xxx_EnumConnectionSecurityRules220Operation) *xxx_EnumConnectionSecurityRules220Operation {
	if op == nil {
		op = &xxx_EnumConnectionSecurityRules220Operation{}
	}
	if o == nil {
		return op
	}
	op.RulesLength = o.RulesLength
	op.Rules = o.Rules
	op.Return = o.Return
	return op
}

func (o *EnumConnectionSecurityRules220Response) xxx_FromOp(ctx context.Context, op *xxx_EnumConnectionSecurityRules220Operation) {
	if o == nil {
		return
	}
	o.RulesLength = op.RulesLength
	o.Rules = op.Rules
	o.Return = op.Return
}
func (o *EnumConnectionSecurityRules220Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumConnectionSecurityRules220Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumConnectionSecurityRules220Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_QueryConnectionSecurityRules220Operation structure represents the RRPC_FWQueryConnectionSecurityRules2_20 operation
type xxx_QueryConnectionSecurityRules220Operation struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	Query       *fasp.Query  `idl:"name:pQuery" json:"query"`
	Flags       uint16       `idl:"name:wFlags" json:"flags"`
	RulesLength uint32       `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	Rules       *fasp.CSRule `idl:"name:ppRules" json:"rules"`
	Return      uint32       `idl:"name:Return" json:"return"`
}

func (o *xxx_QueryConnectionSecurityRules220Operation) OpNum() int { return 61 }

func (o *xxx_QueryConnectionSecurityRules220Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWQueryConnectionSecurityRules2_20"
}

func (o *xxx_QueryConnectionSecurityRules220Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryConnectionSecurityRules220Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pQuery {in} (1:{alias=PFW_QUERY}*(1))(2:{alias=FW_QUERY}(struct))
	{
		if o.Query != nil {
			if err := o.Query.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.Query{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryConnectionSecurityRules220Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pQuery {in} (1:{alias=PFW_QUERY,pointer=ref}*(1))(2:{alias=FW_QUERY}(struct))
	{
		if o.Query == nil {
			o.Query = &fasp.Query{}
		}
		if err := o.Query.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryConnectionSecurityRules220Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryConnectionSecurityRules220Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RulesLength); err != nil {
			return err
		}
	}
	// ppRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_CS_RULE}*(1))(3:{alias=FW_CS_RULE}(struct))
	{
		if o.Rules != nil {
			_ptr_ppRules := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Rules != nil {
					if err := o.Rules.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&fasp.CSRule{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Rules, _ptr_ppRules); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryConnectionSecurityRules220Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RulesLength); err != nil {
			return err
		}
	}
	// ppRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_CS_RULE,pointer=ref}*(1))(3:{alias=FW_CS_RULE}(struct))
	{
		_ptr_ppRules := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Rules == nil {
				o.Rules = &fasp.CSRule{}
			}
			if err := o.Rules.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ppRules := func(ptr interface{}) { o.Rules = *ptr.(**fasp.CSRule) }
		if err := w.ReadPointer(&o.Rules, _s_ppRules, _ptr_ppRules); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// QueryConnectionSecurityRules220Request structure represents the RRPC_FWQueryConnectionSecurityRules2_20 operation request
type QueryConnectionSecurityRules220Request struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pQuery: This parameter represents the query object that the client uses to specify
	// which main mode rules MUST be retrieved from the store. The query object MUST be
	// valid, as specified in the definition of the FW_QUERY data type.
	Query *fasp.Query `idl:"name:pQuery" json:"query"`
	// wFlags: This parameter is a combination of flags from the FW_ENUM_RULES_FLAGS enumeration,
	// which modifies the behavior of the method and performs operations on the rules before
	// returning them in the linked list.
	Flags uint16 `idl:"name:wFlags" json:"flags"`
}

func (o *QueryConnectionSecurityRules220Request) xxx_ToOp(ctx context.Context, op *xxx_QueryConnectionSecurityRules220Operation) *xxx_QueryConnectionSecurityRules220Operation {
	if op == nil {
		op = &xxx_QueryConnectionSecurityRules220Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Query = o.Query
	op.Flags = o.Flags
	return op
}

func (o *QueryConnectionSecurityRules220Request) xxx_FromOp(ctx context.Context, op *xxx_QueryConnectionSecurityRules220Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Query = op.Query
	o.Flags = op.Flags
}
func (o *QueryConnectionSecurityRules220Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *QueryConnectionSecurityRules220Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryConnectionSecurityRules220Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// QueryConnectionSecurityRules220Response structure represents the RRPC_FWQueryConnectionSecurityRules2_20 operation response
type QueryConnectionSecurityRules220Response struct {
	// pdwNumRules: This is an output parameter that on success MUST be equal to the number
	// of rules returned.
	RulesLength uint32 `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	// ppRules: This is an output parameter that on success contains a linked list of FW_CS_RULE
	// data types.
	Rules *fasp.CSRule `idl:"name:ppRules" json:"rules"`
	// Return: The RRPC_FWQueryConnectionSecurityRules2_20 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *QueryConnectionSecurityRules220Response) xxx_ToOp(ctx context.Context, op *xxx_QueryConnectionSecurityRules220Operation) *xxx_QueryConnectionSecurityRules220Operation {
	if op == nil {
		op = &xxx_QueryConnectionSecurityRules220Operation{}
	}
	if o == nil {
		return op
	}
	op.RulesLength = o.RulesLength
	op.Rules = o.Rules
	op.Return = o.Return
	return op
}

func (o *QueryConnectionSecurityRules220Response) xxx_FromOp(ctx context.Context, op *xxx_QueryConnectionSecurityRules220Operation) {
	if o == nil {
		return
	}
	o.RulesLength = op.RulesLength
	o.Rules = op.Rules
	o.Return = op.Return
}
func (o *QueryConnectionSecurityRules220Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *QueryConnectionSecurityRules220Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryConnectionSecurityRules220Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddAuthenticationSet220Operation structure represents the RRPC_FWAddAuthenticationSet2_20 operation
type xxx_AddAuthenticationSet220Operation struct {
	PolicyStore *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	Auth        *fasp.AuthSet   `idl:"name:pAuth" json:"auth"`
	Status      fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	Return      uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_AddAuthenticationSet220Operation) OpNum() int { return 62 }

func (o *xxx_AddAuthenticationSet220Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWAddAuthenticationSet2_20"
}

func (o *xxx_AddAuthenticationSet220Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddAuthenticationSet220Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pAuth {in} (1:{alias=PFW_AUTH_SET}*(1))(2:{alias=FW_AUTH_SET}(struct))
	{
		if o.Auth != nil {
			if err := o.Auth.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.AuthSet{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddAuthenticationSet220Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pAuth {in} (1:{alias=PFW_AUTH_SET,pointer=ref}*(1))(2:{alias=FW_AUTH_SET}(struct))
	{
		if o.Auth == nil {
			o.Auth = &fasp.AuthSet{}
		}
		if err := o.Auth.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddAuthenticationSet220Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddAuthenticationSet220Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.WriteEnum(uint32(o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddAuthenticationSet220Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.ReadEnum((*uint32)(&o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddAuthenticationSet220Request structure represents the RRPC_FWAddAuthenticationSet2_20 operation request
type AddAuthenticationSet220Request struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pAuth: This parameter represents the authentication set the client wants to add to
	// the store. The set MUST be valid, as specified in the definition of the FW_AUTH_SET
	// data type.
	Auth *fasp.AuthSet `idl:"name:pAuth" json:"auth"`
}

func (o *AddAuthenticationSet220Request) xxx_ToOp(ctx context.Context, op *xxx_AddAuthenticationSet220Operation) *xxx_AddAuthenticationSet220Operation {
	if op == nil {
		op = &xxx_AddAuthenticationSet220Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Auth = o.Auth
	return op
}

func (o *AddAuthenticationSet220Request) xxx_FromOp(ctx context.Context, op *xxx_AddAuthenticationSet220Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Auth = op.Auth
}
func (o *AddAuthenticationSet220Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *AddAuthenticationSet220Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddAuthenticationSet220Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddAuthenticationSet220Response structure represents the RRPC_FWAddAuthenticationSet2_20 operation response
type AddAuthenticationSet220Response struct {
	// pStatus: This output parameter is the status code of the rule as specified by the
	// FW_RULE_STATUS enumeration. This field is filled out on return.
	Status fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	// Return: The RRPC_FWAddAuthenticationSet2_20 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddAuthenticationSet220Response) xxx_ToOp(ctx context.Context, op *xxx_AddAuthenticationSet220Operation) *xxx_AddAuthenticationSet220Operation {
	if op == nil {
		op = &xxx_AddAuthenticationSet220Operation{}
	}
	if o == nil {
		return op
	}
	op.Status = o.Status
	op.Return = o.Return
	return op
}

func (o *AddAuthenticationSet220Response) xxx_FromOp(ctx context.Context, op *xxx_AddAuthenticationSet220Operation) {
	if o == nil {
		return
	}
	o.Status = op.Status
	o.Return = op.Return
}
func (o *AddAuthenticationSet220Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *AddAuthenticationSet220Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddAuthenticationSet220Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetAuthenticationSet220Operation structure represents the RRPC_FWSetAuthenticationSet2_20 operation
type xxx_SetAuthenticationSet220Operation struct {
	PolicyStore *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	Auth        *fasp.AuthSet   `idl:"name:pAuth" json:"auth"`
	Status      fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	Return      uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_SetAuthenticationSet220Operation) OpNum() int { return 63 }

func (o *xxx_SetAuthenticationSet220Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWSetAuthenticationSet2_20"
}

func (o *xxx_SetAuthenticationSet220Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetAuthenticationSet220Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pAuth {in} (1:{alias=PFW_AUTH_SET}*(1))(2:{alias=FW_AUTH_SET}(struct))
	{
		if o.Auth != nil {
			if err := o.Auth.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.AuthSet{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetAuthenticationSet220Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pAuth {in} (1:{alias=PFW_AUTH_SET,pointer=ref}*(1))(2:{alias=FW_AUTH_SET}(struct))
	{
		if o.Auth == nil {
			o.Auth = &fasp.AuthSet{}
		}
		if err := o.Auth.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetAuthenticationSet220Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetAuthenticationSet220Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.WriteEnum(uint32(o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetAuthenticationSet220Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.ReadEnum((*uint32)(&o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetAuthenticationSet220Request structure represents the RRPC_FWSetAuthenticationSet2_20 operation request
type SetAuthenticationSet220Request struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pAuth: This parameter represents the authentication set that the client wants to
	// add to the store. The set MUST be valid, as specified in the definition of the FW_AUTH_SET
	// data type.
	Auth *fasp.AuthSet `idl:"name:pAuth" json:"auth"`
}

func (o *SetAuthenticationSet220Request) xxx_ToOp(ctx context.Context, op *xxx_SetAuthenticationSet220Operation) *xxx_SetAuthenticationSet220Operation {
	if op == nil {
		op = &xxx_SetAuthenticationSet220Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Auth = o.Auth
	return op
}

func (o *SetAuthenticationSet220Request) xxx_FromOp(ctx context.Context, op *xxx_SetAuthenticationSet220Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Auth = op.Auth
}
func (o *SetAuthenticationSet220Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetAuthenticationSet220Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetAuthenticationSet220Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetAuthenticationSet220Response structure represents the RRPC_FWSetAuthenticationSet2_20 operation response
type SetAuthenticationSet220Response struct {
	// pStatus: This output parameter is the status code of the rule as specified by the
	// FW_RULE_STATUS enumeration. This field is filled out on return.
	Status fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	// Return: The RRPC_FWSetAuthenticationSet2_20 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetAuthenticationSet220Response) xxx_ToOp(ctx context.Context, op *xxx_SetAuthenticationSet220Operation) *xxx_SetAuthenticationSet220Operation {
	if op == nil {
		op = &xxx_SetAuthenticationSet220Operation{}
	}
	if o == nil {
		return op
	}
	op.Status = o.Status
	op.Return = o.Return
	return op
}

func (o *SetAuthenticationSet220Response) xxx_FromOp(ctx context.Context, op *xxx_SetAuthenticationSet220Operation) {
	if o == nil {
		return
	}
	o.Status = op.Status
	o.Return = op.Return
}
func (o *SetAuthenticationSet220Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetAuthenticationSet220Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetAuthenticationSet220Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumAuthenticationSets220Operation structure represents the RRPC_FWEnumAuthenticationSets2_20 operation
type xxx_EnumAuthenticationSets220Operation struct {
	PolicyStore      *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	IPsecPhase       fasp.IPsecPhase `idl:"name:IpSecPhase" json:"ipsec_phase"`
	FilteredByStatus uint32          `idl:"name:dwFilteredByStatus" json:"filtered_by_status"`
	Flags            uint16          `idl:"name:wFlags" json:"flags"`
	AuthSetsLength   uint32          `idl:"name:pdwNumAuthSets" json:"auth_sets_length"`
	Auth             *fasp.AuthSet   `idl:"name:ppAuth" json:"auth"`
	Return           uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumAuthenticationSets220Operation) OpNum() int { return 64 }

func (o *xxx_EnumAuthenticationSets220Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWEnumAuthenticationSets2_20"
}

func (o *xxx_EnumAuthenticationSets220Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.IPsecPhase < fasp.IPsecPhase(1) || o.IPsecPhase > fasp.IPsecPhase(2) {
		return fmt.Errorf("IPsecPhase is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumAuthenticationSets220Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// IpSecPhase {in} (1:{range=(1,2), alias=FW_IPSEC_PHASE}(enum))
	{
		if err := w.WriteEnum(uint16(o.IPsecPhase)); err != nil {
			return err
		}
	}
	// dwFilteredByStatus {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.FilteredByStatus); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumAuthenticationSets220Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// IpSecPhase {in} (1:{range=(1,2), alias=FW_IPSEC_PHASE}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.IPsecPhase)); err != nil {
			return err
		}
	}
	// dwFilteredByStatus {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.FilteredByStatus); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumAuthenticationSets220Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumAuthenticationSets220Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwNumAuthSets {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.AuthSetsLength); err != nil {
			return err
		}
	}
	// ppAuth {out} (1:{pointer=ref}*(2))(2:{alias=PFW_AUTH_SET}*(1))(3:{alias=FW_AUTH_SET}(struct))
	{
		if o.Auth != nil {
			_ptr_ppAuth := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Auth != nil {
					if err := o.Auth.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&fasp.AuthSet{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Auth, _ptr_ppAuth); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumAuthenticationSets220Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwNumAuthSets {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.AuthSetsLength); err != nil {
			return err
		}
	}
	// ppAuth {out} (1:{pointer=ref}*(2))(2:{alias=PFW_AUTH_SET,pointer=ref}*(1))(3:{alias=FW_AUTH_SET}(struct))
	{
		_ptr_ppAuth := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Auth == nil {
				o.Auth = &fasp.AuthSet{}
			}
			if err := o.Auth.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ppAuth := func(ptr interface{}) { o.Auth = *ptr.(**fasp.AuthSet) }
		if err := w.ReadPointer(&o.Auth, _s_ppAuth, _ptr_ppAuth); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumAuthenticationSets220Request structure represents the RRPC_FWEnumAuthenticationSets2_20 operation request
type EnumAuthenticationSets220Request struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// IpSecPhase: This parameter specifies the specific IPsec negotiation phase to which
	// this set applies.
	IPsecPhase fasp.IPsecPhase `idl:"name:IpSecPhase" json:"ipsec_phase"`
	// dwFilteredByStatus: This parameter is a combination of flags from the FW_RULE_STATUS_CLASS
	// enumeration. This method uses this bitmask to determine which rules will be returned.
	// Rules that contain a status code of the specified class that match this parameter
	// will be returned in the linked list.
	FilteredByStatus uint32 `idl:"name:dwFilteredByStatus" json:"filtered_by_status"`
	// wFlags: This parameter is a combination of flags from the FW_ENUM_RULES_FLAGS enumeration,
	// which modifies the behavior of the method and performs operations on the rules before
	// returning them in the linked list.
	Flags uint16 `idl:"name:wFlags" json:"flags"`
}

func (o *EnumAuthenticationSets220Request) xxx_ToOp(ctx context.Context, op *xxx_EnumAuthenticationSets220Operation) *xxx_EnumAuthenticationSets220Operation {
	if op == nil {
		op = &xxx_EnumAuthenticationSets220Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.IPsecPhase = o.IPsecPhase
	op.FilteredByStatus = o.FilteredByStatus
	op.Flags = o.Flags
	return op
}

func (o *EnumAuthenticationSets220Request) xxx_FromOp(ctx context.Context, op *xxx_EnumAuthenticationSets220Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.IPsecPhase = op.IPsecPhase
	o.FilteredByStatus = op.FilteredByStatus
	o.Flags = op.Flags
}
func (o *EnumAuthenticationSets220Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumAuthenticationSets220Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumAuthenticationSets220Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumAuthenticationSets220Response structure represents the RRPC_FWEnumAuthenticationSets2_20 operation response
type EnumAuthenticationSets220Response struct {
	// pdwNumAuthSets: This is an output parameter that, on success, MUST be equal to the
	// number of sets returned.
	AuthSetsLength uint32 `idl:"name:pdwNumAuthSets" json:"auth_sets_length"`
	// ppAuth: This parameter represents the authentication set the client has added to
	// the store. The set MUST be valid, as specified in the definition of the FW_AUTH_SET
	// data type.
	Auth *fasp.AuthSet `idl:"name:ppAuth" json:"auth"`
	// Return: The RRPC_FWEnumAuthenticationSets2_20 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumAuthenticationSets220Response) xxx_ToOp(ctx context.Context, op *xxx_EnumAuthenticationSets220Operation) *xxx_EnumAuthenticationSets220Operation {
	if op == nil {
		op = &xxx_EnumAuthenticationSets220Operation{}
	}
	if o == nil {
		return op
	}
	op.AuthSetsLength = o.AuthSetsLength
	op.Auth = o.Auth
	op.Return = o.Return
	return op
}

func (o *EnumAuthenticationSets220Response) xxx_FromOp(ctx context.Context, op *xxx_EnumAuthenticationSets220Operation) {
	if o == nil {
		return
	}
	o.AuthSetsLength = op.AuthSetsLength
	o.Auth = op.Auth
	o.Return = op.Return
}
func (o *EnumAuthenticationSets220Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumAuthenticationSets220Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumAuthenticationSets220Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_QueryAuthenticationSets220Operation structure represents the RRPC_FWQueryAuthenticationSets2_20 operation
type xxx_QueryAuthenticationSets220Operation struct {
	PolicyStore *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	IPsecPhase  fasp.IPsecPhase `idl:"name:IPsecPhase" json:"ipsec_phase"`
	Query       *fasp.Query     `idl:"name:pQuery" json:"query"`
	Flags       uint16          `idl:"name:wFlags" json:"flags"`
	SetsLength  uint32          `idl:"name:pdwNumSets;pointer:ref" json:"sets_length"`
	AuthSets    *fasp.AuthSet   `idl:"name:ppAuthSets" json:"auth_sets"`
	Return      uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_QueryAuthenticationSets220Operation) OpNum() int { return 65 }

func (o *xxx_QueryAuthenticationSets220Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWQueryAuthenticationSets2_20"
}

func (o *xxx_QueryAuthenticationSets220Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.IPsecPhase < fasp.IPsecPhase(1) || o.IPsecPhase > fasp.IPsecPhase(2) {
		return fmt.Errorf("IPsecPhase is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryAuthenticationSets220Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// IPsecPhase {in} (1:{range=(1,2), alias=FW_IPSEC_PHASE}(enum))
	{
		if err := w.WriteEnum(uint16(o.IPsecPhase)); err != nil {
			return err
		}
	}
	// pQuery {in} (1:{alias=PFW_QUERY}*(1))(2:{alias=FW_QUERY}(struct))
	{
		if o.Query != nil {
			if err := o.Query.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.Query{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryAuthenticationSets220Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// IPsecPhase {in} (1:{range=(1,2), alias=FW_IPSEC_PHASE}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.IPsecPhase)); err != nil {
			return err
		}
	}
	// pQuery {in} (1:{alias=PFW_QUERY,pointer=ref}*(1))(2:{alias=FW_QUERY}(struct))
	{
		if o.Query == nil {
			o.Query = &fasp.Query{}
		}
		if err := o.Query.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryAuthenticationSets220Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryAuthenticationSets220Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwNumSets {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.SetsLength); err != nil {
			return err
		}
	}
	// ppAuthSets {out} (1:{pointer=ref}*(2))(2:{alias=PFW_AUTH_SET}*(1))(3:{alias=FW_AUTH_SET}(struct))
	{
		if o.AuthSets != nil {
			_ptr_ppAuthSets := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.AuthSets != nil {
					if err := o.AuthSets.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&fasp.AuthSet{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.AuthSets, _ptr_ppAuthSets); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryAuthenticationSets220Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwNumSets {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.SetsLength); err != nil {
			return err
		}
	}
	// ppAuthSets {out} (1:{pointer=ref}*(2))(2:{alias=PFW_AUTH_SET,pointer=ref}*(1))(3:{alias=FW_AUTH_SET}(struct))
	{
		_ptr_ppAuthSets := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.AuthSets == nil {
				o.AuthSets = &fasp.AuthSet{}
			}
			if err := o.AuthSets.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ppAuthSets := func(ptr interface{}) { o.AuthSets = *ptr.(**fasp.AuthSet) }
		if err := w.ReadPointer(&o.AuthSets, _s_ppAuthSets, _ptr_ppAuthSets); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// QueryAuthenticationSets220Request structure represents the RRPC_FWQueryAuthenticationSets2_20 operation request
type QueryAuthenticationSets220Request struct {
	PolicyStore *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	IPsecPhase  fasp.IPsecPhase `idl:"name:IPsecPhase" json:"ipsec_phase"`
	// pQuery: This parameter represents the query object that the client wants to use to
	// specify which main mode rules MUST be retrieved from the store. The query object
	// MUST be valid, as specified in the definition of the FW_QUERY data type.
	Query *fasp.Query `idl:"name:pQuery" json:"query"`
	// wFlags: This parameter is a combination of flags from the FW_ENUM_RULES_FLAGS enumeration,
	// which modifies the behavior of the method and performs operations on the rules before
	// returning them in the linked list.
	Flags uint16 `idl:"name:wFlags" json:"flags"`
}

func (o *QueryAuthenticationSets220Request) xxx_ToOp(ctx context.Context, op *xxx_QueryAuthenticationSets220Operation) *xxx_QueryAuthenticationSets220Operation {
	if op == nil {
		op = &xxx_QueryAuthenticationSets220Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.IPsecPhase = o.IPsecPhase
	op.Query = o.Query
	op.Flags = o.Flags
	return op
}

func (o *QueryAuthenticationSets220Request) xxx_FromOp(ctx context.Context, op *xxx_QueryAuthenticationSets220Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.IPsecPhase = op.IPsecPhase
	o.Query = op.Query
	o.Flags = op.Flags
}
func (o *QueryAuthenticationSets220Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *QueryAuthenticationSets220Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryAuthenticationSets220Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// QueryAuthenticationSets220Response structure represents the RRPC_FWQueryAuthenticationSets2_20 operation response
type QueryAuthenticationSets220Response struct {
	// pdwNumSets: This is an output parameter that, on success, MUST be equal to the number
	// of sets returned.
	SetsLength uint32 `idl:"name:pdwNumSets;pointer:ref" json:"sets_length"`
	// ppAuthSets: This is an output parameter that, on success, contains a linked list
	// of FW_AUTH_SET data types.
	AuthSets *fasp.AuthSet `idl:"name:ppAuthSets" json:"auth_sets"`
	// Return: The RRPC_FWQueryAuthenticationSets2_20 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *QueryAuthenticationSets220Response) xxx_ToOp(ctx context.Context, op *xxx_QueryAuthenticationSets220Operation) *xxx_QueryAuthenticationSets220Operation {
	if op == nil {
		op = &xxx_QueryAuthenticationSets220Operation{}
	}
	if o == nil {
		return op
	}
	op.SetsLength = o.SetsLength
	op.AuthSets = o.AuthSets
	op.Return = o.Return
	return op
}

func (o *QueryAuthenticationSets220Response) xxx_FromOp(ctx context.Context, op *xxx_QueryAuthenticationSets220Operation) {
	if o == nil {
		return
	}
	o.SetsLength = op.SetsLength
	o.AuthSets = op.AuthSets
	o.Return = op.Return
}
func (o *QueryAuthenticationSets220Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *QueryAuthenticationSets220Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryAuthenticationSets220Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddFirewallRule220Operation structure represents the RRPC_FWAddFirewallRule2_20 operation
type xxx_AddFirewallRule220Operation struct {
	PolicyStore *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	Rule        *fasp.Rule220   `idl:"name:pRule" json:"rule"`
	Status      fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	Return      uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_AddFirewallRule220Operation) OpNum() int { return 66 }

func (o *xxx_AddFirewallRule220Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWAddFirewallRule2_20"
}

func (o *xxx_AddFirewallRule220Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFirewallRule220Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pRule {in} (1:{alias=PFW_RULE2_20}*(1))(2:{alias=FW_RULE2_20}(struct))
	{
		if o.Rule != nil {
			if err := o.Rule.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.Rule220{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFirewallRule220Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pRule {in} (1:{alias=PFW_RULE2_20,pointer=ref}*(1))(2:{alias=FW_RULE2_20}(struct))
	{
		if o.Rule == nil {
			o.Rule = &fasp.Rule220{}
		}
		if err := o.Rule.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFirewallRule220Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFirewallRule220Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.WriteEnum(uint32(o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFirewallRule220Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.ReadEnum((*uint32)(&o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddFirewallRule220Request structure represents the RRPC_FWAddFirewallRule2_20 operation request
type AddFirewallRule220Request struct {
	// hPolicyStore: This input parameter is an FW_POLICY_STORE_HANDLE data type. The data
	// type MUST contain an opened policy store handle, successfully opened with the RRPC_FWOpenPolicyStore
	// (Opnum 0) method. The handle MUST have read/write access rights.
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pRule: This parameter represents the firewall rule that the client adds to the store.
	// The rule MUST be a valid rule, as specified in the definition of the FW_RULE2_20
	// data type.
	Rule *fasp.Rule220 `idl:"name:pRule" json:"rule"`
}

func (o *AddFirewallRule220Request) xxx_ToOp(ctx context.Context, op *xxx_AddFirewallRule220Operation) *xxx_AddFirewallRule220Operation {
	if op == nil {
		op = &xxx_AddFirewallRule220Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Rule = o.Rule
	return op
}

func (o *AddFirewallRule220Request) xxx_FromOp(ctx context.Context, op *xxx_AddFirewallRule220Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Rule = op.Rule
}
func (o *AddFirewallRule220Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *AddFirewallRule220Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddFirewallRule220Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddFirewallRule220Response structure represents the RRPC_FWAddFirewallRule2_20 operation response
type AddFirewallRule220Response struct {
	// pStatus: This output parameter is the status code of the rule as specified by the
	// FW_RULE_STATUS enumeration. This field is filled out on return.
	Status fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	// Return: The RRPC_FWAddFirewallRule2_20 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddFirewallRule220Response) xxx_ToOp(ctx context.Context, op *xxx_AddFirewallRule220Operation) *xxx_AddFirewallRule220Operation {
	if op == nil {
		op = &xxx_AddFirewallRule220Operation{}
	}
	if o == nil {
		return op
	}
	op.Status = o.Status
	op.Return = o.Return
	return op
}

func (o *AddFirewallRule220Response) xxx_FromOp(ctx context.Context, op *xxx_AddFirewallRule220Operation) {
	if o == nil {
		return
	}
	o.Status = op.Status
	o.Return = op.Return
}
func (o *AddFirewallRule220Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *AddFirewallRule220Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddFirewallRule220Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetFirewallRule220Operation structure represents the RRPC_FWSetFirewallRule2_20 operation
type xxx_SetFirewallRule220Operation struct {
	PolicyStore *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	Rule        *fasp.Rule220   `idl:"name:pRule" json:"rule"`
	Status      fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	Return      uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_SetFirewallRule220Operation) OpNum() int { return 67 }

func (o *xxx_SetFirewallRule220Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWSetFirewallRule2_20"
}

func (o *xxx_SetFirewallRule220Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFirewallRule220Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pRule {in} (1:{alias=PFW_RULE2_20}*(1))(2:{alias=FW_RULE2_20}(struct))
	{
		if o.Rule != nil {
			if err := o.Rule.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.Rule220{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFirewallRule220Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pRule {in} (1:{alias=PFW_RULE2_20,pointer=ref}*(1))(2:{alias=FW_RULE2_20}(struct))
	{
		if o.Rule == nil {
			o.Rule = &fasp.Rule220{}
		}
		if err := o.Rule.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFirewallRule220Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFirewallRule220Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.WriteEnum(uint32(o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFirewallRule220Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.ReadEnum((*uint32)(&o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetFirewallRule220Request structure represents the RRPC_FWSetFirewallRule2_20 operation request
type SetFirewallRule220Request struct {
	// hPolicyStore: This input parameter is an FW_POLICY_STORE_HANDLE data type. The data
	// type MUST contain an opened policy store handle, successfully opened with the RRPC_FWOpenPolicyStore
	// (Opnum 0) method. The handle MUST have read/write access rights.
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pRule: This parameter represents the firewall rule that the client adds to the store.
	// The rule MUST be a valid rule, as specified in the definition of the FW_RULE2_20
	// data type.
	Rule *fasp.Rule220 `idl:"name:pRule" json:"rule"`
}

func (o *SetFirewallRule220Request) xxx_ToOp(ctx context.Context, op *xxx_SetFirewallRule220Operation) *xxx_SetFirewallRule220Operation {
	if op == nil {
		op = &xxx_SetFirewallRule220Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Rule = o.Rule
	return op
}

func (o *SetFirewallRule220Request) xxx_FromOp(ctx context.Context, op *xxx_SetFirewallRule220Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Rule = op.Rule
}
func (o *SetFirewallRule220Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetFirewallRule220Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetFirewallRule220Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetFirewallRule220Response structure represents the RRPC_FWSetFirewallRule2_20 operation response
type SetFirewallRule220Response struct {
	// pStatus: This output parameter is the status code of the rule as specified by the
	// FW_RULE_STATUS enumeration. This field is filled out on return.
	Status fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	// Return: The RRPC_FWSetFirewallRule2_20 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetFirewallRule220Response) xxx_ToOp(ctx context.Context, op *xxx_SetFirewallRule220Operation) *xxx_SetFirewallRule220Operation {
	if op == nil {
		op = &xxx_SetFirewallRule220Operation{}
	}
	if o == nil {
		return op
	}
	op.Status = o.Status
	op.Return = o.Return
	return op
}

func (o *SetFirewallRule220Response) xxx_FromOp(ctx context.Context, op *xxx_SetFirewallRule220Operation) {
	if o == nil {
		return
	}
	o.Status = op.Status
	o.Return = op.Return
}
func (o *SetFirewallRule220Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetFirewallRule220Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetFirewallRule220Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumFirewallRules220Operation structure represents the RRPC_FWEnumFirewallRules2_20 operation
type xxx_EnumFirewallRules220Operation struct {
	PolicyStore      *PolicyStore  `idl:"name:hPolicyStore" json:"policy_store"`
	FilteredByStatus uint32        `idl:"name:dwFilteredByStatus" json:"filtered_by_status"`
	ProfileFilter    uint32        `idl:"name:dwProfileFilter" json:"profile_filter"`
	Flags            uint16        `idl:"name:wFlags" json:"flags"`
	RulesLength      uint32        `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	Rules            *fasp.Rule220 `idl:"name:ppRules" json:"rules"`
	Return           uint32        `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumFirewallRules220Operation) OpNum() int { return 68 }

func (o *xxx_EnumFirewallRules220Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWEnumFirewallRules2_20"
}

func (o *xxx_EnumFirewallRules220Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFirewallRules220Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwFilteredByStatus {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.FilteredByStatus); err != nil {
			return err
		}
	}
	// dwProfileFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ProfileFilter); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFirewallRules220Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwFilteredByStatus {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.FilteredByStatus); err != nil {
			return err
		}
	}
	// dwProfileFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ProfileFilter); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFirewallRules220Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFirewallRules220Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RulesLength); err != nil {
			return err
		}
	}
	// ppRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_RULE2_20}*(1))(3:{alias=FW_RULE2_20}(struct))
	{
		if o.Rules != nil {
			_ptr_ppRules := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Rules != nil {
					if err := o.Rules.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&fasp.Rule220{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Rules, _ptr_ppRules); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFirewallRules220Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RulesLength); err != nil {
			return err
		}
	}
	// ppRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_RULE2_20,pointer=ref}*(1))(3:{alias=FW_RULE2_20}(struct))
	{
		_ptr_ppRules := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Rules == nil {
				o.Rules = &fasp.Rule220{}
			}
			if err := o.Rules.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ppRules := func(ptr interface{}) { o.Rules = *ptr.(**fasp.Rule220) }
		if err := w.ReadPointer(&o.Rules, _s_ppRules, _ptr_ppRules); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumFirewallRules220Request structure represents the RRPC_FWEnumFirewallRules2_20 operation request
type EnumFirewallRules220Request struct {
	// hPolicyStore: This input parameter is an FW_POLICY_STORE_HANDLE data type. The data
	// type MUST contain an opened policy store handle, successfully opened with the RRPC_FWOpenPolicyStore
	// (Opnum 0) method. The handle MUST have read/write access rights.
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// dwFilteredByStatus: This parameter is a combination of flags from the FW_RULE_STATUS_CLASS
	// enumeration. This method uses this bitmask to determine which rules will be returned.
	// Rules that contain a status code of the specified class that match this parameter
	// will be returned in the linked list.
	FilteredByStatus uint32 `idl:"name:dwFilteredByStatus" json:"filtered_by_status"`
	// dwProfileFilter: This parameter is a combination of flags from the FW_PROFILE_TYPE
	// enumeration. This method also uses this parameter to determine which rules will be
	// returned. Rules that contain a profile specified by this parameter will be returned
	// in the linked list.
	ProfileFilter uint32 `idl:"name:dwProfileFilter" json:"profile_filter"`
	// wFlags: This parameter is a combination of flags from the FW_ENUM_RULES_FLAGS enumeration,
	// which modifies the behavior of the method and performs operations on the rules before
	// returning them in the linked list.
	Flags uint16 `idl:"name:wFlags" json:"flags"`
}

func (o *EnumFirewallRules220Request) xxx_ToOp(ctx context.Context, op *xxx_EnumFirewallRules220Operation) *xxx_EnumFirewallRules220Operation {
	if op == nil {
		op = &xxx_EnumFirewallRules220Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.FilteredByStatus = o.FilteredByStatus
	op.ProfileFilter = o.ProfileFilter
	op.Flags = o.Flags
	return op
}

func (o *EnumFirewallRules220Request) xxx_FromOp(ctx context.Context, op *xxx_EnumFirewallRules220Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.FilteredByStatus = op.FilteredByStatus
	o.ProfileFilter = op.ProfileFilter
	o.Flags = op.Flags
}
func (o *EnumFirewallRules220Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumFirewallRules220Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumFirewallRules220Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumFirewallRules220Response structure represents the RRPC_FWEnumFirewallRules2_20 operation response
type EnumFirewallRules220Response struct {
	// pdwNumRules: This is an output parameter that on success MUST be equal to the number
	// of rules returned.
	RulesLength uint32 `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	// ppRules: This is an output parameter that on success contains a linked list of FW_RULE2_20
	// data types.
	Rules *fasp.Rule220 `idl:"name:ppRules" json:"rules"`
	// Return: The RRPC_FWEnumFirewallRules2_20 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumFirewallRules220Response) xxx_ToOp(ctx context.Context, op *xxx_EnumFirewallRules220Operation) *xxx_EnumFirewallRules220Operation {
	if op == nil {
		op = &xxx_EnumFirewallRules220Operation{}
	}
	if o == nil {
		return op
	}
	op.RulesLength = o.RulesLength
	op.Rules = o.Rules
	op.Return = o.Return
	return op
}

func (o *EnumFirewallRules220Response) xxx_FromOp(ctx context.Context, op *xxx_EnumFirewallRules220Operation) {
	if o == nil {
		return
	}
	o.RulesLength = op.RulesLength
	o.Rules = op.Rules
	o.Return = op.Return
}
func (o *EnumFirewallRules220Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumFirewallRules220Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumFirewallRules220Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_QueryFirewallRules220Operation structure represents the RRPC_FWQueryFirewallRules2_20 operation
type xxx_QueryFirewallRules220Operation struct {
	PolicyStore *PolicyStore  `idl:"name:hPolicyStore" json:"policy_store"`
	Query       *fasp.Query   `idl:"name:pQuery" json:"query"`
	Flags       uint16        `idl:"name:wFlags" json:"flags"`
	RulesLength uint32        `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	Rules       *fasp.Rule220 `idl:"name:ppRules" json:"rules"`
	Return      uint32        `idl:"name:Return" json:"return"`
}

func (o *xxx_QueryFirewallRules220Operation) OpNum() int { return 69 }

func (o *xxx_QueryFirewallRules220Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWQueryFirewallRules2_20"
}

func (o *xxx_QueryFirewallRules220Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryFirewallRules220Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pQuery {in} (1:{alias=PFW_QUERY}*(1))(2:{alias=FW_QUERY}(struct))
	{
		if o.Query != nil {
			if err := o.Query.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.Query{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryFirewallRules220Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pQuery {in} (1:{alias=PFW_QUERY,pointer=ref}*(1))(2:{alias=FW_QUERY}(struct))
	{
		if o.Query == nil {
			o.Query = &fasp.Query{}
		}
		if err := o.Query.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryFirewallRules220Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryFirewallRules220Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RulesLength); err != nil {
			return err
		}
	}
	// ppRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_RULE2_20}*(1))(3:{alias=FW_RULE2_20}(struct))
	{
		if o.Rules != nil {
			_ptr_ppRules := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Rules != nil {
					if err := o.Rules.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&fasp.Rule220{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Rules, _ptr_ppRules); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryFirewallRules220Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RulesLength); err != nil {
			return err
		}
	}
	// ppRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_RULE2_20,pointer=ref}*(1))(3:{alias=FW_RULE2_20}(struct))
	{
		_ptr_ppRules := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Rules == nil {
				o.Rules = &fasp.Rule220{}
			}
			if err := o.Rules.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ppRules := func(ptr interface{}) { o.Rules = *ptr.(**fasp.Rule220) }
		if err := w.ReadPointer(&o.Rules, _s_ppRules, _ptr_ppRules); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// QueryFirewallRules220Request structure represents the RRPC_FWQueryFirewallRules2_20 operation request
type QueryFirewallRules220Request struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pQuery: This parameter represents the query object that the client uses to specify
	// which main mode rules MUST be retrieved from the store. The query object MUST be
	// valid, as specified in the definition of the FW_QUERY data type.
	Query *fasp.Query `idl:"name:pQuery" json:"query"`
	// wFlags: This parameter is a combination of flags from the FW_ENUM_RULES_FLAGS enumeration,
	// which modifies the behavior of the method and performs operations on the rules before
	// returning them in the linked list.
	Flags uint16 `idl:"name:wFlags" json:"flags"`
}

func (o *QueryFirewallRules220Request) xxx_ToOp(ctx context.Context, op *xxx_QueryFirewallRules220Operation) *xxx_QueryFirewallRules220Operation {
	if op == nil {
		op = &xxx_QueryFirewallRules220Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Query = o.Query
	op.Flags = o.Flags
	return op
}

func (o *QueryFirewallRules220Request) xxx_FromOp(ctx context.Context, op *xxx_QueryFirewallRules220Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Query = op.Query
	o.Flags = op.Flags
}
func (o *QueryFirewallRules220Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *QueryFirewallRules220Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryFirewallRules220Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// QueryFirewallRules220Response structure represents the RRPC_FWQueryFirewallRules2_20 operation response
type QueryFirewallRules220Response struct {
	// pdwNumRules: This is an output parameter that on success MUST be equal to the number
	// of rules returned.
	RulesLength uint32 `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	// ppRules: This is an output parameter that on success contains a linked list of FW_RULE2_20
	// data types.
	Rules *fasp.Rule220 `idl:"name:ppRules" json:"rules"`
	// Return: The RRPC_FWQueryFirewallRules2_20 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *QueryFirewallRules220Response) xxx_ToOp(ctx context.Context, op *xxx_QueryFirewallRules220Operation) *xxx_QueryFirewallRules220Operation {
	if op == nil {
		op = &xxx_QueryFirewallRules220Operation{}
	}
	if o == nil {
		return op
	}
	op.RulesLength = o.RulesLength
	op.Rules = o.Rules
	op.Return = o.Return
	return op
}

func (o *QueryFirewallRules220Response) xxx_FromOp(ctx context.Context, op *xxx_QueryFirewallRules220Operation) {
	if o == nil {
		return
	}
	o.RulesLength = op.RulesLength
	o.Rules = op.Rules
	o.Return = op.Return
}
func (o *QueryFirewallRules220Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *QueryFirewallRules220Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryFirewallRules220Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddFirewallRule224Operation structure represents the RRPC_FWAddFirewallRule2_24 operation
type xxx_AddFirewallRule224Operation struct {
	PolicyStore *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	Rule        *fasp.Rule224   `idl:"name:pRule" json:"rule"`
	Status      fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	Return      uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_AddFirewallRule224Operation) OpNum() int { return 70 }

func (o *xxx_AddFirewallRule224Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWAddFirewallRule2_24"
}

func (o *xxx_AddFirewallRule224Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFirewallRule224Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pRule {in} (1:{alias=PFW_RULE2_24}*(1))(2:{alias=FW_RULE2_24}(struct))
	{
		if o.Rule != nil {
			if err := o.Rule.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.Rule224{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFirewallRule224Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pRule {in} (1:{alias=PFW_RULE2_24,pointer=ref}*(1))(2:{alias=FW_RULE2_24}(struct))
	{
		if o.Rule == nil {
			o.Rule = &fasp.Rule224{}
		}
		if err := o.Rule.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFirewallRule224Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFirewallRule224Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.WriteEnum(uint32(o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFirewallRule224Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.ReadEnum((*uint32)(&o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddFirewallRule224Request structure represents the RRPC_FWAddFirewallRule2_24 operation request
type AddFirewallRule224Request struct {
	// hPolicyStore: An input parameter that is an FW_POLICY_STORE_HANDLE data type. This
	// parameter MUST contain an opened policy store handle, successfully opened with the
	// RRPC_FWOpenPolicyStore (Opnum 0) method (section 3.1.4.1). The handle MUST have read/write
	// access rights.
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pRule: Represents the firewall rule that the client adds to the store. The rule MUST
	// be a valid rule, as specified in the definition of the FW_RULE2_24 data type.
	Rule *fasp.Rule224 `idl:"name:pRule" json:"rule"`
}

func (o *AddFirewallRule224Request) xxx_ToOp(ctx context.Context, op *xxx_AddFirewallRule224Operation) *xxx_AddFirewallRule224Operation {
	if op == nil {
		op = &xxx_AddFirewallRule224Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Rule = o.Rule
	return op
}

func (o *AddFirewallRule224Request) xxx_FromOp(ctx context.Context, op *xxx_AddFirewallRule224Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Rule = op.Rule
}
func (o *AddFirewallRule224Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *AddFirewallRule224Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddFirewallRule224Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddFirewallRule224Response structure represents the RRPC_FWAddFirewallRule2_24 operation response
type AddFirewallRule224Response struct {
	// pStatus: An output parameter that is the status code of the rule, as specified by
	// the FW_RULE_STATUS enumeration. This field is filled out on return.
	Status fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	// Return: The RRPC_FWAddFirewallRule2_24 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddFirewallRule224Response) xxx_ToOp(ctx context.Context, op *xxx_AddFirewallRule224Operation) *xxx_AddFirewallRule224Operation {
	if op == nil {
		op = &xxx_AddFirewallRule224Operation{}
	}
	if o == nil {
		return op
	}
	op.Status = o.Status
	op.Return = o.Return
	return op
}

func (o *AddFirewallRule224Response) xxx_FromOp(ctx context.Context, op *xxx_AddFirewallRule224Operation) {
	if o == nil {
		return
	}
	o.Status = op.Status
	o.Return = op.Return
}
func (o *AddFirewallRule224Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *AddFirewallRule224Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddFirewallRule224Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetFirewallRule224Operation structure represents the RRPC_FWSetFirewallRule2_24 operation
type xxx_SetFirewallRule224Operation struct {
	PolicyStore *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	Rule        *fasp.Rule224   `idl:"name:pRule" json:"rule"`
	Status      fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	Return      uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_SetFirewallRule224Operation) OpNum() int { return 71 }

func (o *xxx_SetFirewallRule224Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWSetFirewallRule2_24"
}

func (o *xxx_SetFirewallRule224Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFirewallRule224Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pRule {in} (1:{alias=PFW_RULE2_24}*(1))(2:{alias=FW_RULE2_24}(struct))
	{
		if o.Rule != nil {
			if err := o.Rule.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.Rule224{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFirewallRule224Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pRule {in} (1:{alias=PFW_RULE2_24,pointer=ref}*(1))(2:{alias=FW_RULE2_24}(struct))
	{
		if o.Rule == nil {
			o.Rule = &fasp.Rule224{}
		}
		if err := o.Rule.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFirewallRule224Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFirewallRule224Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.WriteEnum(uint32(o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFirewallRule224Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.ReadEnum((*uint32)(&o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetFirewallRule224Request structure represents the RRPC_FWSetFirewallRule2_24 operation request
type SetFirewallRule224Request struct {
	// hPolicyStore: An input parameter that is an FW_POLICY_STORE_HANDLE data type. This
	// parameter MUST contain an opened policy store handle, successfully opened with the
	// RRPC_FWOpenPolicyStore (Opnum 0) method (section 3.1.4.1). The handle MUST have read/write
	// access rights.
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pRule: Represents the firewall rule that the client modifies in the store. The rule
	// MUST be a valid rule, as specified in the definition of the FW_RULE2_24 data type.
	Rule *fasp.Rule224 `idl:"name:pRule" json:"rule"`
}

func (o *SetFirewallRule224Request) xxx_ToOp(ctx context.Context, op *xxx_SetFirewallRule224Operation) *xxx_SetFirewallRule224Operation {
	if op == nil {
		op = &xxx_SetFirewallRule224Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Rule = o.Rule
	return op
}

func (o *SetFirewallRule224Request) xxx_FromOp(ctx context.Context, op *xxx_SetFirewallRule224Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Rule = op.Rule
}
func (o *SetFirewallRule224Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetFirewallRule224Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetFirewallRule224Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetFirewallRule224Response structure represents the RRPC_FWSetFirewallRule2_24 operation response
type SetFirewallRule224Response struct {
	// pStatus: An output parameter that is the status code of the rule, as specified by
	// the FW_RULE_STATUS enumeration. This field is filled out on return.
	Status fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	// Return: The RRPC_FWSetFirewallRule2_24 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetFirewallRule224Response) xxx_ToOp(ctx context.Context, op *xxx_SetFirewallRule224Operation) *xxx_SetFirewallRule224Operation {
	if op == nil {
		op = &xxx_SetFirewallRule224Operation{}
	}
	if o == nil {
		return op
	}
	op.Status = o.Status
	op.Return = o.Return
	return op
}

func (o *SetFirewallRule224Response) xxx_FromOp(ctx context.Context, op *xxx_SetFirewallRule224Operation) {
	if o == nil {
		return
	}
	o.Status = op.Status
	o.Return = op.Return
}
func (o *SetFirewallRule224Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetFirewallRule224Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetFirewallRule224Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumFirewallRules224Operation structure represents the RRPC_FWEnumFirewallRules2_24 operation
type xxx_EnumFirewallRules224Operation struct {
	PolicyStore      *PolicyStore  `idl:"name:hPolicyStore" json:"policy_store"`
	FilteredByStatus uint32        `idl:"name:dwFilteredByStatus" json:"filtered_by_status"`
	ProfileFilter    uint32        `idl:"name:dwProfileFilter" json:"profile_filter"`
	Flags            uint16        `idl:"name:wFlags" json:"flags"`
	RulesLength      uint32        `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	Rules            *fasp.Rule224 `idl:"name:ppRules" json:"rules"`
	Return           uint32        `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumFirewallRules224Operation) OpNum() int { return 72 }

func (o *xxx_EnumFirewallRules224Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWEnumFirewallRules2_24"
}

func (o *xxx_EnumFirewallRules224Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFirewallRules224Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwFilteredByStatus {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.FilteredByStatus); err != nil {
			return err
		}
	}
	// dwProfileFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ProfileFilter); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFirewallRules224Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwFilteredByStatus {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.FilteredByStatus); err != nil {
			return err
		}
	}
	// dwProfileFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ProfileFilter); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFirewallRules224Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFirewallRules224Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RulesLength); err != nil {
			return err
		}
	}
	// ppRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_RULE2_24}*(1))(3:{alias=FW_RULE2_24}(struct))
	{
		if o.Rules != nil {
			_ptr_ppRules := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Rules != nil {
					if err := o.Rules.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&fasp.Rule224{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Rules, _ptr_ppRules); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFirewallRules224Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RulesLength); err != nil {
			return err
		}
	}
	// ppRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_RULE2_24,pointer=ref}*(1))(3:{alias=FW_RULE2_24}(struct))
	{
		_ptr_ppRules := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Rules == nil {
				o.Rules = &fasp.Rule224{}
			}
			if err := o.Rules.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ppRules := func(ptr interface{}) { o.Rules = *ptr.(**fasp.Rule224) }
		if err := w.ReadPointer(&o.Rules, _s_ppRules, _ptr_ppRules); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumFirewallRules224Request structure represents the RRPC_FWEnumFirewallRules2_24 operation request
type EnumFirewallRules224Request struct {
	// hPolicyStore: An input parameter that is an FW_POLICY_STORE_HANDLE data type. This
	// parameter MUST contain an opened policy store handle, successfully opened with the
	// RRPC_FWOpenPolicyStore (Opnum 0) method (section 3.1.4.1). The handle MUST have read/write
	// access rights.
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// dwFilteredByStatus: A combination of flags from the FW_RULE_STATUS_CLASS enumeration.
	// This method uses this bitmask to determine which rules will be returned. Rules that
	// contain a status code of the specified class that match this parameter will be returned
	// in the linked list.
	FilteredByStatus uint32 `idl:"name:dwFilteredByStatus" json:"filtered_by_status"`
	// dwProfileFilter: A combination of flags from the FW_PROFILE_TYPE enumeration. This
	// method also uses this parameter to determine which rules will be returned. Rules
	// that contain a profile specified by this parameter will be returned in the linked
	// list.
	ProfileFilter uint32 `idl:"name:dwProfileFilter" json:"profile_filter"`
	// wFlags: A combination of flags from the FW_ENUM_RULES_FLAGS enumeration, which modifies
	// the behavior of the method and performs operations on the rules before returning
	// them in the linked list.
	Flags uint16 `idl:"name:wFlags" json:"flags"`
}

func (o *EnumFirewallRules224Request) xxx_ToOp(ctx context.Context, op *xxx_EnumFirewallRules224Operation) *xxx_EnumFirewallRules224Operation {
	if op == nil {
		op = &xxx_EnumFirewallRules224Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.FilteredByStatus = o.FilteredByStatus
	op.ProfileFilter = o.ProfileFilter
	op.Flags = o.Flags
	return op
}

func (o *EnumFirewallRules224Request) xxx_FromOp(ctx context.Context, op *xxx_EnumFirewallRules224Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.FilteredByStatus = op.FilteredByStatus
	o.ProfileFilter = op.ProfileFilter
	o.Flags = op.Flags
}
func (o *EnumFirewallRules224Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumFirewallRules224Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumFirewallRules224Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumFirewallRules224Response structure represents the RRPC_FWEnumFirewallRules2_24 operation response
type EnumFirewallRules224Response struct {
	// pdwNumRules: An output parameter that, on success, MUST be equal to the number of
	// rules returned.
	RulesLength uint32 `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	// ppRules: An output parameter that, on success, contains a linked list of FW_RULE2_24
	// data types.
	Rules *fasp.Rule224 `idl:"name:ppRules" json:"rules"`
	// Return: The RRPC_FWEnumFirewallRules2_24 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumFirewallRules224Response) xxx_ToOp(ctx context.Context, op *xxx_EnumFirewallRules224Operation) *xxx_EnumFirewallRules224Operation {
	if op == nil {
		op = &xxx_EnumFirewallRules224Operation{}
	}
	if o == nil {
		return op
	}
	op.RulesLength = o.RulesLength
	op.Rules = o.Rules
	op.Return = o.Return
	return op
}

func (o *EnumFirewallRules224Response) xxx_FromOp(ctx context.Context, op *xxx_EnumFirewallRules224Operation) {
	if o == nil {
		return
	}
	o.RulesLength = op.RulesLength
	o.Rules = op.Rules
	o.Return = op.Return
}
func (o *EnumFirewallRules224Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumFirewallRules224Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumFirewallRules224Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_QueryFirewallRules224Operation structure represents the RRPC_FWQueryFirewallRules2_24 operation
type xxx_QueryFirewallRules224Operation struct {
	PolicyStore *PolicyStore  `idl:"name:hPolicyStore" json:"policy_store"`
	Query       *fasp.Query   `idl:"name:pQuery" json:"query"`
	Flags       uint16        `idl:"name:wFlags" json:"flags"`
	RulesLength uint32        `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	Rules       *fasp.Rule224 `idl:"name:ppRules" json:"rules"`
	Return      uint32        `idl:"name:Return" json:"return"`
}

func (o *xxx_QueryFirewallRules224Operation) OpNum() int { return 73 }

func (o *xxx_QueryFirewallRules224Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWQueryFirewallRules2_24"
}

func (o *xxx_QueryFirewallRules224Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryFirewallRules224Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pQuery {in} (1:{alias=PFW_QUERY}*(1))(2:{alias=FW_QUERY}(struct))
	{
		if o.Query != nil {
			if err := o.Query.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.Query{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryFirewallRules224Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pQuery {in} (1:{alias=PFW_QUERY,pointer=ref}*(1))(2:{alias=FW_QUERY}(struct))
	{
		if o.Query == nil {
			o.Query = &fasp.Query{}
		}
		if err := o.Query.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryFirewallRules224Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryFirewallRules224Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RulesLength); err != nil {
			return err
		}
	}
	// ppRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_RULE2_24}*(1))(3:{alias=FW_RULE2_24}(struct))
	{
		if o.Rules != nil {
			_ptr_ppRules := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Rules != nil {
					if err := o.Rules.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&fasp.Rule224{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Rules, _ptr_ppRules); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryFirewallRules224Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RulesLength); err != nil {
			return err
		}
	}
	// ppRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_RULE2_24,pointer=ref}*(1))(3:{alias=FW_RULE2_24}(struct))
	{
		_ptr_ppRules := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Rules == nil {
				o.Rules = &fasp.Rule224{}
			}
			if err := o.Rules.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ppRules := func(ptr interface{}) { o.Rules = *ptr.(**fasp.Rule224) }
		if err := w.ReadPointer(&o.Rules, _s_ppRules, _ptr_ppRules); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// QueryFirewallRules224Request structure represents the RRPC_FWQueryFirewallRules2_24 operation request
type QueryFirewallRules224Request struct {
	// hPolicyStore: An input parameter that is an FW_POLICY_STORE_HANDLE data type. The
	// data type MUST contain an opened policy store handle, successfully opened with the
	// RRPC_FWOpenPolicyStore (Opnum 0) method (section 3.1.4.1). The handle MUST be of
	// the FW_STORE_TYPE_DYNAMIC store.
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pQuery: Represents the query object that the client uses to specify which main mode
	// rules MUST be retrieved from the store. The query object MUST be valid, as specified
	// in the definition of the FW_QUERY data type.
	Query *fasp.Query `idl:"name:pQuery" json:"query"`
	// wFlags: A combination of flags from the FW_ENUM_RULES_FLAGS enumeration, which modifies
	// the behavior of the method and performs operations on the rules before returning
	// them in the linked list.
	Flags uint16 `idl:"name:wFlags" json:"flags"`
}

func (o *QueryFirewallRules224Request) xxx_ToOp(ctx context.Context, op *xxx_QueryFirewallRules224Operation) *xxx_QueryFirewallRules224Operation {
	if op == nil {
		op = &xxx_QueryFirewallRules224Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Query = o.Query
	op.Flags = o.Flags
	return op
}

func (o *QueryFirewallRules224Request) xxx_FromOp(ctx context.Context, op *xxx_QueryFirewallRules224Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Query = op.Query
	o.Flags = op.Flags
}
func (o *QueryFirewallRules224Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *QueryFirewallRules224Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryFirewallRules224Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// QueryFirewallRules224Response structure represents the RRPC_FWQueryFirewallRules2_24 operation response
type QueryFirewallRules224Response struct {
	// pdwNumRules: An output parameter that, on success, MUST be equal to the number of
	// rules returned.
	RulesLength uint32 `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	// ppRules: An output parameter that, on success, contains a linked list of FW_RULE2_24_data
	// types.
	Rules *fasp.Rule224 `idl:"name:ppRules" json:"rules"`
	// Return: The RRPC_FWQueryFirewallRules2_24 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *QueryFirewallRules224Response) xxx_ToOp(ctx context.Context, op *xxx_QueryFirewallRules224Operation) *xxx_QueryFirewallRules224Operation {
	if op == nil {
		op = &xxx_QueryFirewallRules224Operation{}
	}
	if o == nil {
		return op
	}
	op.RulesLength = o.RulesLength
	op.Rules = o.Rules
	op.Return = o.Return
	return op
}

func (o *QueryFirewallRules224Response) xxx_FromOp(ctx context.Context, op *xxx_QueryFirewallRules224Operation) {
	if o == nil {
		return
	}
	o.RulesLength = op.RulesLength
	o.Rules = op.Rules
	o.Return = op.Return
}
func (o *QueryFirewallRules224Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *QueryFirewallRules224Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryFirewallRules224Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddFirewallRule225Operation structure represents the RRPC_FWAddFirewallRule2_25 operation
type xxx_AddFirewallRule225Operation struct {
	PolicyStore *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	Rule        *fasp.Rule225   `idl:"name:pRule" json:"rule"`
	Status      fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	Return      uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_AddFirewallRule225Operation) OpNum() int { return 74 }

func (o *xxx_AddFirewallRule225Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWAddFirewallRule2_25"
}

func (o *xxx_AddFirewallRule225Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFirewallRule225Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pRule {in} (1:{alias=PFW_RULE2_25}*(1))(2:{alias=FW_RULE2_25}(struct))
	{
		if o.Rule != nil {
			if err := o.Rule.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.Rule225{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFirewallRule225Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pRule {in} (1:{alias=PFW_RULE2_25,pointer=ref}*(1))(2:{alias=FW_RULE2_25}(struct))
	{
		if o.Rule == nil {
			o.Rule = &fasp.Rule225{}
		}
		if err := o.Rule.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFirewallRule225Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFirewallRule225Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.WriteEnum(uint32(o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFirewallRule225Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.ReadEnum((*uint32)(&o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddFirewallRule225Request structure represents the RRPC_FWAddFirewallRule2_25 operation request
type AddFirewallRule225Request struct {
	// hPolicyStore: An input parameter that is an FW_POLICY_STORE_HANDLE data type. This
	// parameter MUST contain an opened policy store handle, successfully opened with the
	// RRPC_FWOpenPolicyStore (Opnum 0) method (section 3.1.4.1). The handle MUST have read/write
	// access rights.
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pRule: Represents the firewall rule that the client adds to the store. The rule MUST
	// be a valid rule, as specified in the definition of the FW_RULE2_25 data type (section
	// 2.2.105).
	Rule *fasp.Rule225 `idl:"name:pRule" json:"rule"`
}

func (o *AddFirewallRule225Request) xxx_ToOp(ctx context.Context, op *xxx_AddFirewallRule225Operation) *xxx_AddFirewallRule225Operation {
	if op == nil {
		op = &xxx_AddFirewallRule225Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Rule = o.Rule
	return op
}

func (o *AddFirewallRule225Request) xxx_FromOp(ctx context.Context, op *xxx_AddFirewallRule225Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Rule = op.Rule
}
func (o *AddFirewallRule225Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *AddFirewallRule225Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddFirewallRule225Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddFirewallRule225Response structure represents the RRPC_FWAddFirewallRule2_25 operation response
type AddFirewallRule225Response struct {
	// pStatus: An output parameter that is the status code of the rule, as specified by
	// the FW_RULE_STATUS enumeration. This field is filled out on return.
	Status fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	// Return: The RRPC_FWAddFirewallRule2_25 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddFirewallRule225Response) xxx_ToOp(ctx context.Context, op *xxx_AddFirewallRule225Operation) *xxx_AddFirewallRule225Operation {
	if op == nil {
		op = &xxx_AddFirewallRule225Operation{}
	}
	if o == nil {
		return op
	}
	op.Status = o.Status
	op.Return = o.Return
	return op
}

func (o *AddFirewallRule225Response) xxx_FromOp(ctx context.Context, op *xxx_AddFirewallRule225Operation) {
	if o == nil {
		return
	}
	o.Status = op.Status
	o.Return = op.Return
}
func (o *AddFirewallRule225Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *AddFirewallRule225Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddFirewallRule225Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetFirewallRule225Operation structure represents the RRPC_FWSetFirewallRule2_25 operation
type xxx_SetFirewallRule225Operation struct {
	PolicyStore *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	Rule        *fasp.Rule225   `idl:"name:pRule" json:"rule"`
	Status      fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	Return      uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_SetFirewallRule225Operation) OpNum() int { return 75 }

func (o *xxx_SetFirewallRule225Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWSetFirewallRule2_25"
}

func (o *xxx_SetFirewallRule225Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFirewallRule225Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pRule {in} (1:{alias=PFW_RULE2_25}*(1))(2:{alias=FW_RULE2_25}(struct))
	{
		if o.Rule != nil {
			if err := o.Rule.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.Rule225{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFirewallRule225Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pRule {in} (1:{alias=PFW_RULE2_25,pointer=ref}*(1))(2:{alias=FW_RULE2_25}(struct))
	{
		if o.Rule == nil {
			o.Rule = &fasp.Rule225{}
		}
		if err := o.Rule.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFirewallRule225Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFirewallRule225Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.WriteEnum(uint32(o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFirewallRule225Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.ReadEnum((*uint32)(&o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetFirewallRule225Request structure represents the RRPC_FWSetFirewallRule2_25 operation request
type SetFirewallRule225Request struct {
	// hPolicyStore: An input parameter that is an FW_POLICY_STORE_HANDLE data type. This
	// parameter MUST contain an opened policy store handle, successfully opened with the
	// RRPC_FWOpenPolicyStore (Opnum 0) method (section 3.1.4.1). The handle MUST have read/write
	// access rights.
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pRule: Represents the firewall rule that the client modifies in the store. The rule
	// MUST be a valid rule, as specified in the definition of the FW_RULE2_25 data type
	// (section 2.2.105).
	Rule *fasp.Rule225 `idl:"name:pRule" json:"rule"`
}

func (o *SetFirewallRule225Request) xxx_ToOp(ctx context.Context, op *xxx_SetFirewallRule225Operation) *xxx_SetFirewallRule225Operation {
	if op == nil {
		op = &xxx_SetFirewallRule225Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Rule = o.Rule
	return op
}

func (o *SetFirewallRule225Request) xxx_FromOp(ctx context.Context, op *xxx_SetFirewallRule225Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Rule = op.Rule
}
func (o *SetFirewallRule225Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetFirewallRule225Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetFirewallRule225Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetFirewallRule225Response structure represents the RRPC_FWSetFirewallRule2_25 operation response
type SetFirewallRule225Response struct {
	// pStatus: An output parameter that is the status code of the rule, as specified by
	// the FW_RULE_STATUS enumeration. This field is filled out on return.
	Status fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	// Return: The RRPC_FWSetFirewallRule2_25 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetFirewallRule225Response) xxx_ToOp(ctx context.Context, op *xxx_SetFirewallRule225Operation) *xxx_SetFirewallRule225Operation {
	if op == nil {
		op = &xxx_SetFirewallRule225Operation{}
	}
	if o == nil {
		return op
	}
	op.Status = o.Status
	op.Return = o.Return
	return op
}

func (o *SetFirewallRule225Response) xxx_FromOp(ctx context.Context, op *xxx_SetFirewallRule225Operation) {
	if o == nil {
		return
	}
	o.Status = op.Status
	o.Return = op.Return
}
func (o *SetFirewallRule225Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetFirewallRule225Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetFirewallRule225Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumFirewallRules225Operation structure represents the RRPC_FWEnumFirewallRules2_25 operation
type xxx_EnumFirewallRules225Operation struct {
	PolicyStore      *PolicyStore  `idl:"name:hPolicyStore" json:"policy_store"`
	FilteredByStatus uint32        `idl:"name:dwFilteredByStatus" json:"filtered_by_status"`
	ProfileFilter    uint32        `idl:"name:dwProfileFilter" json:"profile_filter"`
	Flags            uint16        `idl:"name:wFlags" json:"flags"`
	RulesLength      uint32        `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	Rules            *fasp.Rule225 `idl:"name:ppRules" json:"rules"`
	Return           uint32        `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumFirewallRules225Operation) OpNum() int { return 76 }

func (o *xxx_EnumFirewallRules225Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWEnumFirewallRules2_25"
}

func (o *xxx_EnumFirewallRules225Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFirewallRules225Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwFilteredByStatus {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.FilteredByStatus); err != nil {
			return err
		}
	}
	// dwProfileFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ProfileFilter); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFirewallRules225Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwFilteredByStatus {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.FilteredByStatus); err != nil {
			return err
		}
	}
	// dwProfileFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ProfileFilter); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFirewallRules225Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFirewallRules225Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RulesLength); err != nil {
			return err
		}
	}
	// ppRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_RULE2_25}*(1))(3:{alias=FW_RULE2_25}(struct))
	{
		if o.Rules != nil {
			_ptr_ppRules := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Rules != nil {
					if err := o.Rules.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&fasp.Rule225{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Rules, _ptr_ppRules); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFirewallRules225Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RulesLength); err != nil {
			return err
		}
	}
	// ppRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_RULE2_25,pointer=ref}*(1))(3:{alias=FW_RULE2_25}(struct))
	{
		_ptr_ppRules := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Rules == nil {
				o.Rules = &fasp.Rule225{}
			}
			if err := o.Rules.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ppRules := func(ptr interface{}) { o.Rules = *ptr.(**fasp.Rule225) }
		if err := w.ReadPointer(&o.Rules, _s_ppRules, _ptr_ppRules); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumFirewallRules225Request structure represents the RRPC_FWEnumFirewallRules2_25 operation request
type EnumFirewallRules225Request struct {
	// hPolicyStore: An input parameter that is an FW_POLICY_STORE_HANDLE data type. This
	// parameter MUST contain an opened policy store handle, successfully opened with the
	// RRPC_FWOpenPolicyStore (Opnum 0) method (section 3.1.4.1). The handle MUST have read/write
	// access rights.
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// dwFilteredByStatus: A combination of flags from the FW_RULE_STATUS_CLASS enumeration.
	// This method uses this bitmask to determine whether rules should be returned. Rules
	// that contain a status code of the specified class that match this parameter will
	// be returned in the linked list.
	FilteredByStatus uint32 `idl:"name:dwFilteredByStatus" json:"filtered_by_status"`
	// dwProfileFilter: A combination of flags from the FW_PROFILE_TYPE enumeration. This
	// method also uses this parameter to determine whether rules should be returned. Rules
	// that contain a profile specified by this parameter will be returned in the linked
	// list.
	ProfileFilter uint32 `idl:"name:dwProfileFilter" json:"profile_filter"`
	// wFlags: A combination of flags from the FW_ENUM_RULES_FLAGS enumeration, which modifies
	// the behavior of the method and performs operations on the rules before returning
	// them in the linked list.
	Flags uint16 `idl:"name:wFlags" json:"flags"`
}

func (o *EnumFirewallRules225Request) xxx_ToOp(ctx context.Context, op *xxx_EnumFirewallRules225Operation) *xxx_EnumFirewallRules225Operation {
	if op == nil {
		op = &xxx_EnumFirewallRules225Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.FilteredByStatus = o.FilteredByStatus
	op.ProfileFilter = o.ProfileFilter
	op.Flags = o.Flags
	return op
}

func (o *EnumFirewallRules225Request) xxx_FromOp(ctx context.Context, op *xxx_EnumFirewallRules225Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.FilteredByStatus = op.FilteredByStatus
	o.ProfileFilter = op.ProfileFilter
	o.Flags = op.Flags
}
func (o *EnumFirewallRules225Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumFirewallRules225Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumFirewallRules225Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumFirewallRules225Response structure represents the RRPC_FWEnumFirewallRules2_25 operation response
type EnumFirewallRules225Response struct {
	// pdwNumRules: An output parameter that, on success, MUST be equal to the number of
	// rules returned.
	RulesLength uint32 `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	// ppRules: An output parameter that, on success, contains a linked list of FW_RULE2_25
	// data types (section 2.2.105).
	Rules *fasp.Rule225 `idl:"name:ppRules" json:"rules"`
	// Return: The RRPC_FWEnumFirewallRules2_25 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumFirewallRules225Response) xxx_ToOp(ctx context.Context, op *xxx_EnumFirewallRules225Operation) *xxx_EnumFirewallRules225Operation {
	if op == nil {
		op = &xxx_EnumFirewallRules225Operation{}
	}
	if o == nil {
		return op
	}
	op.RulesLength = o.RulesLength
	op.Rules = o.Rules
	op.Return = o.Return
	return op
}

func (o *EnumFirewallRules225Response) xxx_FromOp(ctx context.Context, op *xxx_EnumFirewallRules225Operation) {
	if o == nil {
		return
	}
	o.RulesLength = op.RulesLength
	o.Rules = op.Rules
	o.Return = op.Return
}
func (o *EnumFirewallRules225Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumFirewallRules225Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumFirewallRules225Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_QueryFirewallRules225Operation structure represents the RRPC_FWQueryFirewallRules2_25 operation
type xxx_QueryFirewallRules225Operation struct {
	PolicyStore *PolicyStore  `idl:"name:hPolicyStore" json:"policy_store"`
	Query       *fasp.Query   `idl:"name:pQuery" json:"query"`
	Flags       uint16        `idl:"name:wFlags" json:"flags"`
	RulesLength uint32        `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	Rules       *fasp.Rule225 `idl:"name:ppRules" json:"rules"`
	Return      uint32        `idl:"name:Return" json:"return"`
}

func (o *xxx_QueryFirewallRules225Operation) OpNum() int { return 77 }

func (o *xxx_QueryFirewallRules225Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWQueryFirewallRules2_25"
}

func (o *xxx_QueryFirewallRules225Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryFirewallRules225Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pQuery {in} (1:{alias=PFW_QUERY}*(1))(2:{alias=FW_QUERY}(struct))
	{
		if o.Query != nil {
			if err := o.Query.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.Query{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryFirewallRules225Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pQuery {in} (1:{alias=PFW_QUERY,pointer=ref}*(1))(2:{alias=FW_QUERY}(struct))
	{
		if o.Query == nil {
			o.Query = &fasp.Query{}
		}
		if err := o.Query.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryFirewallRules225Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryFirewallRules225Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RulesLength); err != nil {
			return err
		}
	}
	// ppRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_RULE2_25}*(1))(3:{alias=FW_RULE2_25}(struct))
	{
		if o.Rules != nil {
			_ptr_ppRules := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Rules != nil {
					if err := o.Rules.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&fasp.Rule225{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Rules, _ptr_ppRules); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryFirewallRules225Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RulesLength); err != nil {
			return err
		}
	}
	// ppRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_RULE2_25,pointer=ref}*(1))(3:{alias=FW_RULE2_25}(struct))
	{
		_ptr_ppRules := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Rules == nil {
				o.Rules = &fasp.Rule225{}
			}
			if err := o.Rules.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ppRules := func(ptr interface{}) { o.Rules = *ptr.(**fasp.Rule225) }
		if err := w.ReadPointer(&o.Rules, _s_ppRules, _ptr_ppRules); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// QueryFirewallRules225Request structure represents the RRPC_FWQueryFirewallRules2_25 operation request
type QueryFirewallRules225Request struct {
	// hPolicyStore: An input parameter that is an FW_POLICY_STORE_HANDLE data type. This
	// parameter MUST contain an opened policy store handle, successfully opened with the
	// RRPC_FWOpenPolicyStore (Opnum 0) method (section 3.1.4.1). The handle MUST be of
	// the FW_STORE_TYPE_DYNAMIC store (section 2.2.1).
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pQuery: Represents the query object that the client uses to specify which main mode
	// rules MUST be retrieved from the store. The query object MUST be valid, as specified
	// in the definition of the FW_QUERY data type.
	Query *fasp.Query `idl:"name:pQuery" json:"query"`
	// wFlags: A combination of flags from the FW_ENUM_RULES_FLAGS enumeration, which modifies
	// the behavior of the method and performs operations on the rules before returning
	// them in the linked list.
	Flags uint16 `idl:"name:wFlags" json:"flags"`
}

func (o *QueryFirewallRules225Request) xxx_ToOp(ctx context.Context, op *xxx_QueryFirewallRules225Operation) *xxx_QueryFirewallRules225Operation {
	if op == nil {
		op = &xxx_QueryFirewallRules225Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Query = o.Query
	op.Flags = o.Flags
	return op
}

func (o *QueryFirewallRules225Request) xxx_FromOp(ctx context.Context, op *xxx_QueryFirewallRules225Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Query = op.Query
	o.Flags = op.Flags
}
func (o *QueryFirewallRules225Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *QueryFirewallRules225Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryFirewallRules225Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// QueryFirewallRules225Response structure represents the RRPC_FWQueryFirewallRules2_25 operation response
type QueryFirewallRules225Response struct {
	// pdwNumRules: An output parameter that, on success, MUST be equal to the number of
	// rules returned.
	RulesLength uint32 `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	// ppRules: An output parameter that, on success, contains a linked list of FW_RULE2_25
	// data types (section 2.2.105).
	Rules *fasp.Rule225 `idl:"name:ppRules" json:"rules"`
	// Return: The RRPC_FWQueryFirewallRules2_25 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *QueryFirewallRules225Response) xxx_ToOp(ctx context.Context, op *xxx_QueryFirewallRules225Operation) *xxx_QueryFirewallRules225Operation {
	if op == nil {
		op = &xxx_QueryFirewallRules225Operation{}
	}
	if o == nil {
		return op
	}
	op.RulesLength = o.RulesLength
	op.Rules = o.Rules
	op.Return = o.Return
	return op
}

func (o *QueryFirewallRules225Response) xxx_FromOp(ctx context.Context, op *xxx_QueryFirewallRules225Operation) {
	if o == nil {
		return
	}
	o.RulesLength = op.RulesLength
	o.Rules = op.Rules
	o.Return = op.Return
}
func (o *QueryFirewallRules225Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *QueryFirewallRules225Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryFirewallRules225Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddFirewallRule226Operation structure represents the RRPC_FWAddFirewallRule2_26 operation
type xxx_AddFirewallRule226Operation struct {
	PolicyStore *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	Rule        *fasp.Rule226   `idl:"name:pRule" json:"rule"`
	Status      fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	Return      uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_AddFirewallRule226Operation) OpNum() int { return 78 }

func (o *xxx_AddFirewallRule226Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWAddFirewallRule2_26"
}

func (o *xxx_AddFirewallRule226Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFirewallRule226Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pRule {in} (1:{alias=PFW_RULE2_26}*(1))(2:{alias=FW_RULE2_26}(struct))
	{
		if o.Rule != nil {
			if err := o.Rule.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.Rule226{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFirewallRule226Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pRule {in} (1:{alias=PFW_RULE2_26,pointer=ref}*(1))(2:{alias=FW_RULE2_26}(struct))
	{
		if o.Rule == nil {
			o.Rule = &fasp.Rule226{}
		}
		if err := o.Rule.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFirewallRule226Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFirewallRule226Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.WriteEnum(uint32(o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFirewallRule226Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.ReadEnum((*uint32)(&o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddFirewallRule226Request structure represents the RRPC_FWAddFirewallRule2_26 operation request
type AddFirewallRule226Request struct {
	// hPolicyStore: An input parameter that is an FW_POLICY_STORE_HANDLE data type. This
	// parameter MUST contain an opened policy store handle, successfully opened with the
	// RRPC_FWOpenPolicyStore (Opnum 0) method (section 3.1.4.1). The handle MUST have read/write
	// access rights.
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pRule: Represents the firewall rule that the client adds to the store. The rule MUST
	// be a valid rule, as specified in the definition of the FW_RULE2_26 data type.
	Rule *fasp.Rule226 `idl:"name:pRule" json:"rule"`
}

func (o *AddFirewallRule226Request) xxx_ToOp(ctx context.Context, op *xxx_AddFirewallRule226Operation) *xxx_AddFirewallRule226Operation {
	if op == nil {
		op = &xxx_AddFirewallRule226Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Rule = o.Rule
	return op
}

func (o *AddFirewallRule226Request) xxx_FromOp(ctx context.Context, op *xxx_AddFirewallRule226Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Rule = op.Rule
}
func (o *AddFirewallRule226Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *AddFirewallRule226Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddFirewallRule226Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddFirewallRule226Response structure represents the RRPC_FWAddFirewallRule2_26 operation response
type AddFirewallRule226Response struct {
	// pStatus: An output parameter that is the status code of the rule, as specified by
	// the FW_RULE_STATUS enumeration. This field is filled out on return.
	Status fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	// Return: The RRPC_FWAddFirewallRule2_26 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddFirewallRule226Response) xxx_ToOp(ctx context.Context, op *xxx_AddFirewallRule226Operation) *xxx_AddFirewallRule226Operation {
	if op == nil {
		op = &xxx_AddFirewallRule226Operation{}
	}
	if o == nil {
		return op
	}
	op.Status = o.Status
	op.Return = o.Return
	return op
}

func (o *AddFirewallRule226Response) xxx_FromOp(ctx context.Context, op *xxx_AddFirewallRule226Operation) {
	if o == nil {
		return
	}
	o.Status = op.Status
	o.Return = op.Return
}
func (o *AddFirewallRule226Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *AddFirewallRule226Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddFirewallRule226Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetFirewallRule226Operation structure represents the RRPC_FWSetFirewallRule2_26 operation
type xxx_SetFirewallRule226Operation struct {
	PolicyStore *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	Rule        *fasp.Rule226   `idl:"name:pRule" json:"rule"`
	Status      fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	Return      uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_SetFirewallRule226Operation) OpNum() int { return 79 }

func (o *xxx_SetFirewallRule226Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWSetFirewallRule2_26"
}

func (o *xxx_SetFirewallRule226Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFirewallRule226Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pRule {in} (1:{alias=PFW_RULE2_26}*(1))(2:{alias=FW_RULE2_26}(struct))
	{
		if o.Rule != nil {
			if err := o.Rule.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.Rule226{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFirewallRule226Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pRule {in} (1:{alias=PFW_RULE2_26,pointer=ref}*(1))(2:{alias=FW_RULE2_26}(struct))
	{
		if o.Rule == nil {
			o.Rule = &fasp.Rule226{}
		}
		if err := o.Rule.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFirewallRule226Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFirewallRule226Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.WriteEnum(uint32(o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFirewallRule226Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.ReadEnum((*uint32)(&o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetFirewallRule226Request structure represents the RRPC_FWSetFirewallRule2_26 operation request
type SetFirewallRule226Request struct {
	// hPolicyStore: An input parameter that is an FW_POLICY_STORE_HANDLE data type. This
	// parameter MUST contain an opened policy store handle, successfully opened with the
	// RRPC_FWOpenPolicyStore (Opnum 0) method (section 3.1.4.1). The handle MUST have read/write
	// access rights.
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pRule: Represents the firewall rule that the client modifies in the store. The rule
	// MUST be a valid rule, as specified in the definition of the FW_RULE2_26 data type.
	Rule *fasp.Rule226 `idl:"name:pRule" json:"rule"`
}

func (o *SetFirewallRule226Request) xxx_ToOp(ctx context.Context, op *xxx_SetFirewallRule226Operation) *xxx_SetFirewallRule226Operation {
	if op == nil {
		op = &xxx_SetFirewallRule226Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Rule = o.Rule
	return op
}

func (o *SetFirewallRule226Request) xxx_FromOp(ctx context.Context, op *xxx_SetFirewallRule226Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Rule = op.Rule
}
func (o *SetFirewallRule226Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetFirewallRule226Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetFirewallRule226Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetFirewallRule226Response structure represents the RRPC_FWSetFirewallRule2_26 operation response
type SetFirewallRule226Response struct {
	// pStatus: An output parameter that is the status code of the rule, as specified by
	// the FW_RULE_STATUS enumeration. This field is filled out on return.
	Status fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	// Return: The RRPC_FWSetFirewallRule2_26 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetFirewallRule226Response) xxx_ToOp(ctx context.Context, op *xxx_SetFirewallRule226Operation) *xxx_SetFirewallRule226Operation {
	if op == nil {
		op = &xxx_SetFirewallRule226Operation{}
	}
	if o == nil {
		return op
	}
	op.Status = o.Status
	op.Return = o.Return
	return op
}

func (o *SetFirewallRule226Response) xxx_FromOp(ctx context.Context, op *xxx_SetFirewallRule226Operation) {
	if o == nil {
		return
	}
	o.Status = op.Status
	o.Return = op.Return
}
func (o *SetFirewallRule226Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetFirewallRule226Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetFirewallRule226Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumFirewallRules226Operation structure represents the RRPC_FWEnumFirewallRules2_26 operation
type xxx_EnumFirewallRules226Operation struct {
	PolicyStore      *PolicyStore  `idl:"name:hPolicyStore" json:"policy_store"`
	FilteredByStatus uint32        `idl:"name:dwFilteredByStatus" json:"filtered_by_status"`
	ProfileFilter    uint32        `idl:"name:dwProfileFilter" json:"profile_filter"`
	Flags            uint16        `idl:"name:wFlags" json:"flags"`
	RulesLength      uint32        `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	Rules            *fasp.Rule226 `idl:"name:ppRules" json:"rules"`
	Return           uint32        `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumFirewallRules226Operation) OpNum() int { return 80 }

func (o *xxx_EnumFirewallRules226Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWEnumFirewallRules2_26"
}

func (o *xxx_EnumFirewallRules226Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFirewallRules226Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwFilteredByStatus {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.FilteredByStatus); err != nil {
			return err
		}
	}
	// dwProfileFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ProfileFilter); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFirewallRules226Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwFilteredByStatus {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.FilteredByStatus); err != nil {
			return err
		}
	}
	// dwProfileFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ProfileFilter); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFirewallRules226Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFirewallRules226Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RulesLength); err != nil {
			return err
		}
	}
	// ppRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_RULE2_26}*(1))(3:{alias=FW_RULE2_26}(struct))
	{
		if o.Rules != nil {
			_ptr_ppRules := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Rules != nil {
					if err := o.Rules.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&fasp.Rule226{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Rules, _ptr_ppRules); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFirewallRules226Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RulesLength); err != nil {
			return err
		}
	}
	// ppRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_RULE2_26,pointer=ref}*(1))(3:{alias=FW_RULE2_26}(struct))
	{
		_ptr_ppRules := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Rules == nil {
				o.Rules = &fasp.Rule226{}
			}
			if err := o.Rules.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ppRules := func(ptr interface{}) { o.Rules = *ptr.(**fasp.Rule226) }
		if err := w.ReadPointer(&o.Rules, _s_ppRules, _ptr_ppRules); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumFirewallRules226Request structure represents the RRPC_FWEnumFirewallRules2_26 operation request
type EnumFirewallRules226Request struct {
	// hPolicyStore: An input parameter that is an FW_POLICY_STORE_HANDLE data type. This
	// parameter MUST contain an opened policy store handle, successfully opened with the
	// RRPC_FWOpenPolicyStore (Opnum 0) method (section 3.1.4.1). The handle MUST have read/write
	// access rights.
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// dwFilteredByStatus: A combination of flags from the FW_RULE_STATUS_CLASS enumeration.
	// This method uses this bitmask to determine whether rules should be returned. Rules
	// that contain a status code of the specified class that match this parameter will
	// be returned in the linked list.
	FilteredByStatus uint32 `idl:"name:dwFilteredByStatus" json:"filtered_by_status"`
	// dwProfileFilter: A combination of flags from the FW_PROFILE_TYPE enumeration. This
	// method also uses this parameter to determine whether rules should be returned. Rules
	// that contain a profile specified by this parameter will be returned in the linked
	// list.
	ProfileFilter uint32 `idl:"name:dwProfileFilter" json:"profile_filter"`
	// wFlags: A combination of flags from the FW_ENUM_RULES_FLAGS enumeration, which modifies
	// the behavior of the method and performs operations on the rules before returning
	// them in the linked list.
	Flags uint16 `idl:"name:wFlags" json:"flags"`
}

func (o *EnumFirewallRules226Request) xxx_ToOp(ctx context.Context, op *xxx_EnumFirewallRules226Operation) *xxx_EnumFirewallRules226Operation {
	if op == nil {
		op = &xxx_EnumFirewallRules226Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.FilteredByStatus = o.FilteredByStatus
	op.ProfileFilter = o.ProfileFilter
	op.Flags = o.Flags
	return op
}

func (o *EnumFirewallRules226Request) xxx_FromOp(ctx context.Context, op *xxx_EnumFirewallRules226Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.FilteredByStatus = op.FilteredByStatus
	o.ProfileFilter = op.ProfileFilter
	o.Flags = op.Flags
}
func (o *EnumFirewallRules226Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumFirewallRules226Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumFirewallRules226Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumFirewallRules226Response structure represents the RRPC_FWEnumFirewallRules2_26 operation response
type EnumFirewallRules226Response struct {
	// pdwNumRules: An output parameter that, on success, MUST be equal to the number of
	// rules returned.
	RulesLength uint32 `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	// ppRules: An output parameter that, on success, contains a linked list of FW_RULE2_26
	// data types.
	Rules *fasp.Rule226 `idl:"name:ppRules" json:"rules"`
	// Return: The RRPC_FWEnumFirewallRules2_26 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumFirewallRules226Response) xxx_ToOp(ctx context.Context, op *xxx_EnumFirewallRules226Operation) *xxx_EnumFirewallRules226Operation {
	if op == nil {
		op = &xxx_EnumFirewallRules226Operation{}
	}
	if o == nil {
		return op
	}
	op.RulesLength = o.RulesLength
	op.Rules = o.Rules
	op.Return = o.Return
	return op
}

func (o *EnumFirewallRules226Response) xxx_FromOp(ctx context.Context, op *xxx_EnumFirewallRules226Operation) {
	if o == nil {
		return
	}
	o.RulesLength = op.RulesLength
	o.Rules = op.Rules
	o.Return = op.Return
}
func (o *EnumFirewallRules226Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumFirewallRules226Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumFirewallRules226Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_QueryFirewallRules226Operation structure represents the RRPC_FWQueryFirewallRules2_26 operation
type xxx_QueryFirewallRules226Operation struct {
	PolicyStore *PolicyStore  `idl:"name:hPolicyStore" json:"policy_store"`
	Query       *fasp.Query   `idl:"name:pQuery" json:"query"`
	Flags       uint16        `idl:"name:wFlags" json:"flags"`
	RulesLength uint32        `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	Rules       *fasp.Rule226 `idl:"name:ppRules" json:"rules"`
	Return      uint32        `idl:"name:Return" json:"return"`
}

func (o *xxx_QueryFirewallRules226Operation) OpNum() int { return 81 }

func (o *xxx_QueryFirewallRules226Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWQueryFirewallRules2_26"
}

func (o *xxx_QueryFirewallRules226Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryFirewallRules226Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pQuery {in} (1:{alias=PFW_QUERY}*(1))(2:{alias=FW_QUERY}(struct))
	{
		if o.Query != nil {
			if err := o.Query.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.Query{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryFirewallRules226Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pQuery {in} (1:{alias=PFW_QUERY,pointer=ref}*(1))(2:{alias=FW_QUERY}(struct))
	{
		if o.Query == nil {
			o.Query = &fasp.Query{}
		}
		if err := o.Query.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryFirewallRules226Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryFirewallRules226Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RulesLength); err != nil {
			return err
		}
	}
	// ppRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_RULE2_26}*(1))(3:{alias=FW_RULE2_26}(struct))
	{
		if o.Rules != nil {
			_ptr_ppRules := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Rules != nil {
					if err := o.Rules.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&fasp.Rule226{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Rules, _ptr_ppRules); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryFirewallRules226Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RulesLength); err != nil {
			return err
		}
	}
	// ppRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_RULE2_26,pointer=ref}*(1))(3:{alias=FW_RULE2_26}(struct))
	{
		_ptr_ppRules := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Rules == nil {
				o.Rules = &fasp.Rule226{}
			}
			if err := o.Rules.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ppRules := func(ptr interface{}) { o.Rules = *ptr.(**fasp.Rule226) }
		if err := w.ReadPointer(&o.Rules, _s_ppRules, _ptr_ppRules); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// QueryFirewallRules226Request structure represents the RRPC_FWQueryFirewallRules2_26 operation request
type QueryFirewallRules226Request struct {
	// hPolicyStore: An input parameter that is an FW_POLICY_STORE_HANDLE data type. This
	// parameter MUST contain an opened policy store handle, successfully opened with the
	// RRPC_FWOpenPolicyStore (Opnum 0) method (section 3.1.4.1). The handle MUST be of
	// the FW_STORE_TYPE_DYNAMIC store (section 2.2.1).
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pQuery: Represents the query object that the client uses to specify which main mode
	// rules MUST be retrieved from the store. The query object MUST be valid, as specified
	// in the definition of the FW_QUERY data type.
	Query *fasp.Query `idl:"name:pQuery" json:"query"`
	// wFlags: A combination of flags from the FW_ENUM_RULES_FLAGS enumeration, which modifies
	// the behavior of the method and performs operations on the rules before returning
	// them in the linked list.
	Flags uint16 `idl:"name:wFlags" json:"flags"`
}

func (o *QueryFirewallRules226Request) xxx_ToOp(ctx context.Context, op *xxx_QueryFirewallRules226Operation) *xxx_QueryFirewallRules226Operation {
	if op == nil {
		op = &xxx_QueryFirewallRules226Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Query = o.Query
	op.Flags = o.Flags
	return op
}

func (o *QueryFirewallRules226Request) xxx_FromOp(ctx context.Context, op *xxx_QueryFirewallRules226Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Query = op.Query
	o.Flags = op.Flags
}
func (o *QueryFirewallRules226Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *QueryFirewallRules226Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryFirewallRules226Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// QueryFirewallRules226Response structure represents the RRPC_FWQueryFirewallRules2_26 operation response
type QueryFirewallRules226Response struct {
	// pdwNumRules: An output parameter that, on success, MUST be equal to the number of
	// rules returned.
	RulesLength uint32 `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	// ppRules: An output parameter that, on success, contains a linked list of FW_RULE2_26
	// data types.
	Rules *fasp.Rule226 `idl:"name:ppRules" json:"rules"`
	// Return: The RRPC_FWQueryFirewallRules2_26 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *QueryFirewallRules226Response) xxx_ToOp(ctx context.Context, op *xxx_QueryFirewallRules226Operation) *xxx_QueryFirewallRules226Operation {
	if op == nil {
		op = &xxx_QueryFirewallRules226Operation{}
	}
	if o == nil {
		return op
	}
	op.RulesLength = o.RulesLength
	op.Rules = o.Rules
	op.Return = o.Return
	return op
}

func (o *QueryFirewallRules226Response) xxx_FromOp(ctx context.Context, op *xxx_QueryFirewallRules226Operation) {
	if o == nil {
		return
	}
	o.RulesLength = op.RulesLength
	o.Rules = op.Rules
	o.Return = op.Return
}
func (o *QueryFirewallRules226Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *QueryFirewallRules226Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryFirewallRules226Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddFirewallRule227Operation structure represents the RRPC_FWAddFirewallRule2_27 operation
type xxx_AddFirewallRule227Operation struct {
	PolicyStore *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	Rule        *fasp.Rule227   `idl:"name:pRule" json:"rule"`
	Status      fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	Return      uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_AddFirewallRule227Operation) OpNum() int { return 82 }

func (o *xxx_AddFirewallRule227Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWAddFirewallRule2_27"
}

func (o *xxx_AddFirewallRule227Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFirewallRule227Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pRule {in} (1:{alias=PFW_RULE2_27}*(1))(2:{alias=FW_RULE2_27}(struct))
	{
		if o.Rule != nil {
			if err := o.Rule.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.Rule227{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFirewallRule227Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pRule {in} (1:{alias=PFW_RULE2_27,pointer=ref}*(1))(2:{alias=FW_RULE2_27}(struct))
	{
		if o.Rule == nil {
			o.Rule = &fasp.Rule227{}
		}
		if err := o.Rule.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFirewallRule227Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFirewallRule227Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.WriteEnum(uint32(o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFirewallRule227Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.ReadEnum((*uint32)(&o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddFirewallRule227Request structure represents the RRPC_FWAddFirewallRule2_27 operation request
type AddFirewallRule227Request struct {
	// hPolicyStore: An input parameter that is an FW_POLICY_STORE_HANDLE data type (section
	// 2.2.94). This parameter MUST contain an opened policy store handle, successfully
	// opened with the RRPC_FWOpenPolicyStore (Opnum 0) method (section 3.1.4.1). The handle
	// MUST have read/write access rights.
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pRule: Represents the firewall rule that the client adds to the store. The rule MUST
	// be a valid rule, as specified in the definition of the FW_RULE2_27 data type (section
	// 2.2.107).
	Rule *fasp.Rule227 `idl:"name:pRule" json:"rule"`
}

func (o *AddFirewallRule227Request) xxx_ToOp(ctx context.Context, op *xxx_AddFirewallRule227Operation) *xxx_AddFirewallRule227Operation {
	if op == nil {
		op = &xxx_AddFirewallRule227Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Rule = o.Rule
	return op
}

func (o *AddFirewallRule227Request) xxx_FromOp(ctx context.Context, op *xxx_AddFirewallRule227Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Rule = op.Rule
}
func (o *AddFirewallRule227Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *AddFirewallRule227Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddFirewallRule227Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddFirewallRule227Response structure represents the RRPC_FWAddFirewallRule2_27 operation response
type AddFirewallRule227Response struct {
	// pStatus: An output parameter that is the status code of the rule, as specified by
	// the FW_RULE_STATUS enumeration (section 2.2.24). This field is filled out on return.
	Status fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	// Return: The RRPC_FWAddFirewallRule2_27 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddFirewallRule227Response) xxx_ToOp(ctx context.Context, op *xxx_AddFirewallRule227Operation) *xxx_AddFirewallRule227Operation {
	if op == nil {
		op = &xxx_AddFirewallRule227Operation{}
	}
	if o == nil {
		return op
	}
	op.Status = o.Status
	op.Return = o.Return
	return op
}

func (o *AddFirewallRule227Response) xxx_FromOp(ctx context.Context, op *xxx_AddFirewallRule227Operation) {
	if o == nil {
		return
	}
	o.Status = op.Status
	o.Return = op.Return
}
func (o *AddFirewallRule227Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *AddFirewallRule227Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddFirewallRule227Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetFirewallRule227Operation structure represents the RRPC_FWSetFirewallRule2_27 operation
type xxx_SetFirewallRule227Operation struct {
	PolicyStore *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	Rule        *fasp.Rule227   `idl:"name:pRule" json:"rule"`
	Status      fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	Return      uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_SetFirewallRule227Operation) OpNum() int { return 83 }

func (o *xxx_SetFirewallRule227Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWSetFirewallRule2_27"
}

func (o *xxx_SetFirewallRule227Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFirewallRule227Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pRule {in} (1:{alias=PFW_RULE2_27}*(1))(2:{alias=FW_RULE2_27}(struct))
	{
		if o.Rule != nil {
			if err := o.Rule.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.Rule227{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFirewallRule227Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pRule {in} (1:{alias=PFW_RULE2_27,pointer=ref}*(1))(2:{alias=FW_RULE2_27}(struct))
	{
		if o.Rule == nil {
			o.Rule = &fasp.Rule227{}
		}
		if err := o.Rule.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFirewallRule227Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFirewallRule227Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.WriteEnum(uint32(o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFirewallRule227Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.ReadEnum((*uint32)(&o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetFirewallRule227Request structure represents the RRPC_FWSetFirewallRule2_27 operation request
type SetFirewallRule227Request struct {
	// hPolicyStore: An input parameter that is an FW_POLICY_STORE_HANDLE data type (section
	// 2.2.94). This parameter MUST contain an opened policy store handle, successfully
	// opened with the RRPC_FWOpenPolicyStore (Opnum 0) method (section 3.1.4.1). The handle
	// MUST have read/write access rights.
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pRule: Represents the firewall rule that the client modifies in the store. The rule
	// MUST be a valid rule, as specified in the definition of the FW_RULE2_27 data type
	// (section 2.2.107).
	Rule *fasp.Rule227 `idl:"name:pRule" json:"rule"`
}

func (o *SetFirewallRule227Request) xxx_ToOp(ctx context.Context, op *xxx_SetFirewallRule227Operation) *xxx_SetFirewallRule227Operation {
	if op == nil {
		op = &xxx_SetFirewallRule227Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Rule = o.Rule
	return op
}

func (o *SetFirewallRule227Request) xxx_FromOp(ctx context.Context, op *xxx_SetFirewallRule227Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Rule = op.Rule
}
func (o *SetFirewallRule227Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetFirewallRule227Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetFirewallRule227Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetFirewallRule227Response structure represents the RRPC_FWSetFirewallRule2_27 operation response
type SetFirewallRule227Response struct {
	// pStatus: An output parameter that is the status code of the rule, as specified by
	// the FW_RULE_STATUS enumeration (section 2.2.24). This field is filled out on return.
	Status fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	// Return: The RRPC_FWSetFirewallRule2_27 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetFirewallRule227Response) xxx_ToOp(ctx context.Context, op *xxx_SetFirewallRule227Operation) *xxx_SetFirewallRule227Operation {
	if op == nil {
		op = &xxx_SetFirewallRule227Operation{}
	}
	if o == nil {
		return op
	}
	op.Status = o.Status
	op.Return = o.Return
	return op
}

func (o *SetFirewallRule227Response) xxx_FromOp(ctx context.Context, op *xxx_SetFirewallRule227Operation) {
	if o == nil {
		return
	}
	o.Status = op.Status
	o.Return = op.Return
}
func (o *SetFirewallRule227Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetFirewallRule227Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetFirewallRule227Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumFirewallRules227Operation structure represents the RRPC_FWEnumFirewallRules2_27 operation
type xxx_EnumFirewallRules227Operation struct {
	PolicyStore      *PolicyStore  `idl:"name:hPolicyStore" json:"policy_store"`
	FilteredByStatus uint32        `idl:"name:dwFilteredByStatus" json:"filtered_by_status"`
	ProfileFilter    uint32        `idl:"name:dwProfileFilter" json:"profile_filter"`
	Flags            uint16        `idl:"name:wFlags" json:"flags"`
	RulesLength      uint32        `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	Rules            *fasp.Rule227 `idl:"name:ppRules" json:"rules"`
	Return           uint32        `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumFirewallRules227Operation) OpNum() int { return 84 }

func (o *xxx_EnumFirewallRules227Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWEnumFirewallRules2_27"
}

func (o *xxx_EnumFirewallRules227Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFirewallRules227Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwFilteredByStatus {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.FilteredByStatus); err != nil {
			return err
		}
	}
	// dwProfileFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ProfileFilter); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFirewallRules227Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwFilteredByStatus {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.FilteredByStatus); err != nil {
			return err
		}
	}
	// dwProfileFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ProfileFilter); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFirewallRules227Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFirewallRules227Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RulesLength); err != nil {
			return err
		}
	}
	// ppRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_RULE2_27}*(1))(3:{alias=FW_RULE2_27}(struct))
	{
		if o.Rules != nil {
			_ptr_ppRules := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Rules != nil {
					if err := o.Rules.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&fasp.Rule227{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Rules, _ptr_ppRules); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFirewallRules227Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RulesLength); err != nil {
			return err
		}
	}
	// ppRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_RULE2_27,pointer=ref}*(1))(3:{alias=FW_RULE2_27}(struct))
	{
		_ptr_ppRules := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Rules == nil {
				o.Rules = &fasp.Rule227{}
			}
			if err := o.Rules.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ppRules := func(ptr interface{}) { o.Rules = *ptr.(**fasp.Rule227) }
		if err := w.ReadPointer(&o.Rules, _s_ppRules, _ptr_ppRules); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumFirewallRules227Request structure represents the RRPC_FWEnumFirewallRules2_27 operation request
type EnumFirewallRules227Request struct {
	// hPolicyStore: An input parameter that is an FW_POLICY_STORE_HANDLE data type (section
	// 2.2.94). This parameter MUST contain an opened policy store handle, successfully
	// opened with the RRPC_FWOpenPolicyStore (Opnum 0) method (section 3.1.4.1). The handle
	// MUST have read/write access rights.
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// dwFilteredByStatus: A combination of flags from the FW_RULE_STATUS_CLASS enumeration
	// (section 2.2.25). This method uses this bitmask to determine whether rules should
	// be returned. Rules that contain a status code of the specified class that match this
	// parameter will be returned in the linked list.
	FilteredByStatus uint32 `idl:"name:dwFilteredByStatus" json:"filtered_by_status"`
	// dwProfileFilter: A combination of flags from the FW_PROFILE_TYPE enumeration (section
	// 2.2.2). This method also uses this parameter to determine whether rules should be
	// returned. Rules that contain a profile specified by this parameter will be returned
	// in the linked list.
	ProfileFilter uint32 `idl:"name:dwProfileFilter" json:"profile_filter"`
	// wFlags: A combination of flags from the FW_ENUM_RULES_FLAGS enumeration (section
	// 2.2.33), which modifies the behavior of the method and performs operations on the
	// rules before returning them in the linked list.
	Flags uint16 `idl:"name:wFlags" json:"flags"`
}

func (o *EnumFirewallRules227Request) xxx_ToOp(ctx context.Context, op *xxx_EnumFirewallRules227Operation) *xxx_EnumFirewallRules227Operation {
	if op == nil {
		op = &xxx_EnumFirewallRules227Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.FilteredByStatus = o.FilteredByStatus
	op.ProfileFilter = o.ProfileFilter
	op.Flags = o.Flags
	return op
}

func (o *EnumFirewallRules227Request) xxx_FromOp(ctx context.Context, op *xxx_EnumFirewallRules227Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.FilteredByStatus = op.FilteredByStatus
	o.ProfileFilter = op.ProfileFilter
	o.Flags = op.Flags
}
func (o *EnumFirewallRules227Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumFirewallRules227Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumFirewallRules227Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumFirewallRules227Response structure represents the RRPC_FWEnumFirewallRules2_27 operation response
type EnumFirewallRules227Response struct {
	// pdwNumRules: An output parameter that, on success, MUST be equal to the number of
	// rules returned.
	RulesLength uint32 `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	// ppRules: An output parameter that, on success, contains a linked list of FW_RULE2_27
	// data types (section 2.2.107).
	Rules *fasp.Rule227 `idl:"name:ppRules" json:"rules"`
	// Return: The RRPC_FWEnumFirewallRules2_27 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumFirewallRules227Response) xxx_ToOp(ctx context.Context, op *xxx_EnumFirewallRules227Operation) *xxx_EnumFirewallRules227Operation {
	if op == nil {
		op = &xxx_EnumFirewallRules227Operation{}
	}
	if o == nil {
		return op
	}
	op.RulesLength = o.RulesLength
	op.Rules = o.Rules
	op.Return = o.Return
	return op
}

func (o *EnumFirewallRules227Response) xxx_FromOp(ctx context.Context, op *xxx_EnumFirewallRules227Operation) {
	if o == nil {
		return
	}
	o.RulesLength = op.RulesLength
	o.Rules = op.Rules
	o.Return = op.Return
}
func (o *EnumFirewallRules227Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumFirewallRules227Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumFirewallRules227Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_QueryFirewallRules227Operation structure represents the RRPC_FWQueryFirewallRules2_27 operation
type xxx_QueryFirewallRules227Operation struct {
	PolicyStore *PolicyStore  `idl:"name:hPolicyStore" json:"policy_store"`
	Query       *fasp.Query   `idl:"name:pQuery" json:"query"`
	Flags       uint16        `idl:"name:wFlags" json:"flags"`
	RulesLength uint32        `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	Rules       *fasp.Rule227 `idl:"name:ppRules" json:"rules"`
	Return      uint32        `idl:"name:Return" json:"return"`
}

func (o *xxx_QueryFirewallRules227Operation) OpNum() int { return 85 }

func (o *xxx_QueryFirewallRules227Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWQueryFirewallRules2_27"
}

func (o *xxx_QueryFirewallRules227Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryFirewallRules227Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pQuery {in} (1:{alias=PFW_QUERY}*(1))(2:{alias=FW_QUERY}(struct))
	{
		if o.Query != nil {
			if err := o.Query.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.Query{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryFirewallRules227Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pQuery {in} (1:{alias=PFW_QUERY,pointer=ref}*(1))(2:{alias=FW_QUERY}(struct))
	{
		if o.Query == nil {
			o.Query = &fasp.Query{}
		}
		if err := o.Query.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryFirewallRules227Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryFirewallRules227Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RulesLength); err != nil {
			return err
		}
	}
	// ppRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_RULE2_27}*(1))(3:{alias=FW_RULE2_27}(struct))
	{
		if o.Rules != nil {
			_ptr_ppRules := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Rules != nil {
					if err := o.Rules.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&fasp.Rule227{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Rules, _ptr_ppRules); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryFirewallRules227Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RulesLength); err != nil {
			return err
		}
	}
	// ppRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_RULE2_27,pointer=ref}*(1))(3:{alias=FW_RULE2_27}(struct))
	{
		_ptr_ppRules := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Rules == nil {
				o.Rules = &fasp.Rule227{}
			}
			if err := o.Rules.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ppRules := func(ptr interface{}) { o.Rules = *ptr.(**fasp.Rule227) }
		if err := w.ReadPointer(&o.Rules, _s_ppRules, _ptr_ppRules); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// QueryFirewallRules227Request structure represents the RRPC_FWQueryFirewallRules2_27 operation request
type QueryFirewallRules227Request struct {
	// hPolicyStore: An input parameter that is an FW_POLICY_STORE_HANDLE data type (section
	// 2.2.94). This parameter MUST contain an opened policy store handle, successfully
	// opened with the RRPC_FWOpenPolicyStore (Opnum 0) method (section 3.1.4.1). The handle
	// MUST be the FW_STORE_TYPE_DYNAMIC policy store type (section 2.2.1).
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pQuery: Represents the query object that the client uses to specify which main mode
	// rules MUST be retrieved from the store. The query object MUST be valid, as specified
	// in the definition of the FW_QUERY data type (section 2.2.93).
	Query *fasp.Query `idl:"name:pQuery" json:"query"`
	// wFlags: A combination of flags from the FW_ENUM_RULES_FLAGS enumeration (section
	// 2.2.33), which modifies the behavior of the method and performs operations on the
	// rules before returning them in the linked list.
	Flags uint16 `idl:"name:wFlags" json:"flags"`
}

func (o *QueryFirewallRules227Request) xxx_ToOp(ctx context.Context, op *xxx_QueryFirewallRules227Operation) *xxx_QueryFirewallRules227Operation {
	if op == nil {
		op = &xxx_QueryFirewallRules227Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Query = o.Query
	op.Flags = o.Flags
	return op
}

func (o *QueryFirewallRules227Request) xxx_FromOp(ctx context.Context, op *xxx_QueryFirewallRules227Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Query = op.Query
	o.Flags = op.Flags
}
func (o *QueryFirewallRules227Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *QueryFirewallRules227Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryFirewallRules227Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// QueryFirewallRules227Response structure represents the RRPC_FWQueryFirewallRules2_27 operation response
type QueryFirewallRules227Response struct {
	// pdwNumRules: An output parameter that, on success, MUST be equal to the number of
	// rules returned.
	RulesLength uint32 `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	// ppRules: An output parameter that, on success, contains a linked list of FW_RULE2_27
	// data types (section 2.2.107).
	Rules *fasp.Rule227 `idl:"name:ppRules" json:"rules"`
	// Return: The RRPC_FWQueryFirewallRules2_27 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *QueryFirewallRules227Response) xxx_ToOp(ctx context.Context, op *xxx_QueryFirewallRules227Operation) *xxx_QueryFirewallRules227Operation {
	if op == nil {
		op = &xxx_QueryFirewallRules227Operation{}
	}
	if o == nil {
		return op
	}
	op.RulesLength = o.RulesLength
	op.Rules = o.Rules
	op.Return = o.Return
	return op
}

func (o *QueryFirewallRules227Response) xxx_FromOp(ctx context.Context, op *xxx_QueryFirewallRules227Operation) {
	if o == nil {
		return
	}
	o.RulesLength = op.RulesLength
	o.Rules = op.Rules
	o.Return = op.Return
}
func (o *QueryFirewallRules227Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *QueryFirewallRules227Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryFirewallRules227Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddFirewallRule231Operation structure represents the RRPC_FWAddFirewallRule2_31 operation
type xxx_AddFirewallRule231Operation struct {
	PolicyStore *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	Rule        *fasp.Rule      `idl:"name:pRule" json:"rule"`
	Status      fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	Return      uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_AddFirewallRule231Operation) OpNum() int { return 86 }

func (o *xxx_AddFirewallRule231Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWAddFirewallRule2_31"
}

func (o *xxx_AddFirewallRule231Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFirewallRule231Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pRule {in} (1:{alias=PFW_RULE}*(1))(2:{alias=FW_RULE}(struct))
	{
		if o.Rule != nil {
			if err := o.Rule.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.Rule{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFirewallRule231Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pRule {in} (1:{alias=PFW_RULE,pointer=ref}*(1))(2:{alias=FW_RULE}(struct))
	{
		if o.Rule == nil {
			o.Rule = &fasp.Rule{}
		}
		if err := o.Rule.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFirewallRule231Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFirewallRule231Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.WriteEnum(uint32(o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddFirewallRule231Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.ReadEnum((*uint32)(&o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddFirewallRule231Request structure represents the RRPC_FWAddFirewallRule2_31 operation request
type AddFirewallRule231Request struct {
	// hPolicyStore: An input parameter that is an FW_POLICY_STORE_HANDLE data type (section
	// 2.2.94). This parameter MUST contain an opened policy store handle, successfully
	// opened with the RRPC_FWOpenPolicyStore (Opnum 0) method (section 3.1.4.1). The handle
	// MUST have read/write access rights.
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pRule: Represents the firewall rule that the client requests to add to the store.
	// The rule MUST be a valid rule, as specified in the definition of the FW_RULE data
	// type (section 2.2.37).
	Rule *fasp.Rule `idl:"name:pRule" json:"rule"`
}

func (o *AddFirewallRule231Request) xxx_ToOp(ctx context.Context, op *xxx_AddFirewallRule231Operation) *xxx_AddFirewallRule231Operation {
	if op == nil {
		op = &xxx_AddFirewallRule231Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Rule = o.Rule
	return op
}

func (o *AddFirewallRule231Request) xxx_FromOp(ctx context.Context, op *xxx_AddFirewallRule231Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Rule = op.Rule
}
func (o *AddFirewallRule231Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *AddFirewallRule231Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddFirewallRule231Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddFirewallRule231Response structure represents the RRPC_FWAddFirewallRule2_31 operation response
type AddFirewallRule231Response struct {
	// pStatus: An output parameter that is the status code of the rule, as specified by
	// the FW_RULE_STATUS enumeration (section 2.2.24)..
	Status fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	// Return: The RRPC_FWAddFirewallRule2_31 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddFirewallRule231Response) xxx_ToOp(ctx context.Context, op *xxx_AddFirewallRule231Operation) *xxx_AddFirewallRule231Operation {
	if op == nil {
		op = &xxx_AddFirewallRule231Operation{}
	}
	if o == nil {
		return op
	}
	op.Status = o.Status
	op.Return = o.Return
	return op
}

func (o *AddFirewallRule231Response) xxx_FromOp(ctx context.Context, op *xxx_AddFirewallRule231Operation) {
	if o == nil {
		return
	}
	o.Status = op.Status
	o.Return = op.Return
}
func (o *AddFirewallRule231Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *AddFirewallRule231Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddFirewallRule231Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetFirewallRule231Operation structure represents the RRPC_FWSetFirewallRule2_31 operation
type xxx_SetFirewallRule231Operation struct {
	PolicyStore *PolicyStore    `idl:"name:hPolicyStore" json:"policy_store"`
	Rule        *fasp.Rule      `idl:"name:pRule" json:"rule"`
	Status      fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	Return      uint32          `idl:"name:Return" json:"return"`
}

func (o *xxx_SetFirewallRule231Operation) OpNum() int { return 87 }

func (o *xxx_SetFirewallRule231Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWSetFirewallRule2_31"
}

func (o *xxx_SetFirewallRule231Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFirewallRule231Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pRule {in} (1:{alias=PFW_RULE}*(1))(2:{alias=FW_RULE}(struct))
	{
		if o.Rule != nil {
			if err := o.Rule.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.Rule{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFirewallRule231Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pRule {in} (1:{alias=PFW_RULE,pointer=ref}*(1))(2:{alias=FW_RULE}(struct))
	{
		if o.Rule == nil {
			o.Rule = &fasp.Rule{}
		}
		if err := o.Rule.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFirewallRule231Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFirewallRule231Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.WriteEnum(uint32(o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetFirewallRule231Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pStatus {out} (1:{pointer=ref}*(1))(2:{v1_enum, alias=FW_RULE_STATUS}(enum))
	{
		if err := w.ReadEnum((*uint32)(&o.Status)); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetFirewallRule231Request structure represents the RRPC_FWSetFirewallRule2_31 operation request
type SetFirewallRule231Request struct {
	// hPolicyStore: An input parameter that is an FW_POLICY_STORE_HANDLE data type (section
	// 2.2.94). This parameter MUST contain an opened policy store handle, successfully
	// opened with the RRPC_FWOpenPolicyStore (Opnum 0) method (section 3.1.4.1). The handle
	// MUST have read/write access rights.
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pRule: Represents the firewall rule that the client requests to have modified in
	// the store. The rule MUST be a valid rule, as specified in the definition of the FW_RULE
	// data type (section 2.2.37).
	Rule *fasp.Rule `idl:"name:pRule" json:"rule"`
}

func (o *SetFirewallRule231Request) xxx_ToOp(ctx context.Context, op *xxx_SetFirewallRule231Operation) *xxx_SetFirewallRule231Operation {
	if op == nil {
		op = &xxx_SetFirewallRule231Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Rule = o.Rule
	return op
}

func (o *SetFirewallRule231Request) xxx_FromOp(ctx context.Context, op *xxx_SetFirewallRule231Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Rule = op.Rule
}
func (o *SetFirewallRule231Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetFirewallRule231Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetFirewallRule231Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetFirewallRule231Response structure represents the RRPC_FWSetFirewallRule2_31 operation response
type SetFirewallRule231Response struct {
	// pStatus: An output parameter that is the status code of the rule, as specified by
	// the FW_RULE_STATUS enumeration (section 2.2.24).
	Status fasp.RuleStatus `idl:"name:pStatus" json:"status"`
	// Return: The RRPC_FWSetFirewallRule2_31 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SetFirewallRule231Response) xxx_ToOp(ctx context.Context, op *xxx_SetFirewallRule231Operation) *xxx_SetFirewallRule231Operation {
	if op == nil {
		op = &xxx_SetFirewallRule231Operation{}
	}
	if o == nil {
		return op
	}
	op.Status = o.Status
	op.Return = o.Return
	return op
}

func (o *SetFirewallRule231Response) xxx_FromOp(ctx context.Context, op *xxx_SetFirewallRule231Operation) {
	if o == nil {
		return
	}
	o.Status = op.Status
	o.Return = op.Return
}
func (o *SetFirewallRule231Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetFirewallRule231Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetFirewallRule231Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumFirewallRules231Operation structure represents the RRPC_FWEnumFirewallRules2_31 operation
type xxx_EnumFirewallRules231Operation struct {
	PolicyStore      *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	FilteredByStatus uint32       `idl:"name:dwFilteredByStatus" json:"filtered_by_status"`
	ProfileFilter    uint32       `idl:"name:dwProfileFilter" json:"profile_filter"`
	Flags            uint16       `idl:"name:wFlags" json:"flags"`
	RulesLength      uint32       `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	Rules            *fasp.Rule   `idl:"name:ppRules" json:"rules"`
	Return           uint32       `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumFirewallRules231Operation) OpNum() int { return 88 }

func (o *xxx_EnumFirewallRules231Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWEnumFirewallRules2_31"
}

func (o *xxx_EnumFirewallRules231Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFirewallRules231Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwFilteredByStatus {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.FilteredByStatus); err != nil {
			return err
		}
	}
	// dwProfileFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ProfileFilter); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFirewallRules231Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwFilteredByStatus {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.FilteredByStatus); err != nil {
			return err
		}
	}
	// dwProfileFilter {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ProfileFilter); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFirewallRules231Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFirewallRules231Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RulesLength); err != nil {
			return err
		}
	}
	// ppRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_RULE}*(1))(3:{alias=FW_RULE}(struct))
	{
		if o.Rules != nil {
			_ptr_ppRules := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Rules != nil {
					if err := o.Rules.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&fasp.Rule{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Rules, _ptr_ppRules); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumFirewallRules231Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RulesLength); err != nil {
			return err
		}
	}
	// ppRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_RULE,pointer=ref}*(1))(3:{alias=FW_RULE}(struct))
	{
		_ptr_ppRules := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Rules == nil {
				o.Rules = &fasp.Rule{}
			}
			if err := o.Rules.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ppRules := func(ptr interface{}) { o.Rules = *ptr.(**fasp.Rule) }
		if err := w.ReadPointer(&o.Rules, _s_ppRules, _ptr_ppRules); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumFirewallRules231Request structure represents the RRPC_FWEnumFirewallRules2_31 operation request
type EnumFirewallRules231Request struct {
	// hPolicyStore: An input parameter that is an FW_POLICY_STORE_HANDLE data type (section
	// 2.2.94). This parameter MUST contain an opened policy store handle, successfully
	// opened with the RRPC_FWOpenPolicyStore (Opnum 0) method (section 3.1.4.1). The handle
	// MUST have read/write access rights.
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// dwFilteredByStatus: A combination of flags from the FW_RULE_STATUS_CLASS enumeration
	// (section 2.2.25). This method uses this bitmask to determine whether rules should
	// be returned. Rules that contain a status code of the specified class that match this
	// parameter will be returned in the linked list.
	FilteredByStatus uint32 `idl:"name:dwFilteredByStatus" json:"filtered_by_status"`
	// dwProfileFilter: A combination of flags from the FW_PROFILE_TYPE enumeration (section
	// 2.2.2). This method also uses this parameter to determine whether rules should be
	// returned. Rules that contain a profile specified by this parameter will be returned
	// in the linked list.
	ProfileFilter uint32 `idl:"name:dwProfileFilter" json:"profile_filter"`
	// wFlags: A combination of flags from the FW_ENUM_RULES_FLAGS enumeration (section
	// 2.2.33), which modifies the behavior of the method and performs operations on the
	// rules before returning them in the linked list.
	Flags uint16 `idl:"name:wFlags" json:"flags"`
}

func (o *EnumFirewallRules231Request) xxx_ToOp(ctx context.Context, op *xxx_EnumFirewallRules231Operation) *xxx_EnumFirewallRules231Operation {
	if op == nil {
		op = &xxx_EnumFirewallRules231Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.FilteredByStatus = o.FilteredByStatus
	op.ProfileFilter = o.ProfileFilter
	op.Flags = o.Flags
	return op
}

func (o *EnumFirewallRules231Request) xxx_FromOp(ctx context.Context, op *xxx_EnumFirewallRules231Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.FilteredByStatus = op.FilteredByStatus
	o.ProfileFilter = op.ProfileFilter
	o.Flags = op.Flags
}
func (o *EnumFirewallRules231Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumFirewallRules231Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumFirewallRules231Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumFirewallRules231Response structure represents the RRPC_FWEnumFirewallRules2_31 operation response
type EnumFirewallRules231Response struct {
	// pdwNumRules: An output parameter that on success MUST be equal to the number of rules
	// returned.
	RulesLength uint32 `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	// ppRules: An output parameter that on success contains a linked list of FW_RULE data
	// types (section 2.2.37).
	Rules *fasp.Rule `idl:"name:ppRules" json:"rules"`
	// Return: The RRPC_FWEnumFirewallRules2_31 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumFirewallRules231Response) xxx_ToOp(ctx context.Context, op *xxx_EnumFirewallRules231Operation) *xxx_EnumFirewallRules231Operation {
	if op == nil {
		op = &xxx_EnumFirewallRules231Operation{}
	}
	if o == nil {
		return op
	}
	op.RulesLength = o.RulesLength
	op.Rules = o.Rules
	op.Return = o.Return
	return op
}

func (o *EnumFirewallRules231Response) xxx_FromOp(ctx context.Context, op *xxx_EnumFirewallRules231Operation) {
	if o == nil {
		return
	}
	o.RulesLength = op.RulesLength
	o.Rules = op.Rules
	o.Return = op.Return
}
func (o *EnumFirewallRules231Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumFirewallRules231Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumFirewallRules231Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_QueryFirewallRules231Operation structure represents the RRPC_FWQueryFirewallRules2_31 operation
type xxx_QueryFirewallRules231Operation struct {
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	Query       *fasp.Query  `idl:"name:pQuery" json:"query"`
	Flags       uint16       `idl:"name:wFlags" json:"flags"`
	RulesLength uint32       `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	Rules       *fasp.Rule   `idl:"name:ppRules" json:"rules"`
	Return      uint32       `idl:"name:Return" json:"return"`
}

func (o *xxx_QueryFirewallRules231Operation) OpNum() int { return 89 }

func (o *xxx_QueryFirewallRules231Operation) OpName() string {
	return "/RemoteFW/v1/RRPC_FWQueryFirewallRules2_31"
}

func (o *xxx_QueryFirewallRules231Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryFirewallRules231Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore != nil {
			if err := o.PolicyStore.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&PolicyStore{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pQuery {in} (1:{alias=PFW_QUERY}*(1))(2:{alias=FW_QUERY}(struct))
	{
		if o.Query != nil {
			if err := o.Query.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&fasp.Query{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryFirewallRules231Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// hPolicyStore {in} (1:{context_handle, alias=FW_POLICY_STORE_HANDLE, names=ndr_context_handle}(struct))
	{
		if o.PolicyStore == nil {
			o.PolicyStore = &PolicyStore{}
		}
		if err := o.PolicyStore.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pQuery {in} (1:{alias=PFW_QUERY,pointer=ref}*(1))(2:{alias=FW_QUERY}(struct))
	{
		if o.Query == nil {
			o.Query = &fasp.Query{}
		}
		if err := o.Query.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// wFlags {in} (1:{alias=WORD}(uint16))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryFirewallRules231Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryFirewallRules231Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.RulesLength); err != nil {
			return err
		}
	}
	// ppRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_RULE}*(1))(3:{alias=FW_RULE}(struct))
	{
		if o.Rules != nil {
			_ptr_ppRules := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Rules != nil {
					if err := o.Rules.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&fasp.Rule{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Rules, _ptr_ppRules); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_QueryFirewallRules231Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// pdwNumRules {out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.RulesLength); err != nil {
			return err
		}
	}
	// ppRules {out} (1:{pointer=ref}*(2))(2:{alias=PFW_RULE,pointer=ref}*(1))(3:{alias=FW_RULE}(struct))
	{
		_ptr_ppRules := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Rules == nil {
				o.Rules = &fasp.Rule{}
			}
			if err := o.Rules.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ppRules := func(ptr interface{}) { o.Rules = *ptr.(**fasp.Rule) }
		if err := w.ReadPointer(&o.Rules, _s_ppRules, _ptr_ppRules); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// QueryFirewallRules231Request structure represents the RRPC_FWQueryFirewallRules2_31 operation request
type QueryFirewallRules231Request struct {
	// hPolicyStore: An input parameter that is an FW_POLICY_STORE_HANDLE data type (section
	// 2.2.94). This parameter MUST contain an opened policy store handle, successfully
	// opened with the RRPC_FWOpenPolicyStore (Opnum 0) method (section 3.1.4.1). The handle
	// MUST be the FW_STORE_TYPE_DYNAMIC policy store type (section 2.2.1).
	PolicyStore *PolicyStore `idl:"name:hPolicyStore" json:"policy_store"`
	// pQuery: Represents the query object that the client uses to specify which main mode
	// rules MUST be retrieved from the store. The query object MUST be valid, as specified
	// in the definition of the FW_QUERY data type (section 2.2.93).
	Query *fasp.Query `idl:"name:pQuery" json:"query"`
	// wFlags: A combination of flags from the FW_ENUM_RULES_FLAGS enumeration (section
	// 2.2.33), which modifies the behavior of the method and performs operations on the
	// rules before returning them in the linked list.
	Flags uint16 `idl:"name:wFlags" json:"flags"`
}

func (o *QueryFirewallRules231Request) xxx_ToOp(ctx context.Context, op *xxx_QueryFirewallRules231Operation) *xxx_QueryFirewallRules231Operation {
	if op == nil {
		op = &xxx_QueryFirewallRules231Operation{}
	}
	if o == nil {
		return op
	}
	op.PolicyStore = o.PolicyStore
	op.Query = o.Query
	op.Flags = o.Flags
	return op
}

func (o *QueryFirewallRules231Request) xxx_FromOp(ctx context.Context, op *xxx_QueryFirewallRules231Operation) {
	if o == nil {
		return
	}
	o.PolicyStore = op.PolicyStore
	o.Query = op.Query
	o.Flags = op.Flags
}
func (o *QueryFirewallRules231Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *QueryFirewallRules231Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryFirewallRules231Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// QueryFirewallRules231Response structure represents the RRPC_FWQueryFirewallRules2_31 operation response
type QueryFirewallRules231Response struct {
	// pdwNumRules: An output parameter that, on success, MUST be equal to the number of
	// rules returned.
	RulesLength uint32 `idl:"name:pdwNumRules;pointer:ref" json:"rules_length"`
	// ppRules: An output parameter that, on success, contains a linked list of FW_RULE
	// data types (section 2.2.37).
	Rules *fasp.Rule `idl:"name:ppRules" json:"rules"`
	// Return: The RRPC_FWQueryFirewallRules2_31 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *QueryFirewallRules231Response) xxx_ToOp(ctx context.Context, op *xxx_QueryFirewallRules231Operation) *xxx_QueryFirewallRules231Operation {
	if op == nil {
		op = &xxx_QueryFirewallRules231Operation{}
	}
	if o == nil {
		return op
	}
	op.RulesLength = o.RulesLength
	op.Rules = o.Rules
	op.Return = o.Return
	return op
}

func (o *QueryFirewallRules231Response) xxx_FromOp(ctx context.Context, op *xxx_QueryFirewallRules231Operation) {
	if o == nil {
		return
	}
	o.RulesLength = op.RulesLength
	o.Rules = op.Rules
	o.Return = op.Return
}
func (o *QueryFirewallRules231Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *QueryFirewallRules231Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_QueryFirewallRules231Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}
