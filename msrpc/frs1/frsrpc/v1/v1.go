package frsrpc

import (
	"context"
	"fmt"
	"strings"
	"unicode/utf16"

	dcerpc "github.com/oiweiwei/go-msrpc/dcerpc"
	errors "github.com/oiweiwei/go-msrpc/dcerpc/errors"
	uuid "github.com/oiweiwei/go-msrpc/midl/uuid"
	ndr "github.com/oiweiwei/go-msrpc/ndr"
)

var (
	_ = context.Background
	_ = fmt.Errorf
	_ = utf16.Encode
	_ = strings.TrimPrefix
	_ = ndr.ZeroString
	_ = (*uuid.UUID)(nil)
	_ = (*dcerpc.SyntaxID)(nil)
	_ = (*errors.Error)(nil)
)

var (
	// import guard
	GoPackage = "frs1"
)

var (
	// Syntax UUID
	FrsrpcSyntaxUUID = &uuid.UUID{TimeLow: 0xf5cc59b4, TimeMid: 0x4264, TimeHiAndVersion: 0x101a, ClockSeqHiAndReserved: 0x8c, ClockSeqLow: 0x59, Node: [6]uint8{0x8, 0x0, 0x2b, 0x2f, 0x84, 0x26}}
	// Syntax ID
	FrsrpcSyntaxV1_1 = &dcerpc.SyntaxID{IfUUID: FrsrpcSyntaxUUID, IfVersionMajor: 1, IfVersionMinor: 1}
)

// frsrpc interface.
type FrsrpcClient interface {

	// The FrsRpcSendCommPkt method transfers change order commands, files, and folders
	// on an FRS connection.
	//
	// Return Values: The method MUST return 0 on success or a nonzero error code on failure.
	// For protocol purposes, all nonzero values MUST be treated as equivalent failures
	// unless otherwise specified.
	//
	//	+--------------------------+------------------------------------+
	//	|          RETURN          |                                    |
	//	|        VALUE/CODE        |            DESCRIPTION             |
	//	|                          |                                    |
	//	+--------------------------+------------------------------------+
	//	+--------------------------+------------------------------------+
	//	| 0x00000000 ERROR_SUCCESS | The method completed successfully. |
	//	+--------------------------+------------------------------------+
	//
	// Exceptions Thrown: No exceptions are thrown beyond those thrown by the underlying
	// RPC protocol [MS-RPCE].
	//
	// FRS uses FrsRpcSendCommPkt to send COMM_PACKET objects (see section 2.2.3.5) between
	// replica members to replicate files and folders inside a Replica Set. See sections
	// 4.1 and 4.2.
	//
	// In the following section, these two sentences have the same meaning:
	//
	// * Machine A sends a COMM_PACKET to machine B.
	//
	// * Machine A calls the FrsRpcSendCommPkt method on machine B.
	//
	// There are 12 types of COMM_PACKETs (see section 2.2.3.6.2). If machine A sends a
	// COMM_PACKET packet to machine B with COMM_PACKET.COMM_COMMAND set to CMD_XXXX, a
	// simple way to describe this is as follows: Machine A sends CMD_XXXX to machine B.
	SendCommPacket(context.Context, *SendCommPacketRequest, ...dcerpc.CallOption) (*SendCommPacketResponse, error)

	// The FrsRpcVerifyPromotionParent method does not perform any actions. It MUST return
	// ERROR_CALL_NOT_IMPLEMENTED.
	VerifyPromotionParent(context.Context, *VerifyPromotionParentRequest, ...dcerpc.CallOption) (*VerifyPromotionParentResponse, error)

	// The FrsRpcStartPromotionParent method requests the server that is the Upstream Partner
	// to start a volatile connection for the purpose of seeding the system volume (SYSVOL)
	// folder on the container.
	//
	// Return Values: The method MUST return 0 on success; otherwise, it MUST return a nonzero
	// error code, as defined by the vendor.
	//
	// To create a \SYSVOL volume (required for the server to operate as a DC), the FrsRpcStartPromotionParent
	// method requests a volatile connection on the server for the purpose of seeding a
	// \SYSVOL folder. This is necessary because of the following: During DC promotion,
	// the newly promoted DC creates a set of Active Directory objects, which includes the
	// connection objects. When the newly promoted DC is trying to replicate the contents
	// from another DC in the domain (the process is called initial sync), the other DC
	// might not know the newly created connection, either because the DS replication service
	// has not replicated the connection out to the other DC or because the other DC has
	// not polled the Directory Service yet. The newly created DC creates a volatile connection
	// for only the initial sync and calls this RPC function to inform the other DC about
	// this volatile connection. In this way, the other DC does not reject the initial sync
	// request. <77> Once the initial sync is completed, NTFRS starts using the connection
	// generated by Knowledge Consistency Checker (KCC) for normal synchronization.
	StartPromotionParent(context.Context, *StartPromotionParentRequest, ...dcerpc.CallOption) (*StartPromotionParentResponse, error)

	// The FrsNOP method verifies that the RPC connection for this interface is functioning
	// properly. This method is not used by FRS.
	//
	// This method has no parameters.
	//
	//	+-------------------+---------------------------+
	//	|      RETURN       |                           |
	//	|    VALUE/CODE     |        DESCRIPTION        |
	//	|                   |                           |
	//	+-------------------+---------------------------+
	//	+-------------------+---------------------------+
	//	| 0x00000000        | The method MUST return 0. |
	//	+-------------------+---------------------------+
	Noop(context.Context, *NoopRequest, ...dcerpc.CallOption) (*NoopResponse, error)

	// Opnum4NotUsedOnWire operation.
	// Opnum4NotUsedOnWire

	// Opnum5NotUsedOnWire operation.
	// Opnum5NotUsedOnWire

	// Opnum6NotUsedOnWire operation.
	// Opnum6NotUsedOnWire

	// Opnum7NotUsedOnWire operation.
	// Opnum7NotUsedOnWire

	// Opnum8NotUsedOnWire operation.
	// Opnum8NotUsedOnWire

	// Opnum9NotUsedOnWire operation.
	// Opnum9NotUsedOnWire

	// Opnum10NotUsedOnWire operation.
	// Opnum10NotUsedOnWire

	// AlterContext alters the client context.
	AlterContext(context.Context, ...dcerpc.Option) error

	// Conn returns the client connection (unsafe)
	Conn() dcerpc.Conn
}

// CommPacket structure represents COMM_PACKET RPC structure.
//
// The COMM_PACKET is the primary message used to accomplish file replication through
// FRS. It MUST be transmitted as the payload of the FrsRpcSendCommPkt method. By successively
// invoking FrsRpcSendCommPkt, a computer participates in a synchronous request/response-based
// conversation with another computer that results in replication of data files. On
// receiving an FrsRpcSendCommPkt call from another computer, FRS responds based on
// the nature of the request inside the COMM_PACKET data received (see section 3.3.4.4).
//
// A PCOMM_PACKET is a pointer to a COMM_PACKET.
//
// The COMM_PACKET contains information about the partner, the replication command,
// and data specific to that replication command, plus hash fields to verify the data's
// integrity. This information is contained in a series of elements within each COMM_PACKET.
// There MUST be no padding between each element unless it is called out in the specification.
//
// Twelve types of COMM_PACKETS, each representing a different replication command,
// are sent over the wire. The replication command for the packet is indicated by the
// data field in the COMM_COMMAND element.
//
// Every packet, regardless of replication command type, MUST begin with the following
// eight elements. There MUST be no padding between each element unless it is called
// out in the specification.
//
// COMM_BOP: Beginning-of-packet marker, as specified in section 2.2.3.6.1.
//
// COMM_COMMAND: The replication command, as specified in section 2.2.3.6.2.
//
// COMM_TO: GUID and name of the member to receive this packet, as specified in section
// 2.2.3.6.3.
//
// COMM_FROM: GUID and name of the member that sent this packet, as specified in section
// 2.2.3.6.4.
//
// COMM_REPLICA: GUID and name that identifies the replica set to which this packet
// applies, as specified in section 2.2.3.6.5.
//
// COMM_CXTION: GUID and name of the connection over which this packet is transmitted,
// as specified in section 2.2.3.6.6.
//
// COMM_JOIN_GUID: GUID that identifies the last successful Join over the connection
// identified in the COMM_CXTION element, as specified in section 2.2.3.6.7.
//
// COMM_LAST_JOIN_TIME: Time that the Join identified by the COMM_JOIN_GUID element
// completed, as specified in section 2.2.3.6.8.
//
// In addition, every packet MUST end with the following element, which MUST appear
// in the packet immediately after the preceding element, with no padding between it
// and the preceding element.
//
// COMM_EOP: End-of-Packet (EOP) marker, as specified in section 2.2.3.6.23.
//
// FRS MUST respond to zero or more replication command-specific elements that appear
// between the last element in the beginning sequence and the ending element. There
// MUST be no padding bytes before or after any elements in the packet, so the following
// text gives the bit-level layout of the fields. All of the COMM_PACKET elements are
// defined in the following section.
//
// The types of replication command packets are listed in the following table along
// with a brief description and the list of elements that are contained in the packet.
// Only the mandatory elements and the elements listed for that COMM_COMMAND value in
// the following table MUST be present for a packet with a particular COMM_COMMAND value.
// The mandatory elements are omitted from this table, but MUST be present in every
// replication command packet. FRS MUST respond to these requests, as specified in section
// 3.3.4.4.
//
//	+-----------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
//	|        COMM COMMAND         |             EXTRA SEQUENCE OF ELEMENTS IN PACKET (NO PADDING BETWEEN             |                                                                                  |
//	|            VALUE            |                                    ELEMENTS)                                     |                                     MEANING                                      |
//	|                             |                                                                                  |                                                                                  |
//	+-----------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
//	+-----------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
//	| CMD_REMOTE_CO (0x218)       | COMM_REMOTE_CO COMM_CO_EXTENSION_2                                               | To send a remote change order to a downstream partner.                           |
//	+-----------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
//	| CMD_RECEIVING_STAGE (0x238) | COMM_BLOCK COMM_BLOCK_SIZE COMM_FILE_SIZE COMM_FILE_OFFSET COMM_CO_GUID          | To transmit staging file to a downstream partner.                                |
//	|                             | COMM_CO_SEQUENCE_NUMBER                                                          |                                                                                  |
//	+-----------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
//	| CMD_REMOTE_CO_DONE (0x250)  | COMM_BLOCK_SIZE COMM_FILE_SIZE COMM_FILE_OFFSET COMM_GVSN COMM_CO_GUID           | To inform the upstream partner that processing the remote change order is        |
//	|                             | COMM_CO_SEQUENCE_NUMBER COMM_REMOTE_CO COMM_CO_EXTENSION_2                       | complete. This packet also MUST include the change order command that has        |
//	|                             |                                                                                  | completed.                                                                       |
//	+-----------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
//	| CMD_ABORT_FETCH (0x246)     | COMM_BLOCK_SIZE COMM_FILE_SIZE COMM_FILE_OFFSET COMM_CO_GUID                     | To inform the downstream partner that the staged file data cannot be sent. This  |
//	|                             | COMM_CO_SEQUENCE_NUMBER                                                          | command tells the partner to abort the fetch operation on the staging file.      |
//	+-----------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
//	| CMD_RETRY_FETCH (0x244)     | COMM_BLOCK_SIZE COMM_FILE_OFFSET COMM_CO_GUID COMM_CO_SEQUENCE_NUMBER            | To inform the downstream partner that the request for the staging file data      |
//	|                             |                                                                                  | cannot be fulfilled at this time and that the request SHOULD be retried at a     |
//	|                             |                                                                                  | later time.                                                                      |
//	+-----------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
//	| CMD_NEED_JOIN (0x121)       |                                                                                  | To inform the upstream partner that a Join operation is needed.                  |
//	+-----------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
//	| CMD_START_JOIN (0x122)      |                                                                                  | To inform the downstream partner that a Join operation is starting.              |
//	+-----------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
//	| CMD_JOINING (0x130)         | COMM_VVECTOR COMM_JOIN_TIME COMM_REPLICA_VERSION_GUID COMM_COMPRESSION_GUID      | To send a version vector to an upstream partner.                                 |
//	+-----------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
//	| CMD_JOINED (0x128)          |                                                                                  | To inform the downstream partner that Join is successful.                        |
//	+-----------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
//	| CMD_UNJOIN_REMOTE (0x148)   |                                                                                  | On completion of a VVJ on a connection, this command causes the upstream partner |
//	|                             |                                                                                  | to disconnect the connection so that it can be torn down.                        |
//	+-----------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
//	| CMD_VVJOIN_DONE (0x136)     |                                                                                  | To inform the downstream partner that all change orders are sent out during      |
//	|                             |                                                                                  | Initial Sync.                                                                    |
//	+-----------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
//	| CMD_SEND_STAGE (0x228)      | COMM_BLOCK_SIZE COMM_FILE_SIZE COMM_FILE_OFFSET COMM_CO_GUID                     | To request staging data from an upstream partner.                                |
//	|                             | COMM_CO_SEQUENCE_NUMBER COMM_REMOTE_CO COMM_CO_EXTENSION_2                       |                                                                                  |
//	+-----------------------------+----------------------------------------------------------------------------------+----------------------------------------------------------------------------------+
//
// The structure of the COMM_PACKET MUST be as follows:
type CommPacket struct {
	// Major:  A 32-bit, unsigned integer indicating the major version number of the FRS.
	// This field MUST be zero (0).
	Major uint32 `idl:"name:Major" json:"major"`
	// Minor:  A 32-bit unsigned integer that specifies the minor version number of FRS.
	// The minor version number of FRS MUST be one of the following.
	//
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	|                               |                                                                                  |
	//	|             VALUE             |                                     MEANING                                      |
	//	|                               |                                                                                  |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	| NTFRS_COMM_MINOR_0 0x00000000 | This is the first version.                                                       |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	| NTFRS_COMM_MINOR_1 0x00000001 | Supports MD5.                                                                    |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	| NTFRS_COMM_MINOR_2 0x00000002 | Supports trigger schedule (see section 3.3.2.1.1).                               |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	| NTFRS_COMM_MINOR_3 0x00000003 | Supports change order record extension (see section 2.2.3.6.21).                 |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	| NTFRS_COMM_MINOR_4 0x00000004 | Forces the replica number fields in a change order to be an unsigned long        |
	//	|                               | instead of an unsigned long PTR for 32–64 bit interoperation. Supports the use   |
	//	|                               | of the COMM_COMPRESSION_GUID. Supports COMM_CO_EXTENSION_2.                      |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	| NTFRS_COMM_MINOR_5 0x00000005 | Supports change order extension COMM_CO_EXTENSION_2 when replication partner is  |
	//	|                               | running FRS minor version 4 or later.                                            |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	| NTFRS_COMM_MINOR_6 0x00000006 | No new capabilities.                                                             |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	| NTFRS_COMM_MINOR_7 0x00000007 | No new capabilities.                                                             |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	| NTFRS_COMM_MINOR_8 0x00000008 | No new capabilities.                                                             |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//	| NTFRS_COMM_MINOR_9 0x00000009 | No new capabilities.                                                             |
	//	+-------------------------------+----------------------------------------------------------------------------------+
	//
	// Version 0.7 or earlier is deprecated and SHOULD be used only for backward compatibility.
	Minor uint32 `idl:"name:Minor" json:"minor"`
	// CsId:   A 32-bit, unsigned integer that MUST be set to 1.
	CSID uint32 `idl:"name:CsId" json:"cs_id"`
	// MemLen:   A 32-bit, unsigned integer containing the size, in bytes, of Pkt. Used
	// to determine the packet length.
	MemLength uint32 `idl:"name:MemLen" json:"mem_length"`
	// PktLen:   A 32-bit, unsigned integer containing the length, in bytes, of the packet's
	// valid data portion. Not all bytes inside Pkt hold valid data. The valid data inside
	// Pkt is from offset 0 to PktLen.
	PacketLength uint32 `idl:"name:PktLen" json:"packet_length"`
	// UpkLen:  MUST be 0.
	UpkLength uint32 `idl:"name:UpkLen" json:"upk_length"`
	// Pkt:   A pointer to a buffer that MUST consist of a sequence of COMM_PACKET element
	// structures placed back to back in contiguous memory. These elements MUST be in a
	// particular order; however, some elements can be omitted depending on the command
	// that is being transmitted. The table earlier in this section specifies the elements
	// that MUST exist in the Pkt buffer, for each supported COMM_COMMAND value.
	//
	// The following table shows the order of the elements in the Pkt buffer. The first
	// column shows when the element is included in the table: A – Always; V – included
	// when a version vector is transmitted; S – included when staging data is transmitted;
	// C – included when a change order Command is transmitted. See the first table in
	// section 2.2.3.5 to see what element types MUST appear for each communication packet.
	// For more information on version vectors see section 3.1.1.11.
	//
	// See sections 2.2.3.6 through 2.2.3.6.23 for the definitions of the packet structures
	// associated with each element type.
	//
	//	+-------+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	|       |                  ELEMENT TYPE AND                   |                                     ELEMENT                                      |
	//	| USAGE |                        VALUE                        |                                     CONTENTS                                     |
	//	|       |                                                     |                                                                                  |
	//	+-------+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	+-------+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| A     | COMM_BOP 0x0001                                     | Beginning of the packet. This element MUST be the first element in the packet.   |
	//	+-------+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| A     | COMM_COMMAND 0x0002                                 | Type of command sent in this packet. See the "Type of communication packets"     |
	//	|       |                                                     | table in section 2.2.3.5.                                                        |
	//	+-------+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| A     | COMM_TO 0x0003                                      | GUID and name of the member to receive this packet. This MUST refer to either    |
	//	|       |                                                     | local machine or partner.                                                        |
	//	+-------+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| A     | COMM_FROM 0x0004                                    | GUID and name of member that sent this packet. This MUST refer to either local   |
	//	|       |                                                     | machine or partner.                                                              |
	//	+-------+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| A     | COMM_REPLICA 0x0005                                 | GUID and name that identifies the replica set to which this packet applies.      |
	//	+-------+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| A     | COMM_CXTION 0x0008                                  | GUID and name of the connection over which this packet is transmitted.           |
	//	+-------+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| A     | COMM_JOIN_GUID 0x0006                               | GUID that identifies the last successful Join over the connection identified in  |
	//	|       |                                                     | the COMM_CXTION element.                                                         |
	//	+-------+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| A     | COMM_LAST_JOIN_TIME 0x0012                          | Time (see section 2.2.3.6.8) that the Join identified by the COMM_JOIN_GUID      |
	//	|       |                                                     | element completed. Packet element contains the time of the last Join by this     |
	//	|       |                                                     | connection.                                                                      |
	//	+-------+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| V     | COMM_VVECTOR 0x0007                                 | A COMM_VVECTOR element MUST be inserted into Pkt for each GVSN structure in the  |
	//	|       |                                                     | version vector. There MUST be one COMM_VVECTOR element for each partner.         |
	//	+-------+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| V     | COMM_JOIN_TIME 0x0011                               | This element MUST be initialized to the FILETIME (as specified in [MS-DTYP])     |
	//	|       |                                                     | when the connection is joined.                                                   |
	//	+-------+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| V     | COMM_REPLICA_VERSION_GUID 0x0014                    | GUID of the machine that generated the version vector.                           |
	//	+-------+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| V     | COMM_COMPRESSION_ GUID 0x0018                       | A COMM_COMPRESSION_GUID element MUST be inserted for each compression algorithm  |
	//	|       |                                                     | that the sending member supports (see section 2.2.3.6.12. There can be more than |
	//	|       |                                                     | one COMM_COMPRESSION_GUID element. There are no other GUID values used by FRS.   |
	//	+-------+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| S     | COMM_BLOCK 0x0009                                   | Block of data from the staging file that is being transmitted.                   |
	//	+-------+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| S     | COMM_BLOCK_SIZE 0x000A                              | Size in bytes of the block of data in the COMM_BLOCK element.                    |
	//	+-------+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| S     | COMM_FILE_SIZE 0x000B                               | Size in bytes of the staging file being transmitted.                             |
	//	+-------+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| S     | COMM_FILE_OFFSET 0x000C                             | Offset from the beginning of the staging file to the beginning of the block in   |
	//	|       |                                                     | the COMM_BLOCK element.                                                          |
	//	+-------+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| S     | COMM_GVSN 0x000E                                    | GVSN structure for the file being transmitted.                                   |
	//	+-------+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| S     | COMM_CO_GUID 0x000F                                 | GUID that identifies the change order that caused the file to be transmitted.    |
	//	+-------+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| S     | COMM_CO_SEQUENCE_ NUMBER 0x0010                     | Sequence number starting at 1 to record the order of change order commands. It   |
	//	|       |                                                     | MUST be used for acknowledgment.                                                 |
	//	+-------+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| C     | COMM_REMOTE_CO 0x000D                               | Includes a remote change order command.                                          |
	//	+-------+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| C     | COMM_CO_EXT_WIN2K 0x0016 COMM_CO_EXTENSION_2 0x0017 | COMM_CO_EXT_WIN2K or a COMM_CO_EXTENSION_2 element will be in Pkt. If either     |
	//	|       |                                                     | partner is NTFRS_COMM_MINOR_3 or lower, the COMM_CO_EXT_WIN2K element will       |
	//	|       |                                                     | be used. Otherwise, the COMM_CO_EXTENSION_2 element will be used. It contains    |
	//	|       |                                                     | change order extensions.                                                         |
	//	+-------+-----------------------------------------------------+----------------------------------------------------------------------------------+
	//	| A     | COMM_EOP 0x13                                       | End-of-packet (EOP) element.                                                     |
	//	+-------+-----------------------------------------------------+----------------------------------------------------------------------------------+
	Packet []byte `idl:"name:Pkt;size_is:(PktLen)" json:"packet"`
	// DataName:   MUST be 0.
	DataName []byte `idl:"name:DataName" json:"data_name"`
	// DataHandle:   MUST be 0.
	DataHandle []byte `idl:"name:DataHandle" json:"data_handle"`
}

func (o *CommPacket) xxx_PreparePayload(ctx context.Context) error {
	if err := ndr.BeforePreparePayload(ctx, o); err != nil {
		return err
	}
	if o.Packet != nil && o.PacketLength == 0 {
		o.PacketLength = uint32(len(o.Packet))
	}
	if o.PacketLength > uint32(262144) {
		return fmt.Errorf("PacketLength is out of range")
	}
	if err := ndr.AfterPreparePayload(ctx, o); err != nil {
		return err
	}
	return nil
}
func (o *CommPacket) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.Major); err != nil {
		return err
	}
	if err := w.WriteData(o.Minor); err != nil {
		return err
	}
	if err := w.WriteData(o.CSID); err != nil {
		return err
	}
	if err := w.WriteData(o.MemLength); err != nil {
		return err
	}
	if err := w.WriteData(o.PacketLength); err != nil {
		return err
	}
	if err := w.WriteData(o.UpkLength); err != nil {
		return err
	}
	if o.Packet != nil || o.PacketLength > 0 {
		_ptr_Pkt := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.PacketLength)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Packet {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.Packet[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.Packet); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Packet, _ptr_Pkt); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *CommPacket) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.Major); err != nil {
		return err
	}
	if err := w.ReadData(&o.Minor); err != nil {
		return err
	}
	if err := w.ReadData(&o.CSID); err != nil {
		return err
	}
	if err := w.ReadData(&o.MemLength); err != nil {
		return err
	}
	if err := w.ReadData(&o.PacketLength); err != nil {
		return err
	}
	if err := w.ReadData(&o.UpkLength); err != nil {
		return err
	}
	_ptr_Pkt := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.PacketLength > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.PacketLength)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Packet", sizeInfo[0])
		}
		o.Packet = make([]byte, sizeInfo[0])
		for i1 := range o.Packet {
			i1 := i1
			if err := w.ReadData(&o.Packet[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_Pkt := func(ptr interface{}) { o.Packet = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.Packet, _s_Pkt, _ptr_Pkt); err != nil {
		return err
	}
	return nil
}

type xxx_DefaultFrsrpcClient struct {
	cc dcerpc.Conn
}

func (o *xxx_DefaultFrsrpcClient) SendCommPacket(ctx context.Context, in *SendCommPacketRequest, opts ...dcerpc.CallOption) (*SendCommPacketResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SendCommPacketResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFrsrpcClient) VerifyPromotionParent(ctx context.Context, in *VerifyPromotionParentRequest, opts ...dcerpc.CallOption) (*VerifyPromotionParentResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &VerifyPromotionParentResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFrsrpcClient) StartPromotionParent(ctx context.Context, in *StartPromotionParentRequest, opts ...dcerpc.CallOption) (*StartPromotionParentResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &StartPromotionParentResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFrsrpcClient) Noop(ctx context.Context, in *NoopRequest, opts ...dcerpc.CallOption) (*NoopResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &NoopResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultFrsrpcClient) AlterContext(ctx context.Context, opts ...dcerpc.Option) error {
	return o.cc.AlterContext(ctx, opts...)
}

func (o *xxx_DefaultFrsrpcClient) Conn() dcerpc.Conn {
	return o.cc
}

func NewFrsrpcClient(ctx context.Context, cc dcerpc.Conn, opts ...dcerpc.Option) (FrsrpcClient, error) {
	cc, err := cc.Bind(ctx, append(opts, dcerpc.WithAbstractSyntax(FrsrpcSyntaxV1_1))...)
	if err != nil {
		return nil, err
	}
	return &xxx_DefaultFrsrpcClient{cc: cc}, nil
}

// xxx_SendCommPacketOperation structure represents the FrsRpcSendCommPkt operation
type xxx_SendCommPacketOperation struct {
	CommPacket *CommPacket `idl:"name:CommPkt" json:"comm_packet"`
	Return     uint32      `idl:"name:Return" json:"return"`
}

func (o *xxx_SendCommPacketOperation) OpNum() int { return 0 }

func (o *xxx_SendCommPacketOperation) OpName() string { return "/frsrpc/v1.1/FrsRpcSendCommPkt" }

func (o *xxx_SendCommPacketOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SendCommPacketOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// CommPkt {in} (1:{alias=PCOMM_PACKET}*(1))(2:{alias=COMM_PACKET}(struct))
	{
		if o.CommPacket != nil {
			if err := o.CommPacket.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&CommPacket{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SendCommPacketOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// CommPkt {in} (1:{alias=PCOMM_PACKET,pointer=ref}*(1))(2:{alias=COMM_PACKET}(struct))
	{
		if o.CommPacket == nil {
			o.CommPacket = &CommPacket{}
		}
		if err := o.CommPacket.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SendCommPacketOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SendCommPacketOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SendCommPacketOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SendCommPacketRequest structure represents the FrsRpcSendCommPkt operation request
type SendCommPacketRequest struct {
	// CommPkt: Command and data sent from the replication partner.
	CommPacket *CommPacket `idl:"name:CommPkt" json:"comm_packet"`
}

func (o *SendCommPacketRequest) xxx_ToOp(ctx context.Context, op *xxx_SendCommPacketOperation) *xxx_SendCommPacketOperation {
	if op == nil {
		op = &xxx_SendCommPacketOperation{}
	}
	if o == nil {
		return op
	}
	op.CommPacket = o.CommPacket
	return op
}

func (o *SendCommPacketRequest) xxx_FromOp(ctx context.Context, op *xxx_SendCommPacketOperation) {
	if o == nil {
		return
	}
	o.CommPacket = op.CommPacket
}
func (o *SendCommPacketRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SendCommPacketRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SendCommPacketOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SendCommPacketResponse structure represents the FrsRpcSendCommPkt operation response
type SendCommPacketResponse struct {
	// Return: The FrsRpcSendCommPkt return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *SendCommPacketResponse) xxx_ToOp(ctx context.Context, op *xxx_SendCommPacketOperation) *xxx_SendCommPacketOperation {
	if op == nil {
		op = &xxx_SendCommPacketOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SendCommPacketResponse) xxx_FromOp(ctx context.Context, op *xxx_SendCommPacketOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SendCommPacketResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SendCommPacketResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SendCommPacketOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_VerifyPromotionParentOperation structure represents the FrsRpcVerifyPromotionParent operation
type xxx_VerifyPromotionParentOperation struct {
	ParentAccount    string `idl:"name:ParentAccount;string;pointer:unique" json:"parent_account"`
	ParentPassword   string `idl:"name:ParentPassword;string;pointer:unique" json:"parent_password"`
	SetNameReplica   string `idl:"name:ReplicaSetName;string;pointer:unique" json:"set_name_replica"`
	SetTypeReplica   string `idl:"name:ReplicaSetType;string;pointer:unique" json:"set_type_replica"`
	PartnerAuthLevel uint32 `idl:"name:PartnerAuthLevel" json:"partner_auth_level"`
	GUIDSize         uint32 `idl:"name:GuidSize" json:"guid_size"`
	Return           uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_VerifyPromotionParentOperation) OpNum() int { return 1 }

func (o *xxx_VerifyPromotionParentOperation) OpName() string {
	return "/frsrpc/v1.1/FrsRpcVerifyPromotionParent"
}

func (o *xxx_VerifyPromotionParentOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_VerifyPromotionParentOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ParentAccount {in} (1:{string, pointer=unique, alias=PWCHAR}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.ParentAccount != "" {
			_ptr_ParentAccount := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ParentAccount); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ParentAccount, _ptr_ParentAccount); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ParentPassword {in} (1:{string, pointer=unique, alias=PWCHAR}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.ParentPassword != "" {
			_ptr_ParentPassword := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ParentPassword); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ParentPassword, _ptr_ParentPassword); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ReplicaSetName {in} (1:{string, pointer=unique, alias=PWCHAR}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.SetNameReplica != "" {
			_ptr_ReplicaSetName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.SetNameReplica); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.SetNameReplica, _ptr_ReplicaSetName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ReplicaSetType {in} (1:{string, pointer=unique, alias=PWCHAR}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.SetTypeReplica != "" {
			_ptr_ReplicaSetType := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.SetTypeReplica); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.SetTypeReplica, _ptr_ReplicaSetType); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// PartnerAuthLevel {in} (1:(uint32))
	{
		if err := w.WriteData(o.PartnerAuthLevel); err != nil {
			return err
		}
	}
	// GuidSize {in} (1:(uint32))
	{
		if err := w.WriteData(o.GUIDSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_VerifyPromotionParentOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ParentAccount {in} (1:{string, pointer=unique, alias=PWCHAR}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_ParentAccount := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ParentAccount); err != nil {
				return err
			}
			return nil
		})
		_s_ParentAccount := func(ptr interface{}) { o.ParentAccount = *ptr.(*string) }
		if err := w.ReadPointer(&o.ParentAccount, _s_ParentAccount, _ptr_ParentAccount); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ParentPassword {in} (1:{string, pointer=unique, alias=PWCHAR}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_ParentPassword := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ParentPassword); err != nil {
				return err
			}
			return nil
		})
		_s_ParentPassword := func(ptr interface{}) { o.ParentPassword = *ptr.(*string) }
		if err := w.ReadPointer(&o.ParentPassword, _s_ParentPassword, _ptr_ParentPassword); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ReplicaSetName {in} (1:{string, pointer=unique, alias=PWCHAR}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_ReplicaSetName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.SetNameReplica); err != nil {
				return err
			}
			return nil
		})
		_s_ReplicaSetName := func(ptr interface{}) { o.SetNameReplica = *ptr.(*string) }
		if err := w.ReadPointer(&o.SetNameReplica, _s_ReplicaSetName, _ptr_ReplicaSetName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ReplicaSetType {in} (1:{string, pointer=unique, alias=PWCHAR}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_ReplicaSetType := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.SetTypeReplica); err != nil {
				return err
			}
			return nil
		})
		_s_ReplicaSetType := func(ptr interface{}) { o.SetTypeReplica = *ptr.(*string) }
		if err := w.ReadPointer(&o.SetTypeReplica, _s_ReplicaSetType, _ptr_ReplicaSetType); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// PartnerAuthLevel {in} (1:(uint32))
	{
		if err := w.ReadData(&o.PartnerAuthLevel); err != nil {
			return err
		}
	}
	// GuidSize {in} (1:(uint32))
	{
		if err := w.ReadData(&o.GUIDSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_VerifyPromotionParentOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_VerifyPromotionParentOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_VerifyPromotionParentOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// VerifyPromotionParentRequest structure represents the FrsRpcVerifyPromotionParent operation request
type VerifyPromotionParentRequest struct {
	// ParentAccount: MUST be 0. MUST be ignored on receipt.
	ParentAccount string `idl:"name:ParentAccount;string;pointer:unique" json:"parent_account"`
	// ParentPassword: MUST be 0. MUST be ignored on receipt.
	ParentPassword string `idl:"name:ParentPassword;string;pointer:unique" json:"parent_password"`
	// ReplicaSetName: MUST be 0. MUST be ignored on receipt.
	SetNameReplica string `idl:"name:ReplicaSetName;string;pointer:unique" json:"set_name_replica"`
	// ReplicaSetType: MUST be 0. MUST be ignored on receipt.
	SetTypeReplica string `idl:"name:ReplicaSetType;string;pointer:unique" json:"set_type_replica"`
	// PartnerAuthLevel: MUST be 0. MUST be ignored on receipt.
	PartnerAuthLevel uint32 `idl:"name:PartnerAuthLevel" json:"partner_auth_level"`
	// GuidSize: MUST be 0. MUST be ignored on receipt.
	//
	//	+---------------------------------------+------------------------------------------------+
	//	|                RETURN                 |                                                |
	//	|              VALUE/CODE               |                  DESCRIPTION                   |
	//	|                                       |                                                |
	//	+---------------------------------------+------------------------------------------------+
	//	+---------------------------------------+------------------------------------------------+
	//	| 0x00000078 ERROR_CALL_NOT_IMPLEMENTED | This function is not supported on this system. |
	//	+---------------------------------------+------------------------------------------------+
	GUIDSize uint32 `idl:"name:GuidSize" json:"guid_size"`
}

func (o *VerifyPromotionParentRequest) xxx_ToOp(ctx context.Context, op *xxx_VerifyPromotionParentOperation) *xxx_VerifyPromotionParentOperation {
	if op == nil {
		op = &xxx_VerifyPromotionParentOperation{}
	}
	if o == nil {
		return op
	}
	op.ParentAccount = o.ParentAccount
	op.ParentPassword = o.ParentPassword
	op.SetNameReplica = o.SetNameReplica
	op.SetTypeReplica = o.SetTypeReplica
	op.PartnerAuthLevel = o.PartnerAuthLevel
	op.GUIDSize = o.GUIDSize
	return op
}

func (o *VerifyPromotionParentRequest) xxx_FromOp(ctx context.Context, op *xxx_VerifyPromotionParentOperation) {
	if o == nil {
		return
	}
	o.ParentAccount = op.ParentAccount
	o.ParentPassword = op.ParentPassword
	o.SetNameReplica = op.SetNameReplica
	o.SetTypeReplica = op.SetTypeReplica
	o.PartnerAuthLevel = op.PartnerAuthLevel
	o.GUIDSize = op.GUIDSize
}
func (o *VerifyPromotionParentRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *VerifyPromotionParentRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_VerifyPromotionParentOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// VerifyPromotionParentResponse structure represents the FrsRpcVerifyPromotionParent operation response
type VerifyPromotionParentResponse struct {
	// Return: The FrsRpcVerifyPromotionParent return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *VerifyPromotionParentResponse) xxx_ToOp(ctx context.Context, op *xxx_VerifyPromotionParentOperation) *xxx_VerifyPromotionParentOperation {
	if op == nil {
		op = &xxx_VerifyPromotionParentOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *VerifyPromotionParentResponse) xxx_FromOp(ctx context.Context, op *xxx_VerifyPromotionParentOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *VerifyPromotionParentResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *VerifyPromotionParentResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_VerifyPromotionParentOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_StartPromotionParentOperation structure represents the FrsRpcStartPromotionParent operation
type xxx_StartPromotionParentOperation struct {
	ParentAccount    string `idl:"name:ParentAccount;string;pointer:unique" json:"parent_account"`
	ParentPassword   string `idl:"name:ParentPassword;string;pointer:unique" json:"parent_password"`
	SetNameReplica   string `idl:"name:ReplicaSetName;string;pointer:unique" json:"set_name_replica"`
	SetTypeReplica   string `idl:"name:ReplicaSetType;string;pointer:unique" json:"set_type_replica"`
	CxtionName       string `idl:"name:CxtionName;string;pointer:unique" json:"cxtion_name"`
	PartnerName      string `idl:"name:PartnerName;string;pointer:unique" json:"partner_name"`
	PartnerPrincName string `idl:"name:PartnerPrincName;string;pointer:unique" json:"partner_princ_name"`
	PartnerAuthLevel uint32 `idl:"name:PartnerAuthLevel" json:"partner_auth_level"`
	GUIDSize         uint32 `idl:"name:GuidSize" json:"guid_size"`
	CxtionGUID       []byte `idl:"name:CxtionGuid;size_is:(GuidSize);pointer:unique" json:"cxtion_guid"`
	PartnerGUID      []byte `idl:"name:PartnerGuid;size_is:(GuidSize);pointer:unique" json:"partner_guid"`
	ParentGUID       []byte `idl:"name:ParentGuid;size_is:(GuidSize);pointer:unique" json:"parent_guid"`
	Return           uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_StartPromotionParentOperation) OpNum() int { return 2 }

func (o *xxx_StartPromotionParentOperation) OpName() string {
	return "/frsrpc/v1.1/FrsRpcStartPromotionParent"
}

func (o *xxx_StartPromotionParentOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.CxtionGUID != nil && o.GUIDSize == 0 {
		o.GUIDSize = uint32(len(o.CxtionGUID))
	}
	if o.PartnerGUID != nil && o.GUIDSize == 0 {
		o.GUIDSize = uint32(len(o.PartnerGUID))
	}
	if o.ParentGUID != nil && o.GUIDSize == 0 {
		o.GUIDSize = uint32(len(o.ParentGUID))
	}
	if o.GUIDSize < uint32(15) || o.GUIDSize > uint32(15) {
		return fmt.Errorf("GUIDSize is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartPromotionParentOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ParentAccount {in} (1:{string, pointer=unique, alias=PWCHAR}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.ParentAccount != "" {
			_ptr_ParentAccount := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ParentAccount); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ParentAccount, _ptr_ParentAccount); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ParentPassword {in} (1:{string, pointer=unique, alias=PWCHAR}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.ParentPassword != "" {
			_ptr_ParentPassword := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ParentPassword); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ParentPassword, _ptr_ParentPassword); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ReplicaSetName {in} (1:{string, pointer=unique, alias=PWCHAR}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.SetNameReplica != "" {
			_ptr_ReplicaSetName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.SetNameReplica); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.SetNameReplica, _ptr_ReplicaSetName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ReplicaSetType {in} (1:{string, pointer=unique, alias=PWCHAR}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.SetTypeReplica != "" {
			_ptr_ReplicaSetType := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.SetTypeReplica); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.SetTypeReplica, _ptr_ReplicaSetType); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// CxtionName {in} (1:{string, pointer=unique, alias=PWCHAR}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.CxtionName != "" {
			_ptr_CxtionName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.CxtionName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.CxtionName, _ptr_CxtionName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// PartnerName {in} (1:{string, pointer=unique, alias=PWCHAR}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.PartnerName != "" {
			_ptr_PartnerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.PartnerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.PartnerName, _ptr_PartnerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// PartnerPrincName {in} (1:{string, pointer=unique, alias=PWCHAR}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		if o.PartnerPrincName != "" {
			_ptr_PartnerPrincName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.PartnerPrincName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.PartnerPrincName, _ptr_PartnerPrincName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// PartnerAuthLevel {in} (1:(uint32))
	{
		if err := w.WriteData(o.PartnerAuthLevel); err != nil {
			return err
		}
	}
	// GuidSize {in} (1:{range=(15,15)}(uint32))
	{
		if err := w.WriteData(o.GUIDSize); err != nil {
			return err
		}
	}
	// CxtionGuid {in} (1:{pointer=unique}*(1)[dim:0,size_is=GuidSize](uchar))
	{
		if o.CxtionGUID != nil || o.GUIDSize > 0 {
			_ptr_CxtionGuid := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.GUIDSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.CxtionGUID {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.CxtionGUID[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.CxtionGUID); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.CxtionGUID, _ptr_CxtionGuid); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// PartnerGuid {in} (1:{pointer=unique}*(1)[dim:0,size_is=GuidSize](uchar))
	{
		if o.PartnerGUID != nil || o.GUIDSize > 0 {
			_ptr_PartnerGuid := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.GUIDSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.PartnerGUID {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.PartnerGUID[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.PartnerGUID); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.PartnerGUID, _ptr_PartnerGuid); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ParentGuid {in, out} (1:{pointer=unique}*(1)[dim:0,size_is=GuidSize](uchar))
	{
		if o.ParentGUID != nil || o.GUIDSize > 0 {
			_ptr_ParentGuid := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.GUIDSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.ParentGUID {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.ParentGUID[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.ParentGUID); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ParentGUID, _ptr_ParentGuid); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartPromotionParentOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ParentAccount {in} (1:{string, pointer=unique, alias=PWCHAR}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_ParentAccount := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ParentAccount); err != nil {
				return err
			}
			return nil
		})
		_s_ParentAccount := func(ptr interface{}) { o.ParentAccount = *ptr.(*string) }
		if err := w.ReadPointer(&o.ParentAccount, _s_ParentAccount, _ptr_ParentAccount); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ParentPassword {in} (1:{string, pointer=unique, alias=PWCHAR}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_ParentPassword := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ParentPassword); err != nil {
				return err
			}
			return nil
		})
		_s_ParentPassword := func(ptr interface{}) { o.ParentPassword = *ptr.(*string) }
		if err := w.ReadPointer(&o.ParentPassword, _s_ParentPassword, _ptr_ParentPassword); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ReplicaSetName {in} (1:{string, pointer=unique, alias=PWCHAR}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_ReplicaSetName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.SetNameReplica); err != nil {
				return err
			}
			return nil
		})
		_s_ReplicaSetName := func(ptr interface{}) { o.SetNameReplica = *ptr.(*string) }
		if err := w.ReadPointer(&o.SetNameReplica, _s_ReplicaSetName, _ptr_ReplicaSetName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ReplicaSetType {in} (1:{string, pointer=unique, alias=PWCHAR}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_ReplicaSetType := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.SetTypeReplica); err != nil {
				return err
			}
			return nil
		})
		_s_ReplicaSetType := func(ptr interface{}) { o.SetTypeReplica = *ptr.(*string) }
		if err := w.ReadPointer(&o.SetTypeReplica, _s_ReplicaSetType, _ptr_ReplicaSetType); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// CxtionName {in} (1:{string, pointer=unique, alias=PWCHAR}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_CxtionName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.CxtionName); err != nil {
				return err
			}
			return nil
		})
		_s_CxtionName := func(ptr interface{}) { o.CxtionName = *ptr.(*string) }
		if err := w.ReadPointer(&o.CxtionName, _s_CxtionName, _ptr_CxtionName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// PartnerName {in} (1:{string, pointer=unique, alias=PWCHAR}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_PartnerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.PartnerName); err != nil {
				return err
			}
			return nil
		})
		_s_PartnerName := func(ptr interface{}) { o.PartnerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.PartnerName, _s_PartnerName, _ptr_PartnerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// PartnerPrincName {in} (1:{string, pointer=unique, alias=PWCHAR}*(1))(2:{alias=WCHAR}[dim:0,string,null](wchar))
	{
		_ptr_PartnerPrincName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.PartnerPrincName); err != nil {
				return err
			}
			return nil
		})
		_s_PartnerPrincName := func(ptr interface{}) { o.PartnerPrincName = *ptr.(*string) }
		if err := w.ReadPointer(&o.PartnerPrincName, _s_PartnerPrincName, _ptr_PartnerPrincName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// PartnerAuthLevel {in} (1:(uint32))
	{
		if err := w.ReadData(&o.PartnerAuthLevel); err != nil {
			return err
		}
	}
	// GuidSize {in} (1:{range=(15,15)}(uint32))
	{
		if err := w.ReadData(&o.GUIDSize); err != nil {
			return err
		}
	}
	// CxtionGuid {in} (1:{pointer=unique}*(1)[dim:0,size_is=GuidSize](uchar))
	{
		_ptr_CxtionGuid := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.CxtionGUID", sizeInfo[0])
			}
			o.CxtionGUID = make([]byte, sizeInfo[0])
			for i1 := range o.CxtionGUID {
				i1 := i1
				if err := w.ReadData(&o.CxtionGUID[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_CxtionGuid := func(ptr interface{}) { o.CxtionGUID = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.CxtionGUID, _s_CxtionGuid, _ptr_CxtionGuid); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// PartnerGuid {in} (1:{pointer=unique}*(1)[dim:0,size_is=GuidSize](uchar))
	{
		_ptr_PartnerGuid := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.PartnerGUID", sizeInfo[0])
			}
			o.PartnerGUID = make([]byte, sizeInfo[0])
			for i1 := range o.PartnerGUID {
				i1 := i1
				if err := w.ReadData(&o.PartnerGUID[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_PartnerGuid := func(ptr interface{}) { o.PartnerGUID = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.PartnerGUID, _s_PartnerGuid, _ptr_PartnerGuid); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ParentGuid {in, out} (1:{pointer=unique}*(1)[dim:0,size_is=GuidSize](uchar))
	{
		_ptr_ParentGuid := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.ParentGUID", sizeInfo[0])
			}
			o.ParentGUID = make([]byte, sizeInfo[0])
			for i1 := range o.ParentGUID {
				i1 := i1
				if err := w.ReadData(&o.ParentGUID[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_ParentGuid := func(ptr interface{}) { o.ParentGUID = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.ParentGUID, _s_ParentGuid, _ptr_ParentGuid); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartPromotionParentOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartPromotionParentOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ParentGuid {in, out} (1:{pointer=unique}*(1)[dim:0,size_is=GuidSize](uchar))
	{
		if o.ParentGUID != nil || o.GUIDSize > 0 {
			_ptr_ParentGuid := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				dimSize1 := uint64(o.GUIDSize)
				if err := w.WriteSize(dimSize1); err != nil {
					return err
				}
				sizeInfo := []uint64{
					dimSize1,
				}
				for i1 := range o.ParentGUID {
					i1 := i1
					if uint64(i1) >= sizeInfo[0] {
						break
					}
					if err := w.WriteData(o.ParentGUID[i1]); err != nil {
						return err
					}
				}
				for i1 := len(o.ParentGUID); uint64(i1) < sizeInfo[0]; i1++ {
					if err := w.WriteData(uint8(0)); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ParentGUID, _ptr_ParentGuid); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_StartPromotionParentOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ParentGuid {in, out} (1:{pointer=unique}*(1)[dim:0,size_is=GuidSize](uchar))
	{
		_ptr_ParentGuid := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			sizeInfo := []uint64{
				0,
			}
			for sz1 := range sizeInfo {
				if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
					return err
				}
			}
			if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
				return fmt.Errorf("buffer overflow for size %d of array o.ParentGUID", sizeInfo[0])
			}
			o.ParentGUID = make([]byte, sizeInfo[0])
			for i1 := range o.ParentGUID {
				i1 := i1
				if err := w.ReadData(&o.ParentGUID[i1]); err != nil {
					return err
				}
			}
			return nil
		})
		_s_ParentGuid := func(ptr interface{}) { o.ParentGUID = *ptr.(*[]byte) }
		if err := w.ReadPointer(&o.ParentGUID, _s_ParentGuid, _ptr_ParentGuid); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// StartPromotionParentRequest structure represents the FrsRpcStartPromotionParent operation request
type StartPromotionParentRequest struct {
	// ParentAccount: Valid account on the DC that functions as the parent. MUST be NULL
	// (indicating to use the current connecting client's credential).
	ParentAccount string `idl:"name:ParentAccount;string;pointer:unique" json:"parent_account"`
	// ParentPassword: Password for an account on the DC. MUST be NULL.
	ParentPassword string `idl:"name:ParentPassword;string;pointer:unique" json:"parent_password"`
	// ReplicaSetName: RDN name of the replica set that the caller requested.
	SetNameReplica string `idl:"name:ReplicaSetName;string;pointer:unique" json:"set_name_replica"`
	// ReplicaSetType: String that specifies the type of the replica set that the caller
	// requested. The string MUST be treated in a case-insensitive manner, and there MUST
	// NOT be white space in the string. The value MUST be one of the following.
	//
	//	+--------------+-------------------------+
	//	|              |                         |
	//	|    VALUE     |         MEANING         |
	//	|              |                         |
	//	+--------------+-------------------------+
	//	+--------------+-------------------------+
	//	| "Enterprise" | Enterprise Replica Set. |
	//	+--------------+-------------------------+
	//	| "Domain"     | Domain Replica Set.     |
	//	+--------------+-------------------------+
	SetTypeReplica string `idl:"name:ReplicaSetType;string;pointer:unique" json:"set_type_replica"`
	// CxtionName: Fully qualified domain name of the machine receiving this call.
	CxtionName string `idl:"name:CxtionName;string;pointer:unique" json:"cxtion_name"`
	// PartnerName: Fully qualified domain name of the caller.
	PartnerName string `idl:"name:PartnerName;string;pointer:unique" json:"partner_name"`
	// PartnerPrincName: Name of the caller to use for Kerberos authentication in the format
	// of [Domain Name]\[Host Name]$.
	PartnerPrincName string `idl:"name:PartnerPrincName;string;pointer:unique" json:"partner_princ_name"`
	// PartnerAuthLevel: Authentication type and level. MUST be one of the following values.
	// <76>
	//
	//	+------------+--------------------+
	//	|            |                    |
	//	|   VALUE    |      MEANING       |
	//	|            |                    |
	//	+------------+--------------------+
	//	+------------+--------------------+
	//	| 0x00000000 | Encrypted Kerberos |
	//	+------------+--------------------+
	//	| 0x00000001 | No authentication  |
	//	+------------+--------------------+
	PartnerAuthLevel uint32 `idl:"name:PartnerAuthLevel" json:"partner_auth_level"`
	// GuidSize: Size of the array allocated to hold the globally unique identifier (GUID).
	// MUST be 0x00000010.
	GUIDSize uint32 `idl:"name:GuidSize" json:"guid_size"`
	// CxtionGuid: Temporary value for the connection. The GUID is generated randomly and
	// is not persisted in Active Directory.
	CxtionGUID []byte `idl:"name:CxtionGuid;size_is:(GuidSize);pointer:unique" json:"cxtion_guid"`
	// PartnerGuid: GUID that identifies the replica set on the replication partner.
	PartnerGUID []byte `idl:"name:PartnerGuid;size_is:(GuidSize);pointer:unique" json:"partner_guid"`
	// ParentGuid: GUID value that identifies the parent for the inbound connection.
	ParentGUID []byte `idl:"name:ParentGuid;size_is:(GuidSize);pointer:unique" json:"parent_guid"`
}

func (o *StartPromotionParentRequest) xxx_ToOp(ctx context.Context, op *xxx_StartPromotionParentOperation) *xxx_StartPromotionParentOperation {
	if op == nil {
		op = &xxx_StartPromotionParentOperation{}
	}
	if o == nil {
		return op
	}
	op.ParentAccount = o.ParentAccount
	op.ParentPassword = o.ParentPassword
	op.SetNameReplica = o.SetNameReplica
	op.SetTypeReplica = o.SetTypeReplica
	op.CxtionName = o.CxtionName
	op.PartnerName = o.PartnerName
	op.PartnerPrincName = o.PartnerPrincName
	op.PartnerAuthLevel = o.PartnerAuthLevel
	op.GUIDSize = o.GUIDSize
	op.CxtionGUID = o.CxtionGUID
	op.PartnerGUID = o.PartnerGUID
	op.ParentGUID = o.ParentGUID
	return op
}

func (o *StartPromotionParentRequest) xxx_FromOp(ctx context.Context, op *xxx_StartPromotionParentOperation) {
	if o == nil {
		return
	}
	o.ParentAccount = op.ParentAccount
	o.ParentPassword = op.ParentPassword
	o.SetNameReplica = op.SetNameReplica
	o.SetTypeReplica = op.SetTypeReplica
	o.CxtionName = op.CxtionName
	o.PartnerName = op.PartnerName
	o.PartnerPrincName = op.PartnerPrincName
	o.PartnerAuthLevel = op.PartnerAuthLevel
	o.GUIDSize = op.GUIDSize
	o.CxtionGUID = op.CxtionGUID
	o.PartnerGUID = op.PartnerGUID
	o.ParentGUID = op.ParentGUID
}
func (o *StartPromotionParentRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *StartPromotionParentRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_StartPromotionParentOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// StartPromotionParentResponse structure represents the FrsRpcStartPromotionParent operation response
type StartPromotionParentResponse struct {
	// XXX: GuidSize is an implicit input depedency for output parameters
	GUIDSize uint32 `idl:"name:GuidSize" json:"guid_size"`

	// ParentGuid: GUID value that identifies the parent for the inbound connection.
	ParentGUID []byte `idl:"name:ParentGuid;size_is:(GuidSize);pointer:unique" json:"parent_guid"`
	// Return: The FrsRpcStartPromotionParent return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *StartPromotionParentResponse) xxx_ToOp(ctx context.Context, op *xxx_StartPromotionParentOperation) *xxx_StartPromotionParentOperation {
	if op == nil {
		op = &xxx_StartPromotionParentOperation{}
	}
	if o == nil {
		return op
	}
	// XXX: implicit input dependencies for output parameters
	if op.GUIDSize == uint32(0) {
		op.GUIDSize = o.GUIDSize
	}

	op.ParentGUID = o.ParentGUID
	op.Return = o.Return
	return op
}

func (o *StartPromotionParentResponse) xxx_FromOp(ctx context.Context, op *xxx_StartPromotionParentOperation) {
	if o == nil {
		return
	}
	// XXX: implicit input dependencies for output parameters
	o.GUIDSize = op.GUIDSize

	o.ParentGUID = op.ParentGUID
	o.Return = op.Return
}
func (o *StartPromotionParentResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *StartPromotionParentResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_StartPromotionParentOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_NoopOperation structure represents the FrsNOP operation
type xxx_NoopOperation struct {
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_NoopOperation) OpNum() int { return 3 }

func (o *xxx_NoopOperation) OpName() string { return "/frsrpc/v1.1/FrsNOP" }

func (o *xxx_NoopOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NoopOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	return nil
}

func (o *xxx_NoopOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	return nil
}

func (o *xxx_NoopOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NoopOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_NoopOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// NoopRequest structure represents the FrsNOP operation request
type NoopRequest struct {
}

func (o *NoopRequest) xxx_ToOp(ctx context.Context, op *xxx_NoopOperation) *xxx_NoopOperation {
	if op == nil {
		op = &xxx_NoopOperation{}
	}
	if o == nil {
		return op
	}
	return op
}

func (o *NoopRequest) xxx_FromOp(ctx context.Context, op *xxx_NoopOperation) {
	if o == nil {
		return
	}
}
func (o *NoopRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *NoopRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_NoopOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// NoopResponse structure represents the FrsNOP operation response
type NoopResponse struct {
	// Return: The FrsNOP return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *NoopResponse) xxx_ToOp(ctx context.Context, op *xxx_NoopOperation) *xxx_NoopOperation {
	if op == nil {
		op = &xxx_NoopOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *NoopResponse) xxx_FromOp(ctx context.Context, op *xxx_NoopOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *NoopResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *NoopResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_NoopOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}
