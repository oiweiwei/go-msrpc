package logon

import (
	"context"
	"fmt"
	"strings"
	"unicode/utf16"

	dcerpc "github.com/oiweiwei/go-msrpc/dcerpc"
	errors "github.com/oiweiwei/go-msrpc/dcerpc/errors"
	uuid "github.com/oiweiwei/go-msrpc/midl/uuid"
	dtyp "github.com/oiweiwei/go-msrpc/msrpc/dtyp"
	ndr "github.com/oiweiwei/go-msrpc/ndr"
)

var (
	_ = context.Background
	_ = fmt.Errorf
	_ = utf16.Encode
	_ = strings.TrimPrefix
	_ = ndr.ZeroString
	_ = (*uuid.UUID)(nil)
	_ = (*dcerpc.SyntaxID)(nil)
	_ = (*errors.Error)(nil)
	_ = dtyp.GoPackage
)

var (
	// import guard
	GoPackage = "nrpc"
)

var (
	// Syntax UUID
	LogonSyntaxUUID = &uuid.UUID{TimeLow: 0x12345678, TimeMid: 0x1234, TimeHiAndVersion: 0xabcd, ClockSeqHiAndReserved: 0xef, ClockSeqLow: 0x0, Node: [6]uint8{0x1, 0x23, 0x45, 0x67, 0xcf, 0xfb}}
	// Syntax ID
	LogonSyntaxV1_0 = &dcerpc.SyntaxID{IfUUID: LogonSyntaxUUID, IfVersionMajor: 1, IfVersionMinor: 0}
)

// logon interface.
type LogonClient interface {
	UASLogon(context.Context, *UASLogonRequest, ...dcerpc.CallOption) (*UASLogonResponse, error)

	UASLogoff(context.Context, *UASLogoffRequest, ...dcerpc.CallOption) (*UASLogoffResponse, error)

	// The NetrLogonSamLogon method<213> is a predecessor to the NetrLogonSamLogonWithFlags
	// method (section 3.5.4.5.2). All parameters of this method have the same meanings
	// as the identically named parameters of the NetrLogonSamLogonWithFlags method.
	//
	// Message processing<214> is identical to NetrLogonSamLogonEx, as specified in section
	// 3.5.4.5.1, except for the following:
	//
	// * The method uses Netlogon authenticators ( b5e7d25a-40b2-41c8-9611-98f53358af66#gt_e72a2c02-84a2-4ce3-b66f-86f725642dc3
	// ) , so instead of checking for Secure RPC, the server MUST confirm the validity of
	// the Authenticator (section 3.1.4.5 ( da7acaa3-030b-481e-979b-f58f89389806 ) ) that
	// it received using the ComputerName for the secure channel ( b5e7d25a-40b2-41c8-9611-98f53358af66#gt_08ce423c-9f9c-48ed-afa8-8b64c04ecdca
	// ) to find the corresponding record in the ClientSessionInfo table. If the Authenticator
	// parameter is valid, the server MUST compute the ReturnAuthenticator parameter returned
	// (section 3.1.4.5). Otherwise, the server MUST return STATUS_ACCESS_DENIED.
	//
	// * The ExtraFlags parameter is not processed.
	//
	// This method SHOULD only be called by a machine that has established a secure channel
	// with the server.
	SAMLogon(context.Context, *SAMLogonRequest, ...dcerpc.CallOption) (*SAMLogonResponse, error)

	// The NetrLogonSamLogoff method SHOULD<215> update the user lastLogoff attribute for
	// the SAM accounts.
	//
	// Return Values: The method returns 0x00000000 on success; otherwise, it returns a
	// nonzero error code.
	SAMLogoff(context.Context, *SAMLogoffRequest, ...dcerpc.CallOption) (*SAMLogoffResponse, error)

	// The NetrServerReqChallenge method SHOULD<172> receive a client challenge and return
	// a server challenge (SC).
	//
	// Return Values: The method returns 0x00000000 on success; otherwise, it returns a
	// nonzero error code.
	RequestChallenge(context.Context, *RequestChallengeRequest, ...dcerpc.CallOption) (*RequestChallengeResponse, error)

	// The NetrServerAuthenticate method<177> is a predecessor to the NetrServerAuthenticate3
	// method (section 3.5.4.4.2). All parameters of this method have the same meanings
	// as the identically named parameters of the NetrServerAuthenticate3 method.
	//
	// Message processing is identical to NetrServerAuthenticate3, as specified in section
	// 3.5.4.4.2, except for the following:
	//
	// * The NegotiateFlags parameter is not present in NetrServerAuthenticate. Message
	// processing would be identical to an invocation of NetrServerAuthenticate3 with the
	// NegotiateFlags parameter set to 0.
	//
	// * The AccountRid parameter is not present in NetrServerAuthenticate.
	Authenticate(context.Context, *AuthenticateRequest, ...dcerpc.CallOption) (*AuthenticateResponse, error)

	// The NetrServerPasswordSet method SHOULD<182> set a new one-way function (OWF) of
	// a password for an account used by the domain controller for setting up the secure
	// channel from the client.
	//
	// Return Values: The method returns 0x00000000 on success; otherwise, it returns a
	// nonzero error code.
	PasswordSet(context.Context, *PasswordSetRequest, ...dcerpc.CallOption) (*PasswordSetResponse, error)

	// The NetrDatabaseDeltas method SHOULD<217> return a set of changes (or deltas) performed
	// to the SAM database, SAM built-in database, or LSA databases after a particular value
	// of the database serial number. It is used by BDCs to request database changes from
	// the PDC that are missing on the BDC.
	//
	// Return Values: The method returns 0x00000000 on success; otherwise, it returns a
	// nonzero error code.
	//
	// The synchronization that this method performs is not a full synchronization; rather,
	// a subset of database changes is returned. To perform a full synchronization, call
	// NetrDatabaseSync.
	//
	// The server that receives this call MUST do the following:
	//
	// * Verify that the client is a BDC.
	//
	// * Verify the client authenticator. The server MUST return status code STATUS_ACCESS_DENIED
	// if the verification fails.
	//
	// * Validate that DatabaseID is one of the allowed values, 0x00000000 through 0x00000002.
	// If the DatabaseID is not one of these values, the server MUST return the status code
	// STATUS_INVALID_LEVEL.
	//
	// * Given the BDC database serial number, obtain all database records that are missing
	// on the BDC and return the array of deltas, NETLOGON_DELTA_ENUM_ARRAY, for the missing
	// records. The number of elements returned is affected by the value of the PreferredMaximumLength
	// parameter. The server SHOULD <219> ( 0c858a52-732a-43ec-85dd-e44b357c1898#Appendix_A_219
	// ) stop including elements in the returned array after the size of the returned data
	// equals or exceeds the value of the PreferredMaximumLength parameter. The server SHOULD
	// also limit the number of elements per local configuration to avoid large array allocations.
	//
	// * Compute and return the server authenticator.
	//
	// * The server MUST set the value of the DomainModifiedCount parameter to the database
	// serial number of the last delta returned in the array.
	//
	// * If not all missing records are returned, the server MUST return the status code
	// STATUS_MORE_ENTRIES.
	//
	// * The server maintains and updates a state that indicates the client progress in
	// the synchronization protocol, as defined in section 3.6 ( f28f9dc8-eeb2-4112-9eec-a466f639c761
	// ).
	DatabaseDeltas(context.Context, *DatabaseDeltasRequest, ...dcerpc.CallOption) (*DatabaseDeltasResponse, error)

	// The NetrDatabaseSync method<223> is a predecessor to the NetrDatabaseSync2 method
	// (section 3.5.4.6.2). All parameters of this method have the same meanings as the
	// identically named parameters of the NetrDatabaseSync2 method.
	//
	// Receiving this method is identical to receiving NetrDatabaseSync2, as specified in
	// section 3.5.4.6.2, except that this call does not use the RestartState parameter.
	// NetrDatabaseSync does not support restarting the synchronization loop.
	DatabaseSync(context.Context, *DatabaseSyncRequest, ...dcerpc.CallOption) (*DatabaseSyncResponse, error)

	AccountDeltas(context.Context, *AccountDeltasRequest, ...dcerpc.CallOption) (*AccountDeltasResponse, error)

	AccountSync(context.Context, *AccountSyncRequest, ...dcerpc.CallOption) (*AccountSyncResponse, error)

	// The NetrGetDCName method MAY<160> be used to retrieve the NetBIOS name of the PDC
	// for the specified domain.
	//
	// Return Values: The method returns 0x00000000 on success; otherwise, it MUST return
	// a nonzero error code and SHOULD return the following error code.
	//
	//	+--------------------------------+---------------------------------+
	//	|             RETURN             |                                 |
	//	|           VALUE/CODE           |           DESCRIPTION           |
	//	|                                |                                 |
	//	+--------------------------------+---------------------------------+
	//	+--------------------------------+---------------------------------+
	//	| 0x00000035 ERROR_ BAD_ NETPATH | The network path was not found. |
	//	+--------------------------------+---------------------------------+
	GetNetrDCName(context.Context, *GetNetrDCNameRequest, ...dcerpc.CallOption) (*GetNetrDCNameResponse, error)

	// The NetrLogonControl method is a predecessor to the NetrLogonControl2Ex method (section
	// 3.5.4.9.1). All parameters of this method SHOULD<260> have the same meanings as the
	// identically named parameters of the NetrLogonControl2Ex method.
	//
	// All restrictions on parameter values in the NetrLogonControl2Ex method (section 3.5.4.9.1)
	// apply. Extra restrictions are applied to the values of the FunctionCode<261> and
	// QueryLevel parameters as follows:
	//
	// * The value of QueryLevel parameter is restricted to 0x00000001. If 0x00000002 is
	// used, the error ERROR_NOT_SUPPORTED is returned; if any value larger than 0x00000002
	// is used, the error ERROR_INVALID_LEVEL is returned.
	//
	// Message processing is identical to NetrLogonControl2Ex (section 3.5.4.9.1), except
	// for the following:
	//
	// * The Data parameter of *NetrLogonControl2Ex* is set to NULL.
	Control(context.Context, *ControlRequest, ...dcerpc.CallOption) (*ControlResponse, error)

	// The NetrGetAnyDCName method MAY<162> be used to retrieve the name of a domain controller
	// in the specified primary or directly trusted domain. Only DCs can return the name
	// of a DC in a specified directly trusted domain.
	//
	// Return Values: The method returns 0x00000000 on success; otherwise, it MUST return
	// a nonzero error code and SHOULD return the following error code.
	//
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	|                   RETURN                   |                                                                                  |
	//	|                 VALUE/CODE                 |                                   DESCRIPTION                                    |
	//	|                                            |                                                                                  |
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000712 ERROR_DOMAIN_TRUST_INCONSISTENT | The name or security ID (SID) of the domain specified is inconsistent with the   |
	//	|                                            | trust information for that domain.                                               |
	//	+--------------------------------------------+----------------------------------------------------------------------------------+
	GetAnyDCName(context.Context, *GetAnyDCNameRequest, ...dcerpc.CallOption) (*GetAnyDCNameResponse, error)

	// The NetrLogonControl2 method<259> is a predecessor to the NetrLogonControl2Ex method
	// (section 3.5.4.9.1) and is updated to have the same functionality as NetrLogonControl2Ex.
	// All parameters of this method have the same meanings as the identically named parameters
	// of the NetrLogonControl2Ex method.
	//
	// All restrictions on parameter values in the NetrLoginControl2Ex method (section 3.5.4.9.1)
	// apply. Extra restrictions are applied to the values of the QueryLevel parameter as
	// follows:
	//
	// * If the QueryLevel parameter is set to 0x00000004, the error ERROR_INVALID_LEVEL
	// is returned.
	//
	// Message processing is identical to NetrLogonControl2Ex (section 3.5.4.9.1).
	Control2(context.Context, *Control2Request, ...dcerpc.CallOption) (*Control2Response, error)

	// The NetrServerAuthenticate2 method<176> is a predecessor to the NetrServerAuthenticate3
	// method, as specified in section 3.5.4.4.2. All parameters of this method have the
	// same meanings as the identically named parameters of the NetrServerAuthenticate3
	// method.
	//
	// Message processing is identical to NetrServerAuthenticate3, except for the following:
	//
	// The AccountRid parameter is not present in NetrServerAuthenticate2.
	Authenticate2(context.Context, *Authenticate2Request, ...dcerpc.CallOption) (*Authenticate2Response, error)

	// The NetrDatabaseSync2 method SHOULD<220> return a set of all changes applied to the
	// specified database since its creation. It provides an interface for a BDC to fully
	// synchronize its databases to those of the PDC. Because returning all changes in one
	// call might be prohibitively expensive due to a large amount of data being returned,
	// this method supports retrieving portions of the database changes in a series of calls
	// using a continuation context until all changes are received. It is possible for the
	// series of calls to be terminated prematurely due to external events, such as system
	// restarts. For that reason, the method also supports restarting the series of calls
	// at a particular point specified by the caller. The caller MUST keep track of synchronization
	// progress during the series of calls as detailed in this section.
	//
	// Return Values: The method returns 0x00000000 on success; otherwise, it returns a
	// nonzero error code.
	//
	// The server that receives this call MUST do the following:
	//
	// * Verify that the client is a backup domain controller (BDC) ( b5e7d25a-40b2-41c8-9611-98f53358af66#gt_ce1138c6-7ab4-4c37-98b4-95599071c3c3
	// ) , the server is a PDC, and is enabled. If any of these conditions are false, the
	// server MUST return the status code STATUS_NOT_SUPPORTED.
	//
	// * Apply Common Error Processing Rule B, specified in section 3 ( 2d776bfc-e81f-4c8f-9da8-4c2920f65413
	// ).
	//
	// * Using the ComputerName for the secure channel ( b5e7d25a-40b2-41c8-9611-98f53358af66#gt_08ce423c-9f9c-48ed-afa8-8b64c04ecdca
	// ) to find the corresponding record in the ClientSessionInfo table, verify the Authenticator
	// parameter (section 3.1.4.5 ( da7acaa3-030b-481e-979b-f58f89389806 ) ). If the Authenticator
	// parameter is valid, compute the ReturnAuthenticator parameter returned (section 3.1.4.5).
	// Otherwise, the server MUST return STATUS_ACCESS_DENIED.
	//
	// * Validate that DatabaseID is one of the allowed values, 0x00000000 through 0x00000002.
	// If the DatabaseID is not one of these values, the server MUST return the status code
	// STATUS_INVALID_LEVEL.
	//
	// * Given the RestartState parameter and the SyncContext parameter, obtain database
	// records that are missing on the BDC and return the array of deltas, NETLOGON_DELTA_ENUM_ARRAY,
	// for the missing records. The number of elements returned is affected by the value
	// of the PreferredMaximumLength parameter. The server SHOULD <222> ( 0c858a52-732a-43ec-85dd-e44b357c1898#Appendix_A_222
	// ) stop including elements in the returned array once the size of the returned data
	// equals or exceeds the value of the PreferredMaximumLength parameter. The server SHOULD
	// also limit the number of elements per local configuration to avoid large array allocations.
	//
	// * The server MUST update and return the SyncContext parameter (section 2.2.1.5.29
	// ( ffce9bbc-6ae5-4478-8f45-e82c3847aaa2 ) ) to continue the synchronization loop on
	// the next client request.
	//
	// * Compute and return the server authenticator.
	//
	// * Initialize *SynchronizationComplete* by setting it to FALSE, and when all the missing
	// records are sent set *SynchronizationComplete* to TRUE.
	//
	// * If *SynchronizationComplete* is FALSE, the server MUST return the status code STATUS_MORE_ENTRIES.
	DatabaseSync2(context.Context, *DatabaseSync2Request, ...dcerpc.CallOption) (*DatabaseSync2Response, error)

	// The NetrDatabaseRedo method SHOULD<224> be used by a backup domain controller (BDC)
	// to request information about a single account from the PDC.
	//
	// Return Values: The method returns 0x00000000 on success; otherwise, it returns a
	// nonzero error code.
	//
	// The following CHANGELOG_ENTRY structure pointed to by the ChangeLogEntry parameter
	// carries information about the account object being queried.
	//
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
	//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| SerialNumber [0..3]                                                                                                           |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| SerialNumber [4..7]                                                                                                           |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| ObjectRid                                                                                                                     |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| Flags                                                         | DBIndex                       | DeltaType                     |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| ObjectSid (optional, variable length) ...                                                                                     |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| ObjectName (optional, variable length) ...                                                                                    |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	DatabaseRedo(context.Context, *DatabaseRedoRequest, ...dcerpc.CallOption) (*DatabaseRedoResponse, error)

	// The NetrLogonControl2Ex method SHOULD<243> execute administrative actions that pertain
	// to the Netlogon server operation. It is used to query the status and control the
	// actions of the Netlogon server.
	//
	// Return Values: The method returns 0x00000000 on success; otherwise, it returns a
	// nonzero error code.
	Control2Ex(context.Context, *Control2ExRequest, ...dcerpc.CallOption) (*Control2ExResponse, error)

	// The NetrEnumerateTrustedDomains method SHOULD<227> return a set of NetBIOS names
	// of trusted domains.
	//
	// Return Values: The method returns 0x00000000 on success; otherwise, it SHOULD return
	// one of the following error codes.
	//
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	|                RETURN                 |                                                                                  |
	//	|              VALUE/CODE               |                                   DESCRIPTION                                    |
	//	|                                       |                                                                                  |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x0000051F ERROR_NO_LOGON_SERVERS     | There are currently no logon servers available to service the logon request.     |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000006FA ERROR_NO_TRUST_LSA_SECRET  | The workstation does not have a trust secret.                                    |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000006FB ERROR_NO_TRUST_SAM_ACCOUNT | The security database on the server does not have a computer account for this    |
	//	|                                       | workstation trust relationship.                                                  |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//
	// The server initializes the DomainNames field of the DOMAIN_NAME_BUFFER to the empty
	// string. The server calls the NetrEnumerateTrustedDomainsEx method and for each PDS_DOMAIN_TRUSTSW
	// element of the NETLOGON_TRUSTED_DOMAIN_ARRAY, appends the NetbiosDomainName field
	// to the DomainNames field of the DOMAIN_NAME_BUFFER (section 2.2.1.6.1). Then the
	// server terminates the DomainNames field with two null bytes.
	//
	// For details, see section 3.5.4.7.2, Receiving NetrEnumerateTrustedDomainsEx.
	EnumerateTrustedDomains(context.Context, *EnumerateTrustedDomainsRequest, ...dcerpc.CallOption) (*EnumerateTrustedDomainsResponse, error)

	// The DsrGetDcName method is a predecessor to the DsrGetDcNameEx2 method (section 3.5.4.3.1).
	// The method SHOULD<159> return information about a domain controller in the specified
	// domain. All parameters of this method have the same meanings as the identically named
	// parameters of the DsrGetDcNameEx2 method, except for the SiteGuid parameter, detailed
	// as follows.
	GetDCName(context.Context, *GetDCNameRequest, ...dcerpc.CallOption) (*GetDCNameResponse, error)

	// The NetrLogonGetCapabilities method is used by clients to confirm the server capabilities
	// after a secure channel has been established.<194>
	//
	// Return Values: The method returns 0x00000000 on success; otherwise, it returns a
	// nonzero error code.
	GetCapabilities(context.Context, *GetCapabilitiesRequest, ...dcerpc.CallOption) (*GetCapabilitiesResponse, error)

	// The NetrLogonSetServiceBits method SHOULD<237> be used to notify Netlogon whether
	// a domain controller is running specified services, as detailed in the following section.
	//
	// Return Values: The method returns 0x00000000 on success; otherwise, it returns a
	// nonzero error code.
	//
	// The server SHOULD<240> return ERROR_ACCESS_DENIED if the caller is not local.
	//
	// If the client does not have sufficient privilege, the server MUST return ERROR_ACCESS_DENIED.
	SetServiceBits(context.Context, *SetServiceBitsRequest, ...dcerpc.CallOption) (*SetServiceBitsResponse, error)

	// The NetrLogonGetTrustRid method SHOULD<231> be used to obtain the RID of the account
	// whose password is used by domain controllers in the specified domain for establishing
	// the secure channel from the server receiving this call.
	//
	// Return Values: The method returns 0x00000000 on success; otherwise, it returns a
	// nonzero error code.
	//
	// The server SHOULD<232> return ERROR_ACCESS_DENIED if the caller is not local.
	//
	// If ServerName equals NULL and DomainName equals NULL, the server determines if the
	// client has sufficient privilege (as specified in section 3.5.4.2) with the Access
	// Request mask set to NETLOGON_FTINFO_ACCESS.
	//
	// Otherwise, the server determines if the client has sufficient privilege (as specified
	// in section 3.5.4.2) with the Access Request mask set to NETLOGON_SERVICE_ACCESS.
	//
	// If the client does not have sufficient privilege, the server MUST return ERROR_ACCESS_DENIED.
	//
	// If ServerName equals NULL, then the call MUST be made to the local machine. If the
	// DomainName is the same as the domain that the machine is joined to, the call MUST
	// succeed, and the server MUST return the AccountRid of the machine in the domain.
	// If the DomainName is a different domain, the server MUST return ERROR_NO_SUCH_DOMAIN.
	//
	// If both ServerName and DomainName are NULL, the server MUST return the RID for the
	// computer account of the caller. Otherwise, the RID for the account identified by
	// ServerName and DomainName MUST be returned.
	//
	// The server uses the server name passed in the ServerName parameter to look up the
	// domain for the request. If the name is not found, the server MUST return ERROR_INVALID_COMPUTERNAME.
	//
	// If the RID cannot be determined, the server SHOULD return ERROR_TRUSTED_RELATIONSHIP_FAILURE.
	GetTrustRID(context.Context, *GetTrustRIDRequest, ...dcerpc.CallOption) (*GetTrustRIDResponse, error)

	// The NetrLogonComputeServerDigest method computes a cryptographic digest of a message
	// by using the MD5 message-digest algorithm, as specified in [RFC1321]. This method
	// SHOULD<233> be called by a client computer against a server and is used to compute
	// a message digest, as specified in this section. The client then calls the NetrLogonComputeClientDigest
	// method (as specified in section 3.4.5.6.3) and compare the digests to ensure that
	// the server that it communicates with knows the shared secret between the client machine
	// and the domain.
	//
	// Return Values: The method returns 0x00000000 on success; otherwise, it returns a
	// nonzero error code.
	//
	// The server uses the server name passed in the ServerName parameter to look up the
	// domain for the request. If the name is not found, the server MUST return ERROR_INVALID_COMPUTERNAME.
	//
	// If the client does not have sufficient privilege, the server MUST return ERROR_ACCESS_DENIED.
	ComputeServerDigest(context.Context, *ComputeServerDigestRequest, ...dcerpc.CallOption) (*ComputeServerDigestResponse, error)

	// The NetrLogonComputeClientDigest method is used by a client to compute a cryptographic
	// digest of a message by using the MD5 message-digest algorithm, as specified in [RFC1321].
	// This method is called by a client to compute a message digest, as specified in this
	// section. The client SHOULD<235> use this digest to compare against one that is returned
	// by a call to NetrLogonComputeServerDigest. This comparison allows the client to ensure
	// that the server that it communicates with knows the shared secret between the client
	// machine and the domain.
	//
	// Return Values: The method returns 0x00000000 on success; otherwise, it returns a
	// nonzero error code.
	//
	// If the client does not have sufficient privilege, the server MUST return ERROR_ACCESS_DENIED.
	ComputeClientDigest(context.Context, *ComputeClientDigestRequest, ...dcerpc.CallOption) (*ComputeClientDigestResponse, error)

	// The NetrServerAuthenticate3 method SHOULD<173> mutually authenticate the client and
	// the server and establish the session key to be used for the secure channel message
	// protection between the client and the server. It is called after the NetrServerReqChallenge
	// method, as specified in section 3.5.4.4.1.
	//
	// Return Values: The method returns 0x00000000 on success; otherwise, it returns a
	// nonzero error code.
	Authenticate3(context.Context, *Authenticate3Request, ...dcerpc.CallOption) (*Authenticate3Response, error)

	// The DsrGetDcNameEx method is a predecessor to the DsrGetDcNameEx2 (section 3.5.4.3.1)
	// method. The method SHOULD<158> return information about a domain controller in the
	// specified domain and site. All parameters of this method have the same meanings as
	// the identically named parameters of the DsrGetDcNameEx2 method.
	GetDCNameEx(context.Context, *GetDCNameExRequest, ...dcerpc.CallOption) (*GetDCNameExResponse, error)

	// The DsrGetSiteName method SHOULD<164> return the site name for the specified computer
	// that receives this call.
	//
	// Return Values: The method returns 0x00000000 on success; otherwise, it MUST return
	// a nonzero error code and SHOULD return the following error code.
	//
	//	+------------------------------+---------------------------------------------+
	//	|            RETURN            |                                             |
	//	|          VALUE/CODE          |                 DESCRIPTION                 |
	//	|                              |                                             |
	//	+------------------------------+---------------------------------------------+
	//	+------------------------------+---------------------------------------------+
	//	| 0x0000077F ERROR_NO_SITENAME | No site name is available for this machine. |
	//	+------------------------------+---------------------------------------------+
	//
	// If the computer has been configured with a SiteName, it MUST return the SiteName
	// immediately.
	//
	// If the DynamicSiteNameSetTime plus the DynamicSiteNameTimeout is less than the current
	// time (meaning that the DynamicSiteNameSetTime is older than allowed by DynamicSiteNameTimeout),
	// then:
	//
	// * The server MUST locate a domain controller ( b5e7d25a-40b2-41c8-9611-98f53358af66#gt_76a05049-3531-4abd-aec8-30e19954b4bd
	// ) in the domain. The server SHOULD <165> ( 0c858a52-732a-43ec-85dd-e44b357c1898#Appendix_A_165
	// ) implement alternate means to locate DCs: for example, a static list in a file,
	// or the two methods detailed in [MS-ADTS] ( ../ms-adts/d2435927-0999-4c62-8c6d-13ba31a52e1a
	// ) section 6.3.6 ( ../ms-adts/3e9711af-9067-435e-93fb-09182053cef7 ). If the server
	// cannot locate a DC for the domain, then the server MUST return ERROR_NO_SUCH_DOMAIN.
	//
	// * The server then populates the SiteName parameter with the NETLOGON_SAM_LOGON_RESPONSE_EX
	// message ([MS-ADTS] section 6.3.1.9 ( ../ms-adts/8401a33f-34a8-40ca-bf03-c3484b66265f
	// ) ) by setting the SiteName parameter to NETLOGON_SAM_LOGON_RESPONSE_EX.ClientSiteName.
	// The server stores the discovered site name in *DynamicSiteName*.
	//
	// * The server sets the DynamicSiteNameSetTime to the current time.
	//
	// Otherwise, DynamicSiteName MUST be returned immediately as the SiteName parameter.
	//
	// If it is determined that the server that receives this call has no site name, the
	// server MUST return ERROR_NO_SITENAME.
	//
	// This method also returns errors based on Common Error Processing Rules B and C, specified
	// in section 3.
	GetSiteName(context.Context, *GetSiteNameRequest, ...dcerpc.CallOption) (*GetSiteNameResponse, error)

	// The NetrLogonGetDomainInfo method SHOULD<188> return information that describes the
	// current domain to which the specified client belongs.
	//
	// Return Values: The method returns 0x00000000 on success; otherwise, it returns a
	// nonzero error code.
	GetDomainInfo(context.Context, *GetDomainInfoRequest, ...dcerpc.CallOption) (*GetDomainInfoResponse, error)

	// The NetrServerPasswordSet2 method SHOULD<178> allow the client to set a new clear
	// text password for an account used by the domain controller for setting up the secure
	// channel from the client. A domain member SHOULD<179> use this function to periodically
	// change its machine account password. A PDC uses this function to periodically change
	// the trust password for all directly trusted domains.
	//
	// Return Values: The method returns 0x00000000 on success; otherwise, it returns a
	// nonzero error code.
	PasswordSet2(context.Context, *PasswordSet2Request, ...dcerpc.CallOption) (*PasswordSet2Response, error)

	// The NetrServerPasswordGet method SHOULD<184> allow a BDC to get a machine account
	// password from the DC with the PDC role in the domain.
	//
	// Return Values: The method returns 0x00000000 on success; otherwise, it returns a
	// nonzero error code.
	PasswordGet(context.Context, *PasswordGetRequest, ...dcerpc.CallOption) (*PasswordGetResponse, error)

	// The NetrLogonSendToSam method allows a BDC or RODC to forward user account password
	// changes to the PDC. It SHOULD<236> be used by the client to deliver an opaque buffer
	// to the SAM database ([MS-SAMR] section 3.1.1) on the server side.
	//
	// Return Values: The method returns 0x00000000 on success; otherwise, it returns a
	// nonzero error code.
	SendToSAM(context.Context, *SendToSAMRequest, ...dcerpc.CallOption) (*SendToSAMResponse, error)

	// The DsrAddressToSiteNamesW method SHOULD<167> translate a list of socket addresses
	// into their corresponding site names. For details about the mapping from socket address
	// to subnet/site name, see [MS-ADTS] sections 6.1.1.2.2.1 and 6.1.1.2.2.2.
	//
	// Return Values: The method returns 0x00000000 on success; otherwise, it returns a
	// nonzero error code.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000008 ERROR_NOT_ENOUGH_MEMORY | Not enough storage is available to process this command.                         |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters is invalid. This error value is returned if the value of   |
	//	|                                    | EntryCount passed to DsrAddressToSiteNamesW is zero.                             |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// This method returns errors based on Common Error Processing Rule A, specified in
	// section 3.
	AddressToSiteNamesW(context.Context, *AddressToSiteNamesWRequest, ...dcerpc.CallOption) (*AddressToSiteNamesWResponse, error)

	// The DsrGetDcNameEx2 method SHOULD<147> return information about a domain controller
	// (DC) in the specified domain and site. If the AccountName parameter is not NULL,
	// and a DC matching the requested capabilities (as defined in the Flags parameter)
	// responds during this method call, then that DC will have verified that the DC account
	// database contains an account for the AccountName specified. The server that receives
	// this call is not required to be a DC.
	//
	// Return Values: The method returns 0x00000000 on success; otherwise, it returns a
	// nonzero error code.
	GetDCNameEx2(context.Context, *GetDCNameEx2Request, ...dcerpc.CallOption) (*GetDCNameEx2Response, error)

	// The NetrLogonGetTimeServiceParentDomain method SHOULD<241> return the name of the
	// parent domain of the current domain. The domain name returned by this method is suitable
	// for passing into the NetrLogonGetTrustRid method and NetrLogonComputeClientDigest
	// method.
	//
	// Return Values: The method returns 0x00000000 on success; otherwise, it returns a
	// nonzero error code.
	//
	// The server SHOULD<242> return ERROR_ACCESS_DENIED if the caller is not local.
	//
	// If the client does not have sufficient privilege, the server MUST return ERROR_ACCESS_DENIED.
	//
	// The domain name returned MUST be determined according to the following rules:
	//
	// * On a non-DC machine, the returned domain name is the name of the domain of which
	// the ServerName is a member. If ServerName is not valid, the server MUST return ERROR_INVALID_COMPUTERNAME.
	//
	// * On a DC that is at the root of the forest ( b5e7d25a-40b2-41c8-9611-98f53358af66#gt_fd104241-4fb3-457c-b2c4-e0c18bb20b62
	// ) , *rootDomainNamingContext* ( [MS-ADTS] ( ../ms-adts/d2435927-0999-4c62-8c6d-13ba31a52e1a
	// ) section 3.1.1.3.2.16 ( ../ms-adts/7ee04fa8-8027-4c7e-9c4a-4cd4c0198a70 ) ) is equal
	// to *defaultNamingContext* ([MS-ADTS] section 3.1.1.3.2.3 ( ../ms-adts/c1ad47fb-e4a1-4240-a749-b8f07ee0ae91
	// ) ). In this case, ERROR_NO_SUCH_DOMAIN is returned.
	//
	// * On a DC that is at the root of a domain tree ( b5e7d25a-40b2-41c8-9611-98f53358af66#gt_e2c071f1-5977-4749-868f-6c5a04929476
	// ) in the forest, the name of a trusted ( b5e7d25a-40b2-41c8-9611-98f53358af66#gt_5ee032d0-d944-4acb-bbb5-b1cfc7df6db6
	// ) domain that is also at the root of a domain tree in the forest is returned.
	//
	// On any other DC, the name of the domain that is directly the parent domain is returned.
	//
	// The domain's information MUST be retrieved from an implementation-specific directory.
	// Based on this retrieved information, if the domain has a DNS domain name, it MUST
	// be returned; otherwise, the NetBIOS domain name MUST be returned. This behavior is
	// functionally equivalent to locally invoking LsarQueryTrustedDomainInfo ([MS-LSAD]
	// section 3.1.4.7.2) for the domain, where TrustedDomainSid is the domain SID corresponding
	// to the appropriate domain name retrieved from a cached list, and InformationClass
	// is TrustedDomainInformationEx (policy handle is not needed locally), to return the
	// TrustedDomainInformationEx.Name string (DNS name) if it is present or TrustedDomainInformationEx.Flat
	// Name string (NetBIOS name) otherwise.
	//
	// The PdcSameSite returned MUST be determined according to the following rules:
	//
	// * On a non-DC machine, the value of PdcSameSite is set to TRUE.
	//
	// * On a DC machine, the server determines the PDC as specified in [MS-ADTS] section
	// 3.1.1.1.11 ( ../ms-adts/bf8afb5f-1ae0-45de-8445-8a717ea5124a ). Then the server determines
	// the sites of both the server and PDC as specified in [MS-ADTS] section 3.1.1.4.5.29
	// ( ../ms-adts/930d3ab8-7344-49f4-9615-a03d38279dff ). The server MUST compare the
	// PDC site with its own site, and if the two match, the PdcSameSite output parameter
	// MUST be set to TRUE; otherwise, it MUST be set to FALSE.
	GetTimeServiceParentDomain(context.Context, *GetTimeServiceParentDomainRequest, ...dcerpc.CallOption) (*GetTimeServiceParentDomainResponse, error)

	// The NetrEnumerateTrustedDomainsEx method SHOULD<226> return a list of trusted domains
	// from a specified server. This method extends NetrEnumerateTrustedDomains by returning
	// an array of domains in a more flexible DS_DOMAIN_TRUSTSW structure, as specified
	// in section 2.2.1.6.2, rather than the array of strings in DOMAIN_NAME_BUFFER structure,
	// as specified in section 2.2.1.6.1. The array is returned as part of the NETLOGON_TRUSTED_DOMAIN_ARRAY
	// structure, as specified in section 2.2.1.6.3.
	//
	// Return Values: The method returns 0x00000000 on success; otherwise, it SHOULD return
	// one of the following error codes.
	//
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	|                RETURN                 |                                                                                  |
	//	|              VALUE/CODE               |                                   DESCRIPTION                                    |
	//	|                                       |                                                                                  |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x0000051F ERROR_NO_LOGON_SERVERS     | There are currently no logon servers available to service the logon request.     |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000006FA ERROR_NO_TRUST_LSA_SECRET  | The workstation does not have a trust secret.                                    |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000006FB ERROR_NO_TRUST_SAM_ACCOUNT | The security database on the server does not have a computer account for this    |
	//	|                                       | workstation trust relationship.                                                  |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//
	// This method is a wrapper for DsrEnumerateDomainTrusts, which strips off the F flag
	// from the returned data for backward compatibility. For details, see section 3.5.4.7.1.
	EnumerateTrustedDomainsEx(context.Context, *EnumerateTrustedDomainsExRequest, ...dcerpc.CallOption) (*EnumerateTrustedDomainsExResponse, error)

	// The DsrAddressToSiteNamesExW method SHOULD<168> translate a list of socket addresses
	// into their corresponding site names and subnet names. For details about the mapping
	// from socket address to subnet/site name, see [MS-ADTS] sections 6.1.1.2.2.1 and 6.1.1.2.2.2.
	//
	// Return Values: The method returns 0x00000000 on success; otherwise, it SHOULD return
	// one of the following error codes.
	//
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	|               RETURN               |                                                                                  |
	//	|             VALUE/CODE             |                                   DESCRIPTION                                    |
	//	|                                    |                                                                                  |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000008 ERROR_NOT_ENOUGH_MEMORY | Not enough storage is available to process this command.                         |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000057 ERROR_INVALID_PARAMETER | One of the parameters is invalid. This error value is returned if the value of   |
	//	|                                    | EntryCount passed to DsrAddressToSiteNamesExW is zero.                           |
	//	+------------------------------------+----------------------------------------------------------------------------------+
	//
	// This method returns errors based on Common Error Processing Rule A, specified in
	// section 3.
	AddressToSiteNamesExW(context.Context, *AddressToSiteNamesExWRequest, ...dcerpc.CallOption) (*AddressToSiteNamesExWResponse, error)

	// The DsrGetDcSiteCoverageW method SHOULD<166> return a list of sites covered by a
	// domain controller. Site coverage is detailed in [MS-ADTS] section 6.1.1.2.2.
	//
	// Return Values: The method returns 0x00000000 on success; otherwise, it returns a
	// nonzero error code.
	//
	// This method returns errors based on Common Error Processing Rules A and B, specified
	// in section 3.
	GetDCSiteCoverageW(context.Context, *GetDCSiteCoverageWRequest, ...dcerpc.CallOption) (*GetDCSiteCoverageWResponse, error)

	// The NetrLogonSamLogonEx method SHOULD<199> provide an extension to NetrLogonSamLogon
	// that accepts an extra flags parameter and uses Secure RPC ([MS-RPCE] section 3.3.1.5.2)
	// instead of Netlogon authenticators. This method handles logon requests for the SAM
	// accounts and allows for generic pass-through authentication, as specified in section
	// 3.2.4.1.
	//
	// Return Values: The method returns 0x00000000 on success; otherwise, it returns a
	// nonzero error code.
	SAMLogonEx(context.Context, *SAMLogonExRequest, ...dcerpc.CallOption) (*SAMLogonExResponse, error)

	// The DsrEnumerateDomainTrusts method SHOULD<225> return an enumerated list of domain
	// trusts, filtered by a set of flags, from the specified server.
	//
	// Return Values: The method returns 0x00000000 on success; otherwise, it SHOULD return
	// one of the following error codes.
	//
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	|                RETURN                 |                                                                                  |
	//	|              VALUE/CODE               |                                   DESCRIPTION                                    |
	//	|                                       |                                                                                  |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x0000051F ERROR_NO_LOGON_SERVERS     | There are currently no logon servers available to service the logon request.     |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000006FA ERROR_NO_TRUST_LSA_SECRET  | The workstation does not have a trust secret.                                    |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	//	| 0x000006FB ERROR_NO_TRUST_SAM_ACCOUNT | The security database on the server does not have a computer account for this    |
	//	|                                       | workstation trust relationship.                                                  |
	//	+---------------------------------------+----------------------------------------------------------------------------------+
	EnumerateDomainTrusts(context.Context, *EnumerateDomainTrustsRequest, ...dcerpc.CallOption) (*EnumerateDomainTrustsResponse, error)

	// The DsrDeregisterDnsHostRecords method SHOULD<169> delete all of the DNS SRV records
	// registered by a specified domain controller. For the list of SRV records that a domain
	// registers, see [MS-ADTS] section 6.3.2.3, "SRV Records Registered by DC".
	//
	// Return Values: The method returns 0x00000000 on success; otherwise, it SHOULD return
	// the following error code.
	//
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	|             RETURN             |                                                                                  |
	//	|           VALUE/CODE           |                                   DESCRIPTION                                    |
	//	|                                |                                                                                  |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//	| 0x00000032 ERROR_NOT_SUPPORTED | The request is not supported. This error value is returned when                  |
	//	|                                | DsrDeregisterDnsHostRecords is called on a machine that is not a DC.             |
	//	+--------------------------------+----------------------------------------------------------------------------------+
	//
	// The server determines if the client has sufficient privileges (as specified in section
	// 3.5.4.2) with the Access Request mask set to the NETLOGON_CONTROL_ACCESS mask.
	//
	// If the client does not have sufficient privilege, the server MUST return ERROR_ACCESS_DENIED.
	//
	// If the DnsHostName parameter is not null, the server MUST attempt to delete the DNS
	// SRV records registered for the DC DnsHostName, as specified in [MS-ADTS] section
	// 6.3.2.3.
	//
	// If the DomainGuid parameter is not null, then the server MUST attempt to delete the
	// domain-GUID-based SRV record.
	//
	// If the DsaGuid parameter is not null, then the server MUST attempt to delete the
	// domain CNAME record.
	//
	// The deletion of site-specific records MUST be attempted for every site in the enterprise
	// of the DC on which the method is executed.
	//
	// Unless stated otherwise, if the attempt to delete any records documented previously
	// fails for any reason, then the server MUST ignore the error and continue message
	// processing.
	//
	// It is possible that this method call will create a time-consuming run that generates
	// significant network traffic for enterprises with many sites.
	DeregisterDNSHostRecords(context.Context, *DeregisterDNSHostRecordsRequest, ...dcerpc.CallOption) (*DeregisterDNSHostRecordsResponse, error)

	// The NetrServerTrustPasswordsGet method SHOULD<186> return the encrypted current and
	// previous passwords for an account in the domain. This method is called by a client
	// to retrieve the current and previous account passwords from a domain controller.
	// The account name requested MUST be the name used when the secure channel was created,
	// unless the method is called on a PDC by a DC, in which case it can be any valid account
	// name.
	//
	// Return Values: The method returns 0x00000000 on success; otherwise, it returns a
	// nonzero error code.
	//
	// Message processing is identical to NetrServerGetTrustInfo, as specified in section
	// 3.5.4.7.6, except for the following:
	//
	// * The TrustInfo parameter is not present in NetrServerTrustPasswordsGet.
	TrustPasswordsGet(context.Context, *TrustPasswordsGetRequest, ...dcerpc.CallOption) (*TrustPasswordsGetResponse, error)

	// The DsrGetForestTrustInformation method SHOULD<229> retrieve the trust information
	// for the forest of the specified domain controller (DC), or for a forest trusted by
	// the forest of the specified DC.
	//
	// Return Values: The method returns 0x00000000 on success; otherwise, it SHOULD return
	// the following error code.
	//
	//	+-----------------------------------+---------------------+
	//	|              RETURN               |                     |
	//	|            VALUE/CODE             |     DESCRIPTION     |
	//	|                                   |                     |
	//	+-----------------------------------+---------------------+
	//	+-----------------------------------+---------------------+
	//	| 0x00000001 ERROR_INVALID_FUNCTION | Incorrect function. |
	//	+-----------------------------------+---------------------+
	GetForestTrustInformation(context.Context, *GetForestTrustInformationRequest, ...dcerpc.CallOption) (*GetForestTrustInformationResponse, error)

	// The NetrGetForestTrustInformation method SHOULD<228> retrieve the trust information
	// for the forest of which the member's domain is itself a member.
	//
	// Return Values: The method returns 0x00000000 on success; otherwise, it returns a
	// nonzero error code.
	GetNetrForestTrustInformation(context.Context, *GetNetrForestTrustInformationRequest, ...dcerpc.CallOption) (*GetNetrForestTrustInformationResponse, error)

	// The NetrLogonSamLogonWithFlags method SHOULD<210> handle logon requests for the SAM
	// accounts.
	//
	// Return Values: The method returns 0x00000000 on success; otherwise, it returns a
	// nonzero error code.
	//
	// Message processing is identical to NetrLogonSamLogon, as specified in section 3.5.4.5.3,
	// except for the following:
	//
	// * NetrLogonSamLogonWithFlags contains an additional parameter named ExtraFlags.
	SAMLogonWithFlags(context.Context, *SAMLogonWithFlagsRequest, ...dcerpc.CallOption) (*SAMLogonWithFlagsResponse, error)

	// The NetrServerGetTrustInfo method SHOULD<230> return an information block from a
	// specified server. The information includes encrypted current and previous passwords
	// for a particular account and additional trust data. The account name requested MUST
	// be the name used when the secure channel was created, unless the method is called
	// on a PDC by a domain controller, in which case it can be any valid account name.
	//
	// Return Values: The method returns 0x00000000 to indicate success; otherwise, it returns
	// a nonzero error code.
	GetTrustInfo(context.Context, *GetTrustInfoRequest, ...dcerpc.CallOption) (*GetTrustInfoResponse, error)

	// OpnumUnused47 operation.
	// OpnumUnused47

	// The DsrUpdateReadOnlyServerDnsRecords method SHOULD<170> allow an RODC to send a
	// control command to a normal (writable) DC for site-specific and CName types of DNS
	// records update. For registration, site-specific records are for the site in which
	// RODC resides. For the types of DNS records, see [MS-ADTS] section 6.3.2.
	//
	// Return Values: The method returns 0x00000000 (NO_ERROR) on success; otherwise, it
	// returns a nonzero error code.
	UpdateReadOnlyServerDNSRecords(context.Context, *UpdateReadOnlyServerDNSRecordsRequest, ...dcerpc.CallOption) (*UpdateReadOnlyServerDNSRecordsResponse, error)

	// The NetrChainSetClientAttributes method SHOULD<198> be invoked by an RODC  on a
	// normal (writable) DC to update to a client's computer account object in Active Directory
	// when it receives either the NetrServerAuthenticate3 method or the NetrLogonGetDomainInfo
	// method with updates requested.
	//
	// Return Values: The method returns 0x00000000 on success.
	ChainSetClientAttributes(context.Context, *ChainSetClientAttributesRequest, ...dcerpc.CallOption) (*ChainSetClientAttributesResponse, error)

	// AlterContext alters the client context.
	AlterContext(context.Context, ...dcerpc.Option) error

	// Conn returns the client connection (unsafe)
	Conn() dcerpc.Conn
}

// IdentityCleartextPasswordAllowed represents the IDENTITY_CLEARTEXT_PASSWORD_ALLOWED RPC constant
const IdentityCleartextPasswordAllowed = 0x00000002

// IdentityUpdateLogonStatistics represents the IDENTITY_UPDATE_LOGON_STATISTICS RPC constant
const IdentityUpdateLogonStatistics = 0x00000004

// IdentityReturnUserParameters represents the IDENTITY_RETURN_USER_PARAMETERS RPC constant
const IdentityReturnUserParameters = 0x00000008

// IdentityDontTryGuestAccount represents the IDENTITY_DONT_TRY_GUEST_ACCOUNT RPC constant
const IdentityDontTryGuestAccount = 0x00000010

// IdentityAllowServerTrustAccount represents the IDENTITY_ALLOW_SERVER_TRUST_ACCOUNT RPC constant
const IdentityAllowServerTrustAccount = 0x00000020

// IdentityReturnPasswordExpiry represents the IDENTITY_RETURN_PASSWORD_EXPIRY RPC constant
const IdentityReturnPasswordExpiry = 0x00000040

// IdentityUseClientChallenge represents the IDENTITY_USE_CLIENT_CHALLENGE RPC constant
const IdentityUseClientChallenge = 0x00000080

// IdentityTryGuestAccountOnly represents the IDENTITY_TRY_GUEST_ACCOUNT_ONLY RPC constant
const IdentityTryGuestAccountOnly = 0x00000100

// IdentityReturnProfilePath represents the IDENTITY_RETURN_PROFILE_PATH RPC constant
const IdentityReturnProfilePath = 0x00000200

// IdentityTrySpecifiedDomainOnly represents the IDENTITY_TRY_SPECIFIED_DOMAIN_ONLY RPC constant
const IdentityTrySpecifiedDomainOnly = 0x00000400

// IdentityAllowWorkstationTrustAccount represents the IDENTITY_ALLOW_WORKSTATION_TRUST_ACCOUNT RPC constant
const IdentityAllowWorkstationTrustAccount = 0x00000800

// IdentityDisablePersonalFallback represents the IDENTITY_DISABLE_PERSONAL_FALLBACK RPC constant
const IdentityDisablePersonalFallback = 0x00001000

// IdentityAllowForceGuest represents the IDENTITY_ALLOW_FORCE_GUEST RPC constant
const IdentityAllowForceGuest = 0x00002000

// IdentityCleartextPasswordSupplied represents the IDENTITY_CLEARTEXT_PASSWORD_SUPPLIED RPC constant
const IdentityCleartextPasswordSupplied = 0x00004000

// IdentityAllowNTLMv1 represents the IDENTITY_ALLOW_NTLM_V1 RPC constant
const IdentityAllowNTLMv1 = 0x00010000

// IdentityUseSubAuthentication represents the IDENTITY_USE_SUB_AUTHENTICATION RPC constant
const IdentityUseSubAuthentication = 0x00100000

// IdentityUseSubAuthenticationPackageIDMask represents the IDENTITY_USE_SUB_AUTHENTICATION_PACKAGE_ID_MASK RPC constant
const IdentityUseSubAuthenticationPackageIDMask = 0xFF000000

// DSForceRediscovery represents the DS_FORCE_REDISCOVERY RPC constant
const DSForceRediscovery = 0x00000001

// DSDirectoryServiceRequired represents the DS_DIRECTORY_SERVICE_REQUIRED RPC constant
const DSDirectoryServiceRequired = 0x00000010

// DSDirectoryServicePreferred represents the DS_DIRECTORY_SERVICE_PREFERRED RPC constant
const DSDirectoryServicePreferred = 0x00000020

// DSGCServerRequired represents the DS_GC_SERVER_REQUIRED RPC constant
const DSGCServerRequired = 0x00000040

// DSPDCRequired represents the DS_PDC_REQUIRED RPC constant
const DSPDCRequired = 0x00000080

// DSBackgroundOnly represents the DS_BACKGROUND_ONLY RPC constant
const DSBackgroundOnly = 0x00000100

// DSIPRequired represents the DS_IP_REQUIRED RPC constant
const DSIPRequired = 0x00000200

// DSKDCRequired represents the DS_KDC_REQUIRED RPC constant
const DSKDCRequired = 0x00000400

// DSTimeServerRequired represents the DS_TIME_SERVER_REQUIRED RPC constant
const DSTimeServerRequired = 0x00000800

// DSWritableRequired represents the DS_WRITABLE_REQUIRED RPC constant
const DSWritableRequired = 0x00001000

// DSGoodTimeServerPreferred represents the DS_GOOD_TIME_SERVER_PREFERRED RPC constant
const DSGoodTimeServerPreferred = 0x00002000

// DSAvoidSelf represents the DS_AVOID_SELF RPC constant
const DSAvoidSelf = 0x00004000

// DSOnlyLDAPNeeded represents the DS_ONLY_LDAP_NEEDED RPC constant
const DSOnlyLDAPNeeded = 0x00008000

// DSIsFlatName represents the DS_IS_FLAT_NAME RPC constant
const DSIsFlatName = 0x00010000

// DSIsDNSName represents the DS_IS_DNS_NAME RPC constant
const DSIsDNSName = 0x00020000

// DSTryNextClosestSite represents the DS_TRY_NEXT_CLOSEST_SITE RPC constant
const DSTryNextClosestSite = 0x00040000

// DSDirectoryService6Required represents the DS_DIRECTORY_SERVICE_6_REQUIRED RPC constant
const DSDirectoryService6Required = 0x00080000

// DSWebServiceRequired represents the DS_WEB_SERVICE_REQUIRED RPC constant
const DSWebServiceRequired = 0x00100000

// DSReturnDNSName represents the DS_RETURN_DNS_NAME RPC constant
const DSReturnDNSName = 0x40000000

// DSReturnFlatName represents the DS_RETURN_FLAT_NAME RPC constant
const DSReturnFlatName = 0x80000000

// TrustTypeForestMember represents the TRUST_TYPE_FOREST_MEMBER RPC constant
const TrustTypeForestMember = 0x00000001

// TrustTypeDirectlyTrusted represents the TRUST_TYPE_DIRECTLY_TRUSTED RPC constant
const TrustTypeDirectlyTrusted = 0x00000002

// TrustTypeDomainTreeRoot represents the TRUST_TYPE_DOMAIN_TREE_ROOT RPC constant
const TrustTypeDomainTreeRoot = 0x00000004

// TrustTypePrimaryDomain represents the TRUST_TYPE_PRIMARY_DOMAIN RPC constant
const TrustTypePrimaryDomain = 0x00000008

// TrustTypeNativeMode represents the TRUST_TYPE_NATIVE_MODE RPC constant
const TrustTypeNativeMode = 0x00000010

// TrustTypeDirectlyTrusts represents the TRUST_TYPE_DIRECTLY_TRUSTS RPC constant
const TrustTypeDirectlyTrusts = 0x00000020

// String structure represents STRING RPC structure.
//
// The STRING structure contains the length, the maximum length, and a pointer to a
// buffer containing the string.
type String struct {
	// Length: The length of the data pointed to by Buffer, in bytes.
	Length uint16 `idl:"name:Length" json:"length"`
	// MaximumLength: The total allocated length of the data pointed to by Buffer, in bytes.<6>
	MaximumLength uint16 `idl:"name:MaximumLength" json:"maximum_length"`
	// Buffer: A pointer to a buffer containing the character string.
	Buffer []byte `idl:"name:Buffer;size_is:(MaximumLength);length_is:(Length)" json:"buffer"`
}

func (o *String) xxx_PreparePayload(ctx context.Context) error {
	if o.Buffer != nil && o.MaximumLength == 0 {
		o.MaximumLength = uint16(len(o.Buffer))
	}
	if o.Buffer != nil && o.Length == 0 {
		o.Length = uint16(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *String) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(7); err != nil {
		return err
	}
	if err := w.WriteData(o.Length); err != nil {
		return err
	}
	if err := w.WriteData(o.MaximumLength); err != nil {
		return err
	}
	if o.Buffer != nil || o.MaximumLength > 0 {
		_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.MaximumLength)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			dimLength1 := uint64(o.Length)
			if dimLength1 > sizeInfo[0] {
				dimLength1 = sizeInfo[0]
			} else {
				sizeInfo[0] = dimLength1
			}
			if err := w.WriteSize(0); err != nil {
				return err
			}
			if err := w.WriteSize(dimLength1); err != nil {
				return err
			}
			for i1 := range o.Buffer {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.Buffer[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *String) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(7); err != nil {
		return err
	}
	if err := w.ReadData(&o.Length); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaximumLength); err != nil {
		return err
	}
	_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
		}
		o.Buffer = make([]byte, sizeInfo[0])
		for i1 := range o.Buffer {
			i1 := i1
			if err := w.ReadData(&o.Buffer[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
		return err
	}
	return nil
}

// OldLargeInteger structure represents OLD_LARGE_INTEGER RPC structure.
type OldLargeInteger struct {
	LowPart  uint32 `idl:"name:LowPart" json:"low_part"`
	HighPart int32  `idl:"name:HighPart" json:"high_part"`
}

func (o *OldLargeInteger) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *OldLargeInteger) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.LowPart); err != nil {
		return err
	}
	if err := w.WriteData(o.HighPart); err != nil {
		return err
	}
	return nil
}
func (o *OldLargeInteger) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.LowPart); err != nil {
		return err
	}
	if err := w.ReadData(&o.HighPart); err != nil {
		return err
	}
	return nil
}

// CypherBlock structure represents CYPHER_BLOCK RPC structure.
//
// The CYPHER_BLOCK structure defines an encrypted eight-character string. The type
// of encryption used is application dependent.
type CypherBlock struct {
	// data: An encrypted eight-character string.
	Data []byte `idl:"name:data" json:"data"`
}

func (o *CypherBlock) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *CypherBlock) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	for i1 := range o.Data {
		i1 := i1
		if uint64(i1) >= 8 {
			break
		}
		if err := w.WriteData(o.Data[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Data); uint64(i1) < 8; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	return nil
}
func (o *CypherBlock) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	o.Data = make([]byte, 8)
	for i1 := range o.Data {
		i1 := i1
		if err := w.ReadData(&o.Data[i1]); err != nil {
			return err
		}
	}
	return nil
}

// NTOWFPassword structure represents NT_OWF_PASSWORD RPC structure.
//
// The NT_OWF_PASSWORD structure SHOULD<7> define a one-way function (OWF) of a domain
// password. The NT_OWF_PASSWORD structure SHOULD be encrypted, as specified by each
// method that uses this structure. When this structure is encrypted, Netlogon methods
// uses the DES encryption algorithm in ECB mode, as specified in [MS-SAMR] section
// 2.2.11.1.1 Encrypting an NT Hash or LM Hash Value with a specified key. The session
// key is the specified 16-byte key used to derive its keys using the 16-byte value
// process, as specified in [MS-SAMR] section 2.2.11.1.4. For specific encryption information,
// see the individual methods, such as NetrServerTrustPasswordsGet (section 3.5.4.4.8)
// and NetrServerGetTrustInfo (section 3.5.4.7.6).
type NTOWFPassword struct {
	// data: An array of CYPHER_BLOCK structures (section 2.2.1.1.1) that contains the NTOWFv1
	// of a password. NTOWFv1 is specified in NTLM v1 Authentication in [MS-NLMP] section
	// 3.3.1.
	Data []*CypherBlock `idl:"name:data" json:"data"`
}

func (o *NTOWFPassword) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *NTOWFPassword) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	for i1 := range o.Data {
		i1 := i1
		if uint64(i1) >= 2 {
			break
		}
		if o.Data[i1] != nil {
			if err := o.Data[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&CypherBlock{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.Data); uint64(i1) < 2; i1++ {
		if err := (&CypherBlock{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *NTOWFPassword) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	o.Data = make([]*CypherBlock, 2)
	for i1 := range o.Data {
		i1 := i1
		if o.Data[i1] == nil {
			o.Data[i1] = &CypherBlock{}
		}
		if err := o.Data[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// EncryptedNTOWFPassword structure represents ENCRYPTED_NT_OWF_PASSWORD RPC structure.
type EncryptedNTOWFPassword struct {
	Data []*CypherBlock `idl:"name:data" json:"data"`
}

func (o *EncryptedNTOWFPassword) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *EncryptedNTOWFPassword) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	for i1 := range o.Data {
		i1 := i1
		if uint64(i1) >= 2 {
			break
		}
		if o.Data[i1] != nil {
			if err := o.Data[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&CypherBlock{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.Data); uint64(i1) < 2; i1++ {
		if err := (&CypherBlock{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *EncryptedNTOWFPassword) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	o.Data = make([]*CypherBlock, 2)
	for i1 := range o.Data {
		i1 := i1
		if o.Data[i1] == nil {
			o.Data[i1] = &CypherBlock{}
		}
		if err := o.Data[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// LMOWFPassword structure represents LM_OWF_PASSWORD RPC structure.
//
// The LM_OWF_PASSWORD structure carries a one-way function (OWF) of a LAN Manager password.
// The LM_OWF_PASSWORD structure SHOULD be encrypted, as specified by each method that
// uses this structure. See the NetrServerPasswordSet method (section 3.5.4.4.6) for
// encryption information.
type LMOWFPassword struct {
	// data: An array of CYPHER_BLOCK structures (section 2.2.1.1.1) that contains the LMOWFv1
	// of a password. LMOWFv1 is specified in NTLM v1 Authentication in [MS-NLMP] section
	// 3.3.1.
	Data []*CypherBlock `idl:"name:data" json:"data"`
}

func (o *LMOWFPassword) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *LMOWFPassword) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	for i1 := range o.Data {
		i1 := i1
		if uint64(i1) >= 2 {
			break
		}
		if o.Data[i1] != nil {
			if err := o.Data[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&CypherBlock{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.Data); uint64(i1) < 2; i1++ {
		if err := (&CypherBlock{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *LMOWFPassword) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	o.Data = make([]*CypherBlock, 2)
	for i1 := range o.Data {
		i1 := i1
		if o.Data[i1] == nil {
			o.Data[i1] = &CypherBlock{}
		}
		if err := o.Data[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// EncryptedLMOWFPassword structure represents ENCRYPTED_LM_OWF_PASSWORD RPC structure.
type EncryptedLMOWFPassword struct {
	Data []*CypherBlock `idl:"name:data" json:"data"`
}

func (o *EncryptedLMOWFPassword) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *EncryptedLMOWFPassword) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	for i1 := range o.Data {
		i1 := i1
		if uint64(i1) >= 2 {
			break
		}
		if o.Data[i1] != nil {
			if err := o.Data[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&CypherBlock{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.Data); uint64(i1) < 2; i1++ {
		if err := (&CypherBlock{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *EncryptedLMOWFPassword) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	o.Data = make([]*CypherBlock, 2)
	for i1 := range o.Data {
		i1 := i1
		if o.Data[i1] == nil {
			o.Data[i1] = &CypherBlock{}
		}
		if err := o.Data[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// SIDInformation structure represents NLPR_SID_INFORMATION RPC structure.
//
// The NLPR_SID_INFORMATION structure is used to form a wrapper for a SID; it is used
// to transmit a SID during certain replication operations. See section 3.6 for details.
type SIDInformation struct {
	// SidPointer: A pointer to a SID structure ([MS-DTYP] section 2.4.2.3).
	SIDPointer *dtyp.SID `idl:"name:SidPointer" json:"sid_pointer"`
}

func (o *SIDInformation) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *SIDInformation) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(6); err != nil {
		return err
	}
	if o.SIDPointer != nil {
		_ptr_SidPointer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.SIDPointer != nil {
				if err := o.SIDPointer.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&dtyp.SID{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.SIDPointer, _ptr_SidPointer); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *SIDInformation) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(6); err != nil {
		return err
	}
	_ptr_SidPointer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.SIDPointer == nil {
			o.SIDPointer = &dtyp.SID{}
		}
		if err := o.SIDPointer.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_SidPointer := func(ptr interface{}) { o.SIDPointer = *ptr.(**dtyp.SID) }
	if err := w.ReadPointer(&o.SIDPointer, _s_SidPointer, _ptr_SidPointer); err != nil {
		return err
	}
	return nil
}

// SIDArray structure represents NLPR_SID_ARRAY RPC structure.
//
// The NLPR_SID_ARRAY structure defines an array of pointers to security identifier
// structures.
type SIDArray struct {
	// Count: The number of pointers in the Sids array.
	Count uint32 `idl:"name:Count" json:"count"`
	// Sids: An array of NLPR_SID_INFORMATION structures, as specified in section 2.2.1.5.5,
	// each of which is a pointer to a SID.
	SIDs []*SIDInformation `idl:"name:Sids;size_is:(Count)" json:"sids"`
}

func (o *SIDArray) xxx_PreparePayload(ctx context.Context) error {
	if o.SIDs != nil && o.Count == 0 {
		o.Count = uint32(len(o.SIDs))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *SIDArray) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.Count); err != nil {
		return err
	}
	if o.SIDs != nil || o.Count > 0 {
		_ptr_Sids := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.Count)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.SIDs {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.SIDs[i1] != nil {
					if err := o.SIDs[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&SIDInformation{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.SIDs); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&SIDInformation{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.SIDs, _ptr_Sids); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *SIDArray) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.Count); err != nil {
		return err
	}
	_ptr_Sids := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.Count > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.Count)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.SIDs", sizeInfo[0])
		}
		o.SIDs = make([]*SIDInformation, sizeInfo[0])
		for i1 := range o.SIDs {
			i1 := i1
			if o.SIDs[i1] == nil {
				o.SIDs[i1] = &SIDInformation{}
			}
			if err := o.SIDs[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_Sids := func(ptr interface{}) { o.SIDs = *ptr.(*[]*SIDInformation) }
	if err := w.ReadPointer(&o.SIDs, _s_Sids, _ptr_Sids); err != nil {
		return err
	}
	return nil
}

// CRCipherValue structure represents NLPR_CR_CIPHER_VALUE RPC structure.
//
// The NLPR_CR_CIPHER_VALUE structure defines an encrypted string buffer that contains
// the value of an LSA Secret Object as specified in [MS-LSAD].
type CRCipherValue struct {
	// Length: The length, in bytes, of the used portion of the buffer.
	Length uint32 `idl:"name:Length" json:"length"`
	// MaximumLength: The maximum length, in bytes, of the buffer.
	MaximumLength uint32 `idl:"name:MaximumLength" json:"maximum_length"`
	// Buffer: A pointer to a buffer that contains the secret data encrypted with the session
	// key used on the secure channel between the client and the server exchanging this
	// data structure. The encryption algorithm is RC4 if the flag C is set in the negotiated
	// flags between the client and the server as detailed in section 3.1.4.2; otherwise
	// the encryption algorithm is DES.
	Buffer []byte `idl:"name:Buffer;size_is:(MaximumLength);length_is:(Length)" json:"buffer"`
}

func (o *CRCipherValue) xxx_PreparePayload(ctx context.Context) error {
	if o.Buffer != nil && o.MaximumLength == 0 {
		o.MaximumLength = uint32(len(o.Buffer))
	}
	if o.Buffer != nil && o.Length == 0 {
		o.Length = uint32(len(o.Buffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *CRCipherValue) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.Length); err != nil {
		return err
	}
	if err := w.WriteData(o.MaximumLength); err != nil {
		return err
	}
	if o.Buffer != nil || o.MaximumLength > 0 {
		_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.MaximumLength)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			dimLength1 := uint64(o.Length)
			if dimLength1 > sizeInfo[0] {
				dimLength1 = sizeInfo[0]
			} else {
				sizeInfo[0] = dimLength1
			}
			if err := w.WriteSize(0); err != nil {
				return err
			}
			if err := w.WriteSize(dimLength1); err != nil {
				return err
			}
			for i1 := range o.Buffer {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.Buffer[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *CRCipherValue) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.Length); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaximumLength); err != nil {
		return err
	}
	_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
		}
		o.Buffer = make([]byte, sizeInfo[0])
		for i1 := range o.Buffer {
			i1 := i1
			if err := w.ReadData(&o.Buffer[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
		return err
	}
	return nil
}

// LogonHours structure represents NLPR_LOGON_HOURS RPC structure.
//
// The NLPR_LOGON_HOURS structure contains the logon policy information that specifies
// when a user account is permitted to authenticate.
//
// The fields in this structure have the same meanings as identically named fields of
// the SAMPR_LOGON_HOURS structure, as specified in [MS-SAMR] section 2.2.6.5.
type LogonHours struct {
	UnitsPerWeek uint16 `idl:"name:UnitsPerWeek" json:"units_per_week"`
	LogonHours   []byte `idl:"name:LogonHours;size_is:(1260);length_is:(((UnitsPerWeek+7)/8))" json:"logon_hours"`
}

func (o *LogonHours) xxx_PreparePayload(ctx context.Context) error {
	// cannot evaluate expression 1260
	if o.LogonHours != nil && o.UnitsPerWeek == 0 {
		o.UnitsPerWeek = uint16(((len(o.LogonHours) * 8) - 7))
		if len(o.LogonHours) < 7 {
			o.UnitsPerWeek = uint16(0)
		}
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *LogonHours) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(7); err != nil {
		return err
	}
	if err := w.WriteData(o.UnitsPerWeek); err != nil {
		return err
	}
	if o.LogonHours != nil || 1260 > 0 {
		_ptr_LogonHours := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(1260)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			dimLength1 := uint64(((o.UnitsPerWeek + 7) / 8))
			if dimLength1 > sizeInfo[0] {
				dimLength1 = sizeInfo[0]
			} else {
				sizeInfo[0] = dimLength1
			}
			if err := w.WriteSize(0); err != nil {
				return err
			}
			if err := w.WriteSize(dimLength1); err != nil {
				return err
			}
			for i1 := range o.LogonHours {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.LogonHours[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.LogonHours); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.LogonHours, _ptr_LogonHours); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *LogonHours) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(7); err != nil {
		return err
	}
	if err := w.ReadData(&o.UnitsPerWeek); err != nil {
		return err
	}
	_ptr_LogonHours := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.LogonHours", sizeInfo[0])
		}
		o.LogonHours = make([]byte, sizeInfo[0])
		for i1 := range o.LogonHours {
			i1 := i1
			if err := w.ReadData(&o.LogonHours[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_LogonHours := func(ptr interface{}) { o.LogonHours = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.LogonHours, _s_LogonHours, _ptr_LogonHours); err != nil {
		return err
	}
	return nil
}

// UserPrivateInfo structure represents NLPR_USER_PRIVATE_INFO RPC structure.
//
// The NLPR_USER_PRIVATE_INFO structure defines a data buffer that is optionally encrypted
// with the session key, as detailed in this section. The structure is used to carry
// user account passwords as follows.
type UserPrivateInfo struct {
	// SensitiveData: Is either TRUE (0x01) or FALSE (0x00). The SensitiveData field indicates
	// whether the data is encrypted as follows. If this field is set to 0x00, then the
	// data is not encrypted. If the field is set to 0x01, the data pointed to by the Data
	// field is encrypted with the session key used on the secure channel between the client
	// and the server exchanging this data structure to the client. The encryption algorithm
	// is RC4 if the flag C is set in the negotiated flags between the client and the server,
	// as specified in section 3.1.4.2; otherwise the encryption algorithm is DES.
	SensitiveData uint8 `idl:"name:SensitiveData" json:"sensitive_data"`
	// DataLength: The size, in bytes, of the Data field.
	DataLength uint32 `idl:"name:DataLength" json:"data_length"`
	// Data: A pointer to a buffer with a size of DataLength. If the SensitiveData field
	// is set to TRUE, this data is encrypted as defined in the SensitiveData field. The
	// buffer content prior to encryption (if any) is shown in the following table.
	//
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
	//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| DataType                                                                                                                      |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| LmLength                                                      | LmMaximumLength                                               |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| Unused1                                                                                                                       |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| LmHash[0..3]                                                                                                                  |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| LmHash[4..7]                                                                                                                  |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| LmHash[8..11]                                                                                                                 |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| LmHash[12..15]                                                                                                                |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| NtLength                                                      | NtMaximumLength                                               |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| Unused2                                                                                                                       |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| NtHash[0..3]                                                                                                                  |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| NtHash[4..7]                                                                                                                  |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| NtHash[8..11]                                                                                                                 |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| NtHash[12..15]                                                                                                                |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| LmHistoryLength                                               | LmHistoryMaximumLength                                        |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| Unused3                                                                                                                       |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| NtHistoryLength                                               | NtHistoryMaximumLength                                        |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| Unused4                                                                                                                       |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| NtHistoryArray (variable)                                                                                                     |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| ...                                                                                                                           |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| LmHistoryArray (variable)                                                                                                     |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| ...                                                                                                                           |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//
	// DataType: An unsigned integer. This value MUST be 0x00000002.
	//
	// LmLength: An unsigned (short) integer. This value MUST be either 0x0010 or 0x0000.
	// If 0x0010, the LmHash field contains the LM hash of the user password (specified
	// in [MS-NLMP]). If 0x0000, the value of the LmHash field is undefined and MUST be
	// ignored upon receipt.
	//
	// LmMaximumLength: This value MUST be the same value as LmLength.
	//
	// Unused1: This value MUST be zero and ignored on receipt.
	//
	// LmHash: The encrypted ([MS-SAMR] section 2.2.11.1) LM OWF ([MS-NLMP] section 3.3)
	// of the user password. The 16-byte encryption key is created by concatenating four
	// times the relative ID (from the given user's SID).
	//
	// NtLength: An unsigned (short) integer. This value MUST be either 0x0010 or 0x0000.
	// If 0x0010, the NtHash field contains the NT hash of the user password (specified
	// in [MS-NLMP]). If 0x0000, the value of the NtHash field is undefined and MUST be
	// ignored upon receipt.
	//
	// NtMaximumLength: This value MUST be the same value as NtLength.
	//
	// Unused2: This value MUST be zero and ignored on receipt.
	//
	// NtHash: The encrypted ([MS-SAMR] section 2.2.11.1) NT OWF ([MS-NLMP] section 3.3)
	// of the user password. The 16-byte encryption key is created by concatenating four
	// times the relative ID (from the given user's SID).
	//
	// LmHistoryLength: An unsigned (short) integer. This value is the length, in bytes,
	// of the LmHistoryArray field.
	//
	// LmHistoryMaximumLength: This value MUST be the same value as LmHistoryLength.
	//
	// Unused3: This value MUST be zero and ignored on receipt.
	//
	// NtHistoryLength: An unsigned (short) integer. This value is the length, in bytes,
	// of the NtHistoryArray field.
	//
	// NtHistoryMaximumLength: This value MUST be the same value as NtHistoryLength.
	//
	// Unused4: This value MUST be zero and ignored on receipt.
	//
	// NtHistoryArray: An array of NT hash values of user passwords for the given user.
	// The array is ordered so that the first element is the hash of the current password
	// and the last element is the hash of the oldest password.
	//
	// Note  The number of elements in the array is the value of the NtHistoryLength field
	// divided by 0x0010.
	//
	// LmHistoryArray: An array of LM hash values of user passwords for the given user.
	// The array is ordered so that the first element is the hash of the current password
	// and the last element is the hash of the oldest password.
	Data []byte `idl:"name:Data;size_is:(DataLength)" json:"data"`
}

func (o *UserPrivateInfo) xxx_PreparePayload(ctx context.Context) error {
	if o.Data != nil && o.DataLength == 0 {
		o.DataLength = uint32(len(o.Data))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *UserPrivateInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.SensitiveData); err != nil {
		return err
	}
	if err := w.WriteData(o.DataLength); err != nil {
		return err
	}
	if o.Data != nil || o.DataLength > 0 {
		_ptr_Data := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.DataLength)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Data {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.Data[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.Data); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Data, _ptr_Data); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *UserPrivateInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.SensitiveData); err != nil {
		return err
	}
	if err := w.ReadData(&o.DataLength); err != nil {
		return err
	}
	_ptr_Data := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.DataLength > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.DataLength)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Data", sizeInfo[0])
		}
		o.Data = make([]byte, sizeInfo[0])
		for i1 := range o.Data {
			i1 := i1
			if err := w.ReadData(&o.Data[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_Data := func(ptr interface{}) { o.Data = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.Data, _s_Data, _ptr_Data); err != nil {
		return err
	}
	return nil
}

// ModifiedCount structure represents NLPR_MODIFIED_COUNT RPC structure.
//
// The NLPR_MODIFIED_COUNT structure specifies a count for the number of times an account's
// database has been modified.
type ModifiedCount struct {
	// ModifiedCount: An OLD_LARGE_INTEGER structure, as specified in [MS-SAMR] section
	// 2.2.2.2, that contains the number of modifications made to the database since its
	// creation. This value is the database serial number.
	ModifiedCount *OldLargeInteger `idl:"name:ModifiedCount" json:"modified_count"`
}

func (o *ModifiedCount) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ModifiedCount) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if o.ModifiedCount != nil {
		if err := o.ModifiedCount.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&OldLargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *ModifiedCount) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if o.ModifiedCount == nil {
		o.ModifiedCount = &OldLargeInteger{}
	}
	if err := o.ModifiedCount.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// QuotaLimits structure represents NLPR_QUOTA_LIMITS RPC structure.
//
// The NLPR_QUOTA_LIMITS structure defines a set of system resources that are available
// to a domain user.
type QuotaLimits struct {
	// PagedPoolLimit: A ULONG that specifies the number of bytes of paged pool memory assigned
	// to the user. The paged pool is an area of system memory (physical memory used by
	// the operating system) for objects that can be written to disk when they are not being
	// used.
	PagedPoolLimit uint32 `idl:"name:PagedPoolLimit" json:"paged_pool_limit"`
	// NonPagedPoolLimit: A ULONG that specifies the number of bytes of nonpaged pool memory
	// assigned to the user. The nonpaged pool is an area of system memory for objects that
	// cannot be written to disk but MUST remain in physical memory as long as they are
	// allocated.
	NonPagedPoolLimit uint32 `idl:"name:NonPagedPoolLimit" json:"non_paged_pool_limit"`
	// MinimumWorkingSetSize: A ULONG that specifies the minimum set size assigned to the
	// user. The working set of a process is the set of memory pages currently visible to
	// the process in physical RAM memory. These pages are present in memory when the application
	// is running and available for an application to use without triggering a page fault.
	MinimumWorkingSetSize uint32 `idl:"name:MinimumWorkingSetSize" json:"minimum_working_set_size"`
	// MaximumWorkingSetSize: A ULONG that specifies the maximum set size assigned to the
	// user.
	MaximumWorkingSetSize uint32 `idl:"name:MaximumWorkingSetSize" json:"maximum_working_set_size"`
	// PagefileLimit: A ULONG that specifies the maximum size, in bytes, of the paging file,
	// which is a reserved space on disk that backs up committed physical memory on the
	// computer.
	PageFileLimit uint32 `idl:"name:PagefileLimit" json:"page_file_limit"`
	// Reserved: An OLD_LARGE_INTEGER structure ([MSDN-OLI]) that is set to zero and ignored
	// on receipt.
	_ *OldLargeInteger `idl:"name:Reserved"`
}

func (o *QuotaLimits) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *QuotaLimits) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.PagedPoolLimit); err != nil {
		return err
	}
	if err := w.WriteData(o.NonPagedPoolLimit); err != nil {
		return err
	}
	if err := w.WriteData(o.MinimumWorkingSetSize); err != nil {
		return err
	}
	if err := w.WriteData(o.MaximumWorkingSetSize); err != nil {
		return err
	}
	if err := w.WriteData(o.PageFileLimit); err != nil {
		return err
	}
	// reserved Reserved
	if err := (&OldLargeInteger{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}
func (o *QuotaLimits) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.PagedPoolLimit); err != nil {
		return err
	}
	if err := w.ReadData(&o.NonPagedPoolLimit); err != nil {
		return err
	}
	if err := w.ReadData(&o.MinimumWorkingSetSize); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaximumWorkingSetSize); err != nil {
		return err
	}
	if err := w.ReadData(&o.PageFileLimit); err != nil {
		return err
	}
	// reserved Reserved
	var _Reserved *OldLargeInteger
	if _Reserved == nil {
		_Reserved = &OldLargeInteger{}
	}
	if err := _Reserved.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// DeltaUser structure represents NETLOGON_DELTA_USER RPC structure.
//
// The NETLOGON_DELTA_USER structure contains information about a SAM user account.
// This structure is used for replicating the user account data from the PDC to a BDC,
// as detailed in section 3.6.
//
// All fields of this structure, except the fields detailed following the structure
// definition, have the same meanings as the identically named fields in the Common
// User Fields, as specified in [MS-SAMR] section 2.2.6.1 and the SAMPR_USER_INTERNAL1_INFORMATION
// structure fields, as specified in [MS-SAMR] section 2.2.6.23.
type DeltaUser struct {
	UserName               *dtyp.UnicodeString     `idl:"name:UserName" json:"user_name"`
	FullName               *dtyp.UnicodeString     `idl:"name:FullName" json:"full_name"`
	UserID                 uint32                  `idl:"name:UserId" json:"user_id"`
	PrimaryGroupID         uint32                  `idl:"name:PrimaryGroupId" json:"primary_group_id"`
	HomeDirectory          *dtyp.UnicodeString     `idl:"name:HomeDirectory" json:"home_directory"`
	HomeDirectoryDrive     *dtyp.UnicodeString     `idl:"name:HomeDirectoryDrive" json:"home_directory_drive"`
	ScriptPath             *dtyp.UnicodeString     `idl:"name:ScriptPath" json:"script_path"`
	AdminComment           *dtyp.UnicodeString     `idl:"name:AdminComment" json:"admin_comment"`
	WorkStations           *dtyp.UnicodeString     `idl:"name:WorkStations" json:"work_stations"`
	LastLogon              *OldLargeInteger        `idl:"name:LastLogon" json:"last_logon"`
	LastLogoff             *OldLargeInteger        `idl:"name:LastLogoff" json:"last_logoff"`
	LogonHours             *LogonHours             `idl:"name:LogonHours" json:"logon_hours"`
	BadPasswordCount       uint16                  `idl:"name:BadPasswordCount" json:"bad_password_count"`
	LogonCount             uint16                  `idl:"name:LogonCount" json:"logon_count"`
	PasswordLastSet        *OldLargeInteger        `idl:"name:PasswordLastSet" json:"password_last_set"`
	AccountExpires         *OldLargeInteger        `idl:"name:AccountExpires" json:"account_expires"`
	UserAccountControl     uint32                  `idl:"name:UserAccountControl" json:"user_account_control"`
	EncryptedNTOWFPassword *EncryptedNTOWFPassword `idl:"name:EncryptedNtOwfPassword" json:"encrypted_nt_owf_password"`
	EncryptedLMOWFPassword *EncryptedLMOWFPassword `idl:"name:EncryptedLmOwfPassword" json:"encrypted_lm_owf_password"`
	NTPasswordPresent      uint8                   `idl:"name:NtPasswordPresent" json:"nt_password_present"`
	LMPasswordPresent      uint8                   `idl:"name:LmPasswordPresent" json:"lm_password_present"`
	PasswordExpired        uint8                   `idl:"name:PasswordExpired" json:"password_expired"`
	UserComment            *dtyp.UnicodeString     `idl:"name:UserComment" json:"user_comment"`
	Parameters             *dtyp.UnicodeString     `idl:"name:Parameters" json:"parameters"`
	CountryCode            uint16                  `idl:"name:CountryCode" json:"country_code"`
	CodePage               uint16                  `idl:"name:CodePage" json:"code_page"`
	// PrivateData: An NLPR_USER_PRIVATE_INFO structure, as specified in section 2.2.1.5.15,
	// containing the PrivateData field of the SAMPR_USER_INFORMATION structure, as specified
	// in [MS-SAMR] section 2.2.6.6.
	PrivateData *UserPrivateInfo `idl:"name:PrivateData" json:"private_data"`
	// SecurityInformation: A SECURITY_INFORMATION structure, as specified in [MS-DTYP]
	// section 2.4.7, that specifies portions of a security descriptor about the user account.
	SecurityInformation uint32 `idl:"name:SecurityInformation" json:"security_information"`
	// SecuritySize: The size, in bytes, of SecurityDescriptor.
	SecuritySize uint32 `idl:"name:SecuritySize" json:"security_size"`
	// SecurityDescriptor: A pointer to a SECURITY_DESCRIPTOR structure, as specified in
	// [MS-DTYP] section 2.4.6, that specifies the security settings for the user account
	// object.
	SecurityDescriptor []byte              `idl:"name:SecurityDescriptor;size_is:(SecuritySize)" json:"security_descriptor"`
	ProfilePath        *dtyp.UnicodeString `idl:"name:ProfilePath" json:"profile_path"`
	// DummyString2: A STRING structure, defined in section 2.2.1.1.2, that MUST contain
	// 0 for the Length field, 0 for the MaximumLength field, and NULL for the Buffer field.
	// It is ignored upon receipt. The Netlogon usage of dummy fields is described in section
	// 1.3.8.1.2.
	_ *dtyp.UnicodeString `idl:"name:DummyString2"`
	// DummyString3: See definition for DummyString2.
	_ *dtyp.UnicodeString `idl:"name:DummyString3"`
	// DummyString4: See definition for DummyString2
	_ *dtyp.UnicodeString `idl:"name:DummyString4"`
	// DummyLong1: The high part (the first 32 bits) of the LastBadPasswordTime field of
	// the SAMPR_USER_INTERNAL3_INFORMATION structure, as specified in [MS-SAMR] section
	// 2.2.6.7.
	_ uint32 `idl:"name:DummyLong1"`
	// DummyLong2: See definition for DummyLong1.
	_ uint32 `idl:"name:DummyLong2"`
	// DummyLong3: See definition for DummyLong1.
	_ uint32 `idl:"name:DummyLong3"`
	// DummyLong4: See definition for DummyLong1.
	_ uint32 `idl:"name:DummyLong4"`
}

func (o *DeltaUser) xxx_PreparePayload(ctx context.Context) error {
	if o.SecurityDescriptor != nil && o.SecuritySize == 0 {
		o.SecuritySize = uint32(len(o.SecurityDescriptor))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *DeltaUser) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.UserName != nil {
		if err := o.UserName.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.FullName != nil {
		if err := o.FullName.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.UserID); err != nil {
		return err
	}
	if err := w.WriteData(o.PrimaryGroupID); err != nil {
		return err
	}
	if o.HomeDirectory != nil {
		if err := o.HomeDirectory.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.HomeDirectoryDrive != nil {
		if err := o.HomeDirectoryDrive.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.ScriptPath != nil {
		if err := o.ScriptPath.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.AdminComment != nil {
		if err := o.AdminComment.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.WorkStations != nil {
		if err := o.WorkStations.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.LastLogon != nil {
		if err := o.LastLogon.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&OldLargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.LastLogoff != nil {
		if err := o.LastLogoff.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&OldLargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.LogonHours != nil {
		if err := o.LogonHours.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&LogonHours{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.BadPasswordCount); err != nil {
		return err
	}
	if err := w.WriteData(o.LogonCount); err != nil {
		return err
	}
	if o.PasswordLastSet != nil {
		if err := o.PasswordLastSet.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&OldLargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.AccountExpires != nil {
		if err := o.AccountExpires.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&OldLargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.UserAccountControl); err != nil {
		return err
	}
	if o.EncryptedNTOWFPassword != nil {
		if err := o.EncryptedNTOWFPassword.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&EncryptedNTOWFPassword{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.EncryptedLMOWFPassword != nil {
		if err := o.EncryptedLMOWFPassword.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&EncryptedLMOWFPassword{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.NTPasswordPresent); err != nil {
		return err
	}
	if err := w.WriteData(o.LMPasswordPresent); err != nil {
		return err
	}
	if err := w.WriteData(o.PasswordExpired); err != nil {
		return err
	}
	if o.UserComment != nil {
		if err := o.UserComment.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.Parameters != nil {
		if err := o.Parameters.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.CountryCode); err != nil {
		return err
	}
	if err := w.WriteData(o.CodePage); err != nil {
		return err
	}
	if o.PrivateData != nil {
		if err := o.PrivateData.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&UserPrivateInfo{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.SecurityInformation); err != nil {
		return err
	}
	if err := w.WriteData(o.SecuritySize); err != nil {
		return err
	}
	if o.SecurityDescriptor != nil || o.SecuritySize > 0 {
		_ptr_SecurityDescriptor := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.SecuritySize)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.SecurityDescriptor {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.SecurityDescriptor[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.SecurityDescriptor); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.SecurityDescriptor, _ptr_SecurityDescriptor); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.ProfilePath != nil {
		if err := o.ProfilePath.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// reserved DummyString2
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString3
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString4
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyLong1
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong2
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong3
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong4
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	return nil
}
func (o *DeltaUser) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if o.UserName == nil {
		o.UserName = &dtyp.UnicodeString{}
	}
	if err := o.UserName.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.FullName == nil {
		o.FullName = &dtyp.UnicodeString{}
	}
	if err := o.FullName.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.UserID); err != nil {
		return err
	}
	if err := w.ReadData(&o.PrimaryGroupID); err != nil {
		return err
	}
	if o.HomeDirectory == nil {
		o.HomeDirectory = &dtyp.UnicodeString{}
	}
	if err := o.HomeDirectory.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.HomeDirectoryDrive == nil {
		o.HomeDirectoryDrive = &dtyp.UnicodeString{}
	}
	if err := o.HomeDirectoryDrive.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.ScriptPath == nil {
		o.ScriptPath = &dtyp.UnicodeString{}
	}
	if err := o.ScriptPath.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.AdminComment == nil {
		o.AdminComment = &dtyp.UnicodeString{}
	}
	if err := o.AdminComment.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.WorkStations == nil {
		o.WorkStations = &dtyp.UnicodeString{}
	}
	if err := o.WorkStations.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.LastLogon == nil {
		o.LastLogon = &OldLargeInteger{}
	}
	if err := o.LastLogon.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.LastLogoff == nil {
		o.LastLogoff = &OldLargeInteger{}
	}
	if err := o.LastLogoff.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.LogonHours == nil {
		o.LogonHours = &LogonHours{}
	}
	if err := o.LogonHours.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.BadPasswordCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.LogonCount); err != nil {
		return err
	}
	if o.PasswordLastSet == nil {
		o.PasswordLastSet = &OldLargeInteger{}
	}
	if err := o.PasswordLastSet.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.AccountExpires == nil {
		o.AccountExpires = &OldLargeInteger{}
	}
	if err := o.AccountExpires.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.UserAccountControl); err != nil {
		return err
	}
	if o.EncryptedNTOWFPassword == nil {
		o.EncryptedNTOWFPassword = &EncryptedNTOWFPassword{}
	}
	if err := o.EncryptedNTOWFPassword.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.EncryptedLMOWFPassword == nil {
		o.EncryptedLMOWFPassword = &EncryptedLMOWFPassword{}
	}
	if err := o.EncryptedLMOWFPassword.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.NTPasswordPresent); err != nil {
		return err
	}
	if err := w.ReadData(&o.LMPasswordPresent); err != nil {
		return err
	}
	if err := w.ReadData(&o.PasswordExpired); err != nil {
		return err
	}
	if o.UserComment == nil {
		o.UserComment = &dtyp.UnicodeString{}
	}
	if err := o.UserComment.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.Parameters == nil {
		o.Parameters = &dtyp.UnicodeString{}
	}
	if err := o.Parameters.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.CountryCode); err != nil {
		return err
	}
	if err := w.ReadData(&o.CodePage); err != nil {
		return err
	}
	if o.PrivateData == nil {
		o.PrivateData = &UserPrivateInfo{}
	}
	if err := o.PrivateData.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.SecurityInformation); err != nil {
		return err
	}
	if err := w.ReadData(&o.SecuritySize); err != nil {
		return err
	}
	_ptr_SecurityDescriptor := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.SecuritySize > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.SecuritySize)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.SecurityDescriptor", sizeInfo[0])
		}
		o.SecurityDescriptor = make([]byte, sizeInfo[0])
		for i1 := range o.SecurityDescriptor {
			i1 := i1
			if err := w.ReadData(&o.SecurityDescriptor[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_SecurityDescriptor := func(ptr interface{}) { o.SecurityDescriptor = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.SecurityDescriptor, _s_SecurityDescriptor, _ptr_SecurityDescriptor); err != nil {
		return err
	}
	if o.ProfilePath == nil {
		o.ProfilePath = &dtyp.UnicodeString{}
	}
	if err := o.ProfilePath.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString2
	var _DummyString2 *dtyp.UnicodeString
	if _DummyString2 == nil {
		_DummyString2 = &dtyp.UnicodeString{}
	}
	if err := _DummyString2.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString3
	var _DummyString3 *dtyp.UnicodeString
	if _DummyString3 == nil {
		_DummyString3 = &dtyp.UnicodeString{}
	}
	if err := _DummyString3.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString4
	var _DummyString4 *dtyp.UnicodeString
	if _DummyString4 == nil {
		_DummyString4 = &dtyp.UnicodeString{}
	}
	if err := _DummyString4.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyLong1
	var _DummyLong1 uint32
	if err := w.ReadData(&_DummyLong1); err != nil {
		return err
	}
	// reserved DummyLong2
	var _DummyLong2 uint32
	if err := w.ReadData(&_DummyLong2); err != nil {
		return err
	}
	// reserved DummyLong3
	var _DummyLong3 uint32
	if err := w.ReadData(&_DummyLong3); err != nil {
		return err
	}
	// reserved DummyLong4
	var _DummyLong4 uint32
	if err := w.ReadData(&_DummyLong4); err != nil {
		return err
	}
	return nil
}

// DeltaGroup structure represents NETLOGON_DELTA_GROUP RPC structure.
//
// The NETLOGON_DELTA_GROUP structure contains information about a SAM group account.
// This structure is used for replicating the group data from the PDC to a BDC, as detailed
// in section 3.6.
type DeltaGroup struct {
	// Name: A RPC_UNICODE_STRING structure that contains the group name.
	Name *dtyp.UnicodeString `idl:"name:Name" json:"name"`
	// RelativeId: The RID for the group.
	RelativeID uint32 `idl:"name:RelativeId" json:"relative_id"`
	// Attributes: A set of bit flags that describe attributes of the SID. An attribute
	// is true (or set) if its value is equal to 1. The value is constructed from one or
	// more bit flags from the following table.
	//
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
	//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | C | B | A |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//
	// Where the bits are defined as:
	//
	//	+-------+----------------------------------------------------------------------------------+
	//	|       |                                                                                  |
	//	| VALUE |                                   DESCRIPTION                                    |
	//	|       |                                                                                  |
	//	+-------+----------------------------------------------------------------------------------+
	//	+-------+----------------------------------------------------------------------------------+
	//	| A     | The SID cannot have the SE_GROUP_ENABLED attribute removed. Corresponds to       |
	//	|       | the SID attribute SE_GROUP_MANDATORY. This attribute prevents the user from      |
	//	|       | disabling the group. Disabling a group causes the group to be ignored by access  |
	//	|       | validation routines.                                                             |
	//	+-------+----------------------------------------------------------------------------------+
	//	| B     | The SID is enabled by default (as opposed to being enabled by an application).   |
	//	|       | Corresponds to the SID attribute SE_GROUP_ENABLED_BY_DEFAULT.                    |
	//	+-------+----------------------------------------------------------------------------------+
	//	| C     | The SID is enabled for access checks. Corresponds to the SID attribute           |
	//	|       | SE_GROUP_ENABLED.                                                                |
	//	+-------+----------------------------------------------------------------------------------+
	Attributes uint32 `idl:"name:Attributes" json:"attributes"`
	// AdminComment: An RPC_UNICODE_STRING structure, as specified in [MS-DTYP] section
	// 2.3.10, that contains an administrative comment for the group.
	AdminComment *dtyp.UnicodeString `idl:"name:AdminComment" json:"admin_comment"`
	// SecurityInformation: A SECURITY_INFORMATION structure, as specified in [MS-DTYP]
	// section 2.4.7, that specifies portions of a security descriptor about the group.
	SecurityInformation uint32 `idl:"name:SecurityInformation" json:"security_information"`
	// SecuritySize: The size, in bytes, of the SecurityDescriptor field.
	SecuritySize uint32 `idl:"name:SecuritySize" json:"security_size"`
	// SecurityDescriptor: A pointer to a SECURITY_DESCRIPTOR structure, as specified in
	// [MS-DTYP] section 2.4.6, that contains the security settings of the group object.
	SecurityDescriptor []byte `idl:"name:SecurityDescriptor;size_is:(SecuritySize)" json:"security_descriptor"`
	// DummyString1: A STRING structure, defined in section 2.2.1.1.2, that MUST contain
	// 0 for the Length field, 0 for the MaximumLength field, and NULL for the Buffer field.
	// It is ignored upon receipt. The Netlogon usage of dummy fields is described in section
	// 1.3.8.1.2.
	_ *dtyp.UnicodeString `idl:"name:DummyString1"`
	// DummyString2: See definition for DummyString1.
	_ *dtyp.UnicodeString `idl:"name:DummyString2"`
	// DummyString3: See definition for DummyString1.
	_ *dtyp.UnicodeString `idl:"name:DummyString3"`
	// DummyString4: See definition for DummyString1.
	_ *dtyp.UnicodeString `idl:"name:DummyString4"`
	// DummyLong1: MUST be set to zero and MUST be ignored on receipt. The Netlogon usage
	// of dummy fields is described in section 1.3.8.1.2.
	_ uint32 `idl:"name:DummyLong1"`
	// DummyLong2: See definition for DummyLong1.
	_ uint32 `idl:"name:DummyLong2"`
	// DummyLong3: See definition for DummyLong1.
	_ uint32 `idl:"name:DummyLong3"`
	// DummyLong4: See definition for DummyLong1.
	_ uint32 `idl:"name:DummyLong4"`
}

func (o *DeltaGroup) xxx_PreparePayload(ctx context.Context) error {
	if o.SecurityDescriptor != nil && o.SecuritySize == 0 {
		o.SecuritySize = uint32(len(o.SecurityDescriptor))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *DeltaGroup) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.Name != nil {
		if err := o.Name.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.RelativeID); err != nil {
		return err
	}
	if err := w.WriteData(o.Attributes); err != nil {
		return err
	}
	if o.AdminComment != nil {
		if err := o.AdminComment.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.SecurityInformation); err != nil {
		return err
	}
	if err := w.WriteData(o.SecuritySize); err != nil {
		return err
	}
	if o.SecurityDescriptor != nil || o.SecuritySize > 0 {
		_ptr_SecurityDescriptor := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.SecuritySize)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.SecurityDescriptor {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.SecurityDescriptor[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.SecurityDescriptor); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.SecurityDescriptor, _ptr_SecurityDescriptor); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	// reserved DummyString1
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString2
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString3
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString4
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyLong1
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong2
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong3
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong4
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	return nil
}
func (o *DeltaGroup) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if o.Name == nil {
		o.Name = &dtyp.UnicodeString{}
	}
	if err := o.Name.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.RelativeID); err != nil {
		return err
	}
	if err := w.ReadData(&o.Attributes); err != nil {
		return err
	}
	if o.AdminComment == nil {
		o.AdminComment = &dtyp.UnicodeString{}
	}
	if err := o.AdminComment.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.SecurityInformation); err != nil {
		return err
	}
	if err := w.ReadData(&o.SecuritySize); err != nil {
		return err
	}
	_ptr_SecurityDescriptor := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.SecuritySize > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.SecuritySize)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.SecurityDescriptor", sizeInfo[0])
		}
		o.SecurityDescriptor = make([]byte, sizeInfo[0])
		for i1 := range o.SecurityDescriptor {
			i1 := i1
			if err := w.ReadData(&o.SecurityDescriptor[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_SecurityDescriptor := func(ptr interface{}) { o.SecurityDescriptor = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.SecurityDescriptor, _s_SecurityDescriptor, _ptr_SecurityDescriptor); err != nil {
		return err
	}
	// reserved DummyString1
	var _DummyString1 *dtyp.UnicodeString
	if _DummyString1 == nil {
		_DummyString1 = &dtyp.UnicodeString{}
	}
	if err := _DummyString1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString2
	var _DummyString2 *dtyp.UnicodeString
	if _DummyString2 == nil {
		_DummyString2 = &dtyp.UnicodeString{}
	}
	if err := _DummyString2.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString3
	var _DummyString3 *dtyp.UnicodeString
	if _DummyString3 == nil {
		_DummyString3 = &dtyp.UnicodeString{}
	}
	if err := _DummyString3.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString4
	var _DummyString4 *dtyp.UnicodeString
	if _DummyString4 == nil {
		_DummyString4 = &dtyp.UnicodeString{}
	}
	if err := _DummyString4.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyLong1
	var _DummyLong1 uint32
	if err := w.ReadData(&_DummyLong1); err != nil {
		return err
	}
	// reserved DummyLong2
	var _DummyLong2 uint32
	if err := w.ReadData(&_DummyLong2); err != nil {
		return err
	}
	// reserved DummyLong3
	var _DummyLong3 uint32
	if err := w.ReadData(&_DummyLong3); err != nil {
		return err
	}
	// reserved DummyLong4
	var _DummyLong4 uint32
	if err := w.ReadData(&_DummyLong4); err != nil {
		return err
	}
	return nil
}

// DeltaGroupMember structure represents NETLOGON_DELTA_GROUP_MEMBER RPC structure.
//
// The NETLOGON_DELTA_GROUP_MEMBER structure contains information about members of a
// group by providing pointers to a list of group members and their respective attributes.
// This structure is used to replicate the group membership data from the PDC to a BDC,
// as detailed in section 3.6.
//
// All fields of this structure, except the fields detailed following the structure
// definition, have the same meanings as the identically named fields of the SAMPR_GET_MEMBERS_BUFFER
// structure, as specified in [MS-SAMR] section 2.2.7.14. The last four fields of the
// structure (DummyLong1, DummyLong2, DummyLong3, and DummyLong4) are not found in [MS-SAMR].
type DeltaGroupMember struct {
	Members     []uint32 `idl:"name:Members;size_is:(MemberCount)" json:"members"`
	Attributes  []uint32 `idl:"name:Attributes;size_is:(MemberCount)" json:"attributes"`
	MemberCount uint32   `idl:"name:MemberCount" json:"member_count"`
	// DummyLong1: MUST be set to zero and MUST be ignored on receipt. The Netlogon usage
	// of dummy fields is described in section 1.3.8.1.2.
	_ uint32 `idl:"name:DummyLong1"`
	// DummyLong2: See definition for DummyLong1.
	_ uint32 `idl:"name:DummyLong2"`
	// DummyLong3: See definition for DummyLong1.
	_ uint32 `idl:"name:DummyLong3"`
	// DummyLong4: See definition for DummyLong1.
	_ uint32 `idl:"name:DummyLong4"`
}

func (o *DeltaGroupMember) xxx_PreparePayload(ctx context.Context) error {
	if o.Members != nil && o.MemberCount == 0 {
		o.MemberCount = uint32(len(o.Members))
	}
	if o.Attributes != nil && o.MemberCount == 0 {
		o.MemberCount = uint32(len(o.Attributes))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *DeltaGroupMember) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.Members != nil || o.MemberCount > 0 {
		_ptr_Members := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.MemberCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Members {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.Members[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.Members); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint32(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Members, _ptr_Members); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.Attributes != nil || o.MemberCount > 0 {
		_ptr_Attributes := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.MemberCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Attributes {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.Attributes[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.Attributes); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint32(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Attributes, _ptr_Attributes); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.MemberCount); err != nil {
		return err
	}
	// reserved DummyLong1
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong2
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong3
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong4
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	return nil
}
func (o *DeltaGroupMember) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_Members := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.MemberCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.MemberCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Members", sizeInfo[0])
		}
		o.Members = make([]uint32, sizeInfo[0])
		for i1 := range o.Members {
			i1 := i1
			if err := w.ReadData(&o.Members[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_Members := func(ptr interface{}) { o.Members = *ptr.(*[]uint32) }
	if err := w.ReadPointer(&o.Members, _s_Members, _ptr_Members); err != nil {
		return err
	}
	_ptr_Attributes := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.MemberCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.MemberCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Attributes", sizeInfo[0])
		}
		o.Attributes = make([]uint32, sizeInfo[0])
		for i1 := range o.Attributes {
			i1 := i1
			if err := w.ReadData(&o.Attributes[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_Attributes := func(ptr interface{}) { o.Attributes = *ptr.(*[]uint32) }
	if err := w.ReadPointer(&o.Attributes, _s_Attributes, _ptr_Attributes); err != nil {
		return err
	}
	if err := w.ReadData(&o.MemberCount); err != nil {
		return err
	}
	// reserved DummyLong1
	var _DummyLong1 uint32
	if err := w.ReadData(&_DummyLong1); err != nil {
		return err
	}
	// reserved DummyLong2
	var _DummyLong2 uint32
	if err := w.ReadData(&_DummyLong2); err != nil {
		return err
	}
	// reserved DummyLong3
	var _DummyLong3 uint32
	if err := w.ReadData(&_DummyLong3); err != nil {
		return err
	}
	// reserved DummyLong4
	var _DummyLong4 uint32
	if err := w.ReadData(&_DummyLong4); err != nil {
		return err
	}
	return nil
}

// DeltaAlias structure represents NETLOGON_DELTA_ALIAS RPC structure.
//
// The NETLOGON_DELTA_ALIAS structure contains information about a SAM alias. This structure
// is used to replicate the SAM alias data from the PDC to a BDC.
type DeltaAlias struct {
	// Name: An RPC_UNICODE_STRING structure, as specified in [MS-DTYP] section 2.3.10,
	// that contains the alias name.
	Name *dtyp.UnicodeString `idl:"name:Name" json:"name"`
	// RelativeId: The RID for the alias.
	RelativeID uint32 `idl:"name:RelativeId" json:"relative_id"`
	// SecurityInformation: A SECURITY_INFORMATION structure, as specified in [MS-DTYP]
	// section 2.4.7, that contains security settings for the alias.
	SecurityInformation uint32 `idl:"name:SecurityInformation" json:"security_information"`
	// SecuritySize: The size, in bytes, of the SecurityDescriptor field.
	SecuritySize uint32 `idl:"name:SecuritySize" json:"security_size"`
	// SecurityDescriptor: A pointer to a SECURITY_DESCRIPTOR structure, as specified in
	// [MS-DTYP] section 2.4.6, that describes the security information for the alias object.
	SecurityDescriptor []byte `idl:"name:SecurityDescriptor;size_is:(SecuritySize)" json:"security_descriptor"`
	// Comment: An RPC_UNICODE_STRING that contains the administrative comment string for
	// the alias.
	Comment *dtyp.UnicodeString `idl:"name:Comment" json:"comment"`
	// DummyString2: A STRING structure, as defined in section 2.2.1.1.2, that MUST contain
	// 0 for the Length field, 0 for the MaximumLength field, and NULL for the Buffer field.
	// It is ignored upon receipt. The Netlogon usage of dummy fields is described in section
	// 1.3.8.1.2.
	_ *dtyp.UnicodeString `idl:"name:DummyString2"`
	// DummyString3: See definition for DummyString2 field.
	_ *dtyp.UnicodeString `idl:"name:DummyString3"`
	// DummyString4: See definition for DummyString2 field.
	_ *dtyp.UnicodeString `idl:"name:DummyString4"`
	// DummyLong1: MUST be set to zero and MUST be ignored on receipt. The Netlogon usage
	// of dummy fields is described in section 1.3.8.1.2.
	_ uint32 `idl:"name:DummyLong1"`
	// DummyLong2: See definition for DummyLong1 field.
	_ uint32 `idl:"name:DummyLong2"`
	// DummyLong3: See definition for DummyLong1 field.
	_ uint32 `idl:"name:DummyLong3"`
	// DummyLong4: See definition for DummyLong1 field.
	_ uint32 `idl:"name:DummyLong4"`
}

func (o *DeltaAlias) xxx_PreparePayload(ctx context.Context) error {
	if o.SecurityDescriptor != nil && o.SecuritySize == 0 {
		o.SecuritySize = uint32(len(o.SecurityDescriptor))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *DeltaAlias) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.Name != nil {
		if err := o.Name.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.RelativeID); err != nil {
		return err
	}
	if err := w.WriteData(o.SecurityInformation); err != nil {
		return err
	}
	if err := w.WriteData(o.SecuritySize); err != nil {
		return err
	}
	if o.SecurityDescriptor != nil || o.SecuritySize > 0 {
		_ptr_SecurityDescriptor := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.SecuritySize)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.SecurityDescriptor {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.SecurityDescriptor[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.SecurityDescriptor); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.SecurityDescriptor, _ptr_SecurityDescriptor); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.Comment != nil {
		if err := o.Comment.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// reserved DummyString2
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString3
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString4
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyLong1
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong2
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong3
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong4
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	return nil
}
func (o *DeltaAlias) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if o.Name == nil {
		o.Name = &dtyp.UnicodeString{}
	}
	if err := o.Name.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.RelativeID); err != nil {
		return err
	}
	if err := w.ReadData(&o.SecurityInformation); err != nil {
		return err
	}
	if err := w.ReadData(&o.SecuritySize); err != nil {
		return err
	}
	_ptr_SecurityDescriptor := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.SecuritySize > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.SecuritySize)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.SecurityDescriptor", sizeInfo[0])
		}
		o.SecurityDescriptor = make([]byte, sizeInfo[0])
		for i1 := range o.SecurityDescriptor {
			i1 := i1
			if err := w.ReadData(&o.SecurityDescriptor[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_SecurityDescriptor := func(ptr interface{}) { o.SecurityDescriptor = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.SecurityDescriptor, _s_SecurityDescriptor, _ptr_SecurityDescriptor); err != nil {
		return err
	}
	if o.Comment == nil {
		o.Comment = &dtyp.UnicodeString{}
	}
	if err := o.Comment.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString2
	var _DummyString2 *dtyp.UnicodeString
	if _DummyString2 == nil {
		_DummyString2 = &dtyp.UnicodeString{}
	}
	if err := _DummyString2.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString3
	var _DummyString3 *dtyp.UnicodeString
	if _DummyString3 == nil {
		_DummyString3 = &dtyp.UnicodeString{}
	}
	if err := _DummyString3.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString4
	var _DummyString4 *dtyp.UnicodeString
	if _DummyString4 == nil {
		_DummyString4 = &dtyp.UnicodeString{}
	}
	if err := _DummyString4.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyLong1
	var _DummyLong1 uint32
	if err := w.ReadData(&_DummyLong1); err != nil {
		return err
	}
	// reserved DummyLong2
	var _DummyLong2 uint32
	if err := w.ReadData(&_DummyLong2); err != nil {
		return err
	}
	// reserved DummyLong3
	var _DummyLong3 uint32
	if err := w.ReadData(&_DummyLong3); err != nil {
		return err
	}
	// reserved DummyLong4
	var _DummyLong4 uint32
	if err := w.ReadData(&_DummyLong4); err != nil {
		return err
	}
	return nil
}

// DeltaAliasMember structure represents NETLOGON_DELTA_ALIAS_MEMBER RPC structure.
//
// The NETLOGON_DELTA_ALIAS_MEMBER structure contains all the members of a SAM alias.
// This structure is used for replicating the SAM alias data from the PDC to a BDC,
// as detailed in section 3.6.
type DeltaAliasMember struct {
	// Members: An NLPR_SID_ARRAY structure, as specified in section 2.2.1.5.6, that contains
	// an array of SIDs for each member of the alias.
	Members *SIDArray `idl:"name:Members" json:"members"`
	// DummyLong1: MUST be set to zero and MUST be ignored on receipt. The Netlogon usage
	// of dummy fields is described in section 1.3.8.1.2.
	_ uint32 `idl:"name:DummyLong1"`
	// DummyLong2: See definition for DummyLong1 field.
	_ uint32 `idl:"name:DummyLong2"`
	// DummyLong3: See definition for DummyLong1 field.
	_ uint32 `idl:"name:DummyLong3"`
	// DummyLong4: See definition for DummyLong1 field.
	_ uint32 `idl:"name:DummyLong4"`
}

func (o *DeltaAliasMember) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *DeltaAliasMember) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.Members != nil {
		if err := o.Members.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&SIDArray{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// reserved DummyLong1
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong2
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong3
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong4
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	return nil
}
func (o *DeltaAliasMember) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if o.Members == nil {
		o.Members = &SIDArray{}
	}
	if err := o.Members.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyLong1
	var _DummyLong1 uint32
	if err := w.ReadData(&_DummyLong1); err != nil {
		return err
	}
	// reserved DummyLong2
	var _DummyLong2 uint32
	if err := w.ReadData(&_DummyLong2); err != nil {
		return err
	}
	// reserved DummyLong3
	var _DummyLong3 uint32
	if err := w.ReadData(&_DummyLong3); err != nil {
		return err
	}
	// reserved DummyLong4
	var _DummyLong4 uint32
	if err := w.ReadData(&_DummyLong4); err != nil {
		return err
	}
	return nil
}

// DeltaDomain structure represents NETLOGON_DELTA_DOMAIN RPC structure.
//
// The NETLOGON_DELTA_DOMAIN structure contains information about a domain. Most of
// the fields in this structure are obtained by querying the database. This structure
// is used to replicate the domain data from the PDC to a BDC, as detailed in Netlogon
// NT Replicaton Details (section 3.6).
//
// All fields of this structure, except the fields detailed following the structure
// definition, have the same meaning as the identically named fields in the Domain Fields
// section in [MS-SAMR] section 2.2.3.1.
type DeltaDomain struct {
	DomainName            *dtyp.UnicodeString `idl:"name:DomainName" json:"domain_name"`
	OEMInformation        *dtyp.UnicodeString `idl:"name:OemInformation" json:"oem_information"`
	ForceLogoff           *OldLargeInteger    `idl:"name:ForceLogoff" json:"force_logoff"`
	MinPasswordLength     uint16              `idl:"name:MinPasswordLength" json:"min_password_length"`
	PasswordHistoryLength uint16              `idl:"name:PasswordHistoryLength" json:"password_history_length"`
	MaxPasswordAge        *OldLargeInteger    `idl:"name:MaxPasswordAge" json:"max_password_age"`
	MinPasswordAge        *OldLargeInteger    `idl:"name:MinPasswordAge" json:"min_password_age"`
	DomainModifiedCount   *OldLargeInteger    `idl:"name:DomainModifiedCount" json:"domain_modified_count"`
	DomainCreationTime    *OldLargeInteger    `idl:"name:DomainCreationTime" json:"domain_creation_time"`
	// SecurityInformation: A SECURITY_INFORMATION structure, as specified in [MS-DTYP]
	// section 2.4.7, that specifies portions of a security descriptor about the domain.
	SecurityInformation uint32 `idl:"name:SecurityInformation" json:"security_information"`
	// SecuritySize: The size, in bytes, of the SecurityDescriptor field.
	SecuritySize uint32 `idl:"name:SecuritySize" json:"security_size"`
	// SecurityDescriptor: A pointer to a SECURITY_DESCRIPTOR structure, as specified in
	// [MS-DTYP] section 2.4.6, that contains the security settings for the domain object.
	SecurityDescriptor []byte `idl:"name:SecurityDescriptor;size_is:(SecuritySize)" json:"security_descriptor"`
	// DomainLockoutInformation: An RPC_UNICODE_STRING structure, as specified in [MS-DTYP]
	// section 2.3.10, that contains the domain lockout information detailed in [MS-SAMR].
	// The Buffer field points to the SAMPR_DOMAIN_LOCKOUT_INFORMATION structure, as specified
	// in [MS-SAMR] section 2.2.3.15, and the Length and MaximumLength fields are set to
	// the size in bytes of the SAMPR_DOMAIN_LOCKOUT_INFORMATION structure pointed to by
	// the Buffer field.
	DomainLockoutInformation *dtyp.UnicodeString `idl:"name:DomainLockoutInformation" json:"domain_lockout_information"`
	// DummyString2: A STRING structure, defined in section 2.2.1.1.2, that MUST contain
	// 0 for the Length field, 0 for the MaximumLength field, and NULL for the Buffer field.
	// It is ignored upon receipt. The Netlogon usage of dummy fields is described in section
	// 1.3.8.1.2.
	_ *dtyp.UnicodeString `idl:"name:DummyString2"`
	// DummyString3: See definition for DummyString2 field.
	_ *dtyp.UnicodeString `idl:"name:DummyString3"`
	// DummyString4: See definition for DummyString2 field.
	_                  *dtyp.UnicodeString `idl:"name:DummyString4"`
	PasswordProperties uint32              `idl:"name:PasswordProperties" json:"password_properties"`
	// DummyLong2: MUST be set to zero and MUST be ignored on receipt. The Netlogon usage
	// of dummy fields is described in section 1.3.8.1.2.
	_ uint32 `idl:"name:DummyLong2"`
	// DummyLong3: See definition for DummyLong2 field.
	_ uint32 `idl:"name:DummyLong3"`
	// DummyLong4: See definition for DummyLong2 field.
	_ uint32 `idl:"name:DummyLong4"`
}

func (o *DeltaDomain) xxx_PreparePayload(ctx context.Context) error {
	if o.SecurityDescriptor != nil && o.SecuritySize == 0 {
		o.SecuritySize = uint32(len(o.SecurityDescriptor))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *DeltaDomain) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.DomainName != nil {
		if err := o.DomainName.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.OEMInformation != nil {
		if err := o.OEMInformation.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.ForceLogoff != nil {
		if err := o.ForceLogoff.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&OldLargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.MinPasswordLength); err != nil {
		return err
	}
	if err := w.WriteData(o.PasswordHistoryLength); err != nil {
		return err
	}
	if o.MaxPasswordAge != nil {
		if err := o.MaxPasswordAge.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&OldLargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.MinPasswordAge != nil {
		if err := o.MinPasswordAge.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&OldLargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.DomainModifiedCount != nil {
		if err := o.DomainModifiedCount.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&OldLargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.DomainCreationTime != nil {
		if err := o.DomainCreationTime.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&OldLargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.SecurityInformation); err != nil {
		return err
	}
	if err := w.WriteData(o.SecuritySize); err != nil {
		return err
	}
	if o.SecurityDescriptor != nil || o.SecuritySize > 0 {
		_ptr_SecurityDescriptor := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.SecuritySize)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.SecurityDescriptor {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.SecurityDescriptor[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.SecurityDescriptor); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.SecurityDescriptor, _ptr_SecurityDescriptor); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.DomainLockoutInformation != nil {
		if err := o.DomainLockoutInformation.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// reserved DummyString2
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString3
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString4
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.WriteData(o.PasswordProperties); err != nil {
		return err
	}
	// reserved DummyLong2
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong3
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong4
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	return nil
}
func (o *DeltaDomain) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if o.DomainName == nil {
		o.DomainName = &dtyp.UnicodeString{}
	}
	if err := o.DomainName.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.OEMInformation == nil {
		o.OEMInformation = &dtyp.UnicodeString{}
	}
	if err := o.OEMInformation.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.ForceLogoff == nil {
		o.ForceLogoff = &OldLargeInteger{}
	}
	if err := o.ForceLogoff.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.MinPasswordLength); err != nil {
		return err
	}
	if err := w.ReadData(&o.PasswordHistoryLength); err != nil {
		return err
	}
	if o.MaxPasswordAge == nil {
		o.MaxPasswordAge = &OldLargeInteger{}
	}
	if err := o.MaxPasswordAge.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.MinPasswordAge == nil {
		o.MinPasswordAge = &OldLargeInteger{}
	}
	if err := o.MinPasswordAge.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.DomainModifiedCount == nil {
		o.DomainModifiedCount = &OldLargeInteger{}
	}
	if err := o.DomainModifiedCount.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.DomainCreationTime == nil {
		o.DomainCreationTime = &OldLargeInteger{}
	}
	if err := o.DomainCreationTime.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.SecurityInformation); err != nil {
		return err
	}
	if err := w.ReadData(&o.SecuritySize); err != nil {
		return err
	}
	_ptr_SecurityDescriptor := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.SecuritySize > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.SecuritySize)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.SecurityDescriptor", sizeInfo[0])
		}
		o.SecurityDescriptor = make([]byte, sizeInfo[0])
		for i1 := range o.SecurityDescriptor {
			i1 := i1
			if err := w.ReadData(&o.SecurityDescriptor[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_SecurityDescriptor := func(ptr interface{}) { o.SecurityDescriptor = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.SecurityDescriptor, _s_SecurityDescriptor, _ptr_SecurityDescriptor); err != nil {
		return err
	}
	if o.DomainLockoutInformation == nil {
		o.DomainLockoutInformation = &dtyp.UnicodeString{}
	}
	if err := o.DomainLockoutInformation.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString2
	var _DummyString2 *dtyp.UnicodeString
	if _DummyString2 == nil {
		_DummyString2 = &dtyp.UnicodeString{}
	}
	if err := _DummyString2.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString3
	var _DummyString3 *dtyp.UnicodeString
	if _DummyString3 == nil {
		_DummyString3 = &dtyp.UnicodeString{}
	}
	if err := _DummyString3.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString4
	var _DummyString4 *dtyp.UnicodeString
	if _DummyString4 == nil {
		_DummyString4 = &dtyp.UnicodeString{}
	}
	if err := _DummyString4.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.PasswordProperties); err != nil {
		return err
	}
	// reserved DummyLong2
	var _DummyLong2 uint32
	if err := w.ReadData(&_DummyLong2); err != nil {
		return err
	}
	// reserved DummyLong3
	var _DummyLong3 uint32
	if err := w.ReadData(&_DummyLong3); err != nil {
		return err
	}
	// reserved DummyLong4
	var _DummyLong4 uint32
	if err := w.ReadData(&_DummyLong4); err != nil {
		return err
	}
	return nil
}

// RenameGroup structure represents NETLOGON_RENAME_GROUP RPC structure.
//
// The NETLOGON_RENAME_GROUP structure specifies a rename of a group.
type RenameGroup struct {
	// OldName: An RPC_UNICODE_STRING structure, as specified in [MS-DTYP] section 2.3.10,
	// that contains the group's previous name.
	OldName *dtyp.UnicodeString `idl:"name:OldName" json:"old_name"`
	// NewName: An RPC_UNICODE_STRING structure, as specified in [MS-DTYP] section 2.3.10,
	// that contains the new name to assign to the group.
	NewName *dtyp.UnicodeString `idl:"name:NewName" json:"new_name"`
	// DummyString1: A STRING structure, defined in section 2.2.1.1.2, that MUST contain
	// 0 for the Length field, 0 for the MaximumLength field, and NULL for the Buffer field.
	// It is ignored upon receipt. The Netlogon usage of dummy fields is described in section
	// 1.3.8.1.2.
	_ *dtyp.UnicodeString `idl:"name:DummyString1"`
	// DummyString2: See definition for DummyString1.
	_ *dtyp.UnicodeString `idl:"name:DummyString2"`
	// DummyString3: See definition for DummyString1.
	_ *dtyp.UnicodeString `idl:"name:DummyString3"`
	// DummyString4: See description for DummyString1.
	_ *dtyp.UnicodeString `idl:"name:DummyString4"`
	// DummyLong1: MUST be set to zero and MUST be ignored on receipt. The Netlogon usage
	// of dummy fields is described in section 1.3.8.1.2.
	_ uint32 `idl:"name:DummyLong1"`
	// DummyLong2: See definition for DummyLong1.
	_ uint32 `idl:"name:DummyLong2"`
	// DummyLong3: See definition for DummyLong1.
	_ uint32 `idl:"name:DummyLong3"`
	// DummyLong4: See definition for DummyLong1.
	_ uint32 `idl:"name:DummyLong4"`
}

func (o *RenameGroup) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *RenameGroup) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.OldName != nil {
		if err := o.OldName.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.NewName != nil {
		if err := o.NewName.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// reserved DummyString1
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString2
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString3
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString4
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyLong1
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong2
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong3
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong4
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	return nil
}
func (o *RenameGroup) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if o.OldName == nil {
		o.OldName = &dtyp.UnicodeString{}
	}
	if err := o.OldName.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.NewName == nil {
		o.NewName = &dtyp.UnicodeString{}
	}
	if err := o.NewName.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString1
	var _DummyString1 *dtyp.UnicodeString
	if _DummyString1 == nil {
		_DummyString1 = &dtyp.UnicodeString{}
	}
	if err := _DummyString1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString2
	var _DummyString2 *dtyp.UnicodeString
	if _DummyString2 == nil {
		_DummyString2 = &dtyp.UnicodeString{}
	}
	if err := _DummyString2.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString3
	var _DummyString3 *dtyp.UnicodeString
	if _DummyString3 == nil {
		_DummyString3 = &dtyp.UnicodeString{}
	}
	if err := _DummyString3.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString4
	var _DummyString4 *dtyp.UnicodeString
	if _DummyString4 == nil {
		_DummyString4 = &dtyp.UnicodeString{}
	}
	if err := _DummyString4.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyLong1
	var _DummyLong1 uint32
	if err := w.ReadData(&_DummyLong1); err != nil {
		return err
	}
	// reserved DummyLong2
	var _DummyLong2 uint32
	if err := w.ReadData(&_DummyLong2); err != nil {
		return err
	}
	// reserved DummyLong3
	var _DummyLong3 uint32
	if err := w.ReadData(&_DummyLong3); err != nil {
		return err
	}
	// reserved DummyLong4
	var _DummyLong4 uint32
	if err := w.ReadData(&_DummyLong4); err != nil {
		return err
	}
	return nil
}

// RenameUser structure represents NETLOGON_RENAME_USER RPC structure.
//
// The NETLOGON_RENAME_USER structure specifies a rename of a user account.
type RenameUser struct {
	// OldName: An RPC_UNICODE_STRING structure, as specified in [MS-DTYP] section 2.3.10,
	// that contains the user account's previous name.
	OldName *dtyp.UnicodeString `idl:"name:OldName" json:"old_name"`
	// NewName: An RPC_UNICODE_STRING structure, as specified in [MS-DTYP] section 2.3.10,
	// that contains the new name to assign to the user account.
	NewName *dtyp.UnicodeString `idl:"name:NewName" json:"new_name"`
	// DummyString1: A STRING structure, defined in section 2.2.1.1.2, that MUST contain
	// 0 for the Length field, 0 for the MaximumLength field, and NULL for the Buffer field.
	// It is ignored upon receipt. The Netlogon usage of dummy fields is described in section
	// 1.3.8.1.2.
	_ *dtyp.UnicodeString `idl:"name:DummyString1"`
	// DummyString2: See definition for DummyString1.
	_ *dtyp.UnicodeString `idl:"name:DummyString2"`
	// DummyString3: See definition for DummyString1.
	_ *dtyp.UnicodeString `idl:"name:DummyString3"`
	// DummyString4: See definition for DummyString1.
	_ *dtyp.UnicodeString `idl:"name:DummyString4"`
	// DummyLong1: MUST be set to zero and MUST be ignored on receipt. The Netlogon usage
	// of dummy fields is described in section 1.3.8.1.2.
	_ uint32 `idl:"name:DummyLong1"`
	// DummyLong2: See definition for DummyLong1.
	_ uint32 `idl:"name:DummyLong2"`
	// DummyLong3: See definition for DummyLong1.
	_ uint32 `idl:"name:DummyLong3"`
	// DummyLong4: See definition for DummyLong1.
	_ uint32 `idl:"name:DummyLong4"`
}

func (o *RenameUser) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *RenameUser) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.OldName != nil {
		if err := o.OldName.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.NewName != nil {
		if err := o.NewName.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// reserved DummyString1
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString2
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString3
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString4
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyLong1
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong2
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong3
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong4
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	return nil
}
func (o *RenameUser) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if o.OldName == nil {
		o.OldName = &dtyp.UnicodeString{}
	}
	if err := o.OldName.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.NewName == nil {
		o.NewName = &dtyp.UnicodeString{}
	}
	if err := o.NewName.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString1
	var _DummyString1 *dtyp.UnicodeString
	if _DummyString1 == nil {
		_DummyString1 = &dtyp.UnicodeString{}
	}
	if err := _DummyString1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString2
	var _DummyString2 *dtyp.UnicodeString
	if _DummyString2 == nil {
		_DummyString2 = &dtyp.UnicodeString{}
	}
	if err := _DummyString2.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString3
	var _DummyString3 *dtyp.UnicodeString
	if _DummyString3 == nil {
		_DummyString3 = &dtyp.UnicodeString{}
	}
	if err := _DummyString3.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString4
	var _DummyString4 *dtyp.UnicodeString
	if _DummyString4 == nil {
		_DummyString4 = &dtyp.UnicodeString{}
	}
	if err := _DummyString4.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyLong1
	var _DummyLong1 uint32
	if err := w.ReadData(&_DummyLong1); err != nil {
		return err
	}
	// reserved DummyLong2
	var _DummyLong2 uint32
	if err := w.ReadData(&_DummyLong2); err != nil {
		return err
	}
	// reserved DummyLong3
	var _DummyLong3 uint32
	if err := w.ReadData(&_DummyLong3); err != nil {
		return err
	}
	// reserved DummyLong4
	var _DummyLong4 uint32
	if err := w.ReadData(&_DummyLong4); err != nil {
		return err
	}
	return nil
}

// RenameAlias structure represents NETLOGON_RENAME_ALIAS RPC structure.
//
// The NETLOGON_RENAME_ALIAS structure specifies a rename of an alias.
type RenameAlias struct {
	// OldName: An RPC_UNICODE_STRING structure, as specified in [MS-DTYP] section 2.3.10,
	// that contains the previous name of the alias.
	OldName *dtyp.UnicodeString `idl:"name:OldName" json:"old_name"`
	// NewName: An RPC_UNICODE_STRING structure, as specified in [MS-DTYP] section 2.3.10,
	// that contains the new name to assign to the alias.
	NewName *dtyp.UnicodeString `idl:"name:NewName" json:"new_name"`
	// DummyString1: A STRING structure, defined in section 2.2.1.1.2, that MUST contain
	// 0 for the Length field, 0 for the MaximumLength field, and NULL for the Buffer field.
	// It is ignored upon receipt. The Netlogon usage of dummy fields is described in section
	// 1.3.8.1.2.
	_ *dtyp.UnicodeString `idl:"name:DummyString1"`
	// DummyString2: See definition for DummyString1.
	_ *dtyp.UnicodeString `idl:"name:DummyString2"`
	// DummyString3: See definition for DummyString1.
	_ *dtyp.UnicodeString `idl:"name:DummyString3"`
	// DummyString4: See definition for DummyString1.
	_ *dtyp.UnicodeString `idl:"name:DummyString4"`
	// DummyLong1: MUST be set to zero and MUST be ignored on receipt. The Netlogon usage
	// of dummy fields is described in section 1.3.8.1.2.
	_ uint32 `idl:"name:DummyLong1"`
	// DummyLong2: See definition for DummyLong1.
	_ uint32 `idl:"name:DummyLong2"`
	// DummyLong3: See definition for DummyLong1.
	_ uint32 `idl:"name:DummyLong3"`
	// DummyLong4: See definition for DummyLong1.
	_ uint32 `idl:"name:DummyLong4"`
}

func (o *RenameAlias) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *RenameAlias) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.OldName != nil {
		if err := o.OldName.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.NewName != nil {
		if err := o.NewName.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// reserved DummyString1
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString2
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString3
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString4
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyLong1
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong2
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong3
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong4
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	return nil
}
func (o *RenameAlias) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if o.OldName == nil {
		o.OldName = &dtyp.UnicodeString{}
	}
	if err := o.OldName.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.NewName == nil {
		o.NewName = &dtyp.UnicodeString{}
	}
	if err := o.NewName.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString1
	var _DummyString1 *dtyp.UnicodeString
	if _DummyString1 == nil {
		_DummyString1 = &dtyp.UnicodeString{}
	}
	if err := _DummyString1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString2
	var _DummyString2 *dtyp.UnicodeString
	if _DummyString2 == nil {
		_DummyString2 = &dtyp.UnicodeString{}
	}
	if err := _DummyString2.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString3
	var _DummyString3 *dtyp.UnicodeString
	if _DummyString3 == nil {
		_DummyString3 = &dtyp.UnicodeString{}
	}
	if err := _DummyString3.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString4
	var _DummyString4 *dtyp.UnicodeString
	if _DummyString4 == nil {
		_DummyString4 = &dtyp.UnicodeString{}
	}
	if err := _DummyString4.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyLong1
	var _DummyLong1 uint32
	if err := w.ReadData(&_DummyLong1); err != nil {
		return err
	}
	// reserved DummyLong2
	var _DummyLong2 uint32
	if err := w.ReadData(&_DummyLong2); err != nil {
		return err
	}
	// reserved DummyLong3
	var _DummyLong3 uint32
	if err := w.ReadData(&_DummyLong3); err != nil {
		return err
	}
	// reserved DummyLong4
	var _DummyLong4 uint32
	if err := w.ReadData(&_DummyLong4); err != nil {
		return err
	}
	return nil
}

// DeltaPolicy structure represents NETLOGON_DELTA_POLICY RPC structure.
//
// The NETLOGON_DELTA_POLICY structure contains information about the LSA policy. This
// structure is used for replicating the LSA policy data from the PDC to a BDC, as detailed
// in section 3.6.
type DeltaPolicy struct {
	// MaximumLogSize: This field has the same meaning as the identically named field of
	// the POLICY_AUDIT_LOG_INFO structure, as specified in [MS-LSAD] section 2.2.4.3.
	MaximumLogSize uint32 `idl:"name:MaximumLogSize" json:"maximum_log_size"`
	// AuditRetentionPeriod: This field has the same meaning as the identically named field
	// of the POLICY_AUDIT_LOG_INFO structure, as specified in [MS-LSAD] section 2.2.4.3.
	AuditRetentionPeriod *OldLargeInteger `idl:"name:AuditRetentionPeriod" json:"audit_retention_period"`
	// AuditingMode: This field has the same meaning as the identically named field of the
	// LSAPR_POLICY_AUDIT_EVENTS_INFO structure, as specified in [MS-LSAD] section 2.2.4.4.
	AuditingMode uint8 `idl:"name:AuditingMode" json:"auditing_mode"`
	// MaximumAuditEventCount: This field has the same meaning as the identically named
	// field of the LSAPR_POLICY_AUDIT_EVENTS_INFO structure, as specified in [MS-LSAD]
	// section 2.2.4.4.
	MaximumAuditEventCount uint32 `idl:"name:MaximumAuditEventCount" json:"maximum_audit_event_count"`
	// EventAuditingOptions: This field has the same meaning as the identically named field
	// of the LSAPR_POLICY_AUDIT_EVENTS_INFO structure, as specified in [MS-LSAD] section
	// 2.2.4.4.
	EventAuditingOptions []uint32 `idl:"name:EventAuditingOptions;size_is:((MaximumAuditEventCount+1))" json:"event_auditing_options"`
	// PrimaryDomainName: An RPC_UNICODE_STRING structure, as specified in [MS-DTYP] section
	// 2.3.10, that contains the NetBIOS name of the primary domain.
	PrimaryDomainName *dtyp.UnicodeString `idl:"name:PrimaryDomainName" json:"primary_domain_name"`
	// PrimaryDomainSid:A pointer to the SID for the primary domain.
	PrimaryDomainSID *dtyp.SID `idl:"name:PrimaryDomainSid" json:"primary_domain_sid"`
	// QuotaLimits: An NLPR_QUOTA_LIMITS structure, as specified in section 2.2.1.5.2, that
	// contains information about system resource quotas imposed on an account.
	QuotaLimits *QuotaLimits `idl:"name:QuotaLimits" json:"quota_limits"`
	// ModifiedId: An OLD_LARGE_INTEGER structure, as specified in [MS-SAMR] section 2.2.2.2,
	// that contains the count that is incremented each time the database is modified. This
	// count is the database serial number for the database.
	ModifiedID *OldLargeInteger `idl:"name:ModifiedId" json:"modified_id"`
	// DatabaseCreationTime: A 64-bit time stamp, equivalent to a FILETIME, specifying when
	// the database was created.
	DatabaseCreationTime *OldLargeInteger `idl:"name:DatabaseCreationTime" json:"database_creation_time"`
	// SecurityInformation: A SECURITY_INFORMATION bit flag that contains security information
	// about the policy. For details about SECURITY_INFORMATION structure, see [MS-DTYP]
	// section 2.4.7.
	SecurityInformation uint32 `idl:"name:SecurityInformation" json:"security_information"`
	// SecuritySize: The size, in bytes, of the SecurityDescriptor field.
	SecuritySize uint32 `idl:"name:SecuritySize" json:"security_size"`
	// SecurityDescriptor: A pointer to a SECURITY_DESCRIPTOR structure, as specified in
	// [MS-DTYP] section 2.4.6, that describes the security settings for the LSA policy
	// object.
	SecurityDescriptor []byte `idl:"name:SecurityDescriptor;size_is:(SecuritySize)" json:"security_descriptor"`
	// DummyString1: A STRING structure, defined in section 2.2.1.1.2, that MUST contain
	// 0 for the Length field, 0 for the MaximumLength field, and NULL for the Buffer field.
	// It is ignored upon receipt. The Netlogon usage of dummy fields is described in section
	// 1.3.8.1.2.
	_ *dtyp.UnicodeString `idl:"name:DummyString1"`
	// DummyString2: See definition for DummyString1.
	_ *dtyp.UnicodeString `idl:"name:DummyString2"`
	// DummyString3: See definition for DummyString1.
	_ *dtyp.UnicodeString `idl:"name:DummyString3"`
	// DummyString4: See definition for DummyString1.
	_ *dtyp.UnicodeString `idl:"name:DummyString4"`
	// DummyLong1: MUST be set to zero and MUST be ignored on receipt. The Netlogon usage
	// of dummy fields is described in section 1.3.8.1.2.
	_ uint32 `idl:"name:DummyLong1"`
	// DummyLong2: See definition for DummyLong1.
	_ uint32 `idl:"name:DummyLong2"`
	// DummyLong3: See definition for DummyLong1.
	_ uint32 `idl:"name:DummyLong3"`
	// DummyLong4: See definition for DummyLong1.
	_ uint32 `idl:"name:DummyLong4"`
}

func (o *DeltaPolicy) xxx_PreparePayload(ctx context.Context) error {
	if o.EventAuditingOptions != nil && o.MaximumAuditEventCount == 0 {
		o.MaximumAuditEventCount = uint32((len(o.EventAuditingOptions) - 1))
		if len(o.EventAuditingOptions) < 1 {
			o.MaximumAuditEventCount = uint32(0)
		}
	}
	if o.SecurityDescriptor != nil && o.SecuritySize == 0 {
		o.SecuritySize = uint32(len(o.SecurityDescriptor))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *DeltaPolicy) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.MaximumLogSize); err != nil {
		return err
	}
	if o.AuditRetentionPeriod != nil {
		if err := o.AuditRetentionPeriod.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&OldLargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.AuditingMode); err != nil {
		return err
	}
	if err := w.WriteData(o.MaximumAuditEventCount); err != nil {
		return err
	}
	if o.EventAuditingOptions != nil || (o.MaximumAuditEventCount+1) > 0 {
		_ptr_EventAuditingOptions := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64((o.MaximumAuditEventCount + 1))
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.EventAuditingOptions {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.EventAuditingOptions[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.EventAuditingOptions); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint32(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.EventAuditingOptions, _ptr_EventAuditingOptions); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.PrimaryDomainName != nil {
		if err := o.PrimaryDomainName.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.PrimaryDomainSID != nil {
		_ptr_PrimaryDomainSid := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.PrimaryDomainSID != nil {
				if err := o.PrimaryDomainSID.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&dtyp.SID{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.PrimaryDomainSID, _ptr_PrimaryDomainSid); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.QuotaLimits != nil {
		if err := o.QuotaLimits.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&QuotaLimits{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.ModifiedID != nil {
		if err := o.ModifiedID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&OldLargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.DatabaseCreationTime != nil {
		if err := o.DatabaseCreationTime.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&OldLargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.SecurityInformation); err != nil {
		return err
	}
	if err := w.WriteData(o.SecuritySize); err != nil {
		return err
	}
	if o.SecurityDescriptor != nil || o.SecuritySize > 0 {
		_ptr_SecurityDescriptor := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.SecuritySize)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.SecurityDescriptor {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.SecurityDescriptor[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.SecurityDescriptor); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.SecurityDescriptor, _ptr_SecurityDescriptor); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	// reserved DummyString1
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString2
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString3
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString4
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyLong1
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong2
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong3
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong4
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	return nil
}
func (o *DeltaPolicy) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaximumLogSize); err != nil {
		return err
	}
	if o.AuditRetentionPeriod == nil {
		o.AuditRetentionPeriod = &OldLargeInteger{}
	}
	if err := o.AuditRetentionPeriod.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.AuditingMode); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaximumAuditEventCount); err != nil {
		return err
	}
	_ptr_EventAuditingOptions := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if (o.MaximumAuditEventCount+1) > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64((o.MaximumAuditEventCount + 1))
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.EventAuditingOptions", sizeInfo[0])
		}
		o.EventAuditingOptions = make([]uint32, sizeInfo[0])
		for i1 := range o.EventAuditingOptions {
			i1 := i1
			if err := w.ReadData(&o.EventAuditingOptions[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_EventAuditingOptions := func(ptr interface{}) { o.EventAuditingOptions = *ptr.(*[]uint32) }
	if err := w.ReadPointer(&o.EventAuditingOptions, _s_EventAuditingOptions, _ptr_EventAuditingOptions); err != nil {
		return err
	}
	if o.PrimaryDomainName == nil {
		o.PrimaryDomainName = &dtyp.UnicodeString{}
	}
	if err := o.PrimaryDomainName.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_PrimaryDomainSid := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.PrimaryDomainSID == nil {
			o.PrimaryDomainSID = &dtyp.SID{}
		}
		if err := o.PrimaryDomainSID.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_PrimaryDomainSid := func(ptr interface{}) { o.PrimaryDomainSID = *ptr.(**dtyp.SID) }
	if err := w.ReadPointer(&o.PrimaryDomainSID, _s_PrimaryDomainSid, _ptr_PrimaryDomainSid); err != nil {
		return err
	}
	if o.QuotaLimits == nil {
		o.QuotaLimits = &QuotaLimits{}
	}
	if err := o.QuotaLimits.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.ModifiedID == nil {
		o.ModifiedID = &OldLargeInteger{}
	}
	if err := o.ModifiedID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.DatabaseCreationTime == nil {
		o.DatabaseCreationTime = &OldLargeInteger{}
	}
	if err := o.DatabaseCreationTime.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.SecurityInformation); err != nil {
		return err
	}
	if err := w.ReadData(&o.SecuritySize); err != nil {
		return err
	}
	_ptr_SecurityDescriptor := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.SecuritySize > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.SecuritySize)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.SecurityDescriptor", sizeInfo[0])
		}
		o.SecurityDescriptor = make([]byte, sizeInfo[0])
		for i1 := range o.SecurityDescriptor {
			i1 := i1
			if err := w.ReadData(&o.SecurityDescriptor[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_SecurityDescriptor := func(ptr interface{}) { o.SecurityDescriptor = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.SecurityDescriptor, _s_SecurityDescriptor, _ptr_SecurityDescriptor); err != nil {
		return err
	}
	// reserved DummyString1
	var _DummyString1 *dtyp.UnicodeString
	if _DummyString1 == nil {
		_DummyString1 = &dtyp.UnicodeString{}
	}
	if err := _DummyString1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString2
	var _DummyString2 *dtyp.UnicodeString
	if _DummyString2 == nil {
		_DummyString2 = &dtyp.UnicodeString{}
	}
	if err := _DummyString2.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString3
	var _DummyString3 *dtyp.UnicodeString
	if _DummyString3 == nil {
		_DummyString3 = &dtyp.UnicodeString{}
	}
	if err := _DummyString3.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString4
	var _DummyString4 *dtyp.UnicodeString
	if _DummyString4 == nil {
		_DummyString4 = &dtyp.UnicodeString{}
	}
	if err := _DummyString4.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyLong1
	var _DummyLong1 uint32
	if err := w.ReadData(&_DummyLong1); err != nil {
		return err
	}
	// reserved DummyLong2
	var _DummyLong2 uint32
	if err := w.ReadData(&_DummyLong2); err != nil {
		return err
	}
	// reserved DummyLong3
	var _DummyLong3 uint32
	if err := w.ReadData(&_DummyLong3); err != nil {
		return err
	}
	// reserved DummyLong4
	var _DummyLong4 uint32
	if err := w.ReadData(&_DummyLong4); err != nil {
		return err
	}
	return nil
}

// DeltaTrustedDomains structure represents NETLOGON_DELTA_TRUSTED_DOMAINS RPC structure.
//
// The NETLOGON_DELTA_TRUSTED_DOMAINS structure contains information about a trusted
// domain. This structure is used for replicating the trusted domain data from the PDC
// to a BDC.
type DeltaTrustedDomains struct {
	// DomainName: An RPC_UNICODE_STRING structure, as specified in [MS-DTYP] section 2.3.10,
	// that contains the NetBIOS name of the trusted domain.
	DomainName *dtyp.UnicodeString `idl:"name:DomainName" json:"domain_name"`
	// NumControllerEntries: Number of domain controller (DC) names listed in the ControllerNames
	// field.<51>
	ControllerEntriesLength uint32 `idl:"name:NumControllerEntries" json:"controller_entries_length"`
	// ControllerNames: Pointer to an array of RPC_UNICODE_STRING structures, as specified
	// in [MS-DTYP] section 2.3.10, that contain the NetBIOS names of the DCs in the trusted
	// domain. The only restriction is the maximum value of the 32-bit unsigned integer
	// enforced by RPC.<52>
	ControllerNames []*dtyp.UnicodeString `idl:"name:ControllerNames;size_is:(NumControllerEntries)" json:"controller_names"`
	// SecurityInformation: A SECURITY_INFORMATION structure, as specified in [MS-DTYP]
	// section 2.4.7, that specifies portions of a security descriptor about the trusted
	// domain.
	SecurityInformation uint32 `idl:"name:SecurityInformation" json:"security_information"`
	// SecuritySize: Size, in bytes, of the SecurityDescriptor field.
	SecuritySize uint32 `idl:"name:SecuritySize" json:"security_size"`
	// SecurityDescriptor: Pointer to a SECURITY_DESCRIPTOR structure, as specified in [MS-DTYP]
	// section 2.4.6 that describes the security settings for the trusted domain object.
	SecurityDescriptor []byte `idl:"name:SecurityDescriptor;size_is:(SecuritySize)" json:"security_descriptor"`
	// DummyString1: A STRING structure, defined in section 2.2.1.1.2, that MUST contain
	// 0 for the Length field, 0 for the MaximumLength field, and NULL for the Buffer field.
	// It is ignored upon receipt. The Netlogon usage of dummy fields is described in section
	// 1.3.8.1.2.
	_ *dtyp.UnicodeString `idl:"name:DummyString1"`
	// DummyString2: See definition for DummyString1.
	_ *dtyp.UnicodeString `idl:"name:DummyString2"`
	// DummyString3: See definition for DummyString1.
	_ *dtyp.UnicodeString `idl:"name:DummyString3"`
	// DummyString4: See definition for DummyString1.
	_ *dtyp.UnicodeString `idl:"name:DummyString4"`
	// TrustedPosixOffset: The value that contains the POSIX offset for the trusted domain,
	// as specified in [MS-ADTS] section 6.1.6.
	TrustedPOSIXOffset uint32 `idl:"name:TrustedPosixOffset" json:"trusted_posix_offset"`
	// DummyLong2: MUST be set to zero and MUST be ignored on receipt. The Netlogon usage
	// of dummy fields is described in section 1.3.8.1.2.
	_ uint32 `idl:"name:DummyLong2"`
	// DummyLong3: See definition for DummyLong2.
	_ uint32 `idl:"name:DummyLong3"`
	// DummyLong4: See definition for DummyLong2.
	_ uint32 `idl:"name:DummyLong4"`
}

func (o *DeltaTrustedDomains) xxx_PreparePayload(ctx context.Context) error {
	if o.ControllerNames != nil && o.ControllerEntriesLength == 0 {
		o.ControllerEntriesLength = uint32(len(o.ControllerNames))
	}
	if o.SecurityDescriptor != nil && o.SecuritySize == 0 {
		o.SecuritySize = uint32(len(o.SecurityDescriptor))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *DeltaTrustedDomains) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.DomainName != nil {
		if err := o.DomainName.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.ControllerEntriesLength); err != nil {
		return err
	}
	if o.ControllerNames != nil || o.ControllerEntriesLength > 0 {
		_ptr_ControllerNames := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.ControllerEntriesLength)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.ControllerNames {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.ControllerNames[i1] != nil {
					if err := o.ControllerNames[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.ControllerNames); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ControllerNames, _ptr_ControllerNames); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.SecurityInformation); err != nil {
		return err
	}
	if err := w.WriteData(o.SecuritySize); err != nil {
		return err
	}
	if o.SecurityDescriptor != nil || o.SecuritySize > 0 {
		_ptr_SecurityDescriptor := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.SecuritySize)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.SecurityDescriptor {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.SecurityDescriptor[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.SecurityDescriptor); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.SecurityDescriptor, _ptr_SecurityDescriptor); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	// reserved DummyString1
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString2
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString3
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString4
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.WriteData(o.TrustedPOSIXOffset); err != nil {
		return err
	}
	// reserved DummyLong2
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong3
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong4
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	return nil
}
func (o *DeltaTrustedDomains) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if o.DomainName == nil {
		o.DomainName = &dtyp.UnicodeString{}
	}
	if err := o.DomainName.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.ControllerEntriesLength); err != nil {
		return err
	}
	_ptr_ControllerNames := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.ControllerEntriesLength > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.ControllerEntriesLength)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.ControllerNames", sizeInfo[0])
		}
		o.ControllerNames = make([]*dtyp.UnicodeString, sizeInfo[0])
		for i1 := range o.ControllerNames {
			i1 := i1
			if o.ControllerNames[i1] == nil {
				o.ControllerNames[i1] = &dtyp.UnicodeString{}
			}
			if err := o.ControllerNames[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_ControllerNames := func(ptr interface{}) { o.ControllerNames = *ptr.(*[]*dtyp.UnicodeString) }
	if err := w.ReadPointer(&o.ControllerNames, _s_ControllerNames, _ptr_ControllerNames); err != nil {
		return err
	}
	if err := w.ReadData(&o.SecurityInformation); err != nil {
		return err
	}
	if err := w.ReadData(&o.SecuritySize); err != nil {
		return err
	}
	_ptr_SecurityDescriptor := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.SecuritySize > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.SecuritySize)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.SecurityDescriptor", sizeInfo[0])
		}
		o.SecurityDescriptor = make([]byte, sizeInfo[0])
		for i1 := range o.SecurityDescriptor {
			i1 := i1
			if err := w.ReadData(&o.SecurityDescriptor[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_SecurityDescriptor := func(ptr interface{}) { o.SecurityDescriptor = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.SecurityDescriptor, _s_SecurityDescriptor, _ptr_SecurityDescriptor); err != nil {
		return err
	}
	// reserved DummyString1
	var _DummyString1 *dtyp.UnicodeString
	if _DummyString1 == nil {
		_DummyString1 = &dtyp.UnicodeString{}
	}
	if err := _DummyString1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString2
	var _DummyString2 *dtyp.UnicodeString
	if _DummyString2 == nil {
		_DummyString2 = &dtyp.UnicodeString{}
	}
	if err := _DummyString2.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString3
	var _DummyString3 *dtyp.UnicodeString
	if _DummyString3 == nil {
		_DummyString3 = &dtyp.UnicodeString{}
	}
	if err := _DummyString3.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString4
	var _DummyString4 *dtyp.UnicodeString
	if _DummyString4 == nil {
		_DummyString4 = &dtyp.UnicodeString{}
	}
	if err := _DummyString4.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.TrustedPOSIXOffset); err != nil {
		return err
	}
	// reserved DummyLong2
	var _DummyLong2 uint32
	if err := w.ReadData(&_DummyLong2); err != nil {
		return err
	}
	// reserved DummyLong3
	var _DummyLong3 uint32
	if err := w.ReadData(&_DummyLong3); err != nil {
		return err
	}
	// reserved DummyLong4
	var _DummyLong4 uint32
	if err := w.ReadData(&_DummyLong4); err != nil {
		return err
	}
	return nil
}

// DeltaAccounts structure represents NETLOGON_DELTA_ACCOUNTS RPC structure.
//
// The NETLOGON_DELTA_ACCOUNTS structure contains the settings and privileges for a
// Local Security Authority (LSA) account. This structure is used for replicating the
// LSA account data from the primary domain controller (PDC) to a backup domain controller
// (BDC).
type DeltaAccounts struct {
	// PrivilegeEntries: The number of privileges associated with the LSA account.
	PrivilegeEntries uint32 `idl:"name:PrivilegeEntries" json:"privilege_entries"`
	// PrivilegeControl: A bit flag describing the properties of the account privileges.
	// A flag is TRUE (or set) if its value is equal to 1. The PrivilegeControl value is
	// as follows.
	//
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
	//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | A |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//
	// Where the bits are defined as:
	//
	//	+-------+----------------------------------------------------------------------------------+
	//	|       |                                                                                  |
	//	| VALUE |                                   DESCRIPTION                                    |
	//	|       |                                                                                  |
	//	+-------+----------------------------------------------------------------------------------+
	//	+-------+----------------------------------------------------------------------------------+
	//	| A     | All of the specified privileges MUST be held by the process that is requesting   |
	//	|       | access.                                                                          |
	//	+-------+----------------------------------------------------------------------------------+
	PrivilegeControl uint32 `idl:"name:PrivilegeControl" json:"privilege_control"`
	// PrivilegeAttributes: Pointer to an array of unsigned 32-bit values that contain a
	// set of bit flags describing each privilege's attributes. An attribute is TRUE (or
	// set) if its value is equal to 1. The value is constructed from zero or more bit flags
	// from the following table.
	//
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
	//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | B | A |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//
	// Where the bits are defined as:
	//
	//	+-------+----------------------------------+
	//	|       |                                  |
	//	| VALUE |           DESCRIPTION            |
	//	|       |                                  |
	//	+-------+----------------------------------+
	//	+-------+----------------------------------+
	//	| A     | Privilege is enabled by default. |
	//	+-------+----------------------------------+
	//	| B     | Privilege is enabled.            |
	//	+-------+----------------------------------+
	PrivilegeAttributes []uint32 `idl:"name:PrivilegeAttributes;size_is:(PrivilegeEntries)" json:"privilege_attributes"`
	// PrivilegeNames: A pointer to an array of privilege names represented as RPC_UNICODE_STRING
	// structures. See [MS-DTYP] section 2.3.10 for a specification of the RPC_UNICODE_STRING
	// structure. The names of the privileges are implementation specific.
	PrivilegeNames []*dtyp.UnicodeString `idl:"name:PrivilegeNames;size_is:(PrivilegeEntries)" json:"privilege_names"`
	// QuotaLimits: An NLPR_QUOTA_LIMITS structure (section 2.2.1.5.2) that describes the
	// account's current quota settings.
	QuotaLimits *QuotaLimits `idl:"name:QuotaLimits" json:"quota_limits"`
	// SystemAccessFlags: A set of the following bit flags that specify the ways in which
	// the account is permitted to access the system as detailed in POLICY_MODE_INTERACTIVE,
	// POLICY_MODE_NETWORK, POLICY_MODE_BATCH, POLICY_MODE_SERVICE, and POLICY_MODE_PROXY
	// of [MS-LSAD]. See [MS-LSAD] for the specification of these bit values and allowed
	// combinations.
	SystemAccessFlags uint32 `idl:"name:SystemAccessFlags" json:"system_access_flags"`
	// SecurityInformation: A SECURITY_INFORMATION structure, as specified in [MS-DTYP]
	// section 2.4.7, that specifies portions of a security descriptor about the trusted
	// domain.
	SecurityInformation uint32 `idl:"name:SecurityInformation" json:"security_information"`
	// SecuritySize: The size, in bytes, of the SecurityDescriptor field.
	SecuritySize uint32 `idl:"name:SecuritySize" json:"security_size"`
	// SecurityDescriptor: A pointer to a SECURITY_DESCRIPTOR structure, as specified in
	// [MS-DTYP] section 2.4.6, that describes the security settings for the account object.
	SecurityDescriptor []byte `idl:"name:SecurityDescriptor;size_is:(SecuritySize)" json:"security_descriptor"`
	// DummyString1: A STRING structure, defined in section 2.2.1.1.2, that MUST contain
	// 0 for the Length field, 0 for the MaximumLength field, and NULL for the Buffer field.
	// It is ignored upon receipt. The Netlogon usage of dummy fields is described in section
	// 1.3.8.1.2.
	_ *dtyp.UnicodeString `idl:"name:DummyString1"`
	// DummyString2: See definition for DummyString1 field.
	_ *dtyp.UnicodeString `idl:"name:DummyString2"`
	// DummyString3: See definition for DummyString1 field.
	_ *dtyp.UnicodeString `idl:"name:DummyString3"`
	// DummyString4: See definition for DummyString1 field.
	_ *dtyp.UnicodeString `idl:"name:DummyString4"`
	// DummyLong1: MUST be set to zero and MUST be ignored on receipt. The Netlogon usage
	// of dummy fields is described in section 1.3.8.1.2.
	_ uint32 `idl:"name:DummyLong1"`
	// DummyLong2: See definition for DummyLong1 field.
	_ uint32 `idl:"name:DummyLong2"`
	// DummyLong3: See definition for DummyLong1 field.
	_ uint32 `idl:"name:DummyLong3"`
	// DummyLong4: See definition for DummyLong1 field.
	_ uint32 `idl:"name:DummyLong4"`
}

func (o *DeltaAccounts) xxx_PreparePayload(ctx context.Context) error {
	if o.PrivilegeAttributes != nil && o.PrivilegeEntries == 0 {
		o.PrivilegeEntries = uint32(len(o.PrivilegeAttributes))
	}
	if o.PrivilegeNames != nil && o.PrivilegeEntries == 0 {
		o.PrivilegeEntries = uint32(len(o.PrivilegeNames))
	}
	if o.SecurityDescriptor != nil && o.SecuritySize == 0 {
		o.SecuritySize = uint32(len(o.SecurityDescriptor))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *DeltaAccounts) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.PrivilegeEntries); err != nil {
		return err
	}
	if err := w.WriteData(o.PrivilegeControl); err != nil {
		return err
	}
	if o.PrivilegeAttributes != nil || o.PrivilegeEntries > 0 {
		_ptr_PrivilegeAttributes := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.PrivilegeEntries)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.PrivilegeAttributes {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.PrivilegeAttributes[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.PrivilegeAttributes); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint32(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.PrivilegeAttributes, _ptr_PrivilegeAttributes); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.PrivilegeNames != nil || o.PrivilegeEntries > 0 {
		_ptr_PrivilegeNames := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.PrivilegeEntries)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.PrivilegeNames {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.PrivilegeNames[i1] != nil {
					if err := o.PrivilegeNames[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.PrivilegeNames); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.PrivilegeNames, _ptr_PrivilegeNames); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.QuotaLimits != nil {
		if err := o.QuotaLimits.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&QuotaLimits{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.SystemAccessFlags); err != nil {
		return err
	}
	if err := w.WriteData(o.SecurityInformation); err != nil {
		return err
	}
	if err := w.WriteData(o.SecuritySize); err != nil {
		return err
	}
	if o.SecurityDescriptor != nil || o.SecuritySize > 0 {
		_ptr_SecurityDescriptor := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.SecuritySize)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.SecurityDescriptor {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.SecurityDescriptor[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.SecurityDescriptor); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.SecurityDescriptor, _ptr_SecurityDescriptor); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	// reserved DummyString1
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString2
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString3
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString4
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyLong1
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong2
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong3
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong4
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	return nil
}
func (o *DeltaAccounts) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.PrivilegeEntries); err != nil {
		return err
	}
	if err := w.ReadData(&o.PrivilegeControl); err != nil {
		return err
	}
	_ptr_PrivilegeAttributes := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.PrivilegeEntries > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.PrivilegeEntries)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.PrivilegeAttributes", sizeInfo[0])
		}
		o.PrivilegeAttributes = make([]uint32, sizeInfo[0])
		for i1 := range o.PrivilegeAttributes {
			i1 := i1
			if err := w.ReadData(&o.PrivilegeAttributes[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_PrivilegeAttributes := func(ptr interface{}) { o.PrivilegeAttributes = *ptr.(*[]uint32) }
	if err := w.ReadPointer(&o.PrivilegeAttributes, _s_PrivilegeAttributes, _ptr_PrivilegeAttributes); err != nil {
		return err
	}
	_ptr_PrivilegeNames := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.PrivilegeEntries > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.PrivilegeEntries)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.PrivilegeNames", sizeInfo[0])
		}
		o.PrivilegeNames = make([]*dtyp.UnicodeString, sizeInfo[0])
		for i1 := range o.PrivilegeNames {
			i1 := i1
			if o.PrivilegeNames[i1] == nil {
				o.PrivilegeNames[i1] = &dtyp.UnicodeString{}
			}
			if err := o.PrivilegeNames[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_PrivilegeNames := func(ptr interface{}) { o.PrivilegeNames = *ptr.(*[]*dtyp.UnicodeString) }
	if err := w.ReadPointer(&o.PrivilegeNames, _s_PrivilegeNames, _ptr_PrivilegeNames); err != nil {
		return err
	}
	if o.QuotaLimits == nil {
		o.QuotaLimits = &QuotaLimits{}
	}
	if err := o.QuotaLimits.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.SystemAccessFlags); err != nil {
		return err
	}
	if err := w.ReadData(&o.SecurityInformation); err != nil {
		return err
	}
	if err := w.ReadData(&o.SecuritySize); err != nil {
		return err
	}
	_ptr_SecurityDescriptor := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.SecuritySize > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.SecuritySize)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.SecurityDescriptor", sizeInfo[0])
		}
		o.SecurityDescriptor = make([]byte, sizeInfo[0])
		for i1 := range o.SecurityDescriptor {
			i1 := i1
			if err := w.ReadData(&o.SecurityDescriptor[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_SecurityDescriptor := func(ptr interface{}) { o.SecurityDescriptor = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.SecurityDescriptor, _s_SecurityDescriptor, _ptr_SecurityDescriptor); err != nil {
		return err
	}
	// reserved DummyString1
	var _DummyString1 *dtyp.UnicodeString
	if _DummyString1 == nil {
		_DummyString1 = &dtyp.UnicodeString{}
	}
	if err := _DummyString1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString2
	var _DummyString2 *dtyp.UnicodeString
	if _DummyString2 == nil {
		_DummyString2 = &dtyp.UnicodeString{}
	}
	if err := _DummyString2.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString3
	var _DummyString3 *dtyp.UnicodeString
	if _DummyString3 == nil {
		_DummyString3 = &dtyp.UnicodeString{}
	}
	if err := _DummyString3.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString4
	var _DummyString4 *dtyp.UnicodeString
	if _DummyString4 == nil {
		_DummyString4 = &dtyp.UnicodeString{}
	}
	if err := _DummyString4.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyLong1
	var _DummyLong1 uint32
	if err := w.ReadData(&_DummyLong1); err != nil {
		return err
	}
	// reserved DummyLong2
	var _DummyLong2 uint32
	if err := w.ReadData(&_DummyLong2); err != nil {
		return err
	}
	// reserved DummyLong3
	var _DummyLong3 uint32
	if err := w.ReadData(&_DummyLong3); err != nil {
		return err
	}
	// reserved DummyLong4
	var _DummyLong4 uint32
	if err := w.ReadData(&_DummyLong4); err != nil {
		return err
	}
	return nil
}

// DeltaSecret structure represents NETLOGON_DELTA_SECRET RPC structure.
//
// The NETLOGON_DELTA_SECRET structure contains information about the LSA secret object,
// as specified in [MS-LSAD]. This structure is used to replicate the LSA secret object
// data from the PDC to a BDC, as detailed in section 3.6.
type DeltaSecret struct {
	// CurrentValue: An NLPR_CR_CIPHER_VALUE structure, as specified in section 2.2.1.5.20,
	// that contains the encrypted current value of the LSA secret.
	CurrentValue *CRCipherValue `idl:"name:CurrentValue" json:"current_value"`
	// CurrentValueSetTime: A 64-bit time stamp, equivalent to a FILETIME, at which the
	// current value of the LSA secret object was set.
	CurrentValueSetTime *OldLargeInteger `idl:"name:CurrentValueSetTime" json:"current_value_set_time"`
	// OldValue: An NLPR_CR_CIPHER_VALUE structure, as specified in section 2.2.1.5.20,
	// that contains the encrypted previous (old) value of the LSA secret.
	OldValue *CRCipherValue `idl:"name:OldValue" json:"old_value"`
	// OldValueSetTime: A 64-bit time stamp, equivalent to a FILETIME, at which the previous
	// value of the LSA secret object was set.
	OldValueSetTime *OldLargeInteger `idl:"name:OldValueSetTime" json:"old_value_set_time"`
	// SecurityInformation: A SECURITY_INFORMATION structure, as specified in [MS-DTYP]
	// section 2.4.7, that specifies portions of a security descriptor about the secret
	// object.
	SecurityInformation uint32 `idl:"name:SecurityInformation" json:"security_information"`
	// SecuritySize: The size, in bytes, of the SecurityDescriptor member.
	SecuritySize uint32 `idl:"name:SecuritySize" json:"security_size"`
	// SecurityDescriptor: A pointer to a SECURITY_DESCRIPTOR structure, as specified in
	// [MS-DTYP] section 2.4.6 that describes the security settings for the LSA secret object.
	SecurityDescriptor []byte `idl:"name:SecurityDescriptor;size_is:(SecuritySize)" json:"security_descriptor"`
	// DummyString1: A STRING structure, defined in section 2.2.1.1.2, that MUST contain
	// 0 for the Length field, 0 for the MaximumLength field, and NULL for the Buffer field.
	// It is ignored upon receipt. The Netlogon usage of dummy fields is described in section
	// 1.3.8.1.2.
	_ *dtyp.UnicodeString `idl:"name:DummyString1"`
	// DummyString2: See definition for DummyString1.
	_ *dtyp.UnicodeString `idl:"name:DummyString2"`
	// DummyString3: See definition for DummyString1.
	_ *dtyp.UnicodeString `idl:"name:DummyString3"`
	// DummyString4: See definition for DummyString1
	_ *dtyp.UnicodeString `idl:"name:DummyString4"`
	// DummyLong1: MUST be set to zero and MUST be ignored on receipt. The Netlogon usage
	// of dummy fields is described in section 1.3.8.1.2.
	_ uint32 `idl:"name:DummyLong1"`
	// DummyLong2: See definition for DummyLong1.
	_ uint32 `idl:"name:DummyLong2"`
	// DummyLong3: See definition for DummyLong1.
	_ uint32 `idl:"name:DummyLong3"`
	// DummyLong4: See definition for DummyLong1.
	_ uint32 `idl:"name:DummyLong4"`
}

func (o *DeltaSecret) xxx_PreparePayload(ctx context.Context) error {
	if o.SecurityDescriptor != nil && o.SecuritySize == 0 {
		o.SecuritySize = uint32(len(o.SecurityDescriptor))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *DeltaSecret) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.CurrentValue != nil {
		if err := o.CurrentValue.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&CRCipherValue{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.CurrentValueSetTime != nil {
		if err := o.CurrentValueSetTime.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&OldLargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.OldValue != nil {
		if err := o.OldValue.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&CRCipherValue{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.OldValueSetTime != nil {
		if err := o.OldValueSetTime.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&OldLargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.SecurityInformation); err != nil {
		return err
	}
	if err := w.WriteData(o.SecuritySize); err != nil {
		return err
	}
	if o.SecurityDescriptor != nil || o.SecuritySize > 0 {
		_ptr_SecurityDescriptor := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.SecuritySize)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.SecurityDescriptor {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.SecurityDescriptor[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.SecurityDescriptor); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.SecurityDescriptor, _ptr_SecurityDescriptor); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	// reserved DummyString1
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString2
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString3
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString4
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyLong1
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong2
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong3
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong4
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	return nil
}
func (o *DeltaSecret) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if o.CurrentValue == nil {
		o.CurrentValue = &CRCipherValue{}
	}
	if err := o.CurrentValue.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.CurrentValueSetTime == nil {
		o.CurrentValueSetTime = &OldLargeInteger{}
	}
	if err := o.CurrentValueSetTime.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.OldValue == nil {
		o.OldValue = &CRCipherValue{}
	}
	if err := o.OldValue.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.OldValueSetTime == nil {
		o.OldValueSetTime = &OldLargeInteger{}
	}
	if err := o.OldValueSetTime.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.SecurityInformation); err != nil {
		return err
	}
	if err := w.ReadData(&o.SecuritySize); err != nil {
		return err
	}
	_ptr_SecurityDescriptor := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.SecuritySize > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.SecuritySize)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.SecurityDescriptor", sizeInfo[0])
		}
		o.SecurityDescriptor = make([]byte, sizeInfo[0])
		for i1 := range o.SecurityDescriptor {
			i1 := i1
			if err := w.ReadData(&o.SecurityDescriptor[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_SecurityDescriptor := func(ptr interface{}) { o.SecurityDescriptor = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.SecurityDescriptor, _s_SecurityDescriptor, _ptr_SecurityDescriptor); err != nil {
		return err
	}
	// reserved DummyString1
	var _DummyString1 *dtyp.UnicodeString
	if _DummyString1 == nil {
		_DummyString1 = &dtyp.UnicodeString{}
	}
	if err := _DummyString1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString2
	var _DummyString2 *dtyp.UnicodeString
	if _DummyString2 == nil {
		_DummyString2 = &dtyp.UnicodeString{}
	}
	if err := _DummyString2.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString3
	var _DummyString3 *dtyp.UnicodeString
	if _DummyString3 == nil {
		_DummyString3 = &dtyp.UnicodeString{}
	}
	if err := _DummyString3.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString4
	var _DummyString4 *dtyp.UnicodeString
	if _DummyString4 == nil {
		_DummyString4 = &dtyp.UnicodeString{}
	}
	if err := _DummyString4.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyLong1
	var _DummyLong1 uint32
	if err := w.ReadData(&_DummyLong1); err != nil {
		return err
	}
	// reserved DummyLong2
	var _DummyLong2 uint32
	if err := w.ReadData(&_DummyLong2); err != nil {
		return err
	}
	// reserved DummyLong3
	var _DummyLong3 uint32
	if err := w.ReadData(&_DummyLong3); err != nil {
		return err
	}
	// reserved DummyLong4
	var _DummyLong4 uint32
	if err := w.ReadData(&_DummyLong4); err != nil {
		return err
	}
	return nil
}

// DeltaDeleteGroup structure represents NETLOGON_DELTA_DELETE_GROUP RPC structure.
//
// The NETLOGON_DELTA_DELETE_GROUP structure contains information about a group to be
// deleted in the database. This structure is used for replicating the SAM group data
// from the PDC to a BDC, as detailed in section 3.6.
type DeltaDeleteGroup struct {
	// AccountName: A null-terminated Unicode string that contains the name of the group
	// to delete.
	AccountName string `idl:"name:AccountName;string" json:"account_name"`
	// DummyString1: A STRING structure, as defined in section 2.2.1.1.2, that MUST contain
	// 0 for the Length field, 0 for the MaximumLength field, and NULL for the Buffer field.
	// It is ignored upon receipt. The Netlogon usage of dummy fields is described in section
	// 1.3.8.1.2.
	_ *dtyp.UnicodeString `idl:"name:DummyString1"`
	// DummyString2: See definition for DummyString1 field.
	_ *dtyp.UnicodeString `idl:"name:DummyString2"`
	// DummyString3: See definition for DummyString1 field.
	_ *dtyp.UnicodeString `idl:"name:DummyString3"`
	// DummyString4: See definition for DummyString1 field.
	_ *dtyp.UnicodeString `idl:"name:DummyString4"`
	// DummyLong1: MUST be set to zero and MUST be ignored on receipt. The Netlogon usage
	// of dummy fields is described in section 1.3.8.1.2.
	_ uint32 `idl:"name:DummyLong1"`
	// DummyLong2: See definition for DummyLong1 field.
	_ uint32 `idl:"name:DummyLong2"`
	// DummyLong3: See definition for DummyLong1 field.
	_ uint32 `idl:"name:DummyLong3"`
	// DummyLong4: See definition for DummyLong1 field.
	_ uint32 `idl:"name:DummyLong4"`
}

func (o *DeltaDeleteGroup) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *DeltaDeleteGroup) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.AccountName != "" {
		_ptr_AccountName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.AccountName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.AccountName, _ptr_AccountName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	// reserved DummyString1
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString2
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString3
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString4
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyLong1
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong2
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong3
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong4
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	return nil
}
func (o *DeltaDeleteGroup) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_AccountName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.AccountName); err != nil {
			return err
		}
		return nil
	})
	_s_AccountName := func(ptr interface{}) { o.AccountName = *ptr.(*string) }
	if err := w.ReadPointer(&o.AccountName, _s_AccountName, _ptr_AccountName); err != nil {
		return err
	}
	// reserved DummyString1
	var _DummyString1 *dtyp.UnicodeString
	if _DummyString1 == nil {
		_DummyString1 = &dtyp.UnicodeString{}
	}
	if err := _DummyString1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString2
	var _DummyString2 *dtyp.UnicodeString
	if _DummyString2 == nil {
		_DummyString2 = &dtyp.UnicodeString{}
	}
	if err := _DummyString2.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString3
	var _DummyString3 *dtyp.UnicodeString
	if _DummyString3 == nil {
		_DummyString3 = &dtyp.UnicodeString{}
	}
	if err := _DummyString3.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString4
	var _DummyString4 *dtyp.UnicodeString
	if _DummyString4 == nil {
		_DummyString4 = &dtyp.UnicodeString{}
	}
	if err := _DummyString4.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyLong1
	var _DummyLong1 uint32
	if err := w.ReadData(&_DummyLong1); err != nil {
		return err
	}
	// reserved DummyLong2
	var _DummyLong2 uint32
	if err := w.ReadData(&_DummyLong2); err != nil {
		return err
	}
	// reserved DummyLong3
	var _DummyLong3 uint32
	if err := w.ReadData(&_DummyLong3); err != nil {
		return err
	}
	// reserved DummyLong4
	var _DummyLong4 uint32
	if err := w.ReadData(&_DummyLong4); err != nil {
		return err
	}
	return nil
}

// DeltaDeleteUser structure represents NETLOGON_DELTA_DELETE_USER RPC structure.
//
// The NETLOGON_DELTA_DELETE_USER structure contains information about a user account
// to be deleted in the database.
type DeltaDeleteUser struct {
	// AccountName: A null-terminated Unicode string that contains the name of the user
	// to delete.
	AccountName string `idl:"name:AccountName;string" json:"account_name"`
	// DummyString1: A STRING structure, defined in section 2.2.1.1.2, that MUST contain
	// 0 for the Length field, 0 for the MaximumLength field, and NULL for the Buffer field.
	// It is ignored upon receipt. The Netlogon usage of dummy fields is described in section
	// 1.3.8.1.2.
	_ *dtyp.UnicodeString `idl:"name:DummyString1"`
	// DummyString2: See definition for DummyString1.
	_ *dtyp.UnicodeString `idl:"name:DummyString2"`
	// DummyString3: See definition for DummyString1.
	_ *dtyp.UnicodeString `idl:"name:DummyString3"`
	// DummyString4: See definition for DummyString1.
	_ *dtyp.UnicodeString `idl:"name:DummyString4"`
	// DummyLong1: MUST be set to zero and MUST be ignored on receipt. The Netlogon usage
	// of dummy fields is described in section 1.3.8.1.2.
	_ uint32 `idl:"name:DummyLong1"`
	// DummyLong2: See definition for DummyLong1.
	_ uint32 `idl:"name:DummyLong2"`
	// DummyLong3: See definition for DummyLong1.
	_ uint32 `idl:"name:DummyLong3"`
	// DummyLong4: See definition for DummyLong1.
	_ uint32 `idl:"name:DummyLong4"`
}

func (o *DeltaDeleteUser) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *DeltaDeleteUser) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.AccountName != "" {
		_ptr_AccountName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.AccountName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.AccountName, _ptr_AccountName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	// reserved DummyString1
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString2
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString3
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString4
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyLong1
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong2
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong3
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong4
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	return nil
}
func (o *DeltaDeleteUser) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_AccountName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.AccountName); err != nil {
			return err
		}
		return nil
	})
	_s_AccountName := func(ptr interface{}) { o.AccountName = *ptr.(*string) }
	if err := w.ReadPointer(&o.AccountName, _s_AccountName, _ptr_AccountName); err != nil {
		return err
	}
	// reserved DummyString1
	var _DummyString1 *dtyp.UnicodeString
	if _DummyString1 == nil {
		_DummyString1 = &dtyp.UnicodeString{}
	}
	if err := _DummyString1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString2
	var _DummyString2 *dtyp.UnicodeString
	if _DummyString2 == nil {
		_DummyString2 = &dtyp.UnicodeString{}
	}
	if err := _DummyString2.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString3
	var _DummyString3 *dtyp.UnicodeString
	if _DummyString3 == nil {
		_DummyString3 = &dtyp.UnicodeString{}
	}
	if err := _DummyString3.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString4
	var _DummyString4 *dtyp.UnicodeString
	if _DummyString4 == nil {
		_DummyString4 = &dtyp.UnicodeString{}
	}
	if err := _DummyString4.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyLong1
	var _DummyLong1 uint32
	if err := w.ReadData(&_DummyLong1); err != nil {
		return err
	}
	// reserved DummyLong2
	var _DummyLong2 uint32
	if err := w.ReadData(&_DummyLong2); err != nil {
		return err
	}
	// reserved DummyLong3
	var _DummyLong3 uint32
	if err := w.ReadData(&_DummyLong3); err != nil {
		return err
	}
	// reserved DummyLong4
	var _DummyLong4 uint32
	if err := w.ReadData(&_DummyLong4); err != nil {
		return err
	}
	return nil
}

// DeltaType type represents NETLOGON_DELTA_TYPE RPC enumeration.
//
// The NETLOGON_DELTA_TYPE enumeration defines an enumerated set of possible database
// changes.
type DeltaType uint16

var (
	// AddOrChangeDomain: Adds or changes a domain Security Account Manager (SAM) account.
	DeltaTypeAddOrChangeDomain DeltaType = 1
	// AddOrChangeGroup: Adds or changes a group SAM account.
	DeltaTypeAddOrChangeGroup DeltaType = 2
	// DeleteGroup: Deletes a group SAM account.
	DeltaTypeDeleteGroup DeltaType = 3
	// RenameGroup: Renames a group SAM account.
	DeltaTypeRenameGroup DeltaType = 4
	// AddOrChangeUser: Adds or changes a user SAM account.
	DeltaTypeAddOrChangeUser DeltaType = 5
	// DeleteUser: Deletes a user SAM account.
	DeltaTypeDeleteUser DeltaType = 6
	// RenameUser: Renames a user SAM account.
	DeltaTypeRenameUser DeltaType = 7
	// ChangeGroupMembership: Changes a group membership record.
	DeltaTypeChangeGroupMembership DeltaType = 8
	// AddOrChangeAlias: Adds or changes an alias.
	DeltaTypeAddOrChangeAlias DeltaType = 9
	// DeleteAlias: Deletes an alias.
	DeltaTypeDeleteAlias DeltaType = 10
	// RenameAlias: Renames an alias.
	DeltaTypeRenameAlias DeltaType = 11
	// ChangeAliasMembership: Changes the membership record for an alias.
	DeltaTypeChangeAliasMembership DeltaType = 12
	// AddOrChangeLsaPolicy: Adds or changes an LSA policy.
	DeltaTypeAddOrChangeLSAPolicy DeltaType = 13
	// AddOrChangeLsaTDomain: Adds or changes a trusted domain account.
	DeltaTypeAddOrChangeLSADomain DeltaType = 14
	// DeleteLsaTDomain: Deletes a trusted domain account.
	DeltaTypeDeleteLSADomain DeltaType = 15
	// AddOrChangeLsaAccount: Adds or changes an LSA user or machine account.
	DeltaTypeAddOrChangeLSAAccount DeltaType = 16
	// DeleteLsaAccount: Deletes an LSA user or machine account.
	DeltaTypeDeleteLSAAccount DeltaType = 17
	// AddOrChangeLsaSecret: Adds or changes an LSA encrypted data block.
	DeltaTypeAddOrChangeLSASecret DeltaType = 18
	// DeleteLsaSecret: Deletes an LSA encrypted data block.
	//
	// The following three types MAY<53> have an additional requirement.
	DeltaTypeDeleteLSASecret DeltaType = 19
	// DeleteGroupByName: Deletes a group account based on a string name.
	DeltaTypeDeleteGroupByName DeltaType = 20
	// DeleteUserByName: Deletes a user account based on a string name.
	DeltaTypeDeleteUserByName DeltaType = 21
	// SerialNumberSkip: Updates the database serial number.
	DeltaTypeSerialNumberSkip DeltaType = 22
)

func (o DeltaType) String() string {
	switch o {
	case DeltaTypeAddOrChangeDomain:
		return "DeltaTypeAddOrChangeDomain"
	case DeltaTypeAddOrChangeGroup:
		return "DeltaTypeAddOrChangeGroup"
	case DeltaTypeDeleteGroup:
		return "DeltaTypeDeleteGroup"
	case DeltaTypeRenameGroup:
		return "DeltaTypeRenameGroup"
	case DeltaTypeAddOrChangeUser:
		return "DeltaTypeAddOrChangeUser"
	case DeltaTypeDeleteUser:
		return "DeltaTypeDeleteUser"
	case DeltaTypeRenameUser:
		return "DeltaTypeRenameUser"
	case DeltaTypeChangeGroupMembership:
		return "DeltaTypeChangeGroupMembership"
	case DeltaTypeAddOrChangeAlias:
		return "DeltaTypeAddOrChangeAlias"
	case DeltaTypeDeleteAlias:
		return "DeltaTypeDeleteAlias"
	case DeltaTypeRenameAlias:
		return "DeltaTypeRenameAlias"
	case DeltaTypeChangeAliasMembership:
		return "DeltaTypeChangeAliasMembership"
	case DeltaTypeAddOrChangeLSAPolicy:
		return "DeltaTypeAddOrChangeLSAPolicy"
	case DeltaTypeAddOrChangeLSADomain:
		return "DeltaTypeAddOrChangeLSADomain"
	case DeltaTypeDeleteLSADomain:
		return "DeltaTypeDeleteLSADomain"
	case DeltaTypeAddOrChangeLSAAccount:
		return "DeltaTypeAddOrChangeLSAAccount"
	case DeltaTypeDeleteLSAAccount:
		return "DeltaTypeDeleteLSAAccount"
	case DeltaTypeAddOrChangeLSASecret:
		return "DeltaTypeAddOrChangeLSASecret"
	case DeltaTypeDeleteLSASecret:
		return "DeltaTypeDeleteLSASecret"
	case DeltaTypeDeleteGroupByName:
		return "DeltaTypeDeleteGroupByName"
	case DeltaTypeDeleteUserByName:
		return "DeltaTypeDeleteUserByName"
	case DeltaTypeSerialNumberSkip:
		return "DeltaTypeSerialNumberSkip"
	}
	return "Invalid"
}

// DeltaUnion structure represents NETLOGON_DELTA_UNION RPC union.
//
// The NETLOGON_DELTA_UNION union defines a union of all types of database changes (deltas).
type DeltaUnion struct {
	// Types that are assignable to Value
	//
	// *DeltaUnion_DeltaDomain
	// *DeltaUnion_DeltaGroup
	// *DeltaUnion_DeltaRenameGroup
	// *DeltaUnion_DeltaUser
	// *DeltaUnion_DeltaRenameUser
	// *DeltaUnion_DeltaGroupMember
	// *DeltaUnion_DeltaAlias
	// *DeltaUnion_DeltaRenameAlias
	// *DeltaUnion_DeltaAliasMember
	// *DeltaUnion_DeltaPolicy
	// *DeltaUnion_DeltaDomains
	// *DeltaUnion_DeltaAccounts
	// *DeltaUnion_DeltaSecret
	// *DeltaUnion_DeltaDeleteGroup
	// *DeltaUnion_DeltaDeleteUser
	// *DeltaUnion_DeltaSerialNumberSkip
	Value is_DeltaUnion `json:"value"`
}

func (o *DeltaUnion) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *DeltaUnion_DeltaDomain:
		if value != nil {
			return value.DeltaDomain
		}
	case *DeltaUnion_DeltaGroup:
		if value != nil {
			return value.DeltaGroup
		}
	case *DeltaUnion_DeltaRenameGroup:
		if value != nil {
			return value.DeltaRenameGroup
		}
	case *DeltaUnion_DeltaUser:
		if value != nil {
			return value.DeltaUser
		}
	case *DeltaUnion_DeltaRenameUser:
		if value != nil {
			return value.DeltaRenameUser
		}
	case *DeltaUnion_DeltaGroupMember:
		if value != nil {
			return value.DeltaGroupMember
		}
	case *DeltaUnion_DeltaAlias:
		if value != nil {
			return value.DeltaAlias
		}
	case *DeltaUnion_DeltaRenameAlias:
		if value != nil {
			return value.DeltaRenameAlias
		}
	case *DeltaUnion_DeltaAliasMember:
		if value != nil {
			return value.DeltaAliasMember
		}
	case *DeltaUnion_DeltaPolicy:
		if value != nil {
			return value.DeltaPolicy
		}
	case *DeltaUnion_DeltaDomains:
		if value != nil {
			return value.DeltaDomains
		}
	case *DeltaUnion_DeltaAccounts:
		if value != nil {
			return value.DeltaAccounts
		}
	case *DeltaUnion_DeltaSecret:
		if value != nil {
			return value.DeltaSecret
		}
	case *DeltaUnion_DeltaDeleteGroup:
		if value != nil {
			return value.DeltaDeleteGroup
		}
	case *DeltaUnion_DeltaDeleteUser:
		if value != nil {
			return value.DeltaDeleteUser
		}
	case *DeltaUnion_DeltaSerialNumberSkip:
		if value != nil {
			return value.DeltaSerialNumberSkip
		}
	}
	return nil
}

type is_DeltaUnion interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_DeltaUnion()
}

func (o *DeltaUnion) NDRSwitchValue(sw uint16) uint16 {
	if o == nil {
		return uint16(0)
	}
	switch (interface{})(o.Value).(type) {
	case *DeltaUnion_DeltaDomain:
		return uint16(1)
	case *DeltaUnion_DeltaGroup:
		return uint16(2)
	case *DeltaUnion_DeltaRenameGroup:
		return uint16(4)
	case *DeltaUnion_DeltaUser:
		return uint16(5)
	case *DeltaUnion_DeltaRenameUser:
		return uint16(7)
	case *DeltaUnion_DeltaGroupMember:
		return uint16(8)
	case *DeltaUnion_DeltaAlias:
		return uint16(9)
	case *DeltaUnion_DeltaRenameAlias:
		return uint16(11)
	case *DeltaUnion_DeltaAliasMember:
		return uint16(12)
	case *DeltaUnion_DeltaPolicy:
		return uint16(13)
	case *DeltaUnion_DeltaDomains:
		return uint16(14)
	case *DeltaUnion_DeltaAccounts:
		return uint16(16)
	case *DeltaUnion_DeltaSecret:
		return uint16(18)
	case *DeltaUnion_DeltaDeleteGroup:
		return uint16(20)
	case *DeltaUnion_DeltaDeleteUser:
		return uint16(21)
	case *DeltaUnion_DeltaSerialNumberSkip:
		return uint16(22)
	}
	return uint16(0)
}

func (o *DeltaUnion) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint16) error {
	if err := w.WriteUnionAlign(7); err != nil {
		return err
	}
	if err := w.WriteSwitch(ndr.Enum(uint16(sw))); err != nil {
		return err
	}
	// ms_union
	if err := w.WriteAlign(7); err != nil {
		return err
	}
	switch sw {
	case uint16(1):
		_o, _ := o.Value.(*DeltaUnion_DeltaDomain)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DeltaUnion_DeltaDomain{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint16(2):
		_o, _ := o.Value.(*DeltaUnion_DeltaGroup)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DeltaUnion_DeltaGroup{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint16(4):
		_o, _ := o.Value.(*DeltaUnion_DeltaRenameGroup)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DeltaUnion_DeltaRenameGroup{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint16(5):
		_o, _ := o.Value.(*DeltaUnion_DeltaUser)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DeltaUnion_DeltaUser{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint16(7):
		_o, _ := o.Value.(*DeltaUnion_DeltaRenameUser)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DeltaUnion_DeltaRenameUser{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint16(8):
		_o, _ := o.Value.(*DeltaUnion_DeltaGroupMember)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DeltaUnion_DeltaGroupMember{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint16(9):
		_o, _ := o.Value.(*DeltaUnion_DeltaAlias)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DeltaUnion_DeltaAlias{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint16(11):
		_o, _ := o.Value.(*DeltaUnion_DeltaRenameAlias)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DeltaUnion_DeltaRenameAlias{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint16(12):
		_o, _ := o.Value.(*DeltaUnion_DeltaAliasMember)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DeltaUnion_DeltaAliasMember{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint16(13):
		_o, _ := o.Value.(*DeltaUnion_DeltaPolicy)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DeltaUnion_DeltaPolicy{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint16(14):
		_o, _ := o.Value.(*DeltaUnion_DeltaDomains)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DeltaUnion_DeltaDomains{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint16(16):
		_o, _ := o.Value.(*DeltaUnion_DeltaAccounts)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DeltaUnion_DeltaAccounts{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint16(18):
		_o, _ := o.Value.(*DeltaUnion_DeltaSecret)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DeltaUnion_DeltaSecret{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint16(20):
		_o, _ := o.Value.(*DeltaUnion_DeltaDeleteGroup)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DeltaUnion_DeltaDeleteGroup{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint16(21):
		_o, _ := o.Value.(*DeltaUnion_DeltaDeleteUser)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DeltaUnion_DeltaDeleteUser{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint16(22):
		_o, _ := o.Value.(*DeltaUnion_DeltaSerialNumberSkip)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DeltaUnion_DeltaSerialNumberSkip{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
	}
	return nil
}

func (o *DeltaUnion) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint16) error {
	if err := w.ReadUnionAlign(7); err != nil {
		return err
	}
	if err := w.ReadSwitch(ndr.Enum((*uint16)(&sw))); err != nil {
		return err
	}
	// ms_union
	if err := w.ReadAlign(7); err != nil {
		return err
	}
	switch sw {
	case uint16(1):
		o.Value = &DeltaUnion_DeltaDomain{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint16(2):
		o.Value = &DeltaUnion_DeltaGroup{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint16(4):
		o.Value = &DeltaUnion_DeltaRenameGroup{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint16(5):
		o.Value = &DeltaUnion_DeltaUser{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint16(7):
		o.Value = &DeltaUnion_DeltaRenameUser{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint16(8):
		o.Value = &DeltaUnion_DeltaGroupMember{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint16(9):
		o.Value = &DeltaUnion_DeltaAlias{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint16(11):
		o.Value = &DeltaUnion_DeltaRenameAlias{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint16(12):
		o.Value = &DeltaUnion_DeltaAliasMember{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint16(13):
		o.Value = &DeltaUnion_DeltaPolicy{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint16(14):
		o.Value = &DeltaUnion_DeltaDomains{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint16(16):
		o.Value = &DeltaUnion_DeltaAccounts{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint16(18):
		o.Value = &DeltaUnion_DeltaSecret{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint16(20):
		o.Value = &DeltaUnion_DeltaDeleteGroup{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint16(21):
		o.Value = &DeltaUnion_DeltaDeleteUser{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint16(22):
		o.Value = &DeltaUnion_DeltaSerialNumberSkip{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
	}
	return nil
}

// DeltaUnion_DeltaDomain structure represents NETLOGON_DELTA_UNION RPC union arm.
//
// It has following labels: 1
type DeltaUnion_DeltaDomain struct {
	// DeltaDomain: A pointer to a NETLOGON_DELTA_DOMAIN structure, as specified in section
	// 2.2.1.5.10, that describes a domain. This structure is selected when the delta type
	// is AddOrChangeDomain.
	DeltaDomain *DeltaDomain `idl:"name:DeltaDomain" json:"delta_domain"`
}

func (*DeltaUnion_DeltaDomain) is_DeltaUnion() {}

func (o *DeltaUnion_DeltaDomain) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.DeltaDomain != nil {
		_ptr_DeltaDomain := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.DeltaDomain != nil {
				if err := o.DeltaDomain.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DeltaDomain{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.DeltaDomain, _ptr_DeltaDomain); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *DeltaUnion_DeltaDomain) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_DeltaDomain := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.DeltaDomain == nil {
			o.DeltaDomain = &DeltaDomain{}
		}
		if err := o.DeltaDomain.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_DeltaDomain := func(ptr interface{}) { o.DeltaDomain = *ptr.(**DeltaDomain) }
	if err := w.ReadPointer(&o.DeltaDomain, _s_DeltaDomain, _ptr_DeltaDomain); err != nil {
		return err
	}
	return nil
}

// DeltaUnion_DeltaGroup structure represents NETLOGON_DELTA_UNION RPC union arm.
//
// It has following labels: 2
type DeltaUnion_DeltaGroup struct {
	// DeltaGroup: A pointer to a NETLOGON_DELTA_GROUP structure, as specified in section
	// 2.2.1.5.13, that describes a group account. This structure is selected when the delta
	// type is AddOrChangeGroup.
	DeltaGroup *DeltaGroup `idl:"name:DeltaGroup" json:"delta_group"`
}

func (*DeltaUnion_DeltaGroup) is_DeltaUnion() {}

func (o *DeltaUnion_DeltaGroup) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.DeltaGroup != nil {
		_ptr_DeltaGroup := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.DeltaGroup != nil {
				if err := o.DeltaGroup.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DeltaGroup{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.DeltaGroup, _ptr_DeltaGroup); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *DeltaUnion_DeltaGroup) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_DeltaGroup := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.DeltaGroup == nil {
			o.DeltaGroup = &DeltaGroup{}
		}
		if err := o.DeltaGroup.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_DeltaGroup := func(ptr interface{}) { o.DeltaGroup = *ptr.(**DeltaGroup) }
	if err := w.ReadPointer(&o.DeltaGroup, _s_DeltaGroup, _ptr_DeltaGroup); err != nil {
		return err
	}
	return nil
}

// DeltaUnion_DeltaRenameGroup structure represents NETLOGON_DELTA_UNION RPC union arm.
//
// It has following labels: 4
type DeltaUnion_DeltaRenameGroup struct {
	// DeltaRenameGroup: A pointer to a NETLOGON_RENAME_GROUP structure, as specified in
	// section 2.2.1.5.24, that describes a rename of a group account. This structure is
	// selected when the delta type is RenameGroup.
	DeltaRenameGroup *RenameGroup `idl:"name:DeltaRenameGroup" json:"delta_rename_group"`
}

func (*DeltaUnion_DeltaRenameGroup) is_DeltaUnion() {}

func (o *DeltaUnion_DeltaRenameGroup) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.DeltaRenameGroup != nil {
		_ptr_DeltaRenameGroup := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.DeltaRenameGroup != nil {
				if err := o.DeltaRenameGroup.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&RenameGroup{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.DeltaRenameGroup, _ptr_DeltaRenameGroup); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *DeltaUnion_DeltaRenameGroup) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_DeltaRenameGroup := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.DeltaRenameGroup == nil {
			o.DeltaRenameGroup = &RenameGroup{}
		}
		if err := o.DeltaRenameGroup.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_DeltaRenameGroup := func(ptr interface{}) { o.DeltaRenameGroup = *ptr.(**RenameGroup) }
	if err := w.ReadPointer(&o.DeltaRenameGroup, _s_DeltaRenameGroup, _ptr_DeltaRenameGroup); err != nil {
		return err
	}
	return nil
}

// DeltaUnion_DeltaUser structure represents NETLOGON_DELTA_UNION RPC union arm.
//
// It has following labels: 5
type DeltaUnion_DeltaUser struct {
	// DeltaUser: A pointer to a NETLOGON_DELTA_USER structure, as specified in section
	// 2.2.1.5.16, that describes a domain user account. This structure is selected when
	// the delta type is AddOrChangeUser.
	DeltaUser *DeltaUser `idl:"name:DeltaUser" json:"delta_user"`
}

func (*DeltaUnion_DeltaUser) is_DeltaUnion() {}

func (o *DeltaUnion_DeltaUser) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.DeltaUser != nil {
		_ptr_DeltaUser := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.DeltaUser != nil {
				if err := o.DeltaUser.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DeltaUser{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.DeltaUser, _ptr_DeltaUser); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *DeltaUnion_DeltaUser) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_DeltaUser := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.DeltaUser == nil {
			o.DeltaUser = &DeltaUser{}
		}
		if err := o.DeltaUser.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_DeltaUser := func(ptr interface{}) { o.DeltaUser = *ptr.(**DeltaUser) }
	if err := w.ReadPointer(&o.DeltaUser, _s_DeltaUser, _ptr_DeltaUser); err != nil {
		return err
	}
	return nil
}

// DeltaUnion_DeltaRenameUser structure represents NETLOGON_DELTA_UNION RPC union arm.
//
// It has following labels: 7
type DeltaUnion_DeltaRenameUser struct {
	// DeltaRenameUser: A pointer to a NETLOGON_RENAME_USER structure, as specified in section
	// 2.2.1.5.25, that describes a rename of a user account. This structure is selected
	// when the delta type is RenameUser.
	DeltaRenameUser *RenameUser `idl:"name:DeltaRenameUser" json:"delta_rename_user"`
}

func (*DeltaUnion_DeltaRenameUser) is_DeltaUnion() {}

func (o *DeltaUnion_DeltaRenameUser) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.DeltaRenameUser != nil {
		_ptr_DeltaRenameUser := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.DeltaRenameUser != nil {
				if err := o.DeltaRenameUser.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&RenameUser{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.DeltaRenameUser, _ptr_DeltaRenameUser); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *DeltaUnion_DeltaRenameUser) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_DeltaRenameUser := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.DeltaRenameUser == nil {
			o.DeltaRenameUser = &RenameUser{}
		}
		if err := o.DeltaRenameUser.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_DeltaRenameUser := func(ptr interface{}) { o.DeltaRenameUser = *ptr.(**RenameUser) }
	if err := w.ReadPointer(&o.DeltaRenameUser, _s_DeltaRenameUser, _ptr_DeltaRenameUser); err != nil {
		return err
	}
	return nil
}

// DeltaUnion_DeltaGroupMember structure represents NETLOGON_DELTA_UNION RPC union arm.
//
// It has following labels: 8
type DeltaUnion_DeltaGroupMember struct {
	// DeltaGroupMember: A pointer to a NETLOGON_DELTA_GROUP_MEMBER structure, as specified
	// in section 2.2.1.5.17, that describes a group membership. This structure is selected
	// when the delta type is ChangeGroupMembership.
	DeltaGroupMember *DeltaGroupMember `idl:"name:DeltaGroupMember" json:"delta_group_member"`
}

func (*DeltaUnion_DeltaGroupMember) is_DeltaUnion() {}

func (o *DeltaUnion_DeltaGroupMember) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.DeltaGroupMember != nil {
		_ptr_DeltaGroupMember := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.DeltaGroupMember != nil {
				if err := o.DeltaGroupMember.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DeltaGroupMember{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.DeltaGroupMember, _ptr_DeltaGroupMember); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *DeltaUnion_DeltaGroupMember) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_DeltaGroupMember := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.DeltaGroupMember == nil {
			o.DeltaGroupMember = &DeltaGroupMember{}
		}
		if err := o.DeltaGroupMember.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_DeltaGroupMember := func(ptr interface{}) { o.DeltaGroupMember = *ptr.(**DeltaGroupMember) }
	if err := w.ReadPointer(&o.DeltaGroupMember, _s_DeltaGroupMember, _ptr_DeltaGroupMember); err != nil {
		return err
	}
	return nil
}

// DeltaUnion_DeltaAlias structure represents NETLOGON_DELTA_UNION RPC union arm.
//
// It has following labels: 9
type DeltaUnion_DeltaAlias struct {
	// DeltaAlias: A pointer to a NETLOGON_DELTA_ALIAS structure, as specified in section
	// 2.2.1.5.4, that describes an alias. This structure is selected when the delta type
	// is AddOrChangeAlias.
	DeltaAlias *DeltaAlias `idl:"name:DeltaAlias" json:"delta_alias"`
}

func (*DeltaUnion_DeltaAlias) is_DeltaUnion() {}

func (o *DeltaUnion_DeltaAlias) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.DeltaAlias != nil {
		_ptr_DeltaAlias := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.DeltaAlias != nil {
				if err := o.DeltaAlias.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DeltaAlias{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.DeltaAlias, _ptr_DeltaAlias); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *DeltaUnion_DeltaAlias) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_DeltaAlias := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.DeltaAlias == nil {
			o.DeltaAlias = &DeltaAlias{}
		}
		if err := o.DeltaAlias.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_DeltaAlias := func(ptr interface{}) { o.DeltaAlias = *ptr.(**DeltaAlias) }
	if err := w.ReadPointer(&o.DeltaAlias, _s_DeltaAlias, _ptr_DeltaAlias); err != nil {
		return err
	}
	return nil
}

// DeltaUnion_DeltaRenameAlias structure represents NETLOGON_DELTA_UNION RPC union arm.
//
// It has following labels: 11
type DeltaUnion_DeltaRenameAlias struct {
	// DeltaRenameAlias: A pointer to a NETLOGON_RENAME_ALIAS structure, as specified in
	// section 2.2.1.5.23, that describes a rename of an alias. This structure is selected
	// when the delta type is RenameAlias.
	DeltaRenameAlias *RenameAlias `idl:"name:DeltaRenameAlias" json:"delta_rename_alias"`
}

func (*DeltaUnion_DeltaRenameAlias) is_DeltaUnion() {}

func (o *DeltaUnion_DeltaRenameAlias) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.DeltaRenameAlias != nil {
		_ptr_DeltaRenameAlias := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.DeltaRenameAlias != nil {
				if err := o.DeltaRenameAlias.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&RenameAlias{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.DeltaRenameAlias, _ptr_DeltaRenameAlias); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *DeltaUnion_DeltaRenameAlias) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_DeltaRenameAlias := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.DeltaRenameAlias == nil {
			o.DeltaRenameAlias = &RenameAlias{}
		}
		if err := o.DeltaRenameAlias.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_DeltaRenameAlias := func(ptr interface{}) { o.DeltaRenameAlias = *ptr.(**RenameAlias) }
	if err := w.ReadPointer(&o.DeltaRenameAlias, _s_DeltaRenameAlias, _ptr_DeltaRenameAlias); err != nil {
		return err
	}
	return nil
}

// DeltaUnion_DeltaAliasMember structure represents NETLOGON_DELTA_UNION RPC union arm.
//
// It has following labels: 12
type DeltaUnion_DeltaAliasMember struct {
	// DeltaAliasMember: A pointer to a NETLOGON_DELTA_ALIAS_MEMBER structure, as specified
	// in section 2.2.1.5.7, that describes an alias membership. This structure is selected
	// when the delta type is ChangeAliasMembership.
	DeltaAliasMember *DeltaAliasMember `idl:"name:DeltaAliasMember" json:"delta_alias_member"`
}

func (*DeltaUnion_DeltaAliasMember) is_DeltaUnion() {}

func (o *DeltaUnion_DeltaAliasMember) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.DeltaAliasMember != nil {
		_ptr_DeltaAliasMember := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.DeltaAliasMember != nil {
				if err := o.DeltaAliasMember.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DeltaAliasMember{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.DeltaAliasMember, _ptr_DeltaAliasMember); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *DeltaUnion_DeltaAliasMember) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_DeltaAliasMember := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.DeltaAliasMember == nil {
			o.DeltaAliasMember = &DeltaAliasMember{}
		}
		if err := o.DeltaAliasMember.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_DeltaAliasMember := func(ptr interface{}) { o.DeltaAliasMember = *ptr.(**DeltaAliasMember) }
	if err := w.ReadPointer(&o.DeltaAliasMember, _s_DeltaAliasMember, _ptr_DeltaAliasMember); err != nil {
		return err
	}
	return nil
}

// DeltaUnion_DeltaPolicy structure represents NETLOGON_DELTA_UNION RPC union arm.
//
// It has following labels: 13
type DeltaUnion_DeltaPolicy struct {
	// DeltaPolicy: A pointer to a NETLOGON_DELTA_POLICY structure, as specified in section
	// 2.2.1.5.19, that describes an LSA policy. This structure is selected when the delta
	// type is AddOrChangeLsaPolicy.
	DeltaPolicy *DeltaPolicy `idl:"name:DeltaPolicy" json:"delta_policy"`
}

func (*DeltaUnion_DeltaPolicy) is_DeltaUnion() {}

func (o *DeltaUnion_DeltaPolicy) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.DeltaPolicy != nil {
		_ptr_DeltaPolicy := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.DeltaPolicy != nil {
				if err := o.DeltaPolicy.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DeltaPolicy{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.DeltaPolicy, _ptr_DeltaPolicy); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *DeltaUnion_DeltaPolicy) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_DeltaPolicy := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.DeltaPolicy == nil {
			o.DeltaPolicy = &DeltaPolicy{}
		}
		if err := o.DeltaPolicy.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_DeltaPolicy := func(ptr interface{}) { o.DeltaPolicy = *ptr.(**DeltaPolicy) }
	if err := w.ReadPointer(&o.DeltaPolicy, _s_DeltaPolicy, _ptr_DeltaPolicy); err != nil {
		return err
	}
	return nil
}

// DeltaUnion_DeltaDomains structure represents NETLOGON_DELTA_UNION RPC union arm.
//
// It has following labels: 14
type DeltaUnion_DeltaDomains struct {
	// DeltaTDomains: A pointer to a NETLOGON_DELTA_TRUSTED_DOMAINS structure, as specified
	// in section 2.2.1.5.22, that describes a trusted domain. This structure is selected
	// when the delta type is AddOrChangeLsaTDomain.
	DeltaDomains *DeltaTrustedDomains `idl:"name:DeltaTDomains" json:"delta_domains"`
}

func (*DeltaUnion_DeltaDomains) is_DeltaUnion() {}

func (o *DeltaUnion_DeltaDomains) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.DeltaDomains != nil {
		_ptr_DeltaTDomains := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.DeltaDomains != nil {
				if err := o.DeltaDomains.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DeltaTrustedDomains{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.DeltaDomains, _ptr_DeltaTDomains); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *DeltaUnion_DeltaDomains) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_DeltaTDomains := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.DeltaDomains == nil {
			o.DeltaDomains = &DeltaTrustedDomains{}
		}
		if err := o.DeltaDomains.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_DeltaTDomains := func(ptr interface{}) { o.DeltaDomains = *ptr.(**DeltaTrustedDomains) }
	if err := w.ReadPointer(&o.DeltaDomains, _s_DeltaTDomains, _ptr_DeltaTDomains); err != nil {
		return err
	}
	return nil
}

// DeltaUnion_DeltaAccounts structure represents NETLOGON_DELTA_UNION RPC union arm.
//
// It has following labels: 16
type DeltaUnion_DeltaAccounts struct {
	// DeltaAccounts: A pointer to a NETLOGON_DELTA_ACCOUNTS structure, as specified in
	// section 2.2.1.5.3, that describes an LSA account. This structure is selected when
	// the delta type is AddOrChangeLsaAccount.
	DeltaAccounts *DeltaAccounts `idl:"name:DeltaAccounts" json:"delta_accounts"`
}

func (*DeltaUnion_DeltaAccounts) is_DeltaUnion() {}

func (o *DeltaUnion_DeltaAccounts) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.DeltaAccounts != nil {
		_ptr_DeltaAccounts := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.DeltaAccounts != nil {
				if err := o.DeltaAccounts.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DeltaAccounts{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.DeltaAccounts, _ptr_DeltaAccounts); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *DeltaUnion_DeltaAccounts) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_DeltaAccounts := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.DeltaAccounts == nil {
			o.DeltaAccounts = &DeltaAccounts{}
		}
		if err := o.DeltaAccounts.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_DeltaAccounts := func(ptr interface{}) { o.DeltaAccounts = *ptr.(**DeltaAccounts) }
	if err := w.ReadPointer(&o.DeltaAccounts, _s_DeltaAccounts, _ptr_DeltaAccounts); err != nil {
		return err
	}
	return nil
}

// DeltaUnion_DeltaSecret structure represents NETLOGON_DELTA_UNION RPC union arm.
//
// It has following labels: 18
type DeltaUnion_DeltaSecret struct {
	// DeltaSecret: A pointer to a NETLOGON_DELTA_SECRET structure, as specified in section
	// 2.2.1.5.21, that describes a LSA secret object as detailed in [MS-LSAD]. This structure
	// is selected when the delta type is AddOrChangeLsaSecret.
	DeltaSecret *DeltaSecret `idl:"name:DeltaSecret" json:"delta_secret"`
}

func (*DeltaUnion_DeltaSecret) is_DeltaUnion() {}

func (o *DeltaUnion_DeltaSecret) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.DeltaSecret != nil {
		_ptr_DeltaSecret := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.DeltaSecret != nil {
				if err := o.DeltaSecret.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DeltaSecret{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.DeltaSecret, _ptr_DeltaSecret); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *DeltaUnion_DeltaSecret) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_DeltaSecret := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.DeltaSecret == nil {
			o.DeltaSecret = &DeltaSecret{}
		}
		if err := o.DeltaSecret.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_DeltaSecret := func(ptr interface{}) { o.DeltaSecret = *ptr.(**DeltaSecret) }
	if err := w.ReadPointer(&o.DeltaSecret, _s_DeltaSecret, _ptr_DeltaSecret); err != nil {
		return err
	}
	return nil
}

// DeltaUnion_DeltaDeleteGroup structure represents NETLOGON_DELTA_UNION RPC union arm.
//
// It has following labels: 20
type DeltaUnion_DeltaDeleteGroup struct {
	// DeltaDeleteGroup: A pointer to a NETLOGON_DELTA_DELETE_GROUP structure, as specified
	// in section 2.2.1.5.8, that describes a group account deletion. This structure is
	// selected when the delta type is DeleteGroupByName.
	DeltaDeleteGroup *DeltaDeleteGroup `idl:"name:DeltaDeleteGroup" json:"delta_delete_group"`
}

func (*DeltaUnion_DeltaDeleteGroup) is_DeltaUnion() {}

func (o *DeltaUnion_DeltaDeleteGroup) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.DeltaDeleteGroup != nil {
		_ptr_DeltaDeleteGroup := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.DeltaDeleteGroup != nil {
				if err := o.DeltaDeleteGroup.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DeltaDeleteGroup{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.DeltaDeleteGroup, _ptr_DeltaDeleteGroup); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *DeltaUnion_DeltaDeleteGroup) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_DeltaDeleteGroup := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.DeltaDeleteGroup == nil {
			o.DeltaDeleteGroup = &DeltaDeleteGroup{}
		}
		if err := o.DeltaDeleteGroup.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_DeltaDeleteGroup := func(ptr interface{}) { o.DeltaDeleteGroup = *ptr.(**DeltaDeleteGroup) }
	if err := w.ReadPointer(&o.DeltaDeleteGroup, _s_DeltaDeleteGroup, _ptr_DeltaDeleteGroup); err != nil {
		return err
	}
	return nil
}

// DeltaUnion_DeltaDeleteUser structure represents NETLOGON_DELTA_UNION RPC union arm.
//
// It has following labels: 21
type DeltaUnion_DeltaDeleteUser struct {
	// DeltaDeleteUser: A pointer to a NETLOGON_DELTA_DELETE_USER structure, as specified
	// in section 2.2.1.5.9, that describes a user account deletion. This structure is selected
	// when the delta type is DeleteUserByName.
	DeltaDeleteUser *DeltaDeleteUser `idl:"name:DeltaDeleteUser" json:"delta_delete_user"`
}

func (*DeltaUnion_DeltaDeleteUser) is_DeltaUnion() {}

func (o *DeltaUnion_DeltaDeleteUser) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.DeltaDeleteUser != nil {
		_ptr_DeltaDeleteUser := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.DeltaDeleteUser != nil {
				if err := o.DeltaDeleteUser.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DeltaDeleteUser{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.DeltaDeleteUser, _ptr_DeltaDeleteUser); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *DeltaUnion_DeltaDeleteUser) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_DeltaDeleteUser := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.DeltaDeleteUser == nil {
			o.DeltaDeleteUser = &DeltaDeleteUser{}
		}
		if err := o.DeltaDeleteUser.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_DeltaDeleteUser := func(ptr interface{}) { o.DeltaDeleteUser = *ptr.(**DeltaDeleteUser) }
	if err := w.ReadPointer(&o.DeltaDeleteUser, _s_DeltaDeleteUser, _ptr_DeltaDeleteUser); err != nil {
		return err
	}
	return nil
}

// DeltaUnion_DeltaSerialNumberSkip structure represents NETLOGON_DELTA_UNION RPC union arm.
//
// It has following labels: 22
type DeltaUnion_DeltaSerialNumberSkip struct {
	// DeltaSerialNumberSkip: A pointer to an NLPR_MODIFIED_COUNT structure, as specified
	// in section 2.2.1.5.26, that holds the database serial number. This structure is selected
	// when the delta type is SerialNumberSkip.
	DeltaSerialNumberSkip *ModifiedCount `idl:"name:DeltaSerialNumberSkip" json:"delta_serial_number_skip"`
}

func (*DeltaUnion_DeltaSerialNumberSkip) is_DeltaUnion() {}

func (o *DeltaUnion_DeltaSerialNumberSkip) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.DeltaSerialNumberSkip != nil {
		_ptr_DeltaSerialNumberSkip := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.DeltaSerialNumberSkip != nil {
				if err := o.DeltaSerialNumberSkip.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ModifiedCount{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.DeltaSerialNumberSkip, _ptr_DeltaSerialNumberSkip); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *DeltaUnion_DeltaSerialNumberSkip) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_DeltaSerialNumberSkip := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.DeltaSerialNumberSkip == nil {
			o.DeltaSerialNumberSkip = &ModifiedCount{}
		}
		if err := o.DeltaSerialNumberSkip.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_DeltaSerialNumberSkip := func(ptr interface{}) { o.DeltaSerialNumberSkip = *ptr.(**ModifiedCount) }
	if err := w.ReadPointer(&o.DeltaSerialNumberSkip, _s_DeltaSerialNumberSkip, _ptr_DeltaSerialNumberSkip); err != nil {
		return err
	}
	return nil
}

// DeltaIDUnion structure represents NETLOGON_DELTA_ID_UNION RPC union.
//
// The NETLOGON_DELTA_ID_UNION union defines an account identifier type that is selected
// based on the requested database change.
type DeltaIDUnion struct {
	// Types that are assignable to Value
	//
	// *DeltaIDUnion_RID
	// *DeltaIDUnion_SID
	// *DeltaIDUnion_Name
	Value is_DeltaIDUnion `json:"value"`
}

func (o *DeltaIDUnion) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *DeltaIDUnion_RID:
		if value != nil {
			return value.RID
		}
	case *DeltaIDUnion_SID:
		if value != nil {
			return value.SID
		}
	case *DeltaIDUnion_Name:
		if value != nil {
			return value.Name
		}
	}
	return nil
}

type is_DeltaIDUnion interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_DeltaIDUnion()
}

func (o *DeltaIDUnion) NDRSwitchValue(sw uint16) uint16 {
	if o == nil {
		return uint16(0)
	}
	switch (interface{})(o.Value).(type) {
	case *DeltaIDUnion_RID:
		switch sw {
		case uint16(1),
			uint16(2),
			uint16(3),
			uint16(4),
			uint16(5),
			uint16(6),
			uint16(7),
			uint16(8),
			uint16(9),
			uint16(10),
			uint16(11),
			uint16(12),
			uint16(20),
			uint16(21):
			return sw
		}
		return uint16(1)
	case *DeltaIDUnion_SID:
		switch sw {
		case uint16(13),
			uint16(14),
			uint16(15),
			uint16(16),
			uint16(17):
			return sw
		}
		return uint16(13)
	case *DeltaIDUnion_Name:
		switch sw {
		case uint16(18),
			uint16(19):
			return sw
		}
		return uint16(18)
	}
	return uint16(0)
}

func (o *DeltaIDUnion) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint16) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(ndr.Enum(uint16(sw))); err != nil {
		return err
	}
	// ms_union
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint16(1),
		uint16(2),
		uint16(3),
		uint16(4),
		uint16(5),
		uint16(6),
		uint16(7),
		uint16(8),
		uint16(9),
		uint16(10),
		uint16(11),
		uint16(12),
		uint16(20),
		uint16(21):
		_o, _ := o.Value.(*DeltaIDUnion_RID)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DeltaIDUnion_RID{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint16(13),
		uint16(14),
		uint16(15),
		uint16(16),
		uint16(17):
		_o, _ := o.Value.(*DeltaIDUnion_SID)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DeltaIDUnion_SID{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint16(18),
		uint16(19):
		_o, _ := o.Value.(*DeltaIDUnion_Name)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DeltaIDUnion_Name{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
	}
	return nil
}

func (o *DeltaIDUnion) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint16) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch(ndr.Enum((*uint16)(&sw))); err != nil {
		return err
	}
	// ms_union
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint16(1),
		uint16(2),
		uint16(3),
		uint16(4),
		uint16(5),
		uint16(6),
		uint16(7),
		uint16(8),
		uint16(9),
		uint16(10),
		uint16(11),
		uint16(12),
		uint16(20),
		uint16(21):
		o.Value = &DeltaIDUnion_RID{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint16(13),
		uint16(14),
		uint16(15),
		uint16(16),
		uint16(17):
		o.Value = &DeltaIDUnion_SID{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint16(18),
		uint16(19):
		o.Value = &DeltaIDUnion_Name{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
	}
	return nil
}

// DeltaIDUnion_RID structure represents NETLOGON_DELTA_ID_UNION RPC union arm.
//
// It has following labels: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 20, 21
type DeltaIDUnion_RID struct {
	// Rid: A 32-bit RID whose type is selected when the following delta types are switched:
	// AddOrChangeDomain(1), AddOrChangeGroup(2), RenameGroup(4), DeleteGroup(3), AddOrChangeUser(5),
	// DeleteUser(6), RenameUser(7), ChangeGroupMembership(8), AddOrChangeAlias(9), DeleteAlias(10),
	// RenameAlias(11), ChangeAliasMembership(12), DeleteGroupByName(20), and DeleteUserByName(21).
	RID uint32 `idl:"name:Rid" json:"rid"`
}

func (*DeltaIDUnion_RID) is_DeltaIDUnion() {}

func (o *DeltaIDUnion_RID) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := w.WriteData(o.RID); err != nil {
		return err
	}
	return nil
}
func (o *DeltaIDUnion_RID) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadData(&o.RID); err != nil {
		return err
	}
	return nil
}

// DeltaIDUnion_SID structure represents NETLOGON_DELTA_ID_UNION RPC union arm.
//
// It has following labels: 13, 14, 15, 16, 17
type DeltaIDUnion_SID struct {
	// Sid: A pointer to a SID whose type is selected when the following delta types are
	// switched: AddOrChangeLsaPolicy(13), AddOrChangeLsaDomain(14), DeleteLsaTDomain(15),
	// AddOrChangeLsaAccount(16), and DeleteLsaAccount(17).
	SID *dtyp.SID `idl:"name:Sid" json:"sid"`
}

func (*DeltaIDUnion_SID) is_DeltaIDUnion() {}

func (o *DeltaIDUnion_SID) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.SID != nil {
		_ptr_Sid := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.SID != nil {
				if err := o.SID.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&dtyp.SID{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.SID, _ptr_Sid); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *DeltaIDUnion_SID) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_Sid := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.SID == nil {
			o.SID = &dtyp.SID{}
		}
		if err := o.SID.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_Sid := func(ptr interface{}) { o.SID = *ptr.(**dtyp.SID) }
	if err := w.ReadPointer(&o.SID, _s_Sid, _ptr_Sid); err != nil {
		return err
	}
	return nil
}

// DeltaIDUnion_Name structure represents NETLOGON_DELTA_ID_UNION RPC union arm.
//
// It has following labels: 18, 19
type DeltaIDUnion_Name struct {
	// Name: A null-terminated Unicode string that contains an identifier name. This identifier
	// type is selected when the following delta types are switched: AddOrChangeLsaSecret(18)
	// and DeleteLsaSecret(19).
	Name string `idl:"name:Name;string" json:"name"`
}

func (*DeltaIDUnion_Name) is_DeltaIDUnion() {}

func (o *DeltaIDUnion_Name) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Name != "" {
		_ptr_Name := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Name); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Name, _ptr_Name); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *DeltaIDUnion_Name) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_Name := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Name); err != nil {
			return err
		}
		return nil
	})
	_s_Name := func(ptr interface{}) { o.Name = *ptr.(*string) }
	if err := w.ReadPointer(&o.Name, _s_Name, _ptr_Name); err != nil {
		return err
	}
	return nil
}

// DeltaEnum structure represents NETLOGON_DELTA_ENUM RPC structure.
//
// The NETLOGON_DELTA_ENUM structure defines a common structure that encapsulates all
// possible types of database changes. Database changes, in the context of Netlogon,
// are called deltas.
type DeltaEnum struct {
	// DeltaType: One of the values from the NETLOGON_DELTA_TYPE enumeration, as specified
	// in section 2.2.1.5.28.
	DeltaType DeltaType `idl:"name:DeltaType" json:"delta_type"`
	// DeltaID: One of the NETLOGON_DELTA_ID_UNION union (section 2.2.1.5.18) types selected
	// based on the value of the DeltaType field.
	DeltaID *DeltaIDUnion `idl:"name:DeltaID;switch_is:DeltaType" json:"delta_id"`
	// DeltaUnion: One of the NETLOGON_DELTA_UNION union (section 2.2.1.5.27) types selected
	// based on the value of the DeltaType.
	DeltaUnion *DeltaUnion `idl:"name:DeltaUnion;switch_is:DeltaType" json:"delta_union"`
}

func (o *DeltaEnum) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *DeltaEnum) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteEnum(uint16(o.DeltaType)); err != nil {
		return err
	}
	_swDeltaID := uint16(o.DeltaType)
	if o.DeltaID != nil {
		if err := o.DeltaID.MarshalUnionNDR(ctx, w, _swDeltaID); err != nil {
			return err
		}
	} else {
		if err := (&DeltaIDUnion{}).MarshalUnionNDR(ctx, w, _swDeltaID); err != nil {
			return err
		}
	}
	_swDeltaUnion := uint16(o.DeltaType)
	if o.DeltaUnion != nil {
		if err := o.DeltaUnion.MarshalUnionNDR(ctx, w, _swDeltaUnion); err != nil {
			return err
		}
	} else {
		if err := (&DeltaUnion{}).MarshalUnionNDR(ctx, w, _swDeltaUnion); err != nil {
			return err
		}
	}
	return nil
}
func (o *DeltaEnum) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadEnum((*uint16)(&o.DeltaType)); err != nil {
		return err
	}
	if o.DeltaID == nil {
		o.DeltaID = &DeltaIDUnion{}
	}
	_swDeltaID := uint16(o.DeltaType)
	if err := o.DeltaID.UnmarshalUnionNDR(ctx, w, _swDeltaID); err != nil {
		return err
	}
	if o.DeltaUnion == nil {
		o.DeltaUnion = &DeltaUnion{}
	}
	_swDeltaUnion := uint16(o.DeltaType)
	if err := o.DeltaUnion.UnmarshalUnionNDR(ctx, w, _swDeltaUnion); err != nil {
		return err
	}
	return nil
}

// DeltaEnumArray structure represents NETLOGON_DELTA_ENUM_ARRAY RPC structure.
//
// The NETLOGON_DELTA_ENUM_ARRAY structure defines an array of delta objects.
type DeltaEnumArray struct {
	// CountReturned: The number of elements in the Deltas field.
	CountReturned uint32 `idl:"name:CountReturned" json:"count_returned"`
	// Deltas: An array of NETLOGON_DELTA_ENUM structures, as specified in section 2.2.1.5.11.
	Deltas []*DeltaEnum `idl:"name:Deltas;size_is:(CountReturned)" json:"deltas"`
}

func (o *DeltaEnumArray) xxx_PreparePayload(ctx context.Context) error {
	if o.Deltas != nil && o.CountReturned == 0 {
		o.CountReturned = uint32(len(o.Deltas))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *DeltaEnumArray) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.CountReturned); err != nil {
		return err
	}
	if o.Deltas != nil || o.CountReturned > 0 {
		_ptr_Deltas := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.CountReturned)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Deltas {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Deltas[i1] != nil {
					if err := o.Deltas[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&DeltaEnum{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Deltas); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&DeltaEnum{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Deltas, _ptr_Deltas); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *DeltaEnumArray) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.CountReturned); err != nil {
		return err
	}
	_ptr_Deltas := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.CountReturned > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.CountReturned)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Deltas", sizeInfo[0])
		}
		o.Deltas = make([]*DeltaEnum, sizeInfo[0])
		for i1 := range o.Deltas {
			i1 := i1
			if o.Deltas[i1] == nil {
				o.Deltas[i1] = &DeltaEnum{}
			}
			if err := o.Deltas[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_Deltas := func(ptr interface{}) { o.Deltas = *ptr.(*[]*DeltaEnum) }
	if err := w.ReadPointer(&o.Deltas, _s_Deltas, _ptr_Deltas); err != nil {
		return err
	}
	return nil
}

// LogonIdentityInfo structure represents NETLOGON_LOGON_IDENTITY_INFO RPC structure.
//
// The NETLOGON_LOGON_IDENTITY_INFO structure defines a logon identity within a domain.
type LogonIdentityInfo struct {
	// LogonDomainName: Contains the NetBIOS name of the domain of the account. The case
	// of the domain name MUST be preserved across all messages.
	LogonDomainName *dtyp.UnicodeString `idl:"name:LogonDomainName" json:"logon_domain_name"`
	// ParameterControl: A set of bit flags that contain information pertaining to the logon
	// validation processing. A flag is TRUE (or set) if its value is equal to 1. The value
	// is constructed from zero or more bit flags from the following table.
	//
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
	//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| X | W | V | U | T | S | R | Q | 0 | 0 | 0 | P | 0 | 0 | 0 | O | 0 | N | M | L | K | J | I | H | G | F | E | D | C | B | A | 0 |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//
	// Where the bits are defined as:
	//
	//	+-------+----------------------------------------------------------------------------------+
	//	|       |                                                                                  |
	//	| VALUE |                                   DESCRIPTION                                    |
	//	|       |                                                                                  |
	//	+-------+----------------------------------------------------------------------------------+
	//	+-------+----------------------------------------------------------------------------------+
	//	| A     | Clear text passwords can be transmitted for this logon identity.                 |
	//	+-------+----------------------------------------------------------------------------------+
	//	| B     | Update the logon statistics for this account upon successful logon.              |
	//	+-------+----------------------------------------------------------------------------------+
	//	| C     | Return the user parameter list for this account upon successful logon.           |
	//	+-------+----------------------------------------------------------------------------------+
	//	| D     | Do not attempt to log this account on as a guest upon logon failure.             |
	//	+-------+----------------------------------------------------------------------------------+
	//	| E     | Allow this account to log on with the domain controller account.                 |
	//	+-------+----------------------------------------------------------------------------------+
	//	| F     | Return the password expiration date and time upon successful logon.              |
	//	+-------+----------------------------------------------------------------------------------+
	//	| G     | Send a client challenge upon logon request.                                      |
	//	+-------+----------------------------------------------------------------------------------+
	//	| H     | Attempt logon as a guest for this account only.                                  |
	//	+-------+----------------------------------------------------------------------------------+
	//	| I     | Return the profile path upon successful logon.                                   |
	//	+-------+----------------------------------------------------------------------------------+
	//	| J     | Attempt logon to the specified domain only.                                      |
	//	+-------+----------------------------------------------------------------------------------+
	//	| K     | Allow this account to log on with the computer account.                          |
	//	+-------+----------------------------------------------------------------------------------+
	//	| L     | Disable allowing fallback to guest account for this account.                     |
	//	+-------+----------------------------------------------------------------------------------+
	//	| M     | Force the logon of this account as a guest if the password is incorrect.         |
	//	+-------+----------------------------------------------------------------------------------+
	//	| N     | This account has supplied a clear text password.                                 |
	//	+-------+----------------------------------------------------------------------------------+
	//	| O     | Allow NTLMv1 authentication ([MS-NLMP]) when only NTLMv2 ([NTLM]) is allowed.    |
	//	+-------+----------------------------------------------------------------------------------+
	//	| P     | Use sub-authentication ([MS-APDS] section 3.1.5.2.1).                            |
	//	+-------+----------------------------------------------------------------------------------+
	//	| Q - X | Encode the sub-authentication package identifier. Bits Q–X are used to encode    |
	//	|       | the integer value of the sub-authentication package identifier (this is in       |
	//	|       | little-endian order).                                                            |
	//	+-------+----------------------------------------------------------------------------------+
	ParameterControl uint32 `idl:"name:ParameterControl" json:"parameter_control"`
	// Reserved: MUST be set to zero when sent and MUST be ignored on receipt.
	_ *OldLargeInteger `idl:"name:Reserved"`
	// UserName: Contains the name of the user.
	UserName *dtyp.UnicodeString `idl:"name:UserName" json:"user_name"`
	// Workstation: Contains the NetBIOS name of the workstation from which the user is
	// logging on.
	Workstation *dtyp.UnicodeString `idl:"name:Workstation" json:"workstation"`
}

func (o *LogonIdentityInfo) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *LogonIdentityInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.LogonDomainName != nil {
		if err := o.LogonDomainName.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.ParameterControl); err != nil {
		return err
	}
	// reserved Reserved
	if err := (&OldLargeInteger{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.UserName != nil {
		if err := o.UserName.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.Workstation != nil {
		if err := o.Workstation.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *LogonIdentityInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if o.LogonDomainName == nil {
		o.LogonDomainName = &dtyp.UnicodeString{}
	}
	if err := o.LogonDomainName.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.ParameterControl); err != nil {
		return err
	}
	// reserved Reserved
	var _Reserved *OldLargeInteger
	if _Reserved == nil {
		_Reserved = &OldLargeInteger{}
	}
	if err := _Reserved.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.UserName == nil {
		o.UserName = &dtyp.UnicodeString{}
	}
	if err := o.UserName.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.Workstation == nil {
		o.Workstation = &dtyp.UnicodeString{}
	}
	if err := o.Workstation.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// InteractiveInfo structure represents NETLOGON_INTERACTIVE_INFO RPC structure.
//
// The NETLOGON_INTERACTIVE_INFO structure defines information about an interactive
// logon instance.
type InteractiveInfo struct {
	// Identity: A NETLOGON_LOGON_IDENTITY_INFO structure, as specified in section 2.2.1.4.15,
	// that contains information about the logon identity.
	Identity *LogonIdentityInfo `idl:"name:Identity" json:"identity"`
	// LmOwfPassword: An LM_OWF_PASSWORD structure, as specified in section 2.2.1.1.3, that
	// contains the LMOWFv1 of a password. LMOWFv1 is specified in NTLM v1 Authentication
	// in [MS-NLMP] section 3.3.1.
	LMOWFPassword *LMOWFPassword `idl:"name:LmOwfPassword" json:"lm_owf_password"`
	// NtOwfPassword: An NT_OWF_PASSWORD structure, as specified in section 2.2.1.1.4, that
	// contains the NTOWFv1 of a password. NTOWFv1 is specified in NTLM v1 Authentication
	// in [MS-NLMP] section 3.3.1.
	NTOWFPassword *NTOWFPassword `idl:"name:NtOwfPassword" json:"nt_owf_password"`
}

func (o *InteractiveInfo) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *InteractiveInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.Identity != nil {
		if err := o.Identity.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&LogonIdentityInfo{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.LMOWFPassword != nil {
		if err := o.LMOWFPassword.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&LMOWFPassword{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.NTOWFPassword != nil {
		if err := o.NTOWFPassword.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&NTOWFPassword{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *InteractiveInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if o.Identity == nil {
		o.Identity = &LogonIdentityInfo{}
	}
	if err := o.Identity.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.LMOWFPassword == nil {
		o.LMOWFPassword = &LMOWFPassword{}
	}
	if err := o.LMOWFPassword.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.NTOWFPassword == nil {
		o.NTOWFPassword = &NTOWFPassword{}
	}
	if err := o.NTOWFPassword.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// LogonInfoClass type represents NETLOGON_LOGON_INFO_CLASS RPC enumeration.
//
// The NETLOGON_LOGON_INFO_CLASS enumeration SHOULD<48> identify a particular type of
// logon information block.
type LogonInfoClass uint16

var (
	// NetlogonInteractiveInformation: Logon information pertains to an interactive account
	// logon. Interactive account logon requires a user to physically input credentials
	// to the client that are then authenticated by the DC.
	LogonInfoClassInteractiveInformation LogonInfoClass = 1
	// NetlogonNetworkInformation: Logon information pertains to a network account logon.
	// Network logon is transparent to the user. The user has already input his or her credentials
	// during interactive logon and has been authenticated by the server or DC. These credentials
	// are used again to log the user onto another network resource without prompting the
	// user for his or her credentials.
	LogonInfoClassNetworkInformation LogonInfoClass = 2
	// NetlogonServiceInformation: Logon information pertains to a service account logon.
	// A service account acts as a non-privileged user on the local computer and presents
	// anonymous credentials to any remote server.
	LogonInfoClassServiceInformation LogonInfoClass = 3
	// NetlogonGenericInformation: Logon information pertains to a generic account logon.
	// This type of account logon is for generic pass-through authentication, as specified
	// in section 3.2.4.1, that enables servers to forward NTLM and Digest authentication
	// credentials to a DC for authorization.
	LogonInfoClassGenericInformation LogonInfoClass = 4
	// NetlogonInteractiveTransitiveInformation: Logon information pertains to a transitive
	// interactive account logon and can be passed through transitive trust links.
	LogonInfoClassInteractiveTransitiveInformation LogonInfoClass = 5
	// NetlogonNetworkTransitiveInformation: Logon information pertains to a transitive
	// network account logon and can be passed through transitive trust links.
	LogonInfoClassNetworkTransitiveInformation LogonInfoClass = 6
	// NetlogonServiceTransitiveInformation: Logon information pertains to a transitive
	// service account logon and can be passed through transitive trust links.
	LogonInfoClassServiceTransitiveInformation LogonInfoClass = 7
)

func (o LogonInfoClass) String() string {
	switch o {
	case LogonInfoClassInteractiveInformation:
		return "LogonInfoClassInteractiveInformation"
	case LogonInfoClassNetworkInformation:
		return "LogonInfoClassNetworkInformation"
	case LogonInfoClassServiceInformation:
		return "LogonInfoClassServiceInformation"
	case LogonInfoClassGenericInformation:
		return "LogonInfoClassGenericInformation"
	case LogonInfoClassInteractiveTransitiveInformation:
		return "LogonInfoClassInteractiveTransitiveInformation"
	case LogonInfoClassNetworkTransitiveInformation:
		return "LogonInfoClassNetworkTransitiveInformation"
	case LogonInfoClassServiceTransitiveInformation:
		return "LogonInfoClassServiceTransitiveInformation"
	}
	return "Invalid"
}

// ServiceInfo structure represents NETLOGON_SERVICE_INFO RPC structure.
//
// The NETLOGON_SERVICE_INFO structure defines information about a service account logon.
// Operating system services use service accounts as their run-time security identity.
type ServiceInfo struct {
	// Identity: NETLOGON_LOGON_IDENTITY_INFO structure, as specified in section 2.2.1.4.15,
	// that contains information about the logon identity.
	Identity *LogonIdentityInfo `idl:"name:Identity" json:"identity"`
	// LmOwfPassword: LM_OWF_PASSWORD structure, as specified in section 2.2.1.1.3, that
	// contains the LMOWFv1 of a password. LMOWFv1 is specified in NTLM v1 Authentication
	// in [MS-NLMP] section 3.3.1.
	LMOWFPassword *LMOWFPassword `idl:"name:LmOwfPassword" json:"lm_owf_password"`
	// NtOwfPassword: NT_OWF_PASSWORD structure, as specified in section 2.2.1.1.4, that
	// contains the NTOWFv1 of a password. NTOWFv1 is specified in NTLM v1 Authentication
	// in [MS-NLMP] section 3.3.1.
	NTOWFPassword *NTOWFPassword `idl:"name:NtOwfPassword" json:"nt_owf_password"`
}

func (o *ServiceInfo) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServiceInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.Identity != nil {
		if err := o.Identity.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&LogonIdentityInfo{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.LMOWFPassword != nil {
		if err := o.LMOWFPassword.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&LMOWFPassword{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.NTOWFPassword != nil {
		if err := o.NTOWFPassword.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&NTOWFPassword{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *ServiceInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if o.Identity == nil {
		o.Identity = &LogonIdentityInfo{}
	}
	if err := o.Identity.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.LMOWFPassword == nil {
		o.LMOWFPassword = &LMOWFPassword{}
	}
	if err := o.LMOWFPassword.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.NTOWFPassword == nil {
		o.NTOWFPassword = &NTOWFPassword{}
	}
	if err := o.NTOWFPassword.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// LMChallenge structure represents LM_CHALLENGE RPC structure.
//
// The LM_CHALLENGE structure carries a LAN Manager authentication challenge.
type LMChallenge struct {
	// data: A string of eight characters that contains a LAN Manager authentication challenge,
	// which is an unencrypted nonce.
	//
	// For more information, see [LANMAN].
	Data []byte `idl:"name:data" json:"data"`
}

func (o *LMChallenge) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *LMChallenge) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	for i1 := range o.Data {
		i1 := i1
		if uint64(i1) >= 8 {
			break
		}
		if err := w.WriteData(o.Data[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Data); uint64(i1) < 8; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	return nil
}
func (o *LMChallenge) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	o.Data = make([]byte, 8)
	for i1 := range o.Data {
		i1 := i1
		if err := w.ReadData(&o.Data[i1]); err != nil {
			return err
		}
	}
	return nil
}

// NetworkInfo structure represents NETLOGON_NETWORK_INFO RPC structure.
//
// The NETLOGON_NETWORK_INFO structure defines information that describes a network
// account logon.
type NetworkInfo struct {
	// Identity: NETLOGON_LOGON_IDENTITY_INFO structure, as specified in section 2.2.1.4.15,
	// that contains information about the logon identity. The Identity.LogonDomainName
	// field MUST match the DomainName field of the authenticate message received by the
	// client. The authenticate message is defined in [MS-NLMP] section 2.2.1.3.
	Identity *LogonIdentityInfo `idl:"name:Identity" json:"identity"`
	// LmChallenge: LM_CHALLENGE structure, as specified in section 2.2.1.4.1, that contains
	// the network authentication challenge. For details about challenges, see [MS-NLMP].
	LMChallenge *LMChallenge `idl:"name:LmChallenge" json:"lm_challenge"`
	// NtChallengeResponse: String that contains the NT response (see [MS-NLMP]) to the
	// network authentication challenge.
	NTChallengeResponse *String `idl:"name:NtChallengeResponse" json:"nt_challenge_response"`
	// LmChallengeResponse: String that contains the LAN Manager response (see [MS-NLMP])
	// to the network authentication challenge.
	LMChallengeResponse *String `idl:"name:LmChallengeResponse" json:"lm_challenge_response"`
}

func (o *NetworkInfo) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *NetworkInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.Identity != nil {
		if err := o.Identity.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&LogonIdentityInfo{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.LMChallenge != nil {
		if err := o.LMChallenge.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&LMChallenge{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.NTChallengeResponse != nil {
		if err := o.NTChallengeResponse.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&String{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.LMChallengeResponse != nil {
		if err := o.LMChallengeResponse.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&String{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *NetworkInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if o.Identity == nil {
		o.Identity = &LogonIdentityInfo{}
	}
	if err := o.Identity.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.LMChallenge == nil {
		o.LMChallenge = &LMChallenge{}
	}
	if err := o.LMChallenge.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.NTChallengeResponse == nil {
		o.NTChallengeResponse = &String{}
	}
	if err := o.NTChallengeResponse.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.LMChallengeResponse == nil {
		o.LMChallengeResponse = &String{}
	}
	if err := o.LMChallengeResponse.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// GenericInfo structure represents NETLOGON_GENERIC_INFO RPC structure.
//
// The NETLOGON_GENERIC_INFO structure defines a structure that contains logon information
// in binary format. Authentication protocols make use of this structure for passing
// generic logon data through the Netlogon secure channel to a DC in the domain that
// contains the user account to use the domain's database. For an example of using the
// NETLOGON_GENERIC_INFO structure, see any of the examples documented in [MS-APDS].
type GenericInfo struct {
	// Identity: The NETLOGON_LOGON_IDENTITY_INFO structure, as specified in section 2.2.1.4.15,
	// contains information about the logon identity. The LogonDomainName field of the NETLOGON_LOGON_IDENTITY_INFO
	// structure indicates the target domain that contains the user account.
	Identity *LogonIdentityInfo `idl:"name:Identity" json:"identity"`
	// PackageName: Contains the name of the security provider, such as Kerberos, to which
	// the data will be delivered on the domain controller in the target domain that was
	// specified in the Identity field. This name MUST match the name of an existing security
	// provider; otherwise, the Security Support Provider Interface (SSPI) ([SSPI]) returns
	// a package not found error.
	PackageName *dtyp.UnicodeString `idl:"name:PackageName" json:"package_name"`
	// DataLength: The length, in bytes, of LogonData.
	DataLength uint32 `idl:"name:DataLength" json:"data_length"`
	// LogonData: A pointer to a block of binary data that contains the information to be
	// sent to the security package referenced in PackageName. This data is opaque to Netlogon.
	LogonData []byte `idl:"name:LogonData;size_is:(DataLength)" json:"logon_data"`
}

func (o *GenericInfo) xxx_PreparePayload(ctx context.Context) error {
	if o.LogonData != nil && o.DataLength == 0 {
		o.DataLength = uint32(len(o.LogonData))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *GenericInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.Identity != nil {
		if err := o.Identity.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&LogonIdentityInfo{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.PackageName != nil {
		if err := o.PackageName.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.DataLength); err != nil {
		return err
	}
	if o.LogonData != nil || o.DataLength > 0 {
		_ptr_LogonData := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.DataLength)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.LogonData {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.LogonData[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.LogonData); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.LogonData, _ptr_LogonData); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *GenericInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if o.Identity == nil {
		o.Identity = &LogonIdentityInfo{}
	}
	if err := o.Identity.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.PackageName == nil {
		o.PackageName = &dtyp.UnicodeString{}
	}
	if err := o.PackageName.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.DataLength); err != nil {
		return err
	}
	_ptr_LogonData := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.DataLength > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.DataLength)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.LogonData", sizeInfo[0])
		}
		o.LogonData = make([]byte, sizeInfo[0])
		for i1 := range o.LogonData {
			i1 := i1
			if err := w.ReadData(&o.LogonData[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_LogonData := func(ptr interface{}) { o.LogonData = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.LogonData, _s_LogonData, _ptr_LogonData); err != nil {
		return err
	}
	return nil
}

// Level structure represents NETLOGON_LEVEL RPC union.
//
// The NETLOGON_LEVEL union defines a union of all types of logon information.
type Level struct {
	// Types that are assignable to Value
	//
	// *Level_LogonInteractive
	// *Level_LogonInteractiveTransitive
	// *Level_LogonService
	// *Level_LogonServiceTransitive
	// *Level_LogonNetwork
	// *Level_LogonNetworkTransitive
	// *Level_LogonGeneric
	Value is_Level `json:"value"`
}

func (o *Level) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *Level_LogonInteractive:
		if value != nil {
			return value.LogonInteractive
		}
	case *Level_LogonInteractiveTransitive:
		if value != nil {
			return value.LogonInteractiveTransitive
		}
	case *Level_LogonService:
		if value != nil {
			return value.LogonService
		}
	case *Level_LogonServiceTransitive:
		if value != nil {
			return value.LogonServiceTransitive
		}
	case *Level_LogonNetwork:
		if value != nil {
			return value.LogonNetwork
		}
	case *Level_LogonNetworkTransitive:
		if value != nil {
			return value.LogonNetworkTransitive
		}
	case *Level_LogonGeneric:
		if value != nil {
			return value.LogonGeneric
		}
	}
	return nil
}

type is_Level interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_Level()
}

func (o *Level) NDRSwitchValue(sw uint16) uint16 {
	if o == nil {
		return uint16(0)
	}
	switch (interface{})(o.Value).(type) {
	case *Level_LogonInteractive:
		return uint16(1)
	case *Level_LogonInteractiveTransitive:
		return uint16(5)
	case *Level_LogonService:
		return uint16(3)
	case *Level_LogonServiceTransitive:
		return uint16(7)
	case *Level_LogonNetwork:
		return uint16(2)
	case *Level_LogonNetworkTransitive:
		return uint16(6)
	case *Level_LogonGeneric:
		return uint16(4)
	}
	return uint16(0)
}

func (o *Level) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint16) error {
	if err := w.WriteUnionAlign(7); err != nil {
		return err
	}
	if err := w.WriteSwitch(ndr.Enum(uint16(sw))); err != nil {
		return err
	}
	// ms_union
	if err := w.WriteAlign(7); err != nil {
		return err
	}
	switch sw {
	case uint16(1):
		_o, _ := o.Value.(*Level_LogonInteractive)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Level_LogonInteractive{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint16(5):
		_o, _ := o.Value.(*Level_LogonInteractiveTransitive)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Level_LogonInteractiveTransitive{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint16(3):
		_o, _ := o.Value.(*Level_LogonService)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Level_LogonService{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint16(7):
		_o, _ := o.Value.(*Level_LogonServiceTransitive)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Level_LogonServiceTransitive{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint16(2):
		_o, _ := o.Value.(*Level_LogonNetwork)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Level_LogonNetwork{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint16(6):
		_o, _ := o.Value.(*Level_LogonNetworkTransitive)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Level_LogonNetworkTransitive{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint16(4):
		_o, _ := o.Value.(*Level_LogonGeneric)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Level_LogonGeneric{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
	}
	return nil
}

func (o *Level) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint16) error {
	if err := w.ReadUnionAlign(7); err != nil {
		return err
	}
	if err := w.ReadSwitch(ndr.Enum((*uint16)(&sw))); err != nil {
		return err
	}
	// ms_union
	if err := w.ReadAlign(7); err != nil {
		return err
	}
	switch sw {
	case uint16(1):
		o.Value = &Level_LogonInteractive{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint16(5):
		o.Value = &Level_LogonInteractiveTransitive{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint16(3):
		o.Value = &Level_LogonService{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint16(7):
		o.Value = &Level_LogonServiceTransitive{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint16(2):
		o.Value = &Level_LogonNetwork{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint16(6):
		o.Value = &Level_LogonNetworkTransitive{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint16(4):
		o.Value = &Level_LogonGeneric{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
	}
	return nil
}

// Level_LogonInteractive structure represents NETLOGON_LEVEL RPC union arm.
//
// It has following labels: 1
type Level_LogonInteractive struct {
	// LogonInteractive: This field is selected when the logon information type is NetlogonInteractiveInformation.
	// The data type is NETLOGON_INTERACTIVE_INFO, as specified in section 2.2.1.4.3.
	LogonInteractive *InteractiveInfo `idl:"name:LogonInteractive" json:"logon_interactive"`
}

func (*Level_LogonInteractive) is_Level() {}

func (o *Level_LogonInteractive) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.LogonInteractive != nil {
		_ptr_LogonInteractive := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.LogonInteractive != nil {
				if err := o.LogonInteractive.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&InteractiveInfo{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.LogonInteractive, _ptr_LogonInteractive); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *Level_LogonInteractive) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_LogonInteractive := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.LogonInteractive == nil {
			o.LogonInteractive = &InteractiveInfo{}
		}
		if err := o.LogonInteractive.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_LogonInteractive := func(ptr interface{}) { o.LogonInteractive = *ptr.(**InteractiveInfo) }
	if err := w.ReadPointer(&o.LogonInteractive, _s_LogonInteractive, _ptr_LogonInteractive); err != nil {
		return err
	}
	return nil
}

// Level_LogonInteractiveTransitive structure represents NETLOGON_LEVEL RPC union arm.
//
// It has following labels: 5
type Level_LogonInteractiveTransitive struct {
	// LogonInteractiveTransitive: This field is selected when the logon information type
	// is NetlogonInteractiveTransitiveInformation. The data type is NETLOGON_INTERACTIVE_INFO,
	// as specified in section 2.2.1.4.3.
	LogonInteractiveTransitive *InteractiveInfo `idl:"name:LogonInteractiveTransitive" json:"logon_interactive_transitive"`
}

func (*Level_LogonInteractiveTransitive) is_Level() {}

func (o *Level_LogonInteractiveTransitive) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.LogonInteractiveTransitive != nil {
		_ptr_LogonInteractiveTransitive := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.LogonInteractiveTransitive != nil {
				if err := o.LogonInteractiveTransitive.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&InteractiveInfo{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.LogonInteractiveTransitive, _ptr_LogonInteractiveTransitive); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *Level_LogonInteractiveTransitive) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_LogonInteractiveTransitive := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.LogonInteractiveTransitive == nil {
			o.LogonInteractiveTransitive = &InteractiveInfo{}
		}
		if err := o.LogonInteractiveTransitive.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_LogonInteractiveTransitive := func(ptr interface{}) { o.LogonInteractiveTransitive = *ptr.(**InteractiveInfo) }
	if err := w.ReadPointer(&o.LogonInteractiveTransitive, _s_LogonInteractiveTransitive, _ptr_LogonInteractiveTransitive); err != nil {
		return err
	}
	return nil
}

// Level_LogonService structure represents NETLOGON_LEVEL RPC union arm.
//
// It has following labels: 3
type Level_LogonService struct {
	// LogonService: This field is selected when the logon information type is NetlogonServiceInformation.
	// The data type is NETLOGON_SERVICE_INFO, as specified in section 2.2.1.4.4.
	LogonService *ServiceInfo `idl:"name:LogonService" json:"logon_service"`
}

func (*Level_LogonService) is_Level() {}

func (o *Level_LogonService) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.LogonService != nil {
		_ptr_LogonService := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.LogonService != nil {
				if err := o.LogonService.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServiceInfo{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.LogonService, _ptr_LogonService); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *Level_LogonService) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_LogonService := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.LogonService == nil {
			o.LogonService = &ServiceInfo{}
		}
		if err := o.LogonService.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_LogonService := func(ptr interface{}) { o.LogonService = *ptr.(**ServiceInfo) }
	if err := w.ReadPointer(&o.LogonService, _s_LogonService, _ptr_LogonService); err != nil {
		return err
	}
	return nil
}

// Level_LogonServiceTransitive structure represents NETLOGON_LEVEL RPC union arm.
//
// It has following labels: 7
type Level_LogonServiceTransitive struct {
	// LogonServiceTransitive: This field is selected when the logon information type is
	// NetlogonServiceTransitiveInformation. The data type is NETLOGON_SERVICE_INFO, as
	// specified in section 2.2.1.4.4.
	LogonServiceTransitive *ServiceInfo `idl:"name:LogonServiceTransitive" json:"logon_service_transitive"`
}

func (*Level_LogonServiceTransitive) is_Level() {}

func (o *Level_LogonServiceTransitive) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.LogonServiceTransitive != nil {
		_ptr_LogonServiceTransitive := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.LogonServiceTransitive != nil {
				if err := o.LogonServiceTransitive.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ServiceInfo{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.LogonServiceTransitive, _ptr_LogonServiceTransitive); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *Level_LogonServiceTransitive) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_LogonServiceTransitive := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.LogonServiceTransitive == nil {
			o.LogonServiceTransitive = &ServiceInfo{}
		}
		if err := o.LogonServiceTransitive.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_LogonServiceTransitive := func(ptr interface{}) { o.LogonServiceTransitive = *ptr.(**ServiceInfo) }
	if err := w.ReadPointer(&o.LogonServiceTransitive, _s_LogonServiceTransitive, _ptr_LogonServiceTransitive); err != nil {
		return err
	}
	return nil
}

// Level_LogonNetwork structure represents NETLOGON_LEVEL RPC union arm.
//
// It has following labels: 2
type Level_LogonNetwork struct {
	// LogonNetwork: This field is selected when the logon information type is NetlogonNetworkInformation.
	// The data type is NETLOGON_NETWORK_INFO, as specified in section 2.2.1.4.5.
	LogonNetwork *NetworkInfo `idl:"name:LogonNetwork" json:"logon_network"`
}

func (*Level_LogonNetwork) is_Level() {}

func (o *Level_LogonNetwork) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.LogonNetwork != nil {
		_ptr_LogonNetwork := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.LogonNetwork != nil {
				if err := o.LogonNetwork.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&NetworkInfo{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.LogonNetwork, _ptr_LogonNetwork); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *Level_LogonNetwork) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_LogonNetwork := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.LogonNetwork == nil {
			o.LogonNetwork = &NetworkInfo{}
		}
		if err := o.LogonNetwork.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_LogonNetwork := func(ptr interface{}) { o.LogonNetwork = *ptr.(**NetworkInfo) }
	if err := w.ReadPointer(&o.LogonNetwork, _s_LogonNetwork, _ptr_LogonNetwork); err != nil {
		return err
	}
	return nil
}

// Level_LogonNetworkTransitive structure represents NETLOGON_LEVEL RPC union arm.
//
// It has following labels: 6
type Level_LogonNetworkTransitive struct {
	// LogonNetworkTransitive: This field is selected when the logon information type is
	// NetlogonNetworkTransitiveInformation. The data type is NETLOGON_NETWORK_INFO, as
	// specified in section 2.2.1.4.5.
	LogonNetworkTransitive *NetworkInfo `idl:"name:LogonNetworkTransitive" json:"logon_network_transitive"`
}

func (*Level_LogonNetworkTransitive) is_Level() {}

func (o *Level_LogonNetworkTransitive) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.LogonNetworkTransitive != nil {
		_ptr_LogonNetworkTransitive := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.LogonNetworkTransitive != nil {
				if err := o.LogonNetworkTransitive.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&NetworkInfo{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.LogonNetworkTransitive, _ptr_LogonNetworkTransitive); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *Level_LogonNetworkTransitive) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_LogonNetworkTransitive := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.LogonNetworkTransitive == nil {
			o.LogonNetworkTransitive = &NetworkInfo{}
		}
		if err := o.LogonNetworkTransitive.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_LogonNetworkTransitive := func(ptr interface{}) { o.LogonNetworkTransitive = *ptr.(**NetworkInfo) }
	if err := w.ReadPointer(&o.LogonNetworkTransitive, _s_LogonNetworkTransitive, _ptr_LogonNetworkTransitive); err != nil {
		return err
	}
	return nil
}

// Level_LogonGeneric structure represents NETLOGON_LEVEL RPC union arm.
//
// It has following labels: 4
type Level_LogonGeneric struct {
	// LogonGeneric: This field is selected when the logon information type is NetlogonGenericInformation.
	// The data type is NETLOGON_GENERIC_INFO, as specified in section 2.2.1.4.2.
	LogonGeneric *GenericInfo `idl:"name:LogonGeneric" json:"logon_generic"`
}

func (*Level_LogonGeneric) is_Level() {}

func (o *Level_LogonGeneric) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.LogonGeneric != nil {
		_ptr_LogonGeneric := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.LogonGeneric != nil {
				if err := o.LogonGeneric.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&GenericInfo{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.LogonGeneric, _ptr_LogonGeneric); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *Level_LogonGeneric) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_LogonGeneric := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.LogonGeneric == nil {
			o.LogonGeneric = &GenericInfo{}
		}
		if err := o.LogonGeneric.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_LogonGeneric := func(ptr interface{}) { o.LogonGeneric = *ptr.(**GenericInfo) }
	if err := w.ReadPointer(&o.LogonGeneric, _s_LogonGeneric, _ptr_LogonGeneric); err != nil {
		return err
	}
	return nil
}

// ValidationInfoClass type represents NETLOGON_VALIDATION_INFO_CLASS RPC enumeration.
//
// The NETLOGON_VALIDATION_INFO_CLASS enumeration SHOULD<49> select the type of logon
// information block being used.
type ValidationInfoClass uint16

var (
	// NetlogonValidationUasInfo: Associated structure is NETLOGON_VALIDATION_UAS_INFO (section
	// 2.2.1.8.1).
	ValidationInfoClassUASInfo ValidationInfoClass = 1
	// NetlogonValidationSamInfo: Associated structure is NETLOGON_VALIDATION_SAM_INFO (section
	// 2.2.1.4.11).
	ValidationInfoClassSAMInfo ValidationInfoClass = 2
	// NetlogonValidationSamInfo2: Associated structure is NETLOGON_VALIDATION_SAM_INFO2
	// (section 2.2.1.4.12).
	ValidationInfoClassSAMInfo2 ValidationInfoClass = 3
	// NetlogonValidationGenericInfo: Associated structure is NETLOGON_VALIDATION_GENERIC_INFO2
	// (section 2.2.1.4.8).
	ValidationInfoClassGenericInfo ValidationInfoClass = 4
	// NetlogonValidationGenericInfo2: Associated structure is NETLOGON_VALIDATION_GENERIC_INFO2.
	ValidationInfoClassGenericInfo2 ValidationInfoClass = 5
	// NetlogonValidationSamInfo4: Associated structure is NETLOGON_VALIDATION_SAM_INFO4
	// (section 2.2.1.4.13).
	ValidationInfoClassSAMInfo4 ValidationInfoClass = 6
)

func (o ValidationInfoClass) String() string {
	switch o {
	case ValidationInfoClassUASInfo:
		return "ValidationInfoClassUASInfo"
	case ValidationInfoClassSAMInfo:
		return "ValidationInfoClassSAMInfo"
	case ValidationInfoClassSAMInfo2:
		return "ValidationInfoClassSAMInfo2"
	case ValidationInfoClassGenericInfo:
		return "ValidationInfoClassGenericInfo"
	case ValidationInfoClassGenericInfo2:
		return "ValidationInfoClassGenericInfo2"
	case ValidationInfoClassSAMInfo4:
		return "ValidationInfoClassSAMInfo4"
	}
	return "Invalid"
}

// GroupMembership structure represents GROUP_MEMBERSHIP RPC structure.
//
// The GROUP_MEMBERSHIP structure identifies the group to which an account belongs.
type GroupMembership struct {
	// RelativeId: The relative identifier (RID) for a particular group.
	RelativeID uint32 `idl:"name:RelativeId" json:"relative_id"`
	// Attributes: A set of values that describe the group membership attributes set for
	// the RID specified in RelativeId. The value is constructed from one or more bit flags
	// from the following table.
	//
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
	//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | C | B | A |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//
	// Where the bits are defined as:
	//
	//	+-------+----------------------------------------------------------------------------------+
	//	|       |                                                                                  |
	//	| VALUE |                                   DESCRIPTION                                    |
	//	|       |                                                                                  |
	//	+-------+----------------------------------------------------------------------------------+
	//	+-------+----------------------------------------------------------------------------------+
	//	| A     | The SID cannot have the SE_GROUP_ENABLED attribute removed. Corresponds to       |
	//	|       | the SID attribute SE_GROUP_MANDATORY. This attribute prevents the user from      |
	//	|       | disabling the group. Disabling a group causes the group to be ignored by access  |
	//	|       | validation routines.                                                             |
	//	+-------+----------------------------------------------------------------------------------+
	//	| B     | The SID is enabled by default (as opposed to being enabled by an application).   |
	//	|       | Corresponds to the SID attribute SE_GROUP_ENABLED_BY_DEFAULT.                    |
	//	+-------+----------------------------------------------------------------------------------+
	//	| C     | The SID is enabled for access checks. Corresponds to the SID attribute           |
	//	|       | SE_GROUP_ENABLED. The SE_GROUP_ENABLED attribute enables the group.              |
	//	+-------+----------------------------------------------------------------------------------+
	//
	// These values are opaque to the Netlogon protocol. They are not used or processed
	// directly. All fields of this structure have the same meaning as the identically named
	// fields in the GROUP_MEMBERSHIP structure as specified in [MS-PAC] section 2.2.2.
	Attributes uint32 `idl:"name:Attributes" json:"attributes"`
}

func (o *GroupMembership) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *GroupMembership) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.RelativeID); err != nil {
		return err
	}
	if err := w.WriteData(o.Attributes); err != nil {
		return err
	}
	return nil
}
func (o *GroupMembership) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.RelativeID); err != nil {
		return err
	}
	if err := w.ReadData(&o.Attributes); err != nil {
		return err
	}
	return nil
}

// UserSessionKey structure represents USER_SESSION_KEY RPC structure.
//
// The USER_SESSION_KEY structure defines an encrypted user session key.
type UserSessionKey struct {
	// data: A two-element CYPHER_BLOCK structure, as specified in section 2.2.1.1.1, that
	// contains the 16-byte encrypted user session key.
	Data []*CypherBlock `idl:"name:data" json:"data"`
}

func (o *UserSessionKey) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *UserSessionKey) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	for i1 := range o.Data {
		i1 := i1
		if uint64(i1) >= 2 {
			break
		}
		if o.Data[i1] != nil {
			if err := o.Data[i1].MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&CypherBlock{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	for i1 := len(o.Data); uint64(i1) < 2; i1++ {
		if err := (&CypherBlock{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *UserSessionKey) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	o.Data = make([]*CypherBlock, 2)
	for i1 := range o.Data {
		i1 := i1
		if o.Data[i1] == nil {
			o.Data[i1] = &CypherBlock{}
		}
		if err := o.Data[i1].UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// SIDAndAttributes structure represents NETLOGON_SID_AND_ATTRIBUTES RPC structure.
//
// The NETLOGON_SID_AND_ATTRIBUTES structure contains a security identifier (SID) and
// its attributes.
type SIDAndAttributes struct {
	// Sid: A pointer to a security identifier (SID), as specified in [MS-DTYP] section
	// 2.4.2.3.
	SID *dtyp.SID `idl:"name:Sid" json:"sid"`
	// Attributes: A set of bit flags that contains the set of security attributes assigned
	// to this SID. A bit is TRUE (or set) if its value is equal to 1.  The value is constructed
	// from one or more bit flags from the following table.
	//
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
	//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 0 | D | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | C | B | A |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//
	// Where the bits are defined as:
	//
	//	+-------+----------------------------------------------------------------------------------+
	//	|       |                                                                                  |
	//	| VALUE |                                   DESCRIPTION                                    |
	//	|       |                                                                                  |
	//	+-------+----------------------------------------------------------------------------------+
	//	+-------+----------------------------------------------------------------------------------+
	//	| A     | The SID cannot have the SE_GROUP_ENABLED attribute removed.  Corresponds to      |
	//	|       | the SID attribute SE_GROUP_MANDATORY. This attribute prevents the user from      |
	//	|       | disabling the group. Disabling a group causes the group to be ignored by access  |
	//	|       | validation routines.                                                             |
	//	+-------+----------------------------------------------------------------------------------+
	//	| B     | The SID is enabled by default (as opposed to being enabled by an application).   |
	//	|       | Corresponds to the SID attribute SE_GROUP_ENABLED_BY_DEFAULT.                    |
	//	+-------+----------------------------------------------------------------------------------+
	//	| C     | The SID is enabled for access checks.  Corresponds to the SID attribute          |
	//	|       | SE_GROUP_ENABLED.                                                                |
	//	+-------+----------------------------------------------------------------------------------+
	//	| D     | This group is a domain local group. Corresponds to SE_GROUP_RESOURCE.            |
	//	+-------+----------------------------------------------------------------------------------+
	//
	// These values are opaque to the Netlogon protocol. They are not used or processed
	// directly. All fields of this structure have the same meaning as the identically named
	// fields in the KERB_SID_AND_ATTRIBUTES structure as specified in [MS-PAC] section
	// 2.2.1.
	Attributes uint32 `idl:"name:Attributes" json:"attributes"`
}

func (o *SIDAndAttributes) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *SIDAndAttributes) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.SID != nil {
		_ptr_Sid := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.SID != nil {
				if err := o.SID.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&dtyp.SID{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.SID, _ptr_Sid); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Attributes); err != nil {
		return err
	}
	return nil
}
func (o *SIDAndAttributes) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_Sid := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.SID == nil {
			o.SID = &dtyp.SID{}
		}
		if err := o.SID.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_Sid := func(ptr interface{}) { o.SID = *ptr.(**dtyp.SID) }
	if err := w.ReadPointer(&o.SID, _s_Sid, _ptr_Sid); err != nil {
		return err
	}
	if err := w.ReadData(&o.Attributes); err != nil {
		return err
	}
	return nil
}

// ValidationSAMInfo structure represents NETLOGON_VALIDATION_SAM_INFO RPC structure.
//
// The NETLOGON_VALIDATION_SAM_INFO structure defines account information retrieved
// from a database upon a successful user logon validation.
//
// All fields of this structure, except the fields detailed following the structure
// definition, have the same meaning as the identically named fields in the KERB_VALIDATION_INFO
// structure, as specified in [MS-PAC] section 2.5. Additionally, fields of this structure
// that are defined as OLD_LARGE_INTEGER [MSDN-OLI] are 64-bit timestamps equivalent
// to the identically named fields in the KERB_VALIDATION_INFO structure of FILETIME
// type ([MS-DTYP] section 2.3.3). For more information see [MSDN-FILETIME].
type ValidationSAMInfo struct {
	LogonTime          *OldLargeInteger    `idl:"name:LogonTime" json:"logon_time"`
	LogoffTime         *OldLargeInteger    `idl:"name:LogoffTime" json:"logoff_time"`
	KickOffTime        *OldLargeInteger    `idl:"name:KickOffTime" json:"kick_off_time"`
	PasswordLastSet    *OldLargeInteger    `idl:"name:PasswordLastSet" json:"password_last_set"`
	PasswordCanChange  *OldLargeInteger    `idl:"name:PasswordCanChange" json:"password_can_change"`
	PasswordMustChange *OldLargeInteger    `idl:"name:PasswordMustChange" json:"password_must_change"`
	EffectiveName      *dtyp.UnicodeString `idl:"name:EffectiveName" json:"effective_name"`
	FullName           *dtyp.UnicodeString `idl:"name:FullName" json:"full_name"`
	LogonScript        *dtyp.UnicodeString `idl:"name:LogonScript" json:"logon_script"`
	ProfilePath        *dtyp.UnicodeString `idl:"name:ProfilePath" json:"profile_path"`
	HomeDirectory      *dtyp.UnicodeString `idl:"name:HomeDirectory" json:"home_directory"`
	HomeDirectoryDrive *dtyp.UnicodeString `idl:"name:HomeDirectoryDrive" json:"home_directory_drive"`
	LogonCount         uint16              `idl:"name:LogonCount" json:"logon_count"`
	BadPasswordCount   uint16              `idl:"name:BadPasswordCount" json:"bad_password_count"`
	UserID             uint32              `idl:"name:UserId" json:"user_id"`
	PrimaryGroupID     uint32              `idl:"name:PrimaryGroupId" json:"primary_group_id"`
	GroupCount         uint32              `idl:"name:GroupCount" json:"group_count"`
	GroupIDs           []*GroupMembership  `idl:"name:GroupIds;size_is:(GroupCount)" json:"group_ids"`
	UserFlags          uint32              `idl:"name:UserFlags" json:"user_flags"`
	UserSessionKey     *UserSessionKey     `idl:"name:UserSessionKey" json:"user_session_key"`
	// LogonServer: An RPC_UNICODE_STRING structure (defined in [MS-DTYP] section 2.3.10)
	// that contains the NetBIOS name of the server that populates this structure.
	LogonServer     *dtyp.UnicodeString `idl:"name:LogonServer" json:"logon_server"`
	LogonDomainName *dtyp.UnicodeString `idl:"name:LogonDomainName" json:"logon_domain_name"`
	LogonDomainID   *dtyp.SID           `idl:"name:LogonDomainId" json:"logon_domain_id"`
	// ExpansionRoom: A ten-element array of unsigned 32-bit integers. This member has a
	// function similar to that of dummy fields, as detailed in section 1.3.8.1.2. Each
	// element of the array MUST be zero when sent and MUST be ignored on receipt.
	ExpansionRoom []uint32 `idl:"name:ExpansionRoom" json:"expansion_room"`
}

func (o *ValidationSAMInfo) xxx_PreparePayload(ctx context.Context) error {
	if o.GroupIDs != nil && o.GroupCount == 0 {
		o.GroupCount = uint32(len(o.GroupIDs))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ValidationSAMInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.LogonTime != nil {
		if err := o.LogonTime.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&OldLargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.LogoffTime != nil {
		if err := o.LogoffTime.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&OldLargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.KickOffTime != nil {
		if err := o.KickOffTime.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&OldLargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.PasswordLastSet != nil {
		if err := o.PasswordLastSet.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&OldLargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.PasswordCanChange != nil {
		if err := o.PasswordCanChange.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&OldLargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.PasswordMustChange != nil {
		if err := o.PasswordMustChange.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&OldLargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.EffectiveName != nil {
		if err := o.EffectiveName.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.FullName != nil {
		if err := o.FullName.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.LogonScript != nil {
		if err := o.LogonScript.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.ProfilePath != nil {
		if err := o.ProfilePath.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.HomeDirectory != nil {
		if err := o.HomeDirectory.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.HomeDirectoryDrive != nil {
		if err := o.HomeDirectoryDrive.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.LogonCount); err != nil {
		return err
	}
	if err := w.WriteData(o.BadPasswordCount); err != nil {
		return err
	}
	if err := w.WriteData(o.UserID); err != nil {
		return err
	}
	if err := w.WriteData(o.PrimaryGroupID); err != nil {
		return err
	}
	if err := w.WriteData(o.GroupCount); err != nil {
		return err
	}
	if o.GroupIDs != nil || o.GroupCount > 0 {
		_ptr_GroupIds := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.GroupCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.GroupIDs {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.GroupIDs[i1] != nil {
					if err := o.GroupIDs[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&GroupMembership{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.GroupIDs); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&GroupMembership{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.GroupIDs, _ptr_GroupIds); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.UserFlags); err != nil {
		return err
	}
	if o.UserSessionKey != nil {
		if err := o.UserSessionKey.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&UserSessionKey{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.LogonServer != nil {
		if err := o.LogonServer.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.LogonDomainName != nil {
		if err := o.LogonDomainName.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.LogonDomainID != nil {
		_ptr_LogonDomainId := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.LogonDomainID != nil {
				if err := o.LogonDomainID.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&dtyp.SID{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.LogonDomainID, _ptr_LogonDomainId); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	for i1 := range o.ExpansionRoom {
		i1 := i1
		if uint64(i1) >= 10 {
			break
		}
		if err := w.WriteData(o.ExpansionRoom[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.ExpansionRoom); uint64(i1) < 10; i1++ {
		if err := w.WriteData(uint32(0)); err != nil {
			return err
		}
	}
	return nil
}
func (o *ValidationSAMInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if o.LogonTime == nil {
		o.LogonTime = &OldLargeInteger{}
	}
	if err := o.LogonTime.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.LogoffTime == nil {
		o.LogoffTime = &OldLargeInteger{}
	}
	if err := o.LogoffTime.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.KickOffTime == nil {
		o.KickOffTime = &OldLargeInteger{}
	}
	if err := o.KickOffTime.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.PasswordLastSet == nil {
		o.PasswordLastSet = &OldLargeInteger{}
	}
	if err := o.PasswordLastSet.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.PasswordCanChange == nil {
		o.PasswordCanChange = &OldLargeInteger{}
	}
	if err := o.PasswordCanChange.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.PasswordMustChange == nil {
		o.PasswordMustChange = &OldLargeInteger{}
	}
	if err := o.PasswordMustChange.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.EffectiveName == nil {
		o.EffectiveName = &dtyp.UnicodeString{}
	}
	if err := o.EffectiveName.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.FullName == nil {
		o.FullName = &dtyp.UnicodeString{}
	}
	if err := o.FullName.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.LogonScript == nil {
		o.LogonScript = &dtyp.UnicodeString{}
	}
	if err := o.LogonScript.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.ProfilePath == nil {
		o.ProfilePath = &dtyp.UnicodeString{}
	}
	if err := o.ProfilePath.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.HomeDirectory == nil {
		o.HomeDirectory = &dtyp.UnicodeString{}
	}
	if err := o.HomeDirectory.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.HomeDirectoryDrive == nil {
		o.HomeDirectoryDrive = &dtyp.UnicodeString{}
	}
	if err := o.HomeDirectoryDrive.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.LogonCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.BadPasswordCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.UserID); err != nil {
		return err
	}
	if err := w.ReadData(&o.PrimaryGroupID); err != nil {
		return err
	}
	if err := w.ReadData(&o.GroupCount); err != nil {
		return err
	}
	_ptr_GroupIds := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.GroupCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.GroupCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.GroupIDs", sizeInfo[0])
		}
		o.GroupIDs = make([]*GroupMembership, sizeInfo[0])
		for i1 := range o.GroupIDs {
			i1 := i1
			if o.GroupIDs[i1] == nil {
				o.GroupIDs[i1] = &GroupMembership{}
			}
			if err := o.GroupIDs[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_GroupIds := func(ptr interface{}) { o.GroupIDs = *ptr.(*[]*GroupMembership) }
	if err := w.ReadPointer(&o.GroupIDs, _s_GroupIds, _ptr_GroupIds); err != nil {
		return err
	}
	if err := w.ReadData(&o.UserFlags); err != nil {
		return err
	}
	if o.UserSessionKey == nil {
		o.UserSessionKey = &UserSessionKey{}
	}
	if err := o.UserSessionKey.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.LogonServer == nil {
		o.LogonServer = &dtyp.UnicodeString{}
	}
	if err := o.LogonServer.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.LogonDomainName == nil {
		o.LogonDomainName = &dtyp.UnicodeString{}
	}
	if err := o.LogonDomainName.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_LogonDomainId := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.LogonDomainID == nil {
			o.LogonDomainID = &dtyp.SID{}
		}
		if err := o.LogonDomainID.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_LogonDomainId := func(ptr interface{}) { o.LogonDomainID = *ptr.(**dtyp.SID) }
	if err := w.ReadPointer(&o.LogonDomainID, _s_LogonDomainId, _ptr_LogonDomainId); err != nil {
		return err
	}
	o.ExpansionRoom = make([]uint32, 10)
	for i1 := range o.ExpansionRoom {
		i1 := i1
		if err := w.ReadData(&o.ExpansionRoom[i1]); err != nil {
			return err
		}
	}
	return nil
}

// ValidationSAMInfo2 structure represents NETLOGON_VALIDATION_SAM_INFO2 RPC structure.
//
// The NETLOGON_VALIDATION_SAM_INFO2 structure is an extension to NETLOGON_VALIDATION_SAM_INFO,
// as specified in section 2.2.1.4.11, with support for storing extra SIDs.
//
// All fields of this structure, except the fields detailed following the structure
// definition, have the same meaning as the identically named fields in the KERB_VALIDATION_INFO
// structure as specified in [MS-PAC] section 2.5. Additionally, fields of this structure
// that are defined as OLD_LARGE_INTEGER are 64-bit timestamps equivalent to the identically
// named fields in the KERB_VALIDATION_INFO structure of FILETIME type ([MS-DTYP] section
// 2.3.3).
type ValidationSAMInfo2 struct {
	LogonTime          *OldLargeInteger    `idl:"name:LogonTime" json:"logon_time"`
	LogoffTime         *OldLargeInteger    `idl:"name:LogoffTime" json:"logoff_time"`
	KickOffTime        *OldLargeInteger    `idl:"name:KickOffTime" json:"kick_off_time"`
	PasswordLastSet    *OldLargeInteger    `idl:"name:PasswordLastSet" json:"password_last_set"`
	PasswordCanChange  *OldLargeInteger    `idl:"name:PasswordCanChange" json:"password_can_change"`
	PasswordMustChange *OldLargeInteger    `idl:"name:PasswordMustChange" json:"password_must_change"`
	EffectiveName      *dtyp.UnicodeString `idl:"name:EffectiveName" json:"effective_name"`
	FullName           *dtyp.UnicodeString `idl:"name:FullName" json:"full_name"`
	LogonScript        *dtyp.UnicodeString `idl:"name:LogonScript" json:"logon_script"`
	ProfilePath        *dtyp.UnicodeString `idl:"name:ProfilePath" json:"profile_path"`
	HomeDirectory      *dtyp.UnicodeString `idl:"name:HomeDirectory" json:"home_directory"`
	HomeDirectoryDrive *dtyp.UnicodeString `idl:"name:HomeDirectoryDrive" json:"home_directory_drive"`
	LogonCount         uint16              `idl:"name:LogonCount" json:"logon_count"`
	BadPasswordCount   uint16              `idl:"name:BadPasswordCount" json:"bad_password_count"`
	UserID             uint32              `idl:"name:UserId" json:"user_id"`
	PrimaryGroupID     uint32              `idl:"name:PrimaryGroupId" json:"primary_group_id"`
	GroupCount         uint32              `idl:"name:GroupCount" json:"group_count"`
	GroupIDs           []*GroupMembership  `idl:"name:GroupIds;size_is:(GroupCount)" json:"group_ids"`
	UserFlags          uint32              `idl:"name:UserFlags" json:"user_flags"`
	UserSessionKey     *UserSessionKey     `idl:"name:UserSessionKey" json:"user_session_key"`
	// LogonServer: An RPC_UNICODE_STRING structure that contains the NetBIOS name of the
	// server that populates this structure.
	LogonServer     *dtyp.UnicodeString `idl:"name:LogonServer" json:"logon_server"`
	LogonDomainName *dtyp.UnicodeString `idl:"name:LogonDomainName" json:"logon_domain_name"`
	LogonDomainID   *dtyp.SID           `idl:"name:LogonDomainId" json:"logon_domain_id"`
	// ExpansionRoom: A ten-element array of unsigned 32-bit integers. This member has a
	// function similar to that of dummy fields, as described in section 1.3.8.1.2. Each
	// element of the array MUST be zero when sent and MUST be ignored on receipt.
	ExpansionRoom []uint32            `idl:"name:ExpansionRoom" json:"expansion_room"`
	SIDCount      uint32              `idl:"name:SidCount" json:"sid_count"`
	ExtraSIDs     []*SIDAndAttributes `idl:"name:ExtraSids;size_is:(SidCount)" json:"extra_sids"`
}

func (o *ValidationSAMInfo2) xxx_PreparePayload(ctx context.Context) error {
	if o.GroupIDs != nil && o.GroupCount == 0 {
		o.GroupCount = uint32(len(o.GroupIDs))
	}
	if o.ExtraSIDs != nil && o.SIDCount == 0 {
		o.SIDCount = uint32(len(o.ExtraSIDs))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ValidationSAMInfo2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.LogonTime != nil {
		if err := o.LogonTime.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&OldLargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.LogoffTime != nil {
		if err := o.LogoffTime.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&OldLargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.KickOffTime != nil {
		if err := o.KickOffTime.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&OldLargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.PasswordLastSet != nil {
		if err := o.PasswordLastSet.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&OldLargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.PasswordCanChange != nil {
		if err := o.PasswordCanChange.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&OldLargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.PasswordMustChange != nil {
		if err := o.PasswordMustChange.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&OldLargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.EffectiveName != nil {
		if err := o.EffectiveName.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.FullName != nil {
		if err := o.FullName.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.LogonScript != nil {
		if err := o.LogonScript.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.ProfilePath != nil {
		if err := o.ProfilePath.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.HomeDirectory != nil {
		if err := o.HomeDirectory.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.HomeDirectoryDrive != nil {
		if err := o.HomeDirectoryDrive.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.LogonCount); err != nil {
		return err
	}
	if err := w.WriteData(o.BadPasswordCount); err != nil {
		return err
	}
	if err := w.WriteData(o.UserID); err != nil {
		return err
	}
	if err := w.WriteData(o.PrimaryGroupID); err != nil {
		return err
	}
	if err := w.WriteData(o.GroupCount); err != nil {
		return err
	}
	if o.GroupIDs != nil || o.GroupCount > 0 {
		_ptr_GroupIds := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.GroupCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.GroupIDs {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.GroupIDs[i1] != nil {
					if err := o.GroupIDs[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&GroupMembership{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.GroupIDs); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&GroupMembership{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.GroupIDs, _ptr_GroupIds); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.UserFlags); err != nil {
		return err
	}
	if o.UserSessionKey != nil {
		if err := o.UserSessionKey.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&UserSessionKey{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.LogonServer != nil {
		if err := o.LogonServer.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.LogonDomainName != nil {
		if err := o.LogonDomainName.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.LogonDomainID != nil {
		_ptr_LogonDomainId := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.LogonDomainID != nil {
				if err := o.LogonDomainID.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&dtyp.SID{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.LogonDomainID, _ptr_LogonDomainId); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	for i1 := range o.ExpansionRoom {
		i1 := i1
		if uint64(i1) >= 10 {
			break
		}
		if err := w.WriteData(o.ExpansionRoom[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.ExpansionRoom); uint64(i1) < 10; i1++ {
		if err := w.WriteData(uint32(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.SIDCount); err != nil {
		return err
	}
	if o.ExtraSIDs != nil || o.SIDCount > 0 {
		_ptr_ExtraSids := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.SIDCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.ExtraSIDs {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.ExtraSIDs[i1] != nil {
					if err := o.ExtraSIDs[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&SIDAndAttributes{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.ExtraSIDs); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&SIDAndAttributes{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ExtraSIDs, _ptr_ExtraSids); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ValidationSAMInfo2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if o.LogonTime == nil {
		o.LogonTime = &OldLargeInteger{}
	}
	if err := o.LogonTime.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.LogoffTime == nil {
		o.LogoffTime = &OldLargeInteger{}
	}
	if err := o.LogoffTime.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.KickOffTime == nil {
		o.KickOffTime = &OldLargeInteger{}
	}
	if err := o.KickOffTime.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.PasswordLastSet == nil {
		o.PasswordLastSet = &OldLargeInteger{}
	}
	if err := o.PasswordLastSet.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.PasswordCanChange == nil {
		o.PasswordCanChange = &OldLargeInteger{}
	}
	if err := o.PasswordCanChange.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.PasswordMustChange == nil {
		o.PasswordMustChange = &OldLargeInteger{}
	}
	if err := o.PasswordMustChange.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.EffectiveName == nil {
		o.EffectiveName = &dtyp.UnicodeString{}
	}
	if err := o.EffectiveName.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.FullName == nil {
		o.FullName = &dtyp.UnicodeString{}
	}
	if err := o.FullName.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.LogonScript == nil {
		o.LogonScript = &dtyp.UnicodeString{}
	}
	if err := o.LogonScript.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.ProfilePath == nil {
		o.ProfilePath = &dtyp.UnicodeString{}
	}
	if err := o.ProfilePath.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.HomeDirectory == nil {
		o.HomeDirectory = &dtyp.UnicodeString{}
	}
	if err := o.HomeDirectory.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.HomeDirectoryDrive == nil {
		o.HomeDirectoryDrive = &dtyp.UnicodeString{}
	}
	if err := o.HomeDirectoryDrive.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.LogonCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.BadPasswordCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.UserID); err != nil {
		return err
	}
	if err := w.ReadData(&o.PrimaryGroupID); err != nil {
		return err
	}
	if err := w.ReadData(&o.GroupCount); err != nil {
		return err
	}
	_ptr_GroupIds := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.GroupCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.GroupCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.GroupIDs", sizeInfo[0])
		}
		o.GroupIDs = make([]*GroupMembership, sizeInfo[0])
		for i1 := range o.GroupIDs {
			i1 := i1
			if o.GroupIDs[i1] == nil {
				o.GroupIDs[i1] = &GroupMembership{}
			}
			if err := o.GroupIDs[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_GroupIds := func(ptr interface{}) { o.GroupIDs = *ptr.(*[]*GroupMembership) }
	if err := w.ReadPointer(&o.GroupIDs, _s_GroupIds, _ptr_GroupIds); err != nil {
		return err
	}
	if err := w.ReadData(&o.UserFlags); err != nil {
		return err
	}
	if o.UserSessionKey == nil {
		o.UserSessionKey = &UserSessionKey{}
	}
	if err := o.UserSessionKey.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.LogonServer == nil {
		o.LogonServer = &dtyp.UnicodeString{}
	}
	if err := o.LogonServer.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.LogonDomainName == nil {
		o.LogonDomainName = &dtyp.UnicodeString{}
	}
	if err := o.LogonDomainName.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_LogonDomainId := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.LogonDomainID == nil {
			o.LogonDomainID = &dtyp.SID{}
		}
		if err := o.LogonDomainID.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_LogonDomainId := func(ptr interface{}) { o.LogonDomainID = *ptr.(**dtyp.SID) }
	if err := w.ReadPointer(&o.LogonDomainID, _s_LogonDomainId, _ptr_LogonDomainId); err != nil {
		return err
	}
	o.ExpansionRoom = make([]uint32, 10)
	for i1 := range o.ExpansionRoom {
		i1 := i1
		if err := w.ReadData(&o.ExpansionRoom[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.SIDCount); err != nil {
		return err
	}
	_ptr_ExtraSids := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.SIDCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.SIDCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.ExtraSIDs", sizeInfo[0])
		}
		o.ExtraSIDs = make([]*SIDAndAttributes, sizeInfo[0])
		for i1 := range o.ExtraSIDs {
			i1 := i1
			if o.ExtraSIDs[i1] == nil {
				o.ExtraSIDs[i1] = &SIDAndAttributes{}
			}
			if err := o.ExtraSIDs[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_ExtraSids := func(ptr interface{}) { o.ExtraSIDs = *ptr.(*[]*SIDAndAttributes) }
	if err := w.ReadPointer(&o.ExtraSIDs, _s_ExtraSids, _ptr_ExtraSids); err != nil {
		return err
	}
	return nil
}

// ValidationGenericInfo2 structure represents NETLOGON_VALIDATION_GENERIC_INFO2 RPC structure.
//
// The NETLOGON_VALIDATION_GENERIC_INFO2 structure defines a structure that contains
// account information in binary format. This structure is used by authentication protocols
// to return generic account information upon successful logon validation. For an example
// of using the NETLOGON_VALIDATION_GENERIC_INFO2 structure, see any of the examples
// in [MS-APDS].
type ValidationGenericInfo2 struct {
	// DataLength: An integer value that contains the length of the data referenced by ValidationData,
	// in bytes.
	DataLength uint32 `idl:"name:DataLength" json:"data_length"`
	// ValidationData: A pointer to a buffer that contains the logon validation information.
	ValidationData []byte `idl:"name:ValidationData;size_is:(DataLength)" json:"validation_data"`
}

func (o *ValidationGenericInfo2) xxx_PreparePayload(ctx context.Context) error {
	if o.ValidationData != nil && o.DataLength == 0 {
		o.DataLength = uint32(len(o.ValidationData))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ValidationGenericInfo2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.DataLength); err != nil {
		return err
	}
	if o.ValidationData != nil || o.DataLength > 0 {
		_ptr_ValidationData := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.DataLength)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.ValidationData {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.ValidationData[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.ValidationData); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ValidationData, _ptr_ValidationData); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ValidationGenericInfo2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.DataLength); err != nil {
		return err
	}
	_ptr_ValidationData := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.DataLength > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.DataLength)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.ValidationData", sizeInfo[0])
		}
		o.ValidationData = make([]byte, sizeInfo[0])
		for i1 := range o.ValidationData {
			i1 := i1
			if err := w.ReadData(&o.ValidationData[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_ValidationData := func(ptr interface{}) { o.ValidationData = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.ValidationData, _s_ValidationData, _ptr_ValidationData); err != nil {
		return err
	}
	return nil
}

// ValidationSAMInfo4 structure represents NETLOGON_VALIDATION_SAM_INFO4 RPC structure.
//
// The NETLOGON_VALIDATION_SAM_INFO4 structure extends NETLOGON_VALIDATION_SAM_INFO2,
// as specified in section 2.2.1.4.12, by storing the FQDN of the domain of the user
// account and the user principal.
//
// All fields of this structure, except the fields detailed following the structure
// definition, have the same meaning as the identically named fields in the KERB_VALIDATION_INFO
// structure, as specified in [MS-PAC] section 2.5. Additionally, fields of this structure
// that are defined as OLD_LARGE_INTEGER are 64-bit timestamps equivalent to the identically
// named fields in the KERB_VALIDATION_INFO structure of FILETIME type ([MS-DTYP] section
// 2.3.3).
type ValidationSAMInfo4 struct {
	LogonTime          *OldLargeInteger    `idl:"name:LogonTime" json:"logon_time"`
	LogoffTime         *OldLargeInteger    `idl:"name:LogoffTime" json:"logoff_time"`
	KickOffTime        *OldLargeInteger    `idl:"name:KickOffTime" json:"kick_off_time"`
	PasswordLastSet    *OldLargeInteger    `idl:"name:PasswordLastSet" json:"password_last_set"`
	PasswordCanChange  *OldLargeInteger    `idl:"name:PasswordCanChange" json:"password_can_change"`
	PasswordMustChange *OldLargeInteger    `idl:"name:PasswordMustChange" json:"password_must_change"`
	EffectiveName      *dtyp.UnicodeString `idl:"name:EffectiveName" json:"effective_name"`
	FullName           *dtyp.UnicodeString `idl:"name:FullName" json:"full_name"`
	LogonScript        *dtyp.UnicodeString `idl:"name:LogonScript" json:"logon_script"`
	ProfilePath        *dtyp.UnicodeString `idl:"name:ProfilePath" json:"profile_path"`
	HomeDirectory      *dtyp.UnicodeString `idl:"name:HomeDirectory" json:"home_directory"`
	HomeDirectoryDrive *dtyp.UnicodeString `idl:"name:HomeDirectoryDrive" json:"home_directory_drive"`
	LogonCount         uint16              `idl:"name:LogonCount" json:"logon_count"`
	BadPasswordCount   uint16              `idl:"name:BadPasswordCount" json:"bad_password_count"`
	UserID             uint32              `idl:"name:UserId" json:"user_id"`
	PrimaryGroupID     uint32              `idl:"name:PrimaryGroupId" json:"primary_group_id"`
	GroupCount         uint32              `idl:"name:GroupCount" json:"group_count"`
	GroupIDs           []*GroupMembership  `idl:"name:GroupIds;size_is:(GroupCount)" json:"group_ids"`
	UserFlags          uint32              `idl:"name:UserFlags" json:"user_flags"`
	UserSessionKey     *UserSessionKey     `idl:"name:UserSessionKey" json:"user_session_key"`
	// LogonServer: An RPC_UNICODE_STRING structure that contains the NetBIOS name of the
	// server that populates this structure.
	LogonServer     *dtyp.UnicodeString `idl:"name:LogonServer" json:"logon_server"`
	LogonDomainName *dtyp.UnicodeString `idl:"name:LogonDomainName" json:"logon_domain_name"`
	LogonDomainID   *dtyp.SID           `idl:"name:LogonDomainId" json:"logon_domain_id"`
	// LMKey: Contains the first 8 bytes of the LMOWF ([MS-NLMP] section 3.3.1) if NTLMV1
	// is used, or the first 8 bytes of the KXKEY ([MS-NLMP] section 3.4.5.1) if NTLMV2
	// is used.
	LMKey                []byte           `idl:"name:LMKey" json:"lm_key"`
	UserAccountControl   uint32           `idl:"name:UserAccountControl" json:"user_account_control"`
	SubAuthStatus        uint32           `idl:"name:SubAuthStatus" json:"sub_auth_status"`
	LastSuccessfulILogon *OldLargeInteger `idl:"name:LastSuccessfulILogon" json:"last_successful_i_logon"`
	LastFailedILogon     *OldLargeInteger `idl:"name:LastFailedILogon" json:"last_failed_i_logon"`
	FailedILogonCount    uint32           `idl:"name:FailedILogonCount" json:"failed_i_logon_count"`
	// Reserved4: An unsigned 32-bit integer. This member is reserved. MUST be zero when
	// sent and MUST be ignored on receipt.
	_         []uint32            `idl:"name:Reserved4"`
	SIDCount  uint32              `idl:"name:SidCount" json:"sid_count"`
	ExtraSIDs []*SIDAndAttributes `idl:"name:ExtraSids;size_is:(SidCount)" json:"extra_sids"`
	// DnsLogonDomainName: Contains the FQDN of the domain of the user account.
	DNSLogonDomainName *dtyp.UnicodeString `idl:"name:DnsLogonDomainName" json:"dns_logon_domain_name"`
	// Upn: Contains the user principal name (UPN).
	UPN *dtyp.UnicodeString `idl:"name:Upn" json:"upn"`
	// ExpansionString1: A STRING structure, defined in section 2.2.1.1.2, that MUST contain
	// 0 for the Length field, 0 for the MaximumLength field, and NULL for the Buffer field.
	// It is ignored upon receipt. Expansion strings have a function similar to that of
	// dummy fields, as described in section 1.3.8.1.2.
	ExpansionString1 *dtyp.UnicodeString `idl:"name:ExpansionString1" json:"expansion_string1"`
	// ExpansionString2: See definition for ExpansionString1.
	ExpansionString2 *dtyp.UnicodeString `idl:"name:ExpansionString2" json:"expansion_string2"`
	// ExpansionString3: See definition for ExpansionString1.
	ExpansionString3 *dtyp.UnicodeString `idl:"name:ExpansionString3" json:"expansion_string3"`
	// ExpansionString4: See definition for ExpansionString1.
	ExpansionString4 *dtyp.UnicodeString `idl:"name:ExpansionString4" json:"expansion_string4"`
	// ExpansionString5: See definition for ExpansionString1.
	ExpansionString5 *dtyp.UnicodeString `idl:"name:ExpansionString5" json:"expansion_string5"`
	// ExpansionString6: See definition for ExpansionString1.
	ExpansionString6 *dtyp.UnicodeString `idl:"name:ExpansionString6" json:"expansion_string6"`
	// ExpansionString7: See definition for ExpansionString1.
	ExpansionString7 *dtyp.UnicodeString `idl:"name:ExpansionString7" json:"expansion_string7"`
	// ExpansionString8: See definition for ExpansionString1.
	ExpansionString8 *dtyp.UnicodeString `idl:"name:ExpansionString8" json:"expansion_string8"`
	// ExpansionString9: See definition for ExpansionString1.
	ExpansionString9 *dtyp.UnicodeString `idl:"name:ExpansionString9" json:"expansion_string9"`
	// ExpansionString10: See definition for ExpansionString1.
	ExpansionString10 *dtyp.UnicodeString `idl:"name:ExpansionString10" json:"expansion_string10"`
}

func (o *ValidationSAMInfo4) xxx_PreparePayload(ctx context.Context) error {
	if o.GroupIDs != nil && o.GroupCount == 0 {
		o.GroupCount = uint32(len(o.GroupIDs))
	}
	if o.ExtraSIDs != nil && o.SIDCount == 0 {
		o.SIDCount = uint32(len(o.ExtraSIDs))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ValidationSAMInfo4) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.LogonTime != nil {
		if err := o.LogonTime.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&OldLargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.LogoffTime != nil {
		if err := o.LogoffTime.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&OldLargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.KickOffTime != nil {
		if err := o.KickOffTime.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&OldLargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.PasswordLastSet != nil {
		if err := o.PasswordLastSet.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&OldLargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.PasswordCanChange != nil {
		if err := o.PasswordCanChange.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&OldLargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.PasswordMustChange != nil {
		if err := o.PasswordMustChange.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&OldLargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.EffectiveName != nil {
		if err := o.EffectiveName.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.FullName != nil {
		if err := o.FullName.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.LogonScript != nil {
		if err := o.LogonScript.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.ProfilePath != nil {
		if err := o.ProfilePath.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.HomeDirectory != nil {
		if err := o.HomeDirectory.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.HomeDirectoryDrive != nil {
		if err := o.HomeDirectoryDrive.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.LogonCount); err != nil {
		return err
	}
	if err := w.WriteData(o.BadPasswordCount); err != nil {
		return err
	}
	if err := w.WriteData(o.UserID); err != nil {
		return err
	}
	if err := w.WriteData(o.PrimaryGroupID); err != nil {
		return err
	}
	if err := w.WriteData(o.GroupCount); err != nil {
		return err
	}
	if o.GroupIDs != nil || o.GroupCount > 0 {
		_ptr_GroupIds := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.GroupCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.GroupIDs {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.GroupIDs[i1] != nil {
					if err := o.GroupIDs[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&GroupMembership{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.GroupIDs); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&GroupMembership{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.GroupIDs, _ptr_GroupIds); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.UserFlags); err != nil {
		return err
	}
	if o.UserSessionKey != nil {
		if err := o.UserSessionKey.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&UserSessionKey{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.LogonServer != nil {
		if err := o.LogonServer.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.LogonDomainName != nil {
		if err := o.LogonDomainName.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.LogonDomainID != nil {
		_ptr_LogonDomainId := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.LogonDomainID != nil {
				if err := o.LogonDomainID.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&dtyp.SID{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.LogonDomainID, _ptr_LogonDomainId); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	for i1 := range o.LMKey {
		i1 := i1
		if uint64(i1) >= 8 {
			break
		}
		if err := w.WriteData(o.LMKey[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.LMKey); uint64(i1) < 8; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.UserAccountControl); err != nil {
		return err
	}
	if err := w.WriteData(o.SubAuthStatus); err != nil {
		return err
	}
	if o.LastSuccessfulILogon != nil {
		if err := o.LastSuccessfulILogon.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&OldLargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.LastFailedILogon != nil {
		if err := o.LastFailedILogon.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&OldLargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.FailedILogonCount); err != nil {
		return err
	}
	// reserved Reserved4
	for i1 := 0; uint64(i1) < 1; i1++ {
		if err := w.WriteData(uint32(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.SIDCount); err != nil {
		return err
	}
	if o.ExtraSIDs != nil || o.SIDCount > 0 {
		_ptr_ExtraSids := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.SIDCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.ExtraSIDs {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.ExtraSIDs[i1] != nil {
					if err := o.ExtraSIDs[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&SIDAndAttributes{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.ExtraSIDs); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&SIDAndAttributes{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ExtraSIDs, _ptr_ExtraSids); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.DNSLogonDomainName != nil {
		if err := o.DNSLogonDomainName.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.UPN != nil {
		if err := o.UPN.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.ExpansionString1 != nil {
		if err := o.ExpansionString1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.ExpansionString2 != nil {
		if err := o.ExpansionString2.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.ExpansionString3 != nil {
		if err := o.ExpansionString3.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.ExpansionString4 != nil {
		if err := o.ExpansionString4.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.ExpansionString5 != nil {
		if err := o.ExpansionString5.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.ExpansionString6 != nil {
		if err := o.ExpansionString6.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.ExpansionString7 != nil {
		if err := o.ExpansionString7.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.ExpansionString8 != nil {
		if err := o.ExpansionString8.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.ExpansionString9 != nil {
		if err := o.ExpansionString9.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.ExpansionString10 != nil {
		if err := o.ExpansionString10.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *ValidationSAMInfo4) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if o.LogonTime == nil {
		o.LogonTime = &OldLargeInteger{}
	}
	if err := o.LogonTime.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.LogoffTime == nil {
		o.LogoffTime = &OldLargeInteger{}
	}
	if err := o.LogoffTime.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.KickOffTime == nil {
		o.KickOffTime = &OldLargeInteger{}
	}
	if err := o.KickOffTime.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.PasswordLastSet == nil {
		o.PasswordLastSet = &OldLargeInteger{}
	}
	if err := o.PasswordLastSet.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.PasswordCanChange == nil {
		o.PasswordCanChange = &OldLargeInteger{}
	}
	if err := o.PasswordCanChange.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.PasswordMustChange == nil {
		o.PasswordMustChange = &OldLargeInteger{}
	}
	if err := o.PasswordMustChange.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.EffectiveName == nil {
		o.EffectiveName = &dtyp.UnicodeString{}
	}
	if err := o.EffectiveName.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.FullName == nil {
		o.FullName = &dtyp.UnicodeString{}
	}
	if err := o.FullName.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.LogonScript == nil {
		o.LogonScript = &dtyp.UnicodeString{}
	}
	if err := o.LogonScript.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.ProfilePath == nil {
		o.ProfilePath = &dtyp.UnicodeString{}
	}
	if err := o.ProfilePath.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.HomeDirectory == nil {
		o.HomeDirectory = &dtyp.UnicodeString{}
	}
	if err := o.HomeDirectory.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.HomeDirectoryDrive == nil {
		o.HomeDirectoryDrive = &dtyp.UnicodeString{}
	}
	if err := o.HomeDirectoryDrive.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.LogonCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.BadPasswordCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.UserID); err != nil {
		return err
	}
	if err := w.ReadData(&o.PrimaryGroupID); err != nil {
		return err
	}
	if err := w.ReadData(&o.GroupCount); err != nil {
		return err
	}
	_ptr_GroupIds := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.GroupCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.GroupCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.GroupIDs", sizeInfo[0])
		}
		o.GroupIDs = make([]*GroupMembership, sizeInfo[0])
		for i1 := range o.GroupIDs {
			i1 := i1
			if o.GroupIDs[i1] == nil {
				o.GroupIDs[i1] = &GroupMembership{}
			}
			if err := o.GroupIDs[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_GroupIds := func(ptr interface{}) { o.GroupIDs = *ptr.(*[]*GroupMembership) }
	if err := w.ReadPointer(&o.GroupIDs, _s_GroupIds, _ptr_GroupIds); err != nil {
		return err
	}
	if err := w.ReadData(&o.UserFlags); err != nil {
		return err
	}
	if o.UserSessionKey == nil {
		o.UserSessionKey = &UserSessionKey{}
	}
	if err := o.UserSessionKey.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.LogonServer == nil {
		o.LogonServer = &dtyp.UnicodeString{}
	}
	if err := o.LogonServer.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.LogonDomainName == nil {
		o.LogonDomainName = &dtyp.UnicodeString{}
	}
	if err := o.LogonDomainName.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_LogonDomainId := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.LogonDomainID == nil {
			o.LogonDomainID = &dtyp.SID{}
		}
		if err := o.LogonDomainID.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_LogonDomainId := func(ptr interface{}) { o.LogonDomainID = *ptr.(**dtyp.SID) }
	if err := w.ReadPointer(&o.LogonDomainID, _s_LogonDomainId, _ptr_LogonDomainId); err != nil {
		return err
	}
	o.LMKey = make([]byte, 8)
	for i1 := range o.LMKey {
		i1 := i1
		if err := w.ReadData(&o.LMKey[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.UserAccountControl); err != nil {
		return err
	}
	if err := w.ReadData(&o.SubAuthStatus); err != nil {
		return err
	}
	if o.LastSuccessfulILogon == nil {
		o.LastSuccessfulILogon = &OldLargeInteger{}
	}
	if err := o.LastSuccessfulILogon.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.LastFailedILogon == nil {
		o.LastFailedILogon = &OldLargeInteger{}
	}
	if err := o.LastFailedILogon.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.FailedILogonCount); err != nil {
		return err
	}
	// reserved Reserved4
	var _Reserved4 []uint32
	_Reserved4 = make([]uint32, 1)
	for i1 := range _Reserved4 {
		i1 := i1
		if err := w.ReadData(&_Reserved4[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.SIDCount); err != nil {
		return err
	}
	_ptr_ExtraSids := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.SIDCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.SIDCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.ExtraSIDs", sizeInfo[0])
		}
		o.ExtraSIDs = make([]*SIDAndAttributes, sizeInfo[0])
		for i1 := range o.ExtraSIDs {
			i1 := i1
			if o.ExtraSIDs[i1] == nil {
				o.ExtraSIDs[i1] = &SIDAndAttributes{}
			}
			if err := o.ExtraSIDs[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_ExtraSids := func(ptr interface{}) { o.ExtraSIDs = *ptr.(*[]*SIDAndAttributes) }
	if err := w.ReadPointer(&o.ExtraSIDs, _s_ExtraSids, _ptr_ExtraSids); err != nil {
		return err
	}
	if o.DNSLogonDomainName == nil {
		o.DNSLogonDomainName = &dtyp.UnicodeString{}
	}
	if err := o.DNSLogonDomainName.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.UPN == nil {
		o.UPN = &dtyp.UnicodeString{}
	}
	if err := o.UPN.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.ExpansionString1 == nil {
		o.ExpansionString1 = &dtyp.UnicodeString{}
	}
	if err := o.ExpansionString1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.ExpansionString2 == nil {
		o.ExpansionString2 = &dtyp.UnicodeString{}
	}
	if err := o.ExpansionString2.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.ExpansionString3 == nil {
		o.ExpansionString3 = &dtyp.UnicodeString{}
	}
	if err := o.ExpansionString3.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.ExpansionString4 == nil {
		o.ExpansionString4 = &dtyp.UnicodeString{}
	}
	if err := o.ExpansionString4.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.ExpansionString5 == nil {
		o.ExpansionString5 = &dtyp.UnicodeString{}
	}
	if err := o.ExpansionString5.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.ExpansionString6 == nil {
		o.ExpansionString6 = &dtyp.UnicodeString{}
	}
	if err := o.ExpansionString6.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.ExpansionString7 == nil {
		o.ExpansionString7 = &dtyp.UnicodeString{}
	}
	if err := o.ExpansionString7.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.ExpansionString8 == nil {
		o.ExpansionString8 = &dtyp.UnicodeString{}
	}
	if err := o.ExpansionString8.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.ExpansionString9 == nil {
		o.ExpansionString9 = &dtyp.UnicodeString{}
	}
	if err := o.ExpansionString9.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.ExpansionString10 == nil {
		o.ExpansionString10 = &dtyp.UnicodeString{}
	}
	if err := o.ExpansionString10.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// Validation structure represents NETLOGON_VALIDATION RPC union.
//
// The NETLOGON_VALIDATION union defines a union of all types of user validation information
// values.
type Validation struct {
	// Types that are assignable to Value
	//
	// *Validation_SAM
	// *Validation_SAM2
	// *Validation_Generic2
	// *Validation_SAM4
	Value is_Validation `json:"value"`
}

func (o *Validation) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *Validation_SAM:
		if value != nil {
			return value.ValidationSAM
		}
	case *Validation_SAM2:
		if value != nil {
			return value.ValidationSAM2
		}
	case *Validation_Generic2:
		if value != nil {
			return value.ValidationGeneric2
		}
	case *Validation_SAM4:
		if value != nil {
			return value.ValidationSAM4
		}
	}
	return nil
}

type is_Validation interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_Validation()
}

func (o *Validation) NDRSwitchValue(sw uint16) uint16 {
	if o == nil {
		return uint16(0)
	}
	switch (interface{})(o.Value).(type) {
	case *Validation_SAM:
		return uint16(2)
	case *Validation_SAM2:
		return uint16(3)
	case *Validation_Generic2:
		return uint16(5)
	case *Validation_SAM4:
		return uint16(6)
	}
	return uint16(0)
}

func (o *Validation) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint16) error {
	if err := w.WriteUnionAlign(7); err != nil {
		return err
	}
	if err := w.WriteSwitch(ndr.Enum(uint16(sw))); err != nil {
		return err
	}
	// ms_union
	if err := w.WriteAlign(7); err != nil {
		return err
	}
	switch sw {
	case uint16(2):
		_o, _ := o.Value.(*Validation_SAM)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Validation_SAM{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint16(3):
		_o, _ := o.Value.(*Validation_SAM2)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Validation_SAM2{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint16(5):
		_o, _ := o.Value.(*Validation_Generic2)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Validation_Generic2{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint16(6):
		_o, _ := o.Value.(*Validation_SAM4)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Validation_SAM4{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
	}
	return nil
}

func (o *Validation) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint16) error {
	if err := w.ReadUnionAlign(7); err != nil {
		return err
	}
	if err := w.ReadSwitch(ndr.Enum((*uint16)(&sw))); err != nil {
		return err
	}
	// ms_union
	if err := w.ReadAlign(7); err != nil {
		return err
	}
	switch sw {
	case uint16(2):
		o.Value = &Validation_SAM{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint16(3):
		o.Value = &Validation_SAM2{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint16(5):
		o.Value = &Validation_Generic2{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint16(6):
		o.Value = &Validation_SAM4{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
	}
	return nil
}

// Validation_SAM structure represents NETLOGON_VALIDATION RPC union arm.
//
// It has following labels: 2
type Validation_SAM struct {
	// ValidationSam: This field is selected when the validation information type is NetlogonValidationSamInfo.
	// The selected data type is NETLOGON_VALIDATION_SAM_INFO, as specified in section 2.2.1.4.11.
	ValidationSAM *ValidationSAMInfo `idl:"name:ValidationSam" json:"validation_sam"`
}

func (*Validation_SAM) is_Validation() {}

func (o *Validation_SAM) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ValidationSAM != nil {
		_ptr_ValidationSam := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ValidationSAM != nil {
				if err := o.ValidationSAM.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ValidationSAMInfo{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ValidationSAM, _ptr_ValidationSam); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *Validation_SAM) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ValidationSam := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ValidationSAM == nil {
			o.ValidationSAM = &ValidationSAMInfo{}
		}
		if err := o.ValidationSAM.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ValidationSam := func(ptr interface{}) { o.ValidationSAM = *ptr.(**ValidationSAMInfo) }
	if err := w.ReadPointer(&o.ValidationSAM, _s_ValidationSam, _ptr_ValidationSam); err != nil {
		return err
	}
	return nil
}

// Validation_SAM2 structure represents NETLOGON_VALIDATION RPC union arm.
//
// It has following labels: 3
type Validation_SAM2 struct {
	// ValidationSam2: This field is selected when the validation information type is NetlogonValidationSamInfo2.
	// The selected data type is NETLOGON_VALIDATION_SAM_INFO2, as specified in section
	// 2.2.1.4.12.
	ValidationSAM2 *ValidationSAMInfo2 `idl:"name:ValidationSam2" json:"validation_sam2"`
}

func (*Validation_SAM2) is_Validation() {}

func (o *Validation_SAM2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ValidationSAM2 != nil {
		_ptr_ValidationSam2 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ValidationSAM2 != nil {
				if err := o.ValidationSAM2.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ValidationSAMInfo2{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ValidationSAM2, _ptr_ValidationSam2); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *Validation_SAM2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ValidationSam2 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ValidationSAM2 == nil {
			o.ValidationSAM2 = &ValidationSAMInfo2{}
		}
		if err := o.ValidationSAM2.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ValidationSam2 := func(ptr interface{}) { o.ValidationSAM2 = *ptr.(**ValidationSAMInfo2) }
	if err := w.ReadPointer(&o.ValidationSAM2, _s_ValidationSam2, _ptr_ValidationSam2); err != nil {
		return err
	}
	return nil
}

// Validation_Generic2 structure represents NETLOGON_VALIDATION RPC union arm.
//
// It has following labels: 5
type Validation_Generic2 struct {
	// ValidationGeneric2: This field is selected when the validation information type is
	// NetlogonValidationGenericInfo2. The selected data type is NETLOGON_VALIDATION_GENERIC_INFO2,
	// as specified in section 2.2.1.4.8.
	ValidationGeneric2 *ValidationGenericInfo2 `idl:"name:ValidationGeneric2" json:"validation_generic2"`
}

func (*Validation_Generic2) is_Validation() {}

func (o *Validation_Generic2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ValidationGeneric2 != nil {
		_ptr_ValidationGeneric2 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ValidationGeneric2 != nil {
				if err := o.ValidationGeneric2.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ValidationGenericInfo2{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ValidationGeneric2, _ptr_ValidationGeneric2); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *Validation_Generic2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ValidationGeneric2 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ValidationGeneric2 == nil {
			o.ValidationGeneric2 = &ValidationGenericInfo2{}
		}
		if err := o.ValidationGeneric2.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ValidationGeneric2 := func(ptr interface{}) { o.ValidationGeneric2 = *ptr.(**ValidationGenericInfo2) }
	if err := w.ReadPointer(&o.ValidationGeneric2, _s_ValidationGeneric2, _ptr_ValidationGeneric2); err != nil {
		return err
	}
	return nil
}

// Validation_SAM4 structure represents NETLOGON_VALIDATION RPC union arm.
//
// It has following labels: 6
type Validation_SAM4 struct {
	// ValidationSam4: This field is selected when the validation information type is NetlogonValidationSamInfo4.
	// The selected data type is NETLOGON_VALIDATION_SAM_INFO4, as specified in section
	// 2.2.1.4.13.
	ValidationSAM4 *ValidationSAMInfo4 `idl:"name:ValidationSam4" json:"validation_sam4"`
}

func (*Validation_SAM4) is_Validation() {}

func (o *Validation_SAM4) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.ValidationSAM4 != nil {
		_ptr_ValidationSam4 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.ValidationSAM4 != nil {
				if err := o.ValidationSAM4.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&ValidationSAMInfo4{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.ValidationSAM4, _ptr_ValidationSam4); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *Validation_SAM4) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_ValidationSam4 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.ValidationSAM4 == nil {
			o.ValidationSAM4 = &ValidationSAMInfo4{}
		}
		if err := o.ValidationSAM4.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_ValidationSam4 := func(ptr interface{}) { o.ValidationSAM4 = *ptr.(**ValidationSAMInfo4) }
	if err := w.ReadPointer(&o.ValidationSAM4, _s_ValidationSam4, _ptr_ValidationSam4); err != nil {
		return err
	}
	return nil
}

// ControlDataInformation structure represents NETLOGON_CONTROL_DATA_INFORMATION RPC union.
//
// The NETLOGON_CONTROL_DATA_INFORMATION union is used as input to the NetrLogonControl2
// method, as specified in section 3.5.4.9.2, and the NetrLogonControl2Ex method, as
// specified in section 3.5.4.9.1. This union selects a data type, based on the FunctionCode
// parameter passed to the method. For details about FunctionCode values, see NetrLogonControl2Ex,
// section 3.5.4.9.1.
type ControlDataInformation struct {
	// Types that are assignable to Value
	//
	// *ControlDataInformation_TrustedDomainName
	// *ControlDataInformation_DebugFlag
	// *ControlDataInformation_UserName
	Value is_ControlDataInformation `json:"value"`
}

func (o *ControlDataInformation) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *ControlDataInformation_TrustedDomainName:
		if value != nil {
			return value.TrustedDomainName
		}
	case *ControlDataInformation_DebugFlag:
		if value != nil {
			return value.DebugFlag
		}
	case *ControlDataInformation_UserName:
		if value != nil {
			return value.UserName
		}
	}
	return nil
}

type is_ControlDataInformation interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_ControlDataInformation()
}

func (o *ControlDataInformation) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *ControlDataInformation_TrustedDomainName:
		switch sw {
		case uint32(5),
			uint32(6),
			uint32(9),
			uint32(10):
			return sw
		}
		return uint32(5)
	case *ControlDataInformation_DebugFlag:
		return uint32(65534)
	case *ControlDataInformation_UserName:
		return uint32(8)
	}
	return uint32(0)
}

func (o *ControlDataInformation) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(5),
		uint32(6),
		uint32(9),
		uint32(10):
		_o, _ := o.Value.(*ControlDataInformation_TrustedDomainName)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ControlDataInformation_TrustedDomainName{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(65534):
		_o, _ := o.Value.(*ControlDataInformation_DebugFlag)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ControlDataInformation_DebugFlag{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(8):
		_o, _ := o.Value.(*ControlDataInformation_UserName)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ControlDataInformation_UserName{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
	}
	return nil
}

func (o *ControlDataInformation) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(5),
		uint32(6),
		uint32(9),
		uint32(10):
		o.Value = &ControlDataInformation_TrustedDomainName{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(65534):
		o.Value = &ControlDataInformation_DebugFlag{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(8):
		o.Value = &ControlDataInformation_UserName{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
	}
	return nil
}

// ControlDataInformation_TrustedDomainName structure represents NETLOGON_CONTROL_DATA_INFORMATION RPC union arm.
//
// It has following labels: 5, 6, 9, 10
type ControlDataInformation_TrustedDomainName struct {
	// TrustedDomainName: A pointer to a null-terminated Unicode string that contains a
	// trusted domain name. Switched on the DWORD ([MS-DTYP] section 2.2.9) values 0x00000005,
	// 0x00000006, 0x00000009, and 0x0000000A. The DWORD values are equivalent to FunctionCode
	// values. For a complete list of the Netlogon function codes and their associated meanings,
	// see the NetrLogonControl2Ex method (section 3.5.4.9.1).
	TrustedDomainName string `idl:"name:TrustedDomainName;string" json:"trusted_domain_name"`
}

func (*ControlDataInformation_TrustedDomainName) is_ControlDataInformation() {}

func (o *ControlDataInformation_TrustedDomainName) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.TrustedDomainName != "" {
		_ptr_TrustedDomainName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.TrustedDomainName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.TrustedDomainName, _ptr_TrustedDomainName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ControlDataInformation_TrustedDomainName) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_TrustedDomainName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.TrustedDomainName); err != nil {
			return err
		}
		return nil
	})
	_s_TrustedDomainName := func(ptr interface{}) { o.TrustedDomainName = *ptr.(*string) }
	if err := w.ReadPointer(&o.TrustedDomainName, _s_TrustedDomainName, _ptr_TrustedDomainName); err != nil {
		return err
	}
	return nil
}

// ControlDataInformation_DebugFlag structure represents NETLOGON_CONTROL_DATA_INFORMATION RPC union arm.
//
// It has following labels: 65534
type ControlDataInformation_DebugFlag struct {
	// DebugFlag: A DWORD that contains an implementation-specific debug flag. Switched
	// on the value 0x0000FFFE.
	DebugFlag uint32 `idl:"name:DebugFlag" json:"debug_flag"`
}

func (*ControlDataInformation_DebugFlag) is_ControlDataInformation() {}

func (o *ControlDataInformation_DebugFlag) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := w.WriteData(o.DebugFlag); err != nil {
		return err
	}
	return nil
}
func (o *ControlDataInformation_DebugFlag) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadData(&o.DebugFlag); err != nil {
		return err
	}
	return nil
}

// ControlDataInformation_UserName structure represents NETLOGON_CONTROL_DATA_INFORMATION RPC union arm.
//
// It has following labels: 8
type ControlDataInformation_UserName struct {
	// UserName: A pointer to null-terminated Unicode string that contains a username. Switched
	// on the DWORD value 0x00000008.
	UserName string `idl:"name:UserName;string" json:"user_name"`
}

func (*ControlDataInformation_UserName) is_ControlDataInformation() {}

func (o *ControlDataInformation_UserName) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.UserName != "" {
		_ptr_UserName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.UserName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.UserName, _ptr_UserName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ControlDataInformation_UserName) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_UserName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.UserName); err != nil {
			return err
		}
		return nil
	})
	_s_UserName := func(ptr interface{}) { o.UserName = *ptr.(*string) }
	if err := w.ReadPointer(&o.UserName, _s_UserName, _ptr_UserName); err != nil {
		return err
	}
	return nil
}

// Info1 structure represents NETLOGON_INFO_1 RPC structure.
//
// The NETLOGON_INFO_1 structure defines information returned as part of an administrative
// query, as detailed in the description of the NetrLogonControl2Ex method in section
// 3.5.4.9.1. This structure is used to convey information about the state and properties
// of the secure channel to a DC in the primary domain of the queried server. Additionally,
// this structure MAY<60> contain information about the state of the database synchronization.
type Info1 struct {
	// netlog1_flags: A set of bit flags that are defined in the following table. A flag
	// SHOULD<61> be TRUE (or set) if its value is equal to 1. The value is constructed
	// from zero or more bit flags from the following table.
	//
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
	//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | G | F | E | D | C | B | A |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//
	//
	//	+-------+----------------------------------------------------------------------------------+
	//	|       |                                                                                  |
	//	| VALUE |                                   DESCRIPTION                                    |
	//	|       |                                                                                  |
	//	+-------+----------------------------------------------------------------------------------+
	//	+-------+----------------------------------------------------------------------------------+
	//	| A     | One of the databases is out-of-date, and replication is needed.                  |
	//	+-------+----------------------------------------------------------------------------------+
	//	| B     | At least one of the databases is currently being replicated.                     |
	//	+-------+----------------------------------------------------------------------------------+
	//	| C     | At least one of the databases requires a full synchronization update.            |
	//	+-------+----------------------------------------------------------------------------------+
	//	| D     | At least one database record requires an update.                                 |
	//	+-------+----------------------------------------------------------------------------------+
	//	| E     | The DC used on the secure channel is reachable over TCP/IP. If this flag is not  |
	//	|       | set, then the DC does not have a known IP address.                               |
	//	+-------+----------------------------------------------------------------------------------+
	//	| F     | The DC used on the secure channel runs W32Time.                                  |
	//	+-------+----------------------------------------------------------------------------------+
	//	| G     | The last update of one of the DNS records on the DC failed.                      |
	//	+-------+----------------------------------------------------------------------------------+
	//
	// All other bits MUST be set to zero and MUST be ignored on receipt.
	Flags uint32 `idl:"name:netlog1_flags" json:"flags"`
	// netlog1_pdc_connection_status: The integer value that indicates the connection status,
	// as described in Setting ConnectionStatus (section 3.4.5.3.1), of the secure channel
	// to a DC in the primary domain of the queried server.
	PDCConnectionStatus uint32 `idl:"name:netlog1_pdc_connection_status" json:"pdc_connection_status"`
}

func (o *Info1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *Info1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	if err := w.WriteData(o.PDCConnectionStatus); err != nil {
		return err
	}
	return nil
}
func (o *Info1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	if err := w.ReadData(&o.PDCConnectionStatus); err != nil {
		return err
	}
	return nil
}

// Info2 structure represents NETLOGON_INFO_2 RPC structure.
//
// The NETLOGON_INFO_2 structure defines information returned as part of an administrative
// query of the status of the Netlogon server, as detailed in the description of the
// NetrLogonControl2Ex method in section 3.5.4.9.1. This structure is used to convey
// information about the status and properties of the secure channel to a DC in the
// primary or directly trusted domain specified by the caller of NetrLogonControl2Ex
// method.
type Info2 struct {
	// netlog2_flags: A set of bit flags describing the following control query responses
	// from the DC. A flag is TRUE (or set) if its value is equal to 1. The value is constructed
	// from zero or more bit flags from the following table.
	//
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
	//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | C | 0 | B | A | 0 | 0 | 0 | 0 |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//
	// Where the flags SHOULD<62> be defined as shown in the following table.
	//
	//	+-------+----------------------------------------------------------------------------------+
	//	|       |                                                                                  |
	//	| VALUE |                                   DESCRIPTION                                    |
	//	|       |                                                                                  |
	//	+-------+----------------------------------------------------------------------------------+
	//	+-------+----------------------------------------------------------------------------------+
	//	| A     | The DC used on the secure channel has an IP address (either IPv4 or IPv6).       |
	//	+-------+----------------------------------------------------------------------------------+
	//	| B     | The DC used on the secure channel runs W32Time.                                  |
	//	+-------+----------------------------------------------------------------------------------+
	//	| C     | Signifies that the trust verification status was returned in the                 |
	//	|       | netlog2_pdc_connection_status field.                                             |
	//	+-------+----------------------------------------------------------------------------------+
	Flags uint32 `idl:"name:netlog2_flags" json:"flags"`
	// netlog2_pdc_connection_status: Unless the C bit is set in netlog2_flags field, this
	// field indicates the connection status, as described in Setting ConnectionStatus (section
	// 3.4.5.3.1), of the secure channel to a DC in the primary domain of the queried server.
	// If the C bit is set in netlog2_flags field, this field indicates the connection status
	// of verifying the secure channel to the DC in the specified domain specified by the
	// caller of NetrLogonControl2Ex method (section 3.5.4.9.1).
	PDCConnectionStatus uint32 `idl:"name:netlog2_pdc_connection_status" json:"pdc_connection_status"`
	// netlog2_trusted_dc_name: A pointer to a null-terminated Unicode string that contains
	// the DNS or NetBIOS name of the DC used on the secure channel for the specified domain.
	// The name is the FQDN if the DC was discovered using the discovery mechanism based
	// on the DNS query and LDAP ping ([MS-ADTS] section 6.3.3). The name is the NetBIOS
	// name if the DC was discovered using the mailslot-based mechanism ([MS-ADTS] section
	// 6.3.5).
	TrustedDCName string `idl:"name:netlog2_trusted_dc_name;string" json:"trusted_dc_name"`
	// netlog2_tc_connection_status: An integer value that indicates the connection status,
	// described in Setting ConnectionStatus (section 3.4.5.3.1), of the secure channel
	// to the DC in the specified domain.
	TCConnectionStatus uint32 `idl:"name:netlog2_tc_connection_status" json:"tc_connection_status"`
}

func (o *Info2) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *Info2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	if err := w.WriteData(o.PDCConnectionStatus); err != nil {
		return err
	}
	if o.TrustedDCName != "" {
		_ptr_netlog2_trusted_dc_name := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.TrustedDCName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.TrustedDCName, _ptr_netlog2_trusted_dc_name); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.TCConnectionStatus); err != nil {
		return err
	}
	return nil
}
func (o *Info2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	if err := w.ReadData(&o.PDCConnectionStatus); err != nil {
		return err
	}
	_ptr_netlog2_trusted_dc_name := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.TrustedDCName); err != nil {
			return err
		}
		return nil
	})
	_s_netlog2_trusted_dc_name := func(ptr interface{}) { o.TrustedDCName = *ptr.(*string) }
	if err := w.ReadPointer(&o.TrustedDCName, _s_netlog2_trusted_dc_name, _ptr_netlog2_trusted_dc_name); err != nil {
		return err
	}
	if err := w.ReadData(&o.TCConnectionStatus); err != nil {
		return err
	}
	return nil
}

// Info3 structure represents NETLOGON_INFO_3 RPC structure.
//
// The NETLOGON_INFO_3 structure defines information returned as part of an administrative
// query of the status of the Netlogon server, as detailed in the description of the
// NetrLogonControl2Ex method in section 3.5.4.9.1. This structure is used to return
// the number of NTLM logons attempted on the queried server since the last restart.
type Info3 struct {
	// netlog3_flags: MUST be set to zero and MUST be ignored on receipt.
	Flags uint32 `idl:"name:netlog3_flags" json:"flags"`
	// netlog3_logon_attempts: The number of NTLM logon attempts made on the server since
	// the last restart.
	LogonAttempts uint32 `idl:"name:netlog3_logon_attempts" json:"logon_attempts"`
	// netlog3_reserved1: MUST be set to zero and MUST be ignored on receipt.
	_ uint32 `idl:"name:netlog3_reserved1"`
	// netlog3_reserved2: MUST be set to zero and MUST be ignored on receipt.
	_ uint32 `idl:"name:netlog3_reserved2"`
	// netlog3_reserved3: MUST be set to zero and MUST be ignored on receipt.
	_ uint32 `idl:"name:netlog3_reserved3"`
	// netlog3_reserved4: MUST be set to zero and MUST be ignored on receipt.
	_ uint32 `idl:"name:netlog3_reserved4"`
	// netlog3_reserved5: MUST be set to zero and MUST be ignored on receipt.
	_ uint32 `idl:"name:netlog3_reserved5"`
}

func (o *Info3) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *Info3) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	if err := w.WriteData(o.LogonAttempts); err != nil {
		return err
	}
	// reserved netlog3_reserved1
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved netlog3_reserved2
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved netlog3_reserved3
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved netlog3_reserved4
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved netlog3_reserved5
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	return nil
}
func (o *Info3) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	if err := w.ReadData(&o.LogonAttempts); err != nil {
		return err
	}
	// reserved netlog3_reserved1
	var _netlog3_reserved1 uint32
	if err := w.ReadData(&_netlog3_reserved1); err != nil {
		return err
	}
	// reserved netlog3_reserved2
	var _netlog3_reserved2 uint32
	if err := w.ReadData(&_netlog3_reserved2); err != nil {
		return err
	}
	// reserved netlog3_reserved3
	var _netlog3_reserved3 uint32
	if err := w.ReadData(&_netlog3_reserved3); err != nil {
		return err
	}
	// reserved netlog3_reserved4
	var _netlog3_reserved4 uint32
	if err := w.ReadData(&_netlog3_reserved4); err != nil {
		return err
	}
	// reserved netlog3_reserved5
	var _netlog3_reserved5 uint32
	if err := w.ReadData(&_netlog3_reserved5); err != nil {
		return err
	}
	return nil
}

// Info4 structure represents NETLOGON_INFO_4 RPC structure.
//
// The NETLOGON_INFO_4 structure defines information that is returned as part of an
// administrative query of the status of the Netlogon server, as detailed in the description
// of the NetrLogonControl2Ex method in section 3.5.4.9.1. This structure is used to
// convey information about the status and properties of the secure channel to a DC
// in the primary or directly trusted domain containing the user account specified by
// the caller of the NetrLogonControl2Ex method.
type Info4 struct {
	// netlog4_trusted_dc_name: A pointer to a null-terminated Unicode string that contains
	// the DNS or NetBIOS name of a DC that is used on the secure channel for the primary
	// or directly trusted domain containing the specified user account. The name is the
	// FQDN if the DC was discovered using the discovery mechanism based on the DNS query
	// and LDAP ping ([MS-ADTS] section 6.3.3). The name is the NetBIOS name if the DC was
	// discovered using the mailslot-based mechanism ([MS-ADTS] section 6.3.5).
	TrustedDCName string `idl:"name:netlog4_trusted_dc_name;string" json:"trusted_dc_name"`
	// netlog4_trusted_domain_name: A pointer to a null-terminated Unicode string that contains
	// the NetBIOS name of the primary or directly trusted domain containing the specified
	// user account.
	TrustedDomainName string `idl:"name:netlog4_trusted_domain_name;string" json:"trusted_domain_name"`
}

func (o *Info4) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *Info4) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(6); err != nil {
		return err
	}
	if o.TrustedDCName != "" {
		_ptr_netlog4_trusted_dc_name := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.TrustedDCName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.TrustedDCName, _ptr_netlog4_trusted_dc_name); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.TrustedDomainName != "" {
		_ptr_netlog4_trusted_domain_name := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.TrustedDomainName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.TrustedDomainName, _ptr_netlog4_trusted_domain_name); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *Info4) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(6); err != nil {
		return err
	}
	_ptr_netlog4_trusted_dc_name := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.TrustedDCName); err != nil {
			return err
		}
		return nil
	})
	_s_netlog4_trusted_dc_name := func(ptr interface{}) { o.TrustedDCName = *ptr.(*string) }
	if err := w.ReadPointer(&o.TrustedDCName, _s_netlog4_trusted_dc_name, _ptr_netlog4_trusted_dc_name); err != nil {
		return err
	}
	_ptr_netlog4_trusted_domain_name := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.TrustedDomainName); err != nil {
			return err
		}
		return nil
	})
	_s_netlog4_trusted_domain_name := func(ptr interface{}) { o.TrustedDomainName = *ptr.(*string) }
	if err := w.ReadPointer(&o.TrustedDomainName, _s_netlog4_trusted_domain_name, _ptr_netlog4_trusted_domain_name); err != nil {
		return err
	}
	return nil
}

// ControlQueryInformation structure represents NETLOGON_CONTROL_QUERY_INFORMATION RPC union.
//
// The NETLOGON_CONTROL_QUERY_INFORMATION union selects an appropriate NETLOGON_INFO
// data type, based on the value of the QueryLevel parameter to the NetrLogonControl2Ex
// method described in section 3.5.4.9.1.
type ControlQueryInformation struct {
	// Types that are assignable to Value
	//
	// *ControlQueryInformation_Info1
	// *ControlQueryInformation_Info2
	// *ControlQueryInformation_Info3
	// *ControlQueryInformation_Info4
	Value is_ControlQueryInformation `json:"value"`
}

func (o *ControlQueryInformation) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *ControlQueryInformation_Info1:
		if value != nil {
			return value.Info1
		}
	case *ControlQueryInformation_Info2:
		if value != nil {
			return value.Info2
		}
	case *ControlQueryInformation_Info3:
		if value != nil {
			return value.Info3
		}
	case *ControlQueryInformation_Info4:
		if value != nil {
			return value.Info4
		}
	}
	return nil
}

type is_ControlQueryInformation interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_ControlQueryInformation()
}

func (o *ControlQueryInformation) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *ControlQueryInformation_Info1:
		return uint32(1)
	case *ControlQueryInformation_Info2:
		return uint32(2)
	case *ControlQueryInformation_Info3:
		return uint32(3)
	case *ControlQueryInformation_Info4:
		return uint32(4)
	}
	return uint32(0)
}

func (o *ControlQueryInformation) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*ControlQueryInformation_Info1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ControlQueryInformation_Info1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(2):
		_o, _ := o.Value.(*ControlQueryInformation_Info2)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ControlQueryInformation_Info2{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(3):
		_o, _ := o.Value.(*ControlQueryInformation_Info3)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ControlQueryInformation_Info3{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(4):
		_o, _ := o.Value.(*ControlQueryInformation_Info4)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ControlQueryInformation_Info4{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
	}
	return nil
}

func (o *ControlQueryInformation) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &ControlQueryInformation_Info1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(2):
		o.Value = &ControlQueryInformation_Info2{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(3):
		o.Value = &ControlQueryInformation_Info3{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(4):
		o.Value = &ControlQueryInformation_Info4{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
	}
	return nil
}

// ControlQueryInformation_Info1 structure represents NETLOGON_CONTROL_QUERY_INFORMATION RPC union arm.
//
// It has following labels: 1
type ControlQueryInformation_Info1 struct {
	// NetlogonInfo1: This field is selected when the switched DWORD ([MS-DTYP] section
	// 2.2.9) value is 1. For more details about NETLOGON_INFO_1 structure, see section
	// 2.2.1.7.2.
	Info1 *Info1 `idl:"name:NetlogonInfo1" json:"info1"`
}

func (*ControlQueryInformation_Info1) is_ControlQueryInformation() {}

func (o *ControlQueryInformation_Info1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Info1 != nil {
		_ptr_NetlogonInfo1 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Info1 != nil {
				if err := o.Info1.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&Info1{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Info1, _ptr_NetlogonInfo1); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ControlQueryInformation_Info1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_NetlogonInfo1 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Info1 == nil {
			o.Info1 = &Info1{}
		}
		if err := o.Info1.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_NetlogonInfo1 := func(ptr interface{}) { o.Info1 = *ptr.(**Info1) }
	if err := w.ReadPointer(&o.Info1, _s_NetlogonInfo1, _ptr_NetlogonInfo1); err != nil {
		return err
	}
	return nil
}

// ControlQueryInformation_Info2 structure represents NETLOGON_CONTROL_QUERY_INFORMATION RPC union arm.
//
// It has following labels: 2
type ControlQueryInformation_Info2 struct {
	// NetlogonInfo2: This field is selected when the switched DWORD value is 2. For more
	// details about NETLOGON_INFO_2 structure, see section 2.2.1.7.3.
	Info2 *Info2 `idl:"name:NetlogonInfo2" json:"info2"`
}

func (*ControlQueryInformation_Info2) is_ControlQueryInformation() {}

func (o *ControlQueryInformation_Info2) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Info2 != nil {
		_ptr_NetlogonInfo2 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Info2 != nil {
				if err := o.Info2.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&Info2{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Info2, _ptr_NetlogonInfo2); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ControlQueryInformation_Info2) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_NetlogonInfo2 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Info2 == nil {
			o.Info2 = &Info2{}
		}
		if err := o.Info2.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_NetlogonInfo2 := func(ptr interface{}) { o.Info2 = *ptr.(**Info2) }
	if err := w.ReadPointer(&o.Info2, _s_NetlogonInfo2, _ptr_NetlogonInfo2); err != nil {
		return err
	}
	return nil
}

// ControlQueryInformation_Info3 structure represents NETLOGON_CONTROL_QUERY_INFORMATION RPC union arm.
//
// It has following labels: 3
type ControlQueryInformation_Info3 struct {
	// NetlogonInfo3: This field is selected when the switched DWORD value is 3. For more
	// details about NETLOGON_INFO_3 structure, see section 2.2.1.7.4.
	Info3 *Info3 `idl:"name:NetlogonInfo3" json:"info3"`
}

func (*ControlQueryInformation_Info3) is_ControlQueryInformation() {}

func (o *ControlQueryInformation_Info3) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Info3 != nil {
		_ptr_NetlogonInfo3 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Info3 != nil {
				if err := o.Info3.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&Info3{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Info3, _ptr_NetlogonInfo3); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ControlQueryInformation_Info3) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_NetlogonInfo3 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Info3 == nil {
			o.Info3 = &Info3{}
		}
		if err := o.Info3.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_NetlogonInfo3 := func(ptr interface{}) { o.Info3 = *ptr.(**Info3) }
	if err := w.ReadPointer(&o.Info3, _s_NetlogonInfo3, _ptr_NetlogonInfo3); err != nil {
		return err
	}
	return nil
}

// ControlQueryInformation_Info4 structure represents NETLOGON_CONTROL_QUERY_INFORMATION RPC union arm.
//
// It has following labels: 4
type ControlQueryInformation_Info4 struct {
	// NetlogonInfo4: This field is selected when the switched DWORD value is 4. For more
	// details about NETLOGON_INFO_4 structure, see section 2.2.1.7.5.
	Info4 *Info4 `idl:"name:NetlogonInfo4" json:"info4"`
}

func (*ControlQueryInformation_Info4) is_ControlQueryInformation() {}

func (o *ControlQueryInformation_Info4) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Info4 != nil {
		_ptr_NetlogonInfo4 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.Info4 != nil {
				if err := o.Info4.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&Info4{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Info4, _ptr_NetlogonInfo4); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ControlQueryInformation_Info4) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_NetlogonInfo4 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.Info4 == nil {
			o.Info4 = &Info4{}
		}
		if err := o.Info4.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_NetlogonInfo4 := func(ptr interface{}) { o.Info4 = *ptr.(**Info4) }
	if err := w.ReadPointer(&o.Info4, _s_NetlogonInfo4, _ptr_NetlogonInfo4); err != nil {
		return err
	}
	return nil
}

// SyncState type represents SYNC_STATE RPC enumeration.
//
// The SYNC_STATE enumeration tracks the progress of synchronization of the database
// between BDCs and PDCs. Synchronization is initiated by the client calling NetrDatabaseSync2
// (section 3.5.4.6.2). All references to SyncContext in the following synchronization
// state descriptions refer to the SyncContext parameter in that method.
type SyncState uint16

var (
	// NormalState: A state that MUST be used unless the current synchronization is the
	// restart of a full synchronization.
	SyncStateNormalState SyncState = 0
	// DomainState: The SyncContext parameter is the domain RID with which to continue.
	SyncStateDomainState SyncState = 1
	// GroupState: The SyncContext parameter is the global group RID with which to continue.
	SyncStateGroupState SyncState = 2
	// UasBuiltInGroupState: Not used.
	SyncStateUASBuiltInGroupState SyncState = 3
	// UserState: The SyncContext parameter is the user RID with which to continue.
	SyncStateUserState SyncState = 4
	// GroupMemberState: The SyncContext parameter is the global group RID with which to
	// continue.
	SyncStateGroupMemberState SyncState = 5
	// AliasState: The SyncContext parameter MUST have a value of 0, indicating synchronization
	// restarts at the first database alias and that AddOrChangeAlias (see NETLOGON_DELTA_TYPE
	// enumeration section 2.2.1.5.28) was the last account change being performed prior
	// to the restart.
	SyncStateAliasState SyncState = 6
	// AliasMemberState: The SyncContext parameter MUST have a value of 0, indicating synchronization
	// restarts at the first database alias and that ChangeAliasMembership (NETLOGON_DELTA_TYPE
	// enumeration section 2.2.1.5.28) was the last account change being performed prior
	// to the restart.
	SyncStateAliasMemberState SyncState = 7
	// SamDoneState: The database has finished synchronization.
	SyncStateSAMDoneState SyncState = 8
)

func (o SyncState) String() string {
	switch o {
	case SyncStateNormalState:
		return "SyncStateNormalState"
	case SyncStateDomainState:
		return "SyncStateDomainState"
	case SyncStateGroupState:
		return "SyncStateGroupState"
	case SyncStateUASBuiltInGroupState:
		return "SyncStateUASBuiltInGroupState"
	case SyncStateUserState:
		return "SyncStateUserState"
	case SyncStateGroupMemberState:
		return "SyncStateGroupMemberState"
	case SyncStateAliasState:
		return "SyncStateAliasState"
	case SyncStateAliasMemberState:
		return "SyncStateAliasMemberState"
	case SyncStateSAMDoneState:
		return "SyncStateSAMDoneState"
	}
	return "Invalid"
}

// DomainNameBuffer structure represents DOMAIN_NAME_BUFFER RPC structure.
//
// The DOMAIN_NAME_BUFFER structure defines information returned by the NetrEnumerateTrustedDomains
// method, as specified in section 3.5.4.7.3. The structure is used to describe a set
// of trusted domain names.
type DomainNameBuffer struct {
	// DomainNameByteCount: The size, in bytes, of the buffer pointed to by the DomainNames
	// field, including all UTF-16 null characters.
	DomainNameByteCount uint32 `idl:"name:DomainNameByteCount" json:"domain_name_byte_count"`
	// DomainNames: The Unicode string buffer that contains the list of trusted domains.
	// The list format is a UTF-16 string composed of one or more substrings. Each substring
	// is separated from adjacent substrings by the UTF-16 null character, 0x0000. After
	// the final substring, the string is terminated by two UTF-16 null characters.
	//
	// For example, if there are three trusted domains, DOMAIN1, DOMAIN2, and DOMAIN3, the
	// DomainNames string buffer would have the following form:
	//
	// DOMAIN1<null>DOMAIN2<null>DOMAIN3<null><null>
	DomainNames []byte `idl:"name:DomainNames;size_is:(DomainNameByteCount);pointer:unique" json:"domain_names"`
}

func (o *DomainNameBuffer) xxx_PreparePayload(ctx context.Context) error {
	if o.DomainNames != nil && o.DomainNameByteCount == 0 {
		o.DomainNameByteCount = uint32(len(o.DomainNames))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *DomainNameBuffer) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.DomainNameByteCount); err != nil {
		return err
	}
	if o.DomainNames != nil || o.DomainNameByteCount > 0 {
		_ptr_DomainNames := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.DomainNameByteCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.DomainNames {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.DomainNames[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.DomainNames); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.DomainNames, _ptr_DomainNames); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *DomainNameBuffer) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.DomainNameByteCount); err != nil {
		return err
	}
	_ptr_DomainNames := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.DomainNameByteCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.DomainNameByteCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.DomainNames", sizeInfo[0])
		}
		o.DomainNames = make([]byte, sizeInfo[0])
		for i1 := range o.DomainNames {
			i1 := i1
			if err := w.ReadData(&o.DomainNames[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_DomainNames := func(ptr interface{}) { o.DomainNames = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.DomainNames, _s_DomainNames, _ptr_DomainNames); err != nil {
		return err
	}
	return nil
}

// LSAPolicyInfo structure represents NETLOGON_LSA_POLICY_INFO RPC structure.
//
// The NETLOGON_LSA_POLICY_INFO structure defines Local Security Authority (LSA) policy
// information as an unsigned character buffer. For details, see [LSAPOLICY] and [MS-LSAD].
type LSAPolicyInfo struct {
	// LsaPolicySize: This field is not used and is set to zero.
	LSAPolicySize uint32 `idl:"name:LsaPolicySize" json:"lsa_policy_size"`
	// LsaPolicy: This field is not used and is initialized to NULL.
	LSAPolicy []byte `idl:"name:LsaPolicy;size_is:(LsaPolicySize)" json:"lsa_policy"`
}

func (o *LSAPolicyInfo) xxx_PreparePayload(ctx context.Context) error {
	if o.LSAPolicy != nil && o.LSAPolicySize == 0 {
		o.LSAPolicySize = uint32(len(o.LSAPolicy))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *LSAPolicyInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.LSAPolicySize); err != nil {
		return err
	}
	if o.LSAPolicy != nil || o.LSAPolicySize > 0 {
		_ptr_LsaPolicy := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.LSAPolicySize)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.LSAPolicy {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.LSAPolicy[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.LSAPolicy); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.LSAPolicy, _ptr_LsaPolicy); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *LSAPolicyInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.LSAPolicySize); err != nil {
		return err
	}
	_ptr_LsaPolicy := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.LSAPolicySize > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.LSAPolicySize)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.LSAPolicy", sizeInfo[0])
		}
		o.LSAPolicy = make([]byte, sizeInfo[0])
		for i1 := range o.LSAPolicy {
			i1 := i1
			if err := w.ReadData(&o.LSAPolicy[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_LsaPolicy := func(ptr interface{}) { o.LSAPolicy = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.LSAPolicy, _s_LsaPolicy, _ptr_LsaPolicy); err != nil {
		return err
	}
	return nil
}

// OneDomainInfo structure represents NETLOGON_ONE_DOMAIN_INFO RPC structure.
//
// The NETLOGON_ONE_DOMAIN_INFO structure SHOULD<27> define information about a single
// domain. It is in turn contained in the NETLOGON_DOMAIN_INFO structure, as specified
// in section 2.2.1.3.11. The NETLOGON_DOMAIN_INFO structure describes domain relationships
// and is generated as output from the NetrLogonGetDomainInfo method, as specified in
// section 3.5.4.4.9.
type OneDomainInfo struct {
	// DomainName: A null-terminated Unicode string that contains the NetBIOS name of the
	// domain being described. This field MUST NOT be an empty string.
	DomainName *dtyp.UnicodeString `idl:"name:DomainName" json:"domain_name"`
	// DnsDomainName: A null-terminated Unicode string that contains the DNS domain name
	// for this domain. This field MUST NOT be an empty string.
	DNSDomainName *dtyp.UnicodeString `idl:"name:DnsDomainName" json:"dns_domain_name"`
	// DnsForestName: A null-terminated Unicode string that contains the DNS forest name
	// for this domain.
	DNSForestName *dtyp.UnicodeString `idl:"name:DnsForestName" json:"dns_forest_name"`
	// DomainGuid: A globally unique 128-bit identifier for this domain.
	DomainGUID *dtyp.GUID `idl:"name:DomainGuid" json:"domain_guid"`
	// DomainSid: The security identifier (SID), as specified in [MS-DTYP] section 2.4.2.3
	// for this domain.
	DomainSID *dtyp.SID `idl:"name:DomainSid" json:"domain_sid"`
	// TrustExtension: An RPC_UNICODE_STRING structure, as specified in [MS-DTYP] section
	// 2.3.10, which does not point to a Unicode string, but in fact points to a buffer
	// of size 16, in bytes, in the following format.
	//
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
	//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| Flags                                                                                                                         |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| ParentIndex                                                                                                                   |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| TrustType                                                                                                                     |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| TrustAttributes                                                                                                               |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	TrustExtension *dtyp.UnicodeString `idl:"name:TrustExtension" json:"trust_extension"`
	// DummyString2: A STRING structure, defined in section 2.2.1.1.2, that MUST contain
	// 0 for the Length field, 0 for the MaximumLength field, and NULL for the Buffer field.
	// It is ignored upon receipt. The Netlogon usage of dummy fields is described in section
	// 1.3.8.1.2.
	_ *dtyp.UnicodeString `idl:"name:DummyString2"`
	// DummyString3: See definition for DummyString2.
	_ *dtyp.UnicodeString `idl:"name:DummyString3"`
	// DummyString4: See definition for DummyString2.
	_ *dtyp.UnicodeString `idl:"name:DummyString4"`
	// DummyLong1: MUST be set to zero and MUST be ignored on receipt. The Netlogon usage
	// of dummy fields is described in section 1.3.8.1.2.
	_ uint32 `idl:"name:DummyLong1"`
	// DummyLong2: See definition for DummyLong1.
	_ uint32 `idl:"name:DummyLong2"`
	// DummyLong3: See definition for DummyLong1.
	_ uint32 `idl:"name:DummyLong3"`
	// DummyLong4: See definition for DummyLong1.
	_ uint32 `idl:"name:DummyLong4"`
}

func (o *OneDomainInfo) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *OneDomainInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.DomainName != nil {
		if err := o.DomainName.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.DNSDomainName != nil {
		if err := o.DNSDomainName.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.DNSForestName != nil {
		if err := o.DNSForestName.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.DomainGUID != nil {
		if err := o.DomainGUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.DomainSID != nil {
		_ptr_DomainSid := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.DomainSID != nil {
				if err := o.DomainSID.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&dtyp.SID{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.DomainSID, _ptr_DomainSid); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.TrustExtension != nil {
		if err := o.TrustExtension.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// reserved DummyString2
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString3
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString4
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyLong1
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong2
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong3
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong4
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	return nil
}
func (o *OneDomainInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if o.DomainName == nil {
		o.DomainName = &dtyp.UnicodeString{}
	}
	if err := o.DomainName.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.DNSDomainName == nil {
		o.DNSDomainName = &dtyp.UnicodeString{}
	}
	if err := o.DNSDomainName.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.DNSForestName == nil {
		o.DNSForestName = &dtyp.UnicodeString{}
	}
	if err := o.DNSForestName.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.DomainGUID == nil {
		o.DomainGUID = &dtyp.GUID{}
	}
	if err := o.DomainGUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_DomainSid := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.DomainSID == nil {
			o.DomainSID = &dtyp.SID{}
		}
		if err := o.DomainSID.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_DomainSid := func(ptr interface{}) { o.DomainSID = *ptr.(**dtyp.SID) }
	if err := w.ReadPointer(&o.DomainSID, _s_DomainSid, _ptr_DomainSid); err != nil {
		return err
	}
	if o.TrustExtension == nil {
		o.TrustExtension = &dtyp.UnicodeString{}
	}
	if err := o.TrustExtension.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString2
	var _DummyString2 *dtyp.UnicodeString
	if _DummyString2 == nil {
		_DummyString2 = &dtyp.UnicodeString{}
	}
	if err := _DummyString2.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString3
	var _DummyString3 *dtyp.UnicodeString
	if _DummyString3 == nil {
		_DummyString3 = &dtyp.UnicodeString{}
	}
	if err := _DummyString3.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString4
	var _DummyString4 *dtyp.UnicodeString
	if _DummyString4 == nil {
		_DummyString4 = &dtyp.UnicodeString{}
	}
	if err := _DummyString4.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyLong1
	var _DummyLong1 uint32
	if err := w.ReadData(&_DummyLong1); err != nil {
		return err
	}
	// reserved DummyLong2
	var _DummyLong2 uint32
	if err := w.ReadData(&_DummyLong2); err != nil {
		return err
	}
	// reserved DummyLong3
	var _DummyLong3 uint32
	if err := w.ReadData(&_DummyLong3); err != nil {
		return err
	}
	// reserved DummyLong4
	var _DummyLong4 uint32
	if err := w.ReadData(&_DummyLong4); err != nil {
		return err
	}
	return nil
}

// DomainInfo structure represents NETLOGON_DOMAIN_INFO RPC structure.
//
// The NETLOGON_DOMAIN_INFO structure SHOULD<28> define information returned as output
// from the NetrLogonGetDomainInfo method, as specified in section 3.5.4.4.9. It contains
// information about a domain, including naming information and a list of trusted domains.
type DomainInfo struct {
	// PrimaryDomain: A NETLOGON_ONE_DOMAIN_INFO structure, as specified in section 2.2.1.3.10,
	// that contains information about the domain of which the server is a member.
	PrimaryDomain *OneDomainInfo `idl:"name:PrimaryDomain" json:"primary_domain"`
	// TrustedDomainCount: The number of trusted domains listed in TrustedDomains.
	TrustedDomainCount uint32 `idl:"name:TrustedDomainCount" json:"trusted_domain_count"`
	// TrustedDomains: A pointer to an array of NETLOGON_ONE_DOMAIN_INFO structures, as
	// specified in section 2.2.1.3.10, which contain information about domains with which
	// the current domain has a trust relationship.
	TrustedDomains []*OneDomainInfo `idl:"name:TrustedDomains;size_is:(TrustedDomainCount)" json:"trusted_domains"`
	// LsaPolicy: A NETLOGON_LSA_POLICY_INFO data structure that contains the LSA policy
	// for this domain. This field is not used. For details, see section 2.2.1.3.5.
	LSAPolicy *LSAPolicyInfo `idl:"name:LsaPolicy" json:"lsa_policy"`
	// DnsHostNameInDs: A null-terminated Unicode string that contains the Active Directory
	// DNS host name for the client.
	DNSHostNameInDS *dtyp.UnicodeString `idl:"name:DnsHostNameInDs" json:"dns_host_name_in_ds"`
	// DummyString2: A STRING structure, defined in section 2.2.1.1.2, that MUST contain
	// 0 for the Length field, 0 for the MaximumLength field, and NULL for the Buffer field.
	// It is ignored upon receipt. The Netlogon usage of dummy fields is described in section
	// 1.3.8.1.2.
	_ *dtyp.UnicodeString `idl:"name:DummyString2"`
	// DummyString3: See definition for DummyString2.
	_ *dtyp.UnicodeString `idl:"name:DummyString3"`
	// DummyString4: See definition for DummyString2.
	_ *dtyp.UnicodeString `idl:"name:DummyString4"`
	// WorkstationFlags: A set of bit flags that specify workstation behavior. A flag is
	// TRUE (or set) if its value is equal to 1. The value is constructed from zero or more
	// bit flags from the following table.
	//
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
	//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | B | A |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//
	// Where the bits are defined as:
	//
	//	+-------+----------------------------------------------------------------------------------+
	//	|       |                                                                                  |
	//	| VALUE |                                   DESCRIPTION                                    |
	//	|       |                                                                                  |
	//	+-------+----------------------------------------------------------------------------------+
	//	+-------+----------------------------------------------------------------------------------+
	//	| A     | Client receives inbound trusts.                                                  |
	//	+-------+----------------------------------------------------------------------------------+
	//	| B     | Client handles the update of the service principal name (SPN). See [SPNNAMES]    |
	//	|       | for details.                                                                     |
	//	+-------+----------------------------------------------------------------------------------+
	WorkstationFlags uint32 `idl:"name:WorkstationFlags" json:"workstation_flags"`
	// SupportedEncTypes: A set of bit flags that SHOULD<29> specify the encryption types
	// supported, as specified in [MS-LSAD] section 2.2.7.18. See [MS-LSAD] for a specification
	// of these bit values and their allowed combinations.
	SupportedEncTypes uint32 `idl:"name:SupportedEncTypes" json:"supported_enc_types"`
	// DummyLong3: MUST be set to zero and MUST be ignored on receipt. The Netlogon usage
	// of dummy fields is described in section 1.3.8.1.2.
	_ uint32 `idl:"name:DummyLong3"`
	// DummyLong4: See definition of DummyLong3.
	_ uint32 `idl:"name:DummyLong4"`
}

func (o *DomainInfo) xxx_PreparePayload(ctx context.Context) error {
	if o.TrustedDomains != nil && o.TrustedDomainCount == 0 {
		o.TrustedDomainCount = uint32(len(o.TrustedDomains))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *DomainInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.PrimaryDomain != nil {
		if err := o.PrimaryDomain.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&OneDomainInfo{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.TrustedDomainCount); err != nil {
		return err
	}
	if o.TrustedDomains != nil || o.TrustedDomainCount > 0 {
		_ptr_TrustedDomains := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.TrustedDomainCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.TrustedDomains {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.TrustedDomains[i1] != nil {
					if err := o.TrustedDomains[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&OneDomainInfo{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.TrustedDomains); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&OneDomainInfo{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.TrustedDomains, _ptr_TrustedDomains); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.LSAPolicy != nil {
		if err := o.LSAPolicy.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&LSAPolicyInfo{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.DNSHostNameInDS != nil {
		if err := o.DNSHostNameInDS.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// reserved DummyString2
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString3
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString4
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.WriteData(o.WorkstationFlags); err != nil {
		return err
	}
	if err := w.WriteData(o.SupportedEncTypes); err != nil {
		return err
	}
	// reserved DummyLong3
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong4
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	return nil
}
func (o *DomainInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if o.PrimaryDomain == nil {
		o.PrimaryDomain = &OneDomainInfo{}
	}
	if err := o.PrimaryDomain.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.TrustedDomainCount); err != nil {
		return err
	}
	_ptr_TrustedDomains := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.TrustedDomainCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.TrustedDomainCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.TrustedDomains", sizeInfo[0])
		}
		o.TrustedDomains = make([]*OneDomainInfo, sizeInfo[0])
		for i1 := range o.TrustedDomains {
			i1 := i1
			if o.TrustedDomains[i1] == nil {
				o.TrustedDomains[i1] = &OneDomainInfo{}
			}
			if err := o.TrustedDomains[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_TrustedDomains := func(ptr interface{}) { o.TrustedDomains = *ptr.(*[]*OneDomainInfo) }
	if err := w.ReadPointer(&o.TrustedDomains, _s_TrustedDomains, _ptr_TrustedDomains); err != nil {
		return err
	}
	if o.LSAPolicy == nil {
		o.LSAPolicy = &LSAPolicyInfo{}
	}
	if err := o.LSAPolicy.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.DNSHostNameInDS == nil {
		o.DNSHostNameInDS = &dtyp.UnicodeString{}
	}
	if err := o.DNSHostNameInDS.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString2
	var _DummyString2 *dtyp.UnicodeString
	if _DummyString2 == nil {
		_DummyString2 = &dtyp.UnicodeString{}
	}
	if err := _DummyString2.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString3
	var _DummyString3 *dtyp.UnicodeString
	if _DummyString3 == nil {
		_DummyString3 = &dtyp.UnicodeString{}
	}
	if err := _DummyString3.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString4
	var _DummyString4 *dtyp.UnicodeString
	if _DummyString4 == nil {
		_DummyString4 = &dtyp.UnicodeString{}
	}
	if err := _DummyString4.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.WorkstationFlags); err != nil {
		return err
	}
	if err := w.ReadData(&o.SupportedEncTypes); err != nil {
		return err
	}
	// reserved DummyLong3
	var _DummyLong3 uint32
	if err := w.ReadData(&_DummyLong3); err != nil {
		return err
	}
	// reserved DummyLong4
	var _DummyLong4 uint32
	if err := w.ReadData(&_DummyLong4); err != nil {
		return err
	}
	return nil
}

// DomainInformation structure represents NETLOGON_DOMAIN_INFORMATION RPC union.
//
// The NETLOGON_DOMAIN_INFO structure SHOULD<28> define information returned as output
// from the NetrLogonGetDomainInfo method, as specified in section 3.5.4.4.9. It contains
// information about a domain, including naming information and a list of trusted domains.
type DomainInformation struct {
	// Types that are assignable to Value
	//
	// *DomainInformation_DomainInfo
	// *DomainInformation_LSAPolicyInfo
	Value is_DomainInformation `json:"value"`
}

func (o *DomainInformation) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *DomainInformation_DomainInfo:
		if value != nil {
			return value.DomainInfo
		}
	case *DomainInformation_LSAPolicyInfo:
		if value != nil {
			return value.LSAPolicyInfo
		}
	}
	return nil
}

type is_DomainInformation interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_DomainInformation()
}

func (o *DomainInformation) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *DomainInformation_DomainInfo:
		return uint32(1)
	case *DomainInformation_LSAPolicyInfo:
		return uint32(2)
	}
	return uint32(0)
}

func (o *DomainInformation) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*DomainInformation_DomainInfo)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DomainInformation_DomainInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(2):
		_o, _ := o.Value.(*DomainInformation_LSAPolicyInfo)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DomainInformation_LSAPolicyInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *DomainInformation) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &DomainInformation_DomainInfo{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(2):
		o.Value = &DomainInformation_LSAPolicyInfo{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// DomainInformation_DomainInfo structure represents NETLOGON_DOMAIN_INFORMATION RPC union arm.
//
// It has following labels: 1
type DomainInformation_DomainInfo struct {
	DomainInfo *DomainInfo `idl:"name:DomainInfo" json:"domain_info"`
}

func (*DomainInformation_DomainInfo) is_DomainInformation() {}

func (o *DomainInformation_DomainInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.DomainInfo != nil {
		_ptr_DomainInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.DomainInfo != nil {
				if err := o.DomainInfo.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&DomainInfo{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.DomainInfo, _ptr_DomainInfo); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *DomainInformation_DomainInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_DomainInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.DomainInfo == nil {
			o.DomainInfo = &DomainInfo{}
		}
		if err := o.DomainInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_DomainInfo := func(ptr interface{}) { o.DomainInfo = *ptr.(**DomainInfo) }
	if err := w.ReadPointer(&o.DomainInfo, _s_DomainInfo, _ptr_DomainInfo); err != nil {
		return err
	}
	return nil
}

// DomainInformation_LSAPolicyInfo structure represents NETLOGON_DOMAIN_INFORMATION RPC union arm.
//
// It has following labels: 2
type DomainInformation_LSAPolicyInfo struct {
	LSAPolicyInfo *LSAPolicyInfo `idl:"name:LsaPolicyInfo" json:"lsa_policy_info"`
}

func (*DomainInformation_LSAPolicyInfo) is_DomainInformation() {}

func (o *DomainInformation_LSAPolicyInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.LSAPolicyInfo != nil {
		_ptr_LsaPolicyInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.LSAPolicyInfo != nil {
				if err := o.LSAPolicyInfo.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&LSAPolicyInfo{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.LSAPolicyInfo, _ptr_LsaPolicyInfo); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *DomainInformation_LSAPolicyInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_LsaPolicyInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.LSAPolicyInfo == nil {
			o.LSAPolicyInfo = &LSAPolicyInfo{}
		}
		if err := o.LSAPolicyInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_LsaPolicyInfo := func(ptr interface{}) { o.LSAPolicyInfo = *ptr.(**LSAPolicyInfo) }
	if err := w.ReadPointer(&o.LSAPolicyInfo, _s_LsaPolicyInfo, _ptr_LsaPolicyInfo); err != nil {
		return err
	}
	return nil
}

// WorkstationInfo structure represents NETLOGON_WORKSTATION_INFO RPC structure.
//
// The NETLOGON_WORKSTATION_INFO structure defines information passed into the NetrLogonGetDomainInfo
// method, as specified in 3.5.4.4.9. It SHOULD<20> be used to convey information about
// a member workstation from the client side to the server side.
type WorkstationInfo struct {
	// LsaPolicy: A NETLOGON_LSA_POLICY_INFO structure, as specified in section 2.2.1.3.5,
	// that contains the LSA policy for this domain.
	LSAPolicy *LSAPolicyInfo `idl:"name:LsaPolicy" json:"lsa_policy"`
	// DnsHostName: A null-terminated Unicode string that contains the DNS host name of
	// the client.
	DNSHostName string `idl:"name:DnsHostName;string" json:"dns_host_name"`
	// SiteName: A null-terminated Unicode string that contains the name of the site where
	// the workstation resides.
	SiteName string `idl:"name:SiteName;string" json:"site_name"`
	// Dummy1: MUST be set to NULL and MUST be ignored on receipt. The Netlogon usage of
	// dummy fields is described in section 1.3.8.1.2.
	_ string `idl:"name:Dummy1;string"`
	// Dummy2: See definition of Dummy1.
	_ string `idl:"name:Dummy2;string"`
	// Dummy3: See definition of Dummy1.
	_ string `idl:"name:Dummy3;string"`
	// Dummy4: See definition of Dummy1.
	_ string `idl:"name:Dummy4;string"`
	// OsVersion: An RPC_UNICODE_STRING structure (as defined in [MS-DTYP] section 2.3.10)
	// in which the Length and MaximumLength fields are set to the size of an OSVERSIONINFOEX
	// structure and the Buffer field points to an OSVERSIONINFOEX ([MS-RPRN] section 2.2.3.10.2)
	// structure. OsVersion contains the version number of the operating system installed
	// on the client machine.
	OSVersion *dtyp.UnicodeString `idl:"name:OsVersion" json:"os_version"`
	// OsName: A null-terminated Unicode string that SHOULD<21> contain the name of the
	// operating system installed on the client machine. The DC that receives this data
	// structure updates the operatingSystem attribute of the client's machine account object
	// in Active Directory, as specified in [MS-ADA3] section 2.53.
	OSName *dtyp.UnicodeString `idl:"name:OsName" json:"os_name"`
	// DummyString3: A STRING structure, defined in section 2.2.1.1.1, that MUST contain
	// 0 for the Length field, 0 for the MaximumLength field, and NULL for the Buffer field.
	// It is ignored upon receipt. The Netlogon usage of dummy fields is described in section
	// 1.3.8.1.2.
	_ *dtyp.UnicodeString `idl:"name:DummyString3"`
	// DummyString4: See definition for DummyString3.
	_ *dtyp.UnicodeString `idl:"name:DummyString4"`
	// WorkstationFlags: A set of bit flags specifying workstation behavior. A flag is TRUE
	// (or set) if its value is equal to 1. The value is constructed from zero or more bit
	// flags from the following table.
	//
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
	//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | B | A |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//
	// Where the bits are defined as:
	//
	//	+-------+----------------------------------------------------------------------------------+
	//	|       |                                                                                  |
	//	| VALUE |                                   DESCRIPTION                                    |
	//	|       |                                                                                  |
	//	+-------+----------------------------------------------------------------------------------+
	//	+-------+----------------------------------------------------------------------------------+
	//	| A     | Client will receive inbound trusts as specified in [MS-LSAD] section 2.2.7.9.    |
	//	|       | The client sets this bit in order to receive the inbound trusts.                 |
	//	+-------+----------------------------------------------------------------------------------+
	//	| B     | Client handles the update of the service principal name (SPN).                   |
	//	+-------+----------------------------------------------------------------------------------+
	WorkstationFlags uint32 `idl:"name:WorkstationFlags" json:"workstation_flags"`
	// KerberosSupportedEncryptionTypes: The msDS-SupportedEncryptionTypes attribute of
	// the client's machine account object in Active Directory, as specified in [MS-ADA2]
	// section 2.473.<22>
	KerberosSupportedEncryptionTypes uint32 `idl:"name:KerberosSupportedEncryptionTypes" json:"kerberos_supported_encryption_types"`
	// DummyLong3: MUST be set to zero and MUST be ignored on receipt. The Netlogon usage
	// of dummy fields is described in section 1.3.8.1.2.
	_ uint32 `idl:"name:DummyLong3"`
	// DummyLong4: See definition of DummyLong3.
	_ uint32 `idl:"name:DummyLong4"`
}

func (o *WorkstationInfo) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *WorkstationInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.LSAPolicy != nil {
		if err := o.LSAPolicy.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&LSAPolicyInfo{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.DNSHostName != "" {
		_ptr_DnsHostName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.DNSHostName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.DNSHostName, _ptr_DnsHostName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.SiteName != "" {
		_ptr_SiteName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.SiteName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.SiteName, _ptr_SiteName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	// reserved Dummy1
	if err := w.WritePointer(nil); err != nil {
		return err
	}
	// reserved Dummy2
	if err := w.WritePointer(nil); err != nil {
		return err
	}
	// reserved Dummy3
	if err := w.WritePointer(nil); err != nil {
		return err
	}
	// reserved Dummy4
	if err := w.WritePointer(nil); err != nil {
		return err
	}
	if o.OSVersion != nil {
		if err := o.OSVersion.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.OSName != nil {
		if err := o.OSName.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// reserved DummyString3
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString4
	if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.WriteData(o.WorkstationFlags); err != nil {
		return err
	}
	if err := w.WriteData(o.KerberosSupportedEncryptionTypes); err != nil {
		return err
	}
	// reserved DummyLong3
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	// reserved DummyLong4
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	return nil
}
func (o *WorkstationInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if o.LSAPolicy == nil {
		o.LSAPolicy = &LSAPolicyInfo{}
	}
	if err := o.LSAPolicy.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_DnsHostName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.DNSHostName); err != nil {
			return err
		}
		return nil
	})
	_s_DnsHostName := func(ptr interface{}) { o.DNSHostName = *ptr.(*string) }
	if err := w.ReadPointer(&o.DNSHostName, _s_DnsHostName, _ptr_DnsHostName); err != nil {
		return err
	}
	_ptr_SiteName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.SiteName); err != nil {
			return err
		}
		return nil
	})
	_s_SiteName := func(ptr interface{}) { o.SiteName = *ptr.(*string) }
	if err := w.ReadPointer(&o.SiteName, _s_SiteName, _ptr_SiteName); err != nil {
		return err
	}
	// reserved Dummy1
	var _Dummy1 string
	_ptr_Dummy1 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &_Dummy1); err != nil {
			return err
		}
		return nil
	})
	_s_Dummy1 := func(ptr interface{}) { _Dummy1 = *ptr.(*string) }
	if err := w.ReadPointer(&_Dummy1, _s_Dummy1, _ptr_Dummy1); err != nil {
		return err
	}
	// reserved Dummy2
	var _Dummy2 string
	_ptr_Dummy2 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &_Dummy2); err != nil {
			return err
		}
		return nil
	})
	_s_Dummy2 := func(ptr interface{}) { _Dummy2 = *ptr.(*string) }
	if err := w.ReadPointer(&_Dummy2, _s_Dummy2, _ptr_Dummy2); err != nil {
		return err
	}
	// reserved Dummy3
	var _Dummy3 string
	_ptr_Dummy3 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &_Dummy3); err != nil {
			return err
		}
		return nil
	})
	_s_Dummy3 := func(ptr interface{}) { _Dummy3 = *ptr.(*string) }
	if err := w.ReadPointer(&_Dummy3, _s_Dummy3, _ptr_Dummy3); err != nil {
		return err
	}
	// reserved Dummy4
	var _Dummy4 string
	_ptr_Dummy4 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &_Dummy4); err != nil {
			return err
		}
		return nil
	})
	_s_Dummy4 := func(ptr interface{}) { _Dummy4 = *ptr.(*string) }
	if err := w.ReadPointer(&_Dummy4, _s_Dummy4, _ptr_Dummy4); err != nil {
		return err
	}
	if o.OSVersion == nil {
		o.OSVersion = &dtyp.UnicodeString{}
	}
	if err := o.OSVersion.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.OSName == nil {
		o.OSName = &dtyp.UnicodeString{}
	}
	if err := o.OSName.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString3
	var _DummyString3 *dtyp.UnicodeString
	if _DummyString3 == nil {
		_DummyString3 = &dtyp.UnicodeString{}
	}
	if err := _DummyString3.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	// reserved DummyString4
	var _DummyString4 *dtyp.UnicodeString
	if _DummyString4 == nil {
		_DummyString4 = &dtyp.UnicodeString{}
	}
	if err := _DummyString4.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.WorkstationFlags); err != nil {
		return err
	}
	if err := w.ReadData(&o.KerberosSupportedEncryptionTypes); err != nil {
		return err
	}
	// reserved DummyLong3
	var _DummyLong3 uint32
	if err := w.ReadData(&_DummyLong3); err != nil {
		return err
	}
	// reserved DummyLong4
	var _DummyLong4 uint32
	if err := w.ReadData(&_DummyLong4); err != nil {
		return err
	}
	return nil
}

// WorkstationInformation structure represents NETLOGON_WORKSTATION_INFORMATION RPC union.
//
// The NETLOGON_WORKSTATION_INFO structure defines information passed into the NetrLogonGetDomainInfo
// method, as specified in 3.5.4.4.9. It SHOULD<20> be used to convey information about
// a member workstation from the client side to the server side.
type WorkstationInformation struct {
	// Types that are assignable to Value
	//
	// *WorkstationInformation_WorkstationInfo
	// *WorkstationInformation_LSAPolicyInfo
	Value is_WorkstationInformation `json:"value"`
}

func (o *WorkstationInformation) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *WorkstationInformation_WorkstationInfo:
		if value != nil {
			return value.WorkstationInfo
		}
	case *WorkstationInformation_LSAPolicyInfo:
		if value != nil {
			return value.LSAPolicyInfo
		}
	}
	return nil
}

type is_WorkstationInformation interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_WorkstationInformation()
}

func (o *WorkstationInformation) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *WorkstationInformation_WorkstationInfo:
		return uint32(1)
	case *WorkstationInformation_LSAPolicyInfo:
		return uint32(2)
	}
	return uint32(0)
}

func (o *WorkstationInformation) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*WorkstationInformation_WorkstationInfo)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&WorkstationInformation_WorkstationInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint32(2):
		_o, _ := o.Value.(*WorkstationInformation_LSAPolicyInfo)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&WorkstationInformation_LSAPolicyInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *WorkstationInformation) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &WorkstationInformation_WorkstationInfo{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint32(2):
		o.Value = &WorkstationInformation_LSAPolicyInfo{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// WorkstationInformation_WorkstationInfo structure represents NETLOGON_WORKSTATION_INFORMATION RPC union arm.
//
// It has following labels: 1
type WorkstationInformation_WorkstationInfo struct {
	WorkstationInfo *WorkstationInfo `idl:"name:WorkstationInfo" json:"workstation_info"`
}

func (*WorkstationInformation_WorkstationInfo) is_WorkstationInformation() {}

func (o *WorkstationInformation_WorkstationInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.WorkstationInfo != nil {
		_ptr_WorkstationInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.WorkstationInfo != nil {
				if err := o.WorkstationInfo.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&WorkstationInfo{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.WorkstationInfo, _ptr_WorkstationInfo); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *WorkstationInformation_WorkstationInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_WorkstationInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.WorkstationInfo == nil {
			o.WorkstationInfo = &WorkstationInfo{}
		}
		if err := o.WorkstationInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_WorkstationInfo := func(ptr interface{}) { o.WorkstationInfo = *ptr.(**WorkstationInfo) }
	if err := w.ReadPointer(&o.WorkstationInfo, _s_WorkstationInfo, _ptr_WorkstationInfo); err != nil {
		return err
	}
	return nil
}

// WorkstationInformation_LSAPolicyInfo structure represents NETLOGON_WORKSTATION_INFORMATION RPC union arm.
//
// It has following labels: 2
type WorkstationInformation_LSAPolicyInfo struct {
	LSAPolicyInfo *WorkstationInfo `idl:"name:LsaPolicyInfo" json:"lsa_policy_info"`
}

func (*WorkstationInformation_LSAPolicyInfo) is_WorkstationInformation() {}

func (o *WorkstationInformation_LSAPolicyInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.LSAPolicyInfo != nil {
		_ptr_LsaPolicyInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.LSAPolicyInfo != nil {
				if err := o.LSAPolicyInfo.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&WorkstationInfo{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.LSAPolicyInfo, _ptr_LsaPolicyInfo); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *WorkstationInformation_LSAPolicyInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	_ptr_LsaPolicyInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.LSAPolicyInfo == nil {
			o.LSAPolicyInfo = &WorkstationInfo{}
		}
		if err := o.LSAPolicyInfo.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_LsaPolicyInfo := func(ptr interface{}) { o.LSAPolicyInfo = *ptr.(**WorkstationInfo) }
	if err := w.ReadPointer(&o.LSAPolicyInfo, _s_LsaPolicyInfo, _ptr_LsaPolicyInfo); err != nil {
		return err
	}
	return nil
}

// SocketAddress structure represents NL_SOCKET_ADDRESS RPC structure.
//
// The NL_SOCKET_ADDRESS structure contains a socket address.
type SocketAddress struct {
	// lpSockaddr: A pointer to an octet string. The format of the lpSockaddr member when
	// an IPv4 socket address is used is specified in section 2.2.1.2.4.1. The format of
	// the lpSockaddr member when an IPv6 socket address is used is specified in section
	// 2.2.1.2.4.2.
	Sockaddr []byte `idl:"name:lpSockaddr;size_is:(iSockaddrLength)" json:"sockaddr"`
	// iSockaddrLength: The length of the octet string pointed to by lpSockaddr, in bytes.
	SockaddrLength uint32 `idl:"name:iSockaddrLength" json:"sockaddr_length"`
}

func (o *SocketAddress) xxx_PreparePayload(ctx context.Context) error {
	if o.Sockaddr != nil && o.SockaddrLength == 0 {
		o.SockaddrLength = uint32(len(o.Sockaddr))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *SocketAddress) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.Sockaddr != nil || o.SockaddrLength > 0 {
		_ptr_lpSockaddr := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.SockaddrLength)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Sockaddr {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.Sockaddr[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.Sockaddr); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Sockaddr, _ptr_lpSockaddr); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.SockaddrLength); err != nil {
		return err
	}
	return nil
}
func (o *SocketAddress) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_lpSockaddr := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.SockaddrLength > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.SockaddrLength)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Sockaddr", sizeInfo[0])
		}
		o.Sockaddr = make([]byte, sizeInfo[0])
		for i1 := range o.Sockaddr {
			i1 := i1
			if err := w.ReadData(&o.Sockaddr[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_lpSockaddr := func(ptr interface{}) { o.Sockaddr = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.Sockaddr, _s_lpSockaddr, _ptr_lpSockaddr); err != nil {
		return err
	}
	if err := w.ReadData(&o.SockaddrLength); err != nil {
		return err
	}
	return nil
}

// SiteNameArray structure represents NL_SITE_NAME_ARRAY RPC structure.
//
// The NL_SITE_NAME_ARRAY structure defines an array of site names.
type SiteNameArray struct {
	// EntryCount: The number of entries in SiteNames.
	EntryCount uint32 `idl:"name:EntryCount" json:"entry_count"`
	// SiteNames: A pointer to an array of null-terminated RPC_UNICODE_STRING structures
	// ([MS-DTYP] section 2.3.10) that contain site names. For more information about sites,
	// see [MS-ADTS] section 6.1.1.2.2.1.
	SiteNames []*dtyp.UnicodeString `idl:"name:SiteNames;size_is:(EntryCount)" json:"site_names"`
}

func (o *SiteNameArray) xxx_PreparePayload(ctx context.Context) error {
	if o.SiteNames != nil && o.EntryCount == 0 {
		o.EntryCount = uint32(len(o.SiteNames))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *SiteNameArray) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.EntryCount); err != nil {
		return err
	}
	if o.SiteNames != nil || o.EntryCount > 0 {
		_ptr_SiteNames := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.EntryCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.SiteNames {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.SiteNames[i1] != nil {
					if err := o.SiteNames[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.SiteNames); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.SiteNames, _ptr_SiteNames); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *SiteNameArray) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntryCount); err != nil {
		return err
	}
	_ptr_SiteNames := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.EntryCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.EntryCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.SiteNames", sizeInfo[0])
		}
		o.SiteNames = make([]*dtyp.UnicodeString, sizeInfo[0])
		for i1 := range o.SiteNames {
			i1 := i1
			if o.SiteNames[i1] == nil {
				o.SiteNames[i1] = &dtyp.UnicodeString{}
			}
			if err := o.SiteNames[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_SiteNames := func(ptr interface{}) { o.SiteNames = *ptr.(*[]*dtyp.UnicodeString) }
	if err := w.ReadPointer(&o.SiteNames, _s_SiteNames, _ptr_SiteNames); err != nil {
		return err
	}
	return nil
}

// DSDomainTrustsw structure represents DS_DOMAIN_TRUSTSW RPC structure.
//
// The DS_DOMAIN_TRUSTSW structure defines information about a domain trust. It is part
// of the NETLOGON_TRUSTED_DOMAIN_ARRAY structure, as specified in section 2.2.1.6.3,
// returned by the DsrEnumerateDomainTrusts method, as specified in section 3.5.4.7.1.
// This structure SHOULD<54> contain naming information and trust-related information
// for a specific trusted domain.
type DSDomainTrustsw struct {
	// NetbiosDomainName: A pointer to a null-terminated Unicode string that contains the
	// NetBIOS name of the trusted domain.
	NetBIOSDomainName string `idl:"name:NetbiosDomainName;string" json:"netbios_domain_name"`
	// DnsDomainName: A pointer to a null-terminated Unicode string that contains the FQDN
	// of the trusted domain.
	DNSDomainName string `idl:"name:DnsDomainName;string" json:"dns_domain_name"`
	// Flags: A set of bit flags that defines the domain trust attributes. A flag is TRUE
	// (or set) if its value is equal to 1. The value is constructed from zero or more bit
	// flags from the following table.
	//
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
	//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | F | E | D | C | B | A |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//
	// Where the bits are defined as:
	//
	//	+-------+-----------------------------------------------------+
	//	|       |                                                     |
	//	| VALUE |                     DESCRIPTION                     |
	//	|       |                                                     |
	//	+-------+-----------------------------------------------------+
	//	+-------+-----------------------------------------------------+
	//	| A     | Domain is a member of a forest.                     |
	//	+-------+-----------------------------------------------------+
	//	| B     | Domain is directly trusted by the current domain.   |
	//	+-------+-----------------------------------------------------+
	//	| C     | Domain is the root of a forests.                    |
	//	+-------+-----------------------------------------------------+
	//	| D     | Domain is the primary domain of the queried server. |
	//	+-------+-----------------------------------------------------+
	//	| E     | Primary domain is running in native mode.           |
	//	+-------+-----------------------------------------------------+
	//	| F     | Domain directly trusts the current domain.          |
	//	+-------+-----------------------------------------------------+
	Flags uint32 `idl:"name:Flags" json:"flags"`
	// ParentIndex: An integer value that contains the index in the NETLOGON_TRUSTED_DOMAIN_ARRAY
	// array (returned by DsrEnumerateDomainTrusts method) that corresponds to the parent
	// domain of the domain represented by this structure. This field is set if all of the
	// following conditions are met:
	//
	// * The A flag is specified in the Flags parameter of the *DsrEnumerateDomainTrusts*
	// method.
	//
	// * The *Flags* field of *DS_DOMAIN_TRUSTSW* structure does not contain the C flag.
	ParentIndex uint32 `idl:"name:ParentIndex" json:"parent_index"`
	// TrustType: An integer value that describes the type of domain with which the trust
	// is associated. TrustType is one of the following values.
	//
	//	+------------+----------------------------------------------------------------+
	//	|            |                                                                |
	//	|   VALUE    |                            MEANING                             |
	//	|            |                                                                |
	//	+------------+----------------------------------------------------------------+
	//	+------------+----------------------------------------------------------------+
	//	| 0x00000001 | Trust is with a domain.<55>                                    |
	//	+------------+----------------------------------------------------------------+
	//	| 0x00000002 | Trust is with an Active Directory domain.<56>                  |
	//	+------------+----------------------------------------------------------------+
	//	| 0x00000003 | Trust is with an MIT Kerberos realm.                           |
	//	+------------+----------------------------------------------------------------+
	//	| 0x00000004 | Trust is with a Distributed Computing Environment (DCE) realm. |
	//	+------------+----------------------------------------------------------------+
	TrustType uint32 `idl:"name:TrustType" json:"trust_type"`
	// TrustAttributes: A set of bit flags describing trust link attributes. A flag is true
	// (or set) if its value is equal to 1. The value is constructed from zero or more bit
	// flags from the following table, with the exception that bit F cannot be combined
	// with E or D.
	//
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
	//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | I | H | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | G | F | E | D | C | B | A |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//
	// Where the bits are defined as:
	//
	//	+-------+----------------------------------------------------------------------------------+
	//	|       |                                                                                  |
	//	| VALUE |                                   DESCRIPTION                                    |
	//	|       |                                                                                  |
	//	+-------+----------------------------------------------------------------------------------+
	//	+-------+----------------------------------------------------------------------------------+
	//	| A     | Trust link MUST NOT allow transitivity.                                          |
	//	+-------+----------------------------------------------------------------------------------+
	//	| B     | Trust link MAY<57>  be valid.                                                    |
	//	+-------+----------------------------------------------------------------------------------+
	//	| C     | Trust link MUST be set for SID filtering of the client domain. For details about |
	//	|       | SID filtering, see [MS-PAC].                                                     |
	//	+-------+----------------------------------------------------------------------------------+
	//	| D     | Trust link can contain forest trust information.                                 |
	//	+-------+----------------------------------------------------------------------------------+
	//	| E     | Trust link is to either a domain or a forest that is not part of the enterprise  |
	//	|       | network.                                                                         |
	//	+-------+----------------------------------------------------------------------------------+
	//	| F     | Trust link is internal to the forest.                                            |
	//	+-------+----------------------------------------------------------------------------------+
	//	| G     | Trust is to be treated as external for trust boundary purposes.                  |
	//	+-------+----------------------------------------------------------------------------------+
	//	| H     | Domain is parent domain.                                                         |
	//	+-------+----------------------------------------------------------------------------------+
	//	| I     | Domain is root of another forest.                                                |
	//	+-------+----------------------------------------------------------------------------------+
	TrustAttributes uint32 `idl:"name:TrustAttributes" json:"trust_attributes"`
	// DomainSid: A pointer to a SID structure ([MS-DTYP] section 2.4.2.3) that identifies
	// the current domain. If the TrustAttributes field is set to C or D, the value is 0.
	DomainSID *dtyp.SID `idl:"name:DomainSid" json:"domain_sid"`
	// DomainGuid: A GUID structure ([MS-DTYP] section 2.3.4.1) that identifies the current
	// domain.
	DomainGUID *dtyp.GUID `idl:"name:DomainGuid" json:"domain_guid"`
}

func (o *DSDomainTrustsw) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSDomainTrustsw) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.NetBIOSDomainName != "" {
		_ptr_NetbiosDomainName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.NetBIOSDomainName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.NetBIOSDomainName, _ptr_NetbiosDomainName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.DNSDomainName != "" {
		_ptr_DnsDomainName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.DNSDomainName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.DNSDomainName, _ptr_DnsDomainName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	if err := w.WriteData(o.ParentIndex); err != nil {
		return err
	}
	if err := w.WriteData(o.TrustType); err != nil {
		return err
	}
	if err := w.WriteData(o.TrustAttributes); err != nil {
		return err
	}
	if o.DomainSID != nil {
		_ptr_DomainSid := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.DomainSID != nil {
				if err := o.DomainSID.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&dtyp.SID{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.DomainSID, _ptr_DomainSid); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.DomainGUID != nil {
		if err := o.DomainGUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *DSDomainTrustsw) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_NetbiosDomainName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.NetBIOSDomainName); err != nil {
			return err
		}
		return nil
	})
	_s_NetbiosDomainName := func(ptr interface{}) { o.NetBIOSDomainName = *ptr.(*string) }
	if err := w.ReadPointer(&o.NetBIOSDomainName, _s_NetbiosDomainName, _ptr_NetbiosDomainName); err != nil {
		return err
	}
	_ptr_DnsDomainName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.DNSDomainName); err != nil {
			return err
		}
		return nil
	})
	_s_DnsDomainName := func(ptr interface{}) { o.DNSDomainName = *ptr.(*string) }
	if err := w.ReadPointer(&o.DNSDomainName, _s_DnsDomainName, _ptr_DnsDomainName); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	if err := w.ReadData(&o.ParentIndex); err != nil {
		return err
	}
	if err := w.ReadData(&o.TrustType); err != nil {
		return err
	}
	if err := w.ReadData(&o.TrustAttributes); err != nil {
		return err
	}
	_ptr_DomainSid := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.DomainSID == nil {
			o.DomainSID = &dtyp.SID{}
		}
		if err := o.DomainSID.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_DomainSid := func(ptr interface{}) { o.DomainSID = *ptr.(**dtyp.SID) }
	if err := w.ReadPointer(&o.DomainSID, _s_DomainSid, _ptr_DomainSid); err != nil {
		return err
	}
	if o.DomainGUID == nil {
		o.DomainGUID = &dtyp.GUID{}
	}
	if err := o.DomainGUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// TrustedDomainArray structure represents NETLOGON_TRUSTED_DOMAIN_ARRAY RPC structure.
//
// The NETLOGON_TRUSTED_DOMAIN_ARRAY structure SHOULD<58> define information returned
// by the NetrEnumerateTrustedDomainsEx method, as specified in section 3.5.4.7.2.
type TrustedDomainArray struct {
	// DomainCount: The number of entries in the Domains field.
	DomainCount uint32 `idl:"name:DomainCount" json:"domain_count"`
	// Domains: An array of DS_DOMAIN_TRUSTSW structures (section 2.2.1.6.2) that describe
	// domains trusted by the server processing the NetrEnumerateTrustedDomainsEx method
	// call.
	Domains []*DSDomainTrustsw `idl:"name:Domains;size_is:(DomainCount)" json:"domains"`
}

func (o *TrustedDomainArray) xxx_PreparePayload(ctx context.Context) error {
	if o.Domains != nil && o.DomainCount == 0 {
		o.DomainCount = uint32(len(o.Domains))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *TrustedDomainArray) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.DomainCount); err != nil {
		return err
	}
	if o.Domains != nil || o.DomainCount > 0 {
		_ptr_Domains := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.DomainCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Domains {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Domains[i1] != nil {
					if err := o.Domains[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&DSDomainTrustsw{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Domains); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&DSDomainTrustsw{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Domains, _ptr_Domains); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *TrustedDomainArray) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.DomainCount); err != nil {
		return err
	}
	_ptr_Domains := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.DomainCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.DomainCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Domains", sizeInfo[0])
		}
		o.Domains = make([]*DSDomainTrustsw, sizeInfo[0])
		for i1 := range o.Domains {
			i1 := i1
			if o.Domains[i1] == nil {
				o.Domains[i1] = &DSDomainTrustsw{}
			}
			if err := o.Domains[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_Domains := func(ptr interface{}) { o.Domains = *ptr.(*[]*DSDomainTrustsw) }
	if err := w.ReadPointer(&o.Domains, _s_Domains, _ptr_Domains); err != nil {
		return err
	}
	return nil
}

// SiteNameExArray structure represents NL_SITE_NAME_EX_ARRAY RPC structure.
//
// The NL_SITE_NAME_EX_ARRAY structure defines an array of site and subnet names. This
// structure extends the NL_SITE_NAME_ARRAY (section 2.2.1.2.2) structure by adding
// an array of subnets that correspond to the sites.
type SiteNameExArray struct {
	// EntryCount: The number of entries in SiteNames and SubnetNames.
	EntryCount uint32 `idl:"name:EntryCount" json:"entry_count"`
	// SiteNames: A pointer to an array of null-terminated Unicode strings that contain
	// site names. For details about sites, see [MS-ADTS] section 6.1.1.2.2.1.
	SiteNames []*dtyp.UnicodeString `idl:"name:SiteNames;size_is:(EntryCount)" json:"site_names"`
	// SubnetNames: A pointer to an array of null-terminated Unicode strings that contain
	// subnet names. For details about subnets, see [MS-ADTS] section 6.1.1.2.2.2.1.
	SubnetNames []*dtyp.UnicodeString `idl:"name:SubnetNames;size_is:(EntryCount)" json:"subnet_names"`
}

func (o *SiteNameExArray) xxx_PreparePayload(ctx context.Context) error {
	if o.SiteNames != nil && o.EntryCount == 0 {
		o.EntryCount = uint32(len(o.SiteNames))
	}
	if o.SubnetNames != nil && o.EntryCount == 0 {
		o.EntryCount = uint32(len(o.SubnetNames))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *SiteNameExArray) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.EntryCount); err != nil {
		return err
	}
	if o.SiteNames != nil || o.EntryCount > 0 {
		_ptr_SiteNames := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.EntryCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.SiteNames {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.SiteNames[i1] != nil {
					if err := o.SiteNames[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.SiteNames); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.SiteNames, _ptr_SiteNames); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.SubnetNames != nil || o.EntryCount > 0 {
		_ptr_SubnetNames := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.EntryCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.SubnetNames {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.SubnetNames[i1] != nil {
					if err := o.SubnetNames[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.SubnetNames); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.SubnetNames, _ptr_SubnetNames); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *SiteNameExArray) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntryCount); err != nil {
		return err
	}
	_ptr_SiteNames := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.EntryCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.EntryCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.SiteNames", sizeInfo[0])
		}
		o.SiteNames = make([]*dtyp.UnicodeString, sizeInfo[0])
		for i1 := range o.SiteNames {
			i1 := i1
			if o.SiteNames[i1] == nil {
				o.SiteNames[i1] = &dtyp.UnicodeString{}
			}
			if err := o.SiteNames[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_SiteNames := func(ptr interface{}) { o.SiteNames = *ptr.(*[]*dtyp.UnicodeString) }
	if err := w.ReadPointer(&o.SiteNames, _s_SiteNames, _ptr_SiteNames); err != nil {
		return err
	}
	_ptr_SubnetNames := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.EntryCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.EntryCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.SubnetNames", sizeInfo[0])
		}
		o.SubnetNames = make([]*dtyp.UnicodeString, sizeInfo[0])
		for i1 := range o.SubnetNames {
			i1 := i1
			if o.SubnetNames[i1] == nil {
				o.SubnetNames[i1] = &dtyp.UnicodeString{}
			}
			if err := o.SubnetNames[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_SubnetNames := func(ptr interface{}) { o.SubnetNames = *ptr.(*[]*dtyp.UnicodeString) }
	if err := w.ReadPointer(&o.SubnetNames, _s_SubnetNames, _ptr_SubnetNames); err != nil {
		return err
	}
	return nil
}

// GenericRPCData structure represents NL_GENERIC_RPC_DATA RPC structure.
//
// The NL_GENERIC_RPC_DATA structure SHOULD<59> define a format for marshaling arrays
// of unsigned long values and Unicode strings, by value, over RPC. This structure can
// be used to transmit generic data over RPC from the server to a client.
type GenericRPCData struct {
	// UlongEntryCount: The number of entries in the UlongData field.
	EntryCount uint32 `idl:"name:UlongEntryCount" json:"entry_count"`
	// UlongData: A pointer to an array of unsigned 32-bit integer values.
	Data []uint32 `idl:"name:UlongData;size_is:(UlongEntryCount)" json:"data"`
	// UnicodeStringEntryCount: The number of entries in UnicodeStringData field.
	UnicodeStringEntryCount uint32 `idl:"name:UnicodeStringEntryCount" json:"unicode_string_entry_count"`
	// UnicodeStringData: A pointer to an array of Unicode STRING structures (section 2.2.1.1.2).
	UnicodeStringData []*dtyp.UnicodeString `idl:"name:UnicodeStringData;size_is:(UnicodeStringEntryCount)" json:"unicode_string_data"`
}

func (o *GenericRPCData) xxx_PreparePayload(ctx context.Context) error {
	if o.Data != nil && o.EntryCount == 0 {
		o.EntryCount = uint32(len(o.Data))
	}
	if o.UnicodeStringData != nil && o.UnicodeStringEntryCount == 0 {
		o.UnicodeStringEntryCount = uint32(len(o.UnicodeStringData))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *GenericRPCData) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.EntryCount); err != nil {
		return err
	}
	if o.Data != nil || o.EntryCount > 0 {
		_ptr_UlongData := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.EntryCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Data {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.Data[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.Data); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint32(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Data, _ptr_UlongData); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.UnicodeStringEntryCount); err != nil {
		return err
	}
	if o.UnicodeStringData != nil || o.UnicodeStringEntryCount > 0 {
		_ptr_UnicodeStringData := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.UnicodeStringEntryCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.UnicodeStringData {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.UnicodeStringData[i1] != nil {
					if err := o.UnicodeStringData[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.UnicodeStringData); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&dtyp.UnicodeString{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.UnicodeStringData, _ptr_UnicodeStringData); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *GenericRPCData) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntryCount); err != nil {
		return err
	}
	_ptr_UlongData := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.EntryCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.EntryCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Data", sizeInfo[0])
		}
		o.Data = make([]uint32, sizeInfo[0])
		for i1 := range o.Data {
			i1 := i1
			if err := w.ReadData(&o.Data[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_UlongData := func(ptr interface{}) { o.Data = *ptr.(*[]uint32) }
	if err := w.ReadPointer(&o.Data, _s_UlongData, _ptr_UlongData); err != nil {
		return err
	}
	if err := w.ReadData(&o.UnicodeStringEntryCount); err != nil {
		return err
	}
	_ptr_UnicodeStringData := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.UnicodeStringEntryCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.UnicodeStringEntryCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.UnicodeStringData", sizeInfo[0])
		}
		o.UnicodeStringData = make([]*dtyp.UnicodeString, sizeInfo[0])
		for i1 := range o.UnicodeStringData {
			i1 := i1
			if o.UnicodeStringData[i1] == nil {
				o.UnicodeStringData[i1] = &dtyp.UnicodeString{}
			}
			if err := o.UnicodeStringData[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_UnicodeStringData := func(ptr interface{}) { o.UnicodeStringData = *ptr.(*[]*dtyp.UnicodeString) }
	if err := w.ReadPointer(&o.UnicodeStringData, _s_UnicodeStringData, _ptr_UnicodeStringData); err != nil {
		return err
	}
	return nil
}

// ValidationUASInfo structure represents NETLOGON_VALIDATION_UAS_INFO RPC structure.
//
// The NETLOGON_VALIDATION_UAS_INFO structure was for the support of LAN Manager products
// and is beyond the scope of this document.
type ValidationUASInfo struct {
	EffectiveName      string `idl:"name:usrlog1_eff_name;string" json:"effective_name"`
	Priv               uint32 `idl:"name:usrlog1_priv" json:"priv"`
	AuthFlags          uint32 `idl:"name:usrlog1_auth_flags" json:"auth_flags"`
	NumLogons          uint32 `idl:"name:usrlog1_num_logons" json:"num_logons"`
	BadPasswordCount   uint32 `idl:"name:usrlog1_bad_pw_count" json:"bad_password_count"`
	LastLogon          uint32 `idl:"name:usrlog1_last_logon" json:"last_logon"`
	LastLogoff         uint32 `idl:"name:usrlog1_last_logoff" json:"last_logoff"`
	LogoffTime         uint32 `idl:"name:usrlog1_logoff_time" json:"logoff_time"`
	KickoffTime        uint32 `idl:"name:usrlog1_kickoff_time" json:"kickoff_time"`
	PasswordAge        uint32 `idl:"name:usrlog1_password_age" json:"password_age"`
	PasswordCanChange  uint32 `idl:"name:usrlog1_pw_can_change" json:"password_can_change"`
	PasswordMustChange uint32 `idl:"name:usrlog1_pw_must_change" json:"password_must_change"`
	Computer           string `idl:"name:usrlog1_computer;string" json:"computer"`
	Domain             string `idl:"name:usrlog1_domain;string" json:"domain"`
	ScriptPath         string `idl:"name:usrlog1_script_path;string" json:"script_path"`
	_                  uint32 `idl:"name:usrlog1_reserved1"`
}

func (o *ValidationUASInfo) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ValidationUASInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.EffectiveName != "" {
		_ptr_usrlog1_eff_name := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.EffectiveName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.EffectiveName, _ptr_usrlog1_eff_name); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Priv); err != nil {
		return err
	}
	if err := w.WriteData(o.AuthFlags); err != nil {
		return err
	}
	if err := w.WriteData(o.NumLogons); err != nil {
		return err
	}
	if err := w.WriteData(o.BadPasswordCount); err != nil {
		return err
	}
	if err := w.WriteData(o.LastLogon); err != nil {
		return err
	}
	if err := w.WriteData(o.LastLogoff); err != nil {
		return err
	}
	if err := w.WriteData(o.LogoffTime); err != nil {
		return err
	}
	if err := w.WriteData(o.KickoffTime); err != nil {
		return err
	}
	if err := w.WriteData(o.PasswordAge); err != nil {
		return err
	}
	if err := w.WriteData(o.PasswordCanChange); err != nil {
		return err
	}
	if err := w.WriteData(o.PasswordMustChange); err != nil {
		return err
	}
	if o.Computer != "" {
		_ptr_usrlog1_computer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Computer); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Computer, _ptr_usrlog1_computer); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.Domain != "" {
		_ptr_usrlog1_domain := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.Domain); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.Domain, _ptr_usrlog1_domain); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.ScriptPath != "" {
		_ptr_usrlog1_script_path := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.ScriptPath); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ScriptPath, _ptr_usrlog1_script_path); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	// reserved usrlog1_reserved1
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	return nil
}
func (o *ValidationUASInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_usrlog1_eff_name := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.EffectiveName); err != nil {
			return err
		}
		return nil
	})
	_s_usrlog1_eff_name := func(ptr interface{}) { o.EffectiveName = *ptr.(*string) }
	if err := w.ReadPointer(&o.EffectiveName, _s_usrlog1_eff_name, _ptr_usrlog1_eff_name); err != nil {
		return err
	}
	if err := w.ReadData(&o.Priv); err != nil {
		return err
	}
	if err := w.ReadData(&o.AuthFlags); err != nil {
		return err
	}
	if err := w.ReadData(&o.NumLogons); err != nil {
		return err
	}
	if err := w.ReadData(&o.BadPasswordCount); err != nil {
		return err
	}
	if err := w.ReadData(&o.LastLogon); err != nil {
		return err
	}
	if err := w.ReadData(&o.LastLogoff); err != nil {
		return err
	}
	if err := w.ReadData(&o.LogoffTime); err != nil {
		return err
	}
	if err := w.ReadData(&o.KickoffTime); err != nil {
		return err
	}
	if err := w.ReadData(&o.PasswordAge); err != nil {
		return err
	}
	if err := w.ReadData(&o.PasswordCanChange); err != nil {
		return err
	}
	if err := w.ReadData(&o.PasswordMustChange); err != nil {
		return err
	}
	_ptr_usrlog1_computer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Computer); err != nil {
			return err
		}
		return nil
	})
	_s_usrlog1_computer := func(ptr interface{}) { o.Computer = *ptr.(*string) }
	if err := w.ReadPointer(&o.Computer, _s_usrlog1_computer, _ptr_usrlog1_computer); err != nil {
		return err
	}
	_ptr_usrlog1_domain := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.Domain); err != nil {
			return err
		}
		return nil
	})
	_s_usrlog1_domain := func(ptr interface{}) { o.Domain = *ptr.(*string) }
	if err := w.ReadPointer(&o.Domain, _s_usrlog1_domain, _ptr_usrlog1_domain); err != nil {
		return err
	}
	_ptr_usrlog1_script_path := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.ScriptPath); err != nil {
			return err
		}
		return nil
	})
	_s_usrlog1_script_path := func(ptr interface{}) { o.ScriptPath = *ptr.(*string) }
	if err := w.ReadPointer(&o.ScriptPath, _s_usrlog1_script_path, _ptr_usrlog1_script_path); err != nil {
		return err
	}
	// reserved usrlog1_reserved1
	var _usrlog1_reserved1 uint32
	if err := w.ReadData(&_usrlog1_reserved1); err != nil {
		return err
	}
	return nil
}

// LogoffUASInfo structure represents NETLOGON_LOGOFF_UAS_INFO RPC structure.
type LogoffUASInfo struct {
	Duration   uint32 `idl:"name:Duration" json:"duration"`
	LogonCount uint16 `idl:"name:LogonCount" json:"logon_count"`
}

func (o *LogoffUASInfo) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *LogoffUASInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.Duration); err != nil {
		return err
	}
	if err := w.WriteData(o.LogonCount); err != nil {
		return err
	}
	return nil
}
func (o *LogoffUASInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.Duration); err != nil {
		return err
	}
	if err := w.ReadData(&o.LogonCount); err != nil {
		return err
	}
	return nil
}

// Capabilities structure represents NETLOGON_CAPABILITIES RPC union.
type Capabilities struct {
	// Types that are assignable to Value
	//
	// *Capabilities_Server
	Value is_Capabilities `json:"value"`
}

func (o *Capabilities) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *Capabilities_Server:
		if value != nil {
			return value.ServerCapabilities
		}
	}
	return nil
}

type is_Capabilities interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_Capabilities()
}

func (o *Capabilities) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *Capabilities_Server:
		return uint32(1)
	}
	return uint32(0)
}

func (o *Capabilities) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(4); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*Capabilities_Server)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Capabilities_Server{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *Capabilities) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(4); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &Capabilities_Server{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// Capabilities_Server structure represents NETLOGON_CAPABILITIES RPC union arm.
//
// It has following labels: 1
type Capabilities_Server struct {
	ServerCapabilities uint32 `idl:"name:ServerCapabilities" json:"server_capabilities"`
}

func (*Capabilities_Server) is_Capabilities() {}

func (o *Capabilities_Server) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := w.WriteData(o.ServerCapabilities); err != nil {
		return err
	}
	return nil
}
func (o *Capabilities_Server) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadData(&o.ServerCapabilities); err != nil {
		return err
	}
	return nil
}

// Credential structure represents NETLOGON_CREDENTIAL RPC structure.
//
// The NETLOGON_CREDENTIAL structure contains 8 bytes of data that have two distinct
// uses: for session-key negotiation and for building a Netlogon authenticator.
type Credential struct {
	// data: The meaning of the 8 bytes of data contained in this structure is determined
	// by the following:
	//
	// * When session-key negotiation is performed, the data field carries an 8-byte challenge.
	// Also see section 3.1.4.1 ( 7b9e31d1-670e-4fc5-ad54-9ffff50755f9 ).
	//
	// * When the *NETLOGON_CREDENTIAL* is used as part of a *NETLOGON_AUTHENTICATOR* structure
	// (section 2.2.1.1.5 ( 76c93227-942a-4687-ab9d-9d972ffabdab ) ), the data field carries
	// 8 bytes of encrypted data, as specified in the *Netlogon Credential Computation*
	// (section 3.1.4.4 ( 594909fd-725f-45ac-9799-62e4aefe0585 ) ) ** and *Netlogon Authenticator
	// Computation and Verification* (section 3.1.4.5 ( da7acaa3-030b-481e-979b-f58f89389806
	// ) ) sections.
	Data []byte `idl:"name:data" json:"data"`
}

func (o *Credential) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *Credential) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	for i1 := range o.Data {
		i1 := i1
		if uint64(i1) >= 8 {
			break
		}
		if err := w.WriteData(o.Data[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Data); uint64(i1) < 8; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	return nil
}
func (o *Credential) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	o.Data = make([]byte, 8)
	for i1 := range o.Data {
		i1 := i1
		if err := w.ReadData(&o.Data[i1]); err != nil {
			return err
		}
	}
	return nil
}

// Authenticator structure represents NETLOGON_AUTHENTICATOR RPC structure.
//
// The NETLOGON_AUTHENTICATOR structure defines an authentication credential.
type Authenticator struct {
	// Credential: A NETLOGON_CREDENTIAL (section 2.2.1.3.4) structure that contains the
	// encrypted portion of the authenticator.
	Credential *Credential `idl:"name:Credential" json:"credential"`
	// Timestamp: An integer value that contains the time of day at which the client constructed
	// this authentication credential, represented as the number of elapsed seconds since
	// 00:00:00 of January 1, 1970. The authenticator is constructed just before making
	// a call to a method that requires its usage.
	Timestamp uint32 `idl:"name:Timestamp" json:"timestamp"`
}

func (o *Authenticator) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *Authenticator) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if o.Credential != nil {
		if err := o.Credential.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&Credential{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Timestamp); err != nil {
		return err
	}
	return nil
}
func (o *Authenticator) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if o.Credential == nil {
		o.Credential = &Credential{}
	}
	if err := o.Credential.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if err := w.ReadData(&o.Timestamp); err != nil {
		return err
	}
	return nil
}

// SecureChannelType type represents NETLOGON_SECURE_CHANNEL_TYPE RPC enumeration.
//
// The NETLOGON_SECURE_CHANNEL_TYPE enumeration specifies the type of secure channel
// to use in a logon transaction.
type SecureChannelType uint16

var (
	// NullSecureChannel: An unauthenticated channel type. This value MUST NOT be used in
	// the Netlogon RPC calls between a client and a remote server. The error code STATUS_INVALID_PARAMETER
	// is returned.
	SecureChannelTypeNullSecureChannel SecureChannelType = 0
	// MsvApSecureChannel: A secure channel between the local NT LAN Manager (NTLM) security
	// provider and the Netlogon server. The client and the server are the same machine
	// for this channel type. This value MUST NOT be used in the Netlogon RPC calls between
	// a client and a remote server. The error code STATUS_INVALID_PARAMETER is returned.
	SecureChannelTypeMsvApSecureChannel SecureChannelType = 1
	// WorkstationSecureChannel: A secure channel from a domain member to a DC.
	SecureChannelTypeWorkstationSecureChannel SecureChannelType = 2
	// TrustedDnsDomainSecureChannel: A secure channel between two DCs, connected through
	// a trust relationship created between two Active Directory domains. A trusted domain
	// object (TDO) is used in this type of channel.
	SecureChannelTypeTrustedDNSDomainSecureChannel SecureChannelType = 3
	// TrustedDomainSecureChannel: A secure channel between two DCs, connected through a
	// trust relationship created between two domains.<31>
	SecureChannelTypeTrustedDomainSecureChannel SecureChannelType = 4
	// UasServerSecureChannel: Secure channel from a LAN Manager server to a DC. This value
	// is no longer supported, and it MUST NOT be used in the Netlogon RPC calls between
	// a client and a remote server. The error code STATUS_INVALID_PARAMETER is returned.
	SecureChannelTypeUASServerSecureChannel SecureChannelType = 5
	// ServerSecureChannel: A secure channel from a backup domain controller to a primary
	// domain controller.
	SecureChannelTypeServerSecureChannel SecureChannelType = 6
	// CdcServerSecureChannel: A secure channel from a read-only domain controller (RODC)
	// to a domain controller.<32>
	SecureChannelTypeCDCServerSecureChannel SecureChannelType = 7
)

func (o SecureChannelType) String() string {
	switch o {
	case SecureChannelTypeNullSecureChannel:
		return "SecureChannelTypeNullSecureChannel"
	case SecureChannelTypeMsvApSecureChannel:
		return "SecureChannelTypeMsvApSecureChannel"
	case SecureChannelTypeWorkstationSecureChannel:
		return "SecureChannelTypeWorkstationSecureChannel"
	case SecureChannelTypeTrustedDNSDomainSecureChannel:
		return "SecureChannelTypeTrustedDNSDomainSecureChannel"
	case SecureChannelTypeTrustedDomainSecureChannel:
		return "SecureChannelTypeTrustedDomainSecureChannel"
	case SecureChannelTypeUASServerSecureChannel:
		return "SecureChannelTypeUASServerSecureChannel"
	case SecureChannelTypeServerSecureChannel:
		return "SecureChannelTypeServerSecureChannel"
	case SecureChannelTypeCDCServerSecureChannel:
		return "SecureChannelTypeCDCServerSecureChannel"
	}
	return "Invalid"
}

// UASInfo0 structure represents UAS_INFO_0 RPC structure.
//
// The UAS_INFO_0 structure was for the support of LAN Manager products and is beyond
// the scope of this document.
type UASInfo0 struct {
	ComputerName []byte `idl:"name:ComputerName" json:"computer_name"`
	TimeCreated  uint32 `idl:"name:TimeCreated" json:"time_created"`
	SerialNumber uint32 `idl:"name:SerialNumber" json:"serial_number"`
}

func (o *UASInfo0) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *UASInfo0) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	for i1 := range o.ComputerName {
		i1 := i1
		if uint64(i1) >= 16 {
			break
		}
		if err := w.WriteData(o.ComputerName[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.ComputerName); uint64(i1) < 16; i1++ {
		if err := w.WriteData(uint8(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.TimeCreated); err != nil {
		return err
	}
	if err := w.WriteData(o.SerialNumber); err != nil {
		return err
	}
	return nil
}
func (o *UASInfo0) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	o.ComputerName = make([]byte, 16)
	for i1 := range o.ComputerName {
		i1 := i1
		if err := w.ReadData(&o.ComputerName[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.TimeCreated); err != nil {
		return err
	}
	if err := w.ReadData(&o.SerialNumber); err != nil {
		return err
	}
	return nil
}

// DomainControllerInfoW structure represents DOMAIN_CONTROLLER_INFOW RPC structure.
//
// The DOMAIN_CONTROLLER_INFOW structure SHOULD<8> define information returned by the
// following methods: DsrGetDcName (section 3.5.4.3.3), DsrGetDcNameEx (section 3.5.4.3.2),
// and DsrGetDcNameEx2 (section 3.5.4.3.1). This structure is used to describe naming
// and addressing information about a DC.
type DomainControllerInfoW struct {
	// DomainControllerName: A pointer to a null-terminated UTF-16 string that contains
	// a NetBIOS or fully qualified domain name (FQDN) of the DC, prefixed with "\\".
	DomainControllerName string `idl:"name:DomainControllerName;string;pointer:unique" json:"domain_controller_name"`
	// DomainControllerAddress: A pointer to a null-terminated Unicode string that contains
	// the DC address, prefixed with "\\". The string SHOULD<9> be either a textual representation
	// of an IPv4/IPv6 address or the NetBIOS name of the DC, determined by the DomainControllerAddressType
	// field.
	DomainControllerAddress string `idl:"name:DomainControllerAddress;string;pointer:unique" json:"domain_controller_address"`
	// DomainControllerAddressType: A 32-bit value indicating the DC address type, which
	// MUST be one, and only one, of the following.
	//
	//	+------------+----------------------------------------------------------------------------------+
	//	|            |                                                                                  |
	//	|   VALUE    |                                     MEANING                                      |
	//	|            |                                                                                  |
	//	+------------+----------------------------------------------------------------------------------+
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00000001 | The address is a string that contains an IPv4 address in dotted-decimal notation |
	//	|            | (for example, 192.168.0.1), or an IPv6 address in colon-separated notation.<10>  |
	//	+------------+----------------------------------------------------------------------------------+
	//	| 0x00000002 | The address is a NetBIOS name.                                                   |
	//	+------------+----------------------------------------------------------------------------------+
	DomainControllerAddressType uint32 `idl:"name:DomainControllerAddressType" json:"domain_controller_address_type"`
	// DomainGuid: A globally unique identifier (GUID) structure ([MS-DTYP] section 2.3.4.1)
	// that contains an identifier for the domain. When there is no domain GUID, this field
	// MUST be set to zero. A GUID SHOULD<11> be used across all computers and networks
	// wherever a unique identifier is required.
	DomainGUID *dtyp.GUID `idl:"name:DomainGuid" json:"domain_guid"`
	// DomainName: A pointer to a Unicode string that contains the NetBIOS or FQDN of the
	// domain.
	DomainName string `idl:"name:DomainName;string;pointer:unique" json:"domain_name"`
	// DnsForestName: A pointer to a null-terminated Unicode string that contains the FQDN
	// of the forest.
	DNSForestName string `idl:"name:DnsForestName;string;pointer:unique" json:"dns_forest_name"`
	// Flags: A set of bit flags in little-endian format that describe the features and
	// roles of the DC. A flag is TRUE (or set) if its value is equal to 1. The value is
	// constructed from zero or more bit flags from the following table, with the exceptions
	// that bit J cannot be combined with A, B, D, E, or P; bit F cannot be combined with
	// I; and bit K cannot be combined with L.
	//
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
	//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| O | N | M | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | T | S | R | Q | P | L | K | J | I | H | G | F | E | D | C | B | 0 | A |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//
	// Where the bits are defined as:
	//
	//	+-------+----------------------------------------------------------------------------------+
	//	|       |                                                                                  |
	//	| VALUE |                                   DESCRIPTION                                    |
	//	|       |                                                                                  |
	//	+-------+----------------------------------------------------------------------------------+
	//	+-------+----------------------------------------------------------------------------------+
	//	| A     | The DC is the domain's primary domain controller (PDC).                          |
	//	+-------+----------------------------------------------------------------------------------+
	//	| B     | The DC contains the global catalog (GC) for the forest Active Directory.         |
	//	+-------+----------------------------------------------------------------------------------+
	//	| C     | The DC supports the Lightweight Directory Access Protocol (LDAP).                |
	//	+-------+----------------------------------------------------------------------------------+
	//	| D     | The DC supports a directory service.                                             |
	//	+-------+----------------------------------------------------------------------------------+
	//	| E     | The DC is a Kerberos Key Distribution Center (KDC).                              |
	//	+-------+----------------------------------------------------------------------------------+
	//	| F     | The DC has a network time service available but no clock hardware.               |
	//	+-------+----------------------------------------------------------------------------------+
	//	| G     | The DC is in the closest site to the client.                                     |
	//	+-------+----------------------------------------------------------------------------------+
	//	| H     | The DC has a writable directory service available.                               |
	//	+-------+----------------------------------------------------------------------------------+
	//	| I     | The DC has clock hardware and a network time service available.                  |
	//	+-------+----------------------------------------------------------------------------------+
	//	| J     | The DC is an LDAP server servicing an Application naming context (NC) ([MS-ADTS] |
	//	|       | section 3.1.1.1.5).                                                              |
	//	+-------+----------------------------------------------------------------------------------+
	//	| K     | The DC is a read-only domain controller (RODC).<12>                              |
	//	+-------+----------------------------------------------------------------------------------+
	//	| L     | The server is a writable domain controller.<13>                                  |
	//	+-------+----------------------------------------------------------------------------------+
	//	| M     | The DC's name is a DNS name.                                                     |
	//	+-------+----------------------------------------------------------------------------------+
	//	| N     | The DC's domain name is a DNS name.                                              |
	//	+-------+----------------------------------------------------------------------------------+
	//	| O     | The DC's forest name is a DNS name.                                              |
	//	+-------+----------------------------------------------------------------------------------+
	//	| P     | The DC has an Active Directory Web Service available.<14>                        |
	//	+-------+----------------------------------------------------------------------------------+
	//	| Q     | The DC has a functional level of DS_BEHAVIOR_WIN2012 or later.                   |
	//	+-------+----------------------------------------------------------------------------------+
	//	| R     | The DC has a functional level of DS_BEHAVIOR_WIN2012R2 or later.                 |
	//	+-------+----------------------------------------------------------------------------------+
	//	| S     | The DC has a functional level of DS_BEHAVIOR_WIN2016 or later.                   |
	//	+-------+----------------------------------------------------------------------------------+
	//	| T     | The DC supports key list requests, as specified in [MS-KILE] section 2.2.11. If  |
	//	|       | this bit is set, bit S and bit E MUST also be set.                               |
	//	+-------+----------------------------------------------------------------------------------+
	Flags uint32 `idl:"name:Flags" json:"flags"`
	// DcSiteName: A pointer to a null-terminated Unicode string that SHOULD<15> contain
	// the site name that is associated with the DC. When there is no associated site, this
	// field MUST be NULL.
	DCSiteName string `idl:"name:DcSiteName;string;pointer:unique" json:"dc_site_name"`
	// ClientSiteName: A pointer to a null-terminated Unicode string that contains the client's
	// site name. When there is no client site name, this field MUST be NULL.
	ClientSiteName string `idl:"name:ClientSiteName;string;pointer:unique" json:"client_site_name"`
}

func (o *DomainControllerInfoW) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *DomainControllerInfoW) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if o.DomainControllerName != "" {
		_ptr_DomainControllerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.DomainControllerName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.DomainControllerName, _ptr_DomainControllerName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.DomainControllerAddress != "" {
		_ptr_DomainControllerAddress := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.DomainControllerAddress); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.DomainControllerAddress, _ptr_DomainControllerAddress); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.DomainControllerAddressType); err != nil {
		return err
	}
	if o.DomainGUID != nil {
		if err := o.DomainGUID.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.DomainName != "" {
		_ptr_DomainName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.DomainName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.DomainName, _ptr_DomainName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.DNSForestName != "" {
		_ptr_DnsForestName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.DNSForestName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.DNSForestName, _ptr_DnsForestName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	if o.DCSiteName != "" {
		_ptr_DcSiteName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.DCSiteName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.DCSiteName, _ptr_DcSiteName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.ClientSiteName != "" {
		_ptr_ClientSiteName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.ClientSiteName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ClientSiteName, _ptr_ClientSiteName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *DomainControllerInfoW) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	_ptr_DomainControllerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.DomainControllerName); err != nil {
			return err
		}
		return nil
	})
	_s_DomainControllerName := func(ptr interface{}) { o.DomainControllerName = *ptr.(*string) }
	if err := w.ReadPointer(&o.DomainControllerName, _s_DomainControllerName, _ptr_DomainControllerName); err != nil {
		return err
	}
	_ptr_DomainControllerAddress := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.DomainControllerAddress); err != nil {
			return err
		}
		return nil
	})
	_s_DomainControllerAddress := func(ptr interface{}) { o.DomainControllerAddress = *ptr.(*string) }
	if err := w.ReadPointer(&o.DomainControllerAddress, _s_DomainControllerAddress, _ptr_DomainControllerAddress); err != nil {
		return err
	}
	if err := w.ReadData(&o.DomainControllerAddressType); err != nil {
		return err
	}
	if o.DomainGUID == nil {
		o.DomainGUID = &dtyp.GUID{}
	}
	if err := o.DomainGUID.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	_ptr_DomainName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.DomainName); err != nil {
			return err
		}
		return nil
	})
	_s_DomainName := func(ptr interface{}) { o.DomainName = *ptr.(*string) }
	if err := w.ReadPointer(&o.DomainName, _s_DomainName, _ptr_DomainName); err != nil {
		return err
	}
	_ptr_DnsForestName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.DNSForestName); err != nil {
			return err
		}
		return nil
	})
	_s_DnsForestName := func(ptr interface{}) { o.DNSForestName = *ptr.(*string) }
	if err := w.ReadPointer(&o.DNSForestName, _s_DnsForestName, _ptr_DnsForestName); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	_ptr_DcSiteName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.DCSiteName); err != nil {
			return err
		}
		return nil
	})
	_s_DcSiteName := func(ptr interface{}) { o.DCSiteName = *ptr.(*string) }
	if err := w.ReadPointer(&o.DCSiteName, _s_DcSiteName, _ptr_DcSiteName); err != nil {
		return err
	}
	_ptr_ClientSiteName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.ClientSiteName); err != nil {
			return err
		}
		return nil
	})
	_s_ClientSiteName := func(ptr interface{}) { o.ClientSiteName = *ptr.(*string) }
	if err := w.ReadPointer(&o.ClientSiteName, _s_ClientSiteName, _ptr_ClientSiteName); err != nil {
		return err
	}
	return nil
}

// TrustPassword structure represents NL_TRUST_PASSWORD RPC structure.
//
// The NL_TRUST_PASSWORD structure defines a buffer for carrying a computer account
// password, or a trust password, to be transmitted over the wire. It SHOULD<23> be
// transported as an input parameter to the NetrServerPasswordSet2 method, as specified
// in section 3.5.4.4.5. Domain members use NetrServerPasswordSet2 to change their computer
// account password. The primary domain controller uses NetrServerPasswordSet2 to change
// trust passwords for all directly trusted domains. The NL_TRUST_PASSWORD structure
// is encrypted using the negotiated encryption algorithm before it is sent over the
// wire.<24>
type TrustPassword struct {
	// Buffer: Array of Unicode characters that is treated as a byte buffer containing the
	// password, as follows:
	//
	// * For a computer account password, the buffer has the following format:
	//
	// [Computer account password buffer format](ms-nrpc_files/image004.png)
	//
	// Figure 4: Computer account password buffer format
	//
	// * For a domain trust password, the buffer has the following format:
	//
	// [Domain trust password buffer format](ms-nrpc_files/image005.png)
	//
	// Figure 5: Domain trust password buffer format
	//
	// * The *PasswordVersion* part of the preceding diagram has the following format:
	//
	// [Password version buffer format](ms-nrpc_files/image006.png)
	//
	// Figure 6: Password version buffer format
	Buffer []uint16 `idl:"name:Buffer" json:"buffer"`
	// Length: The length of the password, in bytes.
	Length uint32 `idl:"name:Length" json:"length"`
}

func (o *TrustPassword) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *TrustPassword) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	for i1 := range o.Buffer {
		i1 := i1
		if uint64(i1) >= 256 {
			break
		}
		if err := w.WriteData(o.Buffer[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.Buffer); uint64(i1) < 256; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.Length); err != nil {
		return err
	}
	return nil
}
func (o *TrustPassword) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	o.Buffer = make([]uint16, 256)
	for i1 := range o.Buffer {
		i1 := i1
		if err := w.ReadData(&o.Buffer[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.Length); err != nil {
		return err
	}
	return nil
}

// PasswordVersion structure represents NL_PASSWORD_VERSION RPC structure.
//
// The NL_PASSWORD_VERSION structure defines a password version number that is used
// to distinguish between different versions of information passed in the Buffer field
// of the NL_TRUST_PASSWORD structure (section 2.2.1.3.7). The NL_PASSWORD_VERSION structure
// SHOULD<25> be prepended to the password in the buffer of NL_TRUST_PASSWORD and is
// only used for interdomain trust accounts.
type PasswordVersion struct {
	// ReservedField: MUST be set to zero when sent and MUST be ignored on receipt.
	_ uint32 `idl:"name:ReservedField"`
	// PasswordVersionNumber: Integer value that contains the current password version number.
	// The password version number is incremented by one when a new password is generated;
	// the value for the first password is one.
	PasswordVersionNumber uint32 `idl:"name:PasswordVersionNumber" json:"password_version_number"`
	// PasswordVersionPresent: MUST be 0x02231968, which is a constant used to indicate
	// that the password version number is present and is stored in PasswordVersionNumber
	// field. This member is relevant only for server-to-server communication.
	PasswordVersionPresent uint32 `idl:"name:PasswordVersionPresent" json:"password_version_present"`
}

func (o *PasswordVersion) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *PasswordVersion) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	// reserved ReservedField
	if err := w.WriteData(uint32(0)); err != nil {
		return err
	}
	if err := w.WriteData(o.PasswordVersionNumber); err != nil {
		return err
	}
	if err := w.WriteData(o.PasswordVersionPresent); err != nil {
		return err
	}
	return nil
}
func (o *PasswordVersion) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	// reserved ReservedField
	var _ReservedField uint32
	if err := w.ReadData(&_ReservedField); err != nil {
		return err
	}
	if err := w.ReadData(&o.PasswordVersionNumber); err != nil {
		return err
	}
	if err := w.ReadData(&o.PasswordVersionPresent); err != nil {
		return err
	}
	return nil
}

// ForestTrustRecordType type represents LSA_FOREST_TRUST_RECORD_TYPE RPC enumeration.
type ForestTrustRecordType uint16

var (
	ForestTrustRecordTypeTopLevelName   ForestTrustRecordType = 0
	ForestTrustRecordTypeTopLevelNameEx ForestTrustRecordType = 1
	ForestTrustRecordTypeDomainInfo     ForestTrustRecordType = 2
	ForestTrustRecordTypeLast           ForestTrustRecordType = 2
)

func (o ForestTrustRecordType) String() string {
	switch o {
	case ForestTrustRecordTypeTopLevelName:
		return "ForestTrustRecordTypeTopLevelName"
	case ForestTrustRecordTypeTopLevelNameEx:
		return "ForestTrustRecordTypeTopLevelNameEx"
	case ForestTrustRecordTypeDomainInfo:
		return "ForestTrustRecordTypeDomainInfo"
	case ForestTrustRecordTypeLast:
		return "ForestTrustRecordTypeLast"
	}
	return "Invalid"
}

// UnicodeString structure represents LSA_RPC_UNICODE_STRING RPC structure.
type UnicodeString dtyp.UnicodeString

func (o *UnicodeString) UnicodeString() *dtyp.UnicodeString { return (*dtyp.UnicodeString)(o) }

func (o *UnicodeString) xxx_PreparePayload(ctx context.Context) error {
	if o.Buffer != "" && o.MaximumLength == 0 {
		o.MaximumLength = uint16((len(o.Buffer) * 2))
	}
	if o.Buffer != "" && o.Length == 0 {
		o.Length = uint16((len(o.Buffer) * 2))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *UnicodeString) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(7); err != nil {
		return err
	}
	if err := w.WriteData(o.Length); err != nil {
		return err
	}
	if err := w.WriteData(o.MaximumLength); err != nil {
		return err
	}
	if o.Buffer != "" || (o.MaximumLength/2) > 0 {
		_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64((o.MaximumLength / 2))
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			dimLength1 := uint64((o.Length / 2))
			if dimLength1 > sizeInfo[0] {
				dimLength1 = sizeInfo[0]
			} else {
				sizeInfo[0] = dimLength1
			}
			if err := w.WriteSize(0); err != nil {
				return err
			}
			if err := w.WriteSize(dimLength1); err != nil {
				return err
			}
			_Buffer_buf := utf16.Encode([]rune(o.Buffer))
			if uint64(len(_Buffer_buf)) > sizeInfo[0] {
				_Buffer_buf = _Buffer_buf[:sizeInfo[0]]
			}
			for i1 := range _Buffer_buf {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(_Buffer_buf[i1]); err != nil {
					return err
				}
			}
			for i1 := len(_Buffer_buf); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint16(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *UnicodeString) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(7); err != nil {
		return err
	}
	if err := w.ReadData(&o.Length); err != nil {
		return err
	}
	if err := w.ReadData(&o.MaximumLength); err != nil {
		return err
	}
	_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		var _Buffer_buf []uint16
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array _Buffer_buf", sizeInfo[0])
		}
		_Buffer_buf = make([]uint16, sizeInfo[0])
		for i1 := range _Buffer_buf {
			i1 := i1
			if err := w.ReadData(&_Buffer_buf[i1]); err != nil {
				return err
			}
		}
		o.Buffer = strings.TrimRight(string(utf16.Decode(_Buffer_buf)), ndr.ZeroString)
		return nil
	})
	_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*string) }
	if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
		return err
	}
	return nil
}

// ForestTrustDomainInfo structure represents LSA_FOREST_TRUST_DOMAIN_INFO RPC structure.
type ForestTrustDomainInfo struct {
	SID         *dtyp.SID      `idl:"name:Sid" json:"sid"`
	DNSName     *UnicodeString `idl:"name:DnsName" json:"dns_name"`
	NetBIOSName *UnicodeString `idl:"name:NetbiosName" json:"netbios_name"`
}

func (o *ForestTrustDomainInfo) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ForestTrustDomainInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(7); err != nil {
		return err
	}
	if o.SID != nil {
		_ptr_Sid := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.SID != nil {
				if err := o.SID.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&dtyp.SID{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.SID, _ptr_Sid); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.DNSName != nil {
		if err := o.DNSName.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	if o.NetBIOSName != nil {
		if err := o.NetBIOSName.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *ForestTrustDomainInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(7); err != nil {
		return err
	}
	_ptr_Sid := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.SID == nil {
			o.SID = &dtyp.SID{}
		}
		if err := o.SID.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_Sid := func(ptr interface{}) { o.SID = *ptr.(**dtyp.SID) }
	if err := w.ReadPointer(&o.SID, _s_Sid, _ptr_Sid); err != nil {
		return err
	}
	if o.DNSName == nil {
		o.DNSName = &UnicodeString{}
	}
	if err := o.DNSName.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.NetBIOSName == nil {
		o.NetBIOSName = &UnicodeString{}
	}
	if err := o.NetBIOSName.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// ForestTrustBinaryData structure represents LSA_FOREST_TRUST_BINARY_DATA RPC structure.
type ForestTrustBinaryData struct {
	Length uint32 `idl:"name:Length" json:"length"`
	Buffer []byte `idl:"name:Buffer;size_is:(Length)" json:"buffer"`
}

func (o *ForestTrustBinaryData) xxx_PreparePayload(ctx context.Context) error {
	if o.Buffer != nil && o.Length == 0 {
		o.Length = uint32(len(o.Buffer))
	}
	if o.Length > uint32(131072) {
		return fmt.Errorf("Length is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ForestTrustBinaryData) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.Length); err != nil {
		return err
	}
	if o.Buffer != nil || o.Length > 0 {
		_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.Length)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Buffer {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if err := w.WriteData(o.Buffer[i1]); err != nil {
					return err
				}
			}
			for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WriteData(uint8(0)); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ForestTrustBinaryData) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.Length); err != nil {
		return err
	}
	_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.Length > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.Length)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
		}
		o.Buffer = make([]byte, sizeInfo[0])
		for i1 := range o.Buffer {
			i1 := i1
			if err := w.ReadData(&o.Buffer[i1]); err != nil {
				return err
			}
		}
		return nil
	})
	_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*[]byte) }
	if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
		return err
	}
	return nil
}

// ForestTrustRecord structure represents LSA_FOREST_TRUST_RECORD RPC structure.
type ForestTrustRecord struct {
	Flags           uint32                             `idl:"name:Flags" json:"flags"`
	ForestTrustType ForestTrustRecordType              `idl:"name:ForestTrustType" json:"forest_trust_type"`
	Time            *dtyp.LargeInteger                 `idl:"name:Time" json:"time"`
	ForestTrustData *ForestTrustRecord_ForestTrustData `idl:"name:ForestTrustData;switch_is:ForestTrustType" json:"forest_trust_data"`
}

func (o *ForestTrustRecord) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ForestTrustRecord) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(8); err != nil {
		return err
	}
	if err := w.WriteData(o.Flags); err != nil {
		return err
	}
	if err := w.WriteEnum(uint16(o.ForestTrustType)); err != nil {
		return err
	}
	if o.Time != nil {
		if err := o.Time.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&dtyp.LargeInteger{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	_swForestTrustData := uint16(o.ForestTrustType)
	if o.ForestTrustData != nil {
		if err := o.ForestTrustData.MarshalUnionNDR(ctx, w, _swForestTrustData); err != nil {
			return err
		}
	} else {
		if err := (&ForestTrustRecord_ForestTrustData{}).MarshalUnionNDR(ctx, w, _swForestTrustData); err != nil {
			return err
		}
	}
	return nil
}
func (o *ForestTrustRecord) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(8); err != nil {
		return err
	}
	if err := w.ReadData(&o.Flags); err != nil {
		return err
	}
	if err := w.ReadEnum((*uint16)(&o.ForestTrustType)); err != nil {
		return err
	}
	if o.Time == nil {
		o.Time = &dtyp.LargeInteger{}
	}
	if err := o.Time.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	if o.ForestTrustData == nil {
		o.ForestTrustData = &ForestTrustRecord_ForestTrustData{}
	}
	_swForestTrustData := uint16(o.ForestTrustType)
	if err := o.ForestTrustData.UnmarshalUnionNDR(ctx, w, _swForestTrustData); err != nil {
		return err
	}
	return nil
}

// ForestTrustRecord_ForestTrustData structure represents LSA_FOREST_TRUST_RECORD union anonymous member.
type ForestTrustRecord_ForestTrustData struct {
	// Types that are assignable to Value
	//
	// *ForestTrustData_TopLevelName
	// *ForestTrustData_DomainInfo
	// *ForestTrustData_Data
	Value is_ForestTrustRecord_ForestTrustData `json:"value"`
}

func (o *ForestTrustRecord_ForestTrustData) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *ForestTrustData_TopLevelName:
		if value != nil {
			return value.TopLevelName
		}
	case *ForestTrustData_DomainInfo:
		if value != nil {
			return value.DomainInfo
		}
	case *ForestTrustData_Data:
		if value != nil {
			return value.Data
		}
	}
	return nil
}

type is_ForestTrustRecord_ForestTrustData interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_ForestTrustRecord_ForestTrustData()
}

func (o *ForestTrustRecord_ForestTrustData) NDRSwitchValue(sw uint16) uint16 {
	if o == nil {
		return uint16(0)
	}
	switch (interface{})(o.Value).(type) {
	case *ForestTrustData_TopLevelName:
		switch sw {
		case uint16(0),
			uint16(1):
			return sw
		}
		return uint16(0)
	case *ForestTrustData_DomainInfo:
		return uint16(2)
	}
	return uint16(0)
}

func (o *ForestTrustRecord_ForestTrustData) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint16) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(ndr.Enum(uint16(sw))); err != nil {
		return err
	}
	// ms_union
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint16(0),
		uint16(1):
		_o, _ := o.Value.(*ForestTrustData_TopLevelName)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ForestTrustData_TopLevelName{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	case uint16(2):
		_o, _ := o.Value.(*ForestTrustData_DomainInfo)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ForestTrustData_DomainInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		_o, _ := o.Value.(*ForestTrustData_Data)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ForestTrustData_Data{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *ForestTrustRecord_ForestTrustData) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint16) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch(ndr.Enum((*uint16)(&sw))); err != nil {
		return err
	}
	// ms_union
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint16(0),
		uint16(1):
		o.Value = &ForestTrustData_TopLevelName{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	case uint16(2):
		o.Value = &ForestTrustData_DomainInfo{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		o.Value = &ForestTrustData_Data{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

// ForestTrustData_TopLevelName structure represents ForestTrustRecord_ForestTrustData RPC union arm.
//
// It has following labels: 0, 1
type ForestTrustData_TopLevelName struct {
	TopLevelName *UnicodeString `idl:"name:TopLevelName" json:"top_level_name"`
}

func (*ForestTrustData_TopLevelName) is_ForestTrustRecord_ForestTrustData() {}

func (o *ForestTrustData_TopLevelName) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.TopLevelName != nil {
		if err := o.TopLevelName.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&UnicodeString{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *ForestTrustData_TopLevelName) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.TopLevelName == nil {
		o.TopLevelName = &UnicodeString{}
	}
	if err := o.TopLevelName.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// ForestTrustData_DomainInfo structure represents ForestTrustRecord_ForestTrustData RPC union arm.
//
// It has following labels: 2
type ForestTrustData_DomainInfo struct {
	DomainInfo *ForestTrustDomainInfo `idl:"name:DomainInfo" json:"domain_info"`
}

func (*ForestTrustData_DomainInfo) is_ForestTrustRecord_ForestTrustData() {}

func (o *ForestTrustData_DomainInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.DomainInfo != nil {
		if err := o.DomainInfo.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ForestTrustDomainInfo{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *ForestTrustData_DomainInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.DomainInfo == nil {
		o.DomainInfo = &ForestTrustDomainInfo{}
	}
	if err := o.DomainInfo.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// ForestTrustData_Data structure represents ForestTrustRecord_ForestTrustData RPC default union arm.
type ForestTrustData_Data struct {
	Data *ForestTrustBinaryData `idl:"name:Data" json:"data"`
}

func (*ForestTrustData_Data) is_ForestTrustRecord_ForestTrustData() {}

func (o *ForestTrustData_Data) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.Data != nil {
		if err := o.Data.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&ForestTrustBinaryData{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *ForestTrustData_Data) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.Data == nil {
		o.Data = &ForestTrustBinaryData{}
	}
	if err := o.Data.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// ForestTrustInformation structure represents LSA_FOREST_TRUST_INFORMATION RPC structure.
type ForestTrustInformation struct {
	RecordCount uint32               `idl:"name:RecordCount" json:"record_count"`
	Entries     []*ForestTrustRecord `idl:"name:Entries;size_is:(RecordCount)" json:"entries"`
}

func (o *ForestTrustInformation) xxx_PreparePayload(ctx context.Context) error {
	if o.Entries != nil && o.RecordCount == 0 {
		o.RecordCount = uint32(len(o.Entries))
	}
	if o.RecordCount > uint32(4000) {
		return fmt.Errorf("RecordCount is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *ForestTrustInformation) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.RecordCount); err != nil {
		return err
	}
	if o.Entries != nil || o.RecordCount > 0 {
		_ptr_Entries := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.RecordCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.Entries {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.Entries[i1] != nil {
					_ptr_Entries := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
						if o.Entries[i1] != nil {
							if err := o.Entries[i1].MarshalNDR(ctx, w); err != nil {
								return err
							}
						} else {
							if err := (&ForestTrustRecord{}).MarshalNDR(ctx, w); err != nil {
								return err
							}
						}
						return nil
					})
					if err := w.WritePointer(&o.Entries[i1], _ptr_Entries); err != nil {
						return err
					}
				} else {
					if err := w.WritePointer(nil); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.Entries); uint64(i1) < sizeInfo[0]; i1++ {
				if err := w.WritePointer(nil); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.Entries, _ptr_Entries); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *ForestTrustInformation) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.RecordCount); err != nil {
		return err
	}
	_ptr_Entries := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.RecordCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.RecordCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Entries", sizeInfo[0])
		}
		o.Entries = make([]*ForestTrustRecord, sizeInfo[0])
		for i1 := range o.Entries {
			i1 := i1
			_ptr_Entries := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
				if o.Entries[i1] == nil {
					o.Entries[i1] = &ForestTrustRecord{}
				}
				if err := o.Entries[i1].UnmarshalNDR(ctx, w); err != nil {
					return err
				}
				return nil
			})
			_s_Entries := func(ptr interface{}) { o.Entries[i1] = *ptr.(**ForestTrustRecord) }
			if err := w.ReadPointer(&o.Entries[i1], _s_Entries, _ptr_Entries); err != nil {
				return err
			}
		}
		return nil
	})
	_s_Entries := func(ptr interface{}) { o.Entries = *ptr.(*[]*ForestTrustRecord) }
	if err := w.ReadPointer(&o.Entries, _s_Entries, _ptr_Entries); err != nil {
		return err
	}
	return nil
}

// DNSNameInfo structure represents NL_DNS_NAME_INFO RPC structure.
//
// The NL_DNS_NAME_INFO structure provides the information on a DNS name (record) (as
// specified in [RFC2782]) to be updated by the DsrUpdateReadOnlyServerDnsRecords method
// (section 3.5.4.3.11). DsrUpdateReadOnlyServerDnsRecords method will update DNS as
// requested by the Register field's value in this structure.
type DNSNameInfo struct {
	// Type: The type of DNS name, which MUST be one, and only one, of the following.
	//
	//	+--------------------------+----------------------------------------------------------------------------------+
	//	|                          |                                                                                  |
	//	|          VALUE           |                                     MEANING                                      |
	//	|                          |                                                                                  |
	//	+--------------------------+----------------------------------------------------------------------------------+
	//	+--------------------------+----------------------------------------------------------------------------------+
	//	| NlDnsLdapAtSite 22       | _ldap._tcp.<SiteName>._sites.<DnsDomainName>. Allows a client to find an LDAP    |
	//	|                          | server in the domain named by <DnsDomainName> and is in the site named by        |
	//	|                          | <SiteName>.                                                                      |
	//	+--------------------------+----------------------------------------------------------------------------------+
	//	| NlDnsGcAtSite 25         | _ldap._tcp.<SiteName>._sites.gc._msdcs.<DnsForestName>. Allows a client to find  |
	//	|                          | a DC serving a global catalog (GC) in the forest named by <DnsForestName> and is |
	//	|                          | in the site named by <SiteName>.                                                 |
	//	+--------------------------+----------------------------------------------------------------------------------+
	//	| NlDnsDsaCname 28         | <DsaGuid>._msdcs.<DnsForestName>. Allows a client to find a DC in the forest     |
	//	|                          | named by <DnsForestName> based on the DSA GUID. For a definition of DSA GUID,    |
	//	|                          | see [MS-ADTS] section 1.1.                                                       |
	//	+--------------------------+----------------------------------------------------------------------------------+
	//	| NlDnsKdcAtSite 30        | _kerberos._tcp.<SiteName>._sites.dc._msdcs.<DnsDomainName>. Allows a client to   |
	//	|                          | find a DC running a Kerberos KDC in the domain named by <DnsDomainName> and is   |
	//	|                          | in the site named by <SiteName>.                                                 |
	//	+--------------------------+----------------------------------------------------------------------------------+
	//	| NlDnsDcAtSite 32         | _ldap._tcp.<SiteName>._sites.dc._msdcs.<DnsDomainName>. Allows a client to       |
	//	|                          | find a DC in the domain named by <DnsDomainName> and is in the site named by     |
	//	|                          | <SiteName>.                                                                      |
	//	+--------------------------+----------------------------------------------------------------------------------+
	//	| NlDnsRfc1510KdcAtSite 34 | _kerberos._tcp.<SiteName>._sites.<DnsDomainName>. Allows a client to find an     |
	//	|                          | RFC-1510 compliant Kerberos KDC in the domain named by <DnsDomainName> and is in |
	//	|                          | the site named by <SiteName>.                                                    |
	//	+--------------------------+----------------------------------------------------------------------------------+
	//	| NlDnsGenericGcAtSite 36  | _gc._tcp.<SiteName>._sites.<DnsForestName>. Allows a client to find a global     |
	//	|                          | catalog (GC) server in the forest named by <DnsForestName> and is in the site    |
	//	|                          | named by <SiteName>.                                                             |
	//	+--------------------------+----------------------------------------------------------------------------------+
	Type uint32 `idl:"name:Type" json:"type"`
	// DnsDomainInfo: The string that will be based on the DnsDomainInfoType field defined
	// below.
	DNSDomainInfo string `idl:"name:DnsDomainInfo;string" json:"dns_domain_info"`
	// DnsDomainInfoType: The type of DnsDomainInfo member, which MUST be one, and only
	// one, of the following:
	//
	//	+------------------------+----------------------------------------------------------------------------------+
	//	|                        |                                                                                  |
	//	|         VALUE          |                                     MEANING                                      |
	//	|                        |                                                                                  |
	//	+------------------------+----------------------------------------------------------------------------------+
	//	+------------------------+----------------------------------------------------------------------------------+
	//	| NlDnsDomainName 1      | The DnsDomainInfo member is a DNS domain name.                                   |
	//	+------------------------+----------------------------------------------------------------------------------+
	//	| NlDnsDomainNameAlias 2 | The DnsDomainInfo member is a DNS domain name alias.                             |
	//	+------------------------+----------------------------------------------------------------------------------+
	//	| NlDnsForestName 3      | The DnsDomainInfo member is a DNS forest name.                                   |
	//	+------------------------+----------------------------------------------------------------------------------+
	//	| NlDnsForestNameAlias 4 | The DnsDomainInfo member is a DNS forest name alias.                             |
	//	+------------------------+----------------------------------------------------------------------------------+
	//	| NlDnsNdncDomainName 5  | The DnsDomainInfo member is a non-domain NC (application NC) name. For a         |
	//	|                        | definition of application NC, see [MS-ADTS] section 1.1.                         |
	//	+------------------------+----------------------------------------------------------------------------------+
	//	| NlDnsRecordName 6      | The DnsDomainInfo member is a DNS record name that is required to be             |
	//	|                        | deregistered. This is valid only for deregistration in which the Register value  |
	//	|                        | is set to FALSE. For the types of DNS record name, see [MS-ADTS] section 6.3.2.  |
	//	+------------------------+----------------------------------------------------------------------------------+
	DNSDomainInfoType uint32 `idl:"name:DnsDomainInfoType" json:"dns_domain_info_type"`
	// Priority: The priority for DNS SRV records.
	Priority uint32 `idl:"name:Priority" json:"priority"`
	// Weight: The weight for DNS SRV records.
	Weight uint32 `idl:"name:Weight" json:"weight"`
	// Port: The port for the DNS SRV record.
	Port uint32 `idl:"name:Port" json:"port"`
	// Register: Zero indicates to deregister the DNS name; other values indicate to register
	// the DNS name.
	Register uint8 `idl:"name:Register" json:"register"`
	// Status: The update status of the DNS name. Status SHOULD<16> be set to 0x00000000
	// on success; otherwise, it contains a nonzero error code.
	Status uint32 `idl:"name:Status" json:"status"`
}

func (o *DNSNameInfo) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *DNSNameInfo) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.Type); err != nil {
		return err
	}
	if o.DNSDomainInfo != "" {
		_ptr_DnsDomainInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.DNSDomainInfo); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.DNSDomainInfo, _ptr_DnsDomainInfo); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.DNSDomainInfoType); err != nil {
		return err
	}
	if err := w.WriteData(o.Priority); err != nil {
		return err
	}
	if err := w.WriteData(o.Weight); err != nil {
		return err
	}
	if err := w.WriteData(o.Port); err != nil {
		return err
	}
	if err := w.WriteData(o.Register); err != nil {
		return err
	}
	if err := w.WriteData(o.Status); err != nil {
		return err
	}
	return nil
}
func (o *DNSNameInfo) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.Type); err != nil {
		return err
	}
	_ptr_DnsDomainInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.DNSDomainInfo); err != nil {
			return err
		}
		return nil
	})
	_s_DnsDomainInfo := func(ptr interface{}) { o.DNSDomainInfo = *ptr.(*string) }
	if err := w.ReadPointer(&o.DNSDomainInfo, _s_DnsDomainInfo, _ptr_DnsDomainInfo); err != nil {
		return err
	}
	if err := w.ReadData(&o.DNSDomainInfoType); err != nil {
		return err
	}
	if err := w.ReadData(&o.Priority); err != nil {
		return err
	}
	if err := w.ReadData(&o.Weight); err != nil {
		return err
	}
	if err := w.ReadData(&o.Port); err != nil {
		return err
	}
	if err := w.ReadData(&o.Register); err != nil {
		return err
	}
	if err := w.ReadData(&o.Status); err != nil {
		return err
	}
	return nil
}

// DNSNameInfoArray structure represents NL_DNS_NAME_INFO_ARRAY RPC structure.
//
// The NL_DNS_NAME_INFO_ARRAY structure provides the information on DNS names (records)
// to be updated by the DsrUpdateReadOnlyServerDnsRecords (section 3.5.4.3.11) method.
type DNSNameInfoArray struct {
	// EntryCount: The number of entries in the DnsNamesInfo field.
	EntryCount uint32 `idl:"name:EntryCount" json:"entry_count"`
	// DnsNamesInfo: A pointer to an array of the NL_DNS_NAME_INFO (section 2.2.1.2.5) structure,
	// which SHOULD<17> contain DNS name information.
	DNSNamesInfo []*DNSNameInfo `idl:"name:DnsNamesInfo;size_is:(EntryCount)" json:"dns_names_info"`
}

func (o *DNSNameInfoArray) xxx_PreparePayload(ctx context.Context) error {
	if o.DNSNamesInfo != nil && o.EntryCount == 0 {
		o.EntryCount = uint32(len(o.DNSNamesInfo))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *DNSNameInfoArray) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	if err := w.WriteData(o.EntryCount); err != nil {
		return err
	}
	if o.DNSNamesInfo != nil || o.EntryCount > 0 {
		_ptr_DnsNamesInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			dimSize1 := uint64(o.EntryCount)
			if err := w.WriteSize(dimSize1); err != nil {
				return err
			}
			sizeInfo := []uint64{
				dimSize1,
			}
			for i1 := range o.DNSNamesInfo {
				i1 := i1
				if uint64(i1) >= sizeInfo[0] {
					break
				}
				if o.DNSNamesInfo[i1] != nil {
					if err := o.DNSNamesInfo[i1].MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&DNSNameInfo{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
			}
			for i1 := len(o.DNSNamesInfo); uint64(i1) < sizeInfo[0]; i1++ {
				if err := (&DNSNameInfo{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.DNSNamesInfo, _ptr_DnsNamesInfo); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *DNSNameInfoArray) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	if err := w.ReadData(&o.EntryCount); err != nil {
		return err
	}
	_ptr_DnsNamesInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		// XXX: for opaque unmarshaling
		if o.EntryCount > 0 && sizeInfo[0] == 0 {
			sizeInfo[0] = uint64(o.EntryCount)
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.DNSNamesInfo", sizeInfo[0])
		}
		o.DNSNamesInfo = make([]*DNSNameInfo, sizeInfo[0])
		for i1 := range o.DNSNamesInfo {
			i1 := i1
			if o.DNSNamesInfo[i1] == nil {
				o.DNSNamesInfo[i1] = &DNSNameInfo{}
			}
			if err := o.DNSNamesInfo[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		return nil
	})
	_s_DnsNamesInfo := func(ptr interface{}) { o.DNSNamesInfo = *ptr.(*[]*DNSNameInfo) }
	if err := w.ReadPointer(&o.DNSNamesInfo, _s_DnsNamesInfo, _ptr_DnsNamesInfo); err != nil {
		return err
	}
	return nil
}

// OSVersionInfoV1 structure represents NL_OSVERSIONINFO_V1 RPC structure.
//
// The NL_OSVERSIONINFO_V1 structure specifies the values used to update the operatingSystemVersion
// and operatingSystem attributes on the client's computer account object in Active
// Directory on a normal (writable) DC.<35>
type OSVersionInfoV1 struct {
	// dwOSVersionInfoSize: The size, in bytes, of this data structure. Set this member
	// to sizeof(NL_OSVERSIONINFO_V1).
	OSVersionInfoSize uint32 `idl:"name:dwOSVersionInfoSize" json:"os_version_info_size"`
	// dwMajorVersion: The implementation-specific major version number of the operating
	// system.<36>
	MajorVersion uint32 `idl:"name:dwMajorVersion" json:"major_version"`
	// dwMinorVersion: The implementation-specific minor version number of the operating
	// system.<37>
	MinorVersion uint32 `idl:"name:dwMinorVersion" json:"minor_version"`
	// dwBuildNumber: The build number of the operating system.
	BuildNumber uint32 `idl:"name:dwBuildNumber" json:"build_number"`
	// dwPlatformId: The operating system platform.<38>
	PlatformID uint32 `idl:"name:dwPlatformId" json:"platform_id"`
	// szCSDVersion: A null-terminated string, such as "Service Pack 3", that indicates
	// the latest service pack installed on the system. If no service pack has been installed,
	// the string is empty.
	CSDVersion []uint16 `idl:"name:szCSDVersion" json:"csd_version"`
	// wServicePackMajor: The major version number of the latest service pack installed
	// on the system. For example, for "Service Pack 3", the major version number is 3.
	// If no service pack has been installed, the value is 0.
	ServicePackMajor uint16 `idl:"name:wServicePackMajor" json:"service_pack_major"`
	// wServicePackMinor: The minor version number of the latest service pack installed
	// on the system. For example, for "Service Pack 3", the minor version number is 0.
	ServicePackMinor uint16 `idl:"name:wServicePackMinor" json:"service_pack_minor"`
	SuiteMask        uint16 `idl:"name:wSuiteMask" json:"suite_mask"`
	// wProductType: Any additional information about the system. This member can be one
	// of the following values.
	//
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	|                                     |                                                                                  |
	//	|                VALUE                |                                     MEANING                                      |
	//	|                                     |                                                                                  |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| VER_NT_DOMAIN_CONTROLLER 0x00000002 | The system is a DC.                                                              |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| VER_NT_SERVER 0x00000003            | The system is a server. Note that a server that is also a DC is reported as      |
	//	|                                     | VER_NT_DOMAIN_CONTROLLER, not VER_NT_SERVER.                                     |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	//	| VER_NT_WORKSTATION 0x00000001       | Identifies the operating system.<39>                                             |
	//	+-------------------------------------+----------------------------------------------------------------------------------+
	ProductType uint8 `idl:"name:wProductType" json:"product_type"`
	// wReserved: Reserved for future use.<40>
	_ uint8 `idl:"name:wReserved"`
}

func (o *OSVersionInfoV1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *OSVersionInfoV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(4); err != nil {
		return err
	}
	if err := w.WriteData(o.OSVersionInfoSize); err != nil {
		return err
	}
	if err := w.WriteData(o.MajorVersion); err != nil {
		return err
	}
	if err := w.WriteData(o.MinorVersion); err != nil {
		return err
	}
	if err := w.WriteData(o.BuildNumber); err != nil {
		return err
	}
	if err := w.WriteData(o.PlatformID); err != nil {
		return err
	}
	for i1 := range o.CSDVersion {
		i1 := i1
		if uint64(i1) >= 128 {
			break
		}
		if err := w.WriteData(o.CSDVersion[i1]); err != nil {
			return err
		}
	}
	for i1 := len(o.CSDVersion); uint64(i1) < 128; i1++ {
		if err := w.WriteData(uint16(0)); err != nil {
			return err
		}
	}
	if err := w.WriteData(o.ServicePackMajor); err != nil {
		return err
	}
	if err := w.WriteData(o.ServicePackMinor); err != nil {
		return err
	}
	if err := w.WriteData(o.SuiteMask); err != nil {
		return err
	}
	if err := w.WriteData(o.ProductType); err != nil {
		return err
	}
	// reserved wReserved
	if err := w.WriteData(uint8(0)); err != nil {
		return err
	}
	return nil
}
func (o *OSVersionInfoV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(4); err != nil {
		return err
	}
	if err := w.ReadData(&o.OSVersionInfoSize); err != nil {
		return err
	}
	if err := w.ReadData(&o.MajorVersion); err != nil {
		return err
	}
	if err := w.ReadData(&o.MinorVersion); err != nil {
		return err
	}
	if err := w.ReadData(&o.BuildNumber); err != nil {
		return err
	}
	if err := w.ReadData(&o.PlatformID); err != nil {
		return err
	}
	o.CSDVersion = make([]uint16, 128)
	for i1 := range o.CSDVersion {
		i1 := i1
		if err := w.ReadData(&o.CSDVersion[i1]); err != nil {
			return err
		}
	}
	if err := w.ReadData(&o.ServicePackMajor); err != nil {
		return err
	}
	if err := w.ReadData(&o.ServicePackMinor); err != nil {
		return err
	}
	if err := w.ReadData(&o.SuiteMask); err != nil {
		return err
	}
	if err := w.ReadData(&o.ProductType); err != nil {
		return err
	}
	// reserved wReserved
	var _wReserved uint8
	if err := w.ReadData(&_wReserved); err != nil {
		return err
	}
	return nil
}

// InChainSetClientAttributesV1 structure represents NL_IN_CHAIN_SET_CLIENT_ATTRIBUTES_V1 RPC structure.
//
// The NL_IN_CHAIN_SET_CLIENT_ATTRIBUTES_V1 structure specifies the values to update
// on the client's computer account object in Active Directory on a normal (writable)
// domain controller.<41>
type InChainSetClientAttributesV1 struct {
	// ClientDnsHostName: A NULL or null-terminated Unicode string that is used to update
	// the attribute dNSHostName on the client's computer account object in Active Directory.
	ClientDNSHostName string `idl:"name:ClientDnsHostName;string;pointer:unique" json:"client_dns_host_name"`
	// OsVersionInfo_V1: If not NULL, the attribute operatingSystemVersion on the client's
	// computer account in Active Directory (using the ABNF Syntax as specified in [RFC2234])
	// is set to:
	//
	// * If OsVersionInfo_V1.dwBuildNumber is 0:
	//
	// operatingSystemVersion = MajorVersion "." MinorVersion
	//
	// MajorVersion = "OsVersionInfo_V1.dwMajorVersion"
	//
	// MinorVersion = "OsVersionInfo_V1.dwMinorVersion"
	//
	// * Otherwise:
	//
	// operatingSystemVersion = MajorVersion "." MinorVersion "."
	//
	// # BuildNumber
	//
	// MajorVersion = "OsVersionInfo_V1.dwMajorVersion"
	//
	// MinorVersion = "OsVersionInfo_V1.dwMinorVersion"
	//
	// BuildNumber = "OsVersionInfo_V1.dwBuildNumber"
	OSVersionInfoV1 *OSVersionInfoV1 `idl:"name:OsVersionInfo_V1;pointer:unique" json:"os_version_info_v1"`
	// OsName: A NULL or a null-terminated Unicode string that SHOULD<42> be used to update
	// the attribute operatingSystem on the client's computer account object in Active Directory.
	OSName string `idl:"name:OsName;string;pointer:unique" json:"os_name"`
}

func (o *InChainSetClientAttributesV1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *InChainSetClientAttributesV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(6); err != nil {
		return err
	}
	if o.ClientDNSHostName != "" {
		_ptr_ClientDnsHostName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.ClientDNSHostName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.ClientDNSHostName, _ptr_ClientDnsHostName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.OSVersionInfoV1 != nil {
		_ptr_OsVersionInfo_V1 := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.OSVersionInfoV1 != nil {
				if err := o.OSVersionInfoV1.MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&OSVersionInfoV1{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.OSVersionInfoV1, _ptr_OsVersionInfo_V1); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.OSName != "" {
		_ptr_OsName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.OSName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.OSName, _ptr_OsName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	return nil
}
func (o *InChainSetClientAttributesV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(6); err != nil {
		return err
	}
	_ptr_ClientDnsHostName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.ClientDNSHostName); err != nil {
			return err
		}
		return nil
	})
	_s_ClientDnsHostName := func(ptr interface{}) { o.ClientDNSHostName = *ptr.(*string) }
	if err := w.ReadPointer(&o.ClientDNSHostName, _s_ClientDnsHostName, _ptr_ClientDnsHostName); err != nil {
		return err
	}
	_ptr_OsVersionInfo_V1 := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if o.OSVersionInfoV1 == nil {
			o.OSVersionInfoV1 = &OSVersionInfoV1{}
		}
		if err := o.OSVersionInfoV1.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		return nil
	})
	_s_OsVersionInfo_V1 := func(ptr interface{}) { o.OSVersionInfoV1 = *ptr.(**OSVersionInfoV1) }
	if err := w.ReadPointer(&o.OSVersionInfoV1, _s_OsVersionInfo_V1, _ptr_OsVersionInfo_V1); err != nil {
		return err
	}
	_ptr_OsName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.OSName); err != nil {
			return err
		}
		return nil
	})
	_s_OsName := func(ptr interface{}) { o.OSName = *ptr.(*string) }
	if err := w.ReadPointer(&o.OSName, _s_OsName, _ptr_OsName); err != nil {
		return err
	}
	return nil
}

// InChainSetClientAttributes structure represents NL_IN_CHAIN_SET_CLIENT_ATTRIBUTES RPC union.
//
// The NL_IN_CHAIN_SET_CLIENT_ATTRIBUTES union defines versioning.
type InChainSetClientAttributes struct {
	// Types that are assignable to Value
	//
	// *InChainSetClientAttributes_V1
	Value is_InChainSetClientAttributes `json:"value"`
}

func (o *InChainSetClientAttributes) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *InChainSetClientAttributes_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_InChainSetClientAttributes interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_InChainSetClientAttributes()
}

func (o *InChainSetClientAttributes) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *InChainSetClientAttributes_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *InChainSetClientAttributes) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*InChainSetClientAttributes_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&InChainSetClientAttributes_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *InChainSetClientAttributes) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &InChainSetClientAttributes_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// InChainSetClientAttributes_V1 structure represents NL_IN_CHAIN_SET_CLIENT_ATTRIBUTES RPC union arm.
//
// It has following labels: 1
type InChainSetClientAttributes_V1 struct {
	// V1: An NL_IN_CHAIN_SET_CLIENT_ATTRIBUTES_V1 (section 2.2.1.3.16) structure.<43>
	V1 *InChainSetClientAttributesV1 `idl:"name:V1" json:"v1"`
}

func (*InChainSetClientAttributes_V1) is_InChainSetClientAttributes() {}

func (o *InChainSetClientAttributes_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&InChainSetClientAttributesV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *InChainSetClientAttributes_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &InChainSetClientAttributesV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

// OutChainSetClientAttributesV1 structure represents NL_OUT_CHAIN_SET_CLIENT_ATTRIBUTES_V1 RPC structure.
//
// The NL_OUT_CHAIN_SET_CLIENT_ATTRIBUTES_V1 structure SHOULD<44> specify the values
// returned from the normal (writable) DC.
type OutChainSetClientAttributesV1 struct {
	// HubName: The NetBIOS name of the writable domain controller receiving NetrChainSetClientAttributes
	// (section 3.5.4.4.11). The read-only domain controller (RODC) that invoked the method
	// NetrChainSetClientAttributes SHOULD<45> attempt to replicate the computer account
	// object from HubName to itself, ignoring errors.
	HubName string `idl:"name:HubName;string;pointer:unique" json:"hub_name"`
	// OldDnsHostName: The client's DNS host name, if any, from the dNSHostName attribute
	// ([MS-ADA1] section 2.185) on the client's computer account object in Active Directory
	// on the writable domain controller. If there was an update to the dNSHostName attribute
	// by the writable domain controller as a result of receiving NetrChainSetClientAttributes,
	// this value will hold the previous value of that attribute.
	OldDNSHostName string `idl:"name:OldDnsHostName;string;pointer:unique" json:"old_dns_host_name"`
	// SupportedEncTypes: The supported encryption algorithms received from the NetrLogonGetDomainInfo
	// request, in the SupportedEncTypes field in the NETLOGON_DOMAIN_INFO (section 2.2.1.3.11)
	// structure.<46>
	SupportedEncTypes uint32 `idl:"name:SupportedEncTypes;pointer:unique" json:"supported_enc_types"`
}

func (o *OutChainSetClientAttributesV1) xxx_PreparePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPreparePayload(context.Context) error }); ok {
		if err := hook.AfterPreparePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}
func (o *OutChainSetClientAttributesV1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PreparePayload(ctx); err != nil {
		return err
	}
	if err := w.WriteAlign(6); err != nil {
		return err
	}
	if o.HubName != "" {
		_ptr_HubName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if err := ndr.WriteUTF16NString(ctx, w, o.HubName); err != nil {
				return err
			}
			return nil
		})
		if err := w.WritePointer(&o.HubName, _ptr_HubName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	if o.OldDNSHostName != "" {
		_ptr_OldDnsHostName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
			if o.OldDNSHostName != "" {
				_ptr_OldDnsHostName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
					if err := ndr.WriteUTF16NString(ctx, w, o.OldDNSHostName); err != nil {
						return err
					}
					return nil
				})
				if err := w.WritePointer(&o.OldDNSHostName, _ptr_OldDnsHostName); err != nil {
					return err
				}
			} else {
				if err := w.WritePointer(nil); err != nil {
					return err
				}
			}
			return nil
		})
		if err := w.WritePointer(&o.OldDNSHostName, _ptr_OldDnsHostName); err != nil {
			return err
		}
	} else {
		if err := w.WritePointer(nil); err != nil {
			return err
		}
	}
	// XXX pointer to primitive type, default behavior is to write non-null pointer.
	// if this behavior is not desired, use goext_null_if(cond) attribute.
	_ptr_SupportedEncTypes := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
		if err := w.WriteData(o.SupportedEncTypes); err != nil {
			return err
		}
		return nil
	})
	if err := w.WritePointer(&o.SupportedEncTypes, _ptr_SupportedEncTypes); err != nil {
		return err
	}
	return nil
}
func (o *OutChainSetClientAttributesV1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if err := w.ReadAlign(6); err != nil {
		return err
	}
	_ptr_HubName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := ndr.ReadUTF16NString(ctx, w, &o.HubName); err != nil {
			return err
		}
		return nil
	})
	_s_HubName := func(ptr interface{}) { o.HubName = *ptr.(*string) }
	if err := w.ReadPointer(&o.HubName, _s_HubName, _ptr_HubName); err != nil {
		return err
	}
	_ptr_OldDnsHostName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		_ptr_OldDnsHostName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.OldDNSHostName); err != nil {
				return err
			}
			return nil
		})
		_s_OldDnsHostName := func(ptr interface{}) { o.OldDNSHostName = *ptr.(*string) }
		if err := w.ReadPointer(&o.OldDNSHostName, _s_OldDnsHostName, _ptr_OldDnsHostName); err != nil {
			return err
		}
		return nil
	})
	_s_OldDnsHostName := func(ptr interface{}) { o.OldDNSHostName = *ptr.(*string) }
	if err := w.ReadPointer(&o.OldDNSHostName, _s_OldDnsHostName, _ptr_OldDnsHostName); err != nil {
		return err
	}
	_ptr_SupportedEncTypes := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
		if err := w.ReadData(&o.SupportedEncTypes); err != nil {
			return err
		}
		return nil
	})
	_s_SupportedEncTypes := func(ptr interface{}) { o.SupportedEncTypes = *ptr.(*uint32) }
	if err := w.ReadPointer(&o.SupportedEncTypes, _s_SupportedEncTypes, _ptr_SupportedEncTypes); err != nil {
		return err
	}
	return nil
}

// OutChainSetClientAttributes structure represents NL_OUT_CHAIN_SET_CLIENT_ATTRIBUTES RPC union.
//
// The NL_OUT_CHAIN_SET_CLIENT_ATTRIBUTES union defines versioning. Currently, only
// version 1 is supported.
type OutChainSetClientAttributes struct {
	// Types that are assignable to Value
	//
	// *OutChainSetClientAttributes_V1
	Value is_OutChainSetClientAttributes `json:"value"`
}

func (o *OutChainSetClientAttributes) GetValue() any {
	if o == nil {
		return nil
	}
	switch value := (interface{})(o.Value).(type) {
	case *OutChainSetClientAttributes_V1:
		if value != nil {
			return value.V1
		}
	}
	return nil
}

type is_OutChainSetClientAttributes interface {
	ndr.Marshaler
	ndr.Unmarshaler
	is_OutChainSetClientAttributes()
}

func (o *OutChainSetClientAttributes) NDRSwitchValue(sw uint32) uint32 {
	if o == nil {
		return uint32(0)
	}
	switch (interface{})(o.Value).(type) {
	case *OutChainSetClientAttributes_V1:
		return uint32(1)
	}
	return uint32(0)
}

func (o *OutChainSetClientAttributes) MarshalUnionNDR(ctx context.Context, w ndr.Writer, sw uint32) error {
	if err := w.WriteUnionAlign(9); err != nil {
		return err
	}
	if err := w.WriteSwitch(uint32(sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.WriteAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		_o, _ := o.Value.(*OutChainSetClientAttributes_V1)
		if _o != nil {
			if err := _o.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&OutChainSetClientAttributes_V1{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

func (o *OutChainSetClientAttributes) UnmarshalUnionNDR(ctx context.Context, w ndr.Reader, sw uint32) error {
	if err := w.ReadUnionAlign(9); err != nil {
		return err
	}
	if err := w.ReadSwitch((*uint32)(&sw)); err != nil {
		return err
	}
	// ms_union
	if err := w.ReadAlign(9); err != nil {
		return err
	}
	switch sw {
	case uint32(1):
		o.Value = &OutChainSetClientAttributes_V1{}
		if err := o.Value.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	default:
		return fmt.Errorf("unsupported switch case value %v", sw)
	}
	return nil
}

// OutChainSetClientAttributes_V1 structure represents NL_OUT_CHAIN_SET_CLIENT_ATTRIBUTES RPC union arm.
//
// It has following labels: 1
type OutChainSetClientAttributes_V1 struct {
	// V1: An NL_OUT_CHAIN_SET_CLIENT_ATTRIBUTES_V1 (section 2.2.1.3.18) structure.<47>
	V1 *OutChainSetClientAttributesV1 `idl:"name:V1" json:"v1"`
}

func (*OutChainSetClientAttributes_V1) is_OutChainSetClientAttributes() {}

func (o *OutChainSetClientAttributes_V1) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	if o.V1 != nil {
		if err := o.V1.MarshalNDR(ctx, w); err != nil {
			return err
		}
	} else {
		if err := (&OutChainSetClientAttributesV1{}).MarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}
func (o *OutChainSetClientAttributes_V1) UnmarshalNDR(ctx context.Context, w ndr.Reader) error {
	if o.V1 == nil {
		o.V1 = &OutChainSetClientAttributesV1{}
	}
	if err := o.V1.UnmarshalNDR(ctx, w); err != nil {
		return err
	}
	return nil
}

type xxx_DefaultLogonClient struct {
	cc dcerpc.Conn
}

func (o *xxx_DefaultLogonClient) UASLogon(ctx context.Context, in *UASLogonRequest, opts ...dcerpc.CallOption) (*UASLogonResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &UASLogonResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) UASLogoff(ctx context.Context, in *UASLogoffRequest, opts ...dcerpc.CallOption) (*UASLogoffResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &UASLogoffResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) SAMLogon(ctx context.Context, in *SAMLogonRequest, opts ...dcerpc.CallOption) (*SAMLogonResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SAMLogonResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != int32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) SAMLogoff(ctx context.Context, in *SAMLogoffRequest, opts ...dcerpc.CallOption) (*SAMLogoffResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SAMLogoffResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != int32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) RequestChallenge(ctx context.Context, in *RequestChallengeRequest, opts ...dcerpc.CallOption) (*RequestChallengeResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &RequestChallengeResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != int32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) Authenticate(ctx context.Context, in *AuthenticateRequest, opts ...dcerpc.CallOption) (*AuthenticateResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AuthenticateResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != int32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) PasswordSet(ctx context.Context, in *PasswordSetRequest, opts ...dcerpc.CallOption) (*PasswordSetResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &PasswordSetResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != int32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) DatabaseDeltas(ctx context.Context, in *DatabaseDeltasRequest, opts ...dcerpc.CallOption) (*DatabaseDeltasResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &DatabaseDeltasResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != int32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) DatabaseSync(ctx context.Context, in *DatabaseSyncRequest, opts ...dcerpc.CallOption) (*DatabaseSyncResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &DatabaseSyncResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != int32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) AccountDeltas(ctx context.Context, in *AccountDeltasRequest, opts ...dcerpc.CallOption) (*AccountDeltasResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AccountDeltasResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != int32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) AccountSync(ctx context.Context, in *AccountSyncRequest, opts ...dcerpc.CallOption) (*AccountSyncResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AccountSyncResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != int32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) GetNetrDCName(ctx context.Context, in *GetNetrDCNameRequest, opts ...dcerpc.CallOption) (*GetNetrDCNameResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetNetrDCNameResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) Control(ctx context.Context, in *ControlRequest, opts ...dcerpc.CallOption) (*ControlResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ControlResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) GetAnyDCName(ctx context.Context, in *GetAnyDCNameRequest, opts ...dcerpc.CallOption) (*GetAnyDCNameResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetAnyDCNameResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) Control2(ctx context.Context, in *Control2Request, opts ...dcerpc.CallOption) (*Control2Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &Control2Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) Authenticate2(ctx context.Context, in *Authenticate2Request, opts ...dcerpc.CallOption) (*Authenticate2Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &Authenticate2Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != int32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) DatabaseSync2(ctx context.Context, in *DatabaseSync2Request, opts ...dcerpc.CallOption) (*DatabaseSync2Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &DatabaseSync2Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != int32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) DatabaseRedo(ctx context.Context, in *DatabaseRedoRequest, opts ...dcerpc.CallOption) (*DatabaseRedoResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &DatabaseRedoResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != int32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) Control2Ex(ctx context.Context, in *Control2ExRequest, opts ...dcerpc.CallOption) (*Control2ExResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &Control2ExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) EnumerateTrustedDomains(ctx context.Context, in *EnumerateTrustedDomainsRequest, opts ...dcerpc.CallOption) (*EnumerateTrustedDomainsResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumerateTrustedDomainsResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != int32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) GetDCName(ctx context.Context, in *GetDCNameRequest, opts ...dcerpc.CallOption) (*GetDCNameResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetDCNameResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) GetCapabilities(ctx context.Context, in *GetCapabilitiesRequest, opts ...dcerpc.CallOption) (*GetCapabilitiesResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetCapabilitiesResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != int32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) SetServiceBits(ctx context.Context, in *SetServiceBitsRequest, opts ...dcerpc.CallOption) (*SetServiceBitsResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SetServiceBitsResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != int32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) GetTrustRID(ctx context.Context, in *GetTrustRIDRequest, opts ...dcerpc.CallOption) (*GetTrustRIDResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetTrustRIDResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) ComputeServerDigest(ctx context.Context, in *ComputeServerDigestRequest, opts ...dcerpc.CallOption) (*ComputeServerDigestResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ComputeServerDigestResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) ComputeClientDigest(ctx context.Context, in *ComputeClientDigestRequest, opts ...dcerpc.CallOption) (*ComputeClientDigestResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ComputeClientDigestResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) Authenticate3(ctx context.Context, in *Authenticate3Request, opts ...dcerpc.CallOption) (*Authenticate3Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &Authenticate3Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != int32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) GetDCNameEx(ctx context.Context, in *GetDCNameExRequest, opts ...dcerpc.CallOption) (*GetDCNameExResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetDCNameExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) GetSiteName(ctx context.Context, in *GetSiteNameRequest, opts ...dcerpc.CallOption) (*GetSiteNameResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetSiteNameResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) GetDomainInfo(ctx context.Context, in *GetDomainInfoRequest, opts ...dcerpc.CallOption) (*GetDomainInfoResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetDomainInfoResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != int32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) PasswordSet2(ctx context.Context, in *PasswordSet2Request, opts ...dcerpc.CallOption) (*PasswordSet2Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &PasswordSet2Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != int32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) PasswordGet(ctx context.Context, in *PasswordGetRequest, opts ...dcerpc.CallOption) (*PasswordGetResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &PasswordGetResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != int32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) SendToSAM(ctx context.Context, in *SendToSAMRequest, opts ...dcerpc.CallOption) (*SendToSAMResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SendToSAMResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != int32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) AddressToSiteNamesW(ctx context.Context, in *AddressToSiteNamesWRequest, opts ...dcerpc.CallOption) (*AddressToSiteNamesWResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddressToSiteNamesWResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) GetDCNameEx2(ctx context.Context, in *GetDCNameEx2Request, opts ...dcerpc.CallOption) (*GetDCNameEx2Response, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetDCNameEx2Response{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) GetTimeServiceParentDomain(ctx context.Context, in *GetTimeServiceParentDomainRequest, opts ...dcerpc.CallOption) (*GetTimeServiceParentDomainResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetTimeServiceParentDomainResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) EnumerateTrustedDomainsEx(ctx context.Context, in *EnumerateTrustedDomainsExRequest, opts ...dcerpc.CallOption) (*EnumerateTrustedDomainsExResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumerateTrustedDomainsExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) AddressToSiteNamesExW(ctx context.Context, in *AddressToSiteNamesExWRequest, opts ...dcerpc.CallOption) (*AddressToSiteNamesExWResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &AddressToSiteNamesExWResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) GetDCSiteCoverageW(ctx context.Context, in *GetDCSiteCoverageWRequest, opts ...dcerpc.CallOption) (*GetDCSiteCoverageWResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetDCSiteCoverageWResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) SAMLogonEx(ctx context.Context, in *SAMLogonExRequest, opts ...dcerpc.CallOption) (*SAMLogonExResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SAMLogonExResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != int32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) EnumerateDomainTrusts(ctx context.Context, in *EnumerateDomainTrustsRequest, opts ...dcerpc.CallOption) (*EnumerateDomainTrustsResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &EnumerateDomainTrustsResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) DeregisterDNSHostRecords(ctx context.Context, in *DeregisterDNSHostRecordsRequest, opts ...dcerpc.CallOption) (*DeregisterDNSHostRecordsResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &DeregisterDNSHostRecordsResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) TrustPasswordsGet(ctx context.Context, in *TrustPasswordsGetRequest, opts ...dcerpc.CallOption) (*TrustPasswordsGetResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &TrustPasswordsGetResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != int32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) GetForestTrustInformation(ctx context.Context, in *GetForestTrustInformationRequest, opts ...dcerpc.CallOption) (*GetForestTrustInformationResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetForestTrustInformationResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != uint32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) GetNetrForestTrustInformation(ctx context.Context, in *GetNetrForestTrustInformationRequest, opts ...dcerpc.CallOption) (*GetNetrForestTrustInformationResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetNetrForestTrustInformationResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != int32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) SAMLogonWithFlags(ctx context.Context, in *SAMLogonWithFlagsRequest, opts ...dcerpc.CallOption) (*SAMLogonWithFlagsResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &SAMLogonWithFlagsResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != int32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) GetTrustInfo(ctx context.Context, in *GetTrustInfoRequest, opts ...dcerpc.CallOption) (*GetTrustInfoResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &GetTrustInfoResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != int32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) UpdateReadOnlyServerDNSRecords(ctx context.Context, in *UpdateReadOnlyServerDNSRecordsRequest, opts ...dcerpc.CallOption) (*UpdateReadOnlyServerDNSRecordsResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &UpdateReadOnlyServerDNSRecordsResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != int32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) ChainSetClientAttributes(ctx context.Context, in *ChainSetClientAttributesRequest, opts ...dcerpc.CallOption) (*ChainSetClientAttributesResponse, error) {
	op := in.xxx_ToOp(ctx, nil)
	if err := o.cc.Invoke(ctx, op, opts...); err != nil {
		return nil, err
	}
	out := &ChainSetClientAttributesResponse{}
	out.xxx_FromOp(ctx, op)
	if op.Return != int32(0) {
		return out, fmt.Errorf("%s: %w", op.OpName(), errors.New(ctx, op.Return))
	}
	return out, nil
}

func (o *xxx_DefaultLogonClient) AlterContext(ctx context.Context, opts ...dcerpc.Option) error {
	return o.cc.AlterContext(ctx, opts...)
}

func (o *xxx_DefaultLogonClient) Conn() dcerpc.Conn {
	return o.cc
}

func NewLogonClient(ctx context.Context, cc dcerpc.Conn, opts ...dcerpc.Option) (LogonClient, error) {
	cc, err := cc.Bind(ctx, append(opts, dcerpc.WithAbstractSyntax(LogonSyntaxV1_0))...)
	if err != nil {
		return nil, err
	}
	return &xxx_DefaultLogonClient{cc: cc}, nil
}

// xxx_UASLogonOperation structure represents the NetrLogonUasLogon operation
type xxx_UASLogonOperation struct {
	ServerName            string             `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	UserName              string             `idl:"name:UserName;string" json:"user_name"`
	Workstation           string             `idl:"name:Workstation;string" json:"workstation"`
	ValidationInformation *ValidationUASInfo `idl:"name:ValidationInformation" json:"validation_information"`
	Return                uint32             `idl:"name:Return" json:"return"`
}

func (o *xxx_UASLogonOperation) OpNum() int { return 0 }

func (o *xxx_UASLogonOperation) OpName() string { return "/logon/v1/NetrLogonUasLogon" }

func (o *xxx_UASLogonOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UASLogonOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// UserName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.UserName); err != nil {
			return err
		}
	}
	// Workstation {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.Workstation); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UASLogonOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// UserName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.UserName); err != nil {
			return err
		}
	}
	// Workstation {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.Workstation); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UASLogonOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UASLogonOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ValidationInformation {out} (1:{pointer=ref}*(2))(2:{alias=PNETLOGON_VALIDATION_UAS_INFO}*(1))(3:{alias=NETLOGON_VALIDATION_UAS_INFO}(struct))
	{
		if o.ValidationInformation != nil {
			_ptr_ValidationInformation := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.ValidationInformation != nil {
					if err := o.ValidationInformation.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&ValidationUASInfo{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ValidationInformation, _ptr_ValidationInformation); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UASLogonOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ValidationInformation {out} (1:{pointer=ref}*(2))(2:{alias=PNETLOGON_VALIDATION_UAS_INFO,pointer=ref}*(1))(3:{alias=NETLOGON_VALIDATION_UAS_INFO}(struct))
	{
		_ptr_ValidationInformation := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.ValidationInformation == nil {
				o.ValidationInformation = &ValidationUASInfo{}
			}
			if err := o.ValidationInformation.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ValidationInformation := func(ptr interface{}) { o.ValidationInformation = *ptr.(**ValidationUASInfo) }
		if err := w.ReadPointer(&o.ValidationInformation, _s_ValidationInformation, _ptr_ValidationInformation); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// UASLogonRequest structure represents the NetrLogonUasLogon operation request
type UASLogonRequest struct {
	ServerName  string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	UserName    string `idl:"name:UserName;string" json:"user_name"`
	Workstation string `idl:"name:Workstation;string" json:"workstation"`
}

func (o *UASLogonRequest) xxx_ToOp(ctx context.Context, op *xxx_UASLogonOperation) *xxx_UASLogonOperation {
	if op == nil {
		op = &xxx_UASLogonOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.UserName = o.UserName
	op.Workstation = o.Workstation
	return op
}

func (o *UASLogonRequest) xxx_FromOp(ctx context.Context, op *xxx_UASLogonOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.UserName = op.UserName
	o.Workstation = op.Workstation
}
func (o *UASLogonRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *UASLogonRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_UASLogonOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// UASLogonResponse structure represents the NetrLogonUasLogon operation response
type UASLogonResponse struct {
	ValidationInformation *ValidationUASInfo `idl:"name:ValidationInformation" json:"validation_information"`
	// Return: The NetrLogonUasLogon return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *UASLogonResponse) xxx_ToOp(ctx context.Context, op *xxx_UASLogonOperation) *xxx_UASLogonOperation {
	if op == nil {
		op = &xxx_UASLogonOperation{}
	}
	if o == nil {
		return op
	}
	op.ValidationInformation = o.ValidationInformation
	op.Return = o.Return
	return op
}

func (o *UASLogonResponse) xxx_FromOp(ctx context.Context, op *xxx_UASLogonOperation) {
	if o == nil {
		return
	}
	o.ValidationInformation = op.ValidationInformation
	o.Return = op.Return
}
func (o *UASLogonResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *UASLogonResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_UASLogonOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_UASLogoffOperation structure represents the NetrLogonUasLogoff operation
type xxx_UASLogoffOperation struct {
	ServerName        string         `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	UserName          string         `idl:"name:UserName;string" json:"user_name"`
	Workstation       string         `idl:"name:Workstation;string" json:"workstation"`
	LogoffInformation *LogoffUASInfo `idl:"name:LogoffInformation" json:"logoff_information"`
	Return            uint32         `idl:"name:Return" json:"return"`
}

func (o *xxx_UASLogoffOperation) OpNum() int { return 1 }

func (o *xxx_UASLogoffOperation) OpName() string { return "/logon/v1/NetrLogonUasLogoff" }

func (o *xxx_UASLogoffOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UASLogoffOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// UserName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.UserName); err != nil {
			return err
		}
	}
	// Workstation {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.Workstation); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UASLogoffOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// UserName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.UserName); err != nil {
			return err
		}
	}
	// Workstation {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.Workstation); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UASLogoffOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UASLogoffOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// LogoffInformation {out} (1:{alias=PNETLOGON_LOGOFF_UAS_INFO}*(1))(2:{alias=NETLOGON_LOGOFF_UAS_INFO}(struct))
	{
		if o.LogoffInformation != nil {
			if err := o.LogoffInformation.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&LogoffUASInfo{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UASLogoffOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// LogoffInformation {out} (1:{alias=PNETLOGON_LOGOFF_UAS_INFO,pointer=ref}*(1))(2:{alias=NETLOGON_LOGOFF_UAS_INFO}(struct))
	{
		if o.LogoffInformation == nil {
			o.LogoffInformation = &LogoffUASInfo{}
		}
		if err := o.LogoffInformation.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// UASLogoffRequest structure represents the NetrLogonUasLogoff operation request
type UASLogoffRequest struct {
	ServerName  string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	UserName    string `idl:"name:UserName;string" json:"user_name"`
	Workstation string `idl:"name:Workstation;string" json:"workstation"`
}

func (o *UASLogoffRequest) xxx_ToOp(ctx context.Context, op *xxx_UASLogoffOperation) *xxx_UASLogoffOperation {
	if op == nil {
		op = &xxx_UASLogoffOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.UserName = o.UserName
	op.Workstation = o.Workstation
	return op
}

func (o *UASLogoffRequest) xxx_FromOp(ctx context.Context, op *xxx_UASLogoffOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.UserName = op.UserName
	o.Workstation = op.Workstation
}
func (o *UASLogoffRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *UASLogoffRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_UASLogoffOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// UASLogoffResponse structure represents the NetrLogonUasLogoff operation response
type UASLogoffResponse struct {
	LogoffInformation *LogoffUASInfo `idl:"name:LogoffInformation" json:"logoff_information"`
	// Return: The NetrLogonUasLogoff return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *UASLogoffResponse) xxx_ToOp(ctx context.Context, op *xxx_UASLogoffOperation) *xxx_UASLogoffOperation {
	if op == nil {
		op = &xxx_UASLogoffOperation{}
	}
	if o == nil {
		return op
	}
	op.LogoffInformation = o.LogoffInformation
	op.Return = o.Return
	return op
}

func (o *UASLogoffResponse) xxx_FromOp(ctx context.Context, op *xxx_UASLogoffOperation) {
	if o == nil {
		return
	}
	o.LogoffInformation = op.LogoffInformation
	o.Return = op.Return
}
func (o *UASLogoffResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *UASLogoffResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_UASLogoffOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SAMLogonOperation structure represents the NetrLogonSamLogon operation
type xxx_SAMLogonOperation struct {
	LogonServer           string              `idl:"name:LogonServer;string;pointer:unique" json:"logon_server"`
	ComputerName          string              `idl:"name:ComputerName;string;pointer:unique" json:"computer_name"`
	Authenticator         *Authenticator      `idl:"name:Authenticator;pointer:unique" json:"authenticator"`
	ReturnAuthenticator   *Authenticator      `idl:"name:ReturnAuthenticator;pointer:unique" json:"return_authenticator"`
	LogonLevel            LogonInfoClass      `idl:"name:LogonLevel" json:"logon_level"`
	LogonInformation      *Level              `idl:"name:LogonInformation;switch_is:LogonLevel" json:"logon_information"`
	ValidationLevel       ValidationInfoClass `idl:"name:ValidationLevel" json:"validation_level"`
	ValidationInformation *Validation         `idl:"name:ValidationInformation;switch_is:ValidationLevel" json:"validation_information"`
	Authoritative         uint8               `idl:"name:Authoritative" json:"authoritative"`
	Return                int32               `idl:"name:Return" json:"return"`
}

func (o *xxx_SAMLogonOperation) OpNum() int { return 2 }

func (o *xxx_SAMLogonOperation) OpName() string { return "/logon/v1/NetrLogonSamLogon" }

func (o *xxx_SAMLogonOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SAMLogonOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// LogonServer {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.LogonServer != "" {
			_ptr_LogonServer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.LogonServer); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.LogonServer, _ptr_LogonServer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=unique}*(1)[dim:0,string,null](wchar))
	{
		if o.ComputerName != "" {
			_ptr_ComputerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ComputerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ComputerName, _ptr_ComputerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Authenticator {in} (1:{pointer=unique, alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.Authenticator != nil {
			_ptr_Authenticator := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Authenticator != nil {
					if err := o.Authenticator.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Authenticator, _ptr_Authenticator); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ReturnAuthenticator {in, out} (1:{pointer=unique, alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator != nil {
			_ptr_ReturnAuthenticator := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.ReturnAuthenticator != nil {
					if err := o.ReturnAuthenticator.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ReturnAuthenticator, _ptr_ReturnAuthenticator); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// LogonLevel {in} (1:{alias=NETLOGON_LOGON_INFO_CLASS}(enum))
	{
		if err := w.WriteEnum(uint16(o.LogonLevel)); err != nil {
			return err
		}
	}
	// LogonInformation {in} (1:{switch_type={alias=NETLOGON_LOGON_INFO_CLASS}(enum), alias=PNETLOGON_LEVEL}*(1))(2:{switch_type={alias=NETLOGON_LOGON_INFO_CLASS}(enum), alias=NETLOGON_LEVEL}(union))
	{
		_swLogonInformation := uint16(o.LogonLevel)
		if o.LogonInformation != nil {
			if err := o.LogonInformation.MarshalUnionNDR(ctx, w, _swLogonInformation); err != nil {
				return err
			}
		} else {
			if err := (&Level{}).MarshalUnionNDR(ctx, w, _swLogonInformation); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ValidationLevel {in} (1:{alias=NETLOGON_VALIDATION_INFO_CLASS}(enum))
	{
		if err := w.WriteEnum(uint16(o.ValidationLevel)); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SAMLogonOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// LogonServer {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_LogonServer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.LogonServer); err != nil {
				return err
			}
			return nil
		})
		_s_LogonServer := func(ptr interface{}) { o.LogonServer = *ptr.(*string) }
		if err := w.ReadPointer(&o.LogonServer, _s_LogonServer, _ptr_LogonServer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=unique}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ComputerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ComputerName); err != nil {
				return err
			}
			return nil
		})
		_s_ComputerName := func(ptr interface{}) { o.ComputerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ComputerName, _s_ComputerName, _ptr_ComputerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Authenticator {in} (1:{pointer=unique, alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		_ptr_Authenticator := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Authenticator == nil {
				o.Authenticator = &Authenticator{}
			}
			if err := o.Authenticator.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_Authenticator := func(ptr interface{}) { o.Authenticator = *ptr.(**Authenticator) }
		if err := w.ReadPointer(&o.Authenticator, _s_Authenticator, _ptr_Authenticator); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ReturnAuthenticator {in, out} (1:{pointer=unique, alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		_ptr_ReturnAuthenticator := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.ReturnAuthenticator == nil {
				o.ReturnAuthenticator = &Authenticator{}
			}
			if err := o.ReturnAuthenticator.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ReturnAuthenticator := func(ptr interface{}) { o.ReturnAuthenticator = *ptr.(**Authenticator) }
		if err := w.ReadPointer(&o.ReturnAuthenticator, _s_ReturnAuthenticator, _ptr_ReturnAuthenticator); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// LogonLevel {in} (1:{alias=NETLOGON_LOGON_INFO_CLASS}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.LogonLevel)); err != nil {
			return err
		}
	}
	// LogonInformation {in} (1:{switch_type={alias=NETLOGON_LOGON_INFO_CLASS}(enum), alias=PNETLOGON_LEVEL,pointer=ref}*(1))(2:{switch_type={alias=NETLOGON_LOGON_INFO_CLASS}(enum), alias=NETLOGON_LEVEL}(union))
	{
		if o.LogonInformation == nil {
			o.LogonInformation = &Level{}
		}
		_swLogonInformation := uint16(o.LogonLevel)
		if err := o.LogonInformation.UnmarshalUnionNDR(ctx, w, _swLogonInformation); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ValidationLevel {in} (1:{alias=NETLOGON_VALIDATION_INFO_CLASS}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.ValidationLevel)); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SAMLogonOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SAMLogonOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ReturnAuthenticator {in, out} (1:{pointer=unique, alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator != nil {
			_ptr_ReturnAuthenticator := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.ReturnAuthenticator != nil {
					if err := o.ReturnAuthenticator.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ReturnAuthenticator, _ptr_ReturnAuthenticator); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ValidationInformation {out} (1:{switch_type={}(enum), alias=PNETLOGON_VALIDATION}*(1))(2:{switch_type={}(enum), alias=NETLOGON_VALIDATION}(union))
	{
		_swValidationInformation := uint16(o.ValidationLevel)
		if o.ValidationInformation != nil {
			if err := o.ValidationInformation.MarshalUnionNDR(ctx, w, _swValidationInformation); err != nil {
				return err
			}
		} else {
			if err := (&Validation{}).MarshalUnionNDR(ctx, w, _swValidationInformation); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Authoritative {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}(uchar))
	{
		if err := w.WriteData(o.Authoritative); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SAMLogonOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ReturnAuthenticator {in, out} (1:{pointer=unique, alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		_ptr_ReturnAuthenticator := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.ReturnAuthenticator == nil {
				o.ReturnAuthenticator = &Authenticator{}
			}
			if err := o.ReturnAuthenticator.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ReturnAuthenticator := func(ptr interface{}) { o.ReturnAuthenticator = *ptr.(**Authenticator) }
		if err := w.ReadPointer(&o.ReturnAuthenticator, _s_ReturnAuthenticator, _ptr_ReturnAuthenticator); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ValidationInformation {out} (1:{switch_type={}(enum), alias=PNETLOGON_VALIDATION,pointer=ref}*(1))(2:{switch_type={}(enum), alias=NETLOGON_VALIDATION}(union))
	{
		if o.ValidationInformation == nil {
			o.ValidationInformation = &Validation{}
		}
		_swValidationInformation := uint16(o.ValidationLevel)
		if err := o.ValidationInformation.UnmarshalUnionNDR(ctx, w, _swValidationInformation); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Authoritative {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}(uchar))
	{
		if err := w.ReadData(&o.Authoritative); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SAMLogonRequest structure represents the NetrLogonSamLogon operation request
type SAMLogonRequest struct {
	LogonServer         string              `idl:"name:LogonServer;string;pointer:unique" json:"logon_server"`
	ComputerName        string              `idl:"name:ComputerName;string;pointer:unique" json:"computer_name"`
	Authenticator       *Authenticator      `idl:"name:Authenticator;pointer:unique" json:"authenticator"`
	ReturnAuthenticator *Authenticator      `idl:"name:ReturnAuthenticator;pointer:unique" json:"return_authenticator"`
	LogonLevel          LogonInfoClass      `idl:"name:LogonLevel" json:"logon_level"`
	LogonInformation    *Level              `idl:"name:LogonInformation;switch_is:LogonLevel" json:"logon_information"`
	ValidationLevel     ValidationInfoClass `idl:"name:ValidationLevel" json:"validation_level"`
}

func (o *SAMLogonRequest) xxx_ToOp(ctx context.Context, op *xxx_SAMLogonOperation) *xxx_SAMLogonOperation {
	if op == nil {
		op = &xxx_SAMLogonOperation{}
	}
	if o == nil {
		return op
	}
	op.LogonServer = o.LogonServer
	op.ComputerName = o.ComputerName
	op.Authenticator = o.Authenticator
	op.ReturnAuthenticator = o.ReturnAuthenticator
	op.LogonLevel = o.LogonLevel
	op.LogonInformation = o.LogonInformation
	op.ValidationLevel = o.ValidationLevel
	return op
}

func (o *SAMLogonRequest) xxx_FromOp(ctx context.Context, op *xxx_SAMLogonOperation) {
	if o == nil {
		return
	}
	o.LogonServer = op.LogonServer
	o.ComputerName = op.ComputerName
	o.Authenticator = op.Authenticator
	o.ReturnAuthenticator = op.ReturnAuthenticator
	o.LogonLevel = op.LogonLevel
	o.LogonInformation = op.LogonInformation
	o.ValidationLevel = op.ValidationLevel
}
func (o *SAMLogonRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SAMLogonRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SAMLogonOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SAMLogonResponse structure represents the NetrLogonSamLogon operation response
type SAMLogonResponse struct {
	// XXX: ValidationLevel is an implicit input depedency for output parameters
	ValidationLevel ValidationInfoClass `idl:"name:ValidationLevel" json:"validation_level"`

	ReturnAuthenticator   *Authenticator `idl:"name:ReturnAuthenticator;pointer:unique" json:"return_authenticator"`
	ValidationInformation *Validation    `idl:"name:ValidationInformation;switch_is:ValidationLevel" json:"validation_information"`
	Authoritative         uint8          `idl:"name:Authoritative" json:"authoritative"`
	// Return: The NetrLogonSamLogon return value.
	Return int32 `idl:"name:Return" json:"return"`
}

func (o *SAMLogonResponse) xxx_ToOp(ctx context.Context, op *xxx_SAMLogonOperation) *xxx_SAMLogonOperation {
	if op == nil {
		op = &xxx_SAMLogonOperation{}
	}
	if o == nil {
		return op
	}
	// XXX: implicit input dependencies for output parameters
	if op.ValidationLevel == ValidationInfoClass(0) {
		op.ValidationLevel = o.ValidationLevel
	}

	op.ReturnAuthenticator = o.ReturnAuthenticator
	op.ValidationInformation = o.ValidationInformation
	op.Authoritative = o.Authoritative
	op.Return = o.Return
	return op
}

func (o *SAMLogonResponse) xxx_FromOp(ctx context.Context, op *xxx_SAMLogonOperation) {
	if o == nil {
		return
	}
	// XXX: implicit input dependencies for output parameters
	o.ValidationLevel = op.ValidationLevel

	o.ReturnAuthenticator = op.ReturnAuthenticator
	o.ValidationInformation = op.ValidationInformation
	o.Authoritative = op.Authoritative
	o.Return = op.Return
}
func (o *SAMLogonResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SAMLogonResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SAMLogonOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SAMLogoffOperation structure represents the NetrLogonSamLogoff operation
type xxx_SAMLogoffOperation struct {
	LogonServer         string         `idl:"name:LogonServer;string;pointer:unique" json:"logon_server"`
	ComputerName        string         `idl:"name:ComputerName;string;pointer:unique" json:"computer_name"`
	Authenticator       *Authenticator `idl:"name:Authenticator;pointer:unique" json:"authenticator"`
	ReturnAuthenticator *Authenticator `idl:"name:ReturnAuthenticator;pointer:unique" json:"return_authenticator"`
	LogonLevel          LogonInfoClass `idl:"name:LogonLevel" json:"logon_level"`
	LogonInformation    *Level         `idl:"name:LogonInformation;switch_is:LogonLevel" json:"logon_information"`
	Return              int32          `idl:"name:Return" json:"return"`
}

func (o *xxx_SAMLogoffOperation) OpNum() int { return 3 }

func (o *xxx_SAMLogoffOperation) OpName() string { return "/logon/v1/NetrLogonSamLogoff" }

func (o *xxx_SAMLogoffOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SAMLogoffOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// LogonServer {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.LogonServer != "" {
			_ptr_LogonServer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.LogonServer); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.LogonServer, _ptr_LogonServer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=unique}*(1)[dim:0,string,null](wchar))
	{
		if o.ComputerName != "" {
			_ptr_ComputerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ComputerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ComputerName, _ptr_ComputerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Authenticator {in} (1:{pointer=unique, alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.Authenticator != nil {
			_ptr_Authenticator := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Authenticator != nil {
					if err := o.Authenticator.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Authenticator, _ptr_Authenticator); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ReturnAuthenticator {in, out} (1:{pointer=unique, alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator != nil {
			_ptr_ReturnAuthenticator := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.ReturnAuthenticator != nil {
					if err := o.ReturnAuthenticator.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ReturnAuthenticator, _ptr_ReturnAuthenticator); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// LogonLevel {in} (1:{alias=NETLOGON_LOGON_INFO_CLASS}(enum))
	{
		if err := w.WriteEnum(uint16(o.LogonLevel)); err != nil {
			return err
		}
	}
	// LogonInformation {in} (1:{switch_type={alias=NETLOGON_LOGON_INFO_CLASS}(enum), alias=PNETLOGON_LEVEL}*(1))(2:{switch_type={alias=NETLOGON_LOGON_INFO_CLASS}(enum), alias=NETLOGON_LEVEL}(union))
	{
		_swLogonInformation := uint16(o.LogonLevel)
		if o.LogonInformation != nil {
			if err := o.LogonInformation.MarshalUnionNDR(ctx, w, _swLogonInformation); err != nil {
				return err
			}
		} else {
			if err := (&Level{}).MarshalUnionNDR(ctx, w, _swLogonInformation); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SAMLogoffOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// LogonServer {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_LogonServer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.LogonServer); err != nil {
				return err
			}
			return nil
		})
		_s_LogonServer := func(ptr interface{}) { o.LogonServer = *ptr.(*string) }
		if err := w.ReadPointer(&o.LogonServer, _s_LogonServer, _ptr_LogonServer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=unique}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ComputerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ComputerName); err != nil {
				return err
			}
			return nil
		})
		_s_ComputerName := func(ptr interface{}) { o.ComputerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ComputerName, _s_ComputerName, _ptr_ComputerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Authenticator {in} (1:{pointer=unique, alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		_ptr_Authenticator := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Authenticator == nil {
				o.Authenticator = &Authenticator{}
			}
			if err := o.Authenticator.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_Authenticator := func(ptr interface{}) { o.Authenticator = *ptr.(**Authenticator) }
		if err := w.ReadPointer(&o.Authenticator, _s_Authenticator, _ptr_Authenticator); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ReturnAuthenticator {in, out} (1:{pointer=unique, alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		_ptr_ReturnAuthenticator := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.ReturnAuthenticator == nil {
				o.ReturnAuthenticator = &Authenticator{}
			}
			if err := o.ReturnAuthenticator.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ReturnAuthenticator := func(ptr interface{}) { o.ReturnAuthenticator = *ptr.(**Authenticator) }
		if err := w.ReadPointer(&o.ReturnAuthenticator, _s_ReturnAuthenticator, _ptr_ReturnAuthenticator); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// LogonLevel {in} (1:{alias=NETLOGON_LOGON_INFO_CLASS}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.LogonLevel)); err != nil {
			return err
		}
	}
	// LogonInformation {in} (1:{switch_type={alias=NETLOGON_LOGON_INFO_CLASS}(enum), alias=PNETLOGON_LEVEL,pointer=ref}*(1))(2:{switch_type={alias=NETLOGON_LOGON_INFO_CLASS}(enum), alias=NETLOGON_LEVEL}(union))
	{
		if o.LogonInformation == nil {
			o.LogonInformation = &Level{}
		}
		_swLogonInformation := uint16(o.LogonLevel)
		if err := o.LogonInformation.UnmarshalUnionNDR(ctx, w, _swLogonInformation); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SAMLogoffOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SAMLogoffOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ReturnAuthenticator {in, out} (1:{pointer=unique, alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator != nil {
			_ptr_ReturnAuthenticator := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.ReturnAuthenticator != nil {
					if err := o.ReturnAuthenticator.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ReturnAuthenticator, _ptr_ReturnAuthenticator); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SAMLogoffOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ReturnAuthenticator {in, out} (1:{pointer=unique, alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		_ptr_ReturnAuthenticator := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.ReturnAuthenticator == nil {
				o.ReturnAuthenticator = &Authenticator{}
			}
			if err := o.ReturnAuthenticator.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ReturnAuthenticator := func(ptr interface{}) { o.ReturnAuthenticator = *ptr.(**Authenticator) }
		if err := w.ReadPointer(&o.ReturnAuthenticator, _s_ReturnAuthenticator, _ptr_ReturnAuthenticator); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SAMLogoffRequest structure represents the NetrLogonSamLogoff operation request
type SAMLogoffRequest struct {
	// LogonServer: The custom binding handle, as defined in section 3.5.4.1.
	LogonServer string `idl:"name:LogonServer;string;pointer:unique" json:"logon_server"`
	// ComputerName: The Unicode string that contains the NetBIOS name of the client computer
	// calling this method.
	ComputerName string `idl:"name:ComputerName;string;pointer:unique" json:"computer_name"`
	// Authenticator: A pointer to a NETLOGON_AUTHENTICATOR structure, as specified in section
	// 2.2.1.1.5, that contains the client authenticator.
	Authenticator *Authenticator `idl:"name:Authenticator;pointer:unique" json:"authenticator"`
	// ReturnAuthenticator: A pointer to a NETLOGON_AUTHENTICATOR structure, as specified
	// in section 2.2.1.1.5, that contains the server return authenticator.
	ReturnAuthenticator *Authenticator `idl:"name:ReturnAuthenticator;pointer:unique" json:"return_authenticator"`
	// LogonLevel: A NETLOGON_LOGON_INFO_CLASS structure, as specified in section 2.2.1.4.16,
	// that identifies the type of logon information in the LogonInformation union.
	LogonLevel LogonInfoClass `idl:"name:LogonLevel" json:"logon_level"`
	// LogonInformation: A pointer to a NETLOGON_LEVEL structure, as specified in section
	// 2.2.1.4.6, that describes the logon information.
	LogonInformation *Level `idl:"name:LogonInformation;switch_is:LogonLevel" json:"logon_information"`
}

func (o *SAMLogoffRequest) xxx_ToOp(ctx context.Context, op *xxx_SAMLogoffOperation) *xxx_SAMLogoffOperation {
	if op == nil {
		op = &xxx_SAMLogoffOperation{}
	}
	if o == nil {
		return op
	}
	op.LogonServer = o.LogonServer
	op.ComputerName = o.ComputerName
	op.Authenticator = o.Authenticator
	op.ReturnAuthenticator = o.ReturnAuthenticator
	op.LogonLevel = o.LogonLevel
	op.LogonInformation = o.LogonInformation
	return op
}

func (o *SAMLogoffRequest) xxx_FromOp(ctx context.Context, op *xxx_SAMLogoffOperation) {
	if o == nil {
		return
	}
	o.LogonServer = op.LogonServer
	o.ComputerName = op.ComputerName
	o.Authenticator = op.Authenticator
	o.ReturnAuthenticator = op.ReturnAuthenticator
	o.LogonLevel = op.LogonLevel
	o.LogonInformation = op.LogonInformation
}
func (o *SAMLogoffRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SAMLogoffRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SAMLogoffOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SAMLogoffResponse structure represents the NetrLogonSamLogoff operation response
type SAMLogoffResponse struct {
	// ReturnAuthenticator: A pointer to a NETLOGON_AUTHENTICATOR structure, as specified
	// in section 2.2.1.1.5, that contains the server return authenticator.
	ReturnAuthenticator *Authenticator `idl:"name:ReturnAuthenticator;pointer:unique" json:"return_authenticator"`
	// Return: The NetrLogonSamLogoff return value.
	Return int32 `idl:"name:Return" json:"return"`
}

func (o *SAMLogoffResponse) xxx_ToOp(ctx context.Context, op *xxx_SAMLogoffOperation) *xxx_SAMLogoffOperation {
	if op == nil {
		op = &xxx_SAMLogoffOperation{}
	}
	if o == nil {
		return op
	}
	op.ReturnAuthenticator = o.ReturnAuthenticator
	op.Return = o.Return
	return op
}

func (o *SAMLogoffResponse) xxx_FromOp(ctx context.Context, op *xxx_SAMLogoffOperation) {
	if o == nil {
		return
	}
	o.ReturnAuthenticator = op.ReturnAuthenticator
	o.Return = op.Return
}
func (o *SAMLogoffResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SAMLogoffResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SAMLogoffOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_RequestChallengeOperation structure represents the NetrServerReqChallenge operation
type xxx_RequestChallengeOperation struct {
	PrimaryName     string      `idl:"name:PrimaryName;string;pointer:unique" json:"primary_name"`
	ComputerName    string      `idl:"name:ComputerName;string" json:"computer_name"`
	ClientChallenge *Credential `idl:"name:ClientChallenge" json:"client_challenge"`
	ServerChallenge *Credential `idl:"name:ServerChallenge" json:"server_challenge"`
	Return          int32       `idl:"name:Return" json:"return"`
}

func (o *xxx_RequestChallengeOperation) OpNum() int { return 4 }

func (o *xxx_RequestChallengeOperation) OpName() string { return "/logon/v1/NetrServerReqChallenge" }

func (o *xxx_RequestChallengeOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RequestChallengeOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// PrimaryName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.PrimaryName != "" {
			_ptr_PrimaryName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.PrimaryName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.PrimaryName, _ptr_PrimaryName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ComputerName); err != nil {
			return err
		}
	}
	// ClientChallenge {in} (1:{alias=PNETLOGON_CREDENTIAL}*(1))(2:{alias=NETLOGON_CREDENTIAL}(struct))
	{
		if o.ClientChallenge != nil {
			if err := o.ClientChallenge.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Credential{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_RequestChallengeOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// PrimaryName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_PrimaryName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.PrimaryName); err != nil {
				return err
			}
			return nil
		})
		_s_PrimaryName := func(ptr interface{}) { o.PrimaryName = *ptr.(*string) }
		if err := w.ReadPointer(&o.PrimaryName, _s_PrimaryName, _ptr_PrimaryName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ComputerName); err != nil {
			return err
		}
	}
	// ClientChallenge {in} (1:{alias=PNETLOGON_CREDENTIAL,pointer=ref}*(1))(2:{alias=NETLOGON_CREDENTIAL}(struct))
	{
		if o.ClientChallenge == nil {
			o.ClientChallenge = &Credential{}
		}
		if err := o.ClientChallenge.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RequestChallengeOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RequestChallengeOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ServerChallenge {out} (1:{alias=PNETLOGON_CREDENTIAL}*(1))(2:{alias=NETLOGON_CREDENTIAL}(struct))
	{
		if o.ServerChallenge != nil {
			if err := o.ServerChallenge.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Credential{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_RequestChallengeOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ServerChallenge {out} (1:{alias=PNETLOGON_CREDENTIAL,pointer=ref}*(1))(2:{alias=NETLOGON_CREDENTIAL}(struct))
	{
		if o.ServerChallenge == nil {
			o.ServerChallenge = &Credential{}
		}
		if err := o.ServerChallenge.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// RequestChallengeRequest structure represents the NetrServerReqChallenge operation request
type RequestChallengeRequest struct {
	// PrimaryName: The custom binding handle, as defined in section 3.5.4.1.
	PrimaryName string `idl:"name:PrimaryName;string;pointer:unique" json:"primary_name"`
	// ComputerName: A Unicode string that contains the NetBIOS name of the client computer
	// calling this method.
	ComputerName string `idl:"name:ComputerName;string" json:"computer_name"`
	// ClientChallenge: A pointer to a NETLOGON_CREDENTIAL structure, as specified in section
	// 2.2.1.3.4, that contains the client challenge.
	ClientChallenge *Credential `idl:"name:ClientChallenge" json:"client_challenge"`
}

func (o *RequestChallengeRequest) xxx_ToOp(ctx context.Context, op *xxx_RequestChallengeOperation) *xxx_RequestChallengeOperation {
	if op == nil {
		op = &xxx_RequestChallengeOperation{}
	}
	if o == nil {
		return op
	}
	op.PrimaryName = o.PrimaryName
	op.ComputerName = o.ComputerName
	op.ClientChallenge = o.ClientChallenge
	return op
}

func (o *RequestChallengeRequest) xxx_FromOp(ctx context.Context, op *xxx_RequestChallengeOperation) {
	if o == nil {
		return
	}
	o.PrimaryName = op.PrimaryName
	o.ComputerName = op.ComputerName
	o.ClientChallenge = op.ClientChallenge
}
func (o *RequestChallengeRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *RequestChallengeRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RequestChallengeOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// RequestChallengeResponse structure represents the NetrServerReqChallenge operation response
type RequestChallengeResponse struct {
	// ServerChallenge: A pointer to a NETLOGON_CREDENTIAL structure, as specified in section
	// 2.2.1.3.4, that contains the server challenge response.
	ServerChallenge *Credential `idl:"name:ServerChallenge" json:"server_challenge"`
	// Return: The NetrServerReqChallenge return value.
	Return int32 `idl:"name:Return" json:"return"`
}

func (o *RequestChallengeResponse) xxx_ToOp(ctx context.Context, op *xxx_RequestChallengeOperation) *xxx_RequestChallengeOperation {
	if op == nil {
		op = &xxx_RequestChallengeOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerChallenge = o.ServerChallenge
	op.Return = o.Return
	return op
}

func (o *RequestChallengeResponse) xxx_FromOp(ctx context.Context, op *xxx_RequestChallengeOperation) {
	if o == nil {
		return
	}
	o.ServerChallenge = op.ServerChallenge
	o.Return = op.Return
}
func (o *RequestChallengeResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *RequestChallengeResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_RequestChallengeOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AuthenticateOperation structure represents the NetrServerAuthenticate operation
type xxx_AuthenticateOperation struct {
	PrimaryName       string            `idl:"name:PrimaryName;string;pointer:unique" json:"primary_name"`
	AccountName       string            `idl:"name:AccountName;string" json:"account_name"`
	SecureChannelType SecureChannelType `idl:"name:SecureChannelType" json:"secure_channel_type"`
	ComputerName      string            `idl:"name:ComputerName;string" json:"computer_name"`
	ClientCredential  *Credential       `idl:"name:ClientCredential" json:"client_credential"`
	ServerCredential  *Credential       `idl:"name:ServerCredential" json:"server_credential"`
	Return            int32             `idl:"name:Return" json:"return"`
}

func (o *xxx_AuthenticateOperation) OpNum() int { return 5 }

func (o *xxx_AuthenticateOperation) OpName() string { return "/logon/v1/NetrServerAuthenticate" }

func (o *xxx_AuthenticateOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AuthenticateOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// PrimaryName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.PrimaryName != "" {
			_ptr_PrimaryName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.PrimaryName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.PrimaryName, _ptr_PrimaryName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// AccountName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.AccountName); err != nil {
			return err
		}
	}
	// SecureChannelType {in} (1:{alias=NETLOGON_SECURE_CHANNEL_TYPE}(enum))
	{
		if err := w.WriteEnum(uint16(o.SecureChannelType)); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ComputerName); err != nil {
			return err
		}
	}
	// ClientCredential {in} (1:{alias=PNETLOGON_CREDENTIAL}*(1))(2:{alias=NETLOGON_CREDENTIAL}(struct))
	{
		if o.ClientCredential != nil {
			if err := o.ClientCredential.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Credential{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_AuthenticateOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// PrimaryName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_PrimaryName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.PrimaryName); err != nil {
				return err
			}
			return nil
		})
		_s_PrimaryName := func(ptr interface{}) { o.PrimaryName = *ptr.(*string) }
		if err := w.ReadPointer(&o.PrimaryName, _s_PrimaryName, _ptr_PrimaryName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// AccountName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.AccountName); err != nil {
			return err
		}
	}
	// SecureChannelType {in} (1:{alias=NETLOGON_SECURE_CHANNEL_TYPE}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.SecureChannelType)); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ComputerName); err != nil {
			return err
		}
	}
	// ClientCredential {in} (1:{alias=PNETLOGON_CREDENTIAL,pointer=ref}*(1))(2:{alias=NETLOGON_CREDENTIAL}(struct))
	{
		if o.ClientCredential == nil {
			o.ClientCredential = &Credential{}
		}
		if err := o.ClientCredential.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AuthenticateOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AuthenticateOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ServerCredential {out} (1:{alias=PNETLOGON_CREDENTIAL}*(1))(2:{alias=NETLOGON_CREDENTIAL}(struct))
	{
		if o.ServerCredential != nil {
			if err := o.ServerCredential.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Credential{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AuthenticateOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ServerCredential {out} (1:{alias=PNETLOGON_CREDENTIAL,pointer=ref}*(1))(2:{alias=NETLOGON_CREDENTIAL}(struct))
	{
		if o.ServerCredential == nil {
			o.ServerCredential = &Credential{}
		}
		if err := o.ServerCredential.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AuthenticateRequest structure represents the NetrServerAuthenticate operation request
type AuthenticateRequest struct {
	PrimaryName       string            `idl:"name:PrimaryName;string;pointer:unique" json:"primary_name"`
	AccountName       string            `idl:"name:AccountName;string" json:"account_name"`
	SecureChannelType SecureChannelType `idl:"name:SecureChannelType" json:"secure_channel_type"`
	ComputerName      string            `idl:"name:ComputerName;string" json:"computer_name"`
	ClientCredential  *Credential       `idl:"name:ClientCredential" json:"client_credential"`
}

func (o *AuthenticateRequest) xxx_ToOp(ctx context.Context, op *xxx_AuthenticateOperation) *xxx_AuthenticateOperation {
	if op == nil {
		op = &xxx_AuthenticateOperation{}
	}
	if o == nil {
		return op
	}
	op.PrimaryName = o.PrimaryName
	op.AccountName = o.AccountName
	op.SecureChannelType = o.SecureChannelType
	op.ComputerName = o.ComputerName
	op.ClientCredential = o.ClientCredential
	return op
}

func (o *AuthenticateRequest) xxx_FromOp(ctx context.Context, op *xxx_AuthenticateOperation) {
	if o == nil {
		return
	}
	o.PrimaryName = op.PrimaryName
	o.AccountName = op.AccountName
	o.SecureChannelType = op.SecureChannelType
	o.ComputerName = op.ComputerName
	o.ClientCredential = op.ClientCredential
}
func (o *AuthenticateRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *AuthenticateRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AuthenticateOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AuthenticateResponse structure represents the NetrServerAuthenticate operation response
type AuthenticateResponse struct {
	ServerCredential *Credential `idl:"name:ServerCredential" json:"server_credential"`
	// Return: The NetrServerAuthenticate return value.
	Return int32 `idl:"name:Return" json:"return"`
}

func (o *AuthenticateResponse) xxx_ToOp(ctx context.Context, op *xxx_AuthenticateOperation) *xxx_AuthenticateOperation {
	if op == nil {
		op = &xxx_AuthenticateOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerCredential = o.ServerCredential
	op.Return = o.Return
	return op
}

func (o *AuthenticateResponse) xxx_FromOp(ctx context.Context, op *xxx_AuthenticateOperation) {
	if o == nil {
		return
	}
	o.ServerCredential = op.ServerCredential
	o.Return = op.Return
}
func (o *AuthenticateResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *AuthenticateResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AuthenticateOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_PasswordSetOperation structure represents the NetrServerPasswordSet operation
type xxx_PasswordSetOperation struct {
	PrimaryName         string                  `idl:"name:PrimaryName;string;pointer:unique" json:"primary_name"`
	AccountName         string                  `idl:"name:AccountName;string" json:"account_name"`
	SecureChannelType   SecureChannelType       `idl:"name:SecureChannelType" json:"secure_channel_type"`
	ComputerName        string                  `idl:"name:ComputerName;string" json:"computer_name"`
	Authenticator       *Authenticator          `idl:"name:Authenticator" json:"authenticator"`
	ReturnAuthenticator *Authenticator          `idl:"name:ReturnAuthenticator" json:"return_authenticator"`
	UASNewPassword      *EncryptedNTOWFPassword `idl:"name:UasNewPassword" json:"uas_new_password"`
	Return              int32                   `idl:"name:Return" json:"return"`
}

func (o *xxx_PasswordSetOperation) OpNum() int { return 6 }

func (o *xxx_PasswordSetOperation) OpName() string { return "/logon/v1/NetrServerPasswordSet" }

func (o *xxx_PasswordSetOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_PasswordSetOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// PrimaryName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.PrimaryName != "" {
			_ptr_PrimaryName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.PrimaryName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.PrimaryName, _ptr_PrimaryName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// AccountName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.AccountName); err != nil {
			return err
		}
	}
	// SecureChannelType {in} (1:{alias=NETLOGON_SECURE_CHANNEL_TYPE}(enum))
	{
		if err := w.WriteEnum(uint16(o.SecureChannelType)); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ComputerName); err != nil {
			return err
		}
	}
	// Authenticator {in} (1:{alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.Authenticator != nil {
			if err := o.Authenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// UasNewPassword {in} (1:{alias=PENCRYPTED_NT_OWF_PASSWORD}*(1))(2:{alias=ENCRYPTED_NT_OWF_PASSWORD}(struct))
	{
		if o.UASNewPassword != nil {
			if err := o.UASNewPassword.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&EncryptedNTOWFPassword{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_PasswordSetOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// PrimaryName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_PrimaryName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.PrimaryName); err != nil {
				return err
			}
			return nil
		})
		_s_PrimaryName := func(ptr interface{}) { o.PrimaryName = *ptr.(*string) }
		if err := w.ReadPointer(&o.PrimaryName, _s_PrimaryName, _ptr_PrimaryName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// AccountName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.AccountName); err != nil {
			return err
		}
	}
	// SecureChannelType {in} (1:{alias=NETLOGON_SECURE_CHANNEL_TYPE}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.SecureChannelType)); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ComputerName); err != nil {
			return err
		}
	}
	// Authenticator {in} (1:{alias=PNETLOGON_AUTHENTICATOR,pointer=ref}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.Authenticator == nil {
			o.Authenticator = &Authenticator{}
		}
		if err := o.Authenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// UasNewPassword {in} (1:{alias=PENCRYPTED_NT_OWF_PASSWORD,pointer=ref}*(1))(2:{alias=ENCRYPTED_NT_OWF_PASSWORD}(struct))
	{
		if o.UASNewPassword == nil {
			o.UASNewPassword = &EncryptedNTOWFPassword{}
		}
		if err := o.UASNewPassword.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_PasswordSetOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_PasswordSetOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ReturnAuthenticator {out} (1:{alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator != nil {
			if err := o.ReturnAuthenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_PasswordSetOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ReturnAuthenticator {out} (1:{alias=PNETLOGON_AUTHENTICATOR,pointer=ref}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator == nil {
			o.ReturnAuthenticator = &Authenticator{}
		}
		if err := o.ReturnAuthenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// PasswordSetRequest structure represents the NetrServerPasswordSet operation request
type PasswordSetRequest struct {
	// PrimaryName: The custom binding handle, as defined in section 3.5.4.1.
	PrimaryName string `idl:"name:PrimaryName;string;pointer:unique" json:"primary_name"`
	// AccountName: The null-terminated Unicode string that contains the name of the account
	// whose password is being changed.<183>
	AccountName string `idl:"name:AccountName;string" json:"account_name"`
	// SecureChannelType: An enumerated value (specified in section 2.2.1.3.13) that indicates
	// the type of secure channel used by the client.
	SecureChannelType SecureChannelType `idl:"name:SecureChannelType" json:"secure_channel_type"`
	// ComputerName: A null-terminated Unicode string that contains the NetBIOS name of
	// the client computer calling this method.
	ComputerName string `idl:"name:ComputerName;string" json:"computer_name"`
	// Authenticator: A pointer to a NETLOGON_AUTHENTICATOR structure, as specified in section
	// 2.2.1.1.5, that contains the client authenticator.
	Authenticator *Authenticator `idl:"name:Authenticator" json:"authenticator"`
	// UasNewPassword: A pointer to an ENCRYPTED_NT_OWF_PASSWORD structure, as specified
	// in [MS-SAMR] section 2.2.7.3 and encrypted by the algorithm specified in section
	// 3.4.5.2.6.
	UASNewPassword *EncryptedNTOWFPassword `idl:"name:UasNewPassword" json:"uas_new_password"`
}

func (o *PasswordSetRequest) xxx_ToOp(ctx context.Context, op *xxx_PasswordSetOperation) *xxx_PasswordSetOperation {
	if op == nil {
		op = &xxx_PasswordSetOperation{}
	}
	if o == nil {
		return op
	}
	op.PrimaryName = o.PrimaryName
	op.AccountName = o.AccountName
	op.SecureChannelType = o.SecureChannelType
	op.ComputerName = o.ComputerName
	op.Authenticator = o.Authenticator
	op.UASNewPassword = o.UASNewPassword
	return op
}

func (o *PasswordSetRequest) xxx_FromOp(ctx context.Context, op *xxx_PasswordSetOperation) {
	if o == nil {
		return
	}
	o.PrimaryName = op.PrimaryName
	o.AccountName = op.AccountName
	o.SecureChannelType = op.SecureChannelType
	o.ComputerName = op.ComputerName
	o.Authenticator = op.Authenticator
	o.UASNewPassword = op.UASNewPassword
}
func (o *PasswordSetRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *PasswordSetRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_PasswordSetOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// PasswordSetResponse structure represents the NetrServerPasswordSet operation response
type PasswordSetResponse struct {
	// ReturnAuthenticator: A pointer to a NETLOGON_AUTHENTICATOR structure, as specified
	// in section 2.2.1.1.5, that contains the server return authenticator.
	ReturnAuthenticator *Authenticator `idl:"name:ReturnAuthenticator" json:"return_authenticator"`
	// Return: The NetrServerPasswordSet return value.
	Return int32 `idl:"name:Return" json:"return"`
}

func (o *PasswordSetResponse) xxx_ToOp(ctx context.Context, op *xxx_PasswordSetOperation) *xxx_PasswordSetOperation {
	if op == nil {
		op = &xxx_PasswordSetOperation{}
	}
	if o == nil {
		return op
	}
	op.ReturnAuthenticator = o.ReturnAuthenticator
	op.Return = o.Return
	return op
}

func (o *PasswordSetResponse) xxx_FromOp(ctx context.Context, op *xxx_PasswordSetOperation) {
	if o == nil {
		return
	}
	o.ReturnAuthenticator = op.ReturnAuthenticator
	o.Return = op.Return
}
func (o *PasswordSetResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *PasswordSetResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_PasswordSetOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_DatabaseDeltasOperation structure represents the NetrDatabaseDeltas operation
type xxx_DatabaseDeltasOperation struct {
	PrimaryName            string          `idl:"name:PrimaryName;string" json:"primary_name"`
	ComputerName           string          `idl:"name:ComputerName;string" json:"computer_name"`
	Authenticator          *Authenticator  `idl:"name:Authenticator" json:"authenticator"`
	ReturnAuthenticator    *Authenticator  `idl:"name:ReturnAuthenticator" json:"return_authenticator"`
	DatabaseID             uint32          `idl:"name:DatabaseID" json:"database_id"`
	DomainModifiedCount    *ModifiedCount  `idl:"name:DomainModifiedCount" json:"domain_modified_count"`
	DeltaArray             *DeltaEnumArray `idl:"name:DeltaArray" json:"delta_array"`
	PreferredMaximumLength uint32          `idl:"name:PreferredMaximumLength" json:"preferred_maximum_length"`
	Return                 int32           `idl:"name:Return" json:"return"`
}

func (o *xxx_DatabaseDeltasOperation) OpNum() int { return 7 }

func (o *xxx_DatabaseDeltasOperation) OpName() string { return "/logon/v1/NetrDatabaseDeltas" }

func (o *xxx_DatabaseDeltasOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DatabaseDeltasOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// PrimaryName {in} (1:{handle, string, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.PrimaryName); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ComputerName); err != nil {
			return err
		}
	}
	// Authenticator {in} (1:{alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.Authenticator != nil {
			if err := o.Authenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// ReturnAuthenticator {in, out} (1:{alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator != nil {
			if err := o.ReturnAuthenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// DatabaseID {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DatabaseID); err != nil {
			return err
		}
	}
	// DomainModifiedCount {in, out} (1:{alias=PNLPR_MODIFIED_COUNT}*(1))(2:{alias=NLPR_MODIFIED_COUNT}(struct))
	{
		if o.DomainModifiedCount != nil {
			if err := o.DomainModifiedCount.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ModifiedCount{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// PreferredMaximumLength {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PreferredMaximumLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DatabaseDeltasOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// PrimaryName {in} (1:{handle, string, alias=LOGONSRV_HANDLE,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.PrimaryName); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ComputerName); err != nil {
			return err
		}
	}
	// Authenticator {in} (1:{alias=PNETLOGON_AUTHENTICATOR,pointer=ref}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.Authenticator == nil {
			o.Authenticator = &Authenticator{}
		}
		if err := o.Authenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// ReturnAuthenticator {in, out} (1:{alias=PNETLOGON_AUTHENTICATOR,pointer=ref}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator == nil {
			o.ReturnAuthenticator = &Authenticator{}
		}
		if err := o.ReturnAuthenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// DatabaseID {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DatabaseID); err != nil {
			return err
		}
	}
	// DomainModifiedCount {in, out} (1:{alias=PNLPR_MODIFIED_COUNT,pointer=ref}*(1))(2:{alias=NLPR_MODIFIED_COUNT}(struct))
	{
		if o.DomainModifiedCount == nil {
			o.DomainModifiedCount = &ModifiedCount{}
		}
		if err := o.DomainModifiedCount.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// PreferredMaximumLength {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PreferredMaximumLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DatabaseDeltasOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DatabaseDeltasOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ReturnAuthenticator {in, out} (1:{alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator != nil {
			if err := o.ReturnAuthenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// DomainModifiedCount {in, out} (1:{alias=PNLPR_MODIFIED_COUNT}*(1))(2:{alias=NLPR_MODIFIED_COUNT}(struct))
	{
		if o.DomainModifiedCount != nil {
			if err := o.DomainModifiedCount.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&ModifiedCount{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// DeltaArray {out} (1:{pointer=ref}*(2))(2:{alias=PNETLOGON_DELTA_ENUM_ARRAY}*(1))(3:{alias=NETLOGON_DELTA_ENUM_ARRAY}(struct))
	{
		if o.DeltaArray != nil {
			_ptr_DeltaArray := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.DeltaArray != nil {
					if err := o.DeltaArray.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&DeltaEnumArray{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.DeltaArray, _ptr_DeltaArray); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DatabaseDeltasOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ReturnAuthenticator {in, out} (1:{alias=PNETLOGON_AUTHENTICATOR,pointer=ref}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator == nil {
			o.ReturnAuthenticator = &Authenticator{}
		}
		if err := o.ReturnAuthenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// DomainModifiedCount {in, out} (1:{alias=PNLPR_MODIFIED_COUNT,pointer=ref}*(1))(2:{alias=NLPR_MODIFIED_COUNT}(struct))
	{
		if o.DomainModifiedCount == nil {
			o.DomainModifiedCount = &ModifiedCount{}
		}
		if err := o.DomainModifiedCount.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// DeltaArray {out} (1:{pointer=ref}*(2))(2:{alias=PNETLOGON_DELTA_ENUM_ARRAY,pointer=ref}*(1))(3:{alias=NETLOGON_DELTA_ENUM_ARRAY}(struct))
	{
		_ptr_DeltaArray := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.DeltaArray == nil {
				o.DeltaArray = &DeltaEnumArray{}
			}
			if err := o.DeltaArray.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_DeltaArray := func(ptr interface{}) { o.DeltaArray = *ptr.(**DeltaEnumArray) }
		if err := w.ReadPointer(&o.DeltaArray, _s_DeltaArray, _ptr_DeltaArray); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// DatabaseDeltasRequest structure represents the NetrDatabaseDeltas operation request
type DatabaseDeltasRequest struct {
	// PrimaryName: The custom binding handle (as defined in section 3.5.4.1) that represents
	// the connection to the PDC.
	PrimaryName string `idl:"name:PrimaryName;string" json:"primary_name"`
	// ComputerName: The null-terminated Unicode string that contains the NetBIOS name of
	// the BDC calling this method.
	ComputerName string `idl:"name:ComputerName;string" json:"computer_name"`
	// Authenticator: A pointer to a NETLOGON_AUTHENTICATOR structure that contains the
	// client authenticator.
	Authenticator *Authenticator `idl:"name:Authenticator" json:"authenticator"`
	// ReturnAuthenticator: A pointer to a NETLOGON_AUTHENTICATOR structure that contains
	// the server return authenticator.
	ReturnAuthenticator *Authenticator `idl:"name:ReturnAuthenticator" json:"return_authenticator"`
	// DatabaseID: The identifier for a specific account database set as follows:
	//
	//	+------------+--------------------------------------+
	//	|            |                                      |
	//	|   VALUE    |               MEANING                |
	//	|            |                                      |
	//	+------------+--------------------------------------+
	//	+------------+--------------------------------------+
	//	| 0x00000000 | Indicates the SAM database.          |
	//	+------------+--------------------------------------+
	//	| 0x00000001 | Indicates the SAM built-in database. |
	//	+------------+--------------------------------------+
	//	| 0x00000002 | Indicates the LSA database.          |
	//	+------------+--------------------------------------+
	DatabaseID uint32 `idl:"name:DatabaseID" json:"database_id"`
	// DomainModifiedCount: A pointer to an NLPR_MODIFIED_COUNT structure, as specified
	// in section 2.2.1.5.26, that contains the database serial number. On input, this is
	// the value of the database serial number on the client. On output, this is the value
	// of the database serial number corresponding to the last element (delta) returned
	// in the DeltaArray parameter.
	DomainModifiedCount *ModifiedCount `idl:"name:DomainModifiedCount" json:"domain_modified_count"`
	// PreferredMaximumLength: The value that specifies the preferred maximum size, in bytes,
	// of data to return in the DeltaArray parameter. This is not a hard upper limit but
	// serves as a guide to the server. The server SHOULD<218> stop including elements in
	// the returned DeltaArray after the size of the returned data equals or exceeds the
	// value of the PreferredMaximumLength parameter. It is up to the client implementation
	// to choose the value for this parameter.
	PreferredMaximumLength uint32 `idl:"name:PreferredMaximumLength" json:"preferred_maximum_length"`
}

func (o *DatabaseDeltasRequest) xxx_ToOp(ctx context.Context, op *xxx_DatabaseDeltasOperation) *xxx_DatabaseDeltasOperation {
	if op == nil {
		op = &xxx_DatabaseDeltasOperation{}
	}
	if o == nil {
		return op
	}
	op.PrimaryName = o.PrimaryName
	op.ComputerName = o.ComputerName
	op.Authenticator = o.Authenticator
	op.ReturnAuthenticator = o.ReturnAuthenticator
	op.DatabaseID = o.DatabaseID
	op.DomainModifiedCount = o.DomainModifiedCount
	op.PreferredMaximumLength = o.PreferredMaximumLength
	return op
}

func (o *DatabaseDeltasRequest) xxx_FromOp(ctx context.Context, op *xxx_DatabaseDeltasOperation) {
	if o == nil {
		return
	}
	o.PrimaryName = op.PrimaryName
	o.ComputerName = op.ComputerName
	o.Authenticator = op.Authenticator
	o.ReturnAuthenticator = op.ReturnAuthenticator
	o.DatabaseID = op.DatabaseID
	o.DomainModifiedCount = op.DomainModifiedCount
	o.PreferredMaximumLength = op.PreferredMaximumLength
}
func (o *DatabaseDeltasRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *DatabaseDeltasRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DatabaseDeltasOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// DatabaseDeltasResponse structure represents the NetrDatabaseDeltas operation response
type DatabaseDeltasResponse struct {
	// ReturnAuthenticator: A pointer to a NETLOGON_AUTHENTICATOR structure that contains
	// the server return authenticator.
	ReturnAuthenticator *Authenticator `idl:"name:ReturnAuthenticator" json:"return_authenticator"`
	// DomainModifiedCount: A pointer to an NLPR_MODIFIED_COUNT structure, as specified
	// in section 2.2.1.5.26, that contains the database serial number. On input, this is
	// the value of the database serial number on the client. On output, this is the value
	// of the database serial number corresponding to the last element (delta) returned
	// in the DeltaArray parameter.
	DomainModifiedCount *ModifiedCount `idl:"name:DomainModifiedCount" json:"domain_modified_count"`
	// DeltaArray: A pointer to a NETLOGON_DELTA_ENUM_ARRAY structure that contains an array
	// of enumerated changes (deltas) to the specified database with database serial numbers
	// larger than the database serial number value specified in the input value of the
	// DomainModifiedCount parameter.
	DeltaArray *DeltaEnumArray `idl:"name:DeltaArray" json:"delta_array"`
	// Return: The NetrDatabaseDeltas return value.
	Return int32 `idl:"name:Return" json:"return"`
}

func (o *DatabaseDeltasResponse) xxx_ToOp(ctx context.Context, op *xxx_DatabaseDeltasOperation) *xxx_DatabaseDeltasOperation {
	if op == nil {
		op = &xxx_DatabaseDeltasOperation{}
	}
	if o == nil {
		return op
	}
	op.ReturnAuthenticator = o.ReturnAuthenticator
	op.DomainModifiedCount = o.DomainModifiedCount
	op.DeltaArray = o.DeltaArray
	op.Return = o.Return
	return op
}

func (o *DatabaseDeltasResponse) xxx_FromOp(ctx context.Context, op *xxx_DatabaseDeltasOperation) {
	if o == nil {
		return
	}
	o.ReturnAuthenticator = op.ReturnAuthenticator
	o.DomainModifiedCount = op.DomainModifiedCount
	o.DeltaArray = op.DeltaArray
	o.Return = op.Return
}
func (o *DatabaseDeltasResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *DatabaseDeltasResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DatabaseDeltasOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_DatabaseSyncOperation structure represents the NetrDatabaseSync operation
type xxx_DatabaseSyncOperation struct {
	PrimaryName            string          `idl:"name:PrimaryName;string" json:"primary_name"`
	ComputerName           string          `idl:"name:ComputerName;string" json:"computer_name"`
	Authenticator          *Authenticator  `idl:"name:Authenticator" json:"authenticator"`
	ReturnAuthenticator    *Authenticator  `idl:"name:ReturnAuthenticator" json:"return_authenticator"`
	DatabaseID             uint32          `idl:"name:DatabaseID" json:"database_id"`
	SyncContext            uint32          `idl:"name:SyncContext" json:"sync_context"`
	DeltaArray             *DeltaEnumArray `idl:"name:DeltaArray" json:"delta_array"`
	PreferredMaximumLength uint32          `idl:"name:PreferredMaximumLength" json:"preferred_maximum_length"`
	Return                 int32           `idl:"name:Return" json:"return"`
}

func (o *xxx_DatabaseSyncOperation) OpNum() int { return 8 }

func (o *xxx_DatabaseSyncOperation) OpName() string { return "/logon/v1/NetrDatabaseSync" }

func (o *xxx_DatabaseSyncOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DatabaseSyncOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// PrimaryName {in} (1:{handle, string, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.PrimaryName); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ComputerName); err != nil {
			return err
		}
	}
	// Authenticator {in} (1:{alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.Authenticator != nil {
			if err := o.Authenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// ReturnAuthenticator {in, out} (1:{alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator != nil {
			if err := o.ReturnAuthenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// DatabaseID {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DatabaseID); err != nil {
			return err
		}
	}
	// SyncContext {in, out} (1:{pointer=ref}*(1))(2:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.SyncContext); err != nil {
			return err
		}
	}
	// PreferredMaximumLength {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PreferredMaximumLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DatabaseSyncOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// PrimaryName {in} (1:{handle, string, alias=LOGONSRV_HANDLE,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.PrimaryName); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ComputerName); err != nil {
			return err
		}
	}
	// Authenticator {in} (1:{alias=PNETLOGON_AUTHENTICATOR,pointer=ref}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.Authenticator == nil {
			o.Authenticator = &Authenticator{}
		}
		if err := o.Authenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// ReturnAuthenticator {in, out} (1:{alias=PNETLOGON_AUTHENTICATOR,pointer=ref}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator == nil {
			o.ReturnAuthenticator = &Authenticator{}
		}
		if err := o.ReturnAuthenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// DatabaseID {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DatabaseID); err != nil {
			return err
		}
	}
	// SyncContext {in, out} (1:{pointer=ref}*(1))(2:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.SyncContext); err != nil {
			return err
		}
	}
	// PreferredMaximumLength {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PreferredMaximumLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DatabaseSyncOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DatabaseSyncOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ReturnAuthenticator {in, out} (1:{alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator != nil {
			if err := o.ReturnAuthenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// SyncContext {in, out} (1:{pointer=ref}*(1))(2:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.SyncContext); err != nil {
			return err
		}
	}
	// DeltaArray {out} (1:{pointer=ref}*(2))(2:{alias=PNETLOGON_DELTA_ENUM_ARRAY}*(1))(3:{alias=NETLOGON_DELTA_ENUM_ARRAY}(struct))
	{
		if o.DeltaArray != nil {
			_ptr_DeltaArray := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.DeltaArray != nil {
					if err := o.DeltaArray.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&DeltaEnumArray{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.DeltaArray, _ptr_DeltaArray); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DatabaseSyncOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ReturnAuthenticator {in, out} (1:{alias=PNETLOGON_AUTHENTICATOR,pointer=ref}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator == nil {
			o.ReturnAuthenticator = &Authenticator{}
		}
		if err := o.ReturnAuthenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// SyncContext {in, out} (1:{pointer=ref}*(1))(2:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.SyncContext); err != nil {
			return err
		}
	}
	// DeltaArray {out} (1:{pointer=ref}*(2))(2:{alias=PNETLOGON_DELTA_ENUM_ARRAY,pointer=ref}*(1))(3:{alias=NETLOGON_DELTA_ENUM_ARRAY}(struct))
	{
		_ptr_DeltaArray := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.DeltaArray == nil {
				o.DeltaArray = &DeltaEnumArray{}
			}
			if err := o.DeltaArray.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_DeltaArray := func(ptr interface{}) { o.DeltaArray = *ptr.(**DeltaEnumArray) }
		if err := w.ReadPointer(&o.DeltaArray, _s_DeltaArray, _ptr_DeltaArray); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// DatabaseSyncRequest structure represents the NetrDatabaseSync operation request
type DatabaseSyncRequest struct {
	PrimaryName            string         `idl:"name:PrimaryName;string" json:"primary_name"`
	ComputerName           string         `idl:"name:ComputerName;string" json:"computer_name"`
	Authenticator          *Authenticator `idl:"name:Authenticator" json:"authenticator"`
	ReturnAuthenticator    *Authenticator `idl:"name:ReturnAuthenticator" json:"return_authenticator"`
	DatabaseID             uint32         `idl:"name:DatabaseID" json:"database_id"`
	SyncContext            uint32         `idl:"name:SyncContext" json:"sync_context"`
	PreferredMaximumLength uint32         `idl:"name:PreferredMaximumLength" json:"preferred_maximum_length"`
}

func (o *DatabaseSyncRequest) xxx_ToOp(ctx context.Context, op *xxx_DatabaseSyncOperation) *xxx_DatabaseSyncOperation {
	if op == nil {
		op = &xxx_DatabaseSyncOperation{}
	}
	if o == nil {
		return op
	}
	op.PrimaryName = o.PrimaryName
	op.ComputerName = o.ComputerName
	op.Authenticator = o.Authenticator
	op.ReturnAuthenticator = o.ReturnAuthenticator
	op.DatabaseID = o.DatabaseID
	op.SyncContext = o.SyncContext
	op.PreferredMaximumLength = o.PreferredMaximumLength
	return op
}

func (o *DatabaseSyncRequest) xxx_FromOp(ctx context.Context, op *xxx_DatabaseSyncOperation) {
	if o == nil {
		return
	}
	o.PrimaryName = op.PrimaryName
	o.ComputerName = op.ComputerName
	o.Authenticator = op.Authenticator
	o.ReturnAuthenticator = op.ReturnAuthenticator
	o.DatabaseID = op.DatabaseID
	o.SyncContext = op.SyncContext
	o.PreferredMaximumLength = op.PreferredMaximumLength
}
func (o *DatabaseSyncRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *DatabaseSyncRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DatabaseSyncOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// DatabaseSyncResponse structure represents the NetrDatabaseSync operation response
type DatabaseSyncResponse struct {
	ReturnAuthenticator *Authenticator  `idl:"name:ReturnAuthenticator" json:"return_authenticator"`
	SyncContext         uint32          `idl:"name:SyncContext" json:"sync_context"`
	DeltaArray          *DeltaEnumArray `idl:"name:DeltaArray" json:"delta_array"`
	// Return: The NetrDatabaseSync return value.
	Return int32 `idl:"name:Return" json:"return"`
}

func (o *DatabaseSyncResponse) xxx_ToOp(ctx context.Context, op *xxx_DatabaseSyncOperation) *xxx_DatabaseSyncOperation {
	if op == nil {
		op = &xxx_DatabaseSyncOperation{}
	}
	if o == nil {
		return op
	}
	op.ReturnAuthenticator = o.ReturnAuthenticator
	op.SyncContext = o.SyncContext
	op.DeltaArray = o.DeltaArray
	op.Return = o.Return
	return op
}

func (o *DatabaseSyncResponse) xxx_FromOp(ctx context.Context, op *xxx_DatabaseSyncOperation) {
	if o == nil {
		return
	}
	o.ReturnAuthenticator = op.ReturnAuthenticator
	o.SyncContext = op.SyncContext
	o.DeltaArray = op.DeltaArray
	o.Return = op.Return
}
func (o *DatabaseSyncResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *DatabaseSyncResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DatabaseSyncOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AccountDeltasOperation structure represents the NetrAccountDeltas operation
type xxx_AccountDeltasOperation struct {
	PrimaryName         string         `idl:"name:PrimaryName;string;pointer:unique" json:"primary_name"`
	ComputerName        string         `idl:"name:ComputerName;string" json:"computer_name"`
	Authenticator       *Authenticator `idl:"name:Authenticator" json:"authenticator"`
	ReturnAuthenticator *Authenticator `idl:"name:ReturnAuthenticator" json:"return_authenticator"`
	RecordID            *UASInfo0      `idl:"name:RecordId" json:"record_id"`
	Count               uint32         `idl:"name:Count" json:"count"`
	Level               uint32         `idl:"name:Level" json:"level"`
	Buffer              []byte         `idl:"name:Buffer;size_is:(BufferSize)" json:"buffer"`
	BufferSize          uint32         `idl:"name:BufferSize" json:"buffer_size"`
	CountReturned       uint32         `idl:"name:CountReturned" json:"count_returned"`
	TotalEntries        uint32         `idl:"name:TotalEntries" json:"total_entries"`
	NextRecordID        *UASInfo0      `idl:"name:NextRecordId" json:"next_record_id"`
	Return              int32          `idl:"name:Return" json:"return"`
}

func (o *xxx_AccountDeltasOperation) OpNum() int { return 9 }

func (o *xxx_AccountDeltasOperation) OpName() string { return "/logon/v1/NetrAccountDeltas" }

func (o *xxx_AccountDeltasOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AccountDeltasOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// PrimaryName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.PrimaryName != "" {
			_ptr_PrimaryName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.PrimaryName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.PrimaryName, _ptr_PrimaryName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ComputerName); err != nil {
			return err
		}
	}
	// Authenticator {in} (1:{alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.Authenticator != nil {
			if err := o.Authenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// ReturnAuthenticator {in, out} (1:{alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator != nil {
			if err := o.ReturnAuthenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// RecordId {in} (1:{alias=PUAS_INFO_0}*(1))(2:{alias=UAS_INFO_0}(struct))
	{
		if o.RecordID != nil {
			if err := o.RecordID.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&UASInfo0{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Count {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Count); err != nil {
			return err
		}
	}
	// Level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Level); err != nil {
			return err
		}
	}
	// BufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AccountDeltasOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// PrimaryName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_PrimaryName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.PrimaryName); err != nil {
				return err
			}
			return nil
		})
		_s_PrimaryName := func(ptr interface{}) { o.PrimaryName = *ptr.(*string) }
		if err := w.ReadPointer(&o.PrimaryName, _s_PrimaryName, _ptr_PrimaryName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ComputerName); err != nil {
			return err
		}
	}
	// Authenticator {in} (1:{alias=PNETLOGON_AUTHENTICATOR,pointer=ref}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.Authenticator == nil {
			o.Authenticator = &Authenticator{}
		}
		if err := o.Authenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// ReturnAuthenticator {in, out} (1:{alias=PNETLOGON_AUTHENTICATOR,pointer=ref}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator == nil {
			o.ReturnAuthenticator = &Authenticator{}
		}
		if err := o.ReturnAuthenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// RecordId {in} (1:{alias=PUAS_INFO_0,pointer=ref}*(1))(2:{alias=UAS_INFO_0}(struct))
	{
		if o.RecordID == nil {
			o.RecordID = &UASInfo0{}
		}
		if err := o.RecordID.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Count {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Count); err != nil {
			return err
		}
	}
	// Level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Level); err != nil {
			return err
		}
	}
	// BufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AccountDeltasOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AccountDeltasOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ReturnAuthenticator {in, out} (1:{alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator != nil {
			if err := o.ReturnAuthenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Buffer {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=BufferSize](uchar))
	{
		dimSize1 := uint64(o.BufferSize)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.Buffer {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.Buffer[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// CountReturned {out} (1:{pointer=ref}*(1))(2:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.CountReturned); err != nil {
			return err
		}
	}
	// TotalEntries {out} (1:{pointer=ref}*(1))(2:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.TotalEntries); err != nil {
			return err
		}
	}
	// NextRecordId {out} (1:{alias=PUAS_INFO_0}*(1))(2:{alias=UAS_INFO_0}(struct))
	{
		if o.NextRecordID != nil {
			if err := o.NextRecordID.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&UASInfo0{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AccountDeltasOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ReturnAuthenticator {in, out} (1:{alias=PNETLOGON_AUTHENTICATOR,pointer=ref}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator == nil {
			o.ReturnAuthenticator = &Authenticator{}
		}
		if err := o.ReturnAuthenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Buffer {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=BufferSize](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
		}
		o.Buffer = make([]byte, sizeInfo[0])
		for i1 := range o.Buffer {
			i1 := i1
			if err := w.ReadData(&o.Buffer[i1]); err != nil {
				return err
			}
		}
	}
	// CountReturned {out} (1:{pointer=ref}*(1))(2:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.CountReturned); err != nil {
			return err
		}
	}
	// TotalEntries {out} (1:{pointer=ref}*(1))(2:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.TotalEntries); err != nil {
			return err
		}
	}
	// NextRecordId {out} (1:{alias=PUAS_INFO_0,pointer=ref}*(1))(2:{alias=UAS_INFO_0}(struct))
	{
		if o.NextRecordID == nil {
			o.NextRecordID = &UASInfo0{}
		}
		if err := o.NextRecordID.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AccountDeltasRequest structure represents the NetrAccountDeltas operation request
type AccountDeltasRequest struct {
	PrimaryName         string         `idl:"name:PrimaryName;string;pointer:unique" json:"primary_name"`
	ComputerName        string         `idl:"name:ComputerName;string" json:"computer_name"`
	Authenticator       *Authenticator `idl:"name:Authenticator" json:"authenticator"`
	ReturnAuthenticator *Authenticator `idl:"name:ReturnAuthenticator" json:"return_authenticator"`
	RecordID            *UASInfo0      `idl:"name:RecordId" json:"record_id"`
	Count               uint32         `idl:"name:Count" json:"count"`
	Level               uint32         `idl:"name:Level" json:"level"`
	BufferSize          uint32         `idl:"name:BufferSize" json:"buffer_size"`
}

func (o *AccountDeltasRequest) xxx_ToOp(ctx context.Context, op *xxx_AccountDeltasOperation) *xxx_AccountDeltasOperation {
	if op == nil {
		op = &xxx_AccountDeltasOperation{}
	}
	if o == nil {
		return op
	}
	op.PrimaryName = o.PrimaryName
	op.ComputerName = o.ComputerName
	op.Authenticator = o.Authenticator
	op.ReturnAuthenticator = o.ReturnAuthenticator
	op.RecordID = o.RecordID
	op.Count = o.Count
	op.Level = o.Level
	op.BufferSize = o.BufferSize
	return op
}

func (o *AccountDeltasRequest) xxx_FromOp(ctx context.Context, op *xxx_AccountDeltasOperation) {
	if o == nil {
		return
	}
	o.PrimaryName = op.PrimaryName
	o.ComputerName = op.ComputerName
	o.Authenticator = op.Authenticator
	o.ReturnAuthenticator = op.ReturnAuthenticator
	o.RecordID = op.RecordID
	o.Count = op.Count
	o.Level = op.Level
	o.BufferSize = op.BufferSize
}
func (o *AccountDeltasRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *AccountDeltasRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AccountDeltasOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AccountDeltasResponse structure represents the NetrAccountDeltas operation response
type AccountDeltasResponse struct {
	// XXX: BufferSize is an implicit input depedency for output parameters
	BufferSize uint32 `idl:"name:BufferSize" json:"buffer_size"`

	ReturnAuthenticator *Authenticator `idl:"name:ReturnAuthenticator" json:"return_authenticator"`
	Buffer              []byte         `idl:"name:Buffer;size_is:(BufferSize)" json:"buffer"`
	CountReturned       uint32         `idl:"name:CountReturned" json:"count_returned"`
	TotalEntries        uint32         `idl:"name:TotalEntries" json:"total_entries"`
	NextRecordID        *UASInfo0      `idl:"name:NextRecordId" json:"next_record_id"`
	// Return: The NetrAccountDeltas return value.
	Return int32 `idl:"name:Return" json:"return"`
}

func (o *AccountDeltasResponse) xxx_ToOp(ctx context.Context, op *xxx_AccountDeltasOperation) *xxx_AccountDeltasOperation {
	if op == nil {
		op = &xxx_AccountDeltasOperation{}
	}
	if o == nil {
		return op
	}
	// XXX: implicit input dependencies for output parameters
	if op.BufferSize == uint32(0) {
		op.BufferSize = o.BufferSize
	}

	op.ReturnAuthenticator = o.ReturnAuthenticator
	op.Buffer = o.Buffer
	op.CountReturned = o.CountReturned
	op.TotalEntries = o.TotalEntries
	op.NextRecordID = o.NextRecordID
	op.Return = o.Return
	return op
}

func (o *AccountDeltasResponse) xxx_FromOp(ctx context.Context, op *xxx_AccountDeltasOperation) {
	if o == nil {
		return
	}
	// XXX: implicit input dependencies for output parameters
	o.BufferSize = op.BufferSize

	o.ReturnAuthenticator = op.ReturnAuthenticator
	o.Buffer = op.Buffer
	o.CountReturned = op.CountReturned
	o.TotalEntries = op.TotalEntries
	o.NextRecordID = op.NextRecordID
	o.Return = op.Return
}
func (o *AccountDeltasResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *AccountDeltasResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AccountDeltasOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AccountSyncOperation structure represents the NetrAccountSync operation
type xxx_AccountSyncOperation struct {
	PrimaryName         string         `idl:"name:PrimaryName;string;pointer:unique" json:"primary_name"`
	ComputerName        string         `idl:"name:ComputerName;string" json:"computer_name"`
	Authenticator       *Authenticator `idl:"name:Authenticator" json:"authenticator"`
	ReturnAuthenticator *Authenticator `idl:"name:ReturnAuthenticator" json:"return_authenticator"`
	Reference           uint32         `idl:"name:Reference" json:"reference"`
	Level               uint32         `idl:"name:Level" json:"level"`
	Buffer              []byte         `idl:"name:Buffer;size_is:(BufferSize)" json:"buffer"`
	BufferSize          uint32         `idl:"name:BufferSize" json:"buffer_size"`
	CountReturned       uint32         `idl:"name:CountReturned" json:"count_returned"`
	TotalEntries        uint32         `idl:"name:TotalEntries" json:"total_entries"`
	NextReference       uint32         `idl:"name:NextReference" json:"next_reference"`
	LastRecordID        *UASInfo0      `idl:"name:LastRecordId" json:"last_record_id"`
	Return              int32          `idl:"name:Return" json:"return"`
}

func (o *xxx_AccountSyncOperation) OpNum() int { return 10 }

func (o *xxx_AccountSyncOperation) OpName() string { return "/logon/v1/NetrAccountSync" }

func (o *xxx_AccountSyncOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AccountSyncOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// PrimaryName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.PrimaryName != "" {
			_ptr_PrimaryName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.PrimaryName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.PrimaryName, _ptr_PrimaryName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ComputerName); err != nil {
			return err
		}
	}
	// Authenticator {in} (1:{alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.Authenticator != nil {
			if err := o.Authenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// ReturnAuthenticator {in, out} (1:{alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator != nil {
			if err := o.ReturnAuthenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Reference {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Reference); err != nil {
			return err
		}
	}
	// Level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Level); err != nil {
			return err
		}
	}
	// BufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.BufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AccountSyncOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// PrimaryName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_PrimaryName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.PrimaryName); err != nil {
				return err
			}
			return nil
		})
		_s_PrimaryName := func(ptr interface{}) { o.PrimaryName = *ptr.(*string) }
		if err := w.ReadPointer(&o.PrimaryName, _s_PrimaryName, _ptr_PrimaryName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ComputerName); err != nil {
			return err
		}
	}
	// Authenticator {in} (1:{alias=PNETLOGON_AUTHENTICATOR,pointer=ref}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.Authenticator == nil {
			o.Authenticator = &Authenticator{}
		}
		if err := o.Authenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// ReturnAuthenticator {in, out} (1:{alias=PNETLOGON_AUTHENTICATOR,pointer=ref}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator == nil {
			o.ReturnAuthenticator = &Authenticator{}
		}
		if err := o.ReturnAuthenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Reference {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Reference); err != nil {
			return err
		}
	}
	// Level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Level); err != nil {
			return err
		}
	}
	// BufferSize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.BufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AccountSyncOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AccountSyncOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ReturnAuthenticator {in, out} (1:{alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator != nil {
			if err := o.ReturnAuthenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Buffer {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=BufferSize](uchar))
	{
		dimSize1 := uint64(o.BufferSize)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.Buffer {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.Buffer[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.Buffer); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// CountReturned {out} (1:{pointer=ref}*(1))(2:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.CountReturned); err != nil {
			return err
		}
	}
	// TotalEntries {out} (1:{pointer=ref}*(1))(2:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.TotalEntries); err != nil {
			return err
		}
	}
	// NextReference {out} (1:{pointer=ref}*(1))(2:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.NextReference); err != nil {
			return err
		}
	}
	// LastRecordId {out} (1:{alias=PUAS_INFO_0}*(1))(2:{alias=UAS_INFO_0}(struct))
	{
		if o.LastRecordID != nil {
			if err := o.LastRecordID.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&UASInfo0{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AccountSyncOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ReturnAuthenticator {in, out} (1:{alias=PNETLOGON_AUTHENTICATOR,pointer=ref}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator == nil {
			o.ReturnAuthenticator = &Authenticator{}
		}
		if err := o.ReturnAuthenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Buffer {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=BufferSize](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Buffer", sizeInfo[0])
		}
		o.Buffer = make([]byte, sizeInfo[0])
		for i1 := range o.Buffer {
			i1 := i1
			if err := w.ReadData(&o.Buffer[i1]); err != nil {
				return err
			}
		}
	}
	// CountReturned {out} (1:{pointer=ref}*(1))(2:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.CountReturned); err != nil {
			return err
		}
	}
	// TotalEntries {out} (1:{pointer=ref}*(1))(2:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.TotalEntries); err != nil {
			return err
		}
	}
	// NextReference {out} (1:{pointer=ref}*(1))(2:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.NextReference); err != nil {
			return err
		}
	}
	// LastRecordId {out} (1:{alias=PUAS_INFO_0,pointer=ref}*(1))(2:{alias=UAS_INFO_0}(struct))
	{
		if o.LastRecordID == nil {
			o.LastRecordID = &UASInfo0{}
		}
		if err := o.LastRecordID.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AccountSyncRequest structure represents the NetrAccountSync operation request
type AccountSyncRequest struct {
	PrimaryName         string         `idl:"name:PrimaryName;string;pointer:unique" json:"primary_name"`
	ComputerName        string         `idl:"name:ComputerName;string" json:"computer_name"`
	Authenticator       *Authenticator `idl:"name:Authenticator" json:"authenticator"`
	ReturnAuthenticator *Authenticator `idl:"name:ReturnAuthenticator" json:"return_authenticator"`
	Reference           uint32         `idl:"name:Reference" json:"reference"`
	Level               uint32         `idl:"name:Level" json:"level"`
	BufferSize          uint32         `idl:"name:BufferSize" json:"buffer_size"`
}

func (o *AccountSyncRequest) xxx_ToOp(ctx context.Context, op *xxx_AccountSyncOperation) *xxx_AccountSyncOperation {
	if op == nil {
		op = &xxx_AccountSyncOperation{}
	}
	if o == nil {
		return op
	}
	op.PrimaryName = o.PrimaryName
	op.ComputerName = o.ComputerName
	op.Authenticator = o.Authenticator
	op.ReturnAuthenticator = o.ReturnAuthenticator
	op.Reference = o.Reference
	op.Level = o.Level
	op.BufferSize = o.BufferSize
	return op
}

func (o *AccountSyncRequest) xxx_FromOp(ctx context.Context, op *xxx_AccountSyncOperation) {
	if o == nil {
		return
	}
	o.PrimaryName = op.PrimaryName
	o.ComputerName = op.ComputerName
	o.Authenticator = op.Authenticator
	o.ReturnAuthenticator = op.ReturnAuthenticator
	o.Reference = op.Reference
	o.Level = op.Level
	o.BufferSize = op.BufferSize
}
func (o *AccountSyncRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *AccountSyncRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AccountSyncOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AccountSyncResponse structure represents the NetrAccountSync operation response
type AccountSyncResponse struct {
	// XXX: BufferSize is an implicit input depedency for output parameters
	BufferSize uint32 `idl:"name:BufferSize" json:"buffer_size"`

	ReturnAuthenticator *Authenticator `idl:"name:ReturnAuthenticator" json:"return_authenticator"`
	Buffer              []byte         `idl:"name:Buffer;size_is:(BufferSize)" json:"buffer"`
	CountReturned       uint32         `idl:"name:CountReturned" json:"count_returned"`
	TotalEntries        uint32         `idl:"name:TotalEntries" json:"total_entries"`
	NextReference       uint32         `idl:"name:NextReference" json:"next_reference"`
	LastRecordID        *UASInfo0      `idl:"name:LastRecordId" json:"last_record_id"`
	// Return: The NetrAccountSync return value.
	Return int32 `idl:"name:Return" json:"return"`
}

func (o *AccountSyncResponse) xxx_ToOp(ctx context.Context, op *xxx_AccountSyncOperation) *xxx_AccountSyncOperation {
	if op == nil {
		op = &xxx_AccountSyncOperation{}
	}
	if o == nil {
		return op
	}
	// XXX: implicit input dependencies for output parameters
	if op.BufferSize == uint32(0) {
		op.BufferSize = o.BufferSize
	}

	op.ReturnAuthenticator = o.ReturnAuthenticator
	op.Buffer = o.Buffer
	op.CountReturned = o.CountReturned
	op.TotalEntries = o.TotalEntries
	op.NextReference = o.NextReference
	op.LastRecordID = o.LastRecordID
	op.Return = o.Return
	return op
}

func (o *AccountSyncResponse) xxx_FromOp(ctx context.Context, op *xxx_AccountSyncOperation) {
	if o == nil {
		return
	}
	// XXX: implicit input dependencies for output parameters
	o.BufferSize = op.BufferSize

	o.ReturnAuthenticator = op.ReturnAuthenticator
	o.Buffer = op.Buffer
	o.CountReturned = op.CountReturned
	o.TotalEntries = op.TotalEntries
	o.NextReference = op.NextReference
	o.LastRecordID = op.LastRecordID
	o.Return = op.Return
}
func (o *AccountSyncResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *AccountSyncResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AccountSyncOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetNetrDCNameOperation structure represents the NetrGetDCName operation
type xxx_GetNetrDCNameOperation struct {
	ServerName string `idl:"name:ServerName;string" json:"server_name"`
	DomainName string `idl:"name:DomainName;string;pointer:unique" json:"domain_name"`
	Buffer     string `idl:"name:Buffer;string" json:"buffer"`
	Return     uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetNetrDCNameOperation) OpNum() int { return 11 }

func (o *xxx_GetNetrDCNameOperation) OpName() string { return "/logon/v1/NetrGetDCName" }

func (o *xxx_GetNetrDCNameOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNetrDCNameOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
			return err
		}
	}
	// DomainName {in} (1:{string, pointer=unique}*(1)[dim:0,string,null](wchar))
	{
		if o.DomainName != "" {
			_ptr_DomainName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.DomainName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.DomainName, _ptr_DomainName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNetrDCNameOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, alias=LOGONSRV_HANDLE,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
			return err
		}
	}
	// DomainName {in} (1:{string, pointer=unique}*(1)[dim:0,string,null](wchar))
	{
		_ptr_DomainName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.DomainName); err != nil {
				return err
			}
			return nil
		})
		_s_DomainName := func(ptr interface{}) { o.DomainName = *ptr.(*string) }
		if err := w.ReadPointer(&o.DomainName, _s_DomainName, _ptr_DomainName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNetrDCNameOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNetrDCNameOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Buffer {out} (1:{string, pointer=ref}*(2)*(1)[dim:0,string,null](wchar))
	{
		if o.Buffer != "" {
			_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.Buffer); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNetrDCNameOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Buffer {out} (1:{string, pointer=ref}*(2)*(1)[dim:0,string,null](wchar))
	{
		_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.Buffer); err != nil {
				return err
			}
			return nil
		})
		_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*string) }
		if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetNetrDCNameRequest structure represents the NetrGetDCName operation request
type GetNetrDCNameRequest struct {
	// ServerName: The custom binding handle, as defined in section 3.5.4.1, that represents
	// the connection to a domain controller.
	ServerName string `idl:"name:ServerName;string" json:"server_name"`
	// DomainName: A null-terminated Unicode string that specifies the NetBIOS name of the
	// domain.
	DomainName string `idl:"name:DomainName;string;pointer:unique" json:"domain_name"`
}

func (o *GetNetrDCNameRequest) xxx_ToOp(ctx context.Context, op *xxx_GetNetrDCNameOperation) *xxx_GetNetrDCNameOperation {
	if op == nil {
		op = &xxx_GetNetrDCNameOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.DomainName = o.DomainName
	return op
}

func (o *GetNetrDCNameRequest) xxx_FromOp(ctx context.Context, op *xxx_GetNetrDCNameOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.DomainName = op.DomainName
}
func (o *GetNetrDCNameRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetNetrDCNameRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetNetrDCNameOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetNetrDCNameResponse structure represents the NetrGetDCName operation response
type GetNetrDCNameResponse struct {
	// Buffer: A pointer to a null-terminated Unicode string that contains the NetBIOS name
	// of the PDC for the specified domain. The server name returned by this method is prefixed
	// by two backslashes (\\).
	Buffer string `idl:"name:Buffer;string" json:"buffer"`
	// Return: The NetrGetDCName return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetNetrDCNameResponse) xxx_ToOp(ctx context.Context, op *xxx_GetNetrDCNameOperation) *xxx_GetNetrDCNameOperation {
	if op == nil {
		op = &xxx_GetNetrDCNameOperation{}
	}
	if o == nil {
		return op
	}
	op.Buffer = o.Buffer
	op.Return = o.Return
	return op
}

func (o *GetNetrDCNameResponse) xxx_FromOp(ctx context.Context, op *xxx_GetNetrDCNameOperation) {
	if o == nil {
		return
	}
	o.Buffer = op.Buffer
	o.Return = op.Return
}
func (o *GetNetrDCNameResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetNetrDCNameResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetNetrDCNameOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ControlOperation structure represents the NetrLogonControl operation
type xxx_ControlOperation struct {
	ServerName   string                   `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	FunctionCode uint32                   `idl:"name:FunctionCode" json:"function_code"`
	QueryLevel   uint32                   `idl:"name:QueryLevel" json:"query_level"`
	Buffer       *ControlQueryInformation `idl:"name:Buffer;switch_is:QueryLevel" json:"buffer"`
	Return       uint32                   `idl:"name:Return" json:"return"`
}

func (o *xxx_ControlOperation) OpNum() int { return 12 }

func (o *xxx_ControlOperation) OpName() string { return "/logon/v1/NetrLogonControl" }

func (o *xxx_ControlOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ControlOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// FunctionCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.FunctionCode); err != nil {
			return err
		}
	}
	// QueryLevel {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.QueryLevel); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ControlOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// FunctionCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.FunctionCode); err != nil {
			return err
		}
	}
	// QueryLevel {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.QueryLevel); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ControlOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ControlOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Buffer {out} (1:{switch_type={alias=DWORD}(uint32), alias=PNETLOGON_CONTROL_QUERY_INFORMATION}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=NETLOGON_CONTROL_QUERY_INFORMATION}(union))
	{
		_swBuffer := uint32(o.QueryLevel)
		if o.Buffer != nil {
			if err := o.Buffer.MarshalUnionNDR(ctx, w, _swBuffer); err != nil {
				return err
			}
		} else {
			if err := (&ControlQueryInformation{}).MarshalUnionNDR(ctx, w, _swBuffer); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ControlOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Buffer {out} (1:{switch_type={alias=DWORD}(uint32), alias=PNETLOGON_CONTROL_QUERY_INFORMATION,pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=NETLOGON_CONTROL_QUERY_INFORMATION}(union))
	{
		if o.Buffer == nil {
			o.Buffer = &ControlQueryInformation{}
		}
		_swBuffer := uint32(o.QueryLevel)
		if err := o.Buffer.UnmarshalUnionNDR(ctx, w, _swBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ControlRequest structure represents the NetrLogonControl operation request
type ControlRequest struct {
	ServerName   string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	FunctionCode uint32 `idl:"name:FunctionCode" json:"function_code"`
	QueryLevel   uint32 `idl:"name:QueryLevel" json:"query_level"`
}

func (o *ControlRequest) xxx_ToOp(ctx context.Context, op *xxx_ControlOperation) *xxx_ControlOperation {
	if op == nil {
		op = &xxx_ControlOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.FunctionCode = o.FunctionCode
	op.QueryLevel = o.QueryLevel
	return op
}

func (o *ControlRequest) xxx_FromOp(ctx context.Context, op *xxx_ControlOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.FunctionCode = op.FunctionCode
	o.QueryLevel = op.QueryLevel
}
func (o *ControlRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *ControlRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ControlOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ControlResponse structure represents the NetrLogonControl operation response
type ControlResponse struct {
	// XXX: QueryLevel is an implicit input depedency for output parameters
	QueryLevel uint32 `idl:"name:QueryLevel" json:"query_level"`

	Buffer *ControlQueryInformation `idl:"name:Buffer;switch_is:QueryLevel" json:"buffer"`
	// Return: The NetrLogonControl return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ControlResponse) xxx_ToOp(ctx context.Context, op *xxx_ControlOperation) *xxx_ControlOperation {
	if op == nil {
		op = &xxx_ControlOperation{}
	}
	if o == nil {
		return op
	}
	// XXX: implicit input dependencies for output parameters
	if op.QueryLevel == uint32(0) {
		op.QueryLevel = o.QueryLevel
	}

	op.Buffer = o.Buffer
	op.Return = o.Return
	return op
}

func (o *ControlResponse) xxx_FromOp(ctx context.Context, op *xxx_ControlOperation) {
	if o == nil {
		return
	}
	// XXX: implicit input dependencies for output parameters
	o.QueryLevel = op.QueryLevel

	o.Buffer = op.Buffer
	o.Return = op.Return
}
func (o *ControlResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *ControlResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ControlOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetAnyDCNameOperation structure represents the NetrGetAnyDCName operation
type xxx_GetAnyDCNameOperation struct {
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	DomainName string `idl:"name:DomainName;string;pointer:unique" json:"domain_name"`
	Buffer     string `idl:"name:Buffer;string" json:"buffer"`
	Return     uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetAnyDCNameOperation) OpNum() int { return 13 }

func (o *xxx_GetAnyDCNameOperation) OpName() string { return "/logon/v1/NetrGetAnyDCName" }

func (o *xxx_GetAnyDCNameOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetAnyDCNameOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// DomainName {in} (1:{string, pointer=unique}*(1)[dim:0,string,null](wchar))
	{
		if o.DomainName != "" {
			_ptr_DomainName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.DomainName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.DomainName, _ptr_DomainName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetAnyDCNameOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// DomainName {in} (1:{string, pointer=unique}*(1)[dim:0,string,null](wchar))
	{
		_ptr_DomainName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.DomainName); err != nil {
				return err
			}
			return nil
		})
		_s_DomainName := func(ptr interface{}) { o.DomainName = *ptr.(*string) }
		if err := w.ReadPointer(&o.DomainName, _s_DomainName, _ptr_DomainName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetAnyDCNameOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetAnyDCNameOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Buffer {out} (1:{string, pointer=ref}*(2)*(1)[dim:0,string,null](wchar))
	{
		if o.Buffer != "" {
			_ptr_Buffer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.Buffer); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.Buffer, _ptr_Buffer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetAnyDCNameOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Buffer {out} (1:{string, pointer=ref}*(2)*(1)[dim:0,string,null](wchar))
	{
		_ptr_Buffer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.Buffer); err != nil {
				return err
			}
			return nil
		})
		_s_Buffer := func(ptr interface{}) { o.Buffer = *ptr.(*string) }
		if err := w.ReadPointer(&o.Buffer, _s_Buffer, _ptr_Buffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetAnyDCNameRequest structure represents the NetrGetAnyDCName operation request
type GetAnyDCNameRequest struct {
	// ServerName: The custom binding handle, as defined in section 3.5.4.1.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// DomainName: A null-terminated Unicode string that contains the name of the primary
	// or directly trusted domain. If the string is NULL or empty (that is, the first character
	// in the string is the null-terminator character), the primary domain name is assumed.
	DomainName string `idl:"name:DomainName;string;pointer:unique" json:"domain_name"`
}

func (o *GetAnyDCNameRequest) xxx_ToOp(ctx context.Context, op *xxx_GetAnyDCNameOperation) *xxx_GetAnyDCNameOperation {
	if op == nil {
		op = &xxx_GetAnyDCNameOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.DomainName = o.DomainName
	return op
}

func (o *GetAnyDCNameRequest) xxx_FromOp(ctx context.Context, op *xxx_GetAnyDCNameOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.DomainName = op.DomainName
}
func (o *GetAnyDCNameRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetAnyDCNameRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetAnyDCNameOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetAnyDCNameResponse structure represents the NetrGetAnyDCName operation response
type GetAnyDCNameResponse struct {
	// Buffer: A pointer to an allocated buffer that contains the null-terminated Unicode
	// string containing the NetBIOS name of a DC in the specified domain. The DC name is
	// prefixed by two backslashes (\\).
	Buffer string `idl:"name:Buffer;string" json:"buffer"`
	// Return: The NetrGetAnyDCName return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetAnyDCNameResponse) xxx_ToOp(ctx context.Context, op *xxx_GetAnyDCNameOperation) *xxx_GetAnyDCNameOperation {
	if op == nil {
		op = &xxx_GetAnyDCNameOperation{}
	}
	if o == nil {
		return op
	}
	op.Buffer = o.Buffer
	op.Return = o.Return
	return op
}

func (o *GetAnyDCNameResponse) xxx_FromOp(ctx context.Context, op *xxx_GetAnyDCNameOperation) {
	if o == nil {
		return
	}
	o.Buffer = op.Buffer
	o.Return = op.Return
}
func (o *GetAnyDCNameResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetAnyDCNameResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetAnyDCNameOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_Control2Operation structure represents the NetrLogonControl2 operation
type xxx_Control2Operation struct {
	ServerName   string                   `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	FunctionCode uint32                   `idl:"name:FunctionCode" json:"function_code"`
	QueryLevel   uint32                   `idl:"name:QueryLevel" json:"query_level"`
	Data         *ControlDataInformation  `idl:"name:Data;switch_is:FunctionCode" json:"data"`
	Buffer       *ControlQueryInformation `idl:"name:Buffer;switch_is:QueryLevel" json:"buffer"`
	Return       uint32                   `idl:"name:Return" json:"return"`
}

func (o *xxx_Control2Operation) OpNum() int { return 14 }

func (o *xxx_Control2Operation) OpName() string { return "/logon/v1/NetrLogonControl2" }

func (o *xxx_Control2Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_Control2Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// FunctionCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.FunctionCode); err != nil {
			return err
		}
	}
	// QueryLevel {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.QueryLevel); err != nil {
			return err
		}
	}
	// Data {in} (1:{switch_type={alias=DWORD}(uint32), alias=PNETLOGON_CONTROL_DATA_INFORMATION}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=NETLOGON_CONTROL_DATA_INFORMATION}(union))
	{
		_swData := uint32(o.FunctionCode)
		if o.Data != nil {
			if err := o.Data.MarshalUnionNDR(ctx, w, _swData); err != nil {
				return err
			}
		} else {
			if err := (&ControlDataInformation{}).MarshalUnionNDR(ctx, w, _swData); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_Control2Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// FunctionCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.FunctionCode); err != nil {
			return err
		}
	}
	// QueryLevel {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.QueryLevel); err != nil {
			return err
		}
	}
	// Data {in} (1:{switch_type={alias=DWORD}(uint32), alias=PNETLOGON_CONTROL_DATA_INFORMATION,pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=NETLOGON_CONTROL_DATA_INFORMATION}(union))
	{
		if o.Data == nil {
			o.Data = &ControlDataInformation{}
		}
		_swData := uint32(o.FunctionCode)
		if err := o.Data.UnmarshalUnionNDR(ctx, w, _swData); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_Control2Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_Control2Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Buffer {out} (1:{switch_type={alias=DWORD}(uint32), alias=PNETLOGON_CONTROL_QUERY_INFORMATION}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=NETLOGON_CONTROL_QUERY_INFORMATION}(union))
	{
		_swBuffer := uint32(o.QueryLevel)
		if o.Buffer != nil {
			if err := o.Buffer.MarshalUnionNDR(ctx, w, _swBuffer); err != nil {
				return err
			}
		} else {
			if err := (&ControlQueryInformation{}).MarshalUnionNDR(ctx, w, _swBuffer); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_Control2Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Buffer {out} (1:{switch_type={alias=DWORD}(uint32), alias=PNETLOGON_CONTROL_QUERY_INFORMATION,pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=NETLOGON_CONTROL_QUERY_INFORMATION}(union))
	{
		if o.Buffer == nil {
			o.Buffer = &ControlQueryInformation{}
		}
		_swBuffer := uint32(o.QueryLevel)
		if err := o.Buffer.UnmarshalUnionNDR(ctx, w, _swBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// Control2Request structure represents the NetrLogonControl2 operation request
type Control2Request struct {
	ServerName   string                  `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	FunctionCode uint32                  `idl:"name:FunctionCode" json:"function_code"`
	QueryLevel   uint32                  `idl:"name:QueryLevel" json:"query_level"`
	Data         *ControlDataInformation `idl:"name:Data;switch_is:FunctionCode" json:"data"`
}

func (o *Control2Request) xxx_ToOp(ctx context.Context, op *xxx_Control2Operation) *xxx_Control2Operation {
	if op == nil {
		op = &xxx_Control2Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.FunctionCode = o.FunctionCode
	op.QueryLevel = o.QueryLevel
	op.Data = o.Data
	return op
}

func (o *Control2Request) xxx_FromOp(ctx context.Context, op *xxx_Control2Operation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.FunctionCode = op.FunctionCode
	o.QueryLevel = op.QueryLevel
	o.Data = op.Data
}
func (o *Control2Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *Control2Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_Control2Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// Control2Response structure represents the NetrLogonControl2 operation response
type Control2Response struct {
	// XXX: QueryLevel is an implicit input depedency for output parameters
	QueryLevel uint32 `idl:"name:QueryLevel" json:"query_level"`

	Buffer *ControlQueryInformation `idl:"name:Buffer;switch_is:QueryLevel" json:"buffer"`
	// Return: The NetrLogonControl2 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *Control2Response) xxx_ToOp(ctx context.Context, op *xxx_Control2Operation) *xxx_Control2Operation {
	if op == nil {
		op = &xxx_Control2Operation{}
	}
	if o == nil {
		return op
	}
	// XXX: implicit input dependencies for output parameters
	if op.QueryLevel == uint32(0) {
		op.QueryLevel = o.QueryLevel
	}

	op.Buffer = o.Buffer
	op.Return = o.Return
	return op
}

func (o *Control2Response) xxx_FromOp(ctx context.Context, op *xxx_Control2Operation) {
	if o == nil {
		return
	}
	// XXX: implicit input dependencies for output parameters
	o.QueryLevel = op.QueryLevel

	o.Buffer = op.Buffer
	o.Return = op.Return
}
func (o *Control2Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *Control2Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_Control2Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_Authenticate2Operation structure represents the NetrServerAuthenticate2 operation
type xxx_Authenticate2Operation struct {
	PrimaryName       string            `idl:"name:PrimaryName;string;pointer:unique" json:"primary_name"`
	AccountName       string            `idl:"name:AccountName;string" json:"account_name"`
	SecureChannelType SecureChannelType `idl:"name:SecureChannelType" json:"secure_channel_type"`
	ComputerName      string            `idl:"name:ComputerName;string" json:"computer_name"`
	ClientCredential  *Credential       `idl:"name:ClientCredential" json:"client_credential"`
	ServerCredential  *Credential       `idl:"name:ServerCredential" json:"server_credential"`
	NegotiateFlags    uint32            `idl:"name:NegotiateFlags" json:"negotiate_flags"`
	Return            int32             `idl:"name:Return" json:"return"`
}

func (o *xxx_Authenticate2Operation) OpNum() int { return 15 }

func (o *xxx_Authenticate2Operation) OpName() string { return "/logon/v1/NetrServerAuthenticate2" }

func (o *xxx_Authenticate2Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_Authenticate2Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// PrimaryName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.PrimaryName != "" {
			_ptr_PrimaryName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.PrimaryName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.PrimaryName, _ptr_PrimaryName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// AccountName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.AccountName); err != nil {
			return err
		}
	}
	// SecureChannelType {in} (1:{alias=NETLOGON_SECURE_CHANNEL_TYPE}(enum))
	{
		if err := w.WriteEnum(uint16(o.SecureChannelType)); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ComputerName); err != nil {
			return err
		}
	}
	// ClientCredential {in} (1:{alias=PNETLOGON_CREDENTIAL}*(1))(2:{alias=NETLOGON_CREDENTIAL}(struct))
	{
		if o.ClientCredential != nil {
			if err := o.ClientCredential.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Credential{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// NegotiateFlags {in, out} (1:{pointer=ref}*(1))(2:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.NegotiateFlags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_Authenticate2Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// PrimaryName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_PrimaryName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.PrimaryName); err != nil {
				return err
			}
			return nil
		})
		_s_PrimaryName := func(ptr interface{}) { o.PrimaryName = *ptr.(*string) }
		if err := w.ReadPointer(&o.PrimaryName, _s_PrimaryName, _ptr_PrimaryName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// AccountName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.AccountName); err != nil {
			return err
		}
	}
	// SecureChannelType {in} (1:{alias=NETLOGON_SECURE_CHANNEL_TYPE}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.SecureChannelType)); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ComputerName); err != nil {
			return err
		}
	}
	// ClientCredential {in} (1:{alias=PNETLOGON_CREDENTIAL,pointer=ref}*(1))(2:{alias=NETLOGON_CREDENTIAL}(struct))
	{
		if o.ClientCredential == nil {
			o.ClientCredential = &Credential{}
		}
		if err := o.ClientCredential.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// NegotiateFlags {in, out} (1:{pointer=ref}*(1))(2:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.NegotiateFlags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_Authenticate2Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_Authenticate2Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ServerCredential {out} (1:{alias=PNETLOGON_CREDENTIAL}*(1))(2:{alias=NETLOGON_CREDENTIAL}(struct))
	{
		if o.ServerCredential != nil {
			if err := o.ServerCredential.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Credential{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// NegotiateFlags {in, out} (1:{pointer=ref}*(1))(2:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.NegotiateFlags); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_Authenticate2Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ServerCredential {out} (1:{alias=PNETLOGON_CREDENTIAL,pointer=ref}*(1))(2:{alias=NETLOGON_CREDENTIAL}(struct))
	{
		if o.ServerCredential == nil {
			o.ServerCredential = &Credential{}
		}
		if err := o.ServerCredential.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// NegotiateFlags {in, out} (1:{pointer=ref}*(1))(2:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.NegotiateFlags); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// Authenticate2Request structure represents the NetrServerAuthenticate2 operation request
type Authenticate2Request struct {
	PrimaryName       string            `idl:"name:PrimaryName;string;pointer:unique" json:"primary_name"`
	AccountName       string            `idl:"name:AccountName;string" json:"account_name"`
	SecureChannelType SecureChannelType `idl:"name:SecureChannelType" json:"secure_channel_type"`
	ComputerName      string            `idl:"name:ComputerName;string" json:"computer_name"`
	ClientCredential  *Credential       `idl:"name:ClientCredential" json:"client_credential"`
	NegotiateFlags    uint32            `idl:"name:NegotiateFlags" json:"negotiate_flags"`
}

func (o *Authenticate2Request) xxx_ToOp(ctx context.Context, op *xxx_Authenticate2Operation) *xxx_Authenticate2Operation {
	if op == nil {
		op = &xxx_Authenticate2Operation{}
	}
	if o == nil {
		return op
	}
	op.PrimaryName = o.PrimaryName
	op.AccountName = o.AccountName
	op.SecureChannelType = o.SecureChannelType
	op.ComputerName = o.ComputerName
	op.ClientCredential = o.ClientCredential
	op.NegotiateFlags = o.NegotiateFlags
	return op
}

func (o *Authenticate2Request) xxx_FromOp(ctx context.Context, op *xxx_Authenticate2Operation) {
	if o == nil {
		return
	}
	o.PrimaryName = op.PrimaryName
	o.AccountName = op.AccountName
	o.SecureChannelType = op.SecureChannelType
	o.ComputerName = op.ComputerName
	o.ClientCredential = op.ClientCredential
	o.NegotiateFlags = op.NegotiateFlags
}
func (o *Authenticate2Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *Authenticate2Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_Authenticate2Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// Authenticate2Response structure represents the NetrServerAuthenticate2 operation response
type Authenticate2Response struct {
	ServerCredential *Credential `idl:"name:ServerCredential" json:"server_credential"`
	NegotiateFlags   uint32      `idl:"name:NegotiateFlags" json:"negotiate_flags"`
	// Return: The NetrServerAuthenticate2 return value.
	Return int32 `idl:"name:Return" json:"return"`
}

func (o *Authenticate2Response) xxx_ToOp(ctx context.Context, op *xxx_Authenticate2Operation) *xxx_Authenticate2Operation {
	if op == nil {
		op = &xxx_Authenticate2Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerCredential = o.ServerCredential
	op.NegotiateFlags = o.NegotiateFlags
	op.Return = o.Return
	return op
}

func (o *Authenticate2Response) xxx_FromOp(ctx context.Context, op *xxx_Authenticate2Operation) {
	if o == nil {
		return
	}
	o.ServerCredential = op.ServerCredential
	o.NegotiateFlags = op.NegotiateFlags
	o.Return = op.Return
}
func (o *Authenticate2Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *Authenticate2Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_Authenticate2Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_DatabaseSync2Operation structure represents the NetrDatabaseSync2 operation
type xxx_DatabaseSync2Operation struct {
	PrimaryName            string          `idl:"name:PrimaryName;string" json:"primary_name"`
	ComputerName           string          `idl:"name:ComputerName;string" json:"computer_name"`
	Authenticator          *Authenticator  `idl:"name:Authenticator" json:"authenticator"`
	ReturnAuthenticator    *Authenticator  `idl:"name:ReturnAuthenticator" json:"return_authenticator"`
	DatabaseID             uint32          `idl:"name:DatabaseID" json:"database_id"`
	RestartState           SyncState       `idl:"name:RestartState" json:"restart_state"`
	SyncContext            uint32          `idl:"name:SyncContext" json:"sync_context"`
	DeltaArray             *DeltaEnumArray `idl:"name:DeltaArray" json:"delta_array"`
	PreferredMaximumLength uint32          `idl:"name:PreferredMaximumLength" json:"preferred_maximum_length"`
	Return                 int32           `idl:"name:Return" json:"return"`
}

func (o *xxx_DatabaseSync2Operation) OpNum() int { return 16 }

func (o *xxx_DatabaseSync2Operation) OpName() string { return "/logon/v1/NetrDatabaseSync2" }

func (o *xxx_DatabaseSync2Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DatabaseSync2Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// PrimaryName {in} (1:{handle, string, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.PrimaryName); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ComputerName); err != nil {
			return err
		}
	}
	// Authenticator {in} (1:{alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.Authenticator != nil {
			if err := o.Authenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// ReturnAuthenticator {in, out} (1:{alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator != nil {
			if err := o.ReturnAuthenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// DatabaseID {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.DatabaseID); err != nil {
			return err
		}
	}
	// RestartState {in} (1:{alias=SYNC_STATE}(enum))
	{
		if err := w.WriteEnum(uint16(o.RestartState)); err != nil {
			return err
		}
	}
	// SyncContext {in, out} (1:{pointer=ref}*(1))(2:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.SyncContext); err != nil {
			return err
		}
	}
	// PreferredMaximumLength {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.PreferredMaximumLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DatabaseSync2Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// PrimaryName {in} (1:{handle, string, alias=LOGONSRV_HANDLE,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.PrimaryName); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ComputerName); err != nil {
			return err
		}
	}
	// Authenticator {in} (1:{alias=PNETLOGON_AUTHENTICATOR,pointer=ref}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.Authenticator == nil {
			o.Authenticator = &Authenticator{}
		}
		if err := o.Authenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// ReturnAuthenticator {in, out} (1:{alias=PNETLOGON_AUTHENTICATOR,pointer=ref}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator == nil {
			o.ReturnAuthenticator = &Authenticator{}
		}
		if err := o.ReturnAuthenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// DatabaseID {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.DatabaseID); err != nil {
			return err
		}
	}
	// RestartState {in} (1:{alias=SYNC_STATE}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.RestartState)); err != nil {
			return err
		}
	}
	// SyncContext {in, out} (1:{pointer=ref}*(1))(2:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.SyncContext); err != nil {
			return err
		}
	}
	// PreferredMaximumLength {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.PreferredMaximumLength); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DatabaseSync2Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DatabaseSync2Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ReturnAuthenticator {in, out} (1:{alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator != nil {
			if err := o.ReturnAuthenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// SyncContext {in, out} (1:{pointer=ref}*(1))(2:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.SyncContext); err != nil {
			return err
		}
	}
	// DeltaArray {out} (1:{pointer=ref}*(2))(2:{alias=PNETLOGON_DELTA_ENUM_ARRAY}*(1))(3:{alias=NETLOGON_DELTA_ENUM_ARRAY}(struct))
	{
		if o.DeltaArray != nil {
			_ptr_DeltaArray := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.DeltaArray != nil {
					if err := o.DeltaArray.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&DeltaEnumArray{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.DeltaArray, _ptr_DeltaArray); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DatabaseSync2Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ReturnAuthenticator {in, out} (1:{alias=PNETLOGON_AUTHENTICATOR,pointer=ref}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator == nil {
			o.ReturnAuthenticator = &Authenticator{}
		}
		if err := o.ReturnAuthenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// SyncContext {in, out} (1:{pointer=ref}*(1))(2:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.SyncContext); err != nil {
			return err
		}
	}
	// DeltaArray {out} (1:{pointer=ref}*(2))(2:{alias=PNETLOGON_DELTA_ENUM_ARRAY,pointer=ref}*(1))(3:{alias=NETLOGON_DELTA_ENUM_ARRAY}(struct))
	{
		_ptr_DeltaArray := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.DeltaArray == nil {
				o.DeltaArray = &DeltaEnumArray{}
			}
			if err := o.DeltaArray.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_DeltaArray := func(ptr interface{}) { o.DeltaArray = *ptr.(**DeltaEnumArray) }
		if err := w.ReadPointer(&o.DeltaArray, _s_DeltaArray, _ptr_DeltaArray); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// DatabaseSync2Request structure represents the NetrDatabaseSync2 operation request
type DatabaseSync2Request struct {
	// PrimaryName: The custom binding handle, as defined in section 3.5.4.1, that represents
	// the connection to the PDC.
	PrimaryName string `idl:"name:PrimaryName;string" json:"primary_name"`
	// ComputerName: The null-terminated Unicode string that contains the NetBIOS name of
	// the BDC calling this method.
	ComputerName string `idl:"name:ComputerName;string" json:"computer_name"`
	// Authenticator: A pointer to a NETLOGON_AUTHENTICATOR structure, as specified in section
	// 2.2.1.1.5, that contains the client authenticator.
	Authenticator *Authenticator `idl:"name:Authenticator" json:"authenticator"`
	// ReturnAuthenticator: A pointer to a NETLOGON_AUTHENTICATOR structure, as specified
	// in section 2.2.1.1.5, that contains the server return authenticator.
	ReturnAuthenticator *Authenticator `idl:"name:ReturnAuthenticator" json:"return_authenticator"`
	// DatabaseID: The identifier for a specific database for which the changes are requested.
	// It MUST be one of the following values.
	//
	//	+------------+--------------------------------------+
	//	|            |                                      |
	//	|   VALUE    |               MEANING                |
	//	|            |                                      |
	//	+------------+--------------------------------------+
	//	+------------+--------------------------------------+
	//	| 0x00000000 | Indicates the SAM database.          |
	//	+------------+--------------------------------------+
	//	| 0x00000001 | Indicates the SAM built-in database. |
	//	+------------+--------------------------------------+
	//	| 0x00000002 | Indicates the LSA database.          |
	//	+------------+--------------------------------------+
	DatabaseID uint32 `idl:"name:DatabaseID" json:"database_id"`
	// RestartState: Specifies whether this is a restart of the series of the synchronization
	// calls and how to interpret SyncContext. This value MUST be NormalState unless this
	// is the restart, in which case the value MUST be set as specified in the description
	// of the SyncContext parameter.
	RestartState SyncState `idl:"name:RestartState" json:"restart_state"`
	// SyncContext: Specifies context needed to continue the operation. The value MUST be
	// set to zero on the first call. The caller MUST treat this as an opaque value, unless
	// this call is a restart of the series of synchronization calls. The value returned
	// is to be used on input for the next call in the series of synchronization calls.
	//
	// If this call is the restart of the series, the values of the RestartState and the
	// SyncContext parameters are dependent on the DeltaType value received on the last
	// call before the restart and MUST be set as follows. Find the last NETLOGON_DELTA_ENUM
	// structure in the DeltaArray parameter of the call. The DeltaType field of this NETLOGON_DELTA_ENUM
	// structure, as specified in section 2.2.1.5.11, is the DeltaType needed for the restart.
	// The values of RestartState and SyncContext are then determined from the following
	// table.
	//
	//	+---------------------------------------+------------------+------------------------------------------+
	//	|                                       |                  |                                          |
	//	|               DELTATYPE               |   RESTARTSTATE   |               SYNCCONTEXT                |
	//	|                                       |                  |                                          |
	//	+---------------------------------------+------------------+------------------------------------------+
	//	+---------------------------------------+------------------+------------------------------------------+
	//	| AddOrChangeGroup                      | GroupState       | The value of the RID of the last element |
	//	+---------------------------------------+------------------+------------------------------------------+
	//	| AddOrChangeUser                       | UserState        | The value of the RID of the last element |
	//	+---------------------------------------+------------------+------------------------------------------+
	//	| ChangeGroupMembership                 | GroupMemberState | The value of the RID of the last element |
	//	+---------------------------------------+------------------+------------------------------------------+
	//	| AddOrChangeAlias                      | AliasState       | 0x00000000                               |
	//	+---------------------------------------+------------------+------------------------------------------+
	//	| ChangeAliasMembership                 | AliasMemberState | 0x00000000                               |
	//	+---------------------------------------+------------------+------------------------------------------+
	//	| Any other value not previously listed | NormalState      | 0x00000000                               |
	//	+---------------------------------------+------------------+------------------------------------------+
	SyncContext uint32 `idl:"name:SyncContext" json:"sync_context"`
	// PreferredMaximumLength: The value that specifies the preferred maximum size, in bytes,
	// of data referenced in the DeltaArray parameter. This is not a hard upper limit but
	// serves as a guide to the server. The server SHOULD<221> stop including elements in
	// the returned DeltaArray once the size of the returned data equals or exceeds the
	// value of the PreferredMaximumLength parameter. It is up to the client implementation
	// to choose the value for this parameter.
	PreferredMaximumLength uint32 `idl:"name:PreferredMaximumLength" json:"preferred_maximum_length"`
}

func (o *DatabaseSync2Request) xxx_ToOp(ctx context.Context, op *xxx_DatabaseSync2Operation) *xxx_DatabaseSync2Operation {
	if op == nil {
		op = &xxx_DatabaseSync2Operation{}
	}
	if o == nil {
		return op
	}
	op.PrimaryName = o.PrimaryName
	op.ComputerName = o.ComputerName
	op.Authenticator = o.Authenticator
	op.ReturnAuthenticator = o.ReturnAuthenticator
	op.DatabaseID = o.DatabaseID
	op.RestartState = o.RestartState
	op.SyncContext = o.SyncContext
	op.PreferredMaximumLength = o.PreferredMaximumLength
	return op
}

func (o *DatabaseSync2Request) xxx_FromOp(ctx context.Context, op *xxx_DatabaseSync2Operation) {
	if o == nil {
		return
	}
	o.PrimaryName = op.PrimaryName
	o.ComputerName = op.ComputerName
	o.Authenticator = op.Authenticator
	o.ReturnAuthenticator = op.ReturnAuthenticator
	o.DatabaseID = op.DatabaseID
	o.RestartState = op.RestartState
	o.SyncContext = op.SyncContext
	o.PreferredMaximumLength = op.PreferredMaximumLength
}
func (o *DatabaseSync2Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *DatabaseSync2Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DatabaseSync2Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// DatabaseSync2Response structure represents the NetrDatabaseSync2 operation response
type DatabaseSync2Response struct {
	// ReturnAuthenticator: A pointer to a NETLOGON_AUTHENTICATOR structure, as specified
	// in section 2.2.1.1.5, that contains the server return authenticator.
	ReturnAuthenticator *Authenticator `idl:"name:ReturnAuthenticator" json:"return_authenticator"`
	// SyncContext: Specifies context needed to continue the operation. The value MUST be
	// set to zero on the first call. The caller MUST treat this as an opaque value, unless
	// this call is a restart of the series of synchronization calls. The value returned
	// is to be used on input for the next call in the series of synchronization calls.
	//
	// If this call is the restart of the series, the values of the RestartState and the
	// SyncContext parameters are dependent on the DeltaType value received on the last
	// call before the restart and MUST be set as follows. Find the last NETLOGON_DELTA_ENUM
	// structure in the DeltaArray parameter of the call. The DeltaType field of this NETLOGON_DELTA_ENUM
	// structure, as specified in section 2.2.1.5.11, is the DeltaType needed for the restart.
	// The values of RestartState and SyncContext are then determined from the following
	// table.
	//
	//	+---------------------------------------+------------------+------------------------------------------+
	//	|                                       |                  |                                          |
	//	|               DELTATYPE               |   RESTARTSTATE   |               SYNCCONTEXT                |
	//	|                                       |                  |                                          |
	//	+---------------------------------------+------------------+------------------------------------------+
	//	+---------------------------------------+------------------+------------------------------------------+
	//	| AddOrChangeGroup                      | GroupState       | The value of the RID of the last element |
	//	+---------------------------------------+------------------+------------------------------------------+
	//	| AddOrChangeUser                       | UserState        | The value of the RID of the last element |
	//	+---------------------------------------+------------------+------------------------------------------+
	//	| ChangeGroupMembership                 | GroupMemberState | The value of the RID of the last element |
	//	+---------------------------------------+------------------+------------------------------------------+
	//	| AddOrChangeAlias                      | AliasState       | 0x00000000                               |
	//	+---------------------------------------+------------------+------------------------------------------+
	//	| ChangeAliasMembership                 | AliasMemberState | 0x00000000                               |
	//	+---------------------------------------+------------------+------------------------------------------+
	//	| Any other value not previously listed | NormalState      | 0x00000000                               |
	//	+---------------------------------------+------------------+------------------------------------------+
	SyncContext uint32 `idl:"name:SyncContext" json:"sync_context"`
	// DeltaArray: A pointer to a NETLOGON_DELTA_ENUM_ARRAY structure, as specified in section
	// 2.2.1.5.12, that contains an array of enumerated changes (deltas) to the specified
	// database.
	DeltaArray *DeltaEnumArray `idl:"name:DeltaArray" json:"delta_array"`
	// Return: The NetrDatabaseSync2 return value.
	Return int32 `idl:"name:Return" json:"return"`
}

func (o *DatabaseSync2Response) xxx_ToOp(ctx context.Context, op *xxx_DatabaseSync2Operation) *xxx_DatabaseSync2Operation {
	if op == nil {
		op = &xxx_DatabaseSync2Operation{}
	}
	if o == nil {
		return op
	}
	op.ReturnAuthenticator = o.ReturnAuthenticator
	op.SyncContext = o.SyncContext
	op.DeltaArray = o.DeltaArray
	op.Return = o.Return
	return op
}

func (o *DatabaseSync2Response) xxx_FromOp(ctx context.Context, op *xxx_DatabaseSync2Operation) {
	if o == nil {
		return
	}
	o.ReturnAuthenticator = op.ReturnAuthenticator
	o.SyncContext = op.SyncContext
	o.DeltaArray = op.DeltaArray
	o.Return = op.Return
}
func (o *DatabaseSync2Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *DatabaseSync2Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DatabaseSync2Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_DatabaseRedoOperation structure represents the NetrDatabaseRedo operation
type xxx_DatabaseRedoOperation struct {
	PrimaryName         string          `idl:"name:PrimaryName;string" json:"primary_name"`
	ComputerName        string          `idl:"name:ComputerName;string" json:"computer_name"`
	Authenticator       *Authenticator  `idl:"name:Authenticator" json:"authenticator"`
	ReturnAuthenticator *Authenticator  `idl:"name:ReturnAuthenticator" json:"return_authenticator"`
	ChangeLogEntry      []byte          `idl:"name:ChangeLogEntry;size_is:(ChangeLogEntrySize)" json:"change_log_entry"`
	ChangeLogEntrySize  uint32          `idl:"name:ChangeLogEntrySize" json:"change_log_entry_size"`
	DeltaArray          *DeltaEnumArray `idl:"name:DeltaArray" json:"delta_array"`
	Return              int32           `idl:"name:Return" json:"return"`
}

func (o *xxx_DatabaseRedoOperation) OpNum() int { return 17 }

func (o *xxx_DatabaseRedoOperation) OpName() string { return "/logon/v1/NetrDatabaseRedo" }

func (o *xxx_DatabaseRedoOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.ChangeLogEntry != nil && o.ChangeLogEntrySize == 0 {
		o.ChangeLogEntrySize = uint32(len(o.ChangeLogEntry))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DatabaseRedoOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// PrimaryName {in} (1:{handle, string, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.PrimaryName); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ComputerName); err != nil {
			return err
		}
	}
	// Authenticator {in} (1:{alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.Authenticator != nil {
			if err := o.Authenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// ReturnAuthenticator {in, out} (1:{alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator != nil {
			if err := o.ReturnAuthenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// ChangeLogEntry {in} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=ChangeLogEntrySize](uchar))
	{
		dimSize1 := uint64(o.ChangeLogEntrySize)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.ChangeLogEntry {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.ChangeLogEntry[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.ChangeLogEntry); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// ChangeLogEntrySize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ChangeLogEntrySize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DatabaseRedoOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// PrimaryName {in} (1:{handle, string, alias=LOGONSRV_HANDLE,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.PrimaryName); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ComputerName); err != nil {
			return err
		}
	}
	// Authenticator {in} (1:{alias=PNETLOGON_AUTHENTICATOR,pointer=ref}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.Authenticator == nil {
			o.Authenticator = &Authenticator{}
		}
		if err := o.Authenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// ReturnAuthenticator {in, out} (1:{alias=PNETLOGON_AUTHENTICATOR,pointer=ref}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator == nil {
			o.ReturnAuthenticator = &Authenticator{}
		}
		if err := o.ReturnAuthenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// ChangeLogEntry {in} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=ChangeLogEntrySize](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.ChangeLogEntry", sizeInfo[0])
		}
		o.ChangeLogEntry = make([]byte, sizeInfo[0])
		for i1 := range o.ChangeLogEntry {
			i1 := i1
			if err := w.ReadData(&o.ChangeLogEntry[i1]); err != nil {
				return err
			}
		}
	}
	// ChangeLogEntrySize {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ChangeLogEntrySize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DatabaseRedoOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DatabaseRedoOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ReturnAuthenticator {in, out} (1:{alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator != nil {
			if err := o.ReturnAuthenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// DeltaArray {out} (1:{pointer=ref}*(2))(2:{alias=PNETLOGON_DELTA_ENUM_ARRAY}*(1))(3:{alias=NETLOGON_DELTA_ENUM_ARRAY}(struct))
	{
		if o.DeltaArray != nil {
			_ptr_DeltaArray := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.DeltaArray != nil {
					if err := o.DeltaArray.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&DeltaEnumArray{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.DeltaArray, _ptr_DeltaArray); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DatabaseRedoOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ReturnAuthenticator {in, out} (1:{alias=PNETLOGON_AUTHENTICATOR,pointer=ref}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator == nil {
			o.ReturnAuthenticator = &Authenticator{}
		}
		if err := o.ReturnAuthenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// DeltaArray {out} (1:{pointer=ref}*(2))(2:{alias=PNETLOGON_DELTA_ENUM_ARRAY,pointer=ref}*(1))(3:{alias=NETLOGON_DELTA_ENUM_ARRAY}(struct))
	{
		_ptr_DeltaArray := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.DeltaArray == nil {
				o.DeltaArray = &DeltaEnumArray{}
			}
			if err := o.DeltaArray.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_DeltaArray := func(ptr interface{}) { o.DeltaArray = *ptr.(**DeltaEnumArray) }
		if err := w.ReadPointer(&o.DeltaArray, _s_DeltaArray, _ptr_DeltaArray); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// DatabaseRedoRequest structure represents the NetrDatabaseRedo operation request
type DatabaseRedoRequest struct {
	// PrimaryName: The custom binding handle, defined in section 3.5.4.1, representing
	// the connection to the PDC.
	PrimaryName string `idl:"name:PrimaryName;string" json:"primary_name"`
	// ComputerName: The null-terminated Unicode string that contains the NetBIOS name of
	// the BDC calling this method.
	ComputerName string `idl:"name:ComputerName;string" json:"computer_name"`
	// Authenticator: A pointer to a NETLOGON_AUTHENTICATOR structure, as specified in section
	// 2.2.1.1.5, that contains the client authenticator.
	Authenticator *Authenticator `idl:"name:Authenticator" json:"authenticator"`
	// ReturnAuthenticator: A pointer to a NETLOGON_AUTHENTICATOR structure, as specified
	// in section 2.2.1.1.5, that contains the server return authenticator.
	ReturnAuthenticator *Authenticator `idl:"name:ReturnAuthenticator" json:"return_authenticator"`
	// ChangeLogEntry: A pointer to a buffer that contains a CHANGELOG_ENTRY structure,
	// specified as follows, for the account being queried.
	ChangeLogEntry []byte `idl:"name:ChangeLogEntry;size_is:(ChangeLogEntrySize)" json:"change_log_entry"`
	// ChangeLogEntrySize: The size, in bytes, of the buffer pointed to by the ChangeLogEntry
	// parameter.
	ChangeLogEntrySize uint32 `idl:"name:ChangeLogEntrySize" json:"change_log_entry_size"`
}

func (o *DatabaseRedoRequest) xxx_ToOp(ctx context.Context, op *xxx_DatabaseRedoOperation) *xxx_DatabaseRedoOperation {
	if op == nil {
		op = &xxx_DatabaseRedoOperation{}
	}
	if o == nil {
		return op
	}
	op.PrimaryName = o.PrimaryName
	op.ComputerName = o.ComputerName
	op.Authenticator = o.Authenticator
	op.ReturnAuthenticator = o.ReturnAuthenticator
	op.ChangeLogEntry = o.ChangeLogEntry
	op.ChangeLogEntrySize = o.ChangeLogEntrySize
	return op
}

func (o *DatabaseRedoRequest) xxx_FromOp(ctx context.Context, op *xxx_DatabaseRedoOperation) {
	if o == nil {
		return
	}
	o.PrimaryName = op.PrimaryName
	o.ComputerName = op.ComputerName
	o.Authenticator = op.Authenticator
	o.ReturnAuthenticator = op.ReturnAuthenticator
	o.ChangeLogEntry = op.ChangeLogEntry
	o.ChangeLogEntrySize = op.ChangeLogEntrySize
}
func (o *DatabaseRedoRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *DatabaseRedoRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DatabaseRedoOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// DatabaseRedoResponse structure represents the NetrDatabaseRedo operation response
type DatabaseRedoResponse struct {
	// ReturnAuthenticator: A pointer to a NETLOGON_AUTHENTICATOR structure, as specified
	// in section 2.2.1.1.5, that contains the server return authenticator.
	ReturnAuthenticator *Authenticator `idl:"name:ReturnAuthenticator" json:"return_authenticator"`
	// DeltaArray: A pointer to a NETLOGON_DELTA_ENUM_ARRAY structure, as specified in section
	// 2.2.1.5.12, that contains an array of enumerated database changes for the account
	// being queried.
	DeltaArray *DeltaEnumArray `idl:"name:DeltaArray" json:"delta_array"`
	// Return: The NetrDatabaseRedo return value.
	Return int32 `idl:"name:Return" json:"return"`
}

func (o *DatabaseRedoResponse) xxx_ToOp(ctx context.Context, op *xxx_DatabaseRedoOperation) *xxx_DatabaseRedoOperation {
	if op == nil {
		op = &xxx_DatabaseRedoOperation{}
	}
	if o == nil {
		return op
	}
	op.ReturnAuthenticator = o.ReturnAuthenticator
	op.DeltaArray = o.DeltaArray
	op.Return = o.Return
	return op
}

func (o *DatabaseRedoResponse) xxx_FromOp(ctx context.Context, op *xxx_DatabaseRedoOperation) {
	if o == nil {
		return
	}
	o.ReturnAuthenticator = op.ReturnAuthenticator
	o.DeltaArray = op.DeltaArray
	o.Return = op.Return
}
func (o *DatabaseRedoResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *DatabaseRedoResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DatabaseRedoOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_Control2ExOperation structure represents the NetrLogonControl2Ex operation
type xxx_Control2ExOperation struct {
	ServerName   string                   `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	FunctionCode uint32                   `idl:"name:FunctionCode" json:"function_code"`
	QueryLevel   uint32                   `idl:"name:QueryLevel" json:"query_level"`
	Data         *ControlDataInformation  `idl:"name:Data;switch_is:FunctionCode" json:"data"`
	Buffer       *ControlQueryInformation `idl:"name:Buffer;switch_is:QueryLevel" json:"buffer"`
	Return       uint32                   `idl:"name:Return" json:"return"`
}

func (o *xxx_Control2ExOperation) OpNum() int { return 18 }

func (o *xxx_Control2ExOperation) OpName() string { return "/logon/v1/NetrLogonControl2Ex" }

func (o *xxx_Control2ExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_Control2ExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// FunctionCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.FunctionCode); err != nil {
			return err
		}
	}
	// QueryLevel {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.QueryLevel); err != nil {
			return err
		}
	}
	// Data {in} (1:{switch_type={alias=DWORD}(uint32), alias=PNETLOGON_CONTROL_DATA_INFORMATION}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=NETLOGON_CONTROL_DATA_INFORMATION}(union))
	{
		_swData := uint32(o.FunctionCode)
		if o.Data != nil {
			if err := o.Data.MarshalUnionNDR(ctx, w, _swData); err != nil {
				return err
			}
		} else {
			if err := (&ControlDataInformation{}).MarshalUnionNDR(ctx, w, _swData); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_Control2ExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// FunctionCode {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.FunctionCode); err != nil {
			return err
		}
	}
	// QueryLevel {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.QueryLevel); err != nil {
			return err
		}
	}
	// Data {in} (1:{switch_type={alias=DWORD}(uint32), alias=PNETLOGON_CONTROL_DATA_INFORMATION,pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=NETLOGON_CONTROL_DATA_INFORMATION}(union))
	{
		if o.Data == nil {
			o.Data = &ControlDataInformation{}
		}
		_swData := uint32(o.FunctionCode)
		if err := o.Data.UnmarshalUnionNDR(ctx, w, _swData); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_Control2ExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_Control2ExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Buffer {out} (1:{switch_type={alias=DWORD}(uint32), alias=PNETLOGON_CONTROL_QUERY_INFORMATION}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=NETLOGON_CONTROL_QUERY_INFORMATION}(union))
	{
		_swBuffer := uint32(o.QueryLevel)
		if o.Buffer != nil {
			if err := o.Buffer.MarshalUnionNDR(ctx, w, _swBuffer); err != nil {
				return err
			}
		} else {
			if err := (&ControlQueryInformation{}).MarshalUnionNDR(ctx, w, _swBuffer); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_Control2ExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Buffer {out} (1:{switch_type={alias=DWORD}(uint32), alias=PNETLOGON_CONTROL_QUERY_INFORMATION,pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=NETLOGON_CONTROL_QUERY_INFORMATION}(union))
	{
		if o.Buffer == nil {
			o.Buffer = &ControlQueryInformation{}
		}
		_swBuffer := uint32(o.QueryLevel)
		if err := o.Buffer.UnmarshalUnionNDR(ctx, w, _swBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// Control2ExRequest structure represents the NetrLogonControl2Ex operation request
type Control2ExRequest struct {
	// ServerName: The custom binding handle, as defined in section 3.5.4.1.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// FunctionCode: The control operation to be performed; it SHOULD<244> be one of the
	// following values:
	//
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	|                                               |                                                                                  |
	//	|                     VALUE                     |                                     MEANING                                      |
	//	|                                               |                                                                                  |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| NETLOGON_CONTROL_QUERY 0x00000001             | No operation, only the requested information is returned.                        |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| NETLOGON_CONTROL_REPLICATE 0x00000002         | Forces a backup domain controller (BDC) to perform an immediate partial          |
	//	|                                               | synchronization of all databases, as detailed in section 3.6.5.2.2.<245>         |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| NETLOGON_CONTROL_SYNCHRONIZE 0x00000003       | Forces a BDC to perform an immediate full synchronization of all databases.<246> |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| NETLOGON_CONTROL_PDC_REPLICATE 0x00000004     | Forces a PDC to immediately send announcement messages to ask each BDC to        |
	//	|                                               | replicate the database for details (see section 3.6).                            |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| NETLOGON_CONTROL_REDISCOVER 0x00000005        | Forces the server to rediscover a domain controller in the specified domain and  |
	//	|                                               | to set up a secure channel to the discovered DC.                                 |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| NETLOGON_CONTROL_TC_QUERY 0x00000006          | Queries the status of the last usage of the secure channel to the DC.            |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| NETLOGON_CONTROL_TRANSPORT_NOTIFY 0x00000007  | Notifies the Netlogon server that a new network connection has been added and    |
	//	|                                               | causes the server to flush any DC cache.                                         |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| NETLOGON_CONTROL_FIND_USER 0x00000008         | Queries the name of a trusted domain that contains an account for a user.        |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| NETLOGON_CONTROL_CHANGE_PASSWORD 0x00000009   | Causes the server to generate a new shared secret and to set it on the account   |
	//	|                                               | used by the DC for setting up the secure channel from the server.                |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| NETLOGON_CONTROL_TC_VERIFY 0x0000000A         | Verifies the current status of the server's secure channel to a DC in the        |
	//	|                                               | specified domain.                                                                |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| NETLOGON_CONTROL_FORCE_DNS_REG 0x0000000B     | Triggers the non-timer event, Force Register DNS Records, defined in [MS-ADTS]   |
	//	|                                               | section 6.3.2.2.1.                                                               |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| NETLOGON_CONTROL_QUERY_DNS_REG 0x0000000C     | SHOULD<247> query the status of DNS updates performed by the Netlogon server, as |
	//	|                                               | specified in [MS-ADTS] section 6.3.2.                                            |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| NETLOGON_CONTROL_BACKUP_CHANGE_LOG 0x0000FFFC | Used for debugging purposes and does not affect the Netlogon protocol            |
	//	|                                               | behavior.<248>                                                                   |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| NETLOGON_CONTROL_TRUNCATE_LOG 0x0000FFFD      | Used for debugging purposes and does not affect the Netlogon protocol            |
	//	|                                               | behavior.<249>                                                                   |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| NETLOGON_CONTROL_SET_DBFLAG 0x0000FFFE        | Used for debugging purposes and does not affect the Netlogon protocol            |
	//	|                                               | behavior.<250>                                                                   |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	//	| NETLOGON_CONTROL_BREAKPOINT 0x0000FFFF        | Used for debugging purposes and SHOULD<251> be used only with checked builds.    |
	//	|                                               | Calling NetrLogonControl2Ex with this function code does not affect the Netlogon |
	//	|                                               | protocol behavior.<252>                                                          |
	//	+-----------------------------------------------+----------------------------------------------------------------------------------+
	FunctionCode uint32 `idl:"name:FunctionCode" json:"function_code"`
	// QueryLevel: Information query level requested by the client. The buffer returned
	// in the Buffer parameter contains one of the following structures, based on the value
	// of this field.
	//
	//	+------------+-----------------------------------------------+
	//	|            |                    BUFFER                     |
	//	|   VALUE    |                   CONTENTS                    |
	//	|            |                                               |
	//	+------------+-----------------------------------------------+
	//	+------------+-----------------------------------------------+
	//	| 0x00000001 | A NETLOGON_INFO_1 structure is returned.      |
	//	+------------+-----------------------------------------------+
	//	| 0x00000002 | A NETLOGON_INFO_2 structure is returned.      |
	//	+------------+-----------------------------------------------+
	//	| 0x00000003 | A NETLOGON_INFO_3 structure is returned.      |
	//	+------------+-----------------------------------------------+
	//	| 0x00000004 | A NETLOGON_INFO_4 structure is returned.<253> |
	//	+------------+-----------------------------------------------+
	QueryLevel uint32 `idl:"name:QueryLevel" json:"query_level"`
	// Data: A NETLOGON_CONTROL_DATA_INFORMATION structure, as specified in section 2.2.1.7.1,
	// that contains specific data required by the query.
	Data *ControlDataInformation `idl:"name:Data;switch_is:FunctionCode" json:"data"`
}

func (o *Control2ExRequest) xxx_ToOp(ctx context.Context, op *xxx_Control2ExOperation) *xxx_Control2ExOperation {
	if op == nil {
		op = &xxx_Control2ExOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.FunctionCode = o.FunctionCode
	op.QueryLevel = o.QueryLevel
	op.Data = o.Data
	return op
}

func (o *Control2ExRequest) xxx_FromOp(ctx context.Context, op *xxx_Control2ExOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.FunctionCode = op.FunctionCode
	o.QueryLevel = op.QueryLevel
	o.Data = op.Data
}
func (o *Control2ExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *Control2ExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_Control2ExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// Control2ExResponse structure represents the NetrLogonControl2Ex operation response
type Control2ExResponse struct {
	// XXX: QueryLevel is an implicit input depedency for output parameters
	QueryLevel uint32 `idl:"name:QueryLevel" json:"query_level"`

	// Buffer: A NETLOGON_CONTROL_QUERY_INFORMATION structure, as specified in section 2.2.1.7.6,
	// that contains the specific query results, with a level of verbosity as specified
	// in QueryLevel.
	Buffer *ControlQueryInformation `idl:"name:Buffer;switch_is:QueryLevel" json:"buffer"`
	// Return: The NetrLogonControl2Ex return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *Control2ExResponse) xxx_ToOp(ctx context.Context, op *xxx_Control2ExOperation) *xxx_Control2ExOperation {
	if op == nil {
		op = &xxx_Control2ExOperation{}
	}
	if o == nil {
		return op
	}
	// XXX: implicit input dependencies for output parameters
	if op.QueryLevel == uint32(0) {
		op.QueryLevel = o.QueryLevel
	}

	op.Buffer = o.Buffer
	op.Return = o.Return
	return op
}

func (o *Control2ExResponse) xxx_FromOp(ctx context.Context, op *xxx_Control2ExOperation) {
	if o == nil {
		return
	}
	// XXX: implicit input dependencies for output parameters
	o.QueryLevel = op.QueryLevel

	o.Buffer = op.Buffer
	o.Return = op.Return
}
func (o *Control2ExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *Control2ExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_Control2ExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumerateTrustedDomainsOperation structure represents the NetrEnumerateTrustedDomains operation
type xxx_EnumerateTrustedDomainsOperation struct {
	ServerName       string            `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	DomainNameBuffer *DomainNameBuffer `idl:"name:DomainNameBuffer" json:"domain_name_buffer"`
	Return           int32             `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumerateTrustedDomainsOperation) OpNum() int { return 19 }

func (o *xxx_EnumerateTrustedDomainsOperation) OpName() string {
	return "/logon/v1/NetrEnumerateTrustedDomains"
}

func (o *xxx_EnumerateTrustedDomainsOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumerateTrustedDomainsOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumerateTrustedDomainsOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumerateTrustedDomainsOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumerateTrustedDomainsOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// DomainNameBuffer {out} (1:{alias=PDOMAIN_NAME_BUFFER}*(1))(2:{alias=DOMAIN_NAME_BUFFER}(struct))
	{
		if o.DomainNameBuffer != nil {
			if err := o.DomainNameBuffer.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DomainNameBuffer{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumerateTrustedDomainsOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// DomainNameBuffer {out} (1:{alias=PDOMAIN_NAME_BUFFER,pointer=ref}*(1))(2:{alias=DOMAIN_NAME_BUFFER}(struct))
	{
		if o.DomainNameBuffer == nil {
			o.DomainNameBuffer = &DomainNameBuffer{}
		}
		if err := o.DomainNameBuffer.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumerateTrustedDomainsRequest structure represents the NetrEnumerateTrustedDomains operation request
type EnumerateTrustedDomainsRequest struct {
	// ServerName: The custom binding handle, as defined in section 3.5.4.1.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
}

func (o *EnumerateTrustedDomainsRequest) xxx_ToOp(ctx context.Context, op *xxx_EnumerateTrustedDomainsOperation) *xxx_EnumerateTrustedDomainsOperation {
	if op == nil {
		op = &xxx_EnumerateTrustedDomainsOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	return op
}

func (o *EnumerateTrustedDomainsRequest) xxx_FromOp(ctx context.Context, op *xxx_EnumerateTrustedDomainsOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
}
func (o *EnumerateTrustedDomainsRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumerateTrustedDomainsRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumerateTrustedDomainsOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumerateTrustedDomainsResponse structure represents the NetrEnumerateTrustedDomains operation response
type EnumerateTrustedDomainsResponse struct {
	// DomainNameBuffer: A pointer to a DOMAIN_NAME_BUFFER structure, as specified in section
	// 2.2.1.6.1, that contains a list of trusted domain names. The format of domain names
	// contained in the buffer is specified in section 2.2.1.6.1.
	DomainNameBuffer *DomainNameBuffer `idl:"name:DomainNameBuffer" json:"domain_name_buffer"`
	// Return: The NetrEnumerateTrustedDomains return value.
	Return int32 `idl:"name:Return" json:"return"`
}

func (o *EnumerateTrustedDomainsResponse) xxx_ToOp(ctx context.Context, op *xxx_EnumerateTrustedDomainsOperation) *xxx_EnumerateTrustedDomainsOperation {
	if op == nil {
		op = &xxx_EnumerateTrustedDomainsOperation{}
	}
	if o == nil {
		return op
	}
	op.DomainNameBuffer = o.DomainNameBuffer
	op.Return = o.Return
	return op
}

func (o *EnumerateTrustedDomainsResponse) xxx_FromOp(ctx context.Context, op *xxx_EnumerateTrustedDomainsOperation) {
	if o == nil {
		return
	}
	o.DomainNameBuffer = op.DomainNameBuffer
	o.Return = op.Return
}
func (o *EnumerateTrustedDomainsResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumerateTrustedDomainsResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumerateTrustedDomainsOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetDCNameOperation structure represents the DsrGetDcName operation
type xxx_GetDCNameOperation struct {
	ComputerName         string                 `idl:"name:ComputerName;string;pointer:unique" json:"computer_name"`
	DomainName           string                 `idl:"name:DomainName;string;pointer:unique" json:"domain_name"`
	DomainGUID           *dtyp.GUID             `idl:"name:DomainGuid;pointer:unique" json:"domain_guid"`
	SiteGUID             *dtyp.GUID             `idl:"name:SiteGuid;pointer:unique" json:"site_guid"`
	Flags                uint32                 `idl:"name:Flags" json:"flags"`
	DomainControllerInfo *DomainControllerInfoW `idl:"name:DomainControllerInfo" json:"domain_controller_info"`
	Return               uint32                 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetDCNameOperation) OpNum() int { return 20 }

func (o *xxx_GetDCNameOperation) OpName() string { return "/logon/v1/DsrGetDcName" }

func (o *xxx_GetDCNameOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetDCNameOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ComputerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ComputerName != "" {
			_ptr_ComputerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ComputerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ComputerName, _ptr_ComputerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// DomainName {in} (1:{string, pointer=unique}*(1)[dim:0,string,null](wchar))
	{
		if o.DomainName != "" {
			_ptr_DomainName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.DomainName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.DomainName, _ptr_DomainName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// DomainGuid {in} (1:{pointer=unique}*(1))(2:{alias=GUID}(struct))
	{
		if o.DomainGUID != nil {
			_ptr_DomainGuid := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.DomainGUID != nil {
					if err := o.DomainGUID.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.DomainGUID, _ptr_DomainGuid); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// SiteGuid {in} (1:{pointer=unique}*(1))(2:{alias=GUID}(struct))
	{
		if o.SiteGUID != nil {
			_ptr_SiteGuid := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.SiteGUID != nil {
					if err := o.SiteGUID.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.SiteGUID, _ptr_SiteGuid); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetDCNameOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ComputerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ComputerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ComputerName); err != nil {
				return err
			}
			return nil
		})
		_s_ComputerName := func(ptr interface{}) { o.ComputerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ComputerName, _s_ComputerName, _ptr_ComputerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// DomainName {in} (1:{string, pointer=unique}*(1)[dim:0,string,null](wchar))
	{
		_ptr_DomainName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.DomainName); err != nil {
				return err
			}
			return nil
		})
		_s_DomainName := func(ptr interface{}) { o.DomainName = *ptr.(*string) }
		if err := w.ReadPointer(&o.DomainName, _s_DomainName, _ptr_DomainName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// DomainGuid {in} (1:{pointer=unique}*(1))(2:{alias=GUID}(struct))
	{
		_ptr_DomainGuid := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.DomainGUID == nil {
				o.DomainGUID = &dtyp.GUID{}
			}
			if err := o.DomainGUID.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_DomainGuid := func(ptr interface{}) { o.DomainGUID = *ptr.(**dtyp.GUID) }
		if err := w.ReadPointer(&o.DomainGUID, _s_DomainGuid, _ptr_DomainGuid); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// SiteGuid {in} (1:{pointer=unique}*(1))(2:{alias=GUID}(struct))
	{
		_ptr_SiteGuid := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.SiteGUID == nil {
				o.SiteGUID = &dtyp.GUID{}
			}
			if err := o.SiteGUID.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_SiteGuid := func(ptr interface{}) { o.SiteGUID = *ptr.(**dtyp.GUID) }
		if err := w.ReadPointer(&o.SiteGUID, _s_SiteGuid, _ptr_SiteGuid); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetDCNameOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetDCNameOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// DomainControllerInfo {out} (1:{pointer=ref}*(2))(2:{alias=PDOMAIN_CONTROLLER_INFOW}*(1))(3:{alias=DOMAIN_CONTROLLER_INFOW}(struct))
	{
		if o.DomainControllerInfo != nil {
			_ptr_DomainControllerInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.DomainControllerInfo != nil {
					if err := o.DomainControllerInfo.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&DomainControllerInfoW{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.DomainControllerInfo, _ptr_DomainControllerInfo); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetDCNameOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// DomainControllerInfo {out} (1:{pointer=ref}*(2))(2:{alias=PDOMAIN_CONTROLLER_INFOW,pointer=ref}*(1))(3:{alias=DOMAIN_CONTROLLER_INFOW}(struct))
	{
		_ptr_DomainControllerInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.DomainControllerInfo == nil {
				o.DomainControllerInfo = &DomainControllerInfoW{}
			}
			if err := o.DomainControllerInfo.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_DomainControllerInfo := func(ptr interface{}) { o.DomainControllerInfo = *ptr.(**DomainControllerInfoW) }
		if err := w.ReadPointer(&o.DomainControllerInfo, _s_DomainControllerInfo, _ptr_DomainControllerInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetDCNameRequest structure represents the DsrGetDcName operation request
type GetDCNameRequest struct {
	ComputerName string     `idl:"name:ComputerName;string;pointer:unique" json:"computer_name"`
	DomainName   string     `idl:"name:DomainName;string;pointer:unique" json:"domain_name"`
	DomainGUID   *dtyp.GUID `idl:"name:DomainGuid;pointer:unique" json:"domain_guid"`
	// SiteGuid: This parameter MUST be NULL and ignored upon receipt.
	//
	// The DsrGetDcName call accepts the SiteGuid parameter instead of the SiteName parameter
	// of the DsrGetDcNameEx call. On receiving this call, the server MUST perform all of
	// the processing done on receiving the DsrGetDcNameEx call.
	SiteGUID *dtyp.GUID `idl:"name:SiteGuid;pointer:unique" json:"site_guid"`
	Flags    uint32     `idl:"name:Flags" json:"flags"`
}

func (o *GetDCNameRequest) xxx_ToOp(ctx context.Context, op *xxx_GetDCNameOperation) *xxx_GetDCNameOperation {
	if op == nil {
		op = &xxx_GetDCNameOperation{}
	}
	if o == nil {
		return op
	}
	op.ComputerName = o.ComputerName
	op.DomainName = o.DomainName
	op.DomainGUID = o.DomainGUID
	op.SiteGUID = o.SiteGUID
	op.Flags = o.Flags
	return op
}

func (o *GetDCNameRequest) xxx_FromOp(ctx context.Context, op *xxx_GetDCNameOperation) {
	if o == nil {
		return
	}
	o.ComputerName = op.ComputerName
	o.DomainName = op.DomainName
	o.DomainGUID = op.DomainGUID
	o.SiteGUID = op.SiteGUID
	o.Flags = op.Flags
}
func (o *GetDCNameRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetDCNameRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetDCNameOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetDCNameResponse structure represents the DsrGetDcName operation response
type GetDCNameResponse struct {
	DomainControllerInfo *DomainControllerInfoW `idl:"name:DomainControllerInfo" json:"domain_controller_info"`
	// Return: The DsrGetDcName return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetDCNameResponse) xxx_ToOp(ctx context.Context, op *xxx_GetDCNameOperation) *xxx_GetDCNameOperation {
	if op == nil {
		op = &xxx_GetDCNameOperation{}
	}
	if o == nil {
		return op
	}
	op.DomainControllerInfo = o.DomainControllerInfo
	op.Return = o.Return
	return op
}

func (o *GetDCNameResponse) xxx_FromOp(ctx context.Context, op *xxx_GetDCNameOperation) {
	if o == nil {
		return
	}
	o.DomainControllerInfo = op.DomainControllerInfo
	o.Return = op.Return
}
func (o *GetDCNameResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetDCNameResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetDCNameOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetCapabilitiesOperation structure represents the NetrLogonGetCapabilities operation
type xxx_GetCapabilitiesOperation struct {
	ServerName          string         `idl:"name:ServerName;string" json:"server_name"`
	ComputerName        string         `idl:"name:ComputerName;string;pointer:unique" json:"computer_name"`
	Authenticator       *Authenticator `idl:"name:Authenticator" json:"authenticator"`
	ReturnAuthenticator *Authenticator `idl:"name:ReturnAuthenticator" json:"return_authenticator"`
	QueryLevel          uint32         `idl:"name:QueryLevel" json:"query_level"`
	ServerCapabilities  *Capabilities  `idl:"name:ServerCapabilities;switch_is:QueryLevel" json:"server_capabilities"`
	Return              int32          `idl:"name:Return" json:"return"`
}

func (o *xxx_GetCapabilitiesOperation) OpNum() int { return 21 }

func (o *xxx_GetCapabilitiesOperation) OpName() string { return "/logon/v1/NetrLogonGetCapabilities" }

func (o *xxx_GetCapabilitiesOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetCapabilitiesOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=unique}*(1)[dim:0,string,null](wchar))
	{
		if o.ComputerName != "" {
			_ptr_ComputerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ComputerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ComputerName, _ptr_ComputerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Authenticator {in} (1:{alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.Authenticator != nil {
			if err := o.Authenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// ReturnAuthenticator {in, out} (1:{alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator != nil {
			if err := o.ReturnAuthenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// QueryLevel {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.QueryLevel); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetCapabilitiesOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, alias=LOGONSRV_HANDLE,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=unique}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ComputerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ComputerName); err != nil {
				return err
			}
			return nil
		})
		_s_ComputerName := func(ptr interface{}) { o.ComputerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ComputerName, _s_ComputerName, _ptr_ComputerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Authenticator {in} (1:{alias=PNETLOGON_AUTHENTICATOR,pointer=ref}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.Authenticator == nil {
			o.Authenticator = &Authenticator{}
		}
		if err := o.Authenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// ReturnAuthenticator {in, out} (1:{alias=PNETLOGON_AUTHENTICATOR,pointer=ref}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator == nil {
			o.ReturnAuthenticator = &Authenticator{}
		}
		if err := o.ReturnAuthenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// QueryLevel {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.QueryLevel); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetCapabilitiesOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetCapabilitiesOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ReturnAuthenticator {in, out} (1:{alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator != nil {
			if err := o.ReturnAuthenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// ServerCapabilities {out} (1:{switch_type={alias=DWORD}(uint32), alias=PNETLOGON_CAPABILITIES}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=NETLOGON_CAPABILITIES}(union))
	{
		_swServerCapabilities := uint32(o.QueryLevel)
		if o.ServerCapabilities != nil {
			if err := o.ServerCapabilities.MarshalUnionNDR(ctx, w, _swServerCapabilities); err != nil {
				return err
			}
		} else {
			if err := (&Capabilities{}).MarshalUnionNDR(ctx, w, _swServerCapabilities); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetCapabilitiesOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ReturnAuthenticator {in, out} (1:{alias=PNETLOGON_AUTHENTICATOR,pointer=ref}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator == nil {
			o.ReturnAuthenticator = &Authenticator{}
		}
		if err := o.ReturnAuthenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// ServerCapabilities {out} (1:{switch_type={alias=DWORD}(uint32), alias=PNETLOGON_CAPABILITIES,pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=NETLOGON_CAPABILITIES}(union))
	{
		if o.ServerCapabilities == nil {
			o.ServerCapabilities = &Capabilities{}
		}
		_swServerCapabilities := uint32(o.QueryLevel)
		if err := o.ServerCapabilities.UnmarshalUnionNDR(ctx, w, _swServerCapabilities); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetCapabilitiesRequest structure represents the NetrLogonGetCapabilities operation request
type GetCapabilitiesRequest struct {
	// ServerName: A LOGONSRV_HANDLE Unicode string handle of the server that is handling
	// the request.
	ServerName string `idl:"name:ServerName;string" json:"server_name"`
	// ComputerName: A string that contains the name of the computer.
	ComputerName string `idl:"name:ComputerName;string;pointer:unique" json:"computer_name"`
	// Authenticator: A pointer to a NETLOGON_AUTHENTICATOR structure that contains the
	// client authenticator.
	Authenticator *Authenticator `idl:"name:Authenticator" json:"authenticator"`
	// ReturnAuthenticator: A pointer to a NETLOGON_AUTHENTICATOR structure that contains
	// the server return authenticator.
	ReturnAuthenticator *Authenticator `idl:"name:ReturnAuthenticator" json:"return_authenticator"`
	// QueryLevel: Specifies the level of information to return from the domain controller
	// being queried. A value of 0x00000001 causes return of a NETLOGON_CAPABILITIES structure
	// that contains server capabilities.
	QueryLevel uint32 `idl:"name:QueryLevel" json:"query_level"`
}

func (o *GetCapabilitiesRequest) xxx_ToOp(ctx context.Context, op *xxx_GetCapabilitiesOperation) *xxx_GetCapabilitiesOperation {
	if op == nil {
		op = &xxx_GetCapabilitiesOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.ComputerName = o.ComputerName
	op.Authenticator = o.Authenticator
	op.ReturnAuthenticator = o.ReturnAuthenticator
	op.QueryLevel = o.QueryLevel
	return op
}

func (o *GetCapabilitiesRequest) xxx_FromOp(ctx context.Context, op *xxx_GetCapabilitiesOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.ComputerName = op.ComputerName
	o.Authenticator = op.Authenticator
	o.ReturnAuthenticator = op.ReturnAuthenticator
	o.QueryLevel = op.QueryLevel
}
func (o *GetCapabilitiesRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetCapabilitiesRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetCapabilitiesOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetCapabilitiesResponse structure represents the NetrLogonGetCapabilities operation response
type GetCapabilitiesResponse struct {
	// XXX: QueryLevel is an implicit input depedency for output parameters
	QueryLevel uint32 `idl:"name:QueryLevel" json:"query_level"`

	// ReturnAuthenticator: A pointer to a NETLOGON_AUTHENTICATOR structure that contains
	// the server return authenticator.
	ReturnAuthenticator *Authenticator `idl:"name:ReturnAuthenticator" json:"return_authenticator"`
	ServerCapabilities  *Capabilities  `idl:"name:ServerCapabilities;switch_is:QueryLevel" json:"server_capabilities"`
	// Return: The NetrLogonGetCapabilities return value.
	Return int32 `idl:"name:Return" json:"return"`
}

func (o *GetCapabilitiesResponse) xxx_ToOp(ctx context.Context, op *xxx_GetCapabilitiesOperation) *xxx_GetCapabilitiesOperation {
	if op == nil {
		op = &xxx_GetCapabilitiesOperation{}
	}
	if o == nil {
		return op
	}
	// XXX: implicit input dependencies for output parameters
	if op.QueryLevel == uint32(0) {
		op.QueryLevel = o.QueryLevel
	}

	op.ReturnAuthenticator = o.ReturnAuthenticator
	op.ServerCapabilities = o.ServerCapabilities
	op.Return = o.Return
	return op
}

func (o *GetCapabilitiesResponse) xxx_FromOp(ctx context.Context, op *xxx_GetCapabilitiesOperation) {
	if o == nil {
		return
	}
	// XXX: implicit input dependencies for output parameters
	o.QueryLevel = op.QueryLevel

	o.ReturnAuthenticator = op.ReturnAuthenticator
	o.ServerCapabilities = op.ServerCapabilities
	o.Return = op.Return
}
func (o *GetCapabilitiesResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetCapabilitiesResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetCapabilitiesOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SetServiceBitsOperation structure represents the NetrLogonSetServiceBits operation
type xxx_SetServiceBitsOperation struct {
	ServerName            string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	ServiceBitsOfInterest uint32 `idl:"name:ServiceBitsOfInterest" json:"service_bits_of_interest"`
	ServiceBits           uint32 `idl:"name:ServiceBits" json:"service_bits"`
	Return                int32  `idl:"name:Return" json:"return"`
}

func (o *xxx_SetServiceBitsOperation) OpNum() int { return 22 }

func (o *xxx_SetServiceBitsOperation) OpName() string { return "/logon/v1/NetrLogonSetServiceBits" }

func (o *xxx_SetServiceBitsOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetServiceBitsOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ServiceBitsOfInterest {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ServiceBitsOfInterest); err != nil {
			return err
		}
	}
	// ServiceBits {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.ServiceBits); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetServiceBitsOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ServiceBitsOfInterest {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ServiceBitsOfInterest); err != nil {
			return err
		}
	}
	// ServiceBits {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.ServiceBits); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetServiceBitsOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetServiceBitsOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SetServiceBitsOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SetServiceBitsRequest structure represents the NetrLogonSetServiceBits operation request
type SetServiceBitsRequest struct {
	// ServerName: The custom binding handle, as defined in section 3.5.4.1, representing
	// the connection to a DC.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// ServiceBitsOfInterest: A set of bit flags used as a mask to indicate which service's
	// state (running or not running) is being set by this call. The value is constructed
	// from zero or more bit flags from the following table.
	//
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
	//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | C | 0 | 0 | 0 | B | 0 | 0 | A | 0 | 0 | 0 | 0 | 0 | 0 |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//
	// The flags SHOULD<238> be defined as follows.
	//
	//	+-------+-----------------------------------------------------------------+
	//	|       |                                                                 |
	//	| VALUE |                           DESCRIPTION                           |
	//	|       |                                                                 |
	//	+-------+-----------------------------------------------------------------+
	//	+-------+-----------------------------------------------------------------+
	//	| A     | The state of the time service is being set.                     |
	//	+-------+-----------------------------------------------------------------+
	//	| B     | The state of the time service with clock hardware is being set. |
	//	+-------+-----------------------------------------------------------------+
	//	| C     | The state of the Active Directory Web service is being set.     |
	//	+-------+-----------------------------------------------------------------+
	ServiceBitsOfInterest uint32 `idl:"name:ServiceBitsOfInterest" json:"service_bits_of_interest"`
	// ServiceBits: A set of bit flags used as a mask to indicate whether the service indicated
	// by ServiceBitsOfInterest is running. If the flag is set to 0, the corresponding service
	// indicated by ServiceBitsOfInterest is not running. Otherwise, if the flag is set
	// to 1, the corresponding service indicated by ServiceBitsOfInterest is running. The
	// value is constructed from zero or more bit flags from the following table.
	//
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
	//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | C | 0 | 0 | 0 | B | 0 | 0 | A | 0 | 0 | 0 | 0 | 0 | 0 |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//
	// The flags SHOULD<239> be defined as follows.
	//
	//	+-------+----------------------------------------------+
	//	|       |                                              |
	//	| VALUE |                 DESCRIPTION                  |
	//	|       |                                              |
	//	+-------+----------------------------------------------+
	//	+-------+----------------------------------------------+
	//	| A     | Time service is running.                     |
	//	+-------+----------------------------------------------+
	//	| B     | Time service with clock hardware is running. |
	//	+-------+----------------------------------------------+
	//	| C     | Active Directory Web service is running.     |
	//	+-------+----------------------------------------------+
	//
	// All other bits MUST be set to zero; otherwise, the error STATUS_INVALID_PARAMETER
	// is returned.
	ServiceBits uint32 `idl:"name:ServiceBits" json:"service_bits"`
}

func (o *SetServiceBitsRequest) xxx_ToOp(ctx context.Context, op *xxx_SetServiceBitsOperation) *xxx_SetServiceBitsOperation {
	if op == nil {
		op = &xxx_SetServiceBitsOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.ServiceBitsOfInterest = o.ServiceBitsOfInterest
	op.ServiceBits = o.ServiceBits
	return op
}

func (o *SetServiceBitsRequest) xxx_FromOp(ctx context.Context, op *xxx_SetServiceBitsOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.ServiceBitsOfInterest = op.ServiceBitsOfInterest
	o.ServiceBits = op.ServiceBits
}
func (o *SetServiceBitsRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SetServiceBitsRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetServiceBitsOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SetServiceBitsResponse structure represents the NetrLogonSetServiceBits operation response
type SetServiceBitsResponse struct {
	// Return: The NetrLogonSetServiceBits return value.
	Return int32 `idl:"name:Return" json:"return"`
}

func (o *SetServiceBitsResponse) xxx_ToOp(ctx context.Context, op *xxx_SetServiceBitsOperation) *xxx_SetServiceBitsOperation {
	if op == nil {
		op = &xxx_SetServiceBitsOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *SetServiceBitsResponse) xxx_FromOp(ctx context.Context, op *xxx_SetServiceBitsOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *SetServiceBitsResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SetServiceBitsResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SetServiceBitsOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetTrustRIDOperation structure represents the NetrLogonGetTrustRid operation
type xxx_GetTrustRIDOperation struct {
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	DomainName string `idl:"name:DomainName;string;pointer:unique" json:"domain_name"`
	RID        uint32 `idl:"name:Rid" json:"rid"`
	Return     uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetTrustRIDOperation) OpNum() int { return 23 }

func (o *xxx_GetTrustRIDOperation) OpName() string { return "/logon/v1/NetrLogonGetTrustRid" }

func (o *xxx_GetTrustRIDOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetTrustRIDOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// DomainName {in} (1:{string, pointer=unique}*(1)[dim:0,string,null](wchar))
	{
		if o.DomainName != "" {
			_ptr_DomainName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.DomainName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.DomainName, _ptr_DomainName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetTrustRIDOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// DomainName {in} (1:{string, pointer=unique}*(1)[dim:0,string,null](wchar))
	{
		_ptr_DomainName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.DomainName); err != nil {
				return err
			}
			return nil
		})
		_s_DomainName := func(ptr interface{}) { o.DomainName = *ptr.(*string) }
		if err := w.ReadPointer(&o.DomainName, _s_DomainName, _ptr_DomainName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetTrustRIDOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetTrustRIDOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Rid {out} (1:{pointer=ref}*(1))(2:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.RID); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetTrustRIDOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Rid {out} (1:{pointer=ref}*(1))(2:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.RID); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetTrustRIDRequest structure represents the NetrLogonGetTrustRid operation request
type GetTrustRIDRequest struct {
	// ServerName: The custom binding handle, as defined in section 3.5.4.1.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// DomainName: The null-terminated Unicode string that contains the DNS or NetBIOS name
	// of the primary or trusted domain. If this parameter is NULL, this method uses the
	// name of the primary domain of the server.
	DomainName string `idl:"name:DomainName;string;pointer:unique" json:"domain_name"`
}

func (o *GetTrustRIDRequest) xxx_ToOp(ctx context.Context, op *xxx_GetTrustRIDOperation) *xxx_GetTrustRIDOperation {
	if op == nil {
		op = &xxx_GetTrustRIDOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.DomainName = o.DomainName
	return op
}

func (o *GetTrustRIDRequest) xxx_FromOp(ctx context.Context, op *xxx_GetTrustRIDOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.DomainName = op.DomainName
}
func (o *GetTrustRIDRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetTrustRIDRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetTrustRIDOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetTrustRIDResponse structure represents the NetrLogonGetTrustRid operation response
type GetTrustRIDResponse struct {
	// Rid: A pointer to an unsigned long that receives the RID of the account.
	RID uint32 `idl:"name:Rid" json:"rid"`
	// Return: The NetrLogonGetTrustRid return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetTrustRIDResponse) xxx_ToOp(ctx context.Context, op *xxx_GetTrustRIDOperation) *xxx_GetTrustRIDOperation {
	if op == nil {
		op = &xxx_GetTrustRIDOperation{}
	}
	if o == nil {
		return op
	}
	op.RID = o.RID
	op.Return = o.Return
	return op
}

func (o *GetTrustRIDResponse) xxx_FromOp(ctx context.Context, op *xxx_GetTrustRIDOperation) {
	if o == nil {
		return
	}
	o.RID = op.RID
	o.Return = op.Return
}
func (o *GetTrustRIDResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetTrustRIDResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetTrustRIDOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ComputeServerDigestOperation structure represents the NetrLogonComputeServerDigest operation
type xxx_ComputeServerDigestOperation struct {
	ServerName       string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	RID              uint32 `idl:"name:Rid" json:"rid"`
	Message          []byte `idl:"name:Message;size_is:(MessageSize)" json:"message"`
	MessageSize      uint32 `idl:"name:MessageSize" json:"message_size"`
	NewMessageDigest []byte `idl:"name:NewMessageDigest" json:"new_message_digest"`
	OldMessageDigest []byte `idl:"name:OldMessageDigest" json:"old_message_digest"`
	Return           uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_ComputeServerDigestOperation) OpNum() int { return 24 }

func (o *xxx_ComputeServerDigestOperation) OpName() string {
	return "/logon/v1/NetrLogonComputeServerDigest"
}

func (o *xxx_ComputeServerDigestOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.Message != nil && o.MessageSize == 0 {
		o.MessageSize = uint32(len(o.Message))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ComputeServerDigestOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Rid {in} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.RID); err != nil {
			return err
		}
	}
	// Message {in} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=MessageSize](uchar))
	{
		dimSize1 := uint64(o.MessageSize)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.Message {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.Message[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.Message); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// MessageSize {in} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.MessageSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ComputeServerDigestOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Rid {in} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.RID); err != nil {
			return err
		}
	}
	// Message {in} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=MessageSize](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Message", sizeInfo[0])
		}
		o.Message = make([]byte, sizeInfo[0])
		for i1 := range o.Message {
			i1 := i1
			if err := w.ReadData(&o.Message[i1]); err != nil {
				return err
			}
		}
	}
	// MessageSize {in} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.MessageSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ComputeServerDigestOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ComputeServerDigestOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// NewMessageDigest {out} (1:[16])(2:{alias=CHAR}(char))
	{
		for i1 := range o.NewMessageDigest {
			i1 := i1
			if uint64(i1) >= 16 {
				break
			}
			if err := w.WriteData(o.NewMessageDigest[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.NewMessageDigest); uint64(i1) < 16; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// OldMessageDigest {out} (1:[16])(2:{alias=CHAR}(char))
	{
		for i1 := range o.OldMessageDigest {
			i1 := i1
			if uint64(i1) >= 16 {
				break
			}
			if err := w.WriteData(o.OldMessageDigest[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.OldMessageDigest); uint64(i1) < 16; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ComputeServerDigestOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// NewMessageDigest {out} (1:[16])(2:{alias=CHAR}(char))
	{
		o.NewMessageDigest = make([]byte, 16)
		for i1 := range o.NewMessageDigest {
			i1 := i1
			if err := w.ReadData(&o.NewMessageDigest[i1]); err != nil {
				return err
			}
		}
	}
	// OldMessageDigest {out} (1:[16])(2:{alias=CHAR}(char))
	{
		o.OldMessageDigest = make([]byte, 16)
		for i1 := range o.OldMessageDigest {
			i1 := i1
			if err := w.ReadData(&o.OldMessageDigest[i1]); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ComputeServerDigestRequest structure represents the NetrLogonComputeServerDigest operation request
type ComputeServerDigestRequest struct {
	// ServerName: The custom binding handle, as defined in section 3.5.4.1.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// Rid: The RID of the machine account for which the digest is to be computed. The NetrLogonGetTrustRid
	// method, as specified in section 3.5.4.8.1, is used to obtain the RID.
	RID uint32 `idl:"name:Rid" json:"rid"`
	// Message: A pointer to buffer that contains the message to compute the digest.
	Message []byte `idl:"name:Message;size_is:(MessageSize)" json:"message"`
	// MessageSize: The length of the data referenced by the Message parameter, in bytes.
	MessageSize uint32 `idl:"name:MessageSize" json:"message_size"`
}

func (o *ComputeServerDigestRequest) xxx_ToOp(ctx context.Context, op *xxx_ComputeServerDigestOperation) *xxx_ComputeServerDigestOperation {
	if op == nil {
		op = &xxx_ComputeServerDigestOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.RID = o.RID
	op.Message = o.Message
	op.MessageSize = o.MessageSize
	return op
}

func (o *ComputeServerDigestRequest) xxx_FromOp(ctx context.Context, op *xxx_ComputeServerDigestOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.RID = op.RID
	o.Message = op.Message
	o.MessageSize = op.MessageSize
}
func (o *ComputeServerDigestRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *ComputeServerDigestRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ComputeServerDigestOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ComputeServerDigestResponse structure represents the NetrLogonComputeServerDigest operation response
type ComputeServerDigestResponse struct {
	// NewMessageDigest: A 128-bit MD5 digest of the current machine account password and
	// the message in the Message buffer. The machine account is identified by the Rid parameter.
	NewMessageDigest []byte `idl:"name:NewMessageDigest" json:"new_message_digest"`
	// OldMessageDigest: A 128-bit MD5 digest of the previous machine account password,
	// if present, and the message in the Message buffer. If no previous machine account
	// password exists, then the current password is used. The machine account is identified
	// by the Rid parameter.
	OldMessageDigest []byte `idl:"name:OldMessageDigest" json:"old_message_digest"`
	// Return: The NetrLogonComputeServerDigest return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ComputeServerDigestResponse) xxx_ToOp(ctx context.Context, op *xxx_ComputeServerDigestOperation) *xxx_ComputeServerDigestOperation {
	if op == nil {
		op = &xxx_ComputeServerDigestOperation{}
	}
	if o == nil {
		return op
	}
	op.NewMessageDigest = o.NewMessageDigest
	op.OldMessageDigest = o.OldMessageDigest
	op.Return = o.Return
	return op
}

func (o *ComputeServerDigestResponse) xxx_FromOp(ctx context.Context, op *xxx_ComputeServerDigestOperation) {
	if o == nil {
		return
	}
	o.NewMessageDigest = op.NewMessageDigest
	o.OldMessageDigest = op.OldMessageDigest
	o.Return = op.Return
}
func (o *ComputeServerDigestResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *ComputeServerDigestResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ComputeServerDigestOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ComputeClientDigestOperation structure represents the NetrLogonComputeClientDigest operation
type xxx_ComputeClientDigestOperation struct {
	ServerName       string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	DomainName       string `idl:"name:DomainName;string;pointer:unique" json:"domain_name"`
	Message          []byte `idl:"name:Message;size_is:(MessageSize)" json:"message"`
	MessageSize      uint32 `idl:"name:MessageSize" json:"message_size"`
	NewMessageDigest []byte `idl:"name:NewMessageDigest" json:"new_message_digest"`
	OldMessageDigest []byte `idl:"name:OldMessageDigest" json:"old_message_digest"`
	Return           uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_ComputeClientDigestOperation) OpNum() int { return 25 }

func (o *xxx_ComputeClientDigestOperation) OpName() string {
	return "/logon/v1/NetrLogonComputeClientDigest"
}

func (o *xxx_ComputeClientDigestOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.Message != nil && o.MessageSize == 0 {
		o.MessageSize = uint32(len(o.Message))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ComputeClientDigestOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// DomainName {in} (1:{string, pointer=unique}*(1)[dim:0,string,null](wchar))
	{
		if o.DomainName != "" {
			_ptr_DomainName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.DomainName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.DomainName, _ptr_DomainName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Message {in} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=MessageSize](uchar))
	{
		dimSize1 := uint64(o.MessageSize)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.Message {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.Message[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.Message); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// MessageSize {in} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.MessageSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ComputeClientDigestOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// DomainName {in} (1:{string, pointer=unique}*(1)[dim:0,string,null](wchar))
	{
		_ptr_DomainName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.DomainName); err != nil {
				return err
			}
			return nil
		})
		_s_DomainName := func(ptr interface{}) { o.DomainName = *ptr.(*string) }
		if err := w.ReadPointer(&o.DomainName, _s_DomainName, _ptr_DomainName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Message {in} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=MessageSize](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.Message", sizeInfo[0])
		}
		o.Message = make([]byte, sizeInfo[0])
		for i1 := range o.Message {
			i1 := i1
			if err := w.ReadData(&o.Message[i1]); err != nil {
				return err
			}
		}
	}
	// MessageSize {in} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.MessageSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ComputeClientDigestOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ComputeClientDigestOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// NewMessageDigest {out} (1:[16])(2:{alias=CHAR}(char))
	{
		for i1 := range o.NewMessageDigest {
			i1 := i1
			if uint64(i1) >= 16 {
				break
			}
			if err := w.WriteData(o.NewMessageDigest[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.NewMessageDigest); uint64(i1) < 16; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// OldMessageDigest {out} (1:[16])(2:{alias=CHAR}(char))
	{
		for i1 := range o.OldMessageDigest {
			i1 := i1
			if uint64(i1) >= 16 {
				break
			}
			if err := w.WriteData(o.OldMessageDigest[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.OldMessageDigest); uint64(i1) < 16; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ComputeClientDigestOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// NewMessageDigest {out} (1:[16])(2:{alias=CHAR}(char))
	{
		o.NewMessageDigest = make([]byte, 16)
		for i1 := range o.NewMessageDigest {
			i1 := i1
			if err := w.ReadData(&o.NewMessageDigest[i1]); err != nil {
				return err
			}
		}
	}
	// OldMessageDigest {out} (1:[16])(2:{alias=CHAR}(char))
	{
		o.OldMessageDigest = make([]byte, 16)
		for i1 := range o.OldMessageDigest {
			i1 := i1
			if err := w.ReadData(&o.OldMessageDigest[i1]); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ComputeClientDigestRequest structure represents the NetrLogonComputeClientDigest operation request
type ComputeClientDigestRequest struct {
	// ServerName: The custom binding handle, as defined in section 3.5.4.1.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// DomainName: A pointer to a null-terminated Unicode string that contains the DNS or
	// NetBIOS name of the trusted domain. If this parameter is NULL, the domain of which
	// the client computer is a member is used.
	DomainName string `idl:"name:DomainName;string;pointer:unique" json:"domain_name"`
	// Message: A pointer to a buffer that contains the message for which the digest is
	// to be computed.
	Message []byte `idl:"name:Message;size_is:(MessageSize)" json:"message"`
	// MessageSize: The length, in bytes, of the Message parameter.
	MessageSize uint32 `idl:"name:MessageSize" json:"message_size"`
}

func (o *ComputeClientDigestRequest) xxx_ToOp(ctx context.Context, op *xxx_ComputeClientDigestOperation) *xxx_ComputeClientDigestOperation {
	if op == nil {
		op = &xxx_ComputeClientDigestOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.DomainName = o.DomainName
	op.Message = o.Message
	op.MessageSize = o.MessageSize
	return op
}

func (o *ComputeClientDigestRequest) xxx_FromOp(ctx context.Context, op *xxx_ComputeClientDigestOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.DomainName = op.DomainName
	o.Message = op.Message
	o.MessageSize = op.MessageSize
}
func (o *ComputeClientDigestRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *ComputeClientDigestRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ComputeClientDigestOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ComputeClientDigestResponse structure represents the NetrLogonComputeClientDigest operation response
type ComputeClientDigestResponse struct {
	// NewMessageDigest: A 128-bit MD5 digest of the current computer account password and
	// the message in the Message buffer.
	NewMessageDigest []byte `idl:"name:NewMessageDigest" json:"new_message_digest"`
	// OldMessageDigest: A 128-bit MD5 digest of the previous machine account password and
	// the message in the Message buffer. If no previous computer account password exists,
	// the current password is used.
	OldMessageDigest []byte `idl:"name:OldMessageDigest" json:"old_message_digest"`
	// Return: The NetrLogonComputeClientDigest return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *ComputeClientDigestResponse) xxx_ToOp(ctx context.Context, op *xxx_ComputeClientDigestOperation) *xxx_ComputeClientDigestOperation {
	if op == nil {
		op = &xxx_ComputeClientDigestOperation{}
	}
	if o == nil {
		return op
	}
	op.NewMessageDigest = o.NewMessageDigest
	op.OldMessageDigest = o.OldMessageDigest
	op.Return = o.Return
	return op
}

func (o *ComputeClientDigestResponse) xxx_FromOp(ctx context.Context, op *xxx_ComputeClientDigestOperation) {
	if o == nil {
		return
	}
	o.NewMessageDigest = op.NewMessageDigest
	o.OldMessageDigest = op.OldMessageDigest
	o.Return = op.Return
}
func (o *ComputeClientDigestResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *ComputeClientDigestResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ComputeClientDigestOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_Authenticate3Operation structure represents the NetrServerAuthenticate3 operation
type xxx_Authenticate3Operation struct {
	PrimaryName       string            `idl:"name:PrimaryName;string;pointer:unique" json:"primary_name"`
	AccountName       string            `idl:"name:AccountName;string" json:"account_name"`
	SecureChannelType SecureChannelType `idl:"name:SecureChannelType" json:"secure_channel_type"`
	ComputerName      string            `idl:"name:ComputerName;string" json:"computer_name"`
	ClientCredential  *Credential       `idl:"name:ClientCredential" json:"client_credential"`
	ServerCredential  *Credential       `idl:"name:ServerCredential" json:"server_credential"`
	NegotiateFlags    uint32            `idl:"name:NegotiateFlags" json:"negotiate_flags"`
	AccountRID        uint32            `idl:"name:AccountRid" json:"account_rid"`
	Return            int32             `idl:"name:Return" json:"return"`
}

func (o *xxx_Authenticate3Operation) OpNum() int { return 26 }

func (o *xxx_Authenticate3Operation) OpName() string { return "/logon/v1/NetrServerAuthenticate3" }

func (o *xxx_Authenticate3Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_Authenticate3Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// PrimaryName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.PrimaryName != "" {
			_ptr_PrimaryName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.PrimaryName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.PrimaryName, _ptr_PrimaryName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// AccountName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.AccountName); err != nil {
			return err
		}
	}
	// SecureChannelType {in} (1:{alias=NETLOGON_SECURE_CHANNEL_TYPE}(enum))
	{
		if err := w.WriteEnum(uint16(o.SecureChannelType)); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ComputerName); err != nil {
			return err
		}
	}
	// ClientCredential {in} (1:{alias=PNETLOGON_CREDENTIAL}*(1))(2:{alias=NETLOGON_CREDENTIAL}(struct))
	{
		if o.ClientCredential != nil {
			if err := o.ClientCredential.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Credential{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// NegotiateFlags {in, out} (1:{pointer=ref}*(1))(2:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.NegotiateFlags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_Authenticate3Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// PrimaryName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_PrimaryName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.PrimaryName); err != nil {
				return err
			}
			return nil
		})
		_s_PrimaryName := func(ptr interface{}) { o.PrimaryName = *ptr.(*string) }
		if err := w.ReadPointer(&o.PrimaryName, _s_PrimaryName, _ptr_PrimaryName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// AccountName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.AccountName); err != nil {
			return err
		}
	}
	// SecureChannelType {in} (1:{alias=NETLOGON_SECURE_CHANNEL_TYPE}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.SecureChannelType)); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ComputerName); err != nil {
			return err
		}
	}
	// ClientCredential {in} (1:{alias=PNETLOGON_CREDENTIAL,pointer=ref}*(1))(2:{alias=NETLOGON_CREDENTIAL}(struct))
	{
		if o.ClientCredential == nil {
			o.ClientCredential = &Credential{}
		}
		if err := o.ClientCredential.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// NegotiateFlags {in, out} (1:{pointer=ref}*(1))(2:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.NegotiateFlags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_Authenticate3Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_Authenticate3Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ServerCredential {out} (1:{alias=PNETLOGON_CREDENTIAL}*(1))(2:{alias=NETLOGON_CREDENTIAL}(struct))
	{
		if o.ServerCredential != nil {
			if err := o.ServerCredential.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Credential{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// NegotiateFlags {in, out} (1:{pointer=ref}*(1))(2:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.NegotiateFlags); err != nil {
			return err
		}
	}
	// AccountRid {out} (1:{pointer=ref}*(1))(2:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.AccountRID); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_Authenticate3Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ServerCredential {out} (1:{alias=PNETLOGON_CREDENTIAL,pointer=ref}*(1))(2:{alias=NETLOGON_CREDENTIAL}(struct))
	{
		if o.ServerCredential == nil {
			o.ServerCredential = &Credential{}
		}
		if err := o.ServerCredential.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// NegotiateFlags {in, out} (1:{pointer=ref}*(1))(2:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.NegotiateFlags); err != nil {
			return err
		}
	}
	// AccountRid {out} (1:{pointer=ref}*(1))(2:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.AccountRID); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// Authenticate3Request structure represents the NetrServerAuthenticate3 operation request
type Authenticate3Request struct {
	// PrimaryName: The custom binding handle, as defined in section 3.5.4.1.
	PrimaryName string `idl:"name:PrimaryName;string;pointer:unique" json:"primary_name"`
	// AccountName: A null-terminated Unicode string that identifies the name of the account
	// that contains the secret key (password) that is shared between the client and the
	// server.<174>
	AccountName string `idl:"name:AccountName;string" json:"account_name"`
	// SecureChannelType: A NETLOGON_SECURE_CHANNEL_TYPE enumerated value, as specified
	// in section 2.2.1.3.13, that indicates the type of the secure channel being established
	// by this call.
	SecureChannelType SecureChannelType `idl:"name:SecureChannelType" json:"secure_channel_type"`
	// ComputerName: A null-terminated Unicode string that contains the NetBIOS name of
	// the client computer calling this method.
	ComputerName string `idl:"name:ComputerName;string" json:"computer_name"`
	// ClientCredential: A pointer to a NETLOGON_CREDENTIAL structure, as specified in section
	// 2.2.1.3.4, that contains the supplied client credentials, as specified in section
	// 3.1.4.4.
	ClientCredential *Credential `idl:"name:ClientCredential" json:"client_credential"`
	// NegotiateFlags: A pointer to a 32-bit set of bit flags in little-endian format that
	// indicate features supported. As input, the flags are those requested by the client
	// and are the same as ClientCapabilities. As output, they are the bit-wise AND of the
	// client's requested capabilities and the server's ServerCapabilities. For more details,
	// see section 3.1.4.2.
	NegotiateFlags uint32 `idl:"name:NegotiateFlags" json:"negotiate_flags"`
}

func (o *Authenticate3Request) xxx_ToOp(ctx context.Context, op *xxx_Authenticate3Operation) *xxx_Authenticate3Operation {
	if op == nil {
		op = &xxx_Authenticate3Operation{}
	}
	if o == nil {
		return op
	}
	op.PrimaryName = o.PrimaryName
	op.AccountName = o.AccountName
	op.SecureChannelType = o.SecureChannelType
	op.ComputerName = o.ComputerName
	op.ClientCredential = o.ClientCredential
	op.NegotiateFlags = o.NegotiateFlags
	return op
}

func (o *Authenticate3Request) xxx_FromOp(ctx context.Context, op *xxx_Authenticate3Operation) {
	if o == nil {
		return
	}
	o.PrimaryName = op.PrimaryName
	o.AccountName = op.AccountName
	o.SecureChannelType = op.SecureChannelType
	o.ComputerName = op.ComputerName
	o.ClientCredential = op.ClientCredential
	o.NegotiateFlags = op.NegotiateFlags
}
func (o *Authenticate3Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *Authenticate3Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_Authenticate3Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// Authenticate3Response structure represents the NetrServerAuthenticate3 operation response
type Authenticate3Response struct {
	// ServerCredential: A pointer to a NETLOGON_CREDENTIAL structure, as specified in section
	// 2.2.1.3.4, that contains the returned server credentials.
	ServerCredential *Credential `idl:"name:ServerCredential" json:"server_credential"`
	// NegotiateFlags: A pointer to a 32-bit set of bit flags in little-endian format that
	// indicate features supported. As input, the flags are those requested by the client
	// and are the same as ClientCapabilities. As output, they are the bit-wise AND of the
	// client's requested capabilities and the server's ServerCapabilities. For more details,
	// see section 3.1.4.2.
	NegotiateFlags uint32 `idl:"name:NegotiateFlags" json:"negotiate_flags"`
	// AccountRid: A pointer that receives the RID of the account specified by the AccountName
	// parameter. ([MS-ADTS] section 3.1.1.5.2.4 specifies how this RID is assigned at account
	// creation time.) This value is stored in the AccountRid ADM element within the ClientSessionInfo
	// table.
	AccountRID uint32 `idl:"name:AccountRid" json:"account_rid"`
	// Return: The NetrServerAuthenticate3 return value.
	Return int32 `idl:"name:Return" json:"return"`
}

func (o *Authenticate3Response) xxx_ToOp(ctx context.Context, op *xxx_Authenticate3Operation) *xxx_Authenticate3Operation {
	if op == nil {
		op = &xxx_Authenticate3Operation{}
	}
	if o == nil {
		return op
	}
	op.ServerCredential = o.ServerCredential
	op.NegotiateFlags = o.NegotiateFlags
	op.AccountRID = o.AccountRID
	op.Return = o.Return
	return op
}

func (o *Authenticate3Response) xxx_FromOp(ctx context.Context, op *xxx_Authenticate3Operation) {
	if o == nil {
		return
	}
	o.ServerCredential = op.ServerCredential
	o.NegotiateFlags = op.NegotiateFlags
	o.AccountRID = op.AccountRID
	o.Return = op.Return
}
func (o *Authenticate3Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *Authenticate3Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_Authenticate3Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetDCNameExOperation structure represents the DsrGetDcNameEx operation
type xxx_GetDCNameExOperation struct {
	ComputerName         string                 `idl:"name:ComputerName;string;pointer:unique" json:"computer_name"`
	DomainName           string                 `idl:"name:DomainName;string;pointer:unique" json:"domain_name"`
	DomainGUID           *dtyp.GUID             `idl:"name:DomainGuid;pointer:unique" json:"domain_guid"`
	SiteName             string                 `idl:"name:SiteName;string;pointer:unique" json:"site_name"`
	Flags                uint32                 `idl:"name:Flags" json:"flags"`
	DomainControllerInfo *DomainControllerInfoW `idl:"name:DomainControllerInfo" json:"domain_controller_info"`
	Return               uint32                 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetDCNameExOperation) OpNum() int { return 27 }

func (o *xxx_GetDCNameExOperation) OpName() string { return "/logon/v1/DsrGetDcNameEx" }

func (o *xxx_GetDCNameExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetDCNameExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ComputerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ComputerName != "" {
			_ptr_ComputerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ComputerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ComputerName, _ptr_ComputerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// DomainName {in} (1:{string, pointer=unique}*(1)[dim:0,string,null](wchar))
	{
		if o.DomainName != "" {
			_ptr_DomainName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.DomainName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.DomainName, _ptr_DomainName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// DomainGuid {in} (1:{pointer=unique}*(1))(2:{alias=GUID}(struct))
	{
		if o.DomainGUID != nil {
			_ptr_DomainGuid := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.DomainGUID != nil {
					if err := o.DomainGUID.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.DomainGUID, _ptr_DomainGuid); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// SiteName {in} (1:{string, pointer=unique}*(1)[dim:0,string,null](wchar))
	{
		if o.SiteName != "" {
			_ptr_SiteName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.SiteName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.SiteName, _ptr_SiteName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetDCNameExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ComputerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ComputerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ComputerName); err != nil {
				return err
			}
			return nil
		})
		_s_ComputerName := func(ptr interface{}) { o.ComputerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ComputerName, _s_ComputerName, _ptr_ComputerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// DomainName {in} (1:{string, pointer=unique}*(1)[dim:0,string,null](wchar))
	{
		_ptr_DomainName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.DomainName); err != nil {
				return err
			}
			return nil
		})
		_s_DomainName := func(ptr interface{}) { o.DomainName = *ptr.(*string) }
		if err := w.ReadPointer(&o.DomainName, _s_DomainName, _ptr_DomainName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// DomainGuid {in} (1:{pointer=unique}*(1))(2:{alias=GUID}(struct))
	{
		_ptr_DomainGuid := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.DomainGUID == nil {
				o.DomainGUID = &dtyp.GUID{}
			}
			if err := o.DomainGUID.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_DomainGuid := func(ptr interface{}) { o.DomainGUID = *ptr.(**dtyp.GUID) }
		if err := w.ReadPointer(&o.DomainGUID, _s_DomainGuid, _ptr_DomainGuid); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// SiteName {in} (1:{string, pointer=unique}*(1)[dim:0,string,null](wchar))
	{
		_ptr_SiteName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.SiteName); err != nil {
				return err
			}
			return nil
		})
		_s_SiteName := func(ptr interface{}) { o.SiteName = *ptr.(*string) }
		if err := w.ReadPointer(&o.SiteName, _s_SiteName, _ptr_SiteName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetDCNameExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetDCNameExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// DomainControllerInfo {out} (1:{pointer=ref}*(2))(2:{alias=PDOMAIN_CONTROLLER_INFOW}*(1))(3:{alias=DOMAIN_CONTROLLER_INFOW}(struct))
	{
		if o.DomainControllerInfo != nil {
			_ptr_DomainControllerInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.DomainControllerInfo != nil {
					if err := o.DomainControllerInfo.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&DomainControllerInfoW{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.DomainControllerInfo, _ptr_DomainControllerInfo); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetDCNameExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// DomainControllerInfo {out} (1:{pointer=ref}*(2))(2:{alias=PDOMAIN_CONTROLLER_INFOW,pointer=ref}*(1))(3:{alias=DOMAIN_CONTROLLER_INFOW}(struct))
	{
		_ptr_DomainControllerInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.DomainControllerInfo == nil {
				o.DomainControllerInfo = &DomainControllerInfoW{}
			}
			if err := o.DomainControllerInfo.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_DomainControllerInfo := func(ptr interface{}) { o.DomainControllerInfo = *ptr.(**DomainControllerInfoW) }
		if err := w.ReadPointer(&o.DomainControllerInfo, _s_DomainControllerInfo, _ptr_DomainControllerInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetDCNameExRequest structure represents the DsrGetDcNameEx operation request
type GetDCNameExRequest struct {
	ComputerName string     `idl:"name:ComputerName;string;pointer:unique" json:"computer_name"`
	DomainName   string     `idl:"name:DomainName;string;pointer:unique" json:"domain_name"`
	DomainGUID   *dtyp.GUID `idl:"name:DomainGuid;pointer:unique" json:"domain_guid"`
	SiteName     string     `idl:"name:SiteName;string;pointer:unique" json:"site_name"`
	Flags        uint32     `idl:"name:Flags" json:"flags"`
}

func (o *GetDCNameExRequest) xxx_ToOp(ctx context.Context, op *xxx_GetDCNameExOperation) *xxx_GetDCNameExOperation {
	if op == nil {
		op = &xxx_GetDCNameExOperation{}
	}
	if o == nil {
		return op
	}
	op.ComputerName = o.ComputerName
	op.DomainName = o.DomainName
	op.DomainGUID = o.DomainGUID
	op.SiteName = o.SiteName
	op.Flags = o.Flags
	return op
}

func (o *GetDCNameExRequest) xxx_FromOp(ctx context.Context, op *xxx_GetDCNameExOperation) {
	if o == nil {
		return
	}
	o.ComputerName = op.ComputerName
	o.DomainName = op.DomainName
	o.DomainGUID = op.DomainGUID
	o.SiteName = op.SiteName
	o.Flags = op.Flags
}
func (o *GetDCNameExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetDCNameExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetDCNameExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetDCNameExResponse structure represents the DsrGetDcNameEx operation response
type GetDCNameExResponse struct {
	DomainControllerInfo *DomainControllerInfoW `idl:"name:DomainControllerInfo" json:"domain_controller_info"`
	// Return: The DsrGetDcNameEx return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetDCNameExResponse) xxx_ToOp(ctx context.Context, op *xxx_GetDCNameExOperation) *xxx_GetDCNameExOperation {
	if op == nil {
		op = &xxx_GetDCNameExOperation{}
	}
	if o == nil {
		return op
	}
	op.DomainControllerInfo = o.DomainControllerInfo
	op.Return = o.Return
	return op
}

func (o *GetDCNameExResponse) xxx_FromOp(ctx context.Context, op *xxx_GetDCNameExOperation) {
	if o == nil {
		return
	}
	o.DomainControllerInfo = op.DomainControllerInfo
	o.Return = op.Return
}
func (o *GetDCNameExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetDCNameExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetDCNameExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetSiteNameOperation structure represents the DsrGetSiteName operation
type xxx_GetSiteNameOperation struct {
	ComputerName string `idl:"name:ComputerName;string;pointer:unique" json:"computer_name"`
	SiteName     string `idl:"name:SiteName;string" json:"site_name"`
	Return       uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetSiteNameOperation) OpNum() int { return 28 }

func (o *xxx_GetSiteNameOperation) OpName() string { return "/logon/v1/DsrGetSiteName" }

func (o *xxx_GetSiteNameOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetSiteNameOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ComputerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ComputerName != "" {
			_ptr_ComputerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ComputerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ComputerName, _ptr_ComputerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetSiteNameOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ComputerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ComputerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ComputerName); err != nil {
				return err
			}
			return nil
		})
		_s_ComputerName := func(ptr interface{}) { o.ComputerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ComputerName, _s_ComputerName, _ptr_ComputerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetSiteNameOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetSiteNameOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// SiteName {out} (1:{string, pointer=ref}*(2)*(1)[dim:0,string,null](wchar))
	{
		if o.SiteName != "" {
			_ptr_SiteName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.SiteName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.SiteName, _ptr_SiteName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetSiteNameOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// SiteName {out} (1:{string, pointer=ref}*(2)*(1)[dim:0,string,null](wchar))
	{
		_ptr_SiteName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.SiteName); err != nil {
				return err
			}
			return nil
		})
		_s_SiteName := func(ptr interface{}) { o.SiteName = *ptr.(*string) }
		if err := w.ReadPointer(&o.SiteName, _s_SiteName, _ptr_SiteName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetSiteNameRequest structure represents the DsrGetSiteName operation request
type GetSiteNameRequest struct {
	// ComputerName: The custom binding handle (defined in section 3.5.4.1).
	ComputerName string `idl:"name:ComputerName;string;pointer:unique" json:"computer_name"`
}

func (o *GetSiteNameRequest) xxx_ToOp(ctx context.Context, op *xxx_GetSiteNameOperation) *xxx_GetSiteNameOperation {
	if op == nil {
		op = &xxx_GetSiteNameOperation{}
	}
	if o == nil {
		return op
	}
	op.ComputerName = o.ComputerName
	return op
}

func (o *GetSiteNameRequest) xxx_FromOp(ctx context.Context, op *xxx_GetSiteNameOperation) {
	if o == nil {
		return
	}
	o.ComputerName = op.ComputerName
}
func (o *GetSiteNameRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetSiteNameRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetSiteNameOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetSiteNameResponse structure represents the DsrGetSiteName operation response
type GetSiteNameResponse struct {
	// SiteName: A null-terminated Unicode string that contains the name of the site in
	// which the computer that receives this call resides.
	SiteName string `idl:"name:SiteName;string" json:"site_name"`
	// Return: The DsrGetSiteName return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetSiteNameResponse) xxx_ToOp(ctx context.Context, op *xxx_GetSiteNameOperation) *xxx_GetSiteNameOperation {
	if op == nil {
		op = &xxx_GetSiteNameOperation{}
	}
	if o == nil {
		return op
	}
	op.SiteName = o.SiteName
	op.Return = o.Return
	return op
}

func (o *GetSiteNameResponse) xxx_FromOp(ctx context.Context, op *xxx_GetSiteNameOperation) {
	if o == nil {
		return
	}
	o.SiteName = op.SiteName
	o.Return = op.Return
}
func (o *GetSiteNameResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetSiteNameResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetSiteNameOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetDomainInfoOperation structure represents the NetrLogonGetDomainInfo operation
type xxx_GetDomainInfoOperation struct {
	ServerName          string                  `idl:"name:ServerName;string" json:"server_name"`
	ComputerName        string                  `idl:"name:ComputerName;string;pointer:unique" json:"computer_name"`
	Authenticator       *Authenticator          `idl:"name:Authenticator" json:"authenticator"`
	ReturnAuthenticator *Authenticator          `idl:"name:ReturnAuthenticator" json:"return_authenticator"`
	Level               uint32                  `idl:"name:Level" json:"level"`
	WorkstationBuffer   *WorkstationInformation `idl:"name:WkstaBuffer;switch_is:Level" json:"workstation_buffer"`
	DomBuffer           *DomainInformation      `idl:"name:DomBuffer;switch_is:Level" json:"dom_buffer"`
	Return              int32                   `idl:"name:Return" json:"return"`
}

func (o *xxx_GetDomainInfoOperation) OpNum() int { return 29 }

func (o *xxx_GetDomainInfoOperation) OpName() string { return "/logon/v1/NetrLogonGetDomainInfo" }

func (o *xxx_GetDomainInfoOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetDomainInfoOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=unique}*(1)[dim:0,string,null](wchar))
	{
		if o.ComputerName != "" {
			_ptr_ComputerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ComputerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ComputerName, _ptr_ComputerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Authenticator {in} (1:{alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.Authenticator != nil {
			if err := o.Authenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// ReturnAuthenticator {in, out} (1:{alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator != nil {
			if err := o.ReturnAuthenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Level); err != nil {
			return err
		}
	}
	// WkstaBuffer {in} (1:{switch_type={alias=DWORD}(uint32), alias=PNETLOGON_WORKSTATION_INFORMATION}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=NETLOGON_WORKSTATION_INFORMATION}(union))
	{
		_swWorkstationBuffer := uint32(o.Level)
		if o.WorkstationBuffer != nil {
			if err := o.WorkstationBuffer.MarshalUnionNDR(ctx, w, _swWorkstationBuffer); err != nil {
				return err
			}
		} else {
			if err := (&WorkstationInformation{}).MarshalUnionNDR(ctx, w, _swWorkstationBuffer); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetDomainInfoOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, alias=LOGONSRV_HANDLE,pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=unique}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ComputerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ComputerName); err != nil {
				return err
			}
			return nil
		})
		_s_ComputerName := func(ptr interface{}) { o.ComputerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ComputerName, _s_ComputerName, _ptr_ComputerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Authenticator {in} (1:{alias=PNETLOGON_AUTHENTICATOR,pointer=ref}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.Authenticator == nil {
			o.Authenticator = &Authenticator{}
		}
		if err := o.Authenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// ReturnAuthenticator {in, out} (1:{alias=PNETLOGON_AUTHENTICATOR,pointer=ref}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator == nil {
			o.ReturnAuthenticator = &Authenticator{}
		}
		if err := o.ReturnAuthenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Level {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Level); err != nil {
			return err
		}
	}
	// WkstaBuffer {in} (1:{switch_type={alias=DWORD}(uint32), alias=PNETLOGON_WORKSTATION_INFORMATION,pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=NETLOGON_WORKSTATION_INFORMATION}(union))
	{
		if o.WorkstationBuffer == nil {
			o.WorkstationBuffer = &WorkstationInformation{}
		}
		_swWorkstationBuffer := uint32(o.Level)
		if err := o.WorkstationBuffer.UnmarshalUnionNDR(ctx, w, _swWorkstationBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetDomainInfoOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetDomainInfoOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ReturnAuthenticator {in, out} (1:{alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator != nil {
			if err := o.ReturnAuthenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// DomBuffer {out} (1:{switch_type={alias=DWORD}(uint32), alias=PNETLOGON_DOMAIN_INFORMATION}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=NETLOGON_DOMAIN_INFORMATION}(union))
	{
		_swDomBuffer := uint32(o.Level)
		if o.DomBuffer != nil {
			if err := o.DomBuffer.MarshalUnionNDR(ctx, w, _swDomBuffer); err != nil {
				return err
			}
		} else {
			if err := (&DomainInformation{}).MarshalUnionNDR(ctx, w, _swDomBuffer); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetDomainInfoOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ReturnAuthenticator {in, out} (1:{alias=PNETLOGON_AUTHENTICATOR,pointer=ref}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator == nil {
			o.ReturnAuthenticator = &Authenticator{}
		}
		if err := o.ReturnAuthenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// DomBuffer {out} (1:{switch_type={alias=DWORD}(uint32), alias=PNETLOGON_DOMAIN_INFORMATION,pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=NETLOGON_DOMAIN_INFORMATION}(union))
	{
		if o.DomBuffer == nil {
			o.DomBuffer = &DomainInformation{}
		}
		_swDomBuffer := uint32(o.Level)
		if err := o.DomBuffer.UnmarshalUnionNDR(ctx, w, _swDomBuffer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetDomainInfoRequest structure represents the NetrLogonGetDomainInfo operation request
type GetDomainInfoRequest struct {
	// ServerName: The custom binding handle, as defined in section 3.5.4.1.
	ServerName string `idl:"name:ServerName;string" json:"server_name"`
	// ComputerName: The null-terminated Unicode string that contains the name of the client
	// computer issuing the request.
	ComputerName string `idl:"name:ComputerName;string;pointer:unique" json:"computer_name"`
	// Authenticator: A pointer to a NETLOGON_AUTHENTICATOR structure, as specified in section
	// 2.2.1.1.5, that contains the client authenticator.
	Authenticator *Authenticator `idl:"name:Authenticator" json:"authenticator"`
	// ReturnAuthenticator: A pointer to a NETLOGON_AUTHENTICATOR structure, as specified
	// in section 2.2.1.1.5, that contains the server return authenticator.
	ReturnAuthenticator *Authenticator `idl:"name:ReturnAuthenticator" json:"return_authenticator"`
	// Level: The information level requested by the client. The DomBuffer parameter contains
	// one of the following structures, based on the value of this field.
	//
	//	+------------+--------------------------------------------------------------+
	//	|            |                                                              |
	//	|   VALUE    |                           MEANING                            |
	//	|            |                                                              |
	//	+------------+--------------------------------------------------------------+
	//	+------------+--------------------------------------------------------------+
	//	| 0x00000001 | The DomBuffer contains a NETLOGON_DOMAIN_INFO structure.     |
	//	+------------+--------------------------------------------------------------+
	//	| 0x00000002 | The DomBuffer contains a NETLOGON_LSA_POLICY_INFO structure. |
	//	+------------+--------------------------------------------------------------+
	Level uint32 `idl:"name:Level" json:"level"`
	// WkstaBuffer: A pointer to a NETLOGON_WORKSTATION_INFO structure, as specified in
	// section 2.2.1.3.6, that contains information about the client workstation.
	WorkstationBuffer *WorkstationInformation `idl:"name:WkstaBuffer;switch_is:Level" json:"workstation_buffer"`
}

func (o *GetDomainInfoRequest) xxx_ToOp(ctx context.Context, op *xxx_GetDomainInfoOperation) *xxx_GetDomainInfoOperation {
	if op == nil {
		op = &xxx_GetDomainInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.ComputerName = o.ComputerName
	op.Authenticator = o.Authenticator
	op.ReturnAuthenticator = o.ReturnAuthenticator
	op.Level = o.Level
	op.WorkstationBuffer = o.WorkstationBuffer
	return op
}

func (o *GetDomainInfoRequest) xxx_FromOp(ctx context.Context, op *xxx_GetDomainInfoOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.ComputerName = op.ComputerName
	o.Authenticator = op.Authenticator
	o.ReturnAuthenticator = op.ReturnAuthenticator
	o.Level = op.Level
	o.WorkstationBuffer = op.WorkstationBuffer
}
func (o *GetDomainInfoRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetDomainInfoRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetDomainInfoOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetDomainInfoResponse structure represents the NetrLogonGetDomainInfo operation response
type GetDomainInfoResponse struct {
	// XXX: Level is an implicit input depedency for output parameters
	Level uint32 `idl:"name:Level" json:"level"`

	// ReturnAuthenticator: A pointer to a NETLOGON_AUTHENTICATOR structure, as specified
	// in section 2.2.1.1.5, that contains the server return authenticator.
	ReturnAuthenticator *Authenticator `idl:"name:ReturnAuthenticator" json:"return_authenticator"`
	// DomBuffer: A pointer to a NETLOGON_DOMAIN_INFORMATION structure, as specified in
	// section 2.2.1.3.12, that contains information about the domain or policy information.
	DomBuffer *DomainInformation `idl:"name:DomBuffer;switch_is:Level" json:"dom_buffer"`
	// Return: The NetrLogonGetDomainInfo return value.
	Return int32 `idl:"name:Return" json:"return"`
}

func (o *GetDomainInfoResponse) xxx_ToOp(ctx context.Context, op *xxx_GetDomainInfoOperation) *xxx_GetDomainInfoOperation {
	if op == nil {
		op = &xxx_GetDomainInfoOperation{}
	}
	if o == nil {
		return op
	}
	// XXX: implicit input dependencies for output parameters
	if op.Level == uint32(0) {
		op.Level = o.Level
	}

	op.ReturnAuthenticator = o.ReturnAuthenticator
	op.DomBuffer = o.DomBuffer
	op.Return = o.Return
	return op
}

func (o *GetDomainInfoResponse) xxx_FromOp(ctx context.Context, op *xxx_GetDomainInfoOperation) {
	if o == nil {
		return
	}
	// XXX: implicit input dependencies for output parameters
	o.Level = op.Level

	o.ReturnAuthenticator = op.ReturnAuthenticator
	o.DomBuffer = op.DomBuffer
	o.Return = op.Return
}
func (o *GetDomainInfoResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetDomainInfoResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetDomainInfoOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_PasswordSet2Operation structure represents the NetrServerPasswordSet2 operation
type xxx_PasswordSet2Operation struct {
	PrimaryName         string            `idl:"name:PrimaryName;string;pointer:unique" json:"primary_name"`
	AccountName         string            `idl:"name:AccountName;string" json:"account_name"`
	SecureChannelType   SecureChannelType `idl:"name:SecureChannelType" json:"secure_channel_type"`
	ComputerName        string            `idl:"name:ComputerName;string" json:"computer_name"`
	Authenticator       *Authenticator    `idl:"name:Authenticator" json:"authenticator"`
	ReturnAuthenticator *Authenticator    `idl:"name:ReturnAuthenticator" json:"return_authenticator"`
	ClearNewPassword    *TrustPassword    `idl:"name:ClearNewPassword" json:"clear_new_password"`
	Return              int32             `idl:"name:Return" json:"return"`
}

func (o *xxx_PasswordSet2Operation) OpNum() int { return 30 }

func (o *xxx_PasswordSet2Operation) OpName() string { return "/logon/v1/NetrServerPasswordSet2" }

func (o *xxx_PasswordSet2Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_PasswordSet2Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// PrimaryName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.PrimaryName != "" {
			_ptr_PrimaryName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.PrimaryName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.PrimaryName, _ptr_PrimaryName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// AccountName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.AccountName); err != nil {
			return err
		}
	}
	// SecureChannelType {in} (1:{alias=NETLOGON_SECURE_CHANNEL_TYPE}(enum))
	{
		if err := w.WriteEnum(uint16(o.SecureChannelType)); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ComputerName); err != nil {
			return err
		}
	}
	// Authenticator {in} (1:{alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.Authenticator != nil {
			if err := o.Authenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// ClearNewPassword {in} (1:{alias=PNL_TRUST_PASSWORD}*(1))(2:{alias=NL_TRUST_PASSWORD}(struct))
	{
		if o.ClearNewPassword != nil {
			if err := o.ClearNewPassword.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&TrustPassword{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_PasswordSet2Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// PrimaryName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_PrimaryName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.PrimaryName); err != nil {
				return err
			}
			return nil
		})
		_s_PrimaryName := func(ptr interface{}) { o.PrimaryName = *ptr.(*string) }
		if err := w.ReadPointer(&o.PrimaryName, _s_PrimaryName, _ptr_PrimaryName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// AccountName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.AccountName); err != nil {
			return err
		}
	}
	// SecureChannelType {in} (1:{alias=NETLOGON_SECURE_CHANNEL_TYPE}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.SecureChannelType)); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ComputerName); err != nil {
			return err
		}
	}
	// Authenticator {in} (1:{alias=PNETLOGON_AUTHENTICATOR,pointer=ref}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.Authenticator == nil {
			o.Authenticator = &Authenticator{}
		}
		if err := o.Authenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// ClearNewPassword {in} (1:{alias=PNL_TRUST_PASSWORD,pointer=ref}*(1))(2:{alias=NL_TRUST_PASSWORD}(struct))
	{
		if o.ClearNewPassword == nil {
			o.ClearNewPassword = &TrustPassword{}
		}
		if err := o.ClearNewPassword.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_PasswordSet2Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_PasswordSet2Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ReturnAuthenticator {out} (1:{alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator != nil {
			if err := o.ReturnAuthenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_PasswordSet2Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ReturnAuthenticator {out} (1:{alias=PNETLOGON_AUTHENTICATOR,pointer=ref}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator == nil {
			o.ReturnAuthenticator = &Authenticator{}
		}
		if err := o.ReturnAuthenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// PasswordSet2Request structure represents the NetrServerPasswordSet2 operation request
type PasswordSet2Request struct {
	// PrimaryName: The custom binding handle, as defined in section 3.5.4.1.
	PrimaryName string `idl:"name:PrimaryName;string;pointer:unique" json:"primary_name"`
	// AccountName: The null-terminated Unicode string that contains the name of the account
	// whose password is being changed.<180>
	AccountName string `idl:"name:AccountName;string" json:"account_name"`
	// SecureChannelType: An enumerated value that defines the secure channel to be used
	// for authentication, as specified in section 2.2.1.3.13.
	SecureChannelType SecureChannelType `idl:"name:SecureChannelType" json:"secure_channel_type"`
	// ComputerName: The null-terminated Unicode string that contains the NetBIOS name of
	// the computer making the request.
	ComputerName string `idl:"name:ComputerName;string" json:"computer_name"`
	// Authenticator: A pointer to a NETLOGON_AUTHENTICATOR structure, as specified in section
	// 2.2.1.1.5, that contains the encrypted logon credential and a time stamp.
	Authenticator *Authenticator `idl:"name:Authenticator" json:"authenticator"`
	// ClearNewPassword: A pointer to an NL_TRUST_PASSWORD structure, as specified in section
	// 2.2.1.3.7, that contains the new password encrypted<181> as specified in Calling
	// NetrServerPasswordSet2 (section 3.4.5.2.5).
	ClearNewPassword *TrustPassword `idl:"name:ClearNewPassword" json:"clear_new_password"`
}

func (o *PasswordSet2Request) xxx_ToOp(ctx context.Context, op *xxx_PasswordSet2Operation) *xxx_PasswordSet2Operation {
	if op == nil {
		op = &xxx_PasswordSet2Operation{}
	}
	if o == nil {
		return op
	}
	op.PrimaryName = o.PrimaryName
	op.AccountName = o.AccountName
	op.SecureChannelType = o.SecureChannelType
	op.ComputerName = o.ComputerName
	op.Authenticator = o.Authenticator
	op.ClearNewPassword = o.ClearNewPassword
	return op
}

func (o *PasswordSet2Request) xxx_FromOp(ctx context.Context, op *xxx_PasswordSet2Operation) {
	if o == nil {
		return
	}
	o.PrimaryName = op.PrimaryName
	o.AccountName = op.AccountName
	o.SecureChannelType = op.SecureChannelType
	o.ComputerName = op.ComputerName
	o.Authenticator = op.Authenticator
	o.ClearNewPassword = op.ClearNewPassword
}
func (o *PasswordSet2Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *PasswordSet2Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_PasswordSet2Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// PasswordSet2Response structure represents the NetrServerPasswordSet2 operation response
type PasswordSet2Response struct {
	// ReturnAuthenticator: A pointer to a NETLOGON_AUTHENTICATOR structure, as specified
	// in section 2.2.1.1.5, that contains the server return authenticator.
	ReturnAuthenticator *Authenticator `idl:"name:ReturnAuthenticator" json:"return_authenticator"`
	// Return: The NetrServerPasswordSet2 return value.
	Return int32 `idl:"name:Return" json:"return"`
}

func (o *PasswordSet2Response) xxx_ToOp(ctx context.Context, op *xxx_PasswordSet2Operation) *xxx_PasswordSet2Operation {
	if op == nil {
		op = &xxx_PasswordSet2Operation{}
	}
	if o == nil {
		return op
	}
	op.ReturnAuthenticator = o.ReturnAuthenticator
	op.Return = o.Return
	return op
}

func (o *PasswordSet2Response) xxx_FromOp(ctx context.Context, op *xxx_PasswordSet2Operation) {
	if o == nil {
		return
	}
	o.ReturnAuthenticator = op.ReturnAuthenticator
	o.Return = op.Return
}
func (o *PasswordSet2Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *PasswordSet2Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_PasswordSet2Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_PasswordGetOperation structure represents the NetrServerPasswordGet operation
type xxx_PasswordGetOperation struct {
	PrimaryName            string                  `idl:"name:PrimaryName;string;pointer:unique" json:"primary_name"`
	AccountName            string                  `idl:"name:AccountName;string" json:"account_name"`
	AccountType            SecureChannelType       `idl:"name:AccountType" json:"account_type"`
	ComputerName           string                  `idl:"name:ComputerName;string" json:"computer_name"`
	Authenticator          *Authenticator          `idl:"name:Authenticator" json:"authenticator"`
	ReturnAuthenticator    *Authenticator          `idl:"name:ReturnAuthenticator" json:"return_authenticator"`
	EncryptedNTOWFPassword *EncryptedNTOWFPassword `idl:"name:EncryptedNtOwfPassword" json:"encrypted_nt_owf_password"`
	Return                 int32                   `idl:"name:Return" json:"return"`
}

func (o *xxx_PasswordGetOperation) OpNum() int { return 31 }

func (o *xxx_PasswordGetOperation) OpName() string { return "/logon/v1/NetrServerPasswordGet" }

func (o *xxx_PasswordGetOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_PasswordGetOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// PrimaryName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.PrimaryName != "" {
			_ptr_PrimaryName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.PrimaryName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.PrimaryName, _ptr_PrimaryName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// AccountName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.AccountName); err != nil {
			return err
		}
	}
	// AccountType {in} (1:{alias=NETLOGON_SECURE_CHANNEL_TYPE}(enum))
	{
		if err := w.WriteEnum(uint16(o.AccountType)); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ComputerName); err != nil {
			return err
		}
	}
	// Authenticator {in} (1:{alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.Authenticator != nil {
			if err := o.Authenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_PasswordGetOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// PrimaryName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_PrimaryName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.PrimaryName); err != nil {
				return err
			}
			return nil
		})
		_s_PrimaryName := func(ptr interface{}) { o.PrimaryName = *ptr.(*string) }
		if err := w.ReadPointer(&o.PrimaryName, _s_PrimaryName, _ptr_PrimaryName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// AccountName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.AccountName); err != nil {
			return err
		}
	}
	// AccountType {in} (1:{alias=NETLOGON_SECURE_CHANNEL_TYPE}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.AccountType)); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ComputerName); err != nil {
			return err
		}
	}
	// Authenticator {in} (1:{alias=PNETLOGON_AUTHENTICATOR,pointer=ref}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.Authenticator == nil {
			o.Authenticator = &Authenticator{}
		}
		if err := o.Authenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_PasswordGetOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_PasswordGetOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ReturnAuthenticator {out} (1:{alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator != nil {
			if err := o.ReturnAuthenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// EncryptedNtOwfPassword {out} (1:{alias=PENCRYPTED_NT_OWF_PASSWORD}*(1))(2:{alias=ENCRYPTED_NT_OWF_PASSWORD}(struct))
	{
		if o.EncryptedNTOWFPassword != nil {
			if err := o.EncryptedNTOWFPassword.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&EncryptedNTOWFPassword{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_PasswordGetOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ReturnAuthenticator {out} (1:{alias=PNETLOGON_AUTHENTICATOR,pointer=ref}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator == nil {
			o.ReturnAuthenticator = &Authenticator{}
		}
		if err := o.ReturnAuthenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// EncryptedNtOwfPassword {out} (1:{alias=PENCRYPTED_NT_OWF_PASSWORD,pointer=ref}*(1))(2:{alias=ENCRYPTED_NT_OWF_PASSWORD}(struct))
	{
		if o.EncryptedNTOWFPassword == nil {
			o.EncryptedNTOWFPassword = &EncryptedNTOWFPassword{}
		}
		if err := o.EncryptedNTOWFPassword.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// PasswordGetRequest structure represents the NetrServerPasswordGet operation request
type PasswordGetRequest struct {
	// PrimaryName: The custom binding handle, as defined in section 3.5.4.1.
	PrimaryName string `idl:"name:PrimaryName;string;pointer:unique" json:"primary_name"`
	// AccountName: A null-terminated Unicode string that contains the name of the account
	// to retrieve the password for.<185>
	AccountName string `idl:"name:AccountName;string" json:"account_name"`
	// AccountType: A NETLOGON_SECURE_CHANNEL_TYPE enumerated value, as specified in section
	// 2.2.1.3.13, that defines the secure channel to be used for authentication.
	AccountType SecureChannelType `idl:"name:AccountType" json:"account_type"`
	// ComputerName: A null-terminated Unicode string that contains the NetBIOS name of
	// the DC making the call.
	ComputerName string `idl:"name:ComputerName;string" json:"computer_name"`
	// Authenticator: A pointer to a NETLOGON_AUTHENTICATOR structure, as specified in section
	// 2.2.1.1.5, that contains the encrypted logon credential and a time stamp.
	Authenticator *Authenticator `idl:"name:Authenticator" json:"authenticator"`
}

func (o *PasswordGetRequest) xxx_ToOp(ctx context.Context, op *xxx_PasswordGetOperation) *xxx_PasswordGetOperation {
	if op == nil {
		op = &xxx_PasswordGetOperation{}
	}
	if o == nil {
		return op
	}
	op.PrimaryName = o.PrimaryName
	op.AccountName = o.AccountName
	op.AccountType = o.AccountType
	op.ComputerName = o.ComputerName
	op.Authenticator = o.Authenticator
	return op
}

func (o *PasswordGetRequest) xxx_FromOp(ctx context.Context, op *xxx_PasswordGetOperation) {
	if o == nil {
		return
	}
	o.PrimaryName = op.PrimaryName
	o.AccountName = op.AccountName
	o.AccountType = op.AccountType
	o.ComputerName = op.ComputerName
	o.Authenticator = op.Authenticator
}
func (o *PasswordGetRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *PasswordGetRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_PasswordGetOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// PasswordGetResponse structure represents the NetrServerPasswordGet operation response
type PasswordGetResponse struct {
	// ReturnAuthenticator: A pointer to a NETLOGON_AUTHENTICATOR structure, as specified
	// in section 2.2.1.1.5, that contains the server return authenticator.
	ReturnAuthenticator *Authenticator `idl:"name:ReturnAuthenticator" json:"return_authenticator"`
	// EncryptedNtOwfPassword: A pointer to an ENCRYPTED_NT_OWF_PASSWORD structure, as specified
	// in [MS-SAMR] section 2.2.7.3, that contains the OWF password of the account.
	EncryptedNTOWFPassword *EncryptedNTOWFPassword `idl:"name:EncryptedNtOwfPassword" json:"encrypted_nt_owf_password"`
	// Return: The NetrServerPasswordGet return value.
	Return int32 `idl:"name:Return" json:"return"`
}

func (o *PasswordGetResponse) xxx_ToOp(ctx context.Context, op *xxx_PasswordGetOperation) *xxx_PasswordGetOperation {
	if op == nil {
		op = &xxx_PasswordGetOperation{}
	}
	if o == nil {
		return op
	}
	op.ReturnAuthenticator = o.ReturnAuthenticator
	op.EncryptedNTOWFPassword = o.EncryptedNTOWFPassword
	op.Return = o.Return
	return op
}

func (o *PasswordGetResponse) xxx_FromOp(ctx context.Context, op *xxx_PasswordGetOperation) {
	if o == nil {
		return
	}
	o.ReturnAuthenticator = op.ReturnAuthenticator
	o.EncryptedNTOWFPassword = op.EncryptedNTOWFPassword
	o.Return = op.Return
}
func (o *PasswordGetResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *PasswordGetResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_PasswordGetOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SendToSAMOperation structure represents the NetrLogonSendToSam operation
type xxx_SendToSAMOperation struct {
	PrimaryName         string         `idl:"name:PrimaryName;string;pointer:unique" json:"primary_name"`
	ComputerName        string         `idl:"name:ComputerName;string" json:"computer_name"`
	Authenticator       *Authenticator `idl:"name:Authenticator" json:"authenticator"`
	ReturnAuthenticator *Authenticator `idl:"name:ReturnAuthenticator" json:"return_authenticator"`
	OpaqueBuffer        []byte         `idl:"name:OpaqueBuffer;size_is:(OpaqueBufferSize)" json:"opaque_buffer"`
	OpaqueBufferSize    uint32         `idl:"name:OpaqueBufferSize" json:"opaque_buffer_size"`
	Return              int32          `idl:"name:Return" json:"return"`
}

func (o *xxx_SendToSAMOperation) OpNum() int { return 32 }

func (o *xxx_SendToSAMOperation) OpName() string { return "/logon/v1/NetrLogonSendToSam" }

func (o *xxx_SendToSAMOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.OpaqueBuffer != nil && o.OpaqueBufferSize == 0 {
		o.OpaqueBufferSize = uint32(len(o.OpaqueBuffer))
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SendToSAMOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// PrimaryName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.PrimaryName != "" {
			_ptr_PrimaryName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.PrimaryName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.PrimaryName, _ptr_PrimaryName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ComputerName); err != nil {
			return err
		}
	}
	// Authenticator {in} (1:{alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.Authenticator != nil {
			if err := o.Authenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// OpaqueBuffer {in} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=OpaqueBufferSize](uchar))
	{
		dimSize1 := uint64(o.OpaqueBufferSize)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.OpaqueBuffer {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if err := w.WriteData(o.OpaqueBuffer[i1]); err != nil {
				return err
			}
		}
		for i1 := len(o.OpaqueBuffer); uint64(i1) < sizeInfo[0]; i1++ {
			if err := w.WriteData(uint8(0)); err != nil {
				return err
			}
		}
	}
	// OpaqueBufferSize {in} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.OpaqueBufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SendToSAMOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// PrimaryName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_PrimaryName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.PrimaryName); err != nil {
				return err
			}
			return nil
		})
		_s_PrimaryName := func(ptr interface{}) { o.PrimaryName = *ptr.(*string) }
		if err := w.ReadPointer(&o.PrimaryName, _s_PrimaryName, _ptr_PrimaryName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ComputerName); err != nil {
			return err
		}
	}
	// Authenticator {in} (1:{alias=PNETLOGON_AUTHENTICATOR,pointer=ref}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.Authenticator == nil {
			o.Authenticator = &Authenticator{}
		}
		if err := o.Authenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// OpaqueBuffer {in} (1:{pointer=ref}*(1))(2:{alias=UCHAR}[dim:0,size_is=OpaqueBufferSize](uchar))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.OpaqueBuffer", sizeInfo[0])
		}
		o.OpaqueBuffer = make([]byte, sizeInfo[0])
		for i1 := range o.OpaqueBuffer {
			i1 := i1
			if err := w.ReadData(&o.OpaqueBuffer[i1]); err != nil {
				return err
			}
		}
	}
	// OpaqueBufferSize {in} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.OpaqueBufferSize); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SendToSAMOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SendToSAMOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ReturnAuthenticator {out} (1:{alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator != nil {
			if err := o.ReturnAuthenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SendToSAMOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ReturnAuthenticator {out} (1:{alias=PNETLOGON_AUTHENTICATOR,pointer=ref}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator == nil {
			o.ReturnAuthenticator = &Authenticator{}
		}
		if err := o.ReturnAuthenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SendToSAMRequest structure represents the NetrLogonSendToSam operation request
type SendToSAMRequest struct {
	// PrimaryName: The custom binding handle, as defined in 3.5.4.1.
	PrimaryName string `idl:"name:PrimaryName;string;pointer:unique" json:"primary_name"`
	// ComputerName: A null-terminated Unicode string that contains the NetBIOS name of
	// the client computer making the call.
	ComputerName string `idl:"name:ComputerName;string" json:"computer_name"`
	// Authenticator: A pointer to a NETLOGON_AUTHENTICATOR structure, as specified in section
	// 2.2.1.1.5, that contains the client authenticator.
	Authenticator *Authenticator `idl:"name:Authenticator" json:"authenticator"`
	// OpaqueBuffer: A buffer to be passed to the Security Account Manager (SAM) service
	// on the PDC. The buffer is encrypted on the wire.
	OpaqueBuffer []byte `idl:"name:OpaqueBuffer;size_is:(OpaqueBufferSize)" json:"opaque_buffer"`
	// OpaqueBufferSize: The size, in bytes, of the OpaqueBuffer parameter.
	OpaqueBufferSize uint32 `idl:"name:OpaqueBufferSize" json:"opaque_buffer_size"`
}

func (o *SendToSAMRequest) xxx_ToOp(ctx context.Context, op *xxx_SendToSAMOperation) *xxx_SendToSAMOperation {
	if op == nil {
		op = &xxx_SendToSAMOperation{}
	}
	if o == nil {
		return op
	}
	op.PrimaryName = o.PrimaryName
	op.ComputerName = o.ComputerName
	op.Authenticator = o.Authenticator
	op.OpaqueBuffer = o.OpaqueBuffer
	op.OpaqueBufferSize = o.OpaqueBufferSize
	return op
}

func (o *SendToSAMRequest) xxx_FromOp(ctx context.Context, op *xxx_SendToSAMOperation) {
	if o == nil {
		return
	}
	o.PrimaryName = op.PrimaryName
	o.ComputerName = op.ComputerName
	o.Authenticator = op.Authenticator
	o.OpaqueBuffer = op.OpaqueBuffer
	o.OpaqueBufferSize = op.OpaqueBufferSize
}
func (o *SendToSAMRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SendToSAMRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SendToSAMOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SendToSAMResponse structure represents the NetrLogonSendToSam operation response
type SendToSAMResponse struct {
	// ReturnAuthenticator: A pointer to a NETLOGON_AUTHENTICATOR structure, as specified
	// in section 2.2.1.1.5, that contains the server return authenticator.
	ReturnAuthenticator *Authenticator `idl:"name:ReturnAuthenticator" json:"return_authenticator"`
	// Return: The NetrLogonSendToSam return value.
	Return int32 `idl:"name:Return" json:"return"`
}

func (o *SendToSAMResponse) xxx_ToOp(ctx context.Context, op *xxx_SendToSAMOperation) *xxx_SendToSAMOperation {
	if op == nil {
		op = &xxx_SendToSAMOperation{}
	}
	if o == nil {
		return op
	}
	op.ReturnAuthenticator = o.ReturnAuthenticator
	op.Return = o.Return
	return op
}

func (o *SendToSAMResponse) xxx_FromOp(ctx context.Context, op *xxx_SendToSAMOperation) {
	if o == nil {
		return
	}
	o.ReturnAuthenticator = op.ReturnAuthenticator
	o.Return = op.Return
}
func (o *SendToSAMResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SendToSAMResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SendToSAMOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddressToSiteNamesWOperation structure represents the DsrAddressToSiteNamesW operation
type xxx_AddressToSiteNamesWOperation struct {
	ComputerName    string           `idl:"name:ComputerName;string;pointer:unique" json:"computer_name"`
	EntryCount      uint32           `idl:"name:EntryCount" json:"entry_count"`
	SocketAddresses []*SocketAddress `idl:"name:SocketAddresses;size_is:(EntryCount)" json:"socket_addresses"`
	SiteNames       *SiteNameArray   `idl:"name:SiteNames" json:"site_names"`
	Return          uint32           `idl:"name:Return" json:"return"`
}

func (o *xxx_AddressToSiteNamesWOperation) OpNum() int { return 33 }

func (o *xxx_AddressToSiteNamesWOperation) OpName() string { return "/logon/v1/DsrAddressToSiteNamesW" }

func (o *xxx_AddressToSiteNamesWOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.SocketAddresses != nil && o.EntryCount == 0 {
		o.EntryCount = uint32(len(o.SocketAddresses))
	}
	if o.EntryCount > uint32(32000) {
		return fmt.Errorf("EntryCount is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddressToSiteNamesWOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ComputerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ComputerName != "" {
			_ptr_ComputerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ComputerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ComputerName, _ptr_ComputerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// EntryCount {in} (1:{range=(0,32000), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.EntryCount); err != nil {
			return err
		}
	}
	// SocketAddresses {in} (1:{alias=PNL_SOCKET_ADDRESS}*(1))(2:{alias=NL_SOCKET_ADDRESS}[dim:0,size_is=EntryCount](struct))
	{
		dimSize1 := uint64(o.EntryCount)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.SocketAddresses {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if o.SocketAddresses[i1] != nil {
				if err := o.SocketAddresses[i1].MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&SocketAddress{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
		}
		for i1 := len(o.SocketAddresses); uint64(i1) < sizeInfo[0]; i1++ {
			if err := (&SocketAddress{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddressToSiteNamesWOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ComputerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ComputerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ComputerName); err != nil {
				return err
			}
			return nil
		})
		_s_ComputerName := func(ptr interface{}) { o.ComputerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ComputerName, _s_ComputerName, _ptr_ComputerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// EntryCount {in} (1:{range=(0,32000), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.EntryCount); err != nil {
			return err
		}
	}
	// SocketAddresses {in} (1:{alias=PNL_SOCKET_ADDRESS,pointer=ref}*(1))(2:{alias=NL_SOCKET_ADDRESS}[dim:0,size_is=EntryCount](struct))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.SocketAddresses", sizeInfo[0])
		}
		o.SocketAddresses = make([]*SocketAddress, sizeInfo[0])
		for i1 := range o.SocketAddresses {
			i1 := i1
			if o.SocketAddresses[i1] == nil {
				o.SocketAddresses[i1] = &SocketAddress{}
			}
			if err := o.SocketAddresses[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddressToSiteNamesWOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddressToSiteNamesWOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// SiteNames {out} (1:{pointer=ref}*(2))(2:{alias=PNL_SITE_NAME_ARRAY}*(1))(3:{alias=NL_SITE_NAME_ARRAY}(struct))
	{
		if o.SiteNames != nil {
			_ptr_SiteNames := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.SiteNames != nil {
					if err := o.SiteNames.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&SiteNameArray{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.SiteNames, _ptr_SiteNames); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddressToSiteNamesWOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// SiteNames {out} (1:{pointer=ref}*(2))(2:{alias=PNL_SITE_NAME_ARRAY,pointer=ref}*(1))(3:{alias=NL_SITE_NAME_ARRAY}(struct))
	{
		_ptr_SiteNames := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.SiteNames == nil {
				o.SiteNames = &SiteNameArray{}
			}
			if err := o.SiteNames.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_SiteNames := func(ptr interface{}) { o.SiteNames = *ptr.(**SiteNameArray) }
		if err := w.ReadPointer(&o.SiteNames, _s_SiteNames, _ptr_SiteNames); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddressToSiteNamesWRequest structure represents the DsrAddressToSiteNamesW operation request
type AddressToSiteNamesWRequest struct {
	// ComputerName: The custom binding handle (section 3.5.4.1) that represents the connection
	// to a domain controller.
	ComputerName string `idl:"name:ComputerName;string;pointer:unique" json:"computer_name"`
	// EntryCount: The number of socket addresses specified in SocketAddresses. The maximum
	// value for EntryCount is 32000. The limit was chosen to prevent clients from being
	// able to force large memory allocations on servers.
	EntryCount uint32 `idl:"name:EntryCount" json:"entry_count"`
	// SocketAddresses: An array of NL_SOCKET_ADDRESS structures (section 2.2.1.2.4) that
	// contains socket addresses to translate. The number of addresses specified MUST be
	// equal to EntryCount.
	SocketAddresses []*SocketAddress `idl:"name:SocketAddresses;size_is:(EntryCount)" json:"socket_addresses"`
}

func (o *AddressToSiteNamesWRequest) xxx_ToOp(ctx context.Context, op *xxx_AddressToSiteNamesWOperation) *xxx_AddressToSiteNamesWOperation {
	if op == nil {
		op = &xxx_AddressToSiteNamesWOperation{}
	}
	if o == nil {
		return op
	}
	op.ComputerName = o.ComputerName
	op.EntryCount = o.EntryCount
	op.SocketAddresses = o.SocketAddresses
	return op
}

func (o *AddressToSiteNamesWRequest) xxx_FromOp(ctx context.Context, op *xxx_AddressToSiteNamesWOperation) {
	if o == nil {
		return
	}
	o.ComputerName = op.ComputerName
	o.EntryCount = op.EntryCount
	o.SocketAddresses = op.SocketAddresses
}
func (o *AddressToSiteNamesWRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *AddressToSiteNamesWRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddressToSiteNamesWOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddressToSiteNamesWResponse structure represents the DsrAddressToSiteNamesW operation response
type AddressToSiteNamesWResponse struct {
	// SiteNames: A pointer to an NL_SITE_NAME_ARRAY structure (section 2.2.1.2.2) that
	// contains a corresponding array of site names. The number of entries returned is equal
	// to EntryCount. The fields of an entry are set to zero if the corresponding socket
	// address does not map to any site, or if the address family of the socket address
	// is not IPV4 or IPV6. The mapping of IP addresses to sites is specified in [MS-ADTS]
	// section 6.1.1.2.2.1.
	SiteNames *SiteNameArray `idl:"name:SiteNames" json:"site_names"`
	// Return: The DsrAddressToSiteNamesW return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddressToSiteNamesWResponse) xxx_ToOp(ctx context.Context, op *xxx_AddressToSiteNamesWOperation) *xxx_AddressToSiteNamesWOperation {
	if op == nil {
		op = &xxx_AddressToSiteNamesWOperation{}
	}
	if o == nil {
		return op
	}
	op.SiteNames = o.SiteNames
	op.Return = o.Return
	return op
}

func (o *AddressToSiteNamesWResponse) xxx_FromOp(ctx context.Context, op *xxx_AddressToSiteNamesWOperation) {
	if o == nil {
		return
	}
	o.SiteNames = op.SiteNames
	o.Return = op.Return
}
func (o *AddressToSiteNamesWResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *AddressToSiteNamesWResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddressToSiteNamesWOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetDCNameEx2Operation structure represents the DsrGetDcNameEx2 operation
type xxx_GetDCNameEx2Operation struct {
	ComputerName                string                 `idl:"name:ComputerName;string;pointer:unique" json:"computer_name"`
	AccountName                 string                 `idl:"name:AccountName;string;pointer:unique" json:"account_name"`
	AllowableAccountControlBits uint32                 `idl:"name:AllowableAccountControlBits" json:"allowable_account_control_bits"`
	DomainName                  string                 `idl:"name:DomainName;string;pointer:unique" json:"domain_name"`
	DomainGUID                  *dtyp.GUID             `idl:"name:DomainGuid;pointer:unique" json:"domain_guid"`
	SiteName                    string                 `idl:"name:SiteName;string;pointer:unique" json:"site_name"`
	Flags                       uint32                 `idl:"name:Flags" json:"flags"`
	DomainControllerInfo        *DomainControllerInfoW `idl:"name:DomainControllerInfo" json:"domain_controller_info"`
	Return                      uint32                 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetDCNameEx2Operation) OpNum() int { return 34 }

func (o *xxx_GetDCNameEx2Operation) OpName() string { return "/logon/v1/DsrGetDcNameEx2" }

func (o *xxx_GetDCNameEx2Operation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetDCNameEx2Operation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ComputerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ComputerName != "" {
			_ptr_ComputerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ComputerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ComputerName, _ptr_ComputerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// AccountName {in} (1:{string, pointer=unique}*(1)[dim:0,string,null](wchar))
	{
		if o.AccountName != "" {
			_ptr_AccountName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.AccountName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.AccountName, _ptr_AccountName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// AllowableAccountControlBits {in} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.AllowableAccountControlBits); err != nil {
			return err
		}
	}
	// DomainName {in} (1:{string, pointer=unique}*(1)[dim:0,string,null](wchar))
	{
		if o.DomainName != "" {
			_ptr_DomainName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.DomainName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.DomainName, _ptr_DomainName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// DomainGuid {in} (1:{pointer=unique}*(1))(2:{alias=GUID}(struct))
	{
		if o.DomainGUID != nil {
			_ptr_DomainGuid := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.DomainGUID != nil {
					if err := o.DomainGUID.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.DomainGUID, _ptr_DomainGuid); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// SiteName {in} (1:{string, pointer=unique}*(1)[dim:0,string,null](wchar))
	{
		if o.SiteName != "" {
			_ptr_SiteName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.SiteName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.SiteName, _ptr_SiteName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetDCNameEx2Operation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ComputerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ComputerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ComputerName); err != nil {
				return err
			}
			return nil
		})
		_s_ComputerName := func(ptr interface{}) { o.ComputerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ComputerName, _s_ComputerName, _ptr_ComputerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// AccountName {in} (1:{string, pointer=unique}*(1)[dim:0,string,null](wchar))
	{
		_ptr_AccountName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.AccountName); err != nil {
				return err
			}
			return nil
		})
		_s_AccountName := func(ptr interface{}) { o.AccountName = *ptr.(*string) }
		if err := w.ReadPointer(&o.AccountName, _s_AccountName, _ptr_AccountName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// AllowableAccountControlBits {in} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.AllowableAccountControlBits); err != nil {
			return err
		}
	}
	// DomainName {in} (1:{string, pointer=unique}*(1)[dim:0,string,null](wchar))
	{
		_ptr_DomainName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.DomainName); err != nil {
				return err
			}
			return nil
		})
		_s_DomainName := func(ptr interface{}) { o.DomainName = *ptr.(*string) }
		if err := w.ReadPointer(&o.DomainName, _s_DomainName, _ptr_DomainName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// DomainGuid {in} (1:{pointer=unique}*(1))(2:{alias=GUID}(struct))
	{
		_ptr_DomainGuid := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.DomainGUID == nil {
				o.DomainGUID = &dtyp.GUID{}
			}
			if err := o.DomainGUID.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_DomainGuid := func(ptr interface{}) { o.DomainGUID = *ptr.(**dtyp.GUID) }
		if err := w.ReadPointer(&o.DomainGUID, _s_DomainGuid, _ptr_DomainGuid); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// SiteName {in} (1:{string, pointer=unique}*(1)[dim:0,string,null](wchar))
	{
		_ptr_SiteName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.SiteName); err != nil {
				return err
			}
			return nil
		})
		_s_SiteName := func(ptr interface{}) { o.SiteName = *ptr.(*string) }
		if err := w.ReadPointer(&o.SiteName, _s_SiteName, _ptr_SiteName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetDCNameEx2Operation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetDCNameEx2Operation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// DomainControllerInfo {out} (1:{pointer=ref}*(2))(2:{alias=PDOMAIN_CONTROLLER_INFOW}*(1))(3:{alias=DOMAIN_CONTROLLER_INFOW}(struct))
	{
		if o.DomainControllerInfo != nil {
			_ptr_DomainControllerInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.DomainControllerInfo != nil {
					if err := o.DomainControllerInfo.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&DomainControllerInfoW{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.DomainControllerInfo, _ptr_DomainControllerInfo); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetDCNameEx2Operation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// DomainControllerInfo {out} (1:{pointer=ref}*(2))(2:{alias=PDOMAIN_CONTROLLER_INFOW,pointer=ref}*(1))(3:{alias=DOMAIN_CONTROLLER_INFOW}(struct))
	{
		_ptr_DomainControllerInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.DomainControllerInfo == nil {
				o.DomainControllerInfo = &DomainControllerInfoW{}
			}
			if err := o.DomainControllerInfo.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_DomainControllerInfo := func(ptr interface{}) { o.DomainControllerInfo = *ptr.(**DomainControllerInfoW) }
		if err := w.ReadPointer(&o.DomainControllerInfo, _s_DomainControllerInfo, _ptr_DomainControllerInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetDCNameEx2Request structure represents the DsrGetDcNameEx2 operation request
type GetDCNameEx2Request struct {
	// ComputerName: The custom binding handle defined in section 3.5.4.1.
	ComputerName string `idl:"name:ComputerName;string;pointer:unique" json:"computer_name"`
	// AccountName: A null-terminated Unicode string that contains the name of the account
	// that MUST exist and be enabled on the DC.
	AccountName string `idl:"name:AccountName;string;pointer:unique" json:"account_name"`
	// AllowableAccountControlBits: A set of bit flags that list properties of the AccountName
	// account. A flag is TRUE (or set) if its value is equal to 1. If the flag is set,
	// then the account MUST have that property; otherwise, the property is ignored. The
	// value is constructed from zero or more bit flags from the following table.
	//
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
	//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 0 | 0 | 0 | 0 | 0 | F | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | E | D | C | 0 | B | A | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//
	// Where the bits are defined as:
	//
	//	+-------+----------------------------------------------------------------------------------+
	//	|       |                                                                                  |
	//	| VALUE |                                   DESCRIPTION                                    |
	//	|       |                                                                                  |
	//	+-------+----------------------------------------------------------------------------------+
	//	+-------+----------------------------------------------------------------------------------+
	//	| A     | Account for users whose primary account is in another domain. This account       |
	//	|       | provides user access to the domain, but not to any domain that trusts the        |
	//	|       | domain.                                                                          |
	//	+-------+----------------------------------------------------------------------------------+
	//	| B     | Normal domain user account.                                                      |
	//	+-------+----------------------------------------------------------------------------------+
	//	| C     | Interdomain trust account.                                                       |
	//	+-------+----------------------------------------------------------------------------------+
	//	| D     | Computer account for a domain member.                                            |
	//	+-------+----------------------------------------------------------------------------------+
	//	| E     | Computer account for a backup domain controller (BDC).                           |
	//	+-------+----------------------------------------------------------------------------------+
	//	| F     | Computer account for a read-only domain controller (RODC).<148>                  |
	//	+-------+----------------------------------------------------------------------------------+
	AllowableAccountControlBits uint32 `idl:"name:AllowableAccountControlBits" json:"allowable_account_control_bits"`
	// DomainName: A null-terminated Unicode string that contains the domain name. If the
	// string is NULL or empty (that is, the first character in the string is the null-terminator
	// character), then the primary domain name is assumed.
	DomainName string `idl:"name:DomainName;string;pointer:unique" json:"domain_name"`
	// DomainGuid: A pointer to a GUID structure that specifies the GUID of the domain queried.
	// If DomainGuid is not NULL and the domain specified by DomainName cannot be found,
	// the DC locator attempts to locate a DC in the domain that has the GUID specified
	// by DomainGuid. This allows renamed domains to be found by their GUID.
	DomainGUID *dtyp.GUID `idl:"name:DomainGuid;pointer:unique" json:"domain_guid"`
	// SiteName: A null-terminated string that contains the name of the site in which the
	// DC MUST be located.
	SiteName string `idl:"name:SiteName;string;pointer:unique" json:"site_name"`
	// Flags: A set of bit flags that provide additional data that is used to process the
	// request. A flag is TRUE (or set) if its value is equal to 1. The value is constructed
	// from zero or more bit flags from the following table.
	//
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
	//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| S | R | 0 | 0 | 0 | 0 | 0 | 0 | W | V | U | T | Q | P | O | N | M | L | K | J | I | H | G | F | E | D | C | B | 0 | 0 | 0 | A |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//
	// Where the bits are defined as:
	//
	//	+-------+----------------------------------------------------------------------------------+
	//	|       |                                                                                  |
	//	| VALUE |                                   DESCRIPTION                                    |
	//	|       |                                                                                  |
	//	+-------+----------------------------------------------------------------------------------+
	//	+-------+----------------------------------------------------------------------------------+
	//	| A     | The server ignores any cached DC data.                                           |
	//	+-------+----------------------------------------------------------------------------------+
	//	| B     | The server returns a DC that supports directory service functions.               |
	//	+-------+----------------------------------------------------------------------------------+
	//	| C     | The server first attempts to find a DC that supports directory service           |
	//	|       | functions.                                                                       |
	//	+-------+----------------------------------------------------------------------------------+
	//	| D     | The server returns a DC that is a global catalog server for the forest.          |
	//	+-------+----------------------------------------------------------------------------------+
	//	| E     | The server returns a DC that is the PDC for the domain.                          |
	//	+-------+----------------------------------------------------------------------------------+
	//	| F     | The server uses cached DC data if available, even if the cached data is expired. |
	//	+-------+----------------------------------------------------------------------------------+
	//	| G     | The server returns a DC that has an IP (either IPv4 or IPv6) address.            |
	//	+-------+----------------------------------------------------------------------------------+
	//	| H     | The server returns a DC that is currently running the Kerberos Key Distribution  |
	//	|       | Center service.                                                                  |
	//	+-------+----------------------------------------------------------------------------------+
	//	| I     | The server returns a DC that is currently running W32Time.                       |
	//	+-------+----------------------------------------------------------------------------------+
	//	| J     | The server returns a DC that is writable.                                        |
	//	+-------+----------------------------------------------------------------------------------+
	//	| K     | The server first attempts to find a DC that is a reliable time server. If a      |
	//	|       | reliable time server is unavailable, the server returns a DC that is currently   |
	//	|       | running W32Time.                                                                 |
	//	+-------+----------------------------------------------------------------------------------+
	//	| L     | The server returns a different DC in the domain if one exists.                   |
	//	+-------+----------------------------------------------------------------------------------+
	//	| M     | The server returns an LDAP server. The server MAY return a DC.                   |
	//	+-------+----------------------------------------------------------------------------------+
	//	| N     | Specifies that the DomainName parameter is a NetBIOS name.                       |
	//	+-------+----------------------------------------------------------------------------------+
	//	| O     | Specifies that the DomainName parameter is a DNS name.                           |
	//	+-------+----------------------------------------------------------------------------------+
	//	| P     | The server attempts to find a DC in the next closest site if a DC in the closest |
	//	|       | site is not available. If a DC in the next closest site is also not available,   |
	//	|       | the server returns any available DC.<149>                                        |
	//	+-------+----------------------------------------------------------------------------------+
	//	| Q     | The server returns a DC that has a DC functional level of DS_BEHAVIOR_WIN2008 or |
	//	|       | greater, as specified in [MS-ADTS] section 6.1.4.2.                              |
	//	+-------+----------------------------------------------------------------------------------+
	//	| R     | Specifies that the names returned in the DomainControllerName and DomainName     |
	//	|       | fields of DomainControllerInfo are DNS names.                                    |
	//	+-------+----------------------------------------------------------------------------------+
	//	| S     | Specifies that the names returned in the DomainControllerName and DomainName     |
	//	|       | fields of DomainControllerInfo are NetBIOS names.                                |
	//	+-------+----------------------------------------------------------------------------------+
	//	| T     | The server returns a DC that is currently running the Active Directory Web       |
	//	|       | Service.                                                                         |
	//	+-------+----------------------------------------------------------------------------------+
	//	| U     | The server returns a DC that has a DC functional level of DS_BEHAVIOR_WIN2012 or |
	//	|       | greater, as specified in [MS-ADTS] section 6.1.4.2.                              |
	//	+-------+----------------------------------------------------------------------------------+
	//	| V     | The server returns a DC that has a DC functional level of DS_BEHAVIOR_WIN2012R2  |
	//	|       | or greater, as specified in [MS-ADTS] section 6.1.4.2.                           |
	//	+-------+----------------------------------------------------------------------------------+
	//	| W     | The server returns a DC that has a DC functional level of DS_BEHAVIOR_WIN2016 or |
	//	|       | greater, as specified in [MS-ADTS] section 6.1.4.2.                              |
	//	+-------+----------------------------------------------------------------------------------+
	Flags uint32 `idl:"name:Flags" json:"flags"`
}

func (o *GetDCNameEx2Request) xxx_ToOp(ctx context.Context, op *xxx_GetDCNameEx2Operation) *xxx_GetDCNameEx2Operation {
	if op == nil {
		op = &xxx_GetDCNameEx2Operation{}
	}
	if o == nil {
		return op
	}
	op.ComputerName = o.ComputerName
	op.AccountName = o.AccountName
	op.AllowableAccountControlBits = o.AllowableAccountControlBits
	op.DomainName = o.DomainName
	op.DomainGUID = o.DomainGUID
	op.SiteName = o.SiteName
	op.Flags = o.Flags
	return op
}

func (o *GetDCNameEx2Request) xxx_FromOp(ctx context.Context, op *xxx_GetDCNameEx2Operation) {
	if o == nil {
		return
	}
	o.ComputerName = op.ComputerName
	o.AccountName = op.AccountName
	o.AllowableAccountControlBits = op.AllowableAccountControlBits
	o.DomainName = op.DomainName
	o.DomainGUID = op.DomainGUID
	o.SiteName = op.SiteName
	o.Flags = op.Flags
}
func (o *GetDCNameEx2Request) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetDCNameEx2Request) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetDCNameEx2Operation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetDCNameEx2Response structure represents the DsrGetDcNameEx2 operation response
type GetDCNameEx2Response struct {
	// DomainControllerInfo: A pointer to a DOMAIN_CONTROLLER_INFOW structure (section 2.2.1.2.1)
	// containing data about the DC.
	DomainControllerInfo *DomainControllerInfoW `idl:"name:DomainControllerInfo" json:"domain_controller_info"`
	// Return: The DsrGetDcNameEx2 return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetDCNameEx2Response) xxx_ToOp(ctx context.Context, op *xxx_GetDCNameEx2Operation) *xxx_GetDCNameEx2Operation {
	if op == nil {
		op = &xxx_GetDCNameEx2Operation{}
	}
	if o == nil {
		return op
	}
	op.DomainControllerInfo = o.DomainControllerInfo
	op.Return = o.Return
	return op
}

func (o *GetDCNameEx2Response) xxx_FromOp(ctx context.Context, op *xxx_GetDCNameEx2Operation) {
	if o == nil {
		return
	}
	o.DomainControllerInfo = op.DomainControllerInfo
	o.Return = op.Return
}
func (o *GetDCNameEx2Response) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetDCNameEx2Response) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetDCNameEx2Operation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetTimeServiceParentDomainOperation structure represents the NetrLogonGetTimeServiceParentDomain operation
type xxx_GetTimeServiceParentDomainOperation struct {
	ServerName  string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	DomainName  string `idl:"name:DomainName;string" json:"domain_name"`
	PDCSameSite int32  `idl:"name:PdcSameSite" json:"pdc_same_site"`
	Return      uint32 `idl:"name:Return" json:"return"`
}

func (o *xxx_GetTimeServiceParentDomainOperation) OpNum() int { return 35 }

func (o *xxx_GetTimeServiceParentDomainOperation) OpName() string {
	return "/logon/v1/NetrLogonGetTimeServiceParentDomain"
}

func (o *xxx_GetTimeServiceParentDomainOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetTimeServiceParentDomainOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetTimeServiceParentDomainOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetTimeServiceParentDomainOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetTimeServiceParentDomainOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// DomainName {out} (1:{string, pointer=ref}*(2)*(1)[dim:0,string,null](wchar))
	{
		if o.DomainName != "" {
			_ptr_DomainName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.DomainName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.DomainName, _ptr_DomainName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// PdcSameSite {out} (1:{pointer=ref}*(1)(int32))
	{
		if err := w.WriteData(o.PDCSameSite); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetTimeServiceParentDomainOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// DomainName {out} (1:{string, pointer=ref}*(2)*(1)[dim:0,string,null](wchar))
	{
		_ptr_DomainName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.DomainName); err != nil {
				return err
			}
			return nil
		})
		_s_DomainName := func(ptr interface{}) { o.DomainName = *ptr.(*string) }
		if err := w.ReadPointer(&o.DomainName, _s_DomainName, _ptr_DomainName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// PdcSameSite {out} (1:{pointer=ref}*(1)(int32))
	{
		if err := w.ReadData(&o.PDCSameSite); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetTimeServiceParentDomainRequest structure represents the NetrLogonGetTimeServiceParentDomain operation request
type GetTimeServiceParentDomainRequest struct {
	// ServerName: The custom binding handle, as defined in section 3.5.4.1.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
}

func (o *GetTimeServiceParentDomainRequest) xxx_ToOp(ctx context.Context, op *xxx_GetTimeServiceParentDomainOperation) *xxx_GetTimeServiceParentDomainOperation {
	if op == nil {
		op = &xxx_GetTimeServiceParentDomainOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	return op
}

func (o *GetTimeServiceParentDomainRequest) xxx_FromOp(ctx context.Context, op *xxx_GetTimeServiceParentDomainOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
}
func (o *GetTimeServiceParentDomainRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetTimeServiceParentDomainRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetTimeServiceParentDomainOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetTimeServiceParentDomainResponse structure represents the NetrLogonGetTimeServiceParentDomain operation response
type GetTimeServiceParentDomainResponse struct {
	// DomainName: A pointer to the buffer that receives the null-terminated Unicode string
	// that contains the name of the parent domain. If the DNS domain name is available,
	// it is returned through this parameter; otherwise, the NetBIOS domain name is returned.
	DomainName string `idl:"name:DomainName;string" json:"domain_name"`
	// PdcSameSite: A pointer to the integer that receives the value that indicates whether
	// the PDC for the domain DomainName is in the same site as the server specified by
	// ServerName. The Netlogon client ignores this value if ServerName is not a domain
	// controller.
	//
	//	+---------+------------------------------------------------------------------------+
	//	|         |                                                                        |
	//	|  VALUE  |                                MEANING                                 |
	//	|         |                                                                        |
	//	+---------+------------------------------------------------------------------------+
	//	+---------+------------------------------------------------------------------------+
	//	| False 0 | The PDC is not in the same site as the server specified by ServerName. |
	//	+---------+------------------------------------------------------------------------+
	//	| True 1  | The PDC is in the same site as the server specified by ServerName.     |
	//	+---------+------------------------------------------------------------------------+
	PDCSameSite int32 `idl:"name:PdcSameSite" json:"pdc_same_site"`
	// Return: The NetrLogonGetTimeServiceParentDomain return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetTimeServiceParentDomainResponse) xxx_ToOp(ctx context.Context, op *xxx_GetTimeServiceParentDomainOperation) *xxx_GetTimeServiceParentDomainOperation {
	if op == nil {
		op = &xxx_GetTimeServiceParentDomainOperation{}
	}
	if o == nil {
		return op
	}
	op.DomainName = o.DomainName
	op.PDCSameSite = o.PDCSameSite
	op.Return = o.Return
	return op
}

func (o *GetTimeServiceParentDomainResponse) xxx_FromOp(ctx context.Context, op *xxx_GetTimeServiceParentDomainOperation) {
	if o == nil {
		return
	}
	o.DomainName = op.DomainName
	o.PDCSameSite = op.PDCSameSite
	o.Return = op.Return
}
func (o *GetTimeServiceParentDomainResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetTimeServiceParentDomainResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetTimeServiceParentDomainOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumerateTrustedDomainsExOperation structure represents the NetrEnumerateTrustedDomainsEx operation
type xxx_EnumerateTrustedDomainsExOperation struct {
	ServerName string              `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	Domains    *TrustedDomainArray `idl:"name:Domains" json:"domains"`
	Return     uint32              `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumerateTrustedDomainsExOperation) OpNum() int { return 36 }

func (o *xxx_EnumerateTrustedDomainsExOperation) OpName() string {
	return "/logon/v1/NetrEnumerateTrustedDomainsEx"
}

func (o *xxx_EnumerateTrustedDomainsExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumerateTrustedDomainsExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumerateTrustedDomainsExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumerateTrustedDomainsExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumerateTrustedDomainsExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Domains {out} (1:{alias=PNETLOGON_TRUSTED_DOMAIN_ARRAY}*(1))(2:{alias=NETLOGON_TRUSTED_DOMAIN_ARRAY}(struct))
	{
		if o.Domains != nil {
			if err := o.Domains.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&TrustedDomainArray{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumerateTrustedDomainsExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Domains {out} (1:{alias=PNETLOGON_TRUSTED_DOMAIN_ARRAY,pointer=ref}*(1))(2:{alias=NETLOGON_TRUSTED_DOMAIN_ARRAY}(struct))
	{
		if o.Domains == nil {
			o.Domains = &TrustedDomainArray{}
		}
		if err := o.Domains.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumerateTrustedDomainsExRequest structure represents the NetrEnumerateTrustedDomainsEx operation request
type EnumerateTrustedDomainsExRequest struct {
	// ServerName: The custom binding handle, as defined in section 3.5.4.1.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
}

func (o *EnumerateTrustedDomainsExRequest) xxx_ToOp(ctx context.Context, op *xxx_EnumerateTrustedDomainsExOperation) *xxx_EnumerateTrustedDomainsExOperation {
	if op == nil {
		op = &xxx_EnumerateTrustedDomainsExOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	return op
}

func (o *EnumerateTrustedDomainsExRequest) xxx_FromOp(ctx context.Context, op *xxx_EnumerateTrustedDomainsExOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
}
func (o *EnumerateTrustedDomainsExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumerateTrustedDomainsExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumerateTrustedDomainsExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumerateTrustedDomainsExResponse structure represents the NetrEnumerateTrustedDomainsEx operation response
type EnumerateTrustedDomainsExResponse struct {
	// Domains: A pointer to a NETLOGON_TRUSTED_DOMAIN_ARRAY structure, as specified in
	// section 2.2.1.6.3, that contains an array of DS_DOMAIN_TRUSTSW structures, as specified
	// in section 2.2.1.6.2, one for each trusted domain.
	Domains *TrustedDomainArray `idl:"name:Domains" json:"domains"`
	// Return: The NetrEnumerateTrustedDomainsEx return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumerateTrustedDomainsExResponse) xxx_ToOp(ctx context.Context, op *xxx_EnumerateTrustedDomainsExOperation) *xxx_EnumerateTrustedDomainsExOperation {
	if op == nil {
		op = &xxx_EnumerateTrustedDomainsExOperation{}
	}
	if o == nil {
		return op
	}
	op.Domains = o.Domains
	op.Return = o.Return
	return op
}

func (o *EnumerateTrustedDomainsExResponse) xxx_FromOp(ctx context.Context, op *xxx_EnumerateTrustedDomainsExOperation) {
	if o == nil {
		return
	}
	o.Domains = op.Domains
	o.Return = op.Return
}
func (o *EnumerateTrustedDomainsExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumerateTrustedDomainsExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumerateTrustedDomainsExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_AddressToSiteNamesExWOperation structure represents the DsrAddressToSiteNamesExW operation
type xxx_AddressToSiteNamesExWOperation struct {
	ComputerName    string           `idl:"name:ComputerName;string;pointer:unique" json:"computer_name"`
	EntryCount      uint32           `idl:"name:EntryCount" json:"entry_count"`
	SocketAddresses []*SocketAddress `idl:"name:SocketAddresses;size_is:(EntryCount)" json:"socket_addresses"`
	SiteNames       *SiteNameExArray `idl:"name:SiteNames" json:"site_names"`
	Return          uint32           `idl:"name:Return" json:"return"`
}

func (o *xxx_AddressToSiteNamesExWOperation) OpNum() int { return 37 }

func (o *xxx_AddressToSiteNamesExWOperation) OpName() string {
	return "/logon/v1/DsrAddressToSiteNamesExW"
}

func (o *xxx_AddressToSiteNamesExWOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if o.SocketAddresses != nil && o.EntryCount == 0 {
		o.EntryCount = uint32(len(o.SocketAddresses))
	}
	if o.EntryCount > uint32(32000) {
		return fmt.Errorf("EntryCount is out of range")
	}
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddressToSiteNamesExWOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ComputerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ComputerName != "" {
			_ptr_ComputerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ComputerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ComputerName, _ptr_ComputerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// EntryCount {in} (1:{range=(0,32000), alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.EntryCount); err != nil {
			return err
		}
	}
	// SocketAddresses {in} (1:{alias=PNL_SOCKET_ADDRESS}*(1))(2:{alias=NL_SOCKET_ADDRESS}[dim:0,size_is=EntryCount](struct))
	{
		dimSize1 := uint64(o.EntryCount)
		if err := w.WriteSize(dimSize1); err != nil {
			return err
		}
		sizeInfo := []uint64{
			dimSize1,
		}
		for i1 := range o.SocketAddresses {
			i1 := i1
			if uint64(i1) >= sizeInfo[0] {
				break
			}
			if o.SocketAddresses[i1] != nil {
				if err := o.SocketAddresses[i1].MarshalNDR(ctx, w); err != nil {
					return err
				}
			} else {
				if err := (&SocketAddress{}).MarshalNDR(ctx, w); err != nil {
					return err
				}
			}
		}
		for i1 := len(o.SocketAddresses); uint64(i1) < sizeInfo[0]; i1++ {
			if err := (&SocketAddress{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddressToSiteNamesExWOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ComputerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ComputerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ComputerName); err != nil {
				return err
			}
			return nil
		})
		_s_ComputerName := func(ptr interface{}) { o.ComputerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ComputerName, _s_ComputerName, _ptr_ComputerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// EntryCount {in} (1:{range=(0,32000), alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.EntryCount); err != nil {
			return err
		}
	}
	// SocketAddresses {in} (1:{alias=PNL_SOCKET_ADDRESS,pointer=ref}*(1))(2:{alias=NL_SOCKET_ADDRESS}[dim:0,size_is=EntryCount](struct))
	{
		sizeInfo := []uint64{
			0,
		}
		for sz1 := range sizeInfo {
			if err := w.ReadSize(&sizeInfo[sz1]); err != nil {
				return err
			}
		}
		if sizeInfo[0] > uint64(w.Len()) /* sanity-check */ {
			return fmt.Errorf("buffer overflow for size %d of array o.SocketAddresses", sizeInfo[0])
		}
		o.SocketAddresses = make([]*SocketAddress, sizeInfo[0])
		for i1 := range o.SocketAddresses {
			i1 := i1
			if o.SocketAddresses[i1] == nil {
				o.SocketAddresses[i1] = &SocketAddress{}
			}
			if err := o.SocketAddresses[i1].UnmarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddressToSiteNamesExWOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddressToSiteNamesExWOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// SiteNames {out} (1:{pointer=ref}*(2))(2:{alias=PNL_SITE_NAME_EX_ARRAY}*(1))(3:{alias=NL_SITE_NAME_EX_ARRAY}(struct))
	{
		if o.SiteNames != nil {
			_ptr_SiteNames := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.SiteNames != nil {
					if err := o.SiteNames.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&SiteNameExArray{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.SiteNames, _ptr_SiteNames); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_AddressToSiteNamesExWOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// SiteNames {out} (1:{pointer=ref}*(2))(2:{alias=PNL_SITE_NAME_EX_ARRAY,pointer=ref}*(1))(3:{alias=NL_SITE_NAME_EX_ARRAY}(struct))
	{
		_ptr_SiteNames := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.SiteNames == nil {
				o.SiteNames = &SiteNameExArray{}
			}
			if err := o.SiteNames.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_SiteNames := func(ptr interface{}) { o.SiteNames = *ptr.(**SiteNameExArray) }
		if err := w.ReadPointer(&o.SiteNames, _s_SiteNames, _ptr_SiteNames); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// AddressToSiteNamesExWRequest structure represents the DsrAddressToSiteNamesExW operation request
type AddressToSiteNamesExWRequest struct {
	// ComputerName: The custom binding handle (defined in section 3.5.4.1) that represents
	// the connection to a domain controller.
	ComputerName string `idl:"name:ComputerName;string;pointer:unique" json:"computer_name"`
	// EntryCount: The number of socket addresses specified in SocketAddresses. The maximum
	// value for EntryCount is 32000. To avoid large memory allocations, this number was
	// chosen as a reasonable limit for the maximum number of socket addresses that this
	// method accepts.
	EntryCount uint32 `idl:"name:EntryCount" json:"entry_count"`
	// SocketAddresses: An array of NL_SOCKET_ADDRESS structures (section 2.2.1.2.4) that
	// contains socket addresses to translate. The number of addresses specified MUST be
	// equal to EntryCount.
	SocketAddresses []*SocketAddress `idl:"name:SocketAddresses;size_is:(EntryCount)" json:"socket_addresses"`
}

func (o *AddressToSiteNamesExWRequest) xxx_ToOp(ctx context.Context, op *xxx_AddressToSiteNamesExWOperation) *xxx_AddressToSiteNamesExWOperation {
	if op == nil {
		op = &xxx_AddressToSiteNamesExWOperation{}
	}
	if o == nil {
		return op
	}
	op.ComputerName = o.ComputerName
	op.EntryCount = o.EntryCount
	op.SocketAddresses = o.SocketAddresses
	return op
}

func (o *AddressToSiteNamesExWRequest) xxx_FromOp(ctx context.Context, op *xxx_AddressToSiteNamesExWOperation) {
	if o == nil {
		return
	}
	o.ComputerName = op.ComputerName
	o.EntryCount = op.EntryCount
	o.SocketAddresses = op.SocketAddresses
}
func (o *AddressToSiteNamesExWRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *AddressToSiteNamesExWRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddressToSiteNamesExWOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// AddressToSiteNamesExWResponse structure represents the DsrAddressToSiteNamesExW operation response
type AddressToSiteNamesExWResponse struct {
	// SiteNames: A pointer to an NL_SITE_NAME_EX_ARRAY structure (section 2.2.1.2.3) that
	// contains an array of site names and an array of subnet names that correspond to socket
	// addresses in SocketAddresses. The number of entries returned is equal to EntryCount.
	// The fields of an entry are set to zero if the corresponding socket address does not
	// map to any site, or if the address family of the socket address is not IPV4 or IPV6.
	// The mapping of IP addresses to sites is specified in [MS-ADTS] section 6.1.1.2.2.1.
	SiteNames *SiteNameExArray `idl:"name:SiteNames" json:"site_names"`
	// Return: The DsrAddressToSiteNamesExW return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *AddressToSiteNamesExWResponse) xxx_ToOp(ctx context.Context, op *xxx_AddressToSiteNamesExWOperation) *xxx_AddressToSiteNamesExWOperation {
	if op == nil {
		op = &xxx_AddressToSiteNamesExWOperation{}
	}
	if o == nil {
		return op
	}
	op.SiteNames = o.SiteNames
	op.Return = o.Return
	return op
}

func (o *AddressToSiteNamesExWResponse) xxx_FromOp(ctx context.Context, op *xxx_AddressToSiteNamesExWOperation) {
	if o == nil {
		return
	}
	o.SiteNames = op.SiteNames
	o.Return = op.Return
}
func (o *AddressToSiteNamesExWResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *AddressToSiteNamesExWResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_AddressToSiteNamesExWOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetDCSiteCoverageWOperation structure represents the DsrGetDcSiteCoverageW operation
type xxx_GetDCSiteCoverageWOperation struct {
	ServerName string         `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	SiteNames  *SiteNameArray `idl:"name:SiteNames" json:"site_names"`
	Return     uint32         `idl:"name:Return" json:"return"`
}

func (o *xxx_GetDCSiteCoverageWOperation) OpNum() int { return 38 }

func (o *xxx_GetDCSiteCoverageWOperation) OpName() string { return "/logon/v1/DsrGetDcSiteCoverageW" }

func (o *xxx_GetDCSiteCoverageWOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetDCSiteCoverageWOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetDCSiteCoverageWOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetDCSiteCoverageWOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetDCSiteCoverageWOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// SiteNames {out} (1:{pointer=ref}*(2))(2:{alias=PNL_SITE_NAME_ARRAY}*(1))(3:{alias=NL_SITE_NAME_ARRAY}(struct))
	{
		if o.SiteNames != nil {
			_ptr_SiteNames := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.SiteNames != nil {
					if err := o.SiteNames.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&SiteNameArray{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.SiteNames, _ptr_SiteNames); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetDCSiteCoverageWOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// SiteNames {out} (1:{pointer=ref}*(2))(2:{alias=PNL_SITE_NAME_ARRAY,pointer=ref}*(1))(3:{alias=NL_SITE_NAME_ARRAY}(struct))
	{
		_ptr_SiteNames := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.SiteNames == nil {
				o.SiteNames = &SiteNameArray{}
			}
			if err := o.SiteNames.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_SiteNames := func(ptr interface{}) { o.SiteNames = *ptr.(**SiteNameArray) }
		if err := w.ReadPointer(&o.SiteNames, _s_SiteNames, _ptr_SiteNames); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetDCSiteCoverageWRequest structure represents the DsrGetDcSiteCoverageW operation request
type GetDCSiteCoverageWRequest struct {
	// ServerName: The custom binding handle (defined in section 3.5.4.1) that represents
	// the connection to a DC.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
}

func (o *GetDCSiteCoverageWRequest) xxx_ToOp(ctx context.Context, op *xxx_GetDCSiteCoverageWOperation) *xxx_GetDCSiteCoverageWOperation {
	if op == nil {
		op = &xxx_GetDCSiteCoverageWOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	return op
}

func (o *GetDCSiteCoverageWRequest) xxx_FromOp(ctx context.Context, op *xxx_GetDCSiteCoverageWOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
}
func (o *GetDCSiteCoverageWRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetDCSiteCoverageWRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetDCSiteCoverageWOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetDCSiteCoverageWResponse structure represents the DsrGetDcSiteCoverageW operation response
type GetDCSiteCoverageWResponse struct {
	// SiteNames: A pointer to an NL_SITE_NAME_ARRAY structure (section 2.2.1.2.2) that
	// contains an array of site name strings.
	SiteNames *SiteNameArray `idl:"name:SiteNames" json:"site_names"`
	// Return: The DsrGetDcSiteCoverageW return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetDCSiteCoverageWResponse) xxx_ToOp(ctx context.Context, op *xxx_GetDCSiteCoverageWOperation) *xxx_GetDCSiteCoverageWOperation {
	if op == nil {
		op = &xxx_GetDCSiteCoverageWOperation{}
	}
	if o == nil {
		return op
	}
	op.SiteNames = o.SiteNames
	op.Return = o.Return
	return op
}

func (o *GetDCSiteCoverageWResponse) xxx_FromOp(ctx context.Context, op *xxx_GetDCSiteCoverageWOperation) {
	if o == nil {
		return
	}
	o.SiteNames = op.SiteNames
	o.Return = op.Return
}
func (o *GetDCSiteCoverageWResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetDCSiteCoverageWResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetDCSiteCoverageWOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SAMLogonExOperation structure represents the NetrLogonSamLogonEx operation
type xxx_SAMLogonExOperation struct {
	LogonServer           string              `idl:"name:LogonServer;string;pointer:unique" json:"logon_server"`
	ComputerName          string              `idl:"name:ComputerName;string;pointer:unique" json:"computer_name"`
	LogonLevel            LogonInfoClass      `idl:"name:LogonLevel" json:"logon_level"`
	LogonInformation      *Level              `idl:"name:LogonInformation;switch_is:LogonLevel" json:"logon_information"`
	ValidationLevel       ValidationInfoClass `idl:"name:ValidationLevel" json:"validation_level"`
	ValidationInformation *Validation         `idl:"name:ValidationInformation;switch_is:ValidationLevel" json:"validation_information"`
	Authoritative         uint8               `idl:"name:Authoritative" json:"authoritative"`
	ExtraFlags            uint32              `idl:"name:ExtraFlags" json:"extra_flags"`
	Return                int32               `idl:"name:Return" json:"return"`
}

func (o *xxx_SAMLogonExOperation) OpNum() int { return 39 }

func (o *xxx_SAMLogonExOperation) OpName() string { return "/logon/v1/NetrLogonSamLogonEx" }

func (o *xxx_SAMLogonExOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SAMLogonExOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// LogonServer {in} (1:{string, pointer=unique}*(1)[dim:0,string,null](wchar))
	{
		if o.LogonServer != "" {
			_ptr_LogonServer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.LogonServer); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.LogonServer, _ptr_LogonServer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=unique}*(1)[dim:0,string,null](wchar))
	{
		if o.ComputerName != "" {
			_ptr_ComputerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ComputerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ComputerName, _ptr_ComputerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// LogonLevel {in} (1:{alias=NETLOGON_LOGON_INFO_CLASS}(enum))
	{
		if err := w.WriteEnum(uint16(o.LogonLevel)); err != nil {
			return err
		}
	}
	// LogonInformation {in} (1:{switch_type={alias=NETLOGON_LOGON_INFO_CLASS}(enum), alias=PNETLOGON_LEVEL}*(1))(2:{switch_type={alias=NETLOGON_LOGON_INFO_CLASS}(enum), alias=NETLOGON_LEVEL}(union))
	{
		_swLogonInformation := uint16(o.LogonLevel)
		if o.LogonInformation != nil {
			if err := o.LogonInformation.MarshalUnionNDR(ctx, w, _swLogonInformation); err != nil {
				return err
			}
		} else {
			if err := (&Level{}).MarshalUnionNDR(ctx, w, _swLogonInformation); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ValidationLevel {in} (1:{alias=NETLOGON_VALIDATION_INFO_CLASS}(enum))
	{
		if err := w.WriteEnum(uint16(o.ValidationLevel)); err != nil {
			return err
		}
	}
	// ExtraFlags {in, out} (1:{pointer=ref}*(1))(2:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.ExtraFlags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SAMLogonExOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// LogonServer {in} (1:{string, pointer=unique}*(1)[dim:0,string,null](wchar))
	{
		_ptr_LogonServer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.LogonServer); err != nil {
				return err
			}
			return nil
		})
		_s_LogonServer := func(ptr interface{}) { o.LogonServer = *ptr.(*string) }
		if err := w.ReadPointer(&o.LogonServer, _s_LogonServer, _ptr_LogonServer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=unique}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ComputerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ComputerName); err != nil {
				return err
			}
			return nil
		})
		_s_ComputerName := func(ptr interface{}) { o.ComputerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ComputerName, _s_ComputerName, _ptr_ComputerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// LogonLevel {in} (1:{alias=NETLOGON_LOGON_INFO_CLASS}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.LogonLevel)); err != nil {
			return err
		}
	}
	// LogonInformation {in} (1:{switch_type={alias=NETLOGON_LOGON_INFO_CLASS}(enum), alias=PNETLOGON_LEVEL,pointer=ref}*(1))(2:{switch_type={alias=NETLOGON_LOGON_INFO_CLASS}(enum), alias=NETLOGON_LEVEL}(union))
	{
		if o.LogonInformation == nil {
			o.LogonInformation = &Level{}
		}
		_swLogonInformation := uint16(o.LogonLevel)
		if err := o.LogonInformation.UnmarshalUnionNDR(ctx, w, _swLogonInformation); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ValidationLevel {in} (1:{alias=NETLOGON_VALIDATION_INFO_CLASS}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.ValidationLevel)); err != nil {
			return err
		}
	}
	// ExtraFlags {in, out} (1:{pointer=ref}*(1))(2:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.ExtraFlags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SAMLogonExOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SAMLogonExOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ValidationInformation {out} (1:{switch_type={}(enum), alias=PNETLOGON_VALIDATION}*(1))(2:{switch_type={}(enum), alias=NETLOGON_VALIDATION}(union))
	{
		_swValidationInformation := uint16(o.ValidationLevel)
		if o.ValidationInformation != nil {
			if err := o.ValidationInformation.MarshalUnionNDR(ctx, w, _swValidationInformation); err != nil {
				return err
			}
		} else {
			if err := (&Validation{}).MarshalUnionNDR(ctx, w, _swValidationInformation); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Authoritative {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}(uchar))
	{
		if err := w.WriteData(o.Authoritative); err != nil {
			return err
		}
	}
	// ExtraFlags {in, out} (1:{pointer=ref}*(1))(2:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.ExtraFlags); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SAMLogonExOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ValidationInformation {out} (1:{switch_type={}(enum), alias=PNETLOGON_VALIDATION,pointer=ref}*(1))(2:{switch_type={}(enum), alias=NETLOGON_VALIDATION}(union))
	{
		if o.ValidationInformation == nil {
			o.ValidationInformation = &Validation{}
		}
		_swValidationInformation := uint16(o.ValidationLevel)
		if err := o.ValidationInformation.UnmarshalUnionNDR(ctx, w, _swValidationInformation); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Authoritative {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}(uchar))
	{
		if err := w.ReadData(&o.Authoritative); err != nil {
			return err
		}
	}
	// ExtraFlags {in, out} (1:{pointer=ref}*(1))(2:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.ExtraFlags); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SAMLogonExRequest structure represents the NetrLogonSamLogonEx operation request
type SAMLogonExRequest struct {
	// LogonServer: The null-terminated Unicode string that contains the NetBIOS name of
	// the server that will handle the logon request.
	LogonServer string `idl:"name:LogonServer;string;pointer:unique" json:"logon_server"`
	// ComputerName: The null-terminated Unicode string that contains the NetBIOS name of
	// the client computer sending the logon request.
	ComputerName string `idl:"name:ComputerName;string;pointer:unique" json:"computer_name"`
	// LogonLevel: A NETLOGON_LOGON_INFO_CLASS enumerated type, as specified in section
	// 2.2.1.4.16, that specifies the type of the logon information passed in the LogonInformation
	// parameter.
	LogonLevel LogonInfoClass `idl:"name:LogonLevel" json:"logon_level"`
	// LogonInformation: A pointer to a NETLOGON_LEVEL structure, as specified in section
	// 2.2.1.4.6, that describes the logon request information.
	LogonInformation *Level `idl:"name:LogonInformation;switch_is:LogonLevel" json:"logon_information"`
	// ValidationLevel: A NETLOGON_VALIDATION_INFO_CLASS enumerated type, as specified in
	// section 2.2.1.4.17, that contains the validation level requested by the client.
	ValidationLevel ValidationInfoClass `idl:"name:ValidationLevel" json:"validation_level"`
	// ExtraFlags: A pointer to a set of bit flags that specify delivery settings. A flag
	// is TRUE (or set) if its value is equal to 1. Output flags MUST be the same as input.
	// The value is constructed from zero or more bit flags from the following table.
	//
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
	//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | D | C | B | A |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//
	// Where the bits SHOULD<201> be defined as:
	//
	//	+-------+----------------------------------------------------------------------------------+
	//	|       |                                                                                  |
	//	| VALUE |                                   DESCRIPTION                                    |
	//	|       |                                                                                  |
	//	+-------+----------------------------------------------------------------------------------+
	//	+-------+----------------------------------------------------------------------------------+
	//	| A     | Request MUST be passed to the domain controller at the root of the forest.       |
	//	+-------+----------------------------------------------------------------------------------+
	//	| B     | Request MUST be passed to the DC at the end of the first hop over a cross-forest |
	//	|       | trust.                                                                           |
	//	+-------+----------------------------------------------------------------------------------+
	//	| C     | Request was passed by an RODC to a DC in a different domain.                     |
	//	+-------+----------------------------------------------------------------------------------+
	//	| D     | Request is an NTLM authentication package request passed by an RODC.             |
	//	+-------+----------------------------------------------------------------------------------+
	ExtraFlags uint32 `idl:"name:ExtraFlags" json:"extra_flags"`
}

func (o *SAMLogonExRequest) xxx_ToOp(ctx context.Context, op *xxx_SAMLogonExOperation) *xxx_SAMLogonExOperation {
	if op == nil {
		op = &xxx_SAMLogonExOperation{}
	}
	if o == nil {
		return op
	}
	op.LogonServer = o.LogonServer
	op.ComputerName = o.ComputerName
	op.LogonLevel = o.LogonLevel
	op.LogonInformation = o.LogonInformation
	op.ValidationLevel = o.ValidationLevel
	op.ExtraFlags = o.ExtraFlags
	return op
}

func (o *SAMLogonExRequest) xxx_FromOp(ctx context.Context, op *xxx_SAMLogonExOperation) {
	if o == nil {
		return
	}
	o.LogonServer = op.LogonServer
	o.ComputerName = op.ComputerName
	o.LogonLevel = op.LogonLevel
	o.LogonInformation = op.LogonInformation
	o.ValidationLevel = op.ValidationLevel
	o.ExtraFlags = op.ExtraFlags
}
func (o *SAMLogonExRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SAMLogonExRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SAMLogonExOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SAMLogonExResponse structure represents the NetrLogonSamLogonEx operation response
type SAMLogonExResponse struct {
	// XXX: ValidationLevel is an implicit input depedency for output parameters
	ValidationLevel ValidationInfoClass `idl:"name:ValidationLevel" json:"validation_level"`

	// ValidationInformation: A pointer to a NETLOGON_VALIDATION structure, as specified
	// in section 2.2.1.4.14, that describes the user validation information returned to
	// the client. The type of the NETLOGON_VALIDATION used is determined by the value of
	// the ValidationLevel parameter.
	ValidationInformation *Validation `idl:"name:ValidationInformation;switch_is:ValidationLevel" json:"validation_information"`
	// Authoritative: A pointer to a char value that represents a Boolean condition. FALSE
	// is indicated by the value 0x00, and TRUE SHOULD<200> be indicated by the value 0x01
	// and MAY also be indicated by any nonzero value.
	Authoritative uint8 `idl:"name:Authoritative" json:"authoritative"`
	// ExtraFlags: A pointer to a set of bit flags that specify delivery settings. A flag
	// is TRUE (or set) if its value is equal to 1. Output flags MUST be the same as input.
	// The value is constructed from zero or more bit flags from the following table.
	//
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
	//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | D | C | B | A |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//
	// Where the bits SHOULD<201> be defined as:
	//
	//	+-------+----------------------------------------------------------------------------------+
	//	|       |                                                                                  |
	//	| VALUE |                                   DESCRIPTION                                    |
	//	|       |                                                                                  |
	//	+-------+----------------------------------------------------------------------------------+
	//	+-------+----------------------------------------------------------------------------------+
	//	| A     | Request MUST be passed to the domain controller at the root of the forest.       |
	//	+-------+----------------------------------------------------------------------------------+
	//	| B     | Request MUST be passed to the DC at the end of the first hop over a cross-forest |
	//	|       | trust.                                                                           |
	//	+-------+----------------------------------------------------------------------------------+
	//	| C     | Request was passed by an RODC to a DC in a different domain.                     |
	//	+-------+----------------------------------------------------------------------------------+
	//	| D     | Request is an NTLM authentication package request passed by an RODC.             |
	//	+-------+----------------------------------------------------------------------------------+
	ExtraFlags uint32 `idl:"name:ExtraFlags" json:"extra_flags"`
	// Return: The NetrLogonSamLogonEx return value.
	Return int32 `idl:"name:Return" json:"return"`
}

func (o *SAMLogonExResponse) xxx_ToOp(ctx context.Context, op *xxx_SAMLogonExOperation) *xxx_SAMLogonExOperation {
	if op == nil {
		op = &xxx_SAMLogonExOperation{}
	}
	if o == nil {
		return op
	}
	// XXX: implicit input dependencies for output parameters
	if op.ValidationLevel == ValidationInfoClass(0) {
		op.ValidationLevel = o.ValidationLevel
	}

	op.ValidationInformation = o.ValidationInformation
	op.Authoritative = o.Authoritative
	op.ExtraFlags = o.ExtraFlags
	op.Return = o.Return
	return op
}

func (o *SAMLogonExResponse) xxx_FromOp(ctx context.Context, op *xxx_SAMLogonExOperation) {
	if o == nil {
		return
	}
	// XXX: implicit input dependencies for output parameters
	o.ValidationLevel = op.ValidationLevel

	o.ValidationInformation = op.ValidationInformation
	o.Authoritative = op.Authoritative
	o.ExtraFlags = op.ExtraFlags
	o.Return = op.Return
}
func (o *SAMLogonExResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SAMLogonExResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SAMLogonExOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_EnumerateDomainTrustsOperation structure represents the DsrEnumerateDomainTrusts operation
type xxx_EnumerateDomainTrustsOperation struct {
	ServerName string              `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	Flags      uint32              `idl:"name:Flags" json:"flags"`
	Domains    *TrustedDomainArray `idl:"name:Domains" json:"domains"`
	Return     uint32              `idl:"name:Return" json:"return"`
}

func (o *xxx_EnumerateDomainTrustsOperation) OpNum() int { return 40 }

func (o *xxx_EnumerateDomainTrustsOperation) OpName() string {
	return "/logon/v1/DsrEnumerateDomainTrusts"
}

func (o *xxx_EnumerateDomainTrustsOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumerateDomainTrustsOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumerateDomainTrustsOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumerateDomainTrustsOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumerateDomainTrustsOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Domains {out} (1:{alias=PNETLOGON_TRUSTED_DOMAIN_ARRAY}*(1))(2:{alias=NETLOGON_TRUSTED_DOMAIN_ARRAY}(struct))
	{
		if o.Domains != nil {
			if err := o.Domains.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&TrustedDomainArray{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_EnumerateDomainTrustsOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Domains {out} (1:{alias=PNETLOGON_TRUSTED_DOMAIN_ARRAY,pointer=ref}*(1))(2:{alias=NETLOGON_TRUSTED_DOMAIN_ARRAY}(struct))
	{
		if o.Domains == nil {
			o.Domains = &TrustedDomainArray{}
		}
		if err := o.Domains.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// EnumerateDomainTrustsRequest structure represents the DsrEnumerateDomainTrusts operation request
type EnumerateDomainTrustsRequest struct {
	// ServerName: The custom binding handle, as defined in section 3.5.4.1.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// Flags: A set of bit flags that specify properties that MUST be true for a domain
	// trust to be part of the returned domain name list. A flag is TRUE (or set) if its
	// value is equal to 1. Flags MUST contain one or more of the following bits.
	//
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
	//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | F | E | D | C | B | A |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//
	// Where the bits are defined as:
	//
	//	+-------+-----------------------------------------------------+
	//	|       |                                                     |
	//	| VALUE |                     DESCRIPTION                     |
	//	|       |                                                     |
	//	+-------+-----------------------------------------------------+
	//	+-------+-----------------------------------------------------+
	//	| A     | Domain is a member of the forest.                   |
	//	+-------+-----------------------------------------------------+
	//	| B     | Domain is directly trusted by this domain.          |
	//	+-------+-----------------------------------------------------+
	//	| C     | Domain is the root of a domain tree in the forest.  |
	//	+-------+-----------------------------------------------------+
	//	| D     | Domain is the primary domain of the queried server. |
	//	+-------+-----------------------------------------------------+
	//	| E     | Primary domain is running in native mode.           |
	//	+-------+-----------------------------------------------------+
	//	| F     | Domain directly trusts this domain.                 |
	//	+-------+-----------------------------------------------------+
	Flags uint32 `idl:"name:Flags" json:"flags"`
}

func (o *EnumerateDomainTrustsRequest) xxx_ToOp(ctx context.Context, op *xxx_EnumerateDomainTrustsOperation) *xxx_EnumerateDomainTrustsOperation {
	if op == nil {
		op = &xxx_EnumerateDomainTrustsOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.Flags = o.Flags
	return op
}

func (o *EnumerateDomainTrustsRequest) xxx_FromOp(ctx context.Context, op *xxx_EnumerateDomainTrustsOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.Flags = op.Flags
}
func (o *EnumerateDomainTrustsRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *EnumerateDomainTrustsRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumerateDomainTrustsOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// EnumerateDomainTrustsResponse structure represents the DsrEnumerateDomainTrusts operation response
type EnumerateDomainTrustsResponse struct {
	// Domains: A pointer to a NETLOGON_TRUSTED_DOMAIN_ARRAY structure, as specified in
	// section 2.2.1.6.3, that contains a list of trusted domains.
	Domains *TrustedDomainArray `idl:"name:Domains" json:"domains"`
	// Return: The DsrEnumerateDomainTrusts return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *EnumerateDomainTrustsResponse) xxx_ToOp(ctx context.Context, op *xxx_EnumerateDomainTrustsOperation) *xxx_EnumerateDomainTrustsOperation {
	if op == nil {
		op = &xxx_EnumerateDomainTrustsOperation{}
	}
	if o == nil {
		return op
	}
	op.Domains = o.Domains
	op.Return = o.Return
	return op
}

func (o *EnumerateDomainTrustsResponse) xxx_FromOp(ctx context.Context, op *xxx_EnumerateDomainTrustsOperation) {
	if o == nil {
		return
	}
	o.Domains = op.Domains
	o.Return = op.Return
}
func (o *EnumerateDomainTrustsResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *EnumerateDomainTrustsResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_EnumerateDomainTrustsOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_DeregisterDNSHostRecordsOperation structure represents the DsrDeregisterDnsHostRecords operation
type xxx_DeregisterDNSHostRecordsOperation struct {
	ServerName    string     `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	DNSDomainName string     `idl:"name:DnsDomainName;string;pointer:unique" json:"dns_domain_name"`
	DomainGUID    *dtyp.GUID `idl:"name:DomainGuid;pointer:unique" json:"domain_guid"`
	DSAGUID       *dtyp.GUID `idl:"name:DsaGuid;pointer:unique" json:"dsa_guid"`
	DNSHostName   string     `idl:"name:DnsHostName;string" json:"dns_host_name"`
	Return        uint32     `idl:"name:Return" json:"return"`
}

func (o *xxx_DeregisterDNSHostRecordsOperation) OpNum() int { return 41 }

func (o *xxx_DeregisterDNSHostRecordsOperation) OpName() string {
	return "/logon/v1/DsrDeregisterDnsHostRecords"
}

func (o *xxx_DeregisterDNSHostRecordsOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeregisterDNSHostRecordsOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// DnsDomainName {in} (1:{string, pointer=unique}*(1)[dim:0,string,null](wchar))
	{
		if o.DNSDomainName != "" {
			_ptr_DnsDomainName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.DNSDomainName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.DNSDomainName, _ptr_DnsDomainName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// DomainGuid {in} (1:{pointer=unique}*(1))(2:{alias=GUID}(struct))
	{
		if o.DomainGUID != nil {
			_ptr_DomainGuid := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.DomainGUID != nil {
					if err := o.DomainGUID.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.DomainGUID, _ptr_DomainGuid); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// DsaGuid {in} (1:{pointer=unique}*(1))(2:{alias=GUID}(struct))
	{
		if o.DSAGUID != nil {
			_ptr_DsaGuid := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.DSAGUID != nil {
					if err := o.DSAGUID.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&dtyp.GUID{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.DSAGUID, _ptr_DsaGuid); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// DnsHostName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.DNSHostName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeregisterDNSHostRecordsOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// DnsDomainName {in} (1:{string, pointer=unique}*(1)[dim:0,string,null](wchar))
	{
		_ptr_DnsDomainName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.DNSDomainName); err != nil {
				return err
			}
			return nil
		})
		_s_DnsDomainName := func(ptr interface{}) { o.DNSDomainName = *ptr.(*string) }
		if err := w.ReadPointer(&o.DNSDomainName, _s_DnsDomainName, _ptr_DnsDomainName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// DomainGuid {in} (1:{pointer=unique}*(1))(2:{alias=GUID}(struct))
	{
		_ptr_DomainGuid := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.DomainGUID == nil {
				o.DomainGUID = &dtyp.GUID{}
			}
			if err := o.DomainGUID.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_DomainGuid := func(ptr interface{}) { o.DomainGUID = *ptr.(**dtyp.GUID) }
		if err := w.ReadPointer(&o.DomainGUID, _s_DomainGuid, _ptr_DomainGuid); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// DsaGuid {in} (1:{pointer=unique}*(1))(2:{alias=GUID}(struct))
	{
		_ptr_DsaGuid := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.DSAGUID == nil {
				o.DSAGUID = &dtyp.GUID{}
			}
			if err := o.DSAGUID.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_DsaGuid := func(ptr interface{}) { o.DSAGUID = *ptr.(**dtyp.GUID) }
		if err := w.ReadPointer(&o.DSAGUID, _s_DsaGuid, _ptr_DsaGuid); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// DnsHostName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.DNSHostName); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeregisterDNSHostRecordsOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeregisterDNSHostRecordsOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_DeregisterDNSHostRecordsOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// DeregisterDNSHostRecordsRequest structure represents the DsrDeregisterDnsHostRecords operation request
type DeregisterDNSHostRecordsRequest struct {
	// ServerName: The custom binding handle, as defined in section 3.5.4.1, that represents
	// the connection to the DC.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// DnsDomainName: A null-terminated Unicode string that specifies the FQDN.
	DNSDomainName string `idl:"name:DnsDomainName;string;pointer:unique" json:"dns_domain_name"`
	// DomainGuid: A pointer to the domain GUID. If the value is not NULL, the DNS SRV record
	// of type _ldap._tcp.DomainGuid.domains._msdcs.DnsDomainName is also deregistered.
	DomainGUID *dtyp.GUID `idl:"name:DomainGuid;pointer:unique" json:"domain_guid"`
	// DsaGuid: A pointer to the objectGUID of the DC's NTDSDSA object. For details about
	// the NTDSDSA object, see [MS-ADTS] section 6.1.1.2.2.1.2.1.1. If the value is not
	// NULL, the CNAME [RFC1035] record of the domain in the form of DsaGuid._msdcs.DnsDomainName
	// is also deregistered.
	DSAGUID *dtyp.GUID `idl:"name:DsaGuid;pointer:unique" json:"dsa_guid"`
	// DnsHostName: A null-terminated Unicode string that specifies the FQDN of the DC whose
	// records are being deregistered.
	DNSHostName string `idl:"name:DnsHostName;string" json:"dns_host_name"`
}

func (o *DeregisterDNSHostRecordsRequest) xxx_ToOp(ctx context.Context, op *xxx_DeregisterDNSHostRecordsOperation) *xxx_DeregisterDNSHostRecordsOperation {
	if op == nil {
		op = &xxx_DeregisterDNSHostRecordsOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.DNSDomainName = o.DNSDomainName
	op.DomainGUID = o.DomainGUID
	op.DSAGUID = o.DSAGUID
	op.DNSHostName = o.DNSHostName
	return op
}

func (o *DeregisterDNSHostRecordsRequest) xxx_FromOp(ctx context.Context, op *xxx_DeregisterDNSHostRecordsOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.DNSDomainName = op.DNSDomainName
	o.DomainGUID = op.DomainGUID
	o.DSAGUID = op.DSAGUID
	o.DNSHostName = op.DNSHostName
}
func (o *DeregisterDNSHostRecordsRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *DeregisterDNSHostRecordsRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeregisterDNSHostRecordsOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// DeregisterDNSHostRecordsResponse structure represents the DsrDeregisterDnsHostRecords operation response
type DeregisterDNSHostRecordsResponse struct {
	// Return: The DsrDeregisterDnsHostRecords return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *DeregisterDNSHostRecordsResponse) xxx_ToOp(ctx context.Context, op *xxx_DeregisterDNSHostRecordsOperation) *xxx_DeregisterDNSHostRecordsOperation {
	if op == nil {
		op = &xxx_DeregisterDNSHostRecordsOperation{}
	}
	if o == nil {
		return op
	}
	op.Return = o.Return
	return op
}

func (o *DeregisterDNSHostRecordsResponse) xxx_FromOp(ctx context.Context, op *xxx_DeregisterDNSHostRecordsOperation) {
	if o == nil {
		return
	}
	o.Return = op.Return
}
func (o *DeregisterDNSHostRecordsResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *DeregisterDNSHostRecordsResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_DeregisterDNSHostRecordsOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_TrustPasswordsGetOperation structure represents the NetrServerTrustPasswordsGet operation
type xxx_TrustPasswordsGetOperation struct {
	TrustedDCName           string                  `idl:"name:TrustedDcName;string;pointer:unique" json:"trusted_dc_name"`
	AccountName             string                  `idl:"name:AccountName;string" json:"account_name"`
	SecureChannelType       SecureChannelType       `idl:"name:SecureChannelType" json:"secure_channel_type"`
	ComputerName            string                  `idl:"name:ComputerName;string" json:"computer_name"`
	Authenticator           *Authenticator          `idl:"name:Authenticator" json:"authenticator"`
	ReturnAuthenticator     *Authenticator          `idl:"name:ReturnAuthenticator" json:"return_authenticator"`
	EncryptedNewOWFPassword *EncryptedNTOWFPassword `idl:"name:EncryptedNewOwfPassword" json:"encrypted_new_owf_password"`
	EncryptedOldOWFPassword *EncryptedNTOWFPassword `idl:"name:EncryptedOldOwfPassword" json:"encrypted_old_owf_password"`
	Return                  int32                   `idl:"name:Return" json:"return"`
}

func (o *xxx_TrustPasswordsGetOperation) OpNum() int { return 42 }

func (o *xxx_TrustPasswordsGetOperation) OpName() string {
	return "/logon/v1/NetrServerTrustPasswordsGet"
}

func (o *xxx_TrustPasswordsGetOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_TrustPasswordsGetOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// TrustedDcName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.TrustedDCName != "" {
			_ptr_TrustedDcName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.TrustedDCName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.TrustedDCName, _ptr_TrustedDcName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// AccountName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.AccountName); err != nil {
			return err
		}
	}
	// SecureChannelType {in} (1:{alias=NETLOGON_SECURE_CHANNEL_TYPE}(enum))
	{
		if err := w.WriteEnum(uint16(o.SecureChannelType)); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ComputerName); err != nil {
			return err
		}
	}
	// Authenticator {in} (1:{alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.Authenticator != nil {
			if err := o.Authenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_TrustPasswordsGetOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// TrustedDcName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_TrustedDcName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.TrustedDCName); err != nil {
				return err
			}
			return nil
		})
		_s_TrustedDcName := func(ptr interface{}) { o.TrustedDCName = *ptr.(*string) }
		if err := w.ReadPointer(&o.TrustedDCName, _s_TrustedDcName, _ptr_TrustedDcName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// AccountName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.AccountName); err != nil {
			return err
		}
	}
	// SecureChannelType {in} (1:{alias=NETLOGON_SECURE_CHANNEL_TYPE}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.SecureChannelType)); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ComputerName); err != nil {
			return err
		}
	}
	// Authenticator {in} (1:{alias=PNETLOGON_AUTHENTICATOR,pointer=ref}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.Authenticator == nil {
			o.Authenticator = &Authenticator{}
		}
		if err := o.Authenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_TrustPasswordsGetOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_TrustPasswordsGetOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ReturnAuthenticator {out} (1:{alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator != nil {
			if err := o.ReturnAuthenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// EncryptedNewOwfPassword {out} (1:{alias=PENCRYPTED_NT_OWF_PASSWORD}*(1))(2:{alias=ENCRYPTED_NT_OWF_PASSWORD}(struct))
	{
		if o.EncryptedNewOWFPassword != nil {
			if err := o.EncryptedNewOWFPassword.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&EncryptedNTOWFPassword{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// EncryptedOldOwfPassword {out} (1:{alias=PENCRYPTED_NT_OWF_PASSWORD}*(1))(2:{alias=ENCRYPTED_NT_OWF_PASSWORD}(struct))
	{
		if o.EncryptedOldOWFPassword != nil {
			if err := o.EncryptedOldOWFPassword.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&EncryptedNTOWFPassword{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_TrustPasswordsGetOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ReturnAuthenticator {out} (1:{alias=PNETLOGON_AUTHENTICATOR,pointer=ref}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator == nil {
			o.ReturnAuthenticator = &Authenticator{}
		}
		if err := o.ReturnAuthenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// EncryptedNewOwfPassword {out} (1:{alias=PENCRYPTED_NT_OWF_PASSWORD,pointer=ref}*(1))(2:{alias=ENCRYPTED_NT_OWF_PASSWORD}(struct))
	{
		if o.EncryptedNewOWFPassword == nil {
			o.EncryptedNewOWFPassword = &EncryptedNTOWFPassword{}
		}
		if err := o.EncryptedNewOWFPassword.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// EncryptedOldOwfPassword {out} (1:{alias=PENCRYPTED_NT_OWF_PASSWORD,pointer=ref}*(1))(2:{alias=ENCRYPTED_NT_OWF_PASSWORD}(struct))
	{
		if o.EncryptedOldOWFPassword == nil {
			o.EncryptedOldOWFPassword = &EncryptedNTOWFPassword{}
		}
		if err := o.EncryptedOldOWFPassword.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// TrustPasswordsGetRequest structure represents the NetrServerTrustPasswordsGet operation request
type TrustPasswordsGetRequest struct {
	// TrustedDcName: The custom binding handle, as defined in section 3.5.4.1.
	TrustedDCName string `idl:"name:TrustedDcName;string;pointer:unique" json:"trusted_dc_name"`
	// AccountName: The null-terminated Unicode string that contains the name of the client
	// account in the domain for which the trust password MUST be returned.<187>
	AccountName string `idl:"name:AccountName;string" json:"account_name"`
	// SecureChannelType: A NETLOGON_SECURE_CHANNEL_TYPE enumerated value, as specified
	// in section 2.2.1.3.13, that indicates the type of the secure channel being established
	// by this call.
	SecureChannelType SecureChannelType `idl:"name:SecureChannelType" json:"secure_channel_type"`
	// ComputerName: The null-terminated Unicode string that contains the NetBIOS name of
	// the client computer.
	ComputerName string `idl:"name:ComputerName;string" json:"computer_name"`
	// Authenticator: A pointer to a NETLOGON_AUTHENTICATOR structure, as specified in section
	// 2.2.1.1.5, that contains the client authenticator.
	Authenticator *Authenticator `idl:"name:Authenticator" json:"authenticator"`
}

func (o *TrustPasswordsGetRequest) xxx_ToOp(ctx context.Context, op *xxx_TrustPasswordsGetOperation) *xxx_TrustPasswordsGetOperation {
	if op == nil {
		op = &xxx_TrustPasswordsGetOperation{}
	}
	if o == nil {
		return op
	}
	op.TrustedDCName = o.TrustedDCName
	op.AccountName = o.AccountName
	op.SecureChannelType = o.SecureChannelType
	op.ComputerName = o.ComputerName
	op.Authenticator = o.Authenticator
	return op
}

func (o *TrustPasswordsGetRequest) xxx_FromOp(ctx context.Context, op *xxx_TrustPasswordsGetOperation) {
	if o == nil {
		return
	}
	o.TrustedDCName = op.TrustedDCName
	o.AccountName = op.AccountName
	o.SecureChannelType = op.SecureChannelType
	o.ComputerName = op.ComputerName
	o.Authenticator = op.Authenticator
}
func (o *TrustPasswordsGetRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *TrustPasswordsGetRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_TrustPasswordsGetOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// TrustPasswordsGetResponse structure represents the NetrServerTrustPasswordsGet operation response
type TrustPasswordsGetResponse struct {
	// ReturnAuthenticator: A pointer to a NETLOGON_AUTHENTICATOR structure, as specified
	// in section 2.2.1.1.5, that contains the server return authenticator.
	ReturnAuthenticator *Authenticator `idl:"name:ReturnAuthenticator" json:"return_authenticator"`
	// EncryptedNewOwfPassword: A pointer to an ENCRYPTED_NT_OWF_PASSWORD structure, as
	// specified in [MS-SAMR] section 2.2.7.3, that contains the NTOWFv1 (as specified in
	// NTLM v1 Authentication in [MS-NLMP] section 3.3.1) of the current password, encrypted
	// as specified in [MS-SAMR] section 2.2.11.1.1, Encrypting an NT Hash or LM Hash Value
	// with a specified key. The session key is the specified 16-byte key that is used to
	// derive the password's keys. The specified 16-byte key uses the 16-byte value process,
	// as specified in [MS-SAMR] section 2.2.11.1.4.
	EncryptedNewOWFPassword *EncryptedNTOWFPassword `idl:"name:EncryptedNewOwfPassword" json:"encrypted_new_owf_password"`
	// EncryptedOldOwfPassword: A pointer to an ENCRYPTED_NT_OWF_PASSWORD structure, as
	// specified in [MS-SAMR] section 2.2.7.3, that contains the NTOWFv1 (as specified in
	// NTLM v1 Authentication in [MS-NLMP] section 3.3.1) of the previous password, encrypted
	// as specified in [MS-SAMR] section 2.2.11.1.1, Encrypting an NT Hash or LM Hash Value
	// with a specified key. The session key is the specified 16-byte key that is used to
	// derive the password's keys. The specified 16-byte key uses the 16-byte value process,
	// as specified in [MS-SAMR] section 2.2.11.1.4.
	EncryptedOldOWFPassword *EncryptedNTOWFPassword `idl:"name:EncryptedOldOwfPassword" json:"encrypted_old_owf_password"`
	// Return: The NetrServerTrustPasswordsGet return value.
	Return int32 `idl:"name:Return" json:"return"`
}

func (o *TrustPasswordsGetResponse) xxx_ToOp(ctx context.Context, op *xxx_TrustPasswordsGetOperation) *xxx_TrustPasswordsGetOperation {
	if op == nil {
		op = &xxx_TrustPasswordsGetOperation{}
	}
	if o == nil {
		return op
	}
	op.ReturnAuthenticator = o.ReturnAuthenticator
	op.EncryptedNewOWFPassword = o.EncryptedNewOWFPassword
	op.EncryptedOldOWFPassword = o.EncryptedOldOWFPassword
	op.Return = o.Return
	return op
}

func (o *TrustPasswordsGetResponse) xxx_FromOp(ctx context.Context, op *xxx_TrustPasswordsGetOperation) {
	if o == nil {
		return
	}
	o.ReturnAuthenticator = op.ReturnAuthenticator
	o.EncryptedNewOWFPassword = op.EncryptedNewOWFPassword
	o.EncryptedOldOWFPassword = op.EncryptedOldOWFPassword
	o.Return = op.Return
}
func (o *TrustPasswordsGetResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *TrustPasswordsGetResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_TrustPasswordsGetOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetForestTrustInformationOperation structure represents the DsrGetForestTrustInformation operation
type xxx_GetForestTrustInformationOperation struct {
	ServerName        string                  `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	TrustedDomainName string                  `idl:"name:TrustedDomainName;string;pointer:unique" json:"trusted_domain_name"`
	Flags             uint32                  `idl:"name:Flags" json:"flags"`
	ForestTrustInfo   *ForestTrustInformation `idl:"name:ForestTrustInfo" json:"forest_trust_info"`
	Return            uint32                  `idl:"name:Return" json:"return"`
}

func (o *xxx_GetForestTrustInformationOperation) OpNum() int { return 43 }

func (o *xxx_GetForestTrustInformationOperation) OpName() string {
	return "/logon/v1/DsrGetForestTrustInformation"
}

func (o *xxx_GetForestTrustInformationOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetForestTrustInformationOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// TrustedDomainName {in} (1:{string, pointer=unique}*(1)[dim:0,string,null](wchar))
	{
		if o.TrustedDomainName != "" {
			_ptr_TrustedDomainName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.TrustedDomainName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.TrustedDomainName, _ptr_TrustedDomainName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetForestTrustInformationOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// TrustedDomainName {in} (1:{string, pointer=unique}*(1)[dim:0,string,null](wchar))
	{
		_ptr_TrustedDomainName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.TrustedDomainName); err != nil {
				return err
			}
			return nil
		})
		_s_TrustedDomainName := func(ptr interface{}) { o.TrustedDomainName = *ptr.(*string) }
		if err := w.ReadPointer(&o.TrustedDomainName, _s_TrustedDomainName, _ptr_TrustedDomainName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetForestTrustInformationOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetForestTrustInformationOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ForestTrustInfo {out} (1:{pointer=ref}*(2))(2:{alias=PLSA_FOREST_TRUST_INFORMATION}*(1))(3:{alias=LSA_FOREST_TRUST_INFORMATION}(struct))
	{
		if o.ForestTrustInfo != nil {
			_ptr_ForestTrustInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.ForestTrustInfo != nil {
					if err := o.ForestTrustInfo.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&ForestTrustInformation{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ForestTrustInfo, _ptr_ForestTrustInfo); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetForestTrustInformationOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ForestTrustInfo {out} (1:{pointer=ref}*(2))(2:{alias=PLSA_FOREST_TRUST_INFORMATION,pointer=ref}*(1))(3:{alias=LSA_FOREST_TRUST_INFORMATION}(struct))
	{
		_ptr_ForestTrustInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.ForestTrustInfo == nil {
				o.ForestTrustInfo = &ForestTrustInformation{}
			}
			if err := o.ForestTrustInfo.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ForestTrustInfo := func(ptr interface{}) { o.ForestTrustInfo = *ptr.(**ForestTrustInformation) }
		if err := w.ReadPointer(&o.ForestTrustInfo, _s_ForestTrustInfo, _ptr_ForestTrustInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NET_API_STATUS, names=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetForestTrustInformationRequest structure represents the DsrGetForestTrustInformation operation request
type GetForestTrustInformationRequest struct {
	// ServerName: The custom binding handle, as defined in section 3.5.4.1.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// TrustedDomainName: The optional null-terminated Unicode string that contains the
	// DNS or NetBIOS name of the trusted domain for which the forest trust information
	// is to be gathered.
	TrustedDomainName string `idl:"name:TrustedDomainName;string;pointer:unique" json:"trusted_domain_name"`
	// Flags: A set of bit flags that specify additional applications for the forest trust
	// information. A flag is TRUE (or set) if its value is equal to 1.
	//
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
	//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | A |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//
	// Where the bits are defined as:
	//
	//	+-------+----------------------------------------------------------------------------------+
	//	|       |                                                                                  |
	//	| VALUE |                                   DESCRIPTION                                    |
	//	|       |                                                                                  |
	//	+-------+----------------------------------------------------------------------------------+
	//	+-------+----------------------------------------------------------------------------------+
	//	| A     | Update a trusted domain object (TDO) with the information returned in            |
	//	|       | ForestTrustInfo.                                                                 |
	//	+-------+----------------------------------------------------------------------------------+
	Flags uint32 `idl:"name:Flags" json:"flags"`
}

func (o *GetForestTrustInformationRequest) xxx_ToOp(ctx context.Context, op *xxx_GetForestTrustInformationOperation) *xxx_GetForestTrustInformationOperation {
	if op == nil {
		op = &xxx_GetForestTrustInformationOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.TrustedDomainName = o.TrustedDomainName
	op.Flags = o.Flags
	return op
}

func (o *GetForestTrustInformationRequest) xxx_FromOp(ctx context.Context, op *xxx_GetForestTrustInformationOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.TrustedDomainName = op.TrustedDomainName
	o.Flags = op.Flags
}
func (o *GetForestTrustInformationRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetForestTrustInformationRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetForestTrustInformationOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetForestTrustInformationResponse structure represents the DsrGetForestTrustInformation operation response
type GetForestTrustInformationResponse struct {
	// ForestTrustInfo: A pointer to an LSA_FOREST_TRUST_INFORMATION structure, as specified
	// in [MS-LSAD] section 2.2.7.25, that contains data for each forest trust.
	ForestTrustInfo *ForestTrustInformation `idl:"name:ForestTrustInfo" json:"forest_trust_info"`
	// Return: The DsrGetForestTrustInformation return value.
	Return uint32 `idl:"name:Return" json:"return"`
}

func (o *GetForestTrustInformationResponse) xxx_ToOp(ctx context.Context, op *xxx_GetForestTrustInformationOperation) *xxx_GetForestTrustInformationOperation {
	if op == nil {
		op = &xxx_GetForestTrustInformationOperation{}
	}
	if o == nil {
		return op
	}
	op.ForestTrustInfo = o.ForestTrustInfo
	op.Return = o.Return
	return op
}

func (o *GetForestTrustInformationResponse) xxx_FromOp(ctx context.Context, op *xxx_GetForestTrustInformationOperation) {
	if o == nil {
		return
	}
	o.ForestTrustInfo = op.ForestTrustInfo
	o.Return = op.Return
}
func (o *GetForestTrustInformationResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetForestTrustInformationResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetForestTrustInformationOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetNetrForestTrustInformationOperation structure represents the NetrGetForestTrustInformation operation
type xxx_GetNetrForestTrustInformationOperation struct {
	ServerName          string                  `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	ComputerName        string                  `idl:"name:ComputerName;string" json:"computer_name"`
	Authenticator       *Authenticator          `idl:"name:Authenticator" json:"authenticator"`
	ReturnAuthenticator *Authenticator          `idl:"name:ReturnAuthenticator" json:"return_authenticator"`
	Flags               uint32                  `idl:"name:Flags" json:"flags"`
	ForestTrustInfo     *ForestTrustInformation `idl:"name:ForestTrustInfo" json:"forest_trust_info"`
	Return              int32                   `idl:"name:Return" json:"return"`
}

func (o *xxx_GetNetrForestTrustInformationOperation) OpNum() int { return 44 }

func (o *xxx_GetNetrForestTrustInformationOperation) OpName() string {
	return "/logon/v1/NetrGetForestTrustInformation"
}

func (o *xxx_GetNetrForestTrustInformationOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNetrForestTrustInformationOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ComputerName); err != nil {
			return err
		}
	}
	// Authenticator {in} (1:{alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.Authenticator != nil {
			if err := o.Authenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNetrForestTrustInformationOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ComputerName); err != nil {
			return err
		}
	}
	// Authenticator {in} (1:{alias=PNETLOGON_AUTHENTICATOR,pointer=ref}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.Authenticator == nil {
			o.Authenticator = &Authenticator{}
		}
		if err := o.Authenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// Flags {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.Flags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNetrForestTrustInformationOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNetrForestTrustInformationOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ReturnAuthenticator {out} (1:{alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator != nil {
			if err := o.ReturnAuthenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// ForestTrustInfo {out} (1:{pointer=ref}*(2))(2:{alias=PLSA_FOREST_TRUST_INFORMATION}*(1))(3:{alias=LSA_FOREST_TRUST_INFORMATION}(struct))
	{
		if o.ForestTrustInfo != nil {
			_ptr_ForestTrustInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.ForestTrustInfo != nil {
					if err := o.ForestTrustInfo.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&ForestTrustInformation{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ForestTrustInfo, _ptr_ForestTrustInfo); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetNetrForestTrustInformationOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ReturnAuthenticator {out} (1:{alias=PNETLOGON_AUTHENTICATOR,pointer=ref}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator == nil {
			o.ReturnAuthenticator = &Authenticator{}
		}
		if err := o.ReturnAuthenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// ForestTrustInfo {out} (1:{pointer=ref}*(2))(2:{alias=PLSA_FOREST_TRUST_INFORMATION,pointer=ref}*(1))(3:{alias=LSA_FOREST_TRUST_INFORMATION}(struct))
	{
		_ptr_ForestTrustInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.ForestTrustInfo == nil {
				o.ForestTrustInfo = &ForestTrustInformation{}
			}
			if err := o.ForestTrustInfo.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ForestTrustInfo := func(ptr interface{}) { o.ForestTrustInfo = *ptr.(**ForestTrustInformation) }
		if err := w.ReadPointer(&o.ForestTrustInfo, _s_ForestTrustInfo, _ptr_ForestTrustInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetNetrForestTrustInformationRequest structure represents the NetrGetForestTrustInformation operation request
type GetNetrForestTrustInformationRequest struct {
	// ServerName: The custom binding handle, as defined in section 3.5.4.1.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// ComputerName: The null-terminated Unicode string that contains the client computer
	// NetBIOS name.
	ComputerName string `idl:"name:ComputerName;string" json:"computer_name"`
	// Authenticator: A pointer to a NETLOGON_AUTHENTICATOR structure, as specified in section
	// 2.2.1.1.5, that contains the client authenticator.
	Authenticator *Authenticator `idl:"name:Authenticator" json:"authenticator"`
	// Flags: MUST be set to zero and MUST be ignored on receipt.
	Flags uint32 `idl:"name:Flags" json:"flags"`
}

func (o *GetNetrForestTrustInformationRequest) xxx_ToOp(ctx context.Context, op *xxx_GetNetrForestTrustInformationOperation) *xxx_GetNetrForestTrustInformationOperation {
	if op == nil {
		op = &xxx_GetNetrForestTrustInformationOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.ComputerName = o.ComputerName
	op.Authenticator = o.Authenticator
	op.Flags = o.Flags
	return op
}

func (o *GetNetrForestTrustInformationRequest) xxx_FromOp(ctx context.Context, op *xxx_GetNetrForestTrustInformationOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.ComputerName = op.ComputerName
	o.Authenticator = op.Authenticator
	o.Flags = op.Flags
}
func (o *GetNetrForestTrustInformationRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetNetrForestTrustInformationRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetNetrForestTrustInformationOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetNetrForestTrustInformationResponse structure represents the NetrGetForestTrustInformation operation response
type GetNetrForestTrustInformationResponse struct {
	// ReturnAuthenticator: A pointer to a NETLOGON_AUTHENTICATOR structure, as specified
	// in section 2.2.1.1.5, that contains the server return authenticator.
	ReturnAuthenticator *Authenticator `idl:"name:ReturnAuthenticator" json:"return_authenticator"`
	// ForestTrustInfo: A pointer to an LSA_FOREST_TRUST_INFORMATION structure, as specified
	// in [MS-LSAD] section 2.2.7.25, that contains data for each forest trust.
	ForestTrustInfo *ForestTrustInformation `idl:"name:ForestTrustInfo" json:"forest_trust_info"`
	// Return: The NetrGetForestTrustInformation return value.
	Return int32 `idl:"name:Return" json:"return"`
}

func (o *GetNetrForestTrustInformationResponse) xxx_ToOp(ctx context.Context, op *xxx_GetNetrForestTrustInformationOperation) *xxx_GetNetrForestTrustInformationOperation {
	if op == nil {
		op = &xxx_GetNetrForestTrustInformationOperation{}
	}
	if o == nil {
		return op
	}
	op.ReturnAuthenticator = o.ReturnAuthenticator
	op.ForestTrustInfo = o.ForestTrustInfo
	op.Return = o.Return
	return op
}

func (o *GetNetrForestTrustInformationResponse) xxx_FromOp(ctx context.Context, op *xxx_GetNetrForestTrustInformationOperation) {
	if o == nil {
		return
	}
	o.ReturnAuthenticator = op.ReturnAuthenticator
	o.ForestTrustInfo = op.ForestTrustInfo
	o.Return = op.Return
}
func (o *GetNetrForestTrustInformationResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetNetrForestTrustInformationResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetNetrForestTrustInformationOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_SAMLogonWithFlagsOperation structure represents the NetrLogonSamLogonWithFlags operation
type xxx_SAMLogonWithFlagsOperation struct {
	LogonServer           string              `idl:"name:LogonServer;string;pointer:unique" json:"logon_server"`
	ComputerName          string              `idl:"name:ComputerName;string;pointer:unique" json:"computer_name"`
	Authenticator         *Authenticator      `idl:"name:Authenticator;pointer:unique" json:"authenticator"`
	ReturnAuthenticator   *Authenticator      `idl:"name:ReturnAuthenticator;pointer:unique" json:"return_authenticator"`
	LogonLevel            LogonInfoClass      `idl:"name:LogonLevel" json:"logon_level"`
	LogonInformation      *Level              `idl:"name:LogonInformation;switch_is:LogonLevel" json:"logon_information"`
	ValidationLevel       ValidationInfoClass `idl:"name:ValidationLevel" json:"validation_level"`
	ValidationInformation *Validation         `idl:"name:ValidationInformation;switch_is:ValidationLevel" json:"validation_information"`
	Authoritative         uint8               `idl:"name:Authoritative" json:"authoritative"`
	ExtraFlags            uint32              `idl:"name:ExtraFlags" json:"extra_flags"`
	Return                int32               `idl:"name:Return" json:"return"`
}

func (o *xxx_SAMLogonWithFlagsOperation) OpNum() int { return 45 }

func (o *xxx_SAMLogonWithFlagsOperation) OpName() string {
	return "/logon/v1/NetrLogonSamLogonWithFlags"
}

func (o *xxx_SAMLogonWithFlagsOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SAMLogonWithFlagsOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// LogonServer {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.LogonServer != "" {
			_ptr_LogonServer := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.LogonServer); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.LogonServer, _ptr_LogonServer); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=unique}*(1)[dim:0,string,null](wchar))
	{
		if o.ComputerName != "" {
			_ptr_ComputerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ComputerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ComputerName, _ptr_ComputerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Authenticator {in} (1:{pointer=unique, alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.Authenticator != nil {
			_ptr_Authenticator := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.Authenticator != nil {
					if err := o.Authenticator.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.Authenticator, _ptr_Authenticator); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ReturnAuthenticator {in, out} (1:{pointer=unique, alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator != nil {
			_ptr_ReturnAuthenticator := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.ReturnAuthenticator != nil {
					if err := o.ReturnAuthenticator.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ReturnAuthenticator, _ptr_ReturnAuthenticator); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// LogonLevel {in} (1:{alias=NETLOGON_LOGON_INFO_CLASS}(enum))
	{
		if err := w.WriteEnum(uint16(o.LogonLevel)); err != nil {
			return err
		}
	}
	// LogonInformation {in} (1:{switch_type={alias=NETLOGON_LOGON_INFO_CLASS}(enum), alias=PNETLOGON_LEVEL}*(1))(2:{switch_type={alias=NETLOGON_LOGON_INFO_CLASS}(enum), alias=NETLOGON_LEVEL}(union))
	{
		_swLogonInformation := uint16(o.LogonLevel)
		if o.LogonInformation != nil {
			if err := o.LogonInformation.MarshalUnionNDR(ctx, w, _swLogonInformation); err != nil {
				return err
			}
		} else {
			if err := (&Level{}).MarshalUnionNDR(ctx, w, _swLogonInformation); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ValidationLevel {in} (1:{alias=NETLOGON_VALIDATION_INFO_CLASS}(enum))
	{
		if err := w.WriteEnum(uint16(o.ValidationLevel)); err != nil {
			return err
		}
	}
	// ExtraFlags {in, out} (1:{pointer=ref}*(1))(2:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.ExtraFlags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SAMLogonWithFlagsOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// LogonServer {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_LogonServer := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.LogonServer); err != nil {
				return err
			}
			return nil
		})
		_s_LogonServer := func(ptr interface{}) { o.LogonServer = *ptr.(*string) }
		if err := w.ReadPointer(&o.LogonServer, _s_LogonServer, _ptr_LogonServer); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=unique}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ComputerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ComputerName); err != nil {
				return err
			}
			return nil
		})
		_s_ComputerName := func(ptr interface{}) { o.ComputerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ComputerName, _s_ComputerName, _ptr_ComputerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Authenticator {in} (1:{pointer=unique, alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		_ptr_Authenticator := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.Authenticator == nil {
				o.Authenticator = &Authenticator{}
			}
			if err := o.Authenticator.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_Authenticator := func(ptr interface{}) { o.Authenticator = *ptr.(**Authenticator) }
		if err := w.ReadPointer(&o.Authenticator, _s_Authenticator, _ptr_Authenticator); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ReturnAuthenticator {in, out} (1:{pointer=unique, alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		_ptr_ReturnAuthenticator := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.ReturnAuthenticator == nil {
				o.ReturnAuthenticator = &Authenticator{}
			}
			if err := o.ReturnAuthenticator.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ReturnAuthenticator := func(ptr interface{}) { o.ReturnAuthenticator = *ptr.(**Authenticator) }
		if err := w.ReadPointer(&o.ReturnAuthenticator, _s_ReturnAuthenticator, _ptr_ReturnAuthenticator); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// LogonLevel {in} (1:{alias=NETLOGON_LOGON_INFO_CLASS}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.LogonLevel)); err != nil {
			return err
		}
	}
	// LogonInformation {in} (1:{switch_type={alias=NETLOGON_LOGON_INFO_CLASS}(enum), alias=PNETLOGON_LEVEL,pointer=ref}*(1))(2:{switch_type={alias=NETLOGON_LOGON_INFO_CLASS}(enum), alias=NETLOGON_LEVEL}(union))
	{
		if o.LogonInformation == nil {
			o.LogonInformation = &Level{}
		}
		_swLogonInformation := uint16(o.LogonLevel)
		if err := o.LogonInformation.UnmarshalUnionNDR(ctx, w, _swLogonInformation); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ValidationLevel {in} (1:{alias=NETLOGON_VALIDATION_INFO_CLASS}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.ValidationLevel)); err != nil {
			return err
		}
	}
	// ExtraFlags {in, out} (1:{pointer=ref}*(1))(2:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.ExtraFlags); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SAMLogonWithFlagsOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SAMLogonWithFlagsOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ReturnAuthenticator {in, out} (1:{pointer=unique, alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator != nil {
			_ptr_ReturnAuthenticator := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.ReturnAuthenticator != nil {
					if err := o.ReturnAuthenticator.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.ReturnAuthenticator, _ptr_ReturnAuthenticator); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ValidationInformation {out} (1:{switch_type={}(enum), alias=PNETLOGON_VALIDATION}*(1))(2:{switch_type={}(enum), alias=NETLOGON_VALIDATION}(union))
	{
		_swValidationInformation := uint16(o.ValidationLevel)
		if o.ValidationInformation != nil {
			if err := o.ValidationInformation.MarshalUnionNDR(ctx, w, _swValidationInformation); err != nil {
				return err
			}
		} else {
			if err := (&Validation{}).MarshalUnionNDR(ctx, w, _swValidationInformation); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Authoritative {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}(uchar))
	{
		if err := w.WriteData(o.Authoritative); err != nil {
			return err
		}
	}
	// ExtraFlags {in, out} (1:{pointer=ref}*(1))(2:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.ExtraFlags); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_SAMLogonWithFlagsOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ReturnAuthenticator {in, out} (1:{pointer=unique, alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		_ptr_ReturnAuthenticator := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.ReturnAuthenticator == nil {
				o.ReturnAuthenticator = &Authenticator{}
			}
			if err := o.ReturnAuthenticator.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_ReturnAuthenticator := func(ptr interface{}) { o.ReturnAuthenticator = *ptr.(**Authenticator) }
		if err := w.ReadPointer(&o.ReturnAuthenticator, _s_ReturnAuthenticator, _ptr_ReturnAuthenticator); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ValidationInformation {out} (1:{switch_type={}(enum), alias=PNETLOGON_VALIDATION,pointer=ref}*(1))(2:{switch_type={}(enum), alias=NETLOGON_VALIDATION}(union))
	{
		if o.ValidationInformation == nil {
			o.ValidationInformation = &Validation{}
		}
		_swValidationInformation := uint16(o.ValidationLevel)
		if err := o.ValidationInformation.UnmarshalUnionNDR(ctx, w, _swValidationInformation); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Authoritative {out} (1:{pointer=ref}*(1))(2:{alias=UCHAR}(uchar))
	{
		if err := w.ReadData(&o.Authoritative); err != nil {
			return err
		}
	}
	// ExtraFlags {in, out} (1:{pointer=ref}*(1))(2:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.ExtraFlags); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// SAMLogonWithFlagsRequest structure represents the NetrLogonSamLogonWithFlags operation request
type SAMLogonWithFlagsRequest struct {
	// LogonServer: The custom binding handle, as defined in section 3.5.4.1.
	LogonServer string `idl:"name:LogonServer;string;pointer:unique" json:"logon_server"`
	// ComputerName: The Unicode string that contains the NetBIOS name of the client computer
	// calling this method.
	ComputerName string `idl:"name:ComputerName;string;pointer:unique" json:"computer_name"`
	// Authenticator: A pointer to a NETLOGON_AUTHENTICATOR structure, as specified in section
	// 2.2.1.1.5, that contains the client authenticator.
	Authenticator *Authenticator `idl:"name:Authenticator;pointer:unique" json:"authenticator"`
	// ReturnAuthenticator: A pointer to a NETLOGON_AUTHENTICATOR structure, as specified
	// in section 2.2.1.1.5, that contains the server return authenticator.
	ReturnAuthenticator *Authenticator `idl:"name:ReturnAuthenticator;pointer:unique" json:"return_authenticator"`
	// LogonLevel: A NETLOGON_LOGON_INFO_CLASS structure, as specified in section 2.2.1.4.16,
	// that specifies the type of logon information passed in the LogonInformation parameter.
	LogonLevel LogonInfoClass `idl:"name:LogonLevel" json:"logon_level"`
	// LogonInformation: A pointer to a NETLOGON_LEVEL structure, as specified in section
	// 2.2.1.4.6, that describes the logon request information.
	LogonInformation *Level `idl:"name:LogonInformation;switch_is:LogonLevel" json:"logon_information"`
	// ValidationLevel: A NETLOGON_VALIDATION_INFO_CLASS enumerated type, as specified in
	// section 2.2.1.4.17, that contains the validation level requested by the client.
	ValidationLevel ValidationInfoClass `idl:"name:ValidationLevel" json:"validation_level"`
	// ExtraFlags: A pointer to a set of bit flags that specify delivery settings. A flag
	// is TRUE (or set) if its value is equal to 1. The value is constructed from zero or
	// more bit flags from the following table.
	//
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
	//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | D | C | B | A |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//
	// Where the bits SHOULD<212> defined as:
	//
	//	+-------+----------------------------------------------------------------------------------+
	//	|       |                                                                                  |
	//	| VALUE |                                   DESCRIPTION                                    |
	//	|       |                                                                                  |
	//	+-------+----------------------------------------------------------------------------------+
	//	+-------+----------------------------------------------------------------------------------+
	//	| A     | Request is passed to the domain controller at the root of the forest.            |
	//	+-------+----------------------------------------------------------------------------------+
	//	| B     | Request is passed to the DC at the end of the first hop over a cross-forest      |
	//	|       | trust.                                                                           |
	//	+-------+----------------------------------------------------------------------------------+
	//	| C     | Request is passed by an RODC to a DC in a different domain.                      |
	//	+-------+----------------------------------------------------------------------------------+
	//	| D     | Request is an NTLM authentication package request passed by an RODC.             |
	//	+-------+----------------------------------------------------------------------------------+
	ExtraFlags uint32 `idl:"name:ExtraFlags" json:"extra_flags"`
}

func (o *SAMLogonWithFlagsRequest) xxx_ToOp(ctx context.Context, op *xxx_SAMLogonWithFlagsOperation) *xxx_SAMLogonWithFlagsOperation {
	if op == nil {
		op = &xxx_SAMLogonWithFlagsOperation{}
	}
	if o == nil {
		return op
	}
	op.LogonServer = o.LogonServer
	op.ComputerName = o.ComputerName
	op.Authenticator = o.Authenticator
	op.ReturnAuthenticator = o.ReturnAuthenticator
	op.LogonLevel = o.LogonLevel
	op.LogonInformation = o.LogonInformation
	op.ValidationLevel = o.ValidationLevel
	op.ExtraFlags = o.ExtraFlags
	return op
}

func (o *SAMLogonWithFlagsRequest) xxx_FromOp(ctx context.Context, op *xxx_SAMLogonWithFlagsOperation) {
	if o == nil {
		return
	}
	o.LogonServer = op.LogonServer
	o.ComputerName = op.ComputerName
	o.Authenticator = op.Authenticator
	o.ReturnAuthenticator = op.ReturnAuthenticator
	o.LogonLevel = op.LogonLevel
	o.LogonInformation = op.LogonInformation
	o.ValidationLevel = op.ValidationLevel
	o.ExtraFlags = op.ExtraFlags
}
func (o *SAMLogonWithFlagsRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *SAMLogonWithFlagsRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SAMLogonWithFlagsOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// SAMLogonWithFlagsResponse structure represents the NetrLogonSamLogonWithFlags operation response
type SAMLogonWithFlagsResponse struct {
	// XXX: ValidationLevel is an implicit input depedency for output parameters
	ValidationLevel ValidationInfoClass `idl:"name:ValidationLevel" json:"validation_level"`

	// ReturnAuthenticator: A pointer to a NETLOGON_AUTHENTICATOR structure, as specified
	// in section 2.2.1.1.5, that contains the server return authenticator.
	ReturnAuthenticator *Authenticator `idl:"name:ReturnAuthenticator;pointer:unique" json:"return_authenticator"`
	// ValidationInformation: A pointer to a NETLOGON_VALIDATION structure, as specified
	// in section 2.2.1.4.14, that describes the user validation information returned to
	// the client. The type of the NETLOGON_VALIDATION used is determined by the value of
	// the ValidationLevel parameter.
	ValidationInformation *Validation `idl:"name:ValidationInformation;switch_is:ValidationLevel" json:"validation_information"`
	// Authoritative: A pointer to a char value representing a Boolean condition. FALSE
	// is indicated by the value 0x00; TRUE SHOULD<211> be indicated by the value 0x01 and
	// MAY also be indicated by any nonzero value.
	Authoritative uint8 `idl:"name:Authoritative" json:"authoritative"`
	// ExtraFlags: A pointer to a set of bit flags that specify delivery settings. A flag
	// is TRUE (or set) if its value is equal to 1. The value is constructed from zero or
	// more bit flags from the following table.
	//
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 1 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 2 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 3 | 1 |
	//	|   |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |   |   |   |   |   |   |   |   | 0 |   |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//	| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | D | C | B | A |
	//	+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
	//
	// Where the bits SHOULD<212> defined as:
	//
	//	+-------+----------------------------------------------------------------------------------+
	//	|       |                                                                                  |
	//	| VALUE |                                   DESCRIPTION                                    |
	//	|       |                                                                                  |
	//	+-------+----------------------------------------------------------------------------------+
	//	+-------+----------------------------------------------------------------------------------+
	//	| A     | Request is passed to the domain controller at the root of the forest.            |
	//	+-------+----------------------------------------------------------------------------------+
	//	| B     | Request is passed to the DC at the end of the first hop over a cross-forest      |
	//	|       | trust.                                                                           |
	//	+-------+----------------------------------------------------------------------------------+
	//	| C     | Request is passed by an RODC to a DC in a different domain.                      |
	//	+-------+----------------------------------------------------------------------------------+
	//	| D     | Request is an NTLM authentication package request passed by an RODC.             |
	//	+-------+----------------------------------------------------------------------------------+
	ExtraFlags uint32 `idl:"name:ExtraFlags" json:"extra_flags"`
	// Return: The NetrLogonSamLogonWithFlags return value.
	Return int32 `idl:"name:Return" json:"return"`
}

func (o *SAMLogonWithFlagsResponse) xxx_ToOp(ctx context.Context, op *xxx_SAMLogonWithFlagsOperation) *xxx_SAMLogonWithFlagsOperation {
	if op == nil {
		op = &xxx_SAMLogonWithFlagsOperation{}
	}
	if o == nil {
		return op
	}
	// XXX: implicit input dependencies for output parameters
	if op.ValidationLevel == ValidationInfoClass(0) {
		op.ValidationLevel = o.ValidationLevel
	}

	op.ReturnAuthenticator = o.ReturnAuthenticator
	op.ValidationInformation = o.ValidationInformation
	op.Authoritative = o.Authoritative
	op.ExtraFlags = o.ExtraFlags
	op.Return = o.Return
	return op
}

func (o *SAMLogonWithFlagsResponse) xxx_FromOp(ctx context.Context, op *xxx_SAMLogonWithFlagsOperation) {
	if o == nil {
		return
	}
	// XXX: implicit input dependencies for output parameters
	o.ValidationLevel = op.ValidationLevel

	o.ReturnAuthenticator = op.ReturnAuthenticator
	o.ValidationInformation = op.ValidationInformation
	o.Authoritative = op.Authoritative
	o.ExtraFlags = op.ExtraFlags
	o.Return = op.Return
}
func (o *SAMLogonWithFlagsResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *SAMLogonWithFlagsResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_SAMLogonWithFlagsOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_GetTrustInfoOperation structure represents the NetrServerGetTrustInfo operation
type xxx_GetTrustInfoOperation struct {
	TrustedDCName           string                  `idl:"name:TrustedDcName;string;pointer:unique" json:"trusted_dc_name"`
	AccountName             string                  `idl:"name:AccountName;string" json:"account_name"`
	SecureChannelType       SecureChannelType       `idl:"name:SecureChannelType" json:"secure_channel_type"`
	ComputerName            string                  `idl:"name:ComputerName;string" json:"computer_name"`
	Authenticator           *Authenticator          `idl:"name:Authenticator" json:"authenticator"`
	ReturnAuthenticator     *Authenticator          `idl:"name:ReturnAuthenticator" json:"return_authenticator"`
	EncryptedNewOWFPassword *EncryptedNTOWFPassword `idl:"name:EncryptedNewOwfPassword" json:"encrypted_new_owf_password"`
	EncryptedOldOWFPassword *EncryptedNTOWFPassword `idl:"name:EncryptedOldOwfPassword" json:"encrypted_old_owf_password"`
	TrustInfo               *GenericRPCData         `idl:"name:TrustInfo" json:"trust_info"`
	Return                  int32                   `idl:"name:Return" json:"return"`
}

func (o *xxx_GetTrustInfoOperation) OpNum() int { return 46 }

func (o *xxx_GetTrustInfoOperation) OpName() string { return "/logon/v1/NetrServerGetTrustInfo" }

func (o *xxx_GetTrustInfoOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetTrustInfoOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// TrustedDcName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.TrustedDCName != "" {
			_ptr_TrustedDcName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.TrustedDCName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.TrustedDCName, _ptr_TrustedDcName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// AccountName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.AccountName); err != nil {
			return err
		}
	}
	// SecureChannelType {in} (1:{alias=NETLOGON_SECURE_CHANNEL_TYPE}(enum))
	{
		if err := w.WriteEnum(uint16(o.SecureChannelType)); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ComputerName); err != nil {
			return err
		}
	}
	// Authenticator {in} (1:{alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.Authenticator != nil {
			if err := o.Authenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	return nil
}

func (o *xxx_GetTrustInfoOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// TrustedDcName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_TrustedDcName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.TrustedDCName); err != nil {
				return err
			}
			return nil
		})
		_s_TrustedDcName := func(ptr interface{}) { o.TrustedDCName = *ptr.(*string) }
		if err := w.ReadPointer(&o.TrustedDCName, _s_TrustedDcName, _ptr_TrustedDcName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// AccountName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.AccountName); err != nil {
			return err
		}
	}
	// SecureChannelType {in} (1:{alias=NETLOGON_SECURE_CHANNEL_TYPE}(enum))
	{
		if err := w.ReadEnum((*uint16)(&o.SecureChannelType)); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ComputerName); err != nil {
			return err
		}
	}
	// Authenticator {in} (1:{alias=PNETLOGON_AUTHENTICATOR,pointer=ref}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.Authenticator == nil {
			o.Authenticator = &Authenticator{}
		}
		if err := o.Authenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetTrustInfoOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetTrustInfoOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ReturnAuthenticator {out} (1:{alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator != nil {
			if err := o.ReturnAuthenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// EncryptedNewOwfPassword {out} (1:{alias=PENCRYPTED_NT_OWF_PASSWORD}*(1))(2:{alias=ENCRYPTED_NT_OWF_PASSWORD}(struct))
	{
		if o.EncryptedNewOWFPassword != nil {
			if err := o.EncryptedNewOWFPassword.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&EncryptedNTOWFPassword{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// EncryptedOldOwfPassword {out} (1:{alias=PENCRYPTED_NT_OWF_PASSWORD}*(1))(2:{alias=ENCRYPTED_NT_OWF_PASSWORD}(struct))
	{
		if o.EncryptedOldOWFPassword != nil {
			if err := o.EncryptedOldOWFPassword.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&EncryptedNTOWFPassword{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// TrustInfo {out} (1:{pointer=ref}*(2))(2:{alias=PNL_GENERIC_RPC_DATA}*(1))(3:{alias=NL_GENERIC_RPC_DATA}(struct))
	{
		if o.TrustInfo != nil {
			_ptr_TrustInfo := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if o.TrustInfo != nil {
					if err := o.TrustInfo.MarshalNDR(ctx, w); err != nil {
						return err
					}
				} else {
					if err := (&GenericRPCData{}).MarshalNDR(ctx, w); err != nil {
						return err
					}
				}
				return nil
			})
			if err := w.WritePointer(&o.TrustInfo, _ptr_TrustInfo); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_GetTrustInfoOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ReturnAuthenticator {out} (1:{alias=PNETLOGON_AUTHENTICATOR,pointer=ref}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator == nil {
			o.ReturnAuthenticator = &Authenticator{}
		}
		if err := o.ReturnAuthenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// EncryptedNewOwfPassword {out} (1:{alias=PENCRYPTED_NT_OWF_PASSWORD,pointer=ref}*(1))(2:{alias=ENCRYPTED_NT_OWF_PASSWORD}(struct))
	{
		if o.EncryptedNewOWFPassword == nil {
			o.EncryptedNewOWFPassword = &EncryptedNTOWFPassword{}
		}
		if err := o.EncryptedNewOWFPassword.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// EncryptedOldOwfPassword {out} (1:{alias=PENCRYPTED_NT_OWF_PASSWORD,pointer=ref}*(1))(2:{alias=ENCRYPTED_NT_OWF_PASSWORD}(struct))
	{
		if o.EncryptedOldOWFPassword == nil {
			o.EncryptedOldOWFPassword = &EncryptedNTOWFPassword{}
		}
		if err := o.EncryptedOldOWFPassword.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// TrustInfo {out} (1:{pointer=ref}*(2))(2:{alias=PNL_GENERIC_RPC_DATA,pointer=ref}*(1))(3:{alias=NL_GENERIC_RPC_DATA}(struct))
	{
		_ptr_TrustInfo := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if o.TrustInfo == nil {
				o.TrustInfo = &GenericRPCData{}
			}
			if err := o.TrustInfo.UnmarshalNDR(ctx, w); err != nil {
				return err
			}
			return nil
		})
		_s_TrustInfo := func(ptr interface{}) { o.TrustInfo = *ptr.(**GenericRPCData) }
		if err := w.ReadPointer(&o.TrustInfo, _s_TrustInfo, _ptr_TrustInfo); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// GetTrustInfoRequest structure represents the NetrServerGetTrustInfo operation request
type GetTrustInfoRequest struct {
	// TrustedDcName: The custom binding handle, as defined in section 3.5.4.1.
	TrustedDCName string `idl:"name:TrustedDcName;string;pointer:unique" json:"trusted_dc_name"`
	// AccountName: The null-terminated Unicode string that contains the name of the client
	// account in the domain.
	AccountName string `idl:"name:AccountName;string" json:"account_name"`
	// SecureChannelType: A NETLOGON_SECURE_CHANNEL_TYPE enumerated value, as specified
	// in section 2.2.1.3.13, that indicates the type of the secure channel being established
	// by this call.
	SecureChannelType SecureChannelType `idl:"name:SecureChannelType" json:"secure_channel_type"`
	// ComputerName: The null-terminated Unicode string that contains the NetBIOS name of
	// the client computer, for which the trust information MUST be returned.
	ComputerName string `idl:"name:ComputerName;string" json:"computer_name"`
	// Authenticator: A pointer to a NETLOGON_AUTHENTICATOR structure, as specified in section
	// 2.2.1.1.5, that contains the client authenticator.
	Authenticator *Authenticator `idl:"name:Authenticator" json:"authenticator"`
}

func (o *GetTrustInfoRequest) xxx_ToOp(ctx context.Context, op *xxx_GetTrustInfoOperation) *xxx_GetTrustInfoOperation {
	if op == nil {
		op = &xxx_GetTrustInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.TrustedDCName = o.TrustedDCName
	op.AccountName = o.AccountName
	op.SecureChannelType = o.SecureChannelType
	op.ComputerName = o.ComputerName
	op.Authenticator = o.Authenticator
	return op
}

func (o *GetTrustInfoRequest) xxx_FromOp(ctx context.Context, op *xxx_GetTrustInfoOperation) {
	if o == nil {
		return
	}
	o.TrustedDCName = op.TrustedDCName
	o.AccountName = op.AccountName
	o.SecureChannelType = op.SecureChannelType
	o.ComputerName = op.ComputerName
	o.Authenticator = op.Authenticator
}
func (o *GetTrustInfoRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *GetTrustInfoRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetTrustInfoOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// GetTrustInfoResponse structure represents the NetrServerGetTrustInfo operation response
type GetTrustInfoResponse struct {
	// ReturnAuthenticator: A pointer to a NETLOGON_AUTHENTICATOR structure, as specified
	// in section 2.2.1.1.5, that contains the server return authenticator.
	ReturnAuthenticator *Authenticator `idl:"name:ReturnAuthenticator" json:"return_authenticator"`
	// EncryptedNewOwfPassword: A pointer to an ENCRYPTED_NT_OWF_PASSWORD structure, as
	// specified in [MS-SAMR] section 2.2.7.3, that contains the NTOWFv1 (as specified in
	// NTLM v1 Authentication in [MS-NLMP] section 3.3.1) of the current password, encrypted
	// as specified in [MS-SAMR] section 2.2.11.1.1, Encrypting an NT Hash or LM Hash Value
	// with a specified key. The session key is the specified 16-byte key that is used to
	// derive its keys via the 16-byte value process, as specified in [MS-SAMR] section
	// 2.2.11.1.4.
	EncryptedNewOWFPassword *EncryptedNTOWFPassword `idl:"name:EncryptedNewOwfPassword" json:"encrypted_new_owf_password"`
	// EncryptedOldOwfPassword: A pointer to an ENCRYPTED_NT_OWF_PASSWORD structure, as
	// specified in [MS-SAMR] section 2.2.7.3, that contains the NTOWFv1 (as specified in
	// NTLM v1 Authentication in [MS-NLMP] section 3.3.1) of the old password, encrypted
	// as specified in [MS-SAMR] section 2.2.11.1.1, Encrypting an NT Hash or LM Hash Value
	// with a specified key. The session key is the specified 16-byte key that is used to
	// derive its keys via the 16-byte value process, as specified in [MS-SAMR] section
	// 2.2.11.1.4.
	EncryptedOldOWFPassword *EncryptedNTOWFPassword `idl:"name:EncryptedOldOwfPassword" json:"encrypted_old_owf_password"`
	// TrustInfo: A pointer to an NL_GENERIC_RPC_DATA structure, as specified in section
	// 2.2.1.6.4, that contains a block of generic RPC data with trust information for the
	// specified server.
	TrustInfo *GenericRPCData `idl:"name:TrustInfo" json:"trust_info"`
	// Return: The NetrServerGetTrustInfo return value.
	Return int32 `idl:"name:Return" json:"return"`
}

func (o *GetTrustInfoResponse) xxx_ToOp(ctx context.Context, op *xxx_GetTrustInfoOperation) *xxx_GetTrustInfoOperation {
	if op == nil {
		op = &xxx_GetTrustInfoOperation{}
	}
	if o == nil {
		return op
	}
	op.ReturnAuthenticator = o.ReturnAuthenticator
	op.EncryptedNewOWFPassword = o.EncryptedNewOWFPassword
	op.EncryptedOldOWFPassword = o.EncryptedOldOWFPassword
	op.TrustInfo = o.TrustInfo
	op.Return = o.Return
	return op
}

func (o *GetTrustInfoResponse) xxx_FromOp(ctx context.Context, op *xxx_GetTrustInfoOperation) {
	if o == nil {
		return
	}
	o.ReturnAuthenticator = op.ReturnAuthenticator
	o.EncryptedNewOWFPassword = op.EncryptedNewOWFPassword
	o.EncryptedOldOWFPassword = op.EncryptedOldOWFPassword
	o.TrustInfo = op.TrustInfo
	o.Return = op.Return
}
func (o *GetTrustInfoResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *GetTrustInfoResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_GetTrustInfoOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_UpdateReadOnlyServerDNSRecordsOperation structure represents the DsrUpdateReadOnlyServerDnsRecords operation
type xxx_UpdateReadOnlyServerDNSRecordsOperation struct {
	ServerName          string            `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	ComputerName        string            `idl:"name:ComputerName;string" json:"computer_name"`
	Authenticator       *Authenticator    `idl:"name:Authenticator" json:"authenticator"`
	ReturnAuthenticator *Authenticator    `idl:"name:ReturnAuthenticator" json:"return_authenticator"`
	SiteName            string            `idl:"name:SiteName;string;pointer:unique" json:"site_name"`
	DNSTTL              uint32            `idl:"name:DnsTtl" json:"dns_ttl"`
	DNSNames            *DNSNameInfoArray `idl:"name:DnsNames" json:"dns_names"`
	Return              int32             `idl:"name:Return" json:"return"`
}

func (o *xxx_UpdateReadOnlyServerDNSRecordsOperation) OpNum() int { return 48 }

func (o *xxx_UpdateReadOnlyServerDNSRecordsOperation) OpName() string {
	return "/logon/v1/DsrUpdateReadOnlyServerDnsRecords"
}

func (o *xxx_UpdateReadOnlyServerDNSRecordsOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UpdateReadOnlyServerDNSRecordsOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// ServerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if o.ServerName != "" {
			_ptr_ServerName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.ServerName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.ServerName, _ptr_ServerName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ComputerName); err != nil {
			return err
		}
	}
	// Authenticator {in} (1:{alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.Authenticator != nil {
			if err := o.Authenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// SiteName {in} (1:{string, pointer=unique}*(1)[dim:0,string,null](wchar))
	{
		if o.SiteName != "" {
			_ptr_SiteName := ndr.MarshalNDRFunc(func(ctx context.Context, w ndr.Writer) error {
				if err := ndr.WriteUTF16NString(ctx, w, o.SiteName); err != nil {
					return err
				}
				return nil
			})
			if err := w.WritePointer(&o.SiteName, _ptr_SiteName); err != nil {
				return err
			}
		} else {
			if err := w.WritePointer(nil); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// DnsTtl {in} (1:{alias=ULONG}(uint32))
	{
		if err := w.WriteData(o.DNSTTL); err != nil {
			return err
		}
	}
	// DnsNames {in, out} (1:{alias=PNL_DNS_NAME_INFO_ARRAY}*(1))(2:{alias=NL_DNS_NAME_INFO_ARRAY}(struct))
	{
		if o.DNSNames != nil {
			if err := o.DNSNames.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DNSNameInfoArray{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UpdateReadOnlyServerDNSRecordsOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// ServerName {in} (1:{handle, string, pointer=unique, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		_ptr_ServerName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.ServerName); err != nil {
				return err
			}
			return nil
		})
		_s_ServerName := func(ptr interface{}) { o.ServerName = *ptr.(*string) }
		if err := w.ReadPointer(&o.ServerName, _s_ServerName, _ptr_ServerName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// ComputerName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ComputerName); err != nil {
			return err
		}
	}
	// Authenticator {in} (1:{alias=PNETLOGON_AUTHENTICATOR,pointer=ref}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.Authenticator == nil {
			o.Authenticator = &Authenticator{}
		}
		if err := o.Authenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// SiteName {in} (1:{string, pointer=unique}*(1)[dim:0,string,null](wchar))
	{
		_ptr_SiteName := ndr.UnmarshalNDRFunc(func(ctx context.Context, w ndr.Reader) error {
			if err := ndr.ReadUTF16NString(ctx, w, &o.SiteName); err != nil {
				return err
			}
			return nil
		})
		_s_SiteName := func(ptr interface{}) { o.SiteName = *ptr.(*string) }
		if err := w.ReadPointer(&o.SiteName, _s_SiteName, _ptr_SiteName); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// DnsTtl {in} (1:{alias=ULONG}(uint32))
	{
		if err := w.ReadData(&o.DNSTTL); err != nil {
			return err
		}
	}
	// DnsNames {in, out} (1:{alias=PNL_DNS_NAME_INFO_ARRAY,pointer=ref}*(1))(2:{alias=NL_DNS_NAME_INFO_ARRAY}(struct))
	{
		if o.DNSNames == nil {
			o.DNSNames = &DNSNameInfoArray{}
		}
		if err := o.DNSNames.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UpdateReadOnlyServerDNSRecordsOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UpdateReadOnlyServerDNSRecordsOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ReturnAuthenticator {out} (1:{alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator != nil {
			if err := o.ReturnAuthenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// DnsNames {in, out} (1:{alias=PNL_DNS_NAME_INFO_ARRAY}*(1))(2:{alias=NL_DNS_NAME_INFO_ARRAY}(struct))
	{
		if o.DNSNames != nil {
			if err := o.DNSNames.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&DNSNameInfoArray{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_UpdateReadOnlyServerDNSRecordsOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ReturnAuthenticator {out} (1:{alias=PNETLOGON_AUTHENTICATOR,pointer=ref}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator == nil {
			o.ReturnAuthenticator = &Authenticator{}
		}
		if err := o.ReturnAuthenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// DnsNames {in, out} (1:{alias=PNL_DNS_NAME_INFO_ARRAY,pointer=ref}*(1))(2:{alias=NL_DNS_NAME_INFO_ARRAY}(struct))
	{
		if o.DNSNames == nil {
			o.DNSNames = &DNSNameInfoArray{}
		}
		if err := o.DNSNames.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// UpdateReadOnlyServerDNSRecordsRequest structure represents the DsrUpdateReadOnlyServerDnsRecords operation request
type UpdateReadOnlyServerDNSRecordsRequest struct {
	// ServerName: The custom binding handle (as defined in section 3.5.4.1) that represents
	// the connection to the normal (writable) DC.
	ServerName string `idl:"name:ServerName;string;pointer:unique" json:"server_name"`
	// ComputerName: A null-terminated Unicode string that contains the client computer
	// NetBIOS name.
	ComputerName string `idl:"name:ComputerName;string" json:"computer_name"`
	// Authenticator: A pointer to a NETLOGON_AUTHENTICATOR structure (as specified in section
	// 2.2.1.1.5) that contains the client authenticator that will be used to authenticate
	// the client.
	Authenticator *Authenticator `idl:"name:Authenticator" json:"authenticator"`
	// SiteName: A pointer to a null-terminated Unicode string that contains the site name
	// where the RODC resides.
	SiteName string `idl:"name:SiteName;string;pointer:unique" json:"site_name"`
	// DnsTtl: The Time-To-Live (TTL) value, in seconds, for DNS records.
	DNSTTL uint32 `idl:"name:DnsTtl" json:"dns_ttl"`
	// DnsNames: A pointer to an NL_DNS_NAME_INFO_ARRAY (section 2.2.1.2.6) structure that
	// contains an array of NL_DNS_NAME_INFO structures.
	DNSNames *DNSNameInfoArray `idl:"name:DnsNames" json:"dns_names"`
}

func (o *UpdateReadOnlyServerDNSRecordsRequest) xxx_ToOp(ctx context.Context, op *xxx_UpdateReadOnlyServerDNSRecordsOperation) *xxx_UpdateReadOnlyServerDNSRecordsOperation {
	if op == nil {
		op = &xxx_UpdateReadOnlyServerDNSRecordsOperation{}
	}
	if o == nil {
		return op
	}
	op.ServerName = o.ServerName
	op.ComputerName = o.ComputerName
	op.Authenticator = o.Authenticator
	op.SiteName = o.SiteName
	op.DNSTTL = o.DNSTTL
	op.DNSNames = o.DNSNames
	return op
}

func (o *UpdateReadOnlyServerDNSRecordsRequest) xxx_FromOp(ctx context.Context, op *xxx_UpdateReadOnlyServerDNSRecordsOperation) {
	if o == nil {
		return
	}
	o.ServerName = op.ServerName
	o.ComputerName = op.ComputerName
	o.Authenticator = op.Authenticator
	o.SiteName = op.SiteName
	o.DNSTTL = op.DNSTTL
	o.DNSNames = op.DNSNames
}
func (o *UpdateReadOnlyServerDNSRecordsRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *UpdateReadOnlyServerDNSRecordsRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_UpdateReadOnlyServerDNSRecordsOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// UpdateReadOnlyServerDNSRecordsResponse structure represents the DsrUpdateReadOnlyServerDnsRecords operation response
type UpdateReadOnlyServerDNSRecordsResponse struct {
	// ReturnAuthenticator: A pointer to a NETLOGON_AUTHENTICATOR structure that contains
	// the server return authenticator.
	ReturnAuthenticator *Authenticator `idl:"name:ReturnAuthenticator" json:"return_authenticator"`
	// DnsNames: A pointer to an NL_DNS_NAME_INFO_ARRAY (section 2.2.1.2.6) structure that
	// contains an array of NL_DNS_NAME_INFO structures.
	DNSNames *DNSNameInfoArray `idl:"name:DnsNames" json:"dns_names"`
	// Return: The DsrUpdateReadOnlyServerDnsRecords return value.
	Return int32 `idl:"name:Return" json:"return"`
}

func (o *UpdateReadOnlyServerDNSRecordsResponse) xxx_ToOp(ctx context.Context, op *xxx_UpdateReadOnlyServerDNSRecordsOperation) *xxx_UpdateReadOnlyServerDNSRecordsOperation {
	if op == nil {
		op = &xxx_UpdateReadOnlyServerDNSRecordsOperation{}
	}
	if o == nil {
		return op
	}
	op.ReturnAuthenticator = o.ReturnAuthenticator
	op.DNSNames = o.DNSNames
	op.Return = o.Return
	return op
}

func (o *UpdateReadOnlyServerDNSRecordsResponse) xxx_FromOp(ctx context.Context, op *xxx_UpdateReadOnlyServerDNSRecordsOperation) {
	if o == nil {
		return
	}
	o.ReturnAuthenticator = op.ReturnAuthenticator
	o.DNSNames = op.DNSNames
	o.Return = op.Return
}
func (o *UpdateReadOnlyServerDNSRecordsResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *UpdateReadOnlyServerDNSRecordsResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_UpdateReadOnlyServerDNSRecordsOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// xxx_ChainSetClientAttributesOperation structure represents the NetrChainSetClientAttributes operation
type xxx_ChainSetClientAttributesOperation struct {
	PrimaryName           string                       `idl:"name:PrimaryName;string;pointer:ref" json:"primary_name"`
	ChainedFromServerName string                       `idl:"name:ChainedFromServerName;string;pointer:ref" json:"chained_from_server_name"`
	ChainedForClientName  string                       `idl:"name:ChainedForClientName;string;pointer:ref" json:"chained_for_client_name"`
	Authenticator         *Authenticator               `idl:"name:Authenticator;pointer:ref" json:"authenticator"`
	ReturnAuthenticator   *Authenticator               `idl:"name:ReturnAuthenticator;pointer:ref" json:"return_authenticator"`
	InVersion             uint32                       `idl:"name:dwInVersion" json:"in_version"`
	In                    *InChainSetClientAttributes  `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
	OutVersion            uint32                       `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	Out                   *OutChainSetClientAttributes `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	Return                int32                        `idl:"name:Return" json:"return"`
}

func (o *xxx_ChainSetClientAttributesOperation) OpNum() int { return 49 }

func (o *xxx_ChainSetClientAttributesOperation) OpName() string {
	return "/logon/v1/NetrChainSetClientAttributes"
}

func (o *xxx_ChainSetClientAttributesOperation) xxx_PrepareRequestPayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareRequestPayload(context.Context) error }); ok {
		if err := hook.AfterPrepareRequestPayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChainSetClientAttributesOperation) MarshalNDRRequest(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareRequestPayload(ctx); err != nil {
		return err
	}
	// PrimaryName {in} (1:{handle, string, pointer=ref, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.PrimaryName); err != nil {
			return err
		}
	}
	// ChainedFromServerName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ChainedFromServerName); err != nil {
			return err
		}
	}
	// ChainedForClientName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.WriteUTF16NString(ctx, w, o.ChainedForClientName); err != nil {
			return err
		}
	}
	// Authenticator {in} (1:{pointer=ref, alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.Authenticator != nil {
			if err := o.Authenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// ReturnAuthenticator {in, out} (1:{pointer=ref, alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator != nil {
			if err := o.ReturnAuthenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=NL_IN_CHAIN_SET_CLIENT_ATTRIBUTES}(union))
	{
		_swIn := uint32(o.InVersion)
		if o.In != nil {
			if err := o.In.MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		} else {
			if err := (&InChainSetClientAttributes{}).MarshalUnionNDR(ctx, w, _swIn); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// pdwOutVersion {in, out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {in, out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=NL_OUT_CHAIN_SET_CLIENT_ATTRIBUTES}(union))
	{
		_swOut := uint32(o.OutVersion)
		if o.Out != nil {
			if err := o.Out.MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		} else {
			if err := (&OutChainSetClientAttributes{}).MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChainSetClientAttributesOperation) UnmarshalNDRRequest(ctx context.Context, w ndr.Reader) error {
	// PrimaryName {in} (1:{handle, string, pointer=ref, alias=LOGONSRV_HANDLE}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.PrimaryName); err != nil {
			return err
		}
	}
	// ChainedFromServerName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ChainedFromServerName); err != nil {
			return err
		}
	}
	// ChainedForClientName {in} (1:{string, pointer=ref}*(1)[dim:0,string,null](wchar))
	{
		if err := ndr.ReadUTF16NString(ctx, w, &o.ChainedForClientName); err != nil {
			return err
		}
	}
	// Authenticator {in} (1:{pointer=ref, alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.Authenticator == nil {
			o.Authenticator = &Authenticator{}
		}
		if err := o.Authenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// ReturnAuthenticator {in, out} (1:{pointer=ref, alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator == nil {
			o.ReturnAuthenticator = &Authenticator{}
		}
		if err := o.ReturnAuthenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// dwInVersion {in} (1:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.InVersion); err != nil {
			return err
		}
	}
	// pmsgIn {in} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=NL_IN_CHAIN_SET_CLIENT_ATTRIBUTES}(union))
	{
		if o.In == nil {
			o.In = &InChainSetClientAttributes{}
		}
		_swIn := uint32(o.InVersion)
		if err := o.In.UnmarshalUnionNDR(ctx, w, _swIn); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// pdwOutVersion {in, out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {in, out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=NL_OUT_CHAIN_SET_CLIENT_ATTRIBUTES}(union))
	{
		if o.Out == nil {
			o.Out = &OutChainSetClientAttributes{}
		}
		_swOut := uint32(o.OutVersion)
		if err := o.Out.UnmarshalUnionNDR(ctx, w, _swOut); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChainSetClientAttributesOperation) xxx_PrepareResponsePayload(ctx context.Context) error {
	if hook, ok := (interface{})(o).(interface{ AfterPrepareResponsePayload(context.Context) error }); ok {
		if err := hook.AfterPrepareResponsePayload(ctx); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChainSetClientAttributesOperation) MarshalNDRResponse(ctx context.Context, w ndr.Writer) error {
	if err := o.xxx_PrepareResponsePayload(ctx); err != nil {
		return err
	}
	// ReturnAuthenticator {in, out} (1:{pointer=ref, alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator != nil {
			if err := o.ReturnAuthenticator.MarshalNDR(ctx, w); err != nil {
				return err
			}
		} else {
			if err := (&Authenticator{}).MarshalNDR(ctx, w); err != nil {
				return err
			}
		}
	}
	// pdwOutVersion {in, out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.WriteData(o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {in, out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=NL_OUT_CHAIN_SET_CLIENT_ATTRIBUTES}(union))
	{
		_swOut := uint32(o.OutVersion)
		if o.Out != nil {
			if err := o.Out.MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		} else {
			if err := (&OutChainSetClientAttributes{}).MarshalUnionNDR(ctx, w, _swOut); err != nil {
				return err
			}
		}
		if err := w.WriteDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.WriteData(o.Return); err != nil {
			return err
		}
	}
	return nil
}

func (o *xxx_ChainSetClientAttributesOperation) UnmarshalNDRResponse(ctx context.Context, w ndr.Reader) error {
	// ReturnAuthenticator {in, out} (1:{pointer=ref, alias=PNETLOGON_AUTHENTICATOR}*(1))(2:{alias=NETLOGON_AUTHENTICATOR}(struct))
	{
		if o.ReturnAuthenticator == nil {
			o.ReturnAuthenticator = &Authenticator{}
		}
		if err := o.ReturnAuthenticator.UnmarshalNDR(ctx, w); err != nil {
			return err
		}
	}
	// pdwOutVersion {in, out} (1:{pointer=ref}*(1))(2:{alias=DWORD}(uint32))
	{
		if err := w.ReadData(&o.OutVersion); err != nil {
			return err
		}
	}
	// pmsgOut {in, out} (1:{pointer=ref}*(1))(2:{switch_type={alias=DWORD}(uint32), alias=NL_OUT_CHAIN_SET_CLIENT_ATTRIBUTES}(union))
	{
		if o.Out == nil {
			o.Out = &OutChainSetClientAttributes{}
		}
		_swOut := uint32(o.OutVersion)
		if err := o.Out.UnmarshalUnionNDR(ctx, w, _swOut); err != nil {
			return err
		}
		if err := w.ReadDeferred(); err != nil {
			return err
		}
	}
	// Return {out} (1:{alias=NTSTATUS}(int32))
	{
		if err := w.ReadData(&o.Return); err != nil {
			return err
		}
	}
	return nil
}

// ChainSetClientAttributesRequest structure represents the NetrChainSetClientAttributes operation request
type ChainSetClientAttributesRequest struct {
	// PrimaryName: The custom binding handle, as defined in section 3.5.4.1.
	PrimaryName string `idl:"name:PrimaryName;string;pointer:ref" json:"primary_name"`
	// ChainedFromServerName: The null-terminated Unicode string that contains the name
	// of the read-only DC that issues the request.
	ChainedFromServerName string `idl:"name:ChainedFromServerName;string;pointer:ref" json:"chained_from_server_name"`
	// ChainedForClientName: The null-terminated Unicode string that contains the name of
	// the client computer that called NetrServerAuthenticate3 or NetrLogonGetDomainInfo
	// on the RODC.
	ChainedForClientName string `idl:"name:ChainedForClientName;string;pointer:ref" json:"chained_for_client_name"`
	// Authenticator: A pointer to a NETLOGON_AUTHENTICATOR structure that contains the
	// client authenticator.
	Authenticator *Authenticator `idl:"name:Authenticator;pointer:ref" json:"authenticator"`
	// ReturnAuthenticator: A pointer to a NETLOGON_AUTHENTICATOR structure that contains
	// the server return authenticator.
	ReturnAuthenticator *Authenticator `idl:"name:ReturnAuthenticator;pointer:ref" json:"return_authenticator"`
	// dwInVersion: One of the NL_IN_CHAIN_SET_CLIENT_ATTRIBUTES union types selected based
	// on the value of the pmsgIn field. The value MUST be 1.
	InVersion uint32 `idl:"name:dwInVersion" json:"in_version"`
	// pmsgIn: A pointer to an NL_IN_CHAIN_SET_CLIENT_ATTRIBUTES_V1 structure that contains
	// the values to update on the client's computer account object in Active Directory
	// on the normal (writable) DC.
	In *InChainSetClientAttributes `idl:"name:pmsgIn;switch_is:dwInVersion;pointer:ref" json:"in"`
	// pdwOutVersion: A pointer to one of the NL_OUT_CHAIN_SET_CLIENT_ATTRIBUTES union types
	// selected based on the value of the pmsgIn field. The value MUST be 1.
	OutVersion uint32 `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	// pmsgOut: A pointer to an NL_OUT_CHAIN_SET_CLIENT_ATTRIBUTES_V1 structure that contains
	// information on the client workstation and the writable domain controller. For how
	// it is populated by the server, see below.
	Out *OutChainSetClientAttributes `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
}

func (o *ChainSetClientAttributesRequest) xxx_ToOp(ctx context.Context, op *xxx_ChainSetClientAttributesOperation) *xxx_ChainSetClientAttributesOperation {
	if op == nil {
		op = &xxx_ChainSetClientAttributesOperation{}
	}
	if o == nil {
		return op
	}
	op.PrimaryName = o.PrimaryName
	op.ChainedFromServerName = o.ChainedFromServerName
	op.ChainedForClientName = o.ChainedForClientName
	op.Authenticator = o.Authenticator
	op.ReturnAuthenticator = o.ReturnAuthenticator
	op.InVersion = o.InVersion
	op.In = o.In
	op.OutVersion = o.OutVersion
	op.Out = o.Out
	return op
}

func (o *ChainSetClientAttributesRequest) xxx_FromOp(ctx context.Context, op *xxx_ChainSetClientAttributesOperation) {
	if o == nil {
		return
	}
	o.PrimaryName = op.PrimaryName
	o.ChainedFromServerName = op.ChainedFromServerName
	o.ChainedForClientName = op.ChainedForClientName
	o.Authenticator = op.Authenticator
	o.ReturnAuthenticator = op.ReturnAuthenticator
	o.InVersion = op.InVersion
	o.In = op.In
	o.OutVersion = op.OutVersion
	o.Out = op.Out
}
func (o *ChainSetClientAttributesRequest) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRRequest(ctx, w)
}
func (o *ChainSetClientAttributesRequest) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ChainSetClientAttributesOperation{}
	if err := _o.UnmarshalNDRRequest(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}

// ChainSetClientAttributesResponse structure represents the NetrChainSetClientAttributes operation response
type ChainSetClientAttributesResponse struct {
	// ReturnAuthenticator: A pointer to a NETLOGON_AUTHENTICATOR structure that contains
	// the server return authenticator.
	ReturnAuthenticator *Authenticator `idl:"name:ReturnAuthenticator;pointer:ref" json:"return_authenticator"`
	// pdwOutVersion: A pointer to one of the NL_OUT_CHAIN_SET_CLIENT_ATTRIBUTES union types
	// selected based on the value of the pmsgIn field. The value MUST be 1.
	OutVersion uint32 `idl:"name:pdwOutVersion;pointer:ref" json:"out_version"`
	// pmsgOut: A pointer to an NL_OUT_CHAIN_SET_CLIENT_ATTRIBUTES_V1 structure that contains
	// information on the client workstation and the writable domain controller. For how
	// it is populated by the server, see below.
	Out *OutChainSetClientAttributes `idl:"name:pmsgOut;switch_is:*pdwOutVersion;pointer:ref" json:"out"`
	// Return: The NetrChainSetClientAttributes return value.
	Return int32 `idl:"name:Return" json:"return"`
}

func (o *ChainSetClientAttributesResponse) xxx_ToOp(ctx context.Context, op *xxx_ChainSetClientAttributesOperation) *xxx_ChainSetClientAttributesOperation {
	if op == nil {
		op = &xxx_ChainSetClientAttributesOperation{}
	}
	if o == nil {
		return op
	}
	op.ReturnAuthenticator = o.ReturnAuthenticator
	op.OutVersion = o.OutVersion
	op.Out = o.Out
	op.Return = o.Return
	return op
}

func (o *ChainSetClientAttributesResponse) xxx_FromOp(ctx context.Context, op *xxx_ChainSetClientAttributesOperation) {
	if o == nil {
		return
	}
	o.ReturnAuthenticator = op.ReturnAuthenticator
	o.OutVersion = op.OutVersion
	o.Out = op.Out
	o.Return = op.Return
}
func (o *ChainSetClientAttributesResponse) MarshalNDR(ctx context.Context, w ndr.Writer) error {
	return o.xxx_ToOp(ctx, nil).MarshalNDRResponse(ctx, w)
}
func (o *ChainSetClientAttributesResponse) UnmarshalNDR(ctx context.Context, r ndr.Reader) error {
	_o := &xxx_ChainSetClientAttributesOperation{}
	if err := _o.UnmarshalNDRResponse(ctx, r); err != nil {
		return err
	}
	o.xxx_FromOp(ctx, _o)
	return nil
}
